,
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return LeInit( hwnd, (LEARGS* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            ContextHelp( pInfo->pArgs->pdwHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return LeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            LeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
LeAdd(
    IN LEINFO* pInfo )

    /* Add button click handler.  'PInfo' is the dialog context.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEb );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    if (pInfo->pArgs->dwfFlags & LEDFLAG_Unique)
    {
        if (ListBox_IndexFromString( pInfo->hwndLb, psz ) >= 0)
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.apszArgs[ 0 ] = psz;
            MsgDlg( pInfo->hwndDlg, SID_NotUnique, &msgargs );
            Edit_SetSel( pInfo->hwndEb, 0, -1 );
            SetFocus( pInfo->hwndEb );
            Free( psz );
            return;
        }
    }

    ListBox_SetCurSel( pInfo->hwndLb,
        ListBox_AddItem( pInfo->hwndLb, psz, 0 ) );
    Free( psz );
    LeEnableUpAndDownButtons( pInfo );
    EnableWindow( pInfo->hwndPbReplace, FALSE );

    if (!pInfo->fNoDeleteLast || ListBox_GetCount( pInfo->hwndLb ) > 1)
        EnableWindow( pInfo->hwndPbDelete, TRUE );

    SetWindowText( pInfo->hwndEb, TEXT("") );
    SetFocus( pInfo->hwndEb );
}


BOOL
LeCommand(
    IN LEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("LeCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_LE_PB_Add:
            LeAdd( pInfo );
            return TRUE;

        case CID_LE_PB_Replace:
            LeReplace( pInfo );
            return TRUE;

        case CID_LE_PB_Up:
            LeUp( pInfo );
            return TRUE;

        case CID_LE_PB_Down:
            LeDown( pInfo );
            return TRUE;

        case CID_LE_PB_Delete:
            LeDelete( pInfo );
            return TRUE;

        case CID_LE_EB_Item:
        {
            if (wNotification == EN_SETFOCUS || wNotification == EN_UPDATE)
            {
                TCHAR* psz = GetText( pInfo->hwndEb );

                if (psz && lstrlen( psz ) > 0 && !IsAllWhite( psz ))
                {
                    EnableWindow( pInfo->hwndPbAdd, TRUE );
                    EnableWindow( pInfo->hwndPbReplace, TRUE );
                    Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbAdd );
                }
                else
                {
                    EnableWindow( pInfo->hwndPbAdd, FALSE );
                    EnableWindow( pInfo->hwndPbReplace, FALSE );
                    Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
                }

                Free0( psz );
            }
            return TRUE;
        }

        case CID_LE_LB_List:
        {
            if (wNotification == LBN_SELCHANGE)
            {
                LeEnableUpAndDownButtons( pInfo );
                if (ListBox_GetCurSel( pInfo->hwndLb ) >= 0)
                    LeItemTextFromListSelection( pInfo );
            }
            return TRUE;
        }

        case CID_LE_CB_Promote:
        {
            if (wNotification == BN_SETFOCUS)
                Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
            return TRUE;
        }

        case IDOK:
            EndDialog( pInfo->hwndDlg, LeSaveSettings( pInfo ) );
            return TRUE;


        case IDCANCEL:
        {
            DTLLIST* pList;
            DTLNODE* pNode;

            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
LeDelete(
    IN LEINFO* pInfo )

    /* Delete button click handler.  'PInfo' is the dialog context.
    */
{
    INT i;
    INT c;

    i = ListBox_GetCurSel( pInfo->hwndLb );
    if (pInfo->pArgs->pDestroyId)
    {
        INT_PTR lId = ListBox_GetItemData( pInfo->hwndLb, i );
        if (lId != 0)
        {
            DTLNODE* pNode;

            pNode = DtlCreateNode( NULL, (DWORD)lId );
            if (!pNode)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_DisplayData,
                    ERROR_NOT_ENOUGH_MEMORY, NULL );
                EndDialog( pInfo->hwndDlg, FALSE );
                return;
            }

            DtlAddNodeFirst( pInfo->pListDeletes, pNode );
        }
    }
    ListBox_DeleteString( pInfo->hwndLb, i );
    c = ListBox_GetCount( pInfo->hwndLb );

    if (c == 0)
    {
        EnableWindow( pInfo->hwndPbReplace, FALSE );
        EnableWindow( pInfo->hwndPbDelete, FALSE );
        SetFocus( pInfo->hwndEb );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
    else
    {
        if (c == 1 && pInfo->fNoDeleteLast)
            EnableWindow( pInfo->hwndPbDelete, FALSE );

        if (i >= c)
            i = c - 1;

        ListBox_SetCurSel( pInfo->hwndLb, i );
    }

    LeEnableUpAndDownButtons( pInfo );

    if (IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndEb );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
}


VOID
LeDown(
    IN LEINFO* pInfo )

    /* Down button click handler.  'PInfo' is the dialog context.
    */
{
    TCHAR* psz;
    INT    i;
    INT_PTR lId;

    ASSERT(!pInfo->fSorted);

    i = ListBox_GetCurSel( pInfo->hwndLb );
    psz = ListBox_GetPsz( pInfo->hwndLb, i );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    lId = ListBox_GetItemData( pInfo->hwndLb, i );
    ListBox_InsertString( pInfo->hwndLb, i + 2, psz );
    ListBox_SetItemData( pInfo->hwndLb, i + 2, lId );
    Free( psz );
    ListBox_DeleteString( pInfo->hwndLb, i );
    ListBox_SetCurSel( pInfo->hwndLb, i + 1 );

    if (i == ListBox_GetCount( pInfo->hwndLb ))
    {
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbUp );
        SetFocus( pInfo->hwndPbUp );
    }

    LeEnableUpAndDownButtons( pInfo );
}


VOID
LeEnableUpAndDownButtons(
    IN LEINFO* pInfo )

    /* Determine if the Up and Down operations make sense and enable/disable
    ** the buttons as appropriate.  'PInfo' is the dialog context.
    */
{
    INT i;
    INT c;

    if (pInfo->fSorted)
        return;

    i = ListBox_GetCurSel( pInfo->hwndLb );
    c = ListBox_GetCount( pInfo->hwndLb );

    EnableWindow( pInfo->hwndPbDown, (i < c - 1 ) );
    EnableWindow( pInfo->hwndPbUp, (i > 0) );
}


VOID
LeExitNoMemory(
    IN LEINFO* pInfo )

    /* End the dialog reporting a memory.  'PInfo' is the dialog context.
    */
{
    ErrorDlg( pInfo->hwndDlg,
        SID_OP_DisplayData, ERROR_NOT_ENOUGH_MEMORY, NULL );
    EndDialog( pInfo->hwndDlg, FALSE );
}


BOOL
LeInit(
    IN HWND    hwndDlg,
    IN LEARGS* pArgs )

    /* Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    ** dialog window.  'PArgs' is caller's arguments as passed to the stub
    ** API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD    dwErr;
    LEINFO*  pInfo;
    DTLNODE* pNode;
    INT      c;

    TRACE("LeInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    /* Set up convenient shortcuts.
    */
    if (pArgs->dwfFlags & LEDFLAG_Sorted)
        pInfo->fSorted = TRUE;
    if (pArgs->dwfFlags & LEDFLAG_NoDeleteLastItem)
        pInfo->fNoDeleteLast = TRUE;

    pInfo->hwndStItem = GetDlgItem( hwndDlg, CID_LE_ST_Item );
    ASSERT(pInfo->hwndStItem);
    pInfo->hwndStList = GetDlgItem( hwndDlg, CID_LE_ST_List );
    ASSERT(pInfo->hwndStList);
    pInfo->hwndPbAdd = GetDlgItem( hwndDlg, CID_LE_PB_Add );
    ASSERT(pInfo->hwndPbAdd);
    pInfo->hwndPbReplace = GetDlgItem( hwndDlg, CID_LE_PB_Replace );
    ASSERT(pInfo->hwndPbReplace);
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_LE_PB_Delete );
    ASSERT(pInfo->hwndPbDelete);
    pInfo->hwndPbOk = GetDlgItem( hwndDlg, IDOK );
    ASSERT(pInfo->hwndPbOk);
    pInfo->hwndEb = GetDlgItem( hwndDlg, CID_LE_EB_Item );
    ASSERT(pInfo->hwndEb);
    pInfo->hwndLb = GetDlgItem( hwndDlg, CID_LE_LB_List );
    ASSERT(pInfo->hwndLb);

    if (pArgs->pDestroyId)
    {
        /* Create the empty list of deletions.
        */
        pInfo->pListDeletes = DtlCreateList( 0L );
        if (!pInfo->pListDeletes)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    if (!pInfo->fSorted)
    {
        pInfo->hwndPbUp = GetDlgItem( hwndDlg, CID_LE_PB_Up );
        ASSERT(pInfo->hwndPbUp);
        pInfo->hwndPbDown = GetDlgItem( hwndDlg, CID_LE_PB_Down );
        ASSERT(pInfo->hwndPbDown);

        /* Draw the graphical up and down arrow indicators.
        */
        pInfo->hbmUp = Button_CreateBitmap(
            pInfo->hwndPbUp, BMS_UpArrowOnRight );
        if (pInfo->hbmUp)
        {
            SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, 0,
                (LPARAM )pInfo->hbmUp );
        }

        pInfo->hbmDown = Button_CreateBitmap(
            pInfo->hwndPbDown, BMS_DownArrowOnRight );
        if (pInfo->hbmDown)
        {
            SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, 0,
                (LPARAM )pInfo->hbmDown );
        }
    }

    if (pArgs->pfCheck)
    {
        pInfo->hwndCb = GetDlgItem( hwndDlg, CID_LE_CB_Promote );
        ASSERT(pInfo->hwndCb);
        SetWindowText( pInfo->hwndCb, pArgs->pszCheckLabel );
        Button_SetCheck( pInfo->hwndCb, *pArgs->pfCheck );
    }

    Edit_LimitText( pInfo->hwndEb, pArgs->dwMaxItemLen );

    /* Set caller-defined dialog title and labels.
    */
    SetWindowText( pInfo->hwndDlg, pArgs->pszTitle );
    SetWindowText( pInfo->hwndStItem, pArgs->pszItemLabel );
    SetWindowText( pInfo->hwndStList, pArgs->pszListLabel );

    /* Fill the listbox.
    */
    for (pNode = DtlGetFirstNode( pArgs->pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz = (TCHAR* )DtlGetData( pNode );
        ASSERT(psz);

        ListBox_AddItem( pInfo->hwndLb, psz, (VOID* )UlongToPtr(DtlGetNodeId( pNode ) ));
    }

    c = ListBox_GetCount( pInfo->hwndLb );
    if (c > 0)
    {
        /* Select item selected by caller.
        */
        ListBox_SetCurSelNotify( pInfo->hwndLb, pArgs->iSelInitial );
        LeEnableUpAndDownButtons( pInfo );

        if (c == 1 && pInfo->fNoDeleteLast)
            EnableWindow( pInfo->hwndPbDelete, FALSE );
    }
    else
    {
        /* Empty list.
        */
        if (!pInfo->fSorted)
        {
            EnableWindow( pInfo->hwndPbUp, FALSE );
            EnableWindow( pInfo->hwndPbDown, FALSE );
        }
        EnableWindow( pInfo->hwndPbDelete, FALSE );
    }


    /* Set default edit box contents, if any.
    */
    if (pArgs->pszDefaultItem)
    {
        SetWindowText( pInfo->hwndEb, pArgs->pszDefaultItem );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
    else
    {
        EnableWindow( pInfo->hwndPbAdd, FALSE );
        EnableWindow( pInfo->hwndPbReplace, FALSE );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
LeItemTextFromListSelection(
    IN LEINFO* pInfo )

    /* Copies the currently selected item in the list to the edit box.
    ** 'PInfo' is the dialog context.
    */
{
    TCHAR* psz;
    INT    iSel;

    iSel = ListBox_GetCurSel( pInfo->hwndLb );
    if (iSel >= 0)
    {
        psz = ListBox_GetPsz( pInfo->hwndLb, iSel );
        if (psz)
        {
            SetWindowText( pInfo->hwndEb, psz );
            Free( psz );
            return;
        }
    }

    SetWindowText( pInfo->hwndEb, TEXT("") );
}


VOID
LeReplace(
    IN LEINFO* pInfo )

    /* Replace button click handler.  'PInfo' is the dialog context.
    */
{
    TCHAR* psz;
    INT    i;
    INT_PTR lId;

    psz = GetText( pInfo->hwndEb );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    if (pInfo->pArgs->dwfFlags & LEDFLAG_Unique)
    {
        if (ListBox_IndexFromString( pInfo->hwndLb, psz ) >= 0)
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.apszArgs[ 0 ] = psz;
            MsgDlg( pInfo->hwndDlg, SID_NotUnique, &msgargs );
            Edit_SetSel( pInfo->hwndEb, 0, -1 );
            SetFocus( pInfo->hwndEb );
            Free( psz );
            return;
        }
    }

    i = ListBox_GetCurSel( pInfo->hwndLb );
    lId = ListBox_GetItemData( pInfo->hwndLb, i );
    ListBox_DeleteString( pInfo->hwndLb, i );

    if (pInfo->fSorted)
    {
        i = ListBox_AddItem( pInfo->hwndLb, psz, (VOID* )lId );
    }
    else
    {
        ListBox_InsertString( pInfo->hwndLb, i, psz );
        ListBox_SetItemData( pInfo->hwndLb, i, lId );
    }

    Free( psz );
    ListBox_SetCurSel( pInfo->hwndLb, i );
    SetFocus( pInfo->hwndEb );
    SetWindowText( pInfo->hwndEb, TEXT("") );
}


BOOL
LeSaveSettings(
    IN LEINFO* pInfo )

    /* Saves dialog settings in the stub API caller's list.  'PInfo' is the
    ** dialog context.
    **
    ** Returns true if successful, false if does not validate.
    */
{
    DWORD    dwErr;
    DTLNODE* pNode;
    DTLLIST* pList;
    DTLLIST* pListNew;
    TCHAR*   psz;
    INT_PTR  lId;
    INT      c;
    INT      i;

    /* Make new list from list box contents.
    */
    do
    {
        pListNew = DtlCreateList( 0L );
        if (!pListNew)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = 0;
        c = ListBox_GetCount( pInfo->hwndLb );

        for (i = 0; i < c; ++i)
        {
            psz = ListBox_GetPsz( pInfo->hwndLb, i );
            if (!psz)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            lId = ListBox_GetItemData( pInfo->hwndLb, i );
            ASSERT(lId>=0);

            pNode = DtlCreateNode( psz, (DWORD)lId );
            if (!pNode)
            {
                Free( psz );
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DtlAddNodeLast( pListNew, pNode );
        }
    }
    while (FALSE);

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_DisplayData, dwErr, NULL );
        DtlDestroyList( pListNew, DestroyPszNode );
        return FALSE;
    }

    /* Free all data in the old list.
    */
    while (pNode = DtlGetFirstNode( pInfo->pArgs->pList ))
    {
        Free( (TCHAR* )DtlGetData( pNode ) );
        DtlDeleteNode( pInfo->pArgs->pList, pNode );
    }

    /* Free the node-IDs in the list of deletions.
    */
    if (pInfo->pListDeletes)
    {
        while (pNode = DtlGetFirstNode( pInfo->pListDeletes ))
        {
            pInfo->pArgs->pDestroyId( (DTLNODE* )UlongToPtr(DtlGetNodeId( pNode ) ));
            DtlDeleteNode( pInfo->pListDeletes, pNode );
        }
    }

    /* Move the new list onto caller's list.
    */
    while (pNode = DtlGetFirstNode( pListNew ))
    {
        DtlRemoveNode( pListNew, pNode );
        DtlAddNodeLast( pInfo->pArgs->pList, pNode );
    }
    DtlDestroyList( pListNew, DestroyPszNode );

    /* Tell caller what the checkbox setting is.
    */
    if (pInfo->pArgs->pfCheck)
        *pInfo->pArgs->pfCheck = Button_GetCheck( pInfo->hwndCb );

    return TRUE;
}


VOID
LeTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("LeTerm");

    if (pInfo)
    {
        if (pInfo->hbmUp)
            DeleteObject( pInfo->hbmUp );
        if (pInfo->hbmDown)
            DeleteObject( pInfo->hbmDown );

        DtlDestroyList( pInfo->pListDeletes, NULL );
        Free( pInfo );
    }
}


VOID
LeUp(
    IN LEINFO* pInfo )

    /* Up button click handler.  'PInfo' is the dialog context.
    */
{
    TCHAR* psz;
    INT    i;
    LONG_PTR lId;

    ASSERT(!pInfo->fSorted);

    i = ListBox_GetCurSel( pInfo->hwndLb );
    psz = ListBox_GetPsz( pInfo->hwndLb, i );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    ListBox_InsertString( pInfo->hwndLb, i - 1, psz );
    Free( psz );
    lId = ListBox_GetItemData( pInfo->hwndLb, i + 1 );
    ListBox_DeleteString( pInfo->hwndLb, i + 1 );
    ListBox_SetItemData( pInfo->hwndLb, i - 1, lId );
    ListBox_SetCurSel( pInfo->hwndLb, i - 1 );

    if (i == 1)
    {
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbDown );
        SetFocus( pInfo->hwndPbDown );
    }

    LeEnableUpAndDownButtons( pInfo );
}


/*----------------------------------------------------------------------------
** String Editor dialog entry point
**----------------------------------------------------------------------------
*/

BOOL
StringEditorDlg(
    IN     HWND    hwndOwner,
    IN     TCHAR*  pszIn,
    IN     DWORD   dwSidTitle,
    IN     DWORD   dwSidLabel,
    IN     DWORD   cbMax,
    IN     DWORD   dwHelpId,
    IN OUT TCHAR** ppszOut )

    /* Pops-up the String Editor dialog.  'PszIn' is the initial setting of
    ** the edit box or NULL for blank.  'DwSidTitle' and 'dwSidLabel' are the
    ** string resource IDs of the dialog title and edit box label.  'CbMax' is
    ** the maximum length of the to allow or 0 for no limit.  'DwHelpId' is
    ** the HID_* constant to associate with the label and edit field or -1 if
    ** none.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.  If true, '*ppszNumber' is a heap block
    ** with the edited result.  It is caller's responsibility to Free the
    ** returned block.
    */
{
    int    nStatus;
    ZEARGS args;

    TRACE("StringEditorDlg");

    args.pszIn = pszIn;
    args.dwSidTitle = dwSidTitle;
    args.dwSidLabel = dwSidLabel;
    args.cbMax = cbMax;
    args.dwHelpId = dwHelpId;
    args.ppszOut = ppszOut;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_ZE_StringEditor ),
            hwndOwner,
            ZeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


/*----------------------------------------------------------------------------
** String Editor dialog routines
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
ZeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Edit Phone Number dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
FastRight:right    */
{
#if 0
    TRACE4("ZeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return ZeInit( hwnd, (ZEARGS* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ZEINFO* pInfo;

            pInfo = (ZEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            if (pInfo && pInfo->pArgs->dwHelpId != (DWORD )-1)
            {
                DWORD adwZeHelp[ (2 + 1) * 2 ];

                ZeroMemory( adwZeHelp, sizeof(adwZeHelp) );
                adwZeHelp[ 0 ] = CID_ZE_ST_String;
                adwZeHelp[ 2 ] = CID_ZE_EB_String;
                adwZeHelp[ 1 ] = adwZeHelp[ 3 ] = pInfo->pArgs->dwHelpId;

                ContextHelp( adwZeHelp, hwnd, unMsg, wparam, lparam );
                break;
            }
        }

        case WM_COMMAND:
        {
            ZEINFO* pInfo = (ZEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return ZeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            ZeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
ZeCommand(
    IN ZEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("ZeCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case IDOK:
        {
            TRACE("OK pressed");
            *pInfo->pArgs->ppszOut = GetText( pInfo->hwndEb );
            EndDialog( pInfo->hwndDlg, (*pInfo->pArgs->ppszOut != NULL) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ZeInit(
    IN HWND    hwndDlg,
    IN ZEARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    ** 'PArgs' is caller's arguments as passed to the stub API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    TCHAR*  psz;
    ZEINFO* pInfo;

    TRACE("ZeInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndEb = GetDlgItem( hwndDlg, CID_ZE_EB_String );
    ASSERT(pInfo->hwndEb);

    if (pArgs->cbMax > 0)
        Edit_LimitText( pInfo->hwndEb, pArgs->cbMax );

    psz = PszFromId( g_hinstDll, pArgs->dwSidTitle );
    if (psz)
    {
        SetWindowText( hwndDlg, psz );
        Free( psz );
    }

    psz = PszFromId( g_hinstDll, pArgs->dwSidLabel );
    if (psz)
    {
        HWND hwndSt = GetDlgItem( hwndDlg, CID_ZE_ST_String );
        ASSERT(hwndSt);
        SetWindowText( hwndSt, psz );
        Free( psz );
    }

    if (pArgs->pszIn)
    {
        SetWindowText( pInfo->hwndEb, pArgs->pszIn );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
ZeTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    ZEINFO* pInfo = (ZEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("ZeTerm");

    if (pInfo)
        Free( pInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\entryps.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** entryps.c
** Remote Access Common Dialog APIs
** Phonebook Entry property sheet
**
** 06/20/95 Steve Cobb
*/

#include "rasdlgp.h"  // Our private header
#define INCL_ENCRYPT
#include <ppputil.h>  // For IsEncryptionPermitted()
#include "entry.h"    // Shared with add entry wizard

#define RASMERGE

/* Page definitions.
*/
#define PE_BsPage    0
#define PE_SvPage    1
#define PE_ScPage    2
#define PE_SePage    3
#define PE_XsPage    4
#define PE_RdPage    5
#define PE_PageCount 6

#define PE_PageCountNoRtr 5

/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwBsHelp[] =
{
    CID_BS_ST_EntryName,           HID_BS_EB_EntryName,
    CID_BS_EB_EntryName,           HID_BS_EB_EntryName,
    CID_BS_ST_Description,         HID_BS_EB_Description,
    CID_BS_EB_Description,         HID_BS_EB_Description,
    CID_BS_ST_CountryCode,         HID_BS_LB_CountryCode,
    CID_BS_LB_CountryCode,         HID_BS_LB_CountryCode,
    CID_BS_ST_AreaCode,            HID_BS_CL_AreaCode,
    CID_BS_CL_AreaCode,            HID_BS_CL_AreaCode,
    CID_BS_ST_PhoneNumber,         HID_BS_EB_PhoneNumber,
    CID_BS_EB_PhoneNumber,         HID_BS_EB_PhoneNumber,
    CID_BS_PB_Alternates,          HID_BS_PB_Alternates,
    CID_BS_ST_Device,              HID_BS_LB_Device,
    CID_BS_LB_Device,              HID_BS_LB_Device,
    CID_BS_PB_Configure,           HID_BS_PB_Configure,
    CID_BS_CB_UseAreaCountryCodes, HID_BS_CB_UseAreaCountryCodes,
    CID_BS_CB_UseOtherPort,        HID_BS_CB_UseOtherPort,
    0, 0
};

static DWORD g_adwSvHelp[] =
{
    CID_SV_ST_ServerType,    HID_SV_LB_ServerType,
    CID_SV_LB_ServerType,    HID_SV_LB_ServerType,
    CID_SV_GB_Protocols,     HID_SV_GB_Protocols,
    CID_SV_CB_TcpIp,         HID_SV_CB_TcpIp,
    CID_SV_CB_Ipx,           HID_SV_CB_Ipx,
    CID_SV_CB_Netbeui,       HID_SV_CB_Netbeui,
    CID_SV_PB_TcpIpSettings, HID_SV_PB_TcpIpSettings,
    CID_SV_CB_SwCompression, HID_SV_CB_SwCompression,
    CID_SV_CB_LcpExtensions, HID_SV_CB_LcpExtensions,
    0, 0
};

static DWORD g_adwScHelp[] =
{
    CID_SC_RB_None,     HID_SC_RB_None,
    CID_SC_RB_Terminal, HID_SC_RB_Terminal,
    CID_SC_RB_Script,   HID_SC_RB_Script,
    CID_SC_LB_Script,   HID_SC_LB_Script,
    CID_SC_PB_Edit,     HID_SC_PB_Edit,
    CID_SC_PB_Refresh,  HID_SC_PB_Refresh,
    CID_SC_PB_Before,   HID_SC_PB_BeforeDial,
    0, 0
};

static DWORD g_adwSeHelp[] =
{
    CID_SE_GB_AuthEncryption,        HID_SE_GB_AuthEncryption,
    CID_SE_RB_AnyAuth,               HID_SE_RB_AnyAuth,
    CID_SE_RB_EncryptedAuth,         HID_SE_RB_EncryptedAuth,
    CID_SE_RB_MsEncryptedAuth,       HID_SE_RB_MsEncryptedAuth,
    CID_SE_CB_UseLogonCredentials,   HID_SE_CB_UseLogonCredentials,
    CID_SE_CB_RequireDataEncryption, HID_SE_CB_RequireDataEncryption,
    CID_SE_CB_RequireStrongDataEncryption, HID_SE_CB_RequireStrongDataEncryption,
    CID_SE_PB_UnsavePw,              HID_SE_PB_UnsavePw,
    CID_SE_CB_AuthenticateServer,    HID_SE_CB_AuthenticateServer,
    0, 0
};

static DWORD g_adwXsHelp[] =
{
    CID_XS_ST_Network,    HID_XS_LB_Network,
    CID_XS_LB_Network,    HID_XS_LB_Network,
    CID_XS_ST_Address,    HID_XS_EB_Address,
    CID_XS_EB_Address,    HID_XS_EB_Address,
    CID_XS_GB_Optional,   HID_XS_GB_Optional,
    CID_XS_ST_UserData,   HID_XS_EB_UserData,
    CID_XS_EB_UserData,   HID_XS_EB_UserData,
    CID_XS_ST_Facilities, HID_XS_EB_Facilities,
    CID_XS_EB_Facilities, HID_XS_EB_Facilities,
    0, 0
};

static DWORD g_adwBdHelp[] =
{
    CID_BD_RB_None,     HID_BD_RB_None,
    CID_BD_RB_Terminal, HID_BD_RB_Terminal,
    CID_BD_RB_Script,   HID_BD_RB_Script,
    CID_BD_LB_Script,   HID_BD_LB_Script,
    CID_BD_PB_Edit,     HID_BD_PB_Edit,
    CID_BD_PB_Refresh,  HID_BD_PB_Refresh,
    0, 0
};

static DWORD g_adwRdHelp[] =
{
    CID_RD_RB_Persistent,    HID_RD_RB_Persistent,
    CID_RD_RB_DemandDial,    HID_RD_RB_DemandDial,
    CID_RD_ST_Attempts,      HID_RD_EB_Attempts,
    CID_RD_EB_Attempts,      HID_RD_EB_Attempts,
    CID_RD_ST_Seconds,       HID_RD_EB_Seconds,
    CID_RD_EB_Seconds,       HID_RD_EB_Seconds,
    CID_RD_ST_Idle,          HID_RD_EB_Idle,
    CID_RD_EB_Idle,          HID_RD_EB_Idle,
    CID_RD_PB_Callback,      HID_RD_PB_Callback,
    CID_RD_PB_MultipleLines, HID_RD_PB_MultipleLines,
    0, 0
};

static DWORD g_adwCrHelp[] =
{
    CID_CR_RB_No,      HID_CR_RB_No,
    CID_CR_RB_Yes,     HID_CR_RB_Yes,
    CID_CR_ST_Numbers, HID_CR_LV_Numbers,
    CID_CR_LV_Numbers, HID_CR_LV_Numbers,
    CID_CR_PB_Edit,    HID_CR_PB_Edit,
    CID_CR_PB_Delete,  HID_CR_PB_Delete,
    0, 0
};


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* Phonebook Entry property sheet context block.  All property pages refer to
** the single context block is associated with the sheet.
*/
#define PEINFO struct tagPEINFO
PEINFO
{
    /* Common input arguments.
    */
    EINFO* pArgs;

    /* Property sheet dialog and property page handles.  'hwndFirstPage' is
    ** the handle of the first property page initialized.  This is the page
    ** that allocates and frees the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndBs;
    HWND hwndSv;
    HWND hwndSc;
    HWND hwndSe;
    HWND hwndXs;
    HWND hwndRd;

    /* Basic page.
    */
    HWND  hwndEbEntryName;
    HWND  hwndEbDescription;
    HWND  hwndStCountryCode;
    HWND  hwndLbCountryCodes;
    HWND  hwndStAreaCode;
    HWND  hwndLbAreaCodes;
    HWND  hwndStPhoneNumber;
    HWND  hwndEbPhoneNumber;
    HWND  hwndPbAlternate;
    HWND  hwndStDevice;
    HWND  hwndLbDevices;
    HWND  hwndPbConfigure;
    HWND  hwndCbUseAreaCode;
    HWND  hwndCbUseOtherPort;
    POINT xyStPhoneNumber;
    POINT xyEbPhoneNumber;
    POINT xyPbAlternate;
    POINT xyStDevice;
    POINT xyLbDevice;
    POINT xyPbConfigure;
    POINT xyCbUseAreaCode;
    POINT xyCbUseOtherPort;
    int   dyAreaCodeAdjust;

    /* Server page.
    */
    HWND hwndStServerTypes;
    HWND hwndLbServerTypes;
    HWND hwndCbIp;
    HWND hwndPbIp;
    HWND hwndCbIpx;
    HWND hwndCbNbf;
    HWND hwndCbSwCompression;
    HWND hwndCbLcpExtensions;

    DWORD dwfInstalledProtocols;
    DWORD dwBaseProtocolDefault;
    BOOL  fPppIp;
    BOOL  fPppIpx;
    BOOL  fPppNbf;
    BOOL  fPppIpDefault;
    BOOL  fPppIpxDefault;
    BOOL  fPppNbfDefault;
    BOOL  fSwCompression;
    BOOL  fLcpExtensions;

    /* Script page.
    */
    HWND hwndRbNone;
    HWND hwndRbTerminal;
    HWND hwndRbScript;
    HWND hwndLbScript;
    HWND hwndPbEdit;
    HWND hwndPbRefresh;

    /* Security page.
    */
    HWND hwndRbAnyAuth;
    HWND hwndRbEncryptedAuth;
    HWND hwndRbMsEncryptedAuth;
    HWND hwndCbDataEncryption;
    HWND hwndCbStrongDataEncryption;
    HWND hwndCbUseLogon;
    HWND hwndCbAuthenticateServer;
    HWND hwndCbSecureFiles;
    HWND hwndPbUnsavePw;

    BOOL fEncryptionPermitted;
    BOOL fDataEncryption;
    BOOL fStrongDataEncryption;
    BOOL fUseLogon;

    /* X.25 page.
    */
    HWND hwndLbX25Pads;
    HWND hwndEbX25Address;
    HWND hwndEbX25UserData;
    HWND hwndEbX25Facilities;

    /* (Router) Dialing page.
    */
    HWND hwndRbPersistent;
    HWND hwndRbDemand;
    HWND hwndStAttempts;
    HWND hwndEbAttempts;
    HWND hwndStSeconds;
    HWND hwndEbSeconds;
    HWND hwndStIdle;
    HWND hwndEbIdle;

    /* List of PADs initialized by XsFillPadsList, if necessary, and freed by
    ** PeTerm.
    */
    DTLLIST* pListPads;

    /* The phone number stash for single link mode.  This allows user to
    ** change the port to another link without losing the phone number he
    ** typed.
    */
    DTLLIST* pListPhoneNumbers;
    BOOL     fPromoteHuntNumbers;

    /* The current device list selection index.  Used to back out change from
    ** multi-line mode to single line mode if user is just screwing with
    ** device list box.  Initialized by PeInit.
    */
    INT iLbDevices;

    /* True if Multiple Lines is selected, false otherwise.  Does not
    ** necessarily mean there is currently more than one PBLINK.  Initialized
    ** by PeInit.
    */
    BOOL fMultiLinkMode;

    /* The current server type list selection index.  Used to back out change
    ** if user changes to non-PPP with Multiple Lines selected.  Initialized
    ** by PeInit.
    */
    INT iLbServerTypes;

    /* The address of the first link and the associated PBPORT, maintained for
    ** convenience.  Initialized by PeInit.
    */
    PBLINK* pLink;
    PBPORT* pPort;

    /* Our per-entry version of the "any port" flag stored per-link in the
    ** phonebook.  Initialized by BsInit.
    */
    BOOL fOtherPortOk;
};


/* Before Dial dialog context block.
*/
#define BDINFO struct tagBDINFO
BDINFO
{
    /* Caller's argument to the stub API.
    */
    EINFO* pArgs;

    /* Dialog and control handles.
    */
    HWND hwndDlg;
    HWND hwndRbNone;
    HWND hwndRbTerminal;
    HWND hwndRbScript;
    HWND hwndLbScript;
    HWND hwndPbEdit;
    HWND hwndPbRefresh;
};

/* (Router) Callback context block.
*/
#define CRINFO struct tagCRINFO
CRINFO
{
    /* Caller's argument to the stub API.
    */
    EINFO* pArgs;

    /* Dialog and control handles.
    */
    HWND hwndDlg;
    HWND hwndRbNo;
    HWND hwndRbYes;
    HWND hwndLvNumbers;
    HWND hwndPbEdit;
    HWND hwndPbDelete;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
BdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
BdCommand(
    IN BDINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
BdInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs );

VOID
BdSave(
    IN BDINFO* pInfo );

VOID
BdTerm(
    IN HWND hwndDlg );

BOOL
BeforeDialDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo );

INT_PTR CALLBACK
BsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
BsCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

VOID
BsConfigure(
    IN PEINFO* pInfo );

VOID
BsFillDeviceList(
    IN PEINFO* pInfo );

BOOL
BsInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs );

VOID
BsLbDevicesSelChange(
    IN PEINFO* pInfo );

VOID
BsPhoneNumberToStash(
    IN PEINFO* pInfo );

VOID
BsUpdateAreaAndCountryCode(
    IN PEINFO* pInfo );

INT_PTR CALLBACK
CrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CrCommand(
    IN CRINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
CrInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs );

VOID
CrSave(
    IN CRINFO* pInfo );

VOID
CrTerm(
    IN HWND hwndDlg );

VOID
CrUpdateLvAndPbState(
    IN CRINFO* pInfo );

INT_PTR CALLBACK
RdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RdCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
RdInit(
    IN HWND hwndPage );

BOOL
PeApply(
    IN HWND hwndPage );

VOID
PeCancel(
    IN HWND hwndPage );

PEINFO*
PeContext(
    IN HWND hwndPage );

DWORD
PeCountEnabledLinks(
    IN PEINFO* pInfo );

VOID
PeExit(
    IN PEINFO* pInfo,
    IN DWORD   dwError );

VOID
PeExitInit(
    IN HWND hwndDlg );

PEINFO*
PeInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs );

VOID
PeTerm(
    IN HWND hwndPage );

VOID
PeUpdateShortcuts(
    IN PEINFO* pInfo );

BOOL
RouterCallbackDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo );

BOOL
ScCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
ScDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ScInit(
    IN HWND hwndPage );

BOOL
SeCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SeInit(
    IN HWND hwndPage );

VOID
SvCbIpClicked(
    IN PEINFO* pInfo );

VOID
SvCbIpxClicked(
    IN PEINFO* pInfo );

VOID
SvCbNbfClicked(
    IN PEINFO* pInfo );

BOOL
SvCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SvDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SvInit(
    IN HWND hwndPage );

VOID
SvLbServerTypesSelChange(
    IN PEINFO* pInfo );

VOID
SvProtocolNotInstalledPopup(
    IN PEINFO* pInfo,
    IN DWORD   dwSid );

VOID
SvTcpipSettings(
    IN PEINFO* pInfo );

INT_PTR CALLBACK
XsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
XsFillPadsList(
    IN PEINFO* pInfo,
    IN BOOL    fLocalPad );

BOOL
XsInit(
    IN HWND hwndPage );


/*----------------------------------------------------------------------------
** Callback utility prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
CbutilDelete(
    IN HWND  hwndDlg,
    IN HWND  hwndLvNumbers );

VOID
CbutilEdit(
    IN HWND hwndDlg,
    IN HWND hwndLvNumbers );

VOID
CbutilFillLvNumbers(
    IN HWND     hwndDlg,
    IN HWND     hwndLvNumbers,
    IN DTLLIST* pListCallback,
    IN BOOL     fRouter );

LVXDRAWINFO*
CbutilLvNumbersCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
CbutilSaveLv(
    IN  HWND     hwndLvNumbers,
    OUT DTLLIST* pListCallback );


/*----------------------------------------------------------------------------
** Phonebook Entry property sheet entry point
**----------------------------------------------------------------------------
*/

VOID
PePropertySheet(
    IN OUT EINFO* pEinfo )

    /* Runs the Phonebook entry property sheet.  'PEinfo' is the API caller's
    ** arguments.
    */
{
    DWORD           dwErr;
    PROPSHEETHEADER header;
    PROPSHEETPAGE   apage[ PE_PageCount ];
    PROPSHEETPAGE*  ppage;
    TCHAR*          pszTitle;

    TRACE("PePropertySheet");

    if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewEntry)
        pszTitle = PszFromId( g_hinstDll, SID_PeTitleNew );
    else if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry)
        pszTitle = PszFromId( g_hinstDll, SID_PeTitleClone );
    else
        pszTitle = PszFromId( g_hinstDll, SID_PeTitleEdit );

    ZeroMemory( &header, sizeof(header) );

    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK;
    header.hwndParent = pEinfo->pApiArgs->hwndOwner;
    header.hInstance = g_hinstDll;
    header.pszCaption = (pszTitle) ? pszTitle : L"";
    header.nPages = (pEinfo->fRouter) ? PE_PageCount : PE_PageCountNoRtr;
    header.ppsp = apage;
    header.pfnCallback = UnHelpCallbackFunc;

    ZeroMemory( apage, sizeof(apage) );

    ppage = &apage[ PE_BsPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (pEinfo->fRouter)
            ? MAKEINTRESOURCE( PID_BS_RouterBasicSettings )
            : MAKEINTRESOURCE( PID_BS_BasicSettings );
    ppage->pfnDlgProc = BsDlgProc;
    ppage->lParam = (LPARAM )pEinfo;

    ppage = &apage[ PE_SvPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (pEinfo->fRouter)
            ? MAKEINTRESOURCE( PID_SV_RouterServerSettings )
            : MAKEINTRESOURCE( PID_SV_ServerSettings );
    ppage->pfnDlgProc = SvDlgProc;

    ppage = &apage[ PE_ScPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (pEinfo->fRouter)
            ? MAKEINTRESOURCE( PID_SC_RouterScriptSettings )
            : MAKEINTRESOURCE( PID_SC_ScriptSettings );
    ppage->pfnDlgProc = ScDlgProc;

    ppage = &apage[ PE_SePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (pEinfo->fRouter)
            ? MAKEINTRESOURCE( PID_SE_RouterSecuritySettings )
            : MAKEINTRESOURCE( PID_SE_SecuritySettings );
    ppage->pfnDlgProc = SeDlgProc;

    ppage = &apage[ PE_XsPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_XS_X25Settings );
    ppage->pfnDlgProc = XsDlgProc;

    if (pEinfo->fRouter)
    {
        ppage = &apage[ PE_RdPage ];
        ppage->dwSize = sizeof(PROPSHEETPAGE);
        ppage->hInstance = g_hinstDll;
        ppage->pszTemplate = MAKEINTRESOURCE( PID_RD_Dialing );
        ppage->pfnDlgProc = RdDlgProc;
    }

    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg(  pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN,
            NULL );
    }

    Free0( pszTitle );
}


/*----------------------------------------------------------------------------
** Phonebook Entry property sheet
** Listed alphabetically
**----------------------------------------------------------------------------
*/

BOOL
PeApply(
    IN HWND hwndPage )

    /* Saves the contents of the property sheet.  'HwndPage is the handle of a
    ** property page.  Pops up any errors that occur.
    **
    ** Returns true is page can be dismissed, false otherwise.
    */
{
    DWORD    dwErr;
    PEINFO*  pInfo;
    PBENTRY* pEntry;
    BOOL     fLocalPad;
    INT      iPadSelection;

    TRACE("PeApply");

    pInfo = PeContext( hwndPage );
    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    iPadSelection = 0;
    fLocalPad = IsLocalPad( pEntry );
    if (fLocalPad)
    {
        /* Can't have a dialup-PAD network defined when the selected device is
        ** a PAD card.
        */
        Free0( pEntry->pszX25Network );
        pEntry->pszX25Network = NULL;
    }

    /* First page should always be initialized.
    */
    ASSERT(pInfo->hwndBs);

    Free0( pEntry->pszEntryName );
    pEntry->pszEntryName = GetText( pInfo->hwndEbEntryName );
    Free0( pEntry->pszDescription );
    pEntry->pszDescription = GetText( pInfo->hwndEbDescription );
    Free0( pEntry->pszAreaCode );
    pEntry->pszAreaCode = GetText( pInfo->hwndLbAreaCodes );
    if (!pEntry->pszEntryName || !pEntry->pszAreaCode)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        PeExit( pInfo, dwErr );
        return TRUE;
    }

    /* Save stashed phone number settings in single link.
    */
    if (!pInfo->fMultiLinkMode)
    {
        BsPhoneNumberToStash( pInfo );
        EuPhoneNumberStashToEntry( pInfo->pArgs,
            pInfo->pListPhoneNumbers, pInfo->fPromoteHuntNumbers, FALSE );
    }

    pEntry->fUseCountryAndAreaCode =
        IsDlgButtonChecked( pInfo->hwndBs, CID_BS_CB_UseAreaCountryCodes );

    EuSaveCountryInfo( pInfo->pArgs, pInfo->hwndLbCountryCodes );

    /* Retrieve the current "any port" flag which is displayed per-entry,
    ** though stored per-link.
    **
    ** Most link/port information is saved as they are changed, since these
    ** settings are changed on a sub-dialog.  However, this setting and a few
    ** other consistency adjustments are made in a loop below.
    */
    pInfo->fOtherPortOk =
        IsDlgButtonChecked( pInfo->hwndBs, CID_BS_CB_UseOtherPort );

    /* Server page.
    */
    if (pInfo->hwndSv)
    {
        BOOL fChange = FALSE;
        BOOL fDeselect = FALSE;

        /* Note: pEntry->dwBaseProtocol is saved as changed.
        */

        /* Warn SLIP framing won't work without IP installed.
        */
        if (pEntry->dwBaseProtocol == BP_Slip
            && !(pInfo->dwfInstalledProtocols & NP_Ip))
        {
            MsgDlg( pInfo->hwndSv, SID_SlipWithoutIp, NULL );
        }

#ifdef AMB
        /* Warn RAS framing won't work without NetBEUI installed.
        */
        if (pEntry->dwBaseProtocol == BP_Ras
            && !(pInfo->dwfInstalledProtocols & NP_Nbf))
        {
            MsgDlg( pInfo->hwndSv, SID_RasWithoutNbf, NULL );
        }
#endif

        if (pEntry->dwBaseProtocol == BP_Ppp)
        {
            DWORD dwfExcludedProtocols = pEntry->dwfExcludedProtocols;

            if (pInfo->fPppIp && !pInfo->fPppIpDefault)
            {
                dwfExcludedProtocols &= ~(NP_Ip);
                fChange = TRUE;
            }
            else if (!pInfo->fPppIp && pInfo->fPppIpDefault)
            {
                dwfExcludedProtocols |= NP_Ip;
                fChange = TRUE;
                fDeselect = TRUE;
            }

            if (pInfo->fPppIpx && !pInfo->fPppIpxDefault)
            {
                dwfExcludedProtocols &= ~(NP_Ipx);
                fChange = TRUE;
            }
            else if (!pInfo->fPppIpx && pInfo->fPppIpxDefault)
            {
                dwfExcludedProtocols |= NP_Ipx;
                fChange = TRUE;
                fDeselect = TRUE;
            }

            if (pInfo->fPppNbf && !pInfo->fPppNbfDefault)
            {
                dwfExcludedProtocols &= ~(NP_Nbf);
                fChange = TRUE;
            }
            else if (!pInfo->fPppNbf && pInfo->fPppNbfDefault)
            {
                dwfExcludedProtocols |= NP_Nbf;
                fChange = TRUE;
            }

            /* Warn PPP won't work without a network protocol.
            */
            if ((pInfo->dwfInstalledProtocols & ~(dwfExcludedProtocols)) == 0)
            {
                if (pInfo->dwfInstalledProtocols)
                {
                    MsgDlg( pInfo->hwndSv, SID_PppNeedsProtocol, NULL );
                    PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_SvPage );
                    SetFocus( pInfo->hwndCbIp );
                    return FALSE;
                }
                else
                {
                    MsgDlg( pInfo->hwndSv, SID_PppWithoutProtocol, NULL );
                }
            }


            /* In the case of demand-dial router interfaces,
            ** deselecting a CP removes the corresponding router-manager
            ** and routing-protocols. Warn the user about this.
            */
            if (pInfo->pArgs->fRouter &&
                !(pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_NewEntry) &&
                fDeselect)
            {
                MSGARGS msgargs;

                ZeroMemory( &msgargs, sizeof(msgargs) );

                msgargs.dwFlags = MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION;
                if (MsgDlg( pInfo->hwndSv, SID_RemoveCP, &msgargs ) != IDYES)
                {
                    PropSheet_SetCurSel(pInfo->hwndDlg, NULL, PE_SvPage);
                    SetFocus(pInfo->hwndCbIp);
                    return FALSE;
                }
            }

            pEntry->dwfExcludedProtocols = dwfExcludedProtocols;
        }

        if (pEntry->dwBaseProtocol != pInfo->dwBaseProtocolDefault)
            fChange = TRUE;

        if (fChange)
            pEntry->dwAuthentication = (DWORD )-1;

        pEntry->fSwCompression = pInfo->fSwCompression;
        pEntry->fLcpExtensions = pInfo->fLcpExtensions;
    }

    /* Script page.
    */
    if (pInfo->hwndSc)
    {
        TCHAR* psz;

        if (IsDlgButtonChecked( pInfo->hwndSc, CID_SC_RB_None ))
            pEntry->dwScriptModeAfter = SM_None;
        else if (IsDlgButtonChecked( pInfo->hwndSc, CID_SC_RB_Terminal ))
            pEntry->dwScriptModeAfter = SM_Terminal;
        else
            pEntry->dwScriptModeAfter = SM_Script;

        psz = GetText( pInfo->hwndLbScript );
        Free0( pEntry->pszScriptAfter );
        pEntry->pszScriptAfter = psz;

        /* Silently fix-up "no script specified" error.
        */
        if (pEntry->dwScriptModeAfter == SM_Script && !pEntry->pszScriptAfter)
            pEntry->dwScriptModeAfter = SM_None;
    }

    /* Security page.
    */
    if (pInfo->hwndSe)
    {
        if (Button_GetCheck( pInfo->hwndRbAnyAuth ))
            pEntry->dwAuthRestrictions = AR_AuthAny;
        else if (Button_GetCheck( pInfo->hwndRbEncryptedAuth ))
            pEntry->dwAuthRestrictions = AR_AuthEncrypted;
        else
            pEntry->dwAuthRestrictions = AR_AuthMsEncrypted;

        if (pInfo->fStrongDataEncryption)
            pEntry->dwDataEncryption = DE_Strong;
        else if (pInfo->fDataEncryption)
            pEntry->dwDataEncryption = DE_Weak;
        else
            pEntry->dwDataEncryption = DE_None;

        pEntry->fAutoLogon = pInfo->fUseLogon;
        pEntry->fSecureLocalFiles =
            Button_GetCheck( pInfo->hwndCbSecureFiles );

        if (pInfo->pArgs->fRouter)
        {
            pEntry->fAuthenticateServer =
                Button_GetCheck( pInfo->hwndCbAuthenticateServer );
        }
    }

    /* X.25 page.
    */
    if (pInfo->hwndXs)
    {
        iPadSelection = ComboBox_GetCurSel( pInfo->hwndLbX25Pads );
        Free0( pEntry->pszX25Network );
        if (iPadSelection > 0)
            pEntry->pszX25Network = GetText( pInfo->hwndLbX25Pads );
        else
            pEntry->pszX25Network = NULL;

        Free0( pEntry->pszX25Address );
        pEntry->pszX25Address = GetText( pInfo->hwndEbX25Address );
        Free0( pEntry->pszX25UserData );
        pEntry->pszX25UserData = GetText( pInfo->hwndEbX25UserData );
        Free0( pEntry->pszX25Facilities );
        pEntry->pszX25Facilities = GetText( pInfo->hwndEbX25Facilities );
        if (!pEntry->pszX25Address
            || !pEntry->pszX25UserData
            || !pEntry->pszX25Facilities)
        {
            Free0( pEntry->pszX25Address );
            Free0( pEntry->pszX25UserData );
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
            PeExit( pInfo, dwErr );
            return TRUE;
        }
    }

    /* (Router) Dialing page.
    */
    if (pInfo->hwndRd)
    {
        UINT unValue;
        BOOL f;

        unValue = GetDlgItemInt( pInfo->hwndRd, CID_RD_EB_Attempts, &f, FALSE );
        if (f && unValue <= 999999999)
            pEntry->dwRedialAttempts = unValue;

        unValue = GetDlgItemInt( pInfo->hwndRd, CID_RD_EB_Seconds, &f, FALSE );
        if (f && unValue <= 999999999)
            pEntry->dwRedialSeconds = unValue;

        unValue = GetDlgItemInt( pInfo->hwndRd, CID_RD_EB_Idle, &f, FALSE );
        if (f && unValue <= 999999999)
            pEntry->dwIdleDisconnectSeconds = unValue;

        pEntry->fRedialOnLinkFailure =
            IsDlgButtonChecked( pInfo->hwndRd, CID_RD_RB_Persistent );

        /* Mark the fields as overriding the global user preferences.
        */
        pEntry->dwfOverridePref |=
            (RASOR_RedialAttempts |
             RASOR_RedialSeconds |
             RASOR_IdleDisconnectSeconds |
             RASOR_RedialOnLinkFailure);

        /* Note: Callback mode setting is saved on the CallbackRouter dialog.
        */
    }

    /* Validate the entry name.
    */
    if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
    {
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_BsPage );
        SetFocus( pInfo->hwndEbEntryName );
        Edit_SetSel( pInfo->hwndEbEntryName, 0, -1 );
        return FALSE;
    }

    /* Validate area code.
    */
    if (!EuValidateAreaCode( pInfo->hwndDlg, pInfo->pArgs ))
    {
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_BsPage );
        SetFocus( pInfo->hwndLbAreaCodes );
        ComboBox_SetEditSel( pInfo->hwndLbAreaCodes, 0, -1 );
        return FALSE;
    }

    if ((fLocalPad || iPadSelection != 0)
        && (!pEntry->pszX25Address || IsAllWhite( pEntry->pszX25Address )))
    {
        /* Address field is blank with X.25 dial-up or local PAD chosen.
        */
        MsgDlg( pInfo->hwndDlg, SID_NoX25Address, NULL );
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_XsPage );
        SetFocus( pInfo->hwndEbX25Address );
        Edit_SetSel( pInfo->hwndEbX25Address, 0, -1 );
        return FALSE;
    }

    //!!! Check for non-SLIP on non-modem.

    /* Link chain updates:
    **
    ** 1. Set 'fOtherPortOk' on each link to the setting for the entry.
    **
    ** 2. Make sure proprietary ISDN options are disabled if more than one
    **    link is enabled.  The proprietary ISDN option is only meaningful
    **    when calling a down-level server that needs Digiboard channel
    **    aggragation instead of PPP multi-link.
    */
    {
        DTLNODE* pNode;
        DWORD    cIsdnLinks;

        cIsdnLinks = 0;
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            pLink->fOtherPortOk = pInfo->fOtherPortOk;

            if (pLink->fEnabled && pLink->pbport.pbdevicetype == PBDT_Isdn)
                ++cIsdnLinks;
        }

        if (cIsdnLinks > 1)
        {
            for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT(pLink);

                if (pLink->fEnabled && pLink->fProprietaryIsdn)
                    pLink->fProprietaryIsdn = FALSE;
            }
        }
    }

    /* Inform user that edits to the connected entry won't take affect until
    ** the entry is hung up and re-dialed, per PierreS's insistence.
    */
    if (HrasconnFromEntry( pInfo->pArgs->pFile->pszPath, pEntry->pszEntryName ))
        MsgDlg( pInfo->hwndDlg, SID_EditConnected, NULL );

    /* It's a valid new/changed entry.  Mark the entry for commitment.
    */
    pInfo->pArgs->fCommit = TRUE;
    return TRUE;
}


VOID
PeCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a property page.
    */
{
    TRACE("PeCancel");
}


PEINFO*
PeContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a property page handle.
    */
{
    return (PEINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


DWORD
PeCountEnabledLinks(
    IN PEINFO* pInfo )

    /* Returns the number of enabled links in the entry.
    */
{
    DWORD    c;
    DTLNODE* pNode;

    c = 0;

    for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

        if (pLink->fEnabled)
            ++c;
    }

    TRACE1("PeCountEnabledLinks=%d",c);
    return c;
}


VOID
PeExit(
    IN PEINFO* pInfo,
    IN DWORD   dwError )

    /* Forces an exit from the dialog, reporting 'dwError' to the caller.
    ** 'PInfo' is the dialog context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See PeExitInit.
    */
{
    TRACE("PeExit");

    pInfo->pArgs->pApiArgs->dwError = dwError;
    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
PeExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within PeInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


PEINFO*
PeInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs )

    /* Property sheet level initialization.  'HwndPage' is the handle of the
    ** first page.  'PArgs' is the common entry input argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** property sheet has been cancelled.
    */
{
    DWORD   dwErr;
    DWORD   dwOp;
    PEINFO* pInfo;
    HWND    hwndDlg = GetParent( hwndFirstPage );

    TRACE("PeInit");

    /* Allocate the context information block.  Initialize it enough so that
    ** it can be destroyed properly, and associate the context with the
    ** window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE("Context NOT allocated");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            PeExitInit( hwndDlg );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(PEINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        pInfo->iLbDevices = -1;
        pInfo->iLbServerTypes = -1;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE("Context NOT set");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            pArgs->pApiArgs->dwError = ERROR_UNKNOWN;
            Free( pInfo );
            PeExitInit( hwndDlg );
            return NULL;
        }

        TRACE("Context set");
    }

    /* Position the dialog per API caller's instructions.
    */
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    /* Mess with the title bar gadgets.
    */
    TweakTitleBar( hwndDlg );

    if (!pArgs->fChainPropertySheet)
    {
        //
        // Do not load RAS DLL entrypoints if we
        // have an RPC server set.
        //
#ifdef RASMERGE
        if (!pArgs->fRouter) {
#endif
            /* Load RAS DLL entrypoints which starts RASMAN, if necessary.
            */
            dwErr = LoadRas( g_hinstDll, hwndDlg );
            if (dwErr != 0)
            {
                ErrorDlg( hwndDlg, SID_OP_LoadRas, dwErr, NULL );
                pArgs->pApiArgs->dwError = dwErr;
                PeExitInit( hwndDlg );
                return NULL;
            }
#ifdef RASMERGE
        }
#endif

        /* Load the common entry information.  This must happen after RasLoad,
        ** which must happen after the dialog has been positioned so that the
        ** "Waiting for services" appears where the dialog will eventually
        ** popup.  Note that EuInit assumes that EuInit0 has previously been
        ** called.
        */
        dwErr = EuInit( pArgs, &dwOp );
        if (dwErr != 0)
        {
            ErrorDlg( hwndDlg, dwOp, dwErr, NULL );
            pArgs->pApiArgs->dwError = dwErr;
            PeExitInit( hwndDlg );
            return NULL;
        }
    }

    /* Stash phone number settings for first link.
    */
    EuPhoneNumberStashFromEntry( pInfo->pArgs,
        &pInfo->pListPhoneNumbers, &pInfo->fPromoteHuntNumbers );

    /* Initialize link related states and shortcut addresses.
    */
    pInfo->fMultiLinkMode = (PeCountEnabledLinks( pInfo ) > 1);
    PeUpdateShortcuts( pInfo );

    /* Set even fixed tab widths, per spec.
    */
    SetEvenTabWidths(
        hwndDlg, (pArgs->fRouter) ? PE_PageCount : PE_PageCountNoRtr );

    return pInfo;
}


VOID
PeTerm(
    IN HWND hwndPage )

    /* Property sheet level termination.  Releases the context block.
    ** 'HwndPage' is the handle of a property page.
    */
{
    PEINFO* pInfo;

    TRACE("PeTerm");

    pInfo = PeContext( hwndPage );
    if (pInfo)
    {
        if (pInfo->pListPads)
            DtlDestroyList( pInfo->pListPads, DestroyPszNode );

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}


VOID
PeUpdateShortcuts(
    IN PEINFO* pInfo )

    /* Update first link and port shortcut pointers.
    */
{
    DTLNODE* pNode;

    TRACE("PeUpdateShortcuts");

    pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
    ASSERT(pNode);
    pInfo->pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pInfo->pLink);
    pInfo->pPort = &pInfo->pLink->pbport;
}


/*----------------------------------------------------------------------------
** Basic property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
BsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Basic page of the Entry Property sheet.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("BsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                BsInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                PEINFO* pInfo = PeContext(hwnd);
                if (pInfo)
                {
                    ContextHelpHack( g_adwBsHelp, hwnd, unMsg, wparam, lparam,
        							 pInfo->pArgs->fRouter);
                }        							 
            }							 
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;

                    TRACE("BsAPPLY");
                    fValid = PeApply( hwnd );

                    SetWindowLong(
                        hwnd, DWLP_MSGRESULT,
                        (fValid)
                            ? PSNRET_NOERROR
                            : PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                }

                case PSN_RESET:
                {
                    TRACE("BsRESET");
                    PeCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);

            return BsCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            PeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
BsAlternates(
    IN PEINFO* pInfo )

    /* Popup the Alternate Phone Numbers dialog.  'PInfo' is the property
    ** sheet context.
    */
{
    BsPhoneNumberToStash( pInfo );

    if (PhoneNumberDlg(
            pInfo->hwndBs,
            pInfo->pArgs->fRouter,
            pInfo->pListPhoneNumbers,
            &pInfo->fPromoteHuntNumbers ))
    {
        TCHAR* pszPhoneNumber;

        pszPhoneNumber = FirstPszFromList( pInfo->pListPhoneNumbers );
        SetWindowText( pInfo->hwndEbPhoneNumber, pszPhoneNumber );
    }
}


BOOL
BsCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("BsCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_BS_PB_Configure:
            BsConfigure( pInfo );
            return TRUE;

        case CID_BS_PB_Alternates:
            BsAlternates( pInfo );
            return TRUE;

        case CID_BS_CB_UseAreaCountryCodes:
            BsUpdateAreaAndCountryCode( pInfo );
            return TRUE;

        case CID_BS_LB_CountryCode:
        {
            switch (wNotification)
            {
                case CBN_DROPDOWN:
                    EuFillCountryCodeList(
                        pInfo->pArgs, pInfo->hwndLbCountryCodes, TRUE );
                    return TRUE;

                case CBN_SELCHANGE:
                    EuLbCountryCodeSelChange(
                        pInfo->pArgs, pInfo->hwndLbCountryCodes );
                    return TRUE;
            }
        }

        case CID_BS_LB_Device:
        {
            if (wNotification == CBN_SELCHANGE)
                BsLbDevicesSelChange( pInfo );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
BsConfigure(
    IN PEINFO* pInfo )

    /* Called when the configure button is pressed.  'PInfo' is the property
    ** sheet context.
    */
{
    TRACE("BsConfigure");

    if (pInfo->fMultiLinkMode)
    {
        /* Multi-link selected.  Popup the extended configuration dialog.
        */
        if (MultiLinkConfigureDlg( pInfo->hwndDlg,
                pInfo->pArgs->pEntry->pdtllistLinks,
                pInfo->pArgs->fRouter ))
        {
            /* The dialog substitutes a list of links with re-allocated nodes
            ** so need to rebuild the device list so the "pNode" item data
            ** gets updated.
            */
            PeUpdateShortcuts( pInfo );
            BsFillDeviceList( pInfo );
        }
    }
    else
    {
        DTLNODE* pNode;
        PBLINK*  pLink;

        /* Single-link port is selected.  Popup the appropriate device
        ** configuration dialog.
        */
        pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
        ASSERT(pNode);
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT(pLink);
        DeviceConfigureDlg( pInfo->hwndBs, pLink, TRUE );
    }
}


VOID
BsFillDeviceList(
    IN PEINFO* pInfo )

    /* Fill the "dial using" list and set the selection to the one in the
    ** entry.  'PInfo' is the property sheet context.
    */
{
    DTLNODE* pNode;
    PBLINK*  pFirstLink;
    INT      iSel;
    INT      i;

    TRACE("BsFillDeviceList");

    ComboBox_ResetContent( pInfo->hwndLbDevices );
    iSel = -1;
    pFirstLink = NULL;

    /* Add an item for each link in the entry followed by each unconfigured
    ** link.
    */
    for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBLINK* pLink;
        TCHAR*  psz;

        pLink = (PBLINK* )DtlGetData( pNode );

        if (!pFirstLink)
            pFirstLink = pLink;

        psz = DisplayPszFromDeviceAndPort(
            pLink->pbport.pszDevice, pLink->pbport.pszPort );
        if (psz)
        {
            ComboBox_AddItemSorted( pInfo->hwndLbDevices, psz, pNode );
            Free( psz );
        }
    }

    /* Add "Multiple Lines" as the last item.
    */
    {
        TCHAR* pszMultiLink;

        pszMultiLink = PszFromId( g_hinstDll, SID_MultiLink );
        if (pszMultiLink)
        {
            i = ComboBox_AddItem( pInfo->hwndLbDevices, pszMultiLink, NULL );
            Free( pszMultiLink );
            if (pInfo->fMultiLinkMode)
            {
                TCHAR* psz;

                iSel = i;

                /* Set multi-link phone number behavior.
                */
                psz = PszFromId( g_hinstDll, SID_MultiLinkNumber );
                if (psz)
                {
                    SetWindowText( pInfo->hwndEbPhoneNumber, psz );
                    Free( psz );
                }
            }
        }
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbDevices );

    /* Set the selection and set initial window state.
    */
    if (iSel < 0 && pFirstLink)
    {
        TCHAR* psz;

        psz = DisplayPszFromDeviceAndPort(
            pFirstLink->pbport.pszDevice, pFirstLink->pbport.pszPort );
        if (psz)
        {
            iSel = ComboBox_FindStringExact( pInfo->hwndLbDevices, -1, psz );
            Free( psz );
        }            
    }

    ComboBox_SetCurSel( pInfo->hwndLbDevices, iSel );
    pInfo->iLbDevices = iSel;
    EnableWindow( pInfo->hwndStPhoneNumber, !pInfo->fMultiLinkMode );
    EnableWindow( pInfo->hwndEbPhoneNumber, !pInfo->fMultiLinkMode );
    EnableWindow( pInfo->hwndPbAlternate, !pInfo->fMultiLinkMode );
}


BOOL
BsInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    PEINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("BsInit");

    /* We're first page, so initialize the property sheet.
    */
    pInfo = PeInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndBs = hwndPage;
    pInfo->hwndEbEntryName = GetDlgItem( hwndPage, CID_BS_EB_EntryName );
    ASSERT(pInfo->hwndEbEntryName);
    pInfo->hwndEbDescription = GetDlgItem( hwndPage, CID_BS_EB_Description );
    ASSERT(pInfo->hwndEbDescription);
    pInfo->hwndStCountryCode = GetDlgItem( hwndPage, CID_BS_ST_CountryCode );
    ASSERT(pInfo->hwndStCountryCode);
    pInfo->hwndLbCountryCodes = GetDlgItem( hwndPage, CID_BS_LB_CountryCode );
    ASSERT(pInfo->hwndLbCountryCodes);
    pInfo->hwndStAreaCode = GetDlgItem( hwndPage, CID_BS_ST_AreaCode );
    ASSERT(pInfo->hwndStAreaCode);
    pInfo->hwndLbAreaCodes = GetDlgItem( hwndPage, CID_BS_CL_AreaCode );
    ASSERT(pInfo->hwndLbAreaCodes);
    pInfo->hwndStPhoneNumber = GetDlgItem( hwndPage, CID_BS_ST_PhoneNumber );
    ASSERT(pInfo->hwndStPhoneNumber);
    pInfo->hwndEbPhoneNumber = GetDlgItem( hwndPage, CID_BS_EB_PhoneNumber );
    ASSERT(pInfo->hwndEbPhoneNumber);
    pInfo->hwndPbAlternate = GetDlgItem( hwndPage, CID_BS_PB_Alternates );
    ASSERT(pInfo->hwndPbAlternate);
    pInfo->hwndStDevice = GetDlgItem( hwndPage, CID_BS_ST_Device );
    ASSERT(pInfo->hwndStDevice);
    pInfo->hwndLbDevices = GetDlgItem( hwndPage, CID_BS_LB_Device );
    ASSERT(pInfo->hwndLbDevices);
    pInfo->hwndPbConfigure = GetDlgItem( hwndPage, CID_BS_PB_Configure );
    ASSERT(pInfo->hwndPbConfigure);
    pInfo->hwndCbUseAreaCode =
        GetDlgItem( hwndPage, CID_BS_CB_UseAreaCountryCodes );
    ASSERT(pInfo->hwndCbUseAreaCode);
    pInfo->hwndCbUseOtherPort = GetDlgItem( hwndPage, CID_BS_CB_UseOtherPort );
    ASSERT(pInfo->hwndCbUseOtherPort);

    /* Calculate the "on" y-position of the controls that slide up when "Use
    ** Area Code and Country Code" is on, and the offset they slide up when
    ** it's "off".
    */
    {
        RECT  rectStCountryCode;
        RECT  rectStPhoneNumber;
        RECT  rectEbPhoneNumber;
        RECT  rectPbAlternate;
        RECT  rectStDevice;
        RECT  rectLbDevice;
        RECT  rectPbConfigure;
        RECT  rectCbUseAreaCode;
        RECT  rectCbUseOtherPort;
        POINT xyStCountryCode;

        GetWindowRect( pInfo->hwndStCountryCode, &rectStCountryCode );
        GetWindowRect( pInfo->hwndStPhoneNumber, &rectStPhoneNumber );
        GetWindowRect( pInfo->hwndEbPhoneNumber, &rectEbPhoneNumber );
        GetWindowRect( pInfo->hwndPbAlternate, &rectPbAlternate );
        GetWindowRect( pInfo->hwndStDevice, &rectStDevice );
        GetWindowRect( pInfo->hwndLbDevices, &rectLbDevice );
        GetWindowRect( pInfo->hwndPbConfigure, &rectPbConfigure );
        GetWindowRect( pInfo->hwndCbUseAreaCode, &rectCbUseAreaCode );
        GetWindowRect( pInfo->hwndCbUseOtherPort, &rectCbUseOtherPort );

        xyStCountryCode.x = rectStCountryCode.left;
        xyStCountryCode.y = rectStCountryCode.top;
        pInfo->xyStPhoneNumber.x = rectStPhoneNumber.left;
        pInfo->xyStPhoneNumber.y = rectStPhoneNumber.top;
        pInfo->xyEbPhoneNumber.x = rectEbPhoneNumber.left;
        pInfo->xyEbPhoneNumber.y = rectEbPhoneNumber.top;
        pInfo->xyPbAlternate.x = rectPbAlternate.left;
        pInfo->xyPbAlternate.y = rectPbAlternate.top;
        pInfo->xyStDevice.x = rectStDevice.left;
        pInfo->xyStDevice.y = rectStDevice.top;
        pInfo->xyLbDevice.x = rectLbDevice.left;
        pInfo->xyLbDevice.y = rectLbDevice.top;
        pInfo->xyPbConfigure.x = rectPbConfigure.left;
        pInfo->xyPbConfigure.y = rectPbConfigure.top;
        pInfo->xyCbUseAreaCode.x = rectCbUseAreaCode.left;
        pInfo->xyCbUseAreaCode.y = rectCbUseAreaCode.top;
        pInfo->xyCbUseOtherPort.x = rectCbUseOtherPort.left;
        pInfo->xyCbUseOtherPort.y = rectCbUseOtherPort.top;

        ScreenToClient( hwndPage, &xyStCountryCode );
        ScreenToClient( hwndPage, &pInfo->xyStPhoneNumber );
        ScreenToClient( hwndPage, &pInfo->xyEbPhoneNumber );
        ScreenToClient( hwndPage, &pInfo->xyPbAlternate );
        ScreenToClient( hwndPage, &pInfo->xyStDevice );
        ScreenToClient( hwndPage, &pInfo->xyLbDevice );
        ScreenToClient( hwndPage, &pInfo->xyPbConfigure );
        ScreenToClient( hwndPage, &pInfo->xyCbUseAreaCode );
        ScreenToClient( hwndPage, &pInfo->xyCbUseOtherPort );

        pInfo->dyAreaCodeAdjust = pInfo->xyStPhoneNumber.y - xyStCountryCode.y;
    }

    /* Initialize page.
    */
    pEntry = pInfo->pArgs->pEntry;

    /* Entry name field.
    */
    if (!pEntry->pszEntryName)
    {
        /* No entry name, so think up a default.
        */
        dwErr = GetDefaultEntryName(
            pInfo->pArgs->pFile->pdtllistEntries,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPage, dwErr, NULL );
            PeExit( pInfo, dwErr );
            return TRUE;
        }
    }

    Edit_LimitText( pInfo->hwndEbEntryName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbEntryName, pEntry->pszEntryName );

    Edit_LimitText( pInfo->hwndEbDescription, RAS_MaxDescription );
    SetWindowText( pInfo->hwndEbDescription, pEntry->pszDescription );

    Edit_LimitText( pInfo->hwndEbPhoneNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbPhoneNumber,
        FirstPszFromList( pInfo->pListPhoneNumbers ) );

    /* Fill ports/devices list, set selection, and set the state of the phone
    ** number edit field and button.
    */
    BsFillDeviceList( pInfo );

    if (pInfo->pArgs->fRouter)
    {
        /* Always checked and invisible for router.  This allows some
        ** optimization in DDM.  Ask Gibbs.
        */
        CheckDlgButton( pInfo->hwndBs, CID_BS_CB_UseOtherPort, BST_CHECKED );
        EnableWindow( GetDlgItem( hwndPage, CID_BS_CB_UseOtherPort ), FALSE );
        ShowWindow( GetDlgItem( hwndPage, CID_BS_CB_UseOtherPort ), SW_HIDE );
    }
    else
    {
        /* The "use other port" checkbox is currently per-entry in the UI
        ** though the phonebook allows it to be per-link.  Initialize the
        ** per-entry copy from the first link.
        */
        ASSERT(pInfo->pLink);
        CheckDlgButton( pInfo->hwndBs, CID_BS_CB_UseOtherPort,
            (pInfo->pLink->fOtherPortOk) ? BST_CHECKED : BST_UNCHECKED );
    }

    /* Set "Use country code and area code" checkbox and jockey the fields
    ** according to the setting.  This will trigger filling of the area code
    ** and country code lists, if necessary.  If in router-mode,
    ** telephony-properties don't apply, since the router service will be
    ** running in LocalSystem context, for which no telephony settings
    ** currently exist, so the options are disabled.
    */
    if (pInfo->pArgs->fRouter)
    {
        CheckDlgButton(
            pInfo->hwndBs, CID_BS_CB_UseAreaCountryCodes, BST_UNCHECKED );
        BsUpdateAreaAndCountryCode( pInfo );

        EnableWindow(
            GetDlgItem(hwndPage, CID_BS_CB_UseAreaCountryCodes), FALSE );
        ShowWindow(
            GetDlgItem(hwndPage, CID_BS_CB_UseAreaCountryCodes), SW_HIDE );
    }
    else
    {
        CheckDlgButton( pInfo->hwndBs, CID_BS_CB_UseAreaCountryCodes,
            (pEntry->fUseCountryAndAreaCode) ? BST_CHECKED : BST_UNCHECKED );
        BsUpdateAreaAndCountryCode( pInfo );
    }

    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_NoRename)
        EnableWindow( pInfo->hwndEbEntryName, FALSE );

    return TRUE;
}


VOID
BsLbDevicesSelChange(
    IN PEINFO* pInfo )

    /* Called when device selection has changed.  'PInfo' is the property
    ** sheet context.
    */
{
    DTLNODE* pNodeSel;
    INT      iSel;

    TRACE("BsLbDevicesSelChange");

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDevices );
    if (iSel == pInfo->iLbDevices)
        return;

    pNodeSel = ComboBox_GetItemDataPtr( pInfo->hwndLbDevices, iSel );
    if (pNodeSel)
    {
        DTLNODE* pNode;

        if (pInfo->fMultiLinkMode && PeCountEnabledLinks( pInfo ) > 1)
        {
            MSGARGS msgargs;

            /* User just turned off multi-link mode, make sure he means it
            ** because the port/link data associated with the 2nd-to-nth links
            ** will be discarded.
            */
            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_YESNO + MB_DEFBUTTON2 + MB_ICONEXCLAMATION;
            if (MsgDlg( pInfo->hwndBs, SID_UnMultiLink, &msgargs ) != IDYES)
            {
                /* User has cancelled un-multi-link.  Restore previous
                ** selection.
                */
                ComboBox_SetCurSel( pInfo->hwndLbDevices, pInfo->iLbDevices );
                return;
            }
        }

        /* Disable all but the selected link.
        */
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink;

            pLink = (PBLINK* )DtlGetData( pNode );;
            pLink->fEnabled = (pNode == pNodeSel);
        }

        /* Move the selected node to the head of the list of links.
        */
        DtlRemoveNode( pInfo->pArgs->pEntry->pdtllistLinks, pNodeSel );
        DtlAddNodeFirst( pInfo->pArgs->pEntry->pdtllistLinks, pNodeSel );

        if (pInfo->fMultiLinkMode)
        {
            /* Reset phone number to single-link mode.
            */
            EuPhoneNumberStashFromEntry( pInfo->pArgs,
                &pInfo->pListPhoneNumbers, &pInfo->fPromoteHuntNumbers );
            SetWindowText( pInfo->hwndEbPhoneNumber,
                FirstPszFromList( pInfo->pListPhoneNumbers ) );

            EnableWindow( pInfo->hwndStPhoneNumber, TRUE );
            EnableWindow( pInfo->hwndEbPhoneNumber, TRUE );
            EnableWindow( pInfo->hwndPbAlternate, TRUE );
            pInfo->fMultiLinkMode = FALSE;
        }
    }
    else
    {
        TCHAR* psz;

        /* User just turned on multi-link mode.
        */
        if (pInfo->pArgs->pEntry->dwBaseProtocol != BP_Ppp)
        {
            MsgDlg( pInfo->hwndDlg, SID_MlinkNeedsPpp, NULL );
            ComboBox_SetCurSel( pInfo->hwndLbDevices, pInfo->iLbDevices );
            return;
        }

        /* Set multi-link phone number behavior.
        */
        BsPhoneNumberToStash( pInfo );
        EuPhoneNumberStashToEntry( pInfo->pArgs,
            pInfo->pListPhoneNumbers, pInfo->fPromoteHuntNumbers, FALSE );

        psz = PszFromId( g_hinstDll, SID_MultiLinkNumber );
        if (psz)
        {
            SetWindowText( pInfo->hwndEbPhoneNumber, psz );
            Free( psz );
        }

        EnableWindow( pInfo->hwndStPhoneNumber, FALSE );
        EnableWindow( pInfo->hwndEbPhoneNumber, FALSE );
        EnableWindow( pInfo->hwndPbAlternate, FALSE );
        pInfo->fMultiLinkMode = TRUE;
    }

    pInfo->iLbDevices = iSel;
}


VOID
BsPhoneNumberToStash(
    IN PEINFO* pInfo )

    /* Replace the first phonenumber in the stashed list with the contents of
    ** the phone number field.  'pInfo' is the property sheet context.
    */
{
    DWORD  dwErr;
    TCHAR* pszPhoneNumber;

    TRACE("BsPhoneNumberToStash");
    ASSERT(!(pInfo->fMultiLinkMode&&pInfo->iLbDevices>=0));

    pszPhoneNumber = GetText( pInfo->hwndEbPhoneNumber );
    if (pszPhoneNumber)
    {
        dwErr = FirstPszToList( pInfo->pListPhoneNumbers, pszPhoneNumber );
        Free( pszPhoneNumber );
    }
    else
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        PeExit( pInfo, dwErr );
    }
}


VOID
BsUpdateAreaAndCountryCode(
    IN PEINFO* pInfo )

    /* Handles enabling/disabling and moving the Area Code and Country Code
    ** control and those controls below them based on the setting of the "Use
    ** area code and country code" checkbox.  'PInfo' is the dialog context.
    */
{
    HWND hwndFocus;
    BOOL fEnable;

    TRACE("BsUpdateAreaAndCountryCode");

    fEnable = IsDlgButtonChecked(
        pInfo->hwndBs, CID_BS_CB_UseAreaCountryCodes );

    if (fEnable)
    {
        /* The area code and country code lists are being activated, so fill
        ** the lists if they aren't already.
        */
        EuFillCountryCodeList(
            pInfo->pArgs, pInfo->hwndLbCountryCodes, FALSE );
        EuFillAreaCodeList( pInfo->pArgs, pInfo->hwndLbAreaCodes );
    }
    else
    {
        /* If the focus is on one of the controls we're about to disable, move
        ** it to the entry phone number editbox.  Otherwise, keyboard user is
        ** stuck.
        */
        hwndFocus = GetFocus();

        if (hwndFocus == pInfo->hwndLbCountryCodes
            || hwndFocus == pInfo->hwndLbAreaCodes)
        {
            SetFocus( pInfo->hwndEbPhoneNumber );
        }
    }

    /* Enable/disable show/hide the Area Code and Country Code controls as
    ** indicated by user.
    */
    {
        int nCmdShow = (fEnable) ? SW_SHOW : SW_HIDE;

        EnableWindow( pInfo->hwndStAreaCode, fEnable );
        ShowWindow( pInfo->hwndStAreaCode, nCmdShow );
        EnableWindow( pInfo->hwndLbAreaCodes, fEnable );
        ShowWindow( pInfo->hwndLbAreaCodes, nCmdShow );

        EnableWindow( pInfo->hwndStCountryCode, fEnable );
        ShowWindow( pInfo->hwndStCountryCode, nCmdShow );
        EnableWindow( pInfo->hwndLbCountryCodes, fEnable );
        ShowWindow( pInfo->hwndLbCountryCodes, nCmdShow );
    }

    /* Move the controls below the area and country codes up/down depending on
    ** whether the area code and country code controls are visible.
    */
    {
        int yStPhoneNumber;
        int yEbPhoneNumber;
        int yPbAlternate;
        int yStDevice;
        int yLbDevice;
        int yPbConfigure;
        int yCbUseAreaCode;
        int yCbUseOtherPort;

        if (fEnable)
        {
            yStPhoneNumber = pInfo->xyStPhoneNumber.y;
            yEbPhoneNumber = pInfo->xyEbPhoneNumber.y;
            yPbAlternate = pInfo->xyPbAlternate.y;
            yStDevice = pInfo->xyStDevice.y;
            yLbDevice = pInfo->xyLbDevice.y;
            yPbConfigure = pInfo->xyPbConfigure.y;
            yCbUseAreaCode = pInfo->xyCbUseAreaCode.y;
            yCbUseOtherPort = pInfo->xyCbUseOtherPort.y;
        }
        else
        {
            yStPhoneNumber = pInfo->xyStPhoneNumber.y - pInfo->dyAreaCodeAdjust;
            yEbPhoneNumber = pInfo->xyEbPhoneNumber.y - pInfo->dyAreaCodeAdjust;
            yPbAlternate = pInfo->xyPbAlternate.y - pInfo->dyAreaCodeAdjust;
            yStDevice = pInfo->xyStDevice.y - pInfo->dyAreaCodeAdjust;
            yLbDevice = pInfo->xyLbDevice.y - pInfo->dyAreaCodeAdjust;
            yPbConfigure = pInfo->xyPbConfigure.y - pInfo->dyAreaCodeAdjust;
            yCbUseAreaCode = pInfo->xyCbUseAreaCode.y - pInfo->dyAreaCodeAdjust;
            yCbUseOtherPort = pInfo->xyCbUseOtherPort.y - pInfo->dyAreaCodeAdjust;
        }

        SetWindowPos( pInfo->hwndStPhoneNumber, NULL,
            pInfo->xyStPhoneNumber.x, yStPhoneNumber, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndEbPhoneNumber, NULL,
            pInfo->xyEbPhoneNumber.x, yEbPhoneNumber, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndPbAlternate, NULL,
            pInfo->xyPbAlternate.x, yPbAlternate, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndStDevice, NULL,
            pInfo->xyStDevice.x, yStDevice, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndLbDevices, NULL,
            pInfo->xyLbDevice.x, yLbDevice, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndPbConfigure, NULL,
            pInfo->xyPbConfigure.x, yPbConfigure, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndCbUseAreaCode, NULL,
            pInfo->xyCbUseAreaCode.x, yCbUseAreaCode, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndCbUseOtherPort, NULL,
            pInfo->xyCbUseOtherPort.x, yCbUseOtherPort, 0, 0,
            SWP_NOSIZE + SWP_NOZORDER + SWP_NOCOPYBITS );
    }
}


/*----------------------------------------------------------------------------
** Server property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
SvDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Server page of the Entry property sheet.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("SvDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return SvInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                PEINFO* pInfo = PeContext(hwnd);
                if (pInfo)
                {
                    ContextHelpHack( g_adwBsHelp, hwnd, unMsg, wparam, lparam,
        							 pInfo->pArgs->fRouter);
                }        							 
            }							 
            break;

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);

            return SvCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            if (((NMHDR* )lparam)->code == PSN_SETACTIVE)
            {
                PEINFO* pInfo = PeContext( hwnd );
                ASSERT(pInfo);

                if (!pInfo->pArgs->fRouter)
                    break;

                /* Use the server type label to the built information field
                ** instead.
                */
                {
                    TCHAR* pszFormat;
                    TCHAR* pszFormatted;
                    TCHAR* pszEntry;
                    TCHAR* apszArgs[ 2 ];
                    TCHAR szRouterName[ MAX_COMPUTERNAME_LENGTH + 1 ];
                    DWORD dwSize;

                    pszFormat = PszFromId( g_hinstDll, SID_ProtocolsInfo );
                    if (pszFormat)
                    {
                        dwSize = MAX_COMPUTERNAME_LENGTH + 1;
                        szRouterName[ 0 ] = '\0';
                        GetComputerName( szRouterName, &dwSize );

                        pszEntry = GetText( pInfo->hwndEbEntryName );
                        if (pszEntry)
                        {
                            apszArgs[ 0 ] = szRouterName;
                            apszArgs[ 1 ] = pszEntry;
                            pszFormatted = NULL;

                            FormatMessage(
                                FORMAT_MESSAGE_FROM_STRING
                                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                pszFormat, 0, 0, (LPTSTR )&pszFormatted, 2,
                                (va_list* )apszArgs );

                            Free( pszFormat );
                            Free( pszEntry );

                            if (pszFormatted)
                            {
                                SetWindowText(
                                    pInfo->hwndStServerTypes, pszFormatted );
                                LocalFree( pszFormatted );
                            }
                        }
                    }

                }
            }
            break;
        }

    }

    return FALSE;
}


VOID
SvCbIpClicked(
    IN PEINFO* pInfo )

    /* Called when the TCP/IP checkbox is clicked.  'PInfo' is the property
    ** sheet context.
    */
{
    DWORD dwBaseProtocol;
    BOOL  fChecked;
    BOOL  fInstalled;
    INT   iSel;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbServerTypes );
    dwBaseProtocol = (DWORD)ComboBox_GetItemData( pInfo->hwndLbServerTypes, iSel );
    fChecked = Button_GetCheck( pInfo->hwndCbIp );
    fInstalled = (pInfo->dwfInstalledProtocols & NP_Ip);

    if (fChecked && !fInstalled)
    {
        /* Can't check if not installed.
        */
        SvProtocolNotInstalledPopup( pInfo, SID_Ip );
        Button_SetCheck( pInfo->hwndCbIp, FALSE );
        return;
    }

    if (dwBaseProtocol == BP_Slip && !fChecked && fInstalled)
    {
        /* Can't uncheck on SLIP.
        */
        MsgDlg( pInfo->hwndSv, SID_SlipNeedsIp, NULL );
        Button_SetCheck( pInfo->hwndCbIp, TRUE );
        return;
    }

    pInfo->fPppIp = fChecked;
    EnableWindow( pInfo->hwndPbIp, fChecked );
}


VOID
SvCbIpxClicked(
    IN PEINFO* pInfo )

    /* Called when the IPX checkbox is clicked.  'PInfo' is the property sheet
    ** context.
    */
{
    BOOL fChecked;
    BOOL fInstalled;

    fChecked = Button_GetCheck( pInfo->hwndCbIpx );
    fInstalled = (pInfo->dwfInstalledProtocols & NP_Ipx);

    if (fChecked && !fInstalled)
    {
        /* Can't check if not installed.
        */
        SvProtocolNotInstalledPopup( pInfo, SID_Ipx );
        Button_SetCheck( pInfo->hwndCbIpx, FALSE );
    }

    pInfo->fPppIpx = fChecked;
}


VOID
SvCbNbfClicked(
    IN PEINFO* pInfo )

    /* Called when the Netbeui checkbox is clicked.  'PInfo' is the property
    ** sheet context.
    */
{
    DWORD dwBaseProtocol;
    BOOL  fChecked;
    BOOL  fInstalled;
    INT   iSel;

    ASSERT(!pInfo->pArgs->fRouter);

    iSel = ComboBox_GetCurSel( pInfo->hwndLbServerTypes );
    dwBaseProtocol = (DWORD)ComboBox_GetItemData( pInfo->hwndLbServerTypes, iSel );
    fChecked = Button_GetCheck( pInfo->hwndCbNbf );
    fInstalled = (pInfo->dwfInstalledProtocols & NP_Nbf);

    if (fChecked && !fInstalled)
    {
        /* Can't check if not installed.
        */
        SvProtocolNotInstalledPopup( pInfo, SID_Nbf );
        Button_SetCheck( pInfo->hwndCbNbf, FALSE );
        return;
    }

    if (dwBaseProtocol == BP_Ras && !fChecked && fInstalled)
    {
        /* Can't uncheck on RAS.
        */
        MsgDlg( pInfo->hwndSv, SID_RasNeedsNbf, NULL );
        Button_SetCheck( pInfo->hwndCbNbf, TRUE );
    }

    pInfo->fPppNbf = fChecked;
}


BOOL
SvCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("SvCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_SV_LB_ServerType:
            if (wNotification == CBN_SELCHANGE)
                SvLbServerTypesSelChange( pInfo );
            return TRUE;

        case CID_SV_CB_TcpIp:
            if (wNotification == BN_CLICKED)
                SvCbIpClicked( pInfo );
            return TRUE;

        case CID_SV_CB_Ipx:
            if (wNotification == BN_CLICKED)
                SvCbIpxClicked( pInfo );
            return TRUE;

        case CID_SV_CB_Netbeui:
            if (wNotification == BN_CLICKED)
                SvCbNbfClicked( pInfo );
            return TRUE;

        case CID_SV_PB_TcpIpSettings:
            SvTcpipSettings( pInfo );
            return TRUE;

        case CID_SV_CB_SwCompression:
            if (wNotification == BN_CLICKED)
            {
                pInfo->fSwCompression =
                    Button_GetCheck( pInfo->hwndCbSwCompression );
            }
            return TRUE;

        case CID_SV_CB_LcpExtensions:
            if (wNotification == BN_CLICKED)
            {
                pInfo->fLcpExtensions =
                    Button_GetCheck( pInfo->hwndCbLcpExtensions );
            }
            return TRUE;
    }

    return FALSE;
}


BOOL
SvInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;
    HWND     hwndLb;
    INT      i;
    INT      iSel;

    TRACE("SvInit");

    pInfo = PeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndSv = hwndPage;
    pInfo->hwndStServerTypes = GetDlgItem( hwndPage, CID_SV_ST_ServerType );
    ASSERT(pInfo->hwndStServerTypes);
    pInfo->hwndLbServerTypes = GetDlgItem( hwndPage, CID_SV_LB_ServerType );
    ASSERT(pInfo->hwndLbServerTypes);
    pInfo->hwndCbIp = GetDlgItem( hwndPage, CID_SV_CB_TcpIp );
    ASSERT(pInfo->hwndCbIp);
    pInfo->hwndPbIp = GetDlgItem( hwndPage, CID_SV_PB_TcpIpSettings );
    ASSERT(pInfo->hwndPbIp);
    pInfo->hwndCbIpx = GetDlgItem( hwndPage, CID_SV_CB_Ipx );
    ASSERT(pInfo->hwndCbIpx);
    pInfo->hwndCbNbf = GetDlgItem( hwndPage, CID_SV_CB_Netbeui );
    ASSERT(pInfo->hwndCbNbf);
    pInfo->hwndCbSwCompression = GetDlgItem( hwndPage, CID_SV_CB_SwCompression );
    ASSERT(pInfo->hwndCbSwCompression);
    pInfo->hwndCbLcpExtensions = GetDlgItem( hwndPage, CID_SV_CB_LcpExtensions );
    ASSERT(pInfo->hwndCbLcpExtensions);

    /* Initialize page.
    */
    pEntry = pInfo->pArgs->pEntry;
#ifdef RASMERGE
    pInfo->dwfInstalledProtocols = g_pGetInstalledProtocols();
#else
    pInfo->dwfInstalledProtocols = GetInstalledProtocols();
#endif

    if (pInfo->pArgs->fRouter)
    {
        /* Just in case somebody dicked with the phonebook.
        */
        pInfo->dwBaseProtocolDefault = BP_Ppp;

        /* Disable/hide the server type window which we build in the
        ** background to keep our lives simple.
        */
        EnableWindow( pInfo->hwndLbServerTypes, FALSE );
        ShowWindow( pInfo->hwndLbServerTypes, SW_HIDE );
    }

    pInfo->dwBaseProtocolDefault = pEntry->dwBaseProtocol;

    pInfo->fPppIpDefault = pInfo->fPppIp =
        (pInfo->dwfInstalledProtocols & NP_Ip)
        && !(pEntry->dwfExcludedProtocols & NP_Ip);

    pInfo->fPppIpxDefault = pInfo->fPppIpx =
        (pInfo->dwfInstalledProtocols & NP_Ipx)
        && !(pEntry->dwfExcludedProtocols & NP_Ipx);

    pInfo->fPppNbfDefault = pInfo->fPppNbf =
        (pInfo->dwfInstalledProtocols & NP_Nbf)
        && !(pEntry->dwfExcludedProtocols & NP_Nbf);

    pInfo->fSwCompression = pEntry->fSwCompression;
    pInfo->fLcpExtensions = pEntry->fLcpExtensions;

    /* Fill server type list, noting which item should be selected.
    */
    iSel = 0;
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbServerTypes,
        SID_ST_Ppp, (VOID* )BP_Ppp );

    if (!pInfo->pArgs->fRouter)
    {
        i = ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbServerTypes,
                SID_ST_Slip, (VOID* )BP_Slip );
        if (pEntry->dwBaseProtocol == BP_Slip)
            iSel = i;

#ifdef AMB
        i = ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbServerTypes,
                SID_ST_Ras, (VOID* )BP_Ras );
        if (pEntry->dwBaseProtocol == BP_Ras)
            iSel = i;
#endif
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbServerTypes );

    /* Select server type with notification to trigger check box updates.
    */
    ComboBox_SetCurSelNotify( pInfo->hwndLbServerTypes, iSel );
    SetFocus( pInfo->hwndLbServerTypes );

    return FALSE;
}


VOID
SvLbServerTypesSelChange(
    IN PEINFO* pInfo )

    /* Called when the server type is changed.  'PInfo' is the property sheet
    ** context.
    */
{
    INT   iSel;
    DWORD dwBaseProtocol;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbServerTypes );
    dwBaseProtocol = (DWORD)ComboBox_GetItemData( pInfo->hwndLbServerTypes, iSel );

    switch (dwBaseProtocol)
    {
        case BP_Ppp:
        {
            EnableWindow( pInfo->hwndCbIp, TRUE );
            EnableWindow( pInfo->hwndPbIp, TRUE );
            EnableWindow( pInfo->hwndCbIpx, TRUE );
            EnableWindow( pInfo->hwndCbNbf, TRUE );
            EnableWindow( pInfo->hwndCbSwCompression, TRUE );
            EnableWindow( pInfo->hwndCbLcpExtensions, TRUE );
            Button_SetCheck( pInfo->hwndCbIp, pInfo->fPppIp );
            EnableWindow( pInfo->hwndPbIp, pInfo->fPppIp );
            Button_SetCheck( pInfo->hwndCbIpx, pInfo->fPppIpx );
            Button_SetCheck( pInfo->hwndCbNbf, pInfo->fPppNbf );
            Button_SetCheck( pInfo->hwndCbSwCompression,
                pInfo->fSwCompression );
            Button_SetCheck( pInfo->hwndCbLcpExtensions,
                pInfo->fLcpExtensions );
            break;
        }

        case BP_Slip:
        {
            if (pInfo->fMultiLinkMode)
            {
                MsgDlg( pInfo->hwndDlg, SID_MlinkNeedsPpp, NULL );
                ComboBox_SetCurSel( pInfo->hwndLbServerTypes,
                    pInfo->iLbServerTypes );
                return;
            }

            EnableWindow( pInfo->hwndCbIp, TRUE );
            EnableWindow( pInfo->hwndPbIp, TRUE );
            EnableWindow( pInfo->hwndCbIpx, FALSE );
            EnableWindow( pInfo->hwndCbNbf, FALSE );
            EnableWindow( pInfo->hwndCbSwCompression, FALSE );
            EnableWindow( pInfo->hwndCbLcpExtensions, FALSE );
            Button_SetCheck( pInfo->hwndCbIp,
                pInfo->dwfInstalledProtocols & NP_Ip );
            EnableWindow( pInfo->hwndPbIp,
                pInfo->dwfInstalledProtocols & NP_Ip );
            Button_SetCheck( pInfo->hwndCbIpx, FALSE );
            Button_SetCheck( pInfo->hwndCbNbf, FALSE );
            Button_SetCheck( pInfo->hwndCbSwCompression, FALSE );
            Button_SetCheck( pInfo->hwndCbLcpExtensions, FALSE );
            break;
        }

#ifdef AMB
        case BP_Ras:
        {
            if (pInfo->fMultiLinkMode)
            {
                MsgDlg( pInfo->hwndDlg, SID_MlinkNeedsPpp, NULL );
                ComboBox_SetCurSel( pInfo->hwndLbServerTypes,
                    pInfo->iLbServerTypes );
                return;
            }

            EnableWindow( pInfo->hwndCbIp, FALSE );
            EnableWindow( pInfo->hwndPbIp, FALSE );
            EnableWindow( pInfo->hwndCbIpx, FALSE );
            EnableWindow( pInfo->hwndCbNbf, TRUE );
            EnableWindow( pInfo->hwndCbLcpExtensions, FALSE );
            EnableWindow( pInfo->hwndCbSwCompression, TRUE );
            Button_SetCheck( pInfo->hwndCbIp, FALSE );
            EnableWindow( pInfo->hwndPbIp, FALSE );
            Button_SetCheck( pInfo->hwndCbIpx, FALSE );
            Button_SetCheck( pInfo->hwndCbNbf,
                pInfo->dwfInstalledProtocols & NP_Nbf );
            Button_SetCheck( pInfo->hwndCbSwCompression,
                pInfo->fSwCompression );
            Button_SetCheck( pInfo->hwndCbLcpExtensions, FALSE );
            break;
        }
#endif
    }

    /* Save current index so can back out of a selection later if necessary.
    ** Save base protocol so the BS:LbDevices can check it and decide if
    ** Multiple Lines is allowed.
    */
    pInfo->iLbServerTypes = iSel;
    pInfo->pArgs->pEntry->dwBaseProtocol = dwBaseProtocol;
}


VOID
SvProtocolNotInstalledPopup(
    IN PEINFO* pInfo,
    IN DWORD   dwSid )

    /* Popup a message explaining to user that the protocol is not installed
    ** and cannot be checked.  'PInfo' is the property sheet context.  'DwSid'
    ** is a string ID for a network protocol.
    */
{
    MSGARGS msgargs;
    TCHAR*  pszArg;

    pszArg = PszFromId( g_hinstDll, dwSid );
    if (!pszArg)
        return;

    ZeroMemory( &msgargs, sizeof(msgargs) );
    msgargs.apszArgs[ 0 ] = pszArg;
    MsgDlg( pInfo->hwndSv, SID_NpNotInstalled, &msgargs );
    Free( pszArg );
}


VOID
SvTcpipSettings(
    IN PEINFO* pInfo )

    /* Called when TCP/IP Settings button is pressed.  'PInfo' is the property
    ** sheet context.
    */
{
    DWORD dwBaseProtocol;

    dwBaseProtocol = (DWORD)ComboBox_GetItemData( pInfo->hwndLbServerTypes,
                         ComboBox_GetCurSel( pInfo->hwndLbServerTypes ) );

    if (dwBaseProtocol == BP_Ppp)
    {
        PppTcpipDlg(
            pInfo->hwndDlg, pInfo->pArgs->pEntry, pInfo->pArgs->fRouter );
    }
    else
    {
        ASSERT(dwBaseProtocol==BP_Slip);
        SlipTcpipDlg( pInfo->hwndDlg, pInfo->pArgs->pEntry );
    }
}


/*----------------------------------------------------------------------------
** Script property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
ScDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Script page of the Entry property sheet.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("ScDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return ScInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                PEINFO* pInfo = PeContext(hwnd);
                if (pInfo)
                {
                    ContextHelpHack( g_adwBsHelp, hwnd, unMsg, wparam, lparam,
        							 pInfo->pArgs->fRouter);
                }        							 
            }							 
            break;

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);

            return ScCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
ScCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("ScCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_SC_PB_Refresh:
        {
            INT    iSel;
            TCHAR* pszSel;

            iSel = ComboBox_GetCurSel( pInfo->hwndLbScript );
            if (iSel > 0)
                pszSel = ComboBox_GetPsz( pInfo->hwndLbScript, iSel );
            else
                pszSel = NULL;

            EuFillDoubleScriptsList(
                pInfo->pArgs, pInfo->hwndLbScript, pszSel );
            Free0( pszSel );

            return TRUE;
        }

        case CID_SC_PB_Edit:
        {
            TCHAR* psz;

            psz = GetText( pInfo->hwndLbScript );
            if (psz)
            {
                if (FileExists( psz ))
                    EuEditScpScript( pInfo->hwndDlg, psz );
                else
                    EuEditSwitchInf( pInfo->hwndDlg );

                Free( psz );
            }

            return TRUE;
        }

        case CID_SC_PB_Before:
        {
            BeforeDialDlg( pInfo->hwndDlg, pInfo->pArgs );
            return TRUE;
        }

        case CID_SC_RB_None:
        case CID_SC_RB_Terminal:
        case CID_SC_RB_Script:
        {
            /* Scripts listbox is gray unless script mode is selected.
            */
            if (wNotification == BN_CLICKED)
                EnableWindow( pInfo->hwndLbScript, (wId == CID_SC_RB_Script) );
            break;
        }
    }

    return FALSE;
}


BOOL
ScInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    PEINFO* pInfo;

    TRACE("ScInit");

    pInfo = PeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndSc = hwndPage;
    pInfo->hwndRbNone = GetDlgItem( hwndPage, CID_SC_RB_None );
    ASSERT(pInfo->hwndRbNone);
    pInfo->hwndRbTerminal = GetDlgItem( hwndPage, CID_SC_RB_Terminal );
    ASSERT(pInfo->hwndRbTerminal);
    pInfo->hwndRbScript = GetDlgItem( hwndPage, CID_SC_RB_Script );
    ASSERT(pInfo->hwndRbScript);
    pInfo->hwndLbScript = GetDlgItem( hwndPage, CID_SC_LB_Script );
    ASSERT(pInfo->hwndLbScript);
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_SC_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbRefresh = GetDlgItem( hwndPage, CID_SC_PB_Refresh );
    ASSERT(pInfo->hwndPbRefresh);

    /* Fill list boxes and set the selection.
    */
    EuFillDoubleScriptsList( pInfo->pArgs, pInfo->hwndLbScript,
        pInfo->pArgs->pEntry->pszScriptAfter );

    /* Select the correct modes.
    */
    {
        HWND  hwndRb;
        DWORD dwScriptMode;

        dwScriptMode = pInfo->pArgs->pEntry->dwScriptModeAfter;
        if (dwScriptMode == SM_Terminal && !pInfo->pArgs->fRouter)
            hwndRb = pInfo->hwndRbTerminal;
        else if (dwScriptMode == SM_Script)
            hwndRb = pInfo->hwndRbScript;
        else
            hwndRb = pInfo->hwndRbNone;

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    return TRUE;
}


/*----------------------------------------------------------------------------
** Security property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
SeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Security page of the Entry property sheet.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("SeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return SeInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                PEINFO* pInfo = PeContext(hwnd);
                if (pInfo)
                {
                    ContextHelpHack( g_adwBsHelp, hwnd, unMsg, wparam, lparam,
        							 pInfo->pArgs->fRouter);
                }        							 
            }							 
            break;

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);

            return SeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
SeCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("SeCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_SE_RB_AnyAuth:
        case CID_SE_RB_EncryptedAuth:
        {
            if (wNotification == BN_CLICKED)
            {
                EnableWindow( pInfo->hwndCbDataEncryption, FALSE );
                EnableWindow( pInfo->hwndCbStrongDataEncryption, FALSE );
                Button_SetCheck( pInfo->hwndCbDataEncryption, FALSE );
                Button_SetCheck( pInfo->hwndCbStrongDataEncryption, FALSE );

                pInfo->fStrongDataEncryption = FALSE;
                pInfo->fDataEncryption       = FALSE;

                if (!pInfo->pArgs->fRouter)
                {
                    EnableWindow( pInfo->hwndCbUseLogon, FALSE );
                    Button_SetCheck( pInfo->hwndCbUseLogon, FALSE );

                    pInfo->fUseLogon = FALSE;
                }
            }
            return TRUE;
        }

        case CID_SE_RB_MsEncryptedAuth:
        {
            if (wNotification == BN_CLICKED)
            {
                EnableWindow( pInfo->hwndCbDataEncryption, TRUE );
                Button_SetCheck( pInfo->hwndCbDataEncryption,
                    pInfo->fDataEncryption );

                if (!pInfo->pArgs->fRouter)
                {
                    EnableWindow( pInfo->hwndCbUseLogon, TRUE );
                    Button_SetCheck( pInfo->hwndCbUseLogon,
                        pInfo->fUseLogon );
                }

                if (pInfo->fDataEncryption)
                {
                    EnableWindow( pInfo->hwndCbStrongDataEncryption, TRUE );
                    Button_SetCheck( pInfo->hwndCbStrongDataEncryption,
                        pInfo->fStrongDataEncryption );
                }
                else
                {
                    EnableWindow( pInfo->hwndCbStrongDataEncryption, FALSE );
                }

                break;
            }
            return TRUE;
        }

        case CID_SE_CB_RequireDataEncryption:
        {
            if (wNotification == BN_CLICKED)
            {
                BOOL fChecked = Button_GetCheck( pInfo->hwndCbDataEncryption );

                if (!pInfo->fEncryptionPermitted && fChecked)
                {
                    MsgDlg( pInfo->hwndSe, SID_EncryptionBanned, NULL );
                    Button_SetCheck( pInfo->hwndCbDataEncryption, FALSE );
                    Button_SetCheck( pInfo->hwndCbStrongDataEncryption, FALSE );
                    break;
                }

                EnableWindow( pInfo->hwndCbStrongDataEncryption, fChecked );
                if (fChecked)
                {
                    Button_SetCheck( pInfo->hwndCbStrongDataEncryption,
                        pInfo->fStrongDataEncryption );
                }
                else
                {
                    Button_SetCheck( pInfo->hwndCbStrongDataEncryption,
                        FALSE );
                    pInfo->fStrongDataEncryption = FALSE;
                }

                pInfo->fDataEncryption = fChecked;
            }
            return TRUE;
        }

        case CID_SE_CB_RequireStrongDataEncryption:
        {
            if (wNotification == BN_CLICKED)
            {
                BOOL fChecked =
                    Button_GetCheck( pInfo->hwndCbStrongDataEncryption );

                pInfo->fStrongDataEncryption = fChecked;
            }
            return TRUE;
        }

        case CID_SE_CB_UseLogonCredentials:
        {
            if (wNotification == BN_CLICKED)
                pInfo->fUseLogon = Button_GetCheck( pInfo->hwndCbUseLogon );
            return TRUE;
        }

        case CID_SE_PB_UnsavePw:
        {
            DWORD          dwErr;
            RASCREDENTIALS rc;

            /* Uncache the password so user is prompted again.
            */
            ZeroMemory( &rc, sizeof(rc) );
            rc.dwSize = sizeof(rc);
            rc.dwMask = RASCM_Password;

            ASSERT(g_pRasSetCredentials);
            TRACE("RasSetCredentials(p,TRUE)");
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath, pInfo->pArgs->pszEntry,
                &rc, TRUE );
            TRACE1("RasSetCredentials=%d",dwErr);

            if (dwErr == 0)
            {
                /* No longer a cached password, so gray the button, but move
                ** the focus to OK first so keyboard only user is not stuck.
                */
                PostMessage( pInfo->hwndDlg, WM_NEXTDLGCTL,
                    (WPARAM )GetDlgItem( pInfo->hwndDlg, IDOK ), TRUE );
                EnableWindow( pInfo->hwndPbUnsavePw, FALSE );
            }
            else
                ErrorDlg( pInfo->hwndDlg, SID_OP_UncachePw, dwErr, NULL );

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
SeInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("SeInit");

    pInfo = PeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndSe = hwndPage;
    pInfo->hwndRbAnyAuth = GetDlgItem(
        hwndPage, CID_SE_RB_AnyAuth );
    ASSERT(pInfo->hwndRbAnyAuth);
    pInfo->hwndRbEncryptedAuth = GetDlgItem(
        hwndPage, CID_SE_RB_EncryptedAuth );
    ASSERT(pInfo->hwndRbEncryptedAuth);
    pInfo->hwndRbMsEncryptedAuth = GetDlgItem(
        hwndPage, CID_SE_RB_MsEncryptedAuth );
    ASSERT(pInfo->hwndRbMsEncryptedAuth);
    pInfo->hwndCbDataEncryption = GetDlgItem(
        hwndPage, CID_SE_CB_RequireDataEncryption );
    ASSERT(pInfo->hwndCbDataEncryption);
    pInfo->hwndCbStrongDataEncryption = GetDlgItem(
        hwndPage, CID_SE_CB_RequireStrongDataEncryption );
    ASSERT(pInfo->hwndCbStrongDataEncryption);
    pInfo->hwndPbUnsavePw = GetDlgItem(
        hwndPage, CID_SE_PB_UnsavePw );
    ASSERT(pInfo->hwndPbUnsavePw );
    pInfo->hwndCbSecureFiles = GetDlgItem(
        hwndPage, CID_SE_CB_SecureLocalFiles );
    ASSERT(pInfo->hwndCbSecureFiles );

    pEntry = pInfo->pArgs->pEntry;

    if (pInfo->pArgs->fRouter)
    {
        pInfo->hwndCbAuthenticateServer = GetDlgItem(
            hwndPage, CID_SE_CB_AuthenticateServer );
        ASSERT(pInfo->hwndCbAuthenticateServer);

        Button_SetCheck( pInfo->hwndCbAuthenticateServer,
            pEntry->fAuthenticateServer );
    }
    else
    {
        pInfo->hwndCbUseLogon = GetDlgItem(
            hwndPage, CID_SE_CB_UseLogonCredentials );
        ASSERT(pInfo->hwndCbUseLogon);
    }

    pInfo->fEncryptionPermitted = IsEncryptionPermitted();
    if (!pInfo->fEncryptionPermitted)
        pEntry->dwDataEncryption = DE_None;
    pInfo->fDataEncryption = (pEntry->dwDataEncryption >= DE_Weak);
    pInfo->fStrongDataEncryption = (pEntry->dwDataEncryption >= DE_Strong);
    pInfo->fUseLogon = pEntry->fAutoLogon;

    Button_SetCheck( pInfo->hwndCbSecureFiles, pEntry->fSecureLocalFiles );

    /* Select the correct authentication mode with a pseudo-click which will
    ** trigger enabling/disabling of checkbox state.
    */
    {
        HWND hwndRb;

        if (pEntry->dwAuthRestrictions == AR_AuthAny)
            hwndRb = pInfo->hwndRbAnyAuth;
        else if (pEntry->dwAuthRestrictions == AR_AuthEncrypted)
            hwndRb = pInfo->hwndRbEncryptedAuth;
        else
        {
            ASSERT(pEntry->dwAuthRestrictions==AR_AuthMsEncrypted);
            hwndRb = pInfo->hwndRbMsEncryptedAuth;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    if (pInfo->pArgs->fNoUser || pInfo->pArgs->fRouter)
    {
        /* Unsave password button is hidden during logon and when working on
        ** the router phonebook since passwords cannot be saved when dialing
        ** in those cases.
        */
        EnableWindow( pInfo->hwndPbUnsavePw, FALSE );
        ShowWindow( pInfo->hwndPbUnsavePw, SW_HIDE );
    }
    else
    {
        BOOL fEdit;
        BOOL fChanged;
        BOOL fSavedPw;

        /* Enable/disable the "Unsave password" button depending on the
        ** existence of a cached password.
        */
        fSavedPw = FALSE;
        EuGetEditFlags( pInfo->pArgs, &fEdit, &fChanged );
        //
        // !!! If RAS is not installed on the local system,
        // then we cannot call RasGetCredentials.  This is not
        // critical, since this only affects a router installation
        // and they do not use this functionality anyway.
        //
        if (fEdit && g_pRasGetCredentials != NULL)
        {
            DWORD          dwErrRc;
            RASCREDENTIALS rc;

            ZeroMemory( &rc, sizeof(rc) );
            rc.dwSize = sizeof(rc);
            rc.dwMask = RASCM_Password;

            ASSERT(g_pRasGetCredentials);
            TRACE("RasGetCredentials");
            dwErrRc = g_pRasGetCredentials(
                pInfo->pArgs->pFile->pszPath, pInfo->pArgs->pszEntry, &rc );
            TRACE2("RasGetCredentials=%d,m=%d",dwErrRc,rc.dwMask);

            if (dwErrRc == 0 && (rc.dwMask & RASCM_Password))
                fSavedPw = TRUE;
        }

        EnableWindow( pInfo->hwndPbUnsavePw, fSavedPw );
    }

    return TRUE;
}



/*----------------------------------------------------------------------------
** X.25 property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
XsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the X.25 page of the Entry property sheet.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("XsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return XsInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                PEINFO* pInfo = PeContext(hwnd);
                if (pInfo)
                {
                    ContextHelpHack( g_adwBsHelp, hwnd, unMsg, wparam, lparam,
        							 pInfo->pArgs->fRouter);
                }        							 
            }							 
            break;
    }

    return FALSE;
}


VOID
XsFillPadsList(
    IN PEINFO* pInfo,
    IN BOOL    fLocalPad )

    /* Fill PADs list if it's not already, and select the PAD from user's
    ** entry.  'PInfo' is the property sheet context.  'fLocalPad' is true if
    ** the entry device is a local PAD card, false otherwise.
    */
{
    DWORD    dwErr;
    INT      cPads;
    DTLNODE* pNode;
    INT      nIndex;

    TRACE("XsFillPadsList");

    cPads = ComboBox_GetCount( pInfo->hwndLbX25Pads );

    if (cPads > 1 || (fLocalPad && cPads == 1))
        return;

    ComboBox_ResetContent( pInfo->hwndLbX25Pads );
    ComboBox_AddItemFromId(
        g_hinstDll, pInfo->hwndLbX25Pads, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( pInfo->hwndLbX25Pads, 0 );

    if (!fLocalPad)
    {
        PBENTRY* pEntry;

        ASSERT(!pInfo->pListPads);
        dwErr = LoadPadsList( &pInfo->pListPads );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadX25Info, dwErr, NULL );
            return;
        }

        pEntry = pInfo->pArgs->pEntry;

        for (pNode = DtlGetFirstNode( pInfo->pListPads );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            TCHAR* psz;

            psz = (TCHAR* )DtlGetData( pNode );
            nIndex = ComboBox_AddString( pInfo->hwndLbX25Pads, psz );

            if (pEntry->pszX25Network
                && lstrcmp( psz, pEntry->pszX25Network ) == 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbX25Pads, nIndex );
            }
        }

        if (pEntry->pszX25Network
            && ComboBox_GetCurSel( pInfo->hwndLbX25Pads ) == 0)
        {
            /* PAD from phonebook is not in the PAD list.  Add it and select
            ** it.
            */
            nIndex = ComboBox_AddString(
                pInfo->hwndLbX25Pads, pEntry->pszX25Network );
            ComboBox_SetCurSel( pInfo->hwndLbX25Pads, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbX25Pads );
}


BOOL
XsInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;
    BOOL     fLocalPad;

    TRACE("XsInit");

    pInfo = PeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndXs = hwndPage;
    pInfo->hwndLbX25Pads = GetDlgItem( hwndPage, CID_XS_LB_Network );
    ASSERT(pInfo->hwndLbX25Pads);
    pInfo->hwndEbX25Address = GetDlgItem( hwndPage, CID_XS_EB_Address );
    ASSERT(pInfo->hwndEbX25Address);
    pInfo->hwndEbX25UserData = GetDlgItem( hwndPage, CID_XS_EB_UserData );
    ASSERT(pInfo->hwndEbX25UserData);
    pInfo->hwndEbX25Facilities = GetDlgItem( hwndPage, CID_XS_EB_Facilities );
    ASSERT(pInfo->hwndEbX25Facilities);

    /* Initialize page.
    */
    pEntry = pInfo->pArgs->pEntry;
    fLocalPad = IsLocalPad( pEntry );
    XsFillPadsList( pInfo, fLocalPad );

    Edit_LimitText( pInfo->hwndEbX25Address, RAS_MaxX25Address );
    if (pEntry->pszX25Address)
        SetWindowText( pInfo->hwndEbX25Address, pEntry->pszX25Address );

    Edit_LimitText( pInfo->hwndEbX25UserData, RAS_MaxUserData );
    if (pEntry->pszX25UserData)
        SetWindowText( pInfo->hwndEbX25UserData, pEntry->pszX25UserData );

    Edit_LimitText( pInfo->hwndEbX25Facilities, RAS_MaxFacilities );
    if (pEntry->pszX25Facilities)
        SetWindowText( pInfo->hwndEbX25Facilities, pEntry->pszX25Facilities );

    if (fLocalPad)
    {
        /* No point in setting focus to "X.25 Network" on local PAD, so set to
        ** X.25 Address field instead.
        */
        SetFocus( pInfo->hwndEbX25Address );
        Edit_SetSel( pInfo->hwndEbX25Address, 0, -1 );
        return FALSE;
    }

    return TRUE;
}


/*----------------------------------------------------------------------------
** (Router) Dialing property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the router-specific dialing page of the Entry
    ** property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("RdDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RdInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            {
                PEINFO* pInfo = PeContext(hwnd);
                if (pInfo)
                {
                    ContextHelpHack( g_adwBsHelp, hwnd, unMsg, wparam, lparam,
        							 pInfo->pArgs->fRouter);
                }        							 
            }							 
            break;

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);

            return RdCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RdCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("RdCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_RD_RB_Persistent:
        case CID_RD_RB_DemandDial:
        {
            BOOL fDemandDial;

            fDemandDial = (wId == CID_RD_RB_DemandDial);
            EnableWindow( pInfo->hwndStIdle, fDemandDial );
            EnableWindow( pInfo->hwndEbIdle, fDemandDial );
            return TRUE;
        }

        case CID_RD_PB_Callback:
        {
            RouterCallbackDlg( pInfo->hwndRd, pInfo->pArgs );
            return TRUE;
        }

        case CID_RD_PB_MultipleLines:
        {
            MultiLinkDialingDlg( pInfo->hwndRd, pInfo->pArgs->pEntry );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
RdInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;
    HWND     hwndUdAttempts;
    HWND     hwndUdSeconds;
    HWND     hwndUdIdle;

    TRACE("RdInit");

    pInfo = PeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    pInfo->hwndRd = hwndPage;
    pInfo->hwndRbPersistent = GetDlgItem( hwndPage, CID_RD_RB_Persistent );
    ASSERT(pInfo->hwndRbPersistent);
    pInfo->hwndRbDemand = GetDlgItem( hwndPage, CID_RD_RB_DemandDial );
    ASSERT(pInfo->hwndRbDemand);
    pInfo->hwndStAttempts = GetDlgItem( hwndPage, CID_RD_ST_Attempts );
    ASSERT(pInfo->hwndStAttempts);
    pInfo->hwndEbAttempts = GetDlgItem( hwndPage, CID_RD_EB_Attempts );
    ASSERT(pInfo->hwndEbAttempts);
    pInfo->hwndStSeconds = GetDlgItem( hwndPage, CID_RD_ST_Seconds );
    ASSERT(pInfo->hwndStSeconds);
    pInfo->hwndEbSeconds = GetDlgItem( hwndPage, CID_RD_EB_Seconds );
    ASSERT(pInfo->hwndEbSeconds);
    pInfo->hwndStIdle = GetDlgItem( hwndPage, CID_RD_ST_Idle );
    ASSERT(pInfo->hwndStIdle);
    pInfo->hwndEbIdle = GetDlgItem( hwndPage, CID_RD_EB_Idle );
    ASSERT(pInfo->hwndEbIdle);

    /* Initialize spin-button edit fields.
    */
    hwndUdAttempts = CreateUpDownControl(
        WS_CHILD + WS_VISIBLE + WS_BORDER +
            UDS_SETBUDDYINT + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
        0, 0, 0, 0, hwndPage, 100, g_hinstDll, pInfo->hwndEbAttempts,
        UD_MAXVAL, 0, 0 );
    ASSERT(hwndUdAttempts);
    Edit_LimitText( pInfo->hwndEbAttempts, 9 );
    SetDlgItemInt( hwndPage, CID_RD_EB_Attempts,
        pEntry->dwRedialAttempts, FALSE );

    hwndUdSeconds = CreateUpDownControl(
        WS_CHILD + WS_VISIBLE + WS_BORDER +
            UDS_SETBUDDYINT + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
        0, 0, 0, 0, hwndPage, 101, g_hinstDll, pInfo->hwndEbSeconds,
        UD_MAXVAL, 0, 0 );
    ASSERT(hwndUdSeconds);
    Edit_LimitText( pInfo->hwndEbSeconds, 9 );
    SetDlgItemInt( hwndPage, CID_RD_EB_Seconds,
        pEntry->dwRedialSeconds, FALSE );

    hwndUdIdle = CreateUpDownControl(
        WS_CHILD + WS_VISIBLE + WS_BORDER +
            UDS_SETBUDDYINT + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
        0, 0, 0, 0, hwndPage, 102, g_hinstDll, pInfo->hwndEbIdle,
        UD_MAXVAL, 0, 0 );
    ASSERT(hwndUdIdle);
    Edit_LimitText( pInfo->hwndEbIdle, 9 );
    SetDlgItemInt( hwndPage, CID_RD_EB_Idle,
        pEntry->dwIdleDisconnectSeconds, FALSE );

    /* Select the correct dialing option, triggering appropriate
    ** enabling/disabling.
    */
    {
        HWND  hwndRb;

        if (pEntry->fRedialOnLinkFailure)
            hwndRb = pInfo->hwndRbPersistent;
        else
            hwndRb = pInfo->hwndRbDemand;

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    return TRUE;
}


/*----------------------------------------------------------------------------
** Before Dial dialog
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

BOOL
BeforeDialDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo )

    /* Pops-up the Before Dial scripting dialog.  Initial settings are read
    ** from the working entry in common entry context 'pEinfo' and the result
    ** of user's edits written there on "OK" exit.  The common entry context
    ** scripts list is refreshed by this routine.  'HwndOwner' is the window
    ** owning the dialog.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    int nStatus;

    TRACE("BeforeDialDlg");

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (pEinfo->fRouter)
                ? MAKEINTRESOURCE( DID_BD_RouterBeforeDial )
                : MAKEINTRESOURCE( DID_BD_BeforeDial ),
            hwndOwner,
            BdDlgProc,
            (LPARAM )pEinfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
BdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Before Dial dialog.  Parameters and return
    ** value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("BdDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return BdInit( hwnd, (EINFO* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelpHack( g_adwBdHelp, hwnd, unMsg, wparam, lparam,
				 ((BDINFO *)GetWindowLongPtr(hwnd, DWLP_USER))->pArgs->fRouter);
            break;

        case WM_COMMAND:
        {
            BDINFO* pInfo = (BDINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return BdCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            BdTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
BdCommand(
    IN BDINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("BdCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_BD_PB_Refresh:
        {
            INT    iSel;
            TCHAR* pszSel;

            iSel = ComboBox_GetCurSel( pInfo->hwndLbScript );
            if (iSel > 0)
                pszSel = ComboBox_GetPsz( pInfo->hwndLbScript, iSel );
            else
                pszSel = NULL;

            EuFillScriptsList( pInfo->pArgs, pInfo->hwndLbScript, pszSel );
            Free0( pszSel );

            return TRUE;
        }

        case CID_BD_PB_Edit:
        {
            EuEditSwitchInf( pInfo->hwndDlg );
            return TRUE;
        }

        case CID_BD_RB_None:
        case CID_BD_RB_Terminal:
        case CID_BD_RB_Script:
        {
            /* Scripts listbox is gray unless script mode is selected.
            */
            if (wNotification == BN_CLICKED)
                EnableWindow( pInfo->hwndLbScript, (wId == CID_BD_RB_Script) );
            break;
        }

        case IDOK:
        {
            TRACE("OK pressed");
            BdSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
BdInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    ** dialog window.  'pArgs' is caller's argument to the stub API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    BDINFO* pInfo;

    TRACE("BdInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndRbNone = GetDlgItem( hwndDlg, CID_BD_RB_None );
    ASSERT(pInfo->hwndRbNone);
    pInfo->hwndRbTerminal = GetDlgItem( hwndDlg, CID_BD_RB_Terminal );
    ASSERT(pInfo->hwndRbTerminal);
    pInfo->hwndRbScript = GetDlgItem( hwndDlg, CID_BD_RB_Script );
    ASSERT(pInfo->hwndRbScript);
    pInfo->hwndLbScript = GetDlgItem( hwndDlg, CID_BD_LB_Script );
    ASSERT(pInfo->hwndLbScript);
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_BD_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbRefresh = GetDlgItem( hwndDlg, CID_BD_PB_Refresh );
    ASSERT(pInfo->hwndPbRefresh);

    /* Fill list boxes and set the selection.
    */
    EuFillScriptsList( pInfo->pArgs, pInfo->hwndLbScript,
        pInfo->pArgs->pEntry->pszScriptBefore );

    /* Select the correct modes.
    */
    {
        HWND  hwndRb;
        DWORD dwScriptMode;

        dwScriptMode = pArgs->pEntry->dwScriptModeBefore;
        if (dwScriptMode == SM_Terminal && !pArgs->fRouter)
            hwndRb = pInfo->hwndRbTerminal;
        else if (dwScriptMode == SM_Script)
            hwndRb = pInfo->hwndRbScript;
        else
            hwndRb = pInfo->hwndRbNone;

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    return TRUE;
}


VOID
BdSave(
    IN BDINFO* pInfo )

    /* Saves dialog settings in the entry.  'PInfo' is the dialog context.
    */
{
    INT      iSel;
    PBENTRY* pEntry;

    TRACE("BdSave");

    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    if (IsDlgButtonChecked( pInfo->hwndDlg, CID_BD_RB_None ))
        pEntry->dwScriptModeBefore = SM_None;
    else if (IsDlgButtonChecked( pInfo->hwndDlg, CID_BD_RB_Terminal ))
        pEntry->dwScriptModeBefore = SM_Terminal;
    else
        pEntry->dwScriptModeBefore = SM_Script;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbScript );
    Free0( pEntry->pszScriptBefore );
    if (iSel > 0)
        pEntry->pszScriptBefore = ComboBox_GetPsz( pInfo->hwndLbScript, iSel );
    else
        pEntry->pszScriptBefore = NULL;

    /* Silently fix-up "no script specified" error.
    */
    if (pEntry->dwScriptModeBefore == SM_Script && !pEntry->pszScriptBefore)
        pEntry->dwScriptModeBefore = SM_None;

    pEntry->fDirty = TRUE;
}


VOID
BdTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    BDINFO* pInfo = (BDINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("BdTerm");

    if (pInfo)
        Free( pInfo );
}


/*----------------------------------------------------------------------------
** (Router) Callback dialog
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/


BOOL
RouterCallbackDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo )

    /* Pops-up the (Router) Callback dialog.  Initial settings are read from
    ** the working entry (no/yes choice) and router user preferences (number
    ** list) in common entry context 'pEinfo' and the result of user's edits
    ** written there on "OK" exit.  'HwndOwner' is the window owning the
    ** dialog.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    int nStatus;

    TRACE("RouterCallbackDlg");

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CR_CallbackRouter ),
            hwndOwner,
            CrDlgProc,
            (LPARAM )pEinfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
CrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the (Router) Callback dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("CrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, CbutilLvNumbersCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CrInit( hwnd, (EINFO* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelpHack( g_adwCrHelp, hwnd, unMsg, wparam, lparam,
				   ((CRINFO *)GetWindowLongPtr(hwnd, DWLP_USER))->pArgs->fRouter);
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case NM_DBLCLK:
                {
                    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    SendMessage( pInfo->hwndPbEdit, BM_CLICK, 0, 0 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    CrUpdateLvAndPbState( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return CrCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CrTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CrCommand(
    IN CRINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("CrCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_CR_RB_No:
        case CID_CR_RB_Yes:
        {
            if (wNotification == BN_CLICKED)
            {
                CrUpdateLvAndPbState( pInfo );

                if (wId == CID_CR_RB_Yes
                    && ListView_GetSelectedCount( pInfo->hwndLvNumbers ) == 0)
                {
                    /* Nothing's selected, so select the first item, if any.
                    */
                    ListView_SetItemState( pInfo->hwndLvNumbers, 0,
                        LVIS_SELECTED, LVIS_SELECTED );
                }
            }
            break;
        }

        case CID_CR_PB_Edit:
        {
            if (wNotification == BN_CLICKED)
                CbutilEdit( pInfo->hwndDlg, pInfo->hwndLvNumbers );
            break;
        }

        case CID_CR_PB_Delete:
        {
            if (wNotification == BN_CLICKED)
                CbutilDelete( pInfo->hwndDlg, pInfo->hwndLvNumbers );
            break;
        }

        case IDOK:
        {
            TRACE("OK pressed");
            CrSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CrInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    ** dialog window.  'pArgs' is caller's argument to the stub API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    CRINFO* pInfo;

    TRACE("CrInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    /* Initialize page-specific context information.
    */
    pInfo->hwndRbNo = GetDlgItem( hwndDlg, CID_CR_RB_No );
    ASSERT(pInfo->hwndRbNo);
    pInfo->hwndRbYes = GetDlgItem( hwndDlg, CID_CR_RB_Yes );
    ASSERT(pInfo->hwndRbYes);
    pInfo->hwndLvNumbers = GetDlgItem( hwndDlg, CID_CR_LV_Numbers );
    ASSERT(pInfo->hwndLvNumbers);
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_CR_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_CR_PB_Delete );
    ASSERT(pInfo->hwndPbDelete);

    /* Initialize the listview.
    */
    CbutilFillLvNumbers(
        pInfo->hwndDlg, pInfo->hwndLvNumbers,
        pArgs->pUser->pdtllistCallback, pArgs->fRouter );

    /* Set the radio button selection, which triggers appropriate
    ** enabling/disabling.
    */
    {
        HWND  hwndRb;

        if (pArgs->pEntry->dwCallbackMode == CBM_No)
            hwndRb = pInfo->hwndRbNo;
        else
        {
            ASSERT(pArgs->pEntry->dwCallbackMode==CBM_Yes);
            hwndRb = pInfo->hwndRbYes;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    return TRUE;
}


VOID
CrSave(
    IN CRINFO* pInfo )

    /* Saves dialog settings in the entry.  'PInfo' is the dialog context.
    */
{
    PBENTRY* pEntry;

    TRACE("CrSave");

    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    if (IsDlgButtonChecked( pInfo->hwndDlg, CID_CR_RB_No ))
        pEntry->dwCallbackMode = CBM_No;
    else
        pEntry->dwCallbackMode = CBM_Yes;

    pEntry->dwfOverridePref |= RASOR_CallbackMode;
    pEntry->fDirty = TRUE;

    CbutilSaveLv(
        pInfo->hwndLvNumbers, pInfo->pArgs->pUser->pdtllistCallback );
}


VOID
CrTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("CrTerm");

    if (pInfo)
        Free( pInfo );
}


VOID
CrUpdateLvAndPbState(
    IN CRINFO* pInfo )

    /* Enables/disables the list view and associated buttons.  ListView is
    ** gray unless auto-callback is selected.  Buttons gray unless
    ** auto-callback selected and there is an item selected.
    */
{
    BOOL fEnableList;
    BOOL fEnableButton;

    fEnableList = Button_GetCheck( pInfo->hwndRbYes );
    if (fEnableList)
    {
        fEnableButton =
            ListView_GetSelectedCount( pInfo->hwndLvNumbers );
    }
    else
        fEnableButton = FALSE;

    EnableWindow( pInfo->hwndLvNumbers, fEnableList );
    EnableWindow( pInfo->hwndPbEdit, fEnableButton );
    EnableWindow( pInfo->hwndPbDelete, fEnableButton );
}

/*-----------------------------------------------------
** Utilities shared with router version of the listview
**-----------------------------------------------------
*/

VOID
CbutilDelete(
    IN HWND  hwndDlg,
    IN HWND  hwndLvNumbers )

    /* Called when the Delete button is pressed.  'PInfo' is the dialog
    ** context.
    */
{
    MSGARGS msgargs;
    INT     nResponse;

    TRACE("CbDelete");

    ZeroMemory( &msgargs, sizeof(msgargs) );
    msgargs.dwFlags = MB_YESNO + MB_ICONEXCLAMATION;
    nResponse = MsgDlg( hwndDlg, SID_ConfirmDelDevice, &msgargs );
    if (nResponse == IDYES)
    {
        INT iSel;

        /* User has confirmed deletion of selected devices, so do it.
        */
        while ((iSel = ListView_GetNextItem(
                           hwndLvNumbers, -1, LVNI_SELECTED )) >= 0)
        {
            ListView_DeleteItem( hwndLvNumbers, iSel );
        }
    }
}


VOID
CbutilEdit(
    IN HWND hwndDlg,
    IN HWND hwndLvNumbers )

    /* Called when the Edit button is pressed.  'HwndDlg' is the page/dialog
    ** window.  'HwndLvNumbers' is the callback number listview window.
    */
{
    INT    iSel;
    TCHAR  szBuf[ RAS_MaxCallbackNumber + 1 ];
    TCHAR* pszNumber;

    TRACE("CbutilEdit");

    /* Load 'szBuf' with the current phone number of the first selected item.
    */
    iSel = ListView_GetNextItem( hwndLvNumbers, -1, LVNI_SELECTED );
    if (iSel < 0)
        return;
    szBuf[ 0 ] = TEXT('\0');
    ListView_GetItemText( hwndLvNumbers, iSel, 1,
        szBuf, RAS_MaxCallbackNumber + 1 );

    /* Popup dialog to edit the number.
    */
    pszNumber = NULL;
    if (StringEditorDlg( hwndDlg, szBuf,
            SID_EcbnTitle, SID_EcbnLabel, RAS_MaxCallbackNumber,
            HID_ZE_ST_CallbackNumber, &pszNumber ))
    {
        /* OK pressed, so change the number on all selected items.
        */
        ASSERT(pszNumber);

        do
        {
            ListView_SetItemText( hwndLvNumbers, iSel, 1, pszNumber );
        }
        while ((iSel = ListView_GetNextItem(
                           hwndLvNumbers, iSel, LVNI_SELECTED )) >= 0);
    }
}


VOID
CbutilFillLvNumbers(
    IN HWND     hwndDlg,
    IN HWND     hwndLvNumbers,
    IN DTLLIST* pListCallback,
    IN BOOL     fRouter )

    /* Fill the listview with devices and phone numbers.  'HwndDlg' is the
    ** page/dialog window.  'HwndLvNumbers' is the callback listview.
    ** 'PListCallback' is the list of CALLBACKINFO.  'FRouter' is true if the
    ** router ports should be enumerated, or false for regular dial-out ports.
    **
    ** Note: This routine should be called only once.
    */
{
    DWORD    dwErr;
    DTLLIST* pListPorts;
    DTLNODE* pNodeCbi;
    DTLNODE* pNodePort;
    INT      iItem;
    TCHAR*   psz;

    TRACE("CbutilFillLvNumbers");

    ListView_DeleteAllItems( hwndLvNumbers );

    /* Add columns.
    */
    {
        LV_COLUMN col;
        TCHAR*    pszHeader0;
        TCHAR*    pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_DeviceColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_PhoneNumberColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( hwndLvNumbers, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( hwndLvNumbers, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( hwndLvNumbers, g_hinstDll );

    /* Load listview with callback device/number pairs saved as user
    ** preferences.
    */
    iItem = 0;
    ASSERT(pListCallback);
    for (pNodeCbi = DtlGetFirstNode( pListCallback );
         pNodeCbi;
         pNodeCbi = DtlGetNextNode( pNodeCbi ), ++iItem)
    {
        CALLBACKINFO* pCbi;
        LV_ITEM       item;

        pCbi = (CALLBACKINFO* )DtlGetData( pNodeCbi );
        ASSERT(pCbi);
        ASSERT(pCbi->pszPortName);
        ASSERT(pCbi->pszDeviceName);
        ASSERT(pCbi->pszNumber);

        psz = PszFromDeviceAndPort( pCbi->pszDeviceName, pCbi->pszPortName );
        if (psz)
        {
            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
            item.iItem = iItem;
            item.pszText = psz;
            item.iImage =
                ((PBDEVICETYPE )pCbi->dwDeviceType == PBDT_Modem)
                    ? DI_Modem : DI_Adapter;
            item.lParam = (LPARAM )pCbi->dwDeviceType;
            ListView_InsertItem( hwndLvNumbers, &item );
            ListView_SetItemText( hwndLvNumbers, iItem, 1, pCbi->pszNumber );
            Free( psz );
        }
    }

    /* Add any devices installed but not already in the list.
    */
    dwErr = LoadPortsList2( &pListPorts, fRouter );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadPortInfo, dwErr, NULL );
    }
    else
    {
        for (pNodePort = DtlGetFirstNode( pListPorts );
             pNodePort;
             pNodePort = DtlGetNextNode( pNodePort ))
        {
            PBPORT* pPort = (PBPORT* )DtlGetData( pNodePort );
            ASSERT(pPort);

            /* Look for the device/port in the callback list.
            */
            for (pNodeCbi = DtlGetFirstNode( pListCallback );
                 pNodeCbi;
                 pNodeCbi = DtlGetNextNode( pNodeCbi ))
            {
                CALLBACKINFO* pCbi;
                LV_ITEM       item;

                pCbi = (CALLBACKINFO* )DtlGetData( pNodeCbi );
                ASSERT(pCbi);
                ASSERT(pCbi->pszPortName);
                ASSERT(pCbi->pszDeviceName);

                if (lstrcmpi( pPort->pszPort, pCbi->pszPortName ) == 0
                    && lstrcmpi( pPort->pszDevice, pCbi->pszDeviceName ) == 0)
                {
                    break;
                }
            }

            if (!pNodeCbi)
            {
                LV_ITEM      item;
                PBDEVICETYPE pbdt;

                /* The device/port was not in the callback list.  Append it to
                ** the listview with empty phone number.
                */
                psz = PszFromDeviceAndPort( pPort->pszDevice, pPort->pszPort );
                if (psz)
                {
                    ZeroMemory( &item, sizeof(item) );
                    item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                    item.iItem = iItem;
                    item.pszText = psz;
                    item.iImage =
                        (pPort->pbdevicetype == PBDT_Modem)
                            ? DI_Modem : DI_Adapter;
                    item.lParam = (LPARAM )pPort->pbdevicetype;
                    ListView_InsertItem( hwndLvNumbers, &item );
                    ListView_SetItemText( hwndLvNumbers, iItem, 1, TEXT("") );
                    ++iItem;
                    Free( psz );
                }
            }
        }

        DtlDestroyList( pListPorts, DestroyPortNode );
    }

    /* Auto-size columns to look good with the text they contain.
    */
    ListView_SetColumnWidth( hwndLvNumbers, 0, LVSCW_AUTOSIZE_USEHEADER );
    ListView_SetColumnWidth( hwndLvNumbers, 1, LVSCW_AUTOSIZE_USEHEADER );
}


LVXDRAWINFO*
CbutilLvNumbersCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 2, 0, LVXDI_Blend50Dis + LVXDI_DxFill, { 0, 0 } };

    return &info;
}


VOID
CbutilSaveLv(
    IN  HWND     hwndLvNumbers,
    OUT DTLLIST* pListCallback )

    /* Replace list 'pListCallback' contents with that of the listview
    ** 'hwndLvNumbers'.
    */
{
    DTLNODE* pNode;
    INT      i;

    TRACE("CbutilSaveLv");

    /* Empty the list of callback info, then re-populate from the listview.
    */
    while (pNode = DtlGetFirstNode( pListCallback ))
    {
        DtlRemoveNode( pListCallback, pNode );
        DestroyCallbackNode( pNode );
    }

    i = -1;
    while ((i = ListView_GetNextItem( hwndLvNumbers, i, LVNI_ALL )) >= 0)
    {
        LV_ITEM item;
        TCHAR*  pszDevice;
        TCHAR*  pszPort;

        TCHAR szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
        TCHAR szNumber[ RAS_MaxCallbackNumber + 1 ];

        szDP[ 0 ] = TEXT('\0');
        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.pszText = szDP;
        item.cchTextMax = sizeof(szDP) / sizeof(TCHAR);
        if (!ListView_GetItem( hwndLvNumbers, &item ))
            continue;

        szNumber[ 0 ] = TEXT('\0');
        ListView_GetItemText( hwndLvNumbers, i, 1,
            szNumber, RAS_MaxCallbackNumber + 1 );

        if (!DeviceAndPortFromPsz( szDP, &pszDevice, &pszPort ))
            continue;

        pNode = CreateCallbackNode(
                    pszPort, pszDevice, szNumber, (DWORD )item.lParam );
        if (pNode)
            DtlAddNodeLast( pListCallback, pNode );

        Free( pszDevice );
        Free( pszPort );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\entry.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** entry.h
** Remote Access Common Dialog APIs
** Phonebook entry property sheet and wizard header
**
** 06/18/95 Steve Cobb
*/

#ifndef _ENTRY_H_
#define _ENTRY_H_


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Phonebook Entry common block.
*/
#define EINFO struct tagEINFO
EINFO
{
    /* RAS API arguments.  The only fields filled when WM_INITDIALOG is
    ** processed.
    */
    TCHAR*       pszPhonebook;
    TCHAR*       pszEntry;
    RASENTRYDLG* pApiArgs;

    /* Set true by property sheet or wizard if changes should be commited.
    */
    BOOL fCommit;

    /* Set by the add entry wizard if user chooses to end the wizard and go
    ** edit the properties directly.
    */
    BOOL fChainPropertySheet;

    /* Set by the add-entry wizard if the selected port is an X.25 PAD
    */
    BOOL fPadSelected;

    /* Phonebook settings read from the phonebook file.  All access should be
    ** thru 'pFile' as 'file' will only be used in cases where the open
    ** phonebook is not passed thru the reserved word hack.
    */
    PBFILE* pFile;
    PBFILE  file;

    /* Global preferences read via phonebook library.  All access should be
    ** thru 'pUser' as 'user' will only be used in cases where the preferences
    ** are not passed thru the reserved word hack.
    */
    PBUSER* pUser;
    PBUSER  user;

    /* Set if "no user before logon" mode.
    */
    BOOL fNoUser;

    /* Set if there are no ports configured, though a bogus "uninstalled"
    ** unimodem is added to the list of links in this case.
    */
    BOOL fNoPortsConfigured;

    /* List of scripts initialized by EuFill{Double}ScriptsList, if necessary,
    ** and freed by EuFree.
    */
    DTLLIST* pListScripts;
    DTLLIST* pListDoubleScripts;

    /* Property sheet will initialize to the country list only if necessary,
    ** but if allocated must be released after commitment.
    */
    COUNTRY* pCountries;
    DWORD    cCountries;

    /* The node being edited (still in the list), and the original entry name
    ** for use in comparison later.  These are valid in "edit" case only.
    */
    DTLNODE* pOldNode;
    TCHAR    szOldEntryName[ RAS_MaxEntryName + 1 ];

    /* The work entry node containing and a shortcut pointer to the entry
    ** inside.
    */
    DTLNODE* pNode;
    PBENTRY* pEntry;

    /* Set if we have been called via RouterEntryDlg().
    */ 
    BOOL    fRouter;
    TCHAR*  pszRouter;

    /* Dial-out user info for router; used by AiWizard.
    ** Used to set interface credentials via MprAdminInterfaceSetCredentials.
    */
    TCHAR*  pszRouterUserName;
    TCHAR*  pszRouterDomain;
    TCHAR*  pszRouterPassword;

    /* Dial-in user info for router (optional); used by AiWizard.
    ** Used to create dial-in user account via NetUserAdd;
    ** the user name for the account is the interface (phonebook entry) name.
    */
    BOOL    fAddUser;
    TCHAR*  pszRouterDialInPassword;
};


/*----------------------------------------------------------------------------
** Prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
AeWizard(
    IN OUT EINFO* pEinfo );

VOID
AiWizard(
    IN OUT EINFO* pEinfo );

VOID
EuLbCountryCodeSelChange(
    IN EINFO* pEinfo,
    IN HWND   hwndLbCountryCodes );

VOID
EuEditScpScript(
    IN HWND   hwndOwner,
    IN TCHAR* pszScript );

VOID
EuEditSwitchInf(
    IN HWND hwndOwner );

VOID
EuFillAreaCodeList(
    IN EINFO* pEinfo,
    IN HWND   hwndClbAreaCodes );

VOID
EuFillCountryCodeList(
    IN EINFO* pEinfo,
    IN HWND   hwndLbCountryCodes,
    IN BOOL   fComplete );

VOID
EuFillDoubleScriptsList(
    IN EINFO* pEinfo,
    IN HWND   hwndLbScripts,
    IN TCHAR* pszSelection );

VOID
EuFillScriptsList(
    IN EINFO* pEinfo,
    IN HWND   hwndLbScripts,
    IN TCHAR* pszSelection );

VOID
EuFree(
    IN EINFO* pInfo );

VOID
EuGetEditFlags(
    IN  EINFO* pEinfo,
    OUT BOOL*  pfEditMode,
    OUT BOOL*  pfChangedNameInEditMode );

DWORD
EuInit0(
    IN  TCHAR*       pszPhonebook,
    IN  TCHAR*       pszEntry,
    IN  RASENTRYDLG* pArgs,
    OUT EINFO*       pInfo,
    OUT DWORD*       pdwOp );

DWORD
EuInit(
    OUT EINFO* pInfo,
    OUT DWORD* pdwOp );

VOID
EuPhoneNumberStashFromEntry(
    IN     EINFO*    pEinfo,
    IN OUT DTLLIST** ppListPhoneNumbers,
    OUT    BOOL*     pfPromoteHuntNumbers );

VOID
EuPhoneNumberStashToEntry(
    IN EINFO*   pEinfo,
    IN DTLLIST* pListPhoneNumbers,
    IN BOOL     fPromoteHuntNumbers,
    IN BOOL     fAllEnabled );

VOID
EuSaveCountryInfo(
    IN EINFO* pEinfo,
    IN HWND   hwndLbCountryCodes );

BOOL
EuValidateAreaCode(
    IN HWND   hwndOwner,
    IN EINFO* pEinfo );

BOOL
EuValidateName(
    IN HWND   hwndOwner,
    IN EINFO* pEinfo );

VOID
PePropertySheet(
    IN OUT EINFO* pEinfo );


#endif // _ENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\ifw.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** ifw.c
** Remote Access Common Dialog APIs
** Add Interface wizard
**
** 02/11/97 Abolade Gbadegesin (based on entryw.c, by Steve Cobb).
*/

#include "rasdlgp.h"
#include "entry.h"

/* Page definitions.
*/
#define AI_InPage    0
#define AI_SsPage    1
#define AI_RnPage    2
#define AI_RpPage    3
#define AI_RaPage    4
#define AI_NsPage    5
#define AI_RcPage    6
#define AI_DoPage    7
#define AI_DiPage    8
#define AI_RfPage    9
#define AI_PageCount 10


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* Add Interface wizard context block.  All property pages refer to the single
** context block associated with the sheet.
*/
#define AIINFO struct tagAIINFO
AIINFO
{
    /* Common input arguments.
    */
    EINFO* pArgs;

    /* Wizard and page handles.  'hwndFirstPage' is the handle of the first
    ** property page initialized.  This is the page that allocates and frees
    ** the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndIn;
    HWND hwndSs;
    HWND hwndRn;
    HWND hwndRp;
    HWND hwndRc;
    HWND hwndRa;
    HWND hwndNs;
    HWND hwndDo;
    HWND hwndDi;
    HWND hwndRf;

    /* Interface Name page.
    */
    HWND hwndEbInterfaceName;

    /* Modem/Adapter page.
    */
    HWND hwndLv;

    /* Phone number page.
    */
    HWND hwndStNumber;
    HWND hwndEbNumber;
    HWND hwndPbAlternates;

    /* Login script page.
    */
    HWND hwndRbNone;
    HWND hwndRbScript;
    HWND hwndLbScripts;
    HWND hwndPbEdit;
    HWND hwndPbRefresh;

    /* IP address page.
    */
    HWND hwndCcIp;

    /* Name server page.
    */
    HWND hwndCcDns;
    HWND hwndCcWins;

    /* Dial-out credentials page.
    */
    HWND hwndDoEbUserName;
    HWND hwndDoEbDomain;
    HWND hwndDoEbPassword;
    HWND hwndDoEbConfirm;

    /* Dial-in credentials page.
    */
    HWND hwndDiEbUserName;
    HWND hwndDiEbDomain;
    HWND hwndDiEbPassword;
    HWND hwndDiEbConfirm;

    /* The phone number stash.  This allows user to change the port to another
    ** link without losing the phone number he typed.  Initialized to empty in
    ** AiInit and saved to entry in AiFinish.
    */
    DTLLIST* pListPhoneNumbers;
    BOOL     fPromoteHuntNumbers;

    /* Checkbox options chosen by user.
    */
    BOOL fIp;
    BOOL fIpx;
    BOOL fClearPwOk;
    BOOL fNotNt;

    /* Set true when there is only one meaningful choice of device.
    */
    BOOL fSkipMa;

    /* Set true if the selected device is a modem or null modem.
    */
    BOOL fModem;

    /* The NP_* mask of protocols configured for RAS.
    */
    DWORD dwfConfiguredProtocols;

    /* Set true if IP is configured for RAS.
    */
    BOOL fIpConfigured;
    BOOL fIpxConfigured;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

int CALLBACK
AiCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam );

VOID
AiCancel(
    IN HWND hwndPage );

AIINFO*
AiContext(
    IN HWND hwndPage );

VOID
AiExit(
    IN AIINFO* pInfo,
    IN DWORD   dwError );

VOID
AiExitInit(
    IN HWND hwndDlg );

BOOL
AiFinish(
    IN HWND hwndPage );

AIINFO*
AiInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs );

VOID
AiTerm(
    IN HWND hwndPage );

INT_PTR CALLBACK
DiDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DiInit(
    IN HWND   hwndPage );

BOOL
DiKillActive(
    IN AIINFO* pInfo );

BOOL
DiSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
DoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DoInit(
    IN HWND   hwndPage );

BOOL
DoKillActive(
    IN AIINFO* pInfo );

BOOL
DoSetActive(
    IN AIINFO* pInfo );

BOOL
InCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
InDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
InInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs );

BOOL
InKillActive(
    IN AIINFO* pInfo );

BOOL
InSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
NsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NsInit(
    IN HWND   hwndPage );

BOOL
NsKillActive(
    IN AIINFO* pInfo );

BOOL
NsSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RaInit(
    IN HWND hwndPage );

BOOL
RaKillActive(
    IN AIINFO* pInfo );

BOOL
RaSetActive(
    IN AIINFO* pInfo );

BOOL
RcCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RcInit(
    IN HWND hwndPage );

BOOL
RcKillActive(
    IN AIINFO* pInfo );

BOOL
RcSetActive(
    IN AIINFO* pInfo );

BOOL
RfCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RfDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RfInit(
    IN HWND hwndPage );

BOOL
RfSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RnInit(
    IN HWND hwndPage );

LVXDRAWINFO*
RnLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
RnLvItemChanged(
    IN AIINFO* pInfo );

BOOL
RnSetActive(
    IN AIINFO* pInfo );

VOID
RpAlternates(
    IN AIINFO* pInfo );

BOOL
RpCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RpInit(
    IN HWND hwndPage );

BOOL
RpKillActive(
    IN AIINFO* pInfo );

VOID
RpPhoneNumberToStash(
    IN AIINFO* pInfo );

BOOL
RpSetActive(
    IN AIINFO* pInfo );

BOOL
SsCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SsInit(
    IN HWND hwndPage );

BOOL
SsKillActive(
    IN AIINFO* pInfo );

BOOL
SsSetActive(
    IN AIINFO* pInfo );


/*----------------------------------------------------------------------------
** Add Interface wizard entry point
**----------------------------------------------------------------------------
*/

VOID
AiWizard(
    IN OUT EINFO* pEinfo )

    /* Runs the Phonebook entry property sheet.  'PEinfo' is an input block
    ** with only caller's API arguments filled in.
    */
{
    DWORD           dwErr;
    PROPSHEETHEADER header;
    PROPSHEETPAGE   apage[ AI_PageCount ];
    PROPSHEETPAGE*  ppage;

    TRACE("AiWizard");

    ZeroMemory( &header, sizeof(header) );

    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_USECALLBACK;
    header.hwndParent = pEinfo->pApiArgs->hwndOwner;
    header.hInstance = g_hinstDll;
    header.nPages = AI_PageCount;
    header.ppsp = apage;
    header.pfnCallback = AiCallbackFunc;

    ZeroMemory( apage, sizeof(apage) );

    ppage = &apage[ AI_InPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_IN_InterfaceName );
    ppage->pfnDlgProc = InDlgProc;
    ppage->lParam = (LPARAM )pEinfo;

    ppage = &apage[ AI_SsPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_SS_ServerSettings );
    ppage->pfnDlgProc = SsDlgProc;

    ppage = &apage[ AI_RnPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_RN_RouterModemAdapter );
    ppage->pfnDlgProc = RnDlgProc;

    ppage = &apage[ AI_RpPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_RP_RouterPhoneNumber );
    ppage->pfnDlgProc = RpDlgProc;

    ppage = &apage[ AI_RaPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_RA_RouterIpAddress );
    ppage->pfnDlgProc = RaDlgProc;

    ppage = &apage[ AI_NsPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_NS_RouterNameServers );
    ppage->pfnDlgProc = NsDlgProc;

    ppage = &apage[ AI_RcPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_RC_RouterScripting );
    ppage->pfnDlgProc = RcDlgProc;

    ppage = &apage[ AI_DoPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_DO_RouterDialOut );
    ppage->pfnDlgProc = DoDlgProc;

    ppage = &apage[ AI_DiPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_DI_RouterDialIn );
    ppage->pfnDlgProc = DiDlgProc;

    ppage = &apage[ AI_RfPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_RF_RouterFinish );
    ppage->pfnDlgProc = RfDlgProc;

    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg( pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN,
            NULL );
    }
}


/*----------------------------------------------------------------------------
** Add Interface wizard
** Listed alphabetically
**----------------------------------------------------------------------------
*/

int CALLBACK
AiCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    /* A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    **
    ** Returns 0 always.
    */
{
    TRACE2("AiCallbackFunc(m=%d,l=%08x)",unMsg,lparam);

    if (unMsg == PSCB_PRECREATE)
    {
        DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
        pDlg->style &= ~(DS_CONTEXTHELP);
    }

    return 0;
}


VOID
AiCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a wizard page.
    */
{
    TRACE("AiCancel");
}


AIINFO*
AiContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a wizard page handle.
    */
{
    return (AIINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


VOID
AiExit(
    IN AIINFO* pInfo,
    IN DWORD   dwError )

    /* Forces an exit from the dialog, reporting 'dwError' to the caller.
    ** 'PInfo' is the dialog context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See AiExitInit.
    */
{
    TRACE("AiExit");

    pInfo->pArgs->pApiArgs->dwError = dwError;
    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
AiExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within AiInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


BOOL
AiFinish(
    IN HWND hwndPage )

    /* Saves the contents of the wizard.  'HwndPage is the handle of a
    ** property page.  Pops up any errors that occur.  'FPropertySheet'
    ** indicates the user chose to edit the property sheet directly.
    **
    ** Returns true is page can be dismissed, false otherwise.
    */
{
    const TCHAR* pszIp0 = TEXT("0.0.0.0");

    AIINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("AiFinish");

    pInfo = AiContext( hwndPage );
    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    /* Attach the stashed phone number information to the final link(s).
    */
    EuPhoneNumberStashToEntry( pInfo->pArgs, pInfo->pListPhoneNumbers,
        pInfo->fPromoteHuntNumbers, TRUE );

    /* Update some settings based on user selections.
    */
    if (pInfo->fNotNt)
    {
        pEntry->fLcpExtensions = FALSE;
        pEntry->fSwCompression = FALSE;
    }

    if (!pInfo->fClearPwOk)
        pEntry->dwAuthRestrictions = AR_AuthEncrypted;

    if (!pInfo->fIp)
        pEntry->dwfExcludedProtocols |= NP_Ip;

    if (!pInfo->fIpx)
        pEntry->dwfExcludedProtocols |= NP_Ipx;

    if (pEntry->pszIpAddress
        && lstrcmp( pEntry->pszIpAddress, pszIp0 ) != 0)
    {
        pEntry->dwIpAddressSource = ASRC_RequireSpecific;
    }

    if ((pEntry->pszIpDnsAddress
             && lstrcmp( pEntry->pszIpDnsAddress, pszIp0 ) != 0)
        || (pEntry->pszIpWinsAddress
             && lstrcmp( pEntry->pszIpWinsAddress, pszIp0 ) != 0))
    {
        pEntry->dwIpNameSource = ASRC_RequireSpecific;
    }

    /* It's a valid new entry and caller has not chosen to edit properties
    ** directly, so mark the entry for commitment.
    */
    if (!pInfo->pArgs->fChainPropertySheet)
        pInfo->pArgs->fCommit = TRUE;

    return TRUE;
}


AIINFO*
AiInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs )

    /* Wizard level initialization.  'HwndPage' is the handle of the first
    ** page.  'PArgs' is the common entry input argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** wizard has been cancelled.
    */
{
    DWORD   dwErr;
    DWORD   dwOp;
    AIINFO* pInfo;
    HWND    hwndDlg;

    TRACE("AiInit");

    hwndDlg = GetParent( hwndFirstPage );

    /* Allocate the context information block.  Initialize it enough so that
    ** it can be destroyed properly, and associate the context with the
    ** window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE("Context NOT allocated");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            AiExitInit( hwndDlg );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(AIINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE("Context NOT set");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            pArgs->pApiArgs->dwError = ERROR_UNKNOWN;
            Free( pInfo );
            AiExitInit( hwndDlg );
            return NULL;
        }

        TRACE("Context set");
    }

    /* Position the dialog per caller's instructions.
    */
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    /* Mess with the title bar gadgets.
    */
    TweakTitleBar( hwndDlg );

#if 0
    /* Load MPRAPI DLL entrypoints which starts RASMAN, if necessary.
    */
    dwErr = LoadMpradminDll( );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadRas, dwErr, NULL );
        pArgs->pApiArgs->dwError = dwErr;
        AiExitInit( hwndDlg );
        return NULL;
    }
#endif

    /* Load the common entry information.
    ** Note that EuInit assumes that EuInit0 has previously been called.
    */
    dwErr = EuInit( pArgs, &dwOp );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, dwOp, dwErr, NULL );
        pArgs->pApiArgs->dwError = dwErr;
        AiExitInit( hwndDlg );
        return NULL;
    }

    /* Initialize these meta-flags that are not actually stored.
    */
    pInfo->fNotNt = FALSE;
    pInfo->fSkipMa = FALSE;
    pInfo->fModem = FALSE;
    pInfo->pArgs->fPadSelected = FALSE;
    pInfo->dwfConfiguredProtocols = g_pGetInstalledProtocols();
    pInfo->fIpConfigured = (pInfo->dwfConfiguredProtocols & NP_Ip);
    pInfo->fIpxConfigured = (pInfo->dwfConfiguredProtocols & NP_Ipx);

    /* Initialize the phone number stash to from the entry, i.e. set it to
    ** empty default.  The stash list is edited rather than the list in the
    ** entry so user can change active links without losing the phone number
    ** he entered.
    */
    EuPhoneNumberStashFromEntry( pArgs, &pInfo->pListPhoneNumbers,
        &pInfo->fPromoteHuntNumbers );

    return pInfo;
}


VOID
AiTerm(
    IN HWND hwndPage )

    /* Wizard level termination.  Releases the context block.  'HwndPage' is
    ** the handle of a property page.
    */
{
    AIINFO* pInfo;

    TRACE("AiTerm");

    pInfo = AiContext( hwndPage );
    if (pInfo)
    {
        DtlDestroyList( pInfo->pListPhoneNumbers, DestroyPszNode );

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}



/*----------------------------------------------------------------------------
** Dial-In Credentials property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DiDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Dial-in Credentials page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                DiInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DiSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DiSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DiKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DiKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}



BOOL
DiInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("DiInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndDi = hwndPage;
    pInfo->hwndDiEbUserName = GetDlgItem( hwndPage, CID_DI_EB_UserName );
    Edit_LimitText( pInfo->hwndDiEbUserName, UNLEN );
    pInfo->hwndDiEbDomain = GetDlgItem( hwndPage, CID_DI_EB_Domain );
    Edit_LimitText( pInfo->hwndDiEbDomain, DNLEN );
    pInfo->hwndDiEbPassword = GetDlgItem( hwndPage, CID_DI_EB_Password );
    Edit_LimitText( pInfo->hwndDiEbPassword, PWLEN );
    pInfo->hwndDiEbConfirm = GetDlgItem( hwndPage, CID_DI_EB_Confirm );
    Edit_LimitText( pInfo->hwndDiEbConfirm, PWLEN );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}




BOOL
DiKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText(pInfo->hwndDiEbPassword);
    if (psz)
    {
        TCHAR* psz2;

        psz2 = GetText(pInfo->hwndDiEbConfirm);
        if (psz2)
        {

            if (lstrcmp(psz, psz2))
            {
                Free(psz);
                Free(psz2);
                MsgDlg(pInfo->hwndDlg, SID_PasswordMismatch, NULL);
                SetFocus(pInfo->hwndDiEbPassword);
                return TRUE;
            }

            Free(psz2);
            Free0(pInfo->pArgs->pszRouterDialInPassword);
            pInfo->pArgs->pszRouterDialInPassword = psz;
        }            
        else
        {
            Free(psz);
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DiSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    /* The dialog is only displayed if the user is adding a dial-in account.
    */
    if (!pInfo->pArgs->fAddUser)
        return FALSE;

    /* Display the interface name in the disabled edit-box
    */
    SetWindowText(
        pInfo->hwndDiEbUserName, pInfo->pArgs->pEntry->pszEntryName );

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}




/*----------------------------------------------------------------------------
** Dial-Out Credentials property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Dial-Out Credentials page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                DoInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DoSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DoSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DoKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}



BOOL
DoInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("DoInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndDo = hwndPage;
    pInfo->hwndDoEbUserName = GetDlgItem( hwndPage, CID_DO_EB_UserName );
    Edit_LimitText( pInfo->hwndDoEbUserName, UNLEN );
    pInfo->hwndDoEbDomain = GetDlgItem( hwndPage, CID_DO_EB_Domain );
    Edit_LimitText( pInfo->hwndDoEbDomain, DNLEN );
    pInfo->hwndDoEbPassword = GetDlgItem( hwndPage, CID_DO_EB_Password );
    Edit_LimitText( pInfo->hwndDoEbPassword, PWLEN );
    pInfo->hwndDoEbConfirm = GetDlgItem( hwndPage, CID_DO_EB_Confirm );
    Edit_LimitText( pInfo->hwndDoEbConfirm, PWLEN );

    /* Use the target router name as the default "User name",
    */
    if (pInfo->pArgs->pszRouter)
    {
        if (pInfo->pArgs->pszRouter[0] == TEXT('\\') &&
            pInfo->pArgs->pszRouter[1] == TEXT('\\'))
            SetWindowText(pInfo->hwndDoEbUserName, pInfo->pArgs->pszRouter+2);
        else
            SetWindowText(pInfo->hwndDoEbUserName, pInfo->pArgs->pszRouter);
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}




BOOL
DoKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText(pInfo->hwndDoEbUserName);
    if (psz)
    {
        if (!lstrlen(psz))
        {
            Free(psz);
            MsgDlg(pInfo->hwndDlg, SID_DialOutUserName, NULL);
            SetFocus(pInfo->hwndDoEbUserName);
            return TRUE;
        }

        Free0(pInfo->pArgs->pszRouterUserName);
        pInfo->pArgs->pszRouterUserName = psz;
    }

    psz = GetText(pInfo->hwndDoEbDomain);
    if (psz)
    {
        Free0(pInfo->pArgs->pszRouterDomain);
        pInfo->pArgs->pszRouterDomain = psz;
    }

    psz = GetText(pInfo->hwndDoEbPassword);
    if (psz)
    {
        TCHAR* psz2;

        psz2 = GetText(pInfo->hwndDoEbConfirm);

        if (psz2 == NULL)
        {
            Free(psz);
            return TRUE;
        }

        if (lstrcmp(psz, psz2))
        {
            Free(psz);
            Free(psz2);
            MsgDlg(pInfo->hwndDlg, SID_PasswordMismatch, NULL);
            SetFocus(pInfo->hwndDoEbPassword);
            return TRUE;
        }

        Free(psz2);
        Free0(pInfo->pArgs->pszRouterPassword);
        pInfo->pArgs->pszRouterPassword = psz;
    }

    return FALSE;
}


BOOL
DoSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    TCHAR* psz;

    /* Fill in the interface name in the explanatory text.
    */
    psz = PszFromId( g_hinstDll, SID_RouterDialOut );
    if (psz)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pArgs->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;
        msgargs.pszString = psz;

        MsgDlgUtil( NULL, 0, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( pInfo->hwndDo, CID_DO_ST_Explain,
                msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }

        Free( psz );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Interface Name property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
InDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Interface Name page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("InDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                InInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("InRESET");
                    AiCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("InSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = InSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("InKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = InKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    AIINFO* pInfo;

                    TRACE("InWIZFINISH");

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);

                    /* You'd think pressing Finish would trigger a KILLACTIVE
                    ** event, but it doesn't, so we do it ourselves.
                    */
                    InKillActive( pInfo );

                    /* Set "no wizard" user preference, per user's check.
                    */
                    pInfo->pArgs->pUser->fNewEntryWizard = FALSE;
                    pInfo->pArgs->pUser->fDirty = TRUE;
                    SetUserPreferences(
                        pInfo->pArgs->pUser,
                        pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                    pInfo->pArgs->fPadSelected = FALSE;
                    pInfo->pArgs->fChainPropertySheet = TRUE;
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);

            return InCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            AiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
InCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("InCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_IN_CB_SkipWizard:
        {
            if (IsDlgButtonChecked( pInfo->hwndIn, CID_IN_CB_SkipWizard ))
                PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_FINISH );
            else
                PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
InInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("InInit");

    /* We're first page, so initialize the wizard.
    */
    pInfo = AiInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndIn = hwndPage;
    pInfo->hwndEbInterfaceName =
        GetDlgItem( hwndPage, CID_IN_EB_InterfaceName );
    ASSERT(pInfo->hwndEbInterfaceName);

    /* Initialize the entry name field.
    */
    pEntry = pInfo->pArgs->pEntry;
    if (!pEntry->pszEntryName)
    {
        /* No entry name, so think up a default.
        */
        dwErr = GetDefaultEntryName(
            pInfo->pArgs->pFile->pdtllistEntries,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPage, dwErr, NULL );
            AiExit( pInfo, dwErr );
            return TRUE;
        }
    }

    Edit_LimitText( pInfo->hwndEbInterfaceName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbInterfaceName, pEntry->pszEntryName );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return TRUE;
}


BOOL
InKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEbInterfaceName );
    if (psz)
    {
        /* Update the entry name from the editbox.
        */
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = psz;

        /* Validate the entry name.
        */
        if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
        {
            SetFocus( pInfo->hwndEbInterfaceName );
            Edit_SetSel( pInfo->hwndEbInterfaceName, 0, -1 );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
InSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Name Servers property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
NsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Name Servers page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                NsInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("NsSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = NsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("NsKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = NsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}



BOOL
NsInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("NsInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndNs = hwndPage;
    pInfo->hwndCcDns = GetDlgItem( hwndPage, CID_NS_CC_Dns );
    ASSERT(pInfo->hwndCcDns);
    pInfo->hwndCcWins = GetDlgItem( hwndPage, CID_NS_CC_Wins );
    ASSERT(pInfo->hwndCcWins);

    /* Set the IP address fields.
    */
    SetWindowText( pInfo->hwndCcDns, pInfo->pArgs->pEntry->pszIpDnsAddress );
    SetWindowText( pInfo->hwndCcWins, pInfo->pArgs->pEntry->pszIpWinsAddress );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}




BOOL
NsKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR*      psz;
    PBENTRY*    pEntry = pInfo->pArgs->pEntry;

    psz = GetText( pInfo->hwndCcDns );
    if (psz)
    {
        Free0( pEntry->pszIpDnsAddress );
        pEntry->pszIpDnsAddress = psz;
    }

    psz = GetText( pInfo->hwndCcWins );
    if (psz)
    {
        Free0( pEntry->pszIpWinsAddress );
        pEntry->pszIpWinsAddress = psz;
    }

    return FALSE;
}


BOOL
NsSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}




/*----------------------------------------------------------------------------
** IP Address property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the IP Address page of the wizard.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("RaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RaSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RaKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = RaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RaInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRa = hwndPage;
    pInfo->hwndCcIp = GetDlgItem( hwndPage, CID_RA_CC_Ip );
    ASSERT(pInfo->hwndCcIp);

    /* Set the IP address field to '0.0.0.0'.
    */
    SetWindowText( pInfo->hwndCcIp, pInfo->pArgs->pEntry->pszIpAddress );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
RaKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndCcIp );
    if (psz)
    {
        PBENTRY* pEntry = pInfo->pArgs->pEntry;

        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = psz;
    }

    return FALSE;
}


BOOL
RaSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Logon Script property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Logon Script page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RcInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RcSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RcSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RcKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = RcKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);

            return RcCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RcCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("RcCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_RC_PB_Refresh:
        {
            INT    iSel;
            TCHAR* pszSel;

            iSel = ComboBox_GetCurSel( pInfo->hwndLbScripts );
            if (iSel > 0)
                pszSel = ComboBox_GetPsz( pInfo->hwndLbScripts, iSel );
            else
                pszSel = NULL;

            EuFillDoubleScriptsList(
                pInfo->pArgs, pInfo->hwndLbScripts, pszSel );
            Free0( pszSel );
            return TRUE;
        }

        case CID_RC_PB_Edit:
        {
            TCHAR* psz;

            psz = GetText( pInfo->hwndLbScripts );
            if (psz)
            {
                if (FileExists( psz ))
                    EuEditScpScript( pInfo->hwndDlg, psz );
                else
                    EuEditSwitchInf( pInfo->hwndDlg );

                Free( psz );
            }

            return TRUE;
        }

        case CID_RC_RB_None:
        case CID_RC_RB_Script:
        {
            /* Scripts listbox is gray unless script mode is selected.
            */
            if (wNotification == BN_CLICKED)
            {
                EnableWindow( pInfo->hwndLbScripts,
                    (wId == CID_RC_RB_Script) );
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RcInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RcInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRc = hwndPage;
    pInfo->hwndRbNone = GetDlgItem( hwndPage, CID_RC_RB_None );
    ASSERT(pInfo->hwndRbNone);
    pInfo->hwndRbScript = GetDlgItem( hwndPage, CID_RC_RB_Script );
    ASSERT(pInfo->hwndRbScript);
    pInfo->hwndLbScripts = GetDlgItem( hwndPage, CID_RC_LB_Scripts );
    ASSERT(pInfo->hwndLbScripts);
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_RC_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbRefresh = GetDlgItem( hwndPage, CID_RC_PB_Refresh );
    ASSERT(pInfo->hwndPbRefresh);

    /* Fill the script list and select "(none)".
    */
    EuFillDoubleScriptsList( pInfo->pArgs, pInfo->hwndLbScripts, NULL );

    pInfo->pArgs->pEntry->dwScriptModeAfter = SM_None;

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
RcKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    INT      iSel;
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    if (IsDlgButtonChecked( pInfo->hwndRc, CID_RC_RB_None ))
        pEntry->dwScriptModeAfter = SM_None;
    else
        pEntry->dwScriptModeAfter = SM_Script;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbScripts );
    Free0( pEntry->pszScriptAfter );
    if (iSel > 0)
        pEntry->pszScriptAfter = ComboBox_GetPsz( pInfo->hwndLbScripts, iSel );
    else
        pEntry->pszScriptAfter = NULL;

    /* Silently fix-up "no script specified" error.
    */
    if (pEntry->dwScriptModeAfter == SM_Script && !pEntry->pszScriptAfter)
        pEntry->dwScriptModeAfter = SM_None;

    return FALSE;
}


BOOL
RcSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndRb;

    if (!pInfo->fNotNt || !pInfo->fModem)
        return FALSE;

    /* Select the correct mode.
    */
    {
        HWND  hwndRb;
        DWORD dwScriptMode;

        dwScriptMode = pInfo->pArgs->pEntry->dwScriptModeAfter;
        if (dwScriptMode == SM_Script)
            hwndRb = pInfo->hwndRbScript;
        else
        {
            ASSERT(dwScriptMode==SM_None);
            hwndRb = pInfo->hwndRbNone;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Finish property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RfDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Finish page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RfDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RfInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RfSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RfSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    TRACE("RfWIZFINISH");
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);

            return RfCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RfCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("RfCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

#if 0
    switch (wId)
    {
        case CID_RF_PB_Properties:
        {
            pInfo->pArgs->fChainPropertySheet = TRUE;
            PropSheet_PressButton( pInfo->hwndDlg, PSBTN_FINISH );
            return TRUE;
        }
    }
#endif

    return FALSE;
}


BOOL
RfInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RfInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRf = hwndPage;

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

#if 0 // Disables AP page display

    SetOffDesktop( pInfo->hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( pInfo->hwndDlg, SOD_Free, NULL );
    PostMessage( pInfo->hwndDlg, PSM_PRESSBUTTON, PSBTN_FINISH, 0 );

#endif

    return FALSE;
}


BOOL
RfSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    TCHAR* psz;

    /* Fill in the entry name.
    */
    psz = PszFromId( g_hinstDll, SID_FinishWizard );
    if (psz)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pArgs->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;
        msgargs.pszString = psz;

        MsgDlgUtil( NULL, 0, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( pInfo->hwndRf, CID_RF_ST_Interface,
                msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }

        Free( psz );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_FINISH );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Modem/Adapter property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Modem/Adapter page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RnDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, RnLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RnSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    AIINFO* pInfo;

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    RnLvItemChanged( pInfo );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RnInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD   dwErr;
    AIINFO* pInfo;

    TRACE("RnInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRn = hwndPage;
    pInfo->hwndLv = GetDlgItem( hwndPage, CID_RN_LV_Devices );
    ASSERT(pInfo->hwndLv);

    ListView_DeleteAllItems( pInfo->hwndLv );

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    /* Fill the list of devices and select the first item.
    */
    {
        TCHAR*   psz;
        DTLNODE* pNode;
        DWORD    cMultilinkableIsdn;
        INT      iItem;

        iItem = 1;
        cMultilinkableIsdn = 0;
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink;

            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if (pLink->pbport.pbdevicetype == PBDT_Isdn
                && !pLink->fProprietaryIsdn)
            {
                ++cMultilinkableIsdn;
            }

            psz = DisplayPszFromDeviceAndPort(
                pLink->pbport.pszDevice, pLink->pbport.pszPort );
            if (psz)
            {
                PBLINK* pLink;
                LV_ITEM item;

                pLink = (PBLINK* )DtlGetData( pNode );

                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.iItem = iItem++;
                item.pszText = psz;

                item.iImage =
                    (pLink->pbport.pbdevicetype == PBDT_Modem)
                        ? DI_Modem : DI_Adapter;

                item.lParam = (LPARAM )pNode;

                ListView_InsertItem( pInfo->hwndLv, &item );
                Free( psz );
            }
        }

        if (cMultilinkableIsdn > 1)
        {
            psz = PszFromId( g_hinstDll, SID_IsdnAdapter );
            if (psz)
            {
                LONG    lStyle;
                LV_ITEM item;

                /* Turn off sorting so the special ISDN-multilink item appears
                ** at the top of the list.
                */
                lStyle = GetWindowLong( pInfo->hwndLv, GWL_STYLE );
                SetWindowLong( pInfo->hwndLv, GWL_STYLE,
                    (lStyle & ~(LVS_SORTASCENDING)) );

                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                item.iItem = 0;
                item.pszText = psz;
                item.iImage = DI_Adapter;
                item.lParam = (LPARAM )NULL;

                ListView_InsertItem( pInfo->hwndLv, &item );
                Free( psz );
            }
        }

        /* Select the first item.
        */
        ListView_SetItemState( pInfo->hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );

        /* Add a single column exactly wide enough to fully display the
        ** widest member of the list.
        */
        {
            LV_COLUMN col;

            ZeroMemory( &col, sizeof(col) );
            col.mask = LVCF_FMT;
            col.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( pInfo->hwndLv, 0, &col );
            ListView_SetColumnWidth(
                pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
        }
    }

    /* Don't bother with this page if there's only one device, not counting
    ** the bogus "uninstalled" standard modem that's added by EuInit so
    ** entries can be edited when there are no ports.
    */
    if (!pInfo->pArgs->fNoPortsConfigured
        && ListView_GetItemCount( pInfo->hwndLv ) == 1)
    {
        pInfo->fSkipMa = TRUE;
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


LVXDRAWINFO*
RnLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 1, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}


VOID
RnLvItemChanged(
    IN AIINFO* pInfo )

    /* Called when the combobox selection changes.  'PInfo' is the wizard
    ** context.
    */
{
    INT      iSel;
    DTLNODE* pNode;
    DTLLIST* pList;

    TRACE("RnLvItemChanged");

    pList = pInfo->pArgs->pEntry->pdtllistLinks;
    ASSERT(pList);
    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );

    if (pNode)
    {
        PBLINK* pLink;

        /* Single device selected.  Enable it, move it to the head of the list
        ** of links, and disable all the other links.
        */
        pLink = (PBLINK* )DtlGetData( pNode );
        pLink->fEnabled = TRUE;

        pInfo->fModem =
            (pLink->pbport.pbdevicetype == PBDT_Modem
             || pLink->pbport.pbdevicetype == PBDT_Null);

        /* If the device selected is an X25 PAD, we will drop the user into
        ** the phonebook entry-dialog after this wizard, so that the X25
        ** address can be entered there.
        */
        pInfo->pArgs->fPadSelected = (pLink->pbport.pbdevicetype == PBDT_Pad);

        DtlRemoveNode( pList, pNode );
        DtlAddNodeFirst( pList, pNode );

        for (pNode = DtlGetNextNode( pNode );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);
            pLink->fEnabled = FALSE;
        }
    }
    else
    {
        DTLNODE* pNextNode;
        DTLNODE* pAfterNode;

        pInfo->fModem = FALSE;

        /* ISDN multi-link selected.  Enable the ISDN multi-link nodes, move
        ** them to the head of the list, and disable all the other links.
        */
        pAfterNode = NULL;
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = pNextNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            pNextNode = DtlGetNextNode( pNode );

            if (pLink->pbport.pbdevicetype == PBDT_Isdn
                && !pLink->fProprietaryIsdn)
            {
                pLink->fEnabled = TRUE;

                DtlRemoveNode( pList, pNode );
                if (pAfterNode)
                    DtlAddNodeAfter( pList, pAfterNode, pNode );
                else
                    DtlAddNodeFirst( pList, pNode );
                pAfterNode = pNode;
            }
            else
            {
                pLink->fEnabled = FALSE;
            }
        }
    }
}


BOOL
RnSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    INT cDevices;

    if (pInfo->fSkipMa)
        return FALSE;

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Phone Number property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Phone Number page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RpInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RpSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RpSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RpKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = RpKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);

            return RpCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


VOID
RpAlternates(
    IN AIINFO* pInfo )

    /* Popup the Alternate Phone Numbers dialog.  'PInfo' is the property
    ** sheet context.
    */
{
    RpPhoneNumberToStash( pInfo );

    if (PhoneNumberDlg(
            pInfo->hwndRp,
            pInfo->pArgs->fRouter,
            pInfo->pListPhoneNumbers,
            &pInfo->fPromoteHuntNumbers ))
    {
        TCHAR* pszPhoneNumber;

        pszPhoneNumber = FirstPszFromList( pInfo->pListPhoneNumbers );
        SetWindowText( pInfo->hwndEbNumber, pszPhoneNumber );
    }
}


BOOL
RpCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("RpCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_RP_PB_Alternates:
            RpAlternates( pInfo );
            return TRUE;
    }

    return FALSE;
}


BOOL
RpInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RpInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRp = hwndPage;
    pInfo->hwndStNumber = GetDlgItem( hwndPage, CID_RP_ST_Number );
    ASSERT(pInfo->hwndStNumber);
    pInfo->hwndEbNumber = GetDlgItem( hwndPage, CID_RP_EB_Number );
    ASSERT(pInfo->hwndEbNumber);
    pInfo->hwndPbAlternates = GetDlgItem( hwndPage, CID_RP_PB_Alternates );
    ASSERT(pInfo->hwndPbAlternates);

    /* Fill the phone number field from the stash created earlier.
    */
    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
        FirstPszFromList( pInfo->pListPhoneNumbers ) );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
RpKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    /* Update the stashed phone number from the editbox.
    */
    RpPhoneNumberToStash( pInfo );

    return FALSE;
}


VOID
RpPhoneNumberToStash(
    IN AIINFO* pInfo )

    /* Replace the first phone number in the stashed list with the contents of
    ** the phone number field.  'pInfo' is the property sheet context.
    */
{
    DWORD  dwErr;
    TCHAR* pszPhoneNumber;

    TRACE("RpPhoneNumberToStash");

    pszPhoneNumber = GetText( pInfo->hwndEbNumber );
    if (pszPhoneNumber)
    {
        dwErr = FirstPszToList( pInfo->pListPhoneNumbers, pszPhoneNumber );
        Free( pszPhoneNumber );
    }
    else
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        AiExit( pInfo, dwErr );
    }
}


BOOL
RpSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Server settings property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
SsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the 5 checkboxes page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("SsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return SsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SsSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = SsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SsKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = SsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);

            return SsCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}



BOOL
SsCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("SsCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_SS_CB_AddUser:

            /* Toggle the state of the "Authenticate remote..." checkbox,
            ** which is enabled when the "Add user ..." checkbox is enabled.
            */
            if (wNotification == BN_CLICKED)
            {
                if (pInfo->pArgs->fAddUser = !pInfo->pArgs->fAddUser)
                {
                    EnableWindow(
                        GetDlgItem(pInfo->hwndSs, CID_SS_CB_AuthRemote), TRUE);
                }
                else
                {
                    CheckDlgButton(
                        pInfo->hwndSs, CID_SS_CB_AuthRemote, BST_UNCHECKED );
                    EnableWindow(
                        GetDlgItem(pInfo->hwndSs, CID_SS_CB_AuthRemote), FALSE);
                }
            }
            return TRUE;
    }

    return FALSE;
}


BOOL
SsInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("SsInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndSs = hwndPage;

    if (pInfo->fIpConfigured)
        CheckDlgButton( hwndPage, CID_SS_CB_RouteIp, BST_CHECKED );
    if (pInfo->fIpxConfigured)
        CheckDlgButton( hwndPage, CID_SS_CB_RouteIpx, BST_CHECKED );

    /* The 'Authenticate remote router when dialing out' checkbox
    ** only applies when the user elects to add a user for dial-in.
    */

    if (!pInfo->pArgs->fAddUser)
    {
        CheckDlgButton( hwndPage, CID_SS_CB_AddUser, BST_UNCHECKED );
        EnableWindow( GetDlgItem(hwndPage, CID_SS_CB_AuthRemote), FALSE );
    }
    else
    {
        CheckDlgButton( hwndPage, CID_SS_CB_AddUser, BST_CHECKED );
        CheckDlgButton( hwndPage, CID_SS_CB_AuthRemote,
            pInfo->pArgs->pEntry->fAuthenticateServer );
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
SsKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    pInfo->fIp =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_RouteIp );
    pInfo->fIpx =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_RouteIpx );
    pInfo->pArgs->fAddUser = 
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_AddUser );
    pInfo->pArgs->pEntry->fAuthenticateServer = !pInfo->pArgs->fAddUser ?FALSE:
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_AuthRemote );
    pInfo->fClearPwOk =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_PlainPw );
    pInfo->fNotNt =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_NotNt );

    if (pInfo->fIp && !pInfo->fIpConfigured)
    {
        MsgDlg( pInfo->hwndDlg, SID_ConfigureIp, NULL );
        SetFocus( GetDlgItem( pInfo->hwndSs, CID_SS_CB_RouteIp) );
        return TRUE;
    }
    if (pInfo->fIpx && !pInfo->fIpxConfigured)
    {
        MsgDlg( pInfo->hwndDlg, SID_ConfigureIpx, NULL );
        SetFocus( GetDlgItem( pInfo->hwndSs, CID_SS_CB_RouteIpx) );
        return TRUE;
    }

    return FALSE;
}


BOOL
SsSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\lights.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    lights.h
//
// History:
//  Abolade Gbadegesin  Mar-14-1996     Created.
//
// Contains declarations for the dialog seen when the user presses
// Lights on the Dial-Up Networking Monitor Preferences page
//============================================================================

#ifndef _LIGHTS_H_
#define _LIGHTS_H_


//
// arguments expected by StatusLightsDlg 
//
#define SLARGS      struct tagSLARGS
SLARGS {

    //
    // owner window handle
    //
    HWND        hwndOwner;
    //
    // pointer to the RASMON preferences to be modified
    //
    RMUSER     *pUser;
    //
    // pointer to a table of installed devices
    //
    RASDEV     *pDevTable;
    DWORD       iDevCount;
};


//
// function which displays the "Status Lights" dialog;
// returns TRUE if changes were made AND OK was pressed AND
// the changes were saved successfully, returns FALSE otherwise
//

BOOL
StatusLightsDlg(
    IN  SLARGS* pArgs
    );

#endif // _LIGHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\entryw.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** entryw.c
** Remote Access Common Dialog APIs
** Add Entry wizard
**
** 06/20/95 Steve Cobb
*/

#include "rasdlgp.h"
#include "entry.h"

/* Page definitions.
*/
#define AE_EnPage    0
#define AE_RsPage    1
#define AE_MaPage    2
#define AE_PaPage    3
#define AE_FpPage    4
#define AE_LoPage    5
#define AE_IaPage    6
#define AE_NaPage    7
#define AE_ApPage    8
#define AE_PageCount 9


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* Add Entry wizard context block.  All property pages refer to the single
** context block associated with the sheet.
*/
#define AEINFO struct tagAEINFO
AEINFO
{
    /* Common input arguments.
    */
    EINFO* pArgs;

    /* Wizard and page handles.  'hwndFirstPage' is the handle of the first
    ** property page initialized.  This is the page that allocates and frees
    ** the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndEn;
    HWND hwndRs;
    HWND hwndMa;
    HWND hwndPa;
    HWND hwndFp;
    HWND hwndIa;
    HWND hwndNa;
    HWND hwndLo;
    HWND hwndAp;

    /* Entry Name page.
    */
    HWND hwndEbEntryName;

    /* Modem/Adapter page.
    */
    HWND hwndLv;

    /* Phone number page.
    */
    HWND hwndStCountry;
    HWND hwndLbCountry;
    HWND hwndStArea;
    HWND hwndClbArea;
    HWND hwndStNumber;
    HWND hwndEbNumber;
    HWND hwndPbAlternates;

    RECT rectStNumber;
    RECT rectEbNumber;
    RECT rectPbAlternates;
    LONG dxAdjustLeft;
    LONG dyAdjustUp;

    /* Framing page.
    */
    HWND hwndRbPpp;
    HWND hwndRbSlip;

    /* Login script page.
    */
    HWND hwndRbNone;
    HWND hwndRbTerminal;
    HWND hwndRbScript;
    HWND hwndLbScripts;
    HWND hwndPbEdit;
    HWND hwndPbRefresh;

    /* IP address page.
    */
    HWND hwndCcIp;

    /* Name server page.
    */
    HWND hwndCcDns;
    HWND hwndCcWins;

    /* The phone number stash.  This allows user to change the port to another
    ** link without losing the phone number he typed.  Initialized to empty in
    ** AeInit and saved to entry in AeFinish.
    */
    DTLLIST* pListPhoneNumbers;
    BOOL     fPromoteHuntNumbers;

    /* Checkbox options chosen by user.
    */
    BOOL fInternet;
    BOOL fClearPwOk;
    BOOL fNotNt;

    /* Set true when there is only one meaningful choice of device.
    */
    BOOL fSkipMa;

    /* Set true if the selected device is a modem or null modem.
    */
    BOOL fModem;

    /* The NB_* mask of protocols configured for RAS.
    */
    DWORD dwfConfiguredProtocols;

    /* Set true if IP is configured for RAS.
    */
    BOOL fIpConfigured;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

int CALLBACK
AeCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam );

VOID
AeCancel(
    IN HWND hwndPage );

AEINFO*
AeContext(
    IN HWND hwndPage );

VOID
AeExit(
    IN AEINFO* pInfo,
    IN DWORD   dwError );

VOID
AeExitInit(
    IN HWND hwndDlg );

BOOL
AeFinish(
    IN HWND hwndPage );

AEINFO*
AeInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs );

VOID
AeTerm(
    IN HWND hwndPage );

BOOL
ApCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
ApDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ApInit(
    IN HWND hwndPage );

BOOL
ApSetActive(
    IN AEINFO* pInfo );

BOOL
EnCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
EnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
EnInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs );

BOOL
EnKillActive(
    IN AEINFO* pInfo );

BOOL
EnSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
FpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
FpInit(
    IN HWND hwndPage );

BOOL
FpKillActive(
    IN AEINFO* pInfo );

BOOL
FpSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
IaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
IaInit(
    IN HWND hwndPage );

BOOL
IaKillActive(
    IN AEINFO* pInfo );

BOOL
IaSetActive(
    IN AEINFO* pInfo );

BOOL
LoCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
LoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
LoInit(
    IN HWND hwndPage );

BOOL
LoKillActive(
    IN AEINFO* pInfo );

BOOL
LoSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
MaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
MaInit(
    IN HWND hwndPage );

LVXDRAWINFO*
MaLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
MaLvItemChanged(
    IN AEINFO* pInfo );

BOOL
MaSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
NaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NaInit(
    IN HWND hwndPage );

BOOL
NaKillActive(
    IN AEINFO* pInfo );

BOOL
NaSetActive(
    IN AEINFO* pInfo );

VOID
PaAlternates(
    IN AEINFO* pInfo );

BOOL
PaCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
PaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PaInit(
    IN HWND hwndPage );

BOOL
PaKillActive(
    IN AEINFO* pInfo );

VOID
PaPhoneNumberToStash(
    IN AEINFO* pInfo );

BOOL
PaSetActive(
    IN AEINFO* pInfo );

VOID
PaUpdateAreaAndCountryCode(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
RsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RsInit(
    IN HWND hwndPage );

BOOL
RsKillActive(
    IN AEINFO* pInfo );

BOOL
RsSetActive(
    IN AEINFO* pInfo );


/*----------------------------------------------------------------------------
** Add Entry wizard entry point
**----------------------------------------------------------------------------
*/

VOID
AeWizard(
    IN OUT EINFO* pEinfo )

    /* Runs the Phonebook entry property sheet.  'PEinfo' is an input block
    ** with only caller's API arguments filled in.
    */
{
    DWORD           dwErr;
    PROPSHEETHEADER header;
    PROPSHEETPAGE   apage[ AE_PageCount ];
    PROPSHEETPAGE*  ppage;

    TRACE("AeWizard");

    ZeroMemory( &header, sizeof(header) );

    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_USECALLBACK;
    header.hwndParent = pEinfo->pApiArgs->hwndOwner;
    header.hInstance = g_hinstDll;
    header.nPages = AE_PageCount;
    header.ppsp = apage;
    header.pfnCallback = AeCallbackFunc;

    ZeroMemory( apage, sizeof(apage) );

    ppage = &apage[ AE_EnPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_EN_EntryName );
    ppage->pfnDlgProc = EnDlgProc;
    ppage->lParam = (LPARAM )pEinfo;

    ppage = &apage[ AE_RsPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_RS_RandomStuff );
    ppage->pfnDlgProc = RsDlgProc;

    ppage = &apage[ AE_MaPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_MA_ModemAdapter );
    ppage->pfnDlgProc = MaDlgProc;

    ppage = &apage[ AE_PaPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_PA_PhoneNumber );
    ppage->pfnDlgProc = PaDlgProc;

    ppage = &apage[ AE_FpPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_FP_Framing );
    ppage->pfnDlgProc = FpDlgProc;

    ppage = &apage[ AE_LoPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_LO_LoginScript );
    ppage->pfnDlgProc = LoDlgProc;

    ppage = &apage[ AE_IaPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_IA_IpAddress );
    ppage->pfnDlgProc = IaDlgProc;

    ppage = &apage[ AE_NaPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_NA_NameServers );
    ppage->pfnDlgProc = NaDlgProc;

    ppage = &apage[ AE_ApPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_AP_Properties );
    ppage->pfnDlgProc = ApDlgProc;

    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg( pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN,
            NULL );
    }
}


/*----------------------------------------------------------------------------
** Add Entry wizard
** Listed alphabetically
**----------------------------------------------------------------------------
*/

int CALLBACK
AeCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    /* A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    **
    ** Returns 0 always.
    */
{
    TRACE2("AeCallbackFunc(m=%d,l=%08x)",unMsg,lparam);

    if (unMsg == PSCB_PRECREATE)
    {
        DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
        pDlg->style &= ~(DS_CONTEXTHELP);
    }

    return 0;
}


VOID
AeCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a wizard page.
    */
{
    TRACE("AeCancel");
}


AEINFO*
AeContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a wizard page handle.
    */
{
    return (AEINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


VOID
AeExit(
    IN AEINFO* pInfo,
    IN DWORD   dwError )

    /* Forces an exit from the dialog, reporting 'dwError' to the caller.
    ** 'PInfo' is the dialog context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See AeExitInit.
    */
{
    TRACE("AeExit");

    pInfo->pArgs->pApiArgs->dwError = dwError;
    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
AeExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within AeInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


BOOL
AeFinish(
    IN HWND hwndPage )

    /* Saves the contents of the wizard.  'HwndPage is the handle of a
    ** property page.  Pops up any errors that occur.  'FPropertySheet'
    ** indicates the user chose to edit the property sheet directly.
    **
    ** Returns true is page can be dismissed, false otherwise.
    */
{
    const TCHAR* pszIp0 = TEXT("0.0.0.0");

    AEINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("AeFinish");

    pInfo = AeContext( hwndPage );
    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    /* Attach the stashed phone number information to the final link(s).
    */
    EuPhoneNumberStashToEntry( pInfo->pArgs, pInfo->pListPhoneNumbers,
        pInfo->fPromoteHuntNumbers, TRUE );

    /* Update some settings based on user selections.
    */
    if (pInfo->fNotNt)
    {
        pEntry->fLcpExtensions = FALSE;
        pEntry->fSwCompression = FALSE;
    }

    if (!pInfo->fClearPwOk)
        pEntry->dwAuthRestrictions = AR_AuthEncrypted;

    if (pInfo->fInternet && pEntry->dwBaseProtocol == BP_Ppp)
        pEntry->dwfExcludedProtocols |= (NP_Nbf | NP_Ipx);

    if (pEntry->pszIpAddress
        && lstrcmp( pEntry->pszIpAddress, pszIp0 ) != 0)
    {
        pEntry->dwIpAddressSource = ASRC_RequireSpecific;
    }

    if ((pEntry->pszIpDnsAddress
             && lstrcmp( pEntry->pszIpDnsAddress, pszIp0 ) != 0)
        || (pEntry->pszIpWinsAddress
             && lstrcmp( pEntry->pszIpWinsAddress, pszIp0 ) != 0))
    {
        pEntry->dwIpNameSource = ASRC_RequireSpecific;
    }

    /* It's a valid new entry and caller has not chosen to edit properties
    ** directly, so mark the entry for commitment.
    */
    if (!pInfo->pArgs->fChainPropertySheet)
        pInfo->pArgs->fCommit = TRUE;

    return TRUE;
}


AEINFO*
AeInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs )

    /* Wizard level initialization.  'HwndPage' is the handle of the first
    ** page.  'PArgs' is the common entry input argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** wizard has been cancelled.
    */
{
    DWORD   dwErr;
    DWORD   dwOp;
    AEINFO* pInfo;
    HWND    hwndDlg;

    TRACE("AeInit");

    hwndDlg = GetParent( hwndFirstPage );

    /* Allocate the context information block.  Initialize it enough so that
    ** it can be destroyed properly, and associate the context with the
    ** window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE("Context NOT allocated");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            AeExitInit( hwndDlg );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(AEINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE("Context NOT set");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            pArgs->pApiArgs->dwError = ERROR_UNKNOWN;
            Free( pInfo );
            AeExitInit( hwndDlg );
            return NULL;
        }

        TRACE("Context set");
    }

    /* Position the dialog per caller's instructions.
    */
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    /* Mess with the title bar gadgets.
    */
    TweakTitleBar( hwndDlg );

    /* Load RAS DLL entrypoints which starts RASMAN, if necessary.
    */
#ifdef RASMERGE
    if (!pArgs->fRouter) {
#endif
        dwErr = LoadRas( g_hinstDll, hwndDlg );
        if (dwErr != 0)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadRas, dwErr, NULL );
            pArgs->pApiArgs->dwError = dwErr;
            AeExitInit( hwndDlg );
            return NULL;
        }
#ifdef RASMERGE
    }
#endif

    /* Load the common entry information.  This must happen after RasLoad,
    ** which must happen after the dialog has been positioned so that the
    ** "Waiting for services" appears where the dialog will eventually popup.
    ** Note that EuInit assues that EuInit0 has previously been called.
    */
    dwErr = EuInit( pArgs, &dwOp );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, dwOp, dwErr, NULL );
        pArgs->pApiArgs->dwError = dwErr;
        AeExitInit( hwndDlg );
        return NULL;
    }

    /* Initialize these meta-flags that are not actually stored.
    */
    pInfo->fNotNt = FALSE;
    pInfo->fSkipMa = FALSE;
    pInfo->fModem = FALSE;
#ifdef RASMERGE
    pInfo->dwfConfiguredProtocols = g_pGetInstalledProtocols();
#else
    pInfo->dwfConfiguredProtocols = GetInstalledProtocols();
#endif
    pInfo->fIpConfigured = (pInfo->dwfConfiguredProtocols & NP_Ip);

    /* Initialize the phone number stash to from the entry, i.e. set it to
    ** empty default.  The stash list is edited rather than the list in the
    ** entry so user can change active links without losing the phone number
    ** he entered.
    */
    EuPhoneNumberStashFromEntry( pArgs, &pInfo->pListPhoneNumbers,
        &pInfo->fPromoteHuntNumbers );

    return pInfo;
}


VOID
AeTerm(
    IN HWND hwndPage )

    /* Wizard level termination.  Releases the context block.  'HwndPage' is
    ** the handle of a property page.
    */
{
    AEINFO* pInfo;

    TRACE("AeTerm");

    pInfo = AeContext( hwndPage );
    if (pInfo)
    {
        DtlDestroyList( pInfo->pListPhoneNumbers, DestroyPszNode );

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}


/*----------------------------------------------------------------------------
** Entry Name property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
EnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Entry Name page of the wizard.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("EnDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                EnInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("EnRESET");
                    AeCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("EnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = EnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("EnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = EnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    AEINFO* pInfo;

                    TRACE("EnWIZFINISH");

                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);

                    /* You'd think pressing Finish would trigger a KILLACTIVE
                    ** event, but it doesn't, so we do it ourselves.
                    */
                    EnKillActive( pInfo );

                    /* Set "no wizard" user preference, per user's check.
                    */
                    pInfo->pArgs->pUser->fNewEntryWizard = FALSE;
                    pInfo->pArgs->pUser->fDirty = TRUE;
                    SetUserPreferences(
                        pInfo->pArgs->pUser, pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                    pInfo->pArgs->fChainPropertySheet = TRUE;
                    AeFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return EnCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            AeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
EnCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("EnCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_EN_CB_SkipWizard:
        {
            if (IsDlgButtonChecked( pInfo->hwndEn, CID_EN_CB_SkipWizard ))
                PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_FINISH );
            else
                PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AEINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("EnInit");

    /* We're first page, so initialize the wizard.
    */
    pInfo = AeInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndEn = hwndPage;
    pInfo->hwndEbEntryName = GetDlgItem( hwndPage, CID_EN_EB_EntryName );
    ASSERT(pInfo->hwndEbEntryName);

    /* Initialize the entry name field.
    */
    pEntry = pInfo->pArgs->pEntry;
    if (!pEntry->pszEntryName)
    {
        /* No entry name, so think up a default.
        */
        dwErr = GetDefaultEntryName(
            pInfo->pArgs->pFile->pdtllistEntries,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPage, dwErr, NULL );
            AeExit( pInfo, dwErr );
            return TRUE;
        }
    }

    Edit_LimitText( pInfo->hwndEbEntryName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbEntryName, pEntry->pszEntryName );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return TRUE;
}


BOOL
EnKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEbEntryName );
    if (psz)
    {
        /* Update the entry name from the editbox.
        */
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = psz;

        /* Validate the entry name.
        */
        if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
        {
            SetFocus( pInfo->hwndEbEntryName );
            Edit_SetSel( pInfo->hwndEbEntryName, 0, -1 );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Random stuff property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the 3 random checkboxes page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RsSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RsKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = RsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RsInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("NeInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRs = hwndPage;

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
RsKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    pInfo->fInternet =
        IsDlgButtonChecked( pInfo->hwndRs, CID_RS_CB_Internet );
    pInfo->fClearPwOk =
        IsDlgButtonChecked( pInfo->hwndRs, CID_RS_CB_PlainPw );
    pInfo->fNotNt =
        IsDlgButtonChecked( pInfo->hwndRs, CID_RS_CB_NotNt );

    if (pInfo->fInternet && !pInfo->fIpConfigured)
    {
        MsgDlg( pInfo->hwndDlg, SID_InternetWithoutIp, NULL );
        SetFocus( GetDlgItem( pInfo->hwndRs, CID_RS_CB_Internet ) );
        return TRUE;
    }

    return FALSE;
}


BOOL
RsSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Modem/Adapter property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
MaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Modem/Adapter page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("MaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, MaLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return MaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("MaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = MaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    AEINFO* pInfo;

                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    MaLvItemChanged( pInfo );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
MaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD   dwErr;
    AEINFO* pInfo;

    TRACE("MaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndMa = hwndPage;
    pInfo->hwndLv = GetDlgItem( hwndPage, CID_MA_LV_Devices );
    ASSERT(pInfo->hwndLv);

    ListView_DeleteAllItems( pInfo->hwndLv );

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    /* Fill the list of devices and select the first item.
    */
    {
        TCHAR*   psz;
        DTLNODE* pNode;
        DWORD    cMultilinkableIsdn;
        INT      iItem;

        iItem = 1;
        cMultilinkableIsdn = 0;
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink;

            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if (pLink->pbport.pbdevicetype == PBDT_Isdn
                && !pLink->fProprietaryIsdn)
            {
                ++cMultilinkableIsdn;
            }

            psz = DisplayPszFromDeviceAndPort(
                pLink->pbport.pszDevice, pLink->pbport.pszPort );
            if (psz)
            {
                PBLINK* pLink;
                LV_ITEM item;

                pLink = (PBLINK* )DtlGetData( pNode );

                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                item.iItem = iItem++;
                item.pszText = psz;

                item.iImage =
                    (pLink->pbport.pbdevicetype == PBDT_Modem)
                        ? DI_Modem : DI_Adapter;

                item.lParam = (LPARAM )pNode;

                ListView_InsertItem( pInfo->hwndLv, &item );
                Free( psz );
            }
        }

        if (cMultilinkableIsdn > 1)
        {
            psz = PszFromId( g_hinstDll, SID_IsdnAdapter );
            if (psz)
            {
                LONG    lStyle;
                LV_ITEM item;

                /* Turn off sorting so the special ISDN-multilink item appears
                ** at the top of the list.
                */
                lStyle = GetWindowLong( pInfo->hwndLv, GWL_STYLE );
                SetWindowLong( pInfo->hwndLv, GWL_STYLE,
                    (lStyle & ~(LVS_SORTASCENDING)) );

                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                item.iItem = 0;
                item.pszText = psz;
                item.iImage = DI_Adapter;
                item.lParam = (LPARAM )NULL;

                ListView_InsertItem( pInfo->hwndLv, &item );
                Free( psz );
            }
        }

        /* Select the first item.
        */
        ListView_SetItemState( pInfo->hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );

        /* Add a single column exactly wide enough to fully display the
        ** widest member of the list.
        */
        {
            LV_COLUMN col;

            ZeroMemory( &col, sizeof(col) );
            col.mask = LVCF_FMT;
            col.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( pInfo->hwndLv, 0, &col );
            ListView_SetColumnWidth(
                pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
        }
    }

    /* Don't bother with this page if there's only one device, not counting
    ** the bogus "uninstalled" standard modem that's added by EuInit so
    ** entries can be edited when there are no ports.
    */
    if (!pInfo->pArgs->fNoPortsConfigured
        && ListView_GetItemCount( pInfo->hwndLv ) == 1)
    {
        pInfo->fSkipMa = TRUE;
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


LVXDRAWINFO*
MaLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 1, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}


VOID
MaLvItemChanged(
    IN AEINFO* pInfo )

    /* Called when the combobox selection changes.  'PInfo' is the wizard
    ** context.
    */
{
    INT      iSel;
    DTLNODE* pNode;
    DTLLIST* pList;

    TRACE("MaLvSelChange");

    pList = pInfo->pArgs->pEntry->pdtllistLinks;
    ASSERT(pList);
    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );

    if (pNode)
    {
        PBLINK* pLink;

        /* Single device selected.  Enable it, move it to the head of the list
        ** of links, and disable all the other links.
        */
        pLink = (PBLINK* )DtlGetData( pNode );
        pLink->fEnabled = TRUE;

        pInfo->fModem =
            (pLink->pbport.pbdevicetype == PBDT_Modem
             || pLink->pbport.pbdevicetype == PBDT_Null);

        DtlRemoveNode( pList, pNode );
        DtlAddNodeFirst( pList, pNode );

        for (pNode = DtlGetNextNode( pNode );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);
            pLink->fEnabled = FALSE;
        }
    }
    else
    {
        DTLNODE* pNextNode;
        DTLNODE* pAfterNode;

        pInfo->fModem = FALSE;

        /* ISDN multi-link selected.  Enable the ISDN multi-link nodes, move
        ** them to the head of the list, and disable all the other links.
        */
        pAfterNode = NULL;
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = pNextNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            pNextNode = DtlGetNextNode( pNode );

            if (pLink->pbport.pbdevicetype == PBDT_Isdn
                && !pLink->fProprietaryIsdn)
            {
                pLink->fEnabled = TRUE;

                DtlRemoveNode( pList, pNode );
                if (pAfterNode)
                    DtlAddNodeAfter( pList, pAfterNode, pNode );
                else
                    DtlAddNodeFirst( pList, pNode );
                pAfterNode = pNode;
            }
            else
            {
                pLink->fEnabled = FALSE;
            }
        }
    }
}


BOOL
MaSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    INT cDevices;

    if (pInfo->fSkipMa)
        return FALSE;

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Phone Number property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
PaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Phone Number page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("PaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return PaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("PaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = PaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = PaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return PaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


VOID
PaAlternates(
    IN AEINFO* pInfo )

    /* Popup the Alternate Phone Numbers dialog.  'PInfo' is the property
    ** sheet context.
    */
{
    PaPhoneNumberToStash( pInfo );

    if (PhoneNumberDlg(
            pInfo->hwndPa,
            pInfo->pArgs->fRouter,
            pInfo->pListPhoneNumbers,
            &pInfo->fPromoteHuntNumbers ))
    {
        TCHAR* pszPhoneNumber;

        pszPhoneNumber = FirstPszFromList( pInfo->pListPhoneNumbers );
        SetWindowText( pInfo->hwndEbNumber, pszPhoneNumber );
    }
}


BOOL
PaCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("PaCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_PA_PB_Alternates:
            PaAlternates( pInfo );
            return TRUE;

        case CID_PA_CB_UseAreaCountry:
            PaUpdateAreaAndCountryCode( pInfo );
            return TRUE;

        case CID_PA_LB_Country:
        {
            switch (wNotification)
            {
                case CBN_DROPDOWN:
                    EuFillCountryCodeList(
                        pInfo->pArgs, pInfo->hwndLbCountry, TRUE );
                    return TRUE;

                case CBN_SELCHANGE:
                    EuLbCountryCodeSelChange(
                        pInfo->pArgs, pInfo->hwndLbCountry );
                    return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
PaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("PaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndPa = hwndPage;
    pInfo->hwndStCountry = GetDlgItem( hwndPage, CID_PA_ST_Country );
    ASSERT(pInfo->hwndStCountry);
    pInfo->hwndLbCountry = GetDlgItem( hwndPage, CID_PA_LB_Country );
    ASSERT(pInfo->hwndLbCountry);
    pInfo->hwndStArea = GetDlgItem( hwndPage, CID_PA_ST_Area );
    ASSERT(pInfo->hwndStArea);
    pInfo->hwndClbArea = GetDlgItem( hwndPage, CID_PA_CLB_Area );
    ASSERT(pInfo->hwndClbArea);
    pInfo->hwndStNumber = GetDlgItem( hwndPage, CID_PA_ST_Number );
    ASSERT(pInfo->hwndStNumber);
    pInfo->hwndEbNumber = GetDlgItem( hwndPage, CID_PA_EB_Number );
    ASSERT(pInfo->hwndEbNumber);
    pInfo->hwndPbAlternates = GetDlgItem( hwndPage, CID_PA_PB_Alternates );
    ASSERT(pInfo->hwndPbAlternates);

    /* Calculate the client coordinates of the phone number controls and the
    ** offsets they move left and up when "use country and area code" is off.
    */
    {
        RECT rectLbCountry;

        GetWindowRect( pInfo->hwndLbCountry, &rectLbCountry );
        GetWindowRect( pInfo->hwndStNumber, &pInfo->rectStNumber );
        GetWindowRect( pInfo->hwndEbNumber, &pInfo->rectEbNumber );
        GetWindowRect( pInfo->hwndPbAlternates, &pInfo->rectPbAlternates );

        pInfo->dxAdjustLeft = pInfo->rectEbNumber.left - rectLbCountry.left;
        pInfo->dyAdjustUp = pInfo->rectEbNumber.top - rectLbCountry.top;

        ScreenToClientRect( hwndPage, &pInfo->rectStNumber );
        ScreenToClientRect( hwndPage, &pInfo->rectEbNumber );
        ScreenToClientRect( hwndPage, &pInfo->rectPbAlternates );
    }

    /* Fill the phone number field from the stash created earlier.
    */
    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
        FirstPszFromList( pInfo->pListPhoneNumbers ) );

    /* Set "Use country code and area code" checkbox and jockey the fields
    ** according to the setting.  This will trigger filling of the area code
    ** and country code lists, if necessary.
    */
    CheckDlgButton( pInfo->hwndPa, CID_PA_CB_UseAreaCountry,
        (pInfo->pArgs->pEntry->fUseCountryAndAreaCode)
            ? BST_CHECKED : BST_UNCHECKED );
    PaUpdateAreaAndCountryCode( pInfo );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
PaKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    DWORD    dwErr;
    PBENTRY* pEntry;
    TCHAR*   psz;

    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    /* Update the stashed phone number from the editbox.
    */
    PaPhoneNumberToStash( pInfo );

    /* Store the area/country checkbox.
    */
    pEntry->fUseCountryAndAreaCode =
        IsDlgButtonChecked( pInfo->hwndPa, CID_PA_CB_UseAreaCountry );

    /* Store the country code and ID.
    */
    EuSaveCountryInfo( pInfo->pArgs, pInfo->hwndLbCountry );

    /* Store the area code.
    */
    Free0( pEntry->pszAreaCode );
    pEntry->pszAreaCode = GetText( pInfo->hwndClbArea );
    if (!pEntry->pszAreaCode)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        AeExit( pInfo, dwErr );
        return FALSE;
    }

    /* Validate area code.
    */
    if (!EuValidateAreaCode( pInfo->hwndDlg, pInfo->pArgs ))
    {
        SetFocus( pInfo->hwndClbArea );
        ComboBox_SetEditSel( pInfo->hwndClbArea, 0, -1 );
        return TRUE;
    }

    return FALSE;
}


VOID
PaPhoneNumberToStash(
    IN AEINFO* pInfo )

    /* Replace the first phone number in the stashed list with the contents of
    ** the phone number field.  'pInfo' is the property sheet context.
    */
{
    DWORD  dwErr;
    TCHAR* pszPhoneNumber;

    TRACE("PaPhoneNumberToStash");

    pszPhoneNumber = GetText( pInfo->hwndEbNumber );
    if (pszPhoneNumber)
    {
        dwErr = FirstPszToList( pInfo->pListPhoneNumbers, pszPhoneNumber );
        Free( pszPhoneNumber );
    }
    else
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        AeExit( pInfo, dwErr );
    }
}


BOOL
PaSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


VOID
PaUpdateAreaAndCountryCode(
    IN AEINFO* pInfo )

    /* Handles enabling/disabling of the Area Code and Country Code controls
    ** and moving/sizing of the Phone Number control based on the "use area
    ** code and country code" checkbox.  'PInfo' is the dialog context.
    */
{
    HWND hwndFocus;
    BOOL fEnable;

    TRACE("PaUpdateAreaAndCountryCode");

    fEnable = IsDlgButtonChecked(
        pInfo->hwndPa, CID_PA_CB_UseAreaCountry );

    if (fEnable)
    {
        /* The area code and country code lists are being activated, so fill
        ** the lists if they aren't already.
        */
        EuFillCountryCodeList( pInfo->pArgs, pInfo->hwndLbCountry, FALSE );
        EuFillAreaCodeList( pInfo->pArgs, pInfo->hwndClbArea );
    }
    else
    {
        /* If the focus is on one of the controls we're about to disable, move
        ** it to the entry phone number editbox.  Otherwise, keyboard user is
        ** stuck.
        */
        hwndFocus = GetFocus();

        if (hwndFocus == pInfo->hwndLbCountry
            || hwndFocus == pInfo->hwndClbArea)
        {
            SetFocus( pInfo->hwndEbNumber );
        }
    }

    /* Enable/disable show/hide the country code and area code controls as
    ** indicated by user.
    */
    {
        int nCmdShow = (fEnable) ? SW_SHOW : SW_HIDE;

        EnableWindow( pInfo->hwndStCountry, fEnable );
        ShowWindow( pInfo->hwndStCountry, nCmdShow );
        EnableWindow( pInfo->hwndLbCountry, fEnable );
        ShowWindow( pInfo->hwndLbCountry, nCmdShow );

        EnableWindow( pInfo->hwndStArea, fEnable );
        ShowWindow( pInfo->hwndStArea, nCmdShow );
        EnableWindow( pInfo->hwndClbArea, fEnable );
        ShowWindow( pInfo->hwndClbArea, nCmdShow );
    }

    /* Move/size the phone number controls depending on whether the area code
    ** and country code controls are visible.
    */
    {
        RECT rectStNumber;
        RECT rectEbNumber;
        RECT rectPbAlternates;

        rectStNumber = pInfo->rectStNumber;
        rectEbNumber = pInfo->rectEbNumber;
        rectPbAlternates = pInfo->rectPbAlternates;

        if (!fEnable)
        {
            rectStNumber.left -= pInfo->dxAdjustLeft;
            rectStNumber.top -= pInfo->dyAdjustUp;
            rectStNumber.bottom -= pInfo->dyAdjustUp;

            rectEbNumber.left -= pInfo->dxAdjustLeft;
            rectEbNumber.top -= pInfo->dyAdjustUp;
            rectEbNumber.bottom -= pInfo->dyAdjustUp;

            rectPbAlternates.top -= pInfo->dyAdjustUp;
        }

        SetWindowPos( pInfo->hwndStNumber, NULL,
            rectStNumber.left,
            rectStNumber.top,
            rectStNumber.right - rectStNumber.left,
            rectStNumber.bottom - rectStNumber.top,
            SWP_NOZORDER | SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndEbNumber, NULL,
            rectEbNumber.left,
            rectEbNumber.top,
            rectEbNumber.right - rectEbNumber.left,
            rectEbNumber.bottom - rectEbNumber.top,
            SWP_NOZORDER + SWP_NOCOPYBITS );

        SetWindowPos( pInfo->hwndPbAlternates, NULL,
            pInfo->rectPbAlternates.left, rectPbAlternates.top, 0, 0,
            SWP_NOSIZE | SWP_NOZORDER | SWP_NOCOPYBITS );
    }
}


/*----------------------------------------------------------------------------
** Framing Protocol property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
FpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Framing Protocol page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("FpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return FpInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("FpSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = FpSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("FpKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = FpKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
FpInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("FpInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndFp = hwndPage;
    pInfo->hwndRbPpp = GetDlgItem( hwndPage, CID_FP_RB_Ppp );
    ASSERT(pInfo->hwndRbPpp);
    pInfo->hwndRbSlip = GetDlgItem( hwndPage, CID_FP_RB_Slip );
    ASSERT(pInfo->hwndRbSlip);

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
FpKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    if (Button_GetCheck( pInfo->hwndRbPpp ))
        pInfo->pArgs->pEntry->dwBaseProtocol = BP_Ppp;
    else
        pInfo->pArgs->pEntry->dwBaseProtocol = BP_Slip;

    return FALSE;
}


BOOL
FpSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndRb;

    if (!pInfo->fNotNt || !pInfo->fModem || !pInfo->fIpConfigured)
        return FALSE;

    /* Set the radio buttons.
    */
    if (pInfo->pArgs->pEntry->dwBaseProtocol == BP_Ppp)
        hwndRb = pInfo->hwndRbPpp;
    else
    {
        ASSERT(pInfo->pArgs->pEntry->dwBaseProtocol==BP_Slip);
        hwndRb = pInfo->hwndRbSlip;
    }
    SendMessage( hwndRb, BM_CLICK, 0, 0 );

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Logon Script property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
LoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Logon Script page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("LoDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return LoInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("LoSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = LoSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("LoKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = LoKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return LoCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
LoCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("LoCommand(n=%d,i=%d",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_LO_PB_Refresh:
        {
            INT    iSel;
            TCHAR* pszSel;

            iSel = ComboBox_GetCurSel( pInfo->hwndLbScripts );
            if (iSel > 0)
                pszSel = ComboBox_GetPsz( pInfo->hwndLbScripts, iSel );
            else
                pszSel = NULL;

            EuFillDoubleScriptsList(
                pInfo->pArgs, pInfo->hwndLbScripts, pszSel );
            Free0( pszSel );
            return TRUE;
        }

        case CID_LO_PB_Edit:
        {
            TCHAR* psz;

            psz = GetText( pInfo->hwndLbScripts );
            if (psz)
            {
                if (FileExists( psz ))
                    EuEditScpScript( pInfo->hwndDlg, psz );
                else
                    EuEditSwitchInf( pInfo->hwndDlg );

                Free( psz );
            }

            return TRUE;
        }

        case CID_LO_RB_None:
        case CID_LO_RB_Terminal:
        case CID_LO_RB_Script:
        {
            /* Scripts listbox is gray unless script mode is selected.
            */
            if (wNotification == BN_CLICKED)
            {
                EnableWindow( pInfo->hwndLbScripts,
                    (wId == CID_LO_RB_Script) );
            }
            break;
        }
    }

    return FALSE;
}


BOOL
LoInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("LoInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndLo = hwndPage;
    pInfo->hwndRbNone = GetDlgItem( hwndPage, CID_LO_RB_None );
    ASSERT(pInfo->hwndRbNone);
    pInfo->hwndRbTerminal = GetDlgItem( hwndPage, CID_LO_RB_Terminal );
    ASSERT(pInfo->hwndRbTerminal);
    pInfo->hwndRbScript = GetDlgItem( hwndPage, CID_LO_RB_Script );
    ASSERT(pInfo->hwndRbScript);
    pInfo->hwndLbScripts = GetDlgItem( hwndPage, CID_LO_LB_Scripts );
    ASSERT(pInfo->hwndLbScripts);
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_LO_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbRefresh = GetDlgItem( hwndPage, CID_LO_PB_Refresh );
    ASSERT(pInfo->hwndPbRefresh);

    /* Fill the script list and select "(none)".
    */
    EuFillDoubleScriptsList( pInfo->pArgs, pInfo->hwndLbScripts, NULL );

    /* Default mode depends on framing chosen.
    */
    pInfo->pArgs->pEntry->dwScriptModeAfter =
        (pInfo->pArgs->pEntry->dwBaseProtocol == BP_Slip)
            ? SM_Terminal : SM_None;

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
LoKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    INT      iSel;
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    if (IsDlgButtonChecked( pInfo->hwndLo, CID_LO_RB_None ))
        pEntry->dwScriptModeAfter = SM_None;
    else if (IsDlgButtonChecked( pInfo->hwndLo, CID_LO_RB_Terminal ))
        pEntry->dwScriptModeAfter = SM_Terminal;
    else
        pEntry->dwScriptModeAfter = SM_Script;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbScripts );
    Free0( pEntry->pszScriptAfter );
    if (iSel > 0)
        pEntry->pszScriptAfter = ComboBox_GetPsz( pInfo->hwndLbScripts, iSel );
    else
        pEntry->pszScriptAfter = NULL;

    /* Silently fix-up "no script specified" error.
    */
    if (pEntry->dwScriptModeAfter == SM_Script && !pEntry->pszScriptAfter)
        pEntry->dwScriptModeAfter = SM_None;

    return FALSE;
}


BOOL
LoSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndRb;

    if (!pInfo->fNotNt || !pInfo->fModem)
        return FALSE;

    /* Select the correct mode.
    */
    {
        HWND  hwndRb;
        DWORD dwScriptMode;

        dwScriptMode = pInfo->pArgs->pEntry->dwScriptModeAfter;
        if (dwScriptMode == SM_Terminal)
            hwndRb = pInfo->hwndRbTerminal;
        else if (dwScriptMode == SM_Script)
            hwndRb = pInfo->hwndRbScript;
        else
        {
            ASSERT(dwScriptMode==SM_None);
            hwndRb = pInfo->hwndRbNone;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** IP Address property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
IaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the IP Address page of the wizard.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("IaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return IaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("IaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = IaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("IaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = IaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
IaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("IaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndIa = hwndPage;
    pInfo->hwndCcIp = GetDlgItem( hwndPage, CID_IA_CC_Ip );
    ASSERT(pInfo->hwndCcIp);

    /* Set the IP address field to '0.0.0.0'.
    */
    SetWindowText( pInfo->hwndCcIp, pInfo->pArgs->pEntry->pszIpAddress );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
IaKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndCcIp );
    if (psz)
    {
        PBENTRY* pEntry = pInfo->pArgs->pEntry;

        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = psz;
    }

    return FALSE;
}


BOOL
IaSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured
        || (pEntry->dwBaseProtocol == BP_Slip
            && pEntry->dwScriptModeAfter == SM_Terminal))
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Name Server property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
NaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Name Server page of the wizard.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("NaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return NaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("NaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = NaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("NaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = NaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
NaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("NaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndNa = hwndPage;
    pInfo->hwndCcDns = GetDlgItem( hwndPage, CID_NA_CC_Dns );
    ASSERT(pInfo->hwndCcDns);
    pInfo->hwndCcWins = GetDlgItem( hwndPage, CID_NA_CC_Wins );
    ASSERT(pInfo->hwndCcWins);

    /* Set the IP address fields to '0.0.0.0'.
    */
    SetWindowText( pInfo->hwndCcDns, pInfo->pArgs->pEntry->pszIpDnsAddress );
    SetWindowText( pInfo->hwndCcWins, pInfo->pArgs->pEntry->pszIpWinsAddress );

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
NaKillActive(
    IN AEINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    PBENTRY* pEntry;
    TCHAR*   psz;

    pEntry = pInfo->pArgs->pEntry;

    psz = GetText( pInfo->hwndCcDns );
    if (psz)
    {
        Free0( pEntry->pszIpDnsAddress );
        pEntry->pszIpDnsAddress = psz;
    }

    psz = GetText( pInfo->hwndCcWins );
    if (psz)
    {
        Free0( pEntry->pszIpWinsAddress );
        pEntry->pszIpWinsAddress = psz;
    }

    return FALSE;
}


BOOL
NaSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
        return FALSE;

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Advanced Properties property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
ApDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Advanced Properties page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("ApDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return ApInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("ApSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = ApSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    TRACE("ApWIZFINISH");
                    AeFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return ApCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
ApCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("ApCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_AP_PB_Properties:
        {
            pInfo->pArgs->fChainPropertySheet = TRUE;
            PropSheet_PressButton( pInfo->hwndDlg, PSBTN_FINISH );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ApInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AEINFO* pInfo;

    TRACE("ApInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndAp = hwndPage;

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

#if 0 // Disables AP page display

    SetOffDesktop( pInfo->hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( pInfo->hwndDlg, SOD_Free, NULL );
    PostMessage( pInfo->hwndDlg, PSM_PRESSBUTTON, PSBTN_FINISH, 0 );

#endif

    return FALSE;
}


BOOL
ApSetActive(
    IN AEINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    TCHAR* psz;

    /* Fill in the entry name.
    */
    psz = PszFromId( g_hinstDll, SID_FinishWizard );
    if (psz)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pArgs->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;
        msgargs.pszString = psz;

        MsgDlgUtil( NULL, 0, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( pInfo->hwndAp, CID_AP_ST_Entry, msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }

        Free( psz );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_FINISH );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\main.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** main.c
** Remote Access Common Dialog APIs
** Main routines
**
** 06/20/95 Steve Cobb
*/

#include "rasdlgp.h"
#include "treelist.h"


/*----------------------------------------------------------------------------
** Rasdlg globals
**----------------------------------------------------------------------------
*/

/* IMPORTANT: No globals may be defined that do not work properly when the DLL
**            is called by multiple threads within a single process.
*/

/* Handle of the DLL instance set from the corresponding LibMain parameter.
*/
HINSTANCE g_hinstDll = NULL;

/* The atom identifying our context property suitable for use by the Windows
** XxxProp APIs.  A Prop is used to associate context information with a
** property sheet.  The atom is registered in LibMain.
*/
LPCTSTR g_contextId = NULL;

/* The handle of the RAS wizard bitmap.  This is needed only because
** DLGEDIT.EXE is currently unable to produce the RC syntax necessary to
** create a self-contained SS_BITMAP control, so the image must be set at
** run-time.  See also SetWizardBitmap().
*/
HBITMAP g_hbmWizard = NULL;

/* The name of the on-line help file.  Initialized in LibMain.
*/
TCHAR* g_pszHelpFile = NULL;

/* The name of the on-line ROUTER help file.  Initialized in LibMain.
*/
TCHAR* g_pszRouterHelpFile = NULL;

/* Handle and mapping of emory shared by rasdlg.dll and rasmon.exe.
*/
HANDLE g_hRmmem = NULL;
RMMEM* g_pRmmem = NULL;


/*----------------------------------------------------------------------------
** Rasdlg DLL entrypoint
**----------------------------------------------------------------------------
*/

BOOL
LibMain(
    HANDLE hinstDll,
    DWORD  fdwReason,
    LPVOID lpReserved )

    /* This routine is called by the system on various events such as the
    ** process attachment and detachment.  See Win32 DllEntryPoint
    ** documentation.
    **
    ** Returns true if successful, false otherwise.
    */
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        /* Initialize trace and assert support.
        */
        DEBUGINIT( "RASDLG" );

        /* Stash the DLL instance handle for use in the dialog/window calls
        ** later.
        */
        g_hinstDll = hinstDll;

        /* Register the context ID atom for use in the Windows XxxProp calls
        ** which are used to associate a context with a dialog window handle.
        */
        g_contextId = (LPCTSTR )GlobalAddAtom( TEXT("RASDLG") );
        if (!g_contextId)
            return FALSE;

        /* Initialize Win32 common controls in COMCTL32.DLL.
        */
        InitCommonControls();

        /* Initialize the IP custom control.
        */
        IpAddrInit( hinstDll, SID_PopupTitle, SID_BadIpAddrRange );

        /* Initialize the TreeList custom control
        */
        // TL_Init( hinstDll );

        /* Load the name of our on-line help file.
        */
        g_pszHelpFile = PszFromId( hinstDll, SID_HelpFile );
		
        /* Load the name of our on-line help file.
        */
        g_pszRouterHelpFile = PszFromId( hinstDll, SID_RouterHelpFile );

        /* Initialize the Phonebook library.
        */
        if (InitializePbk() != 0)
            return FALSE;
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        /* Remove the context ID atom we registered at initialization.
        */
        GlobalDeleteAtom( LOWORD( g_contextId ) );

        /* Unload the wizard bitmap.
        */
        if (g_hbmWizard)
            DeleteObject( (HGDIOBJ )g_hbmWizard );

        /* Free the on-line help file string.
        */
        Free0( g_pszHelpFile );
        Free0( g_pszRouterHelpFile );

        /* Unmap the shared memory, if any.
        */
        if (g_pRmmem)
            UnmapViewOfFile( g_pRmmem );
        if (g_hRmmem)
            CloseHandle( g_hRmmem );

        /* Uninitialize the Phonebook library.
        */
        TerminatePbk();

        /* Unload dynamically loaded DLLs, if any.
        */
        UnloadRas();

        /* Terminate trace and assert support.
        */
        DEBUGTERM();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\mlink.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** mlink.c
** Remote Access Common Dialog APIs
** Multi-link configuration dialogs
**
** 01/23/96 Steve Cobb
*/

#include "rasdlgp.h"


/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwMlHelp[] =
{
    CID_ML_ST_Devices,   HID_ML_LV_Devices,
    CID_ML_LV_Devices,   HID_ML_LV_Devices,
    CID_ML_PB_Edit,      HID_ML_PB_Edit,
    CID_ML_PB_Configure, HID_ML_PB_Configure,
    0, 0
};

static DWORD g_adwDmHelp[] =
{
    CID_DM_RB_DialAll,       HID_DM_RB_DialAll,
    CID_DM_RB_DialAsNeeded,  HID_DM_RB_DialAsNeeded,
    CID_DM_ST_Dial,          HID_DM_ST_Dial,
    CID_DM_LB_DialPercent,   HID_DM_LB_DialPercent,
    CID_DM_ST_DialOrMore,    HID_DM_LB_DialPercent,
    CID_DM_EB_DialMinutes,   HID_DM_EB_DialMinutes,
    CID_DM_ST_DialMinutes,   HID_DM_EB_DialMinutes,
    CID_DM_ST_HangUp,        HID_DM_ST_HangUp,
    CID_DM_LB_HangUpPercent, HID_DM_LB_HangUpPercent,
    CID_DM_ST_HangUpOrLess,  HID_DM_LB_HangUpPercent,
    CID_DM_EB_HangUpMinutes, HID_DM_EB_HangUpMinutes,
    CID_DM_ST_HangUpMinutes, HID_DM_EB_HangUpMinutes,
    0, 0
};


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* Multi-link configuration dialog argument block.
*/
#define MLARGS struct tagMLARGS
MLARGS
{
    DTLLIST* pList;
    BOOL fRouter;
};

/* Multi-link configuration dialog context block.
*/
#define MLINFO struct tagMLINFO
MLINFO
{
    /* Stub API arguments.
    */
    DTLLIST* pList;
    BOOL fRouter;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndLv;
    HWND hwndPbEdit;
    HWND hwndPbConfigure;

    BOOL fChecksInstalled;
};


/* Multi-link dialing dialog context block.
*/
#define DMINFO struct tagDMINFO
DMINFO
{
    /* Stub API argument.
    */
    PBENTRY* pEntry;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndRbDialAll;
    HWND hwndRbDialAsNeeded;
    HWND hwndStDial;
    HWND hwndLbDialPercent;
    HWND hwndStDialOrMore;
    HWND hwndEbDialMinutes;
    HWND hwndStDialMinutes;
    HWND hwndStHangUp;
    HWND hwndLbHangUpPercent;
    HWND hwndStHangUpOrLess;
    HWND hwndEbHangUpMinutes;
    HWND hwndStHangUpMinutes;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DmDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DmCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
DmInit(
    IN HWND     hwndDlg,
    IN PBENTRY* pEntry );

VOID
DmSave(
    IN DMINFO* pInfo );

VOID
DmTerm(
    IN HWND hwndDlg );

VOID
DmUpdateAsNeededState(
    IN DMINFO* pInfo );

INT_PTR CALLBACK
MlDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
MlCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
MlFillLv(
    IN MLINFO* pInfo );

BOOL
MlInit(
    IN HWND    hwndDlg,
    IN MLARGS* pArgs );

LVXDRAWINFO*
MlLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
MlPbConfigure(
    IN MLINFO* pInfo );

VOID
MlPbEdit(
    IN MLINFO* pInfo );

VOID
MlSave(
    IN MLINFO* pInfo );

VOID
MlTerm(
    IN HWND hwndDlg );

VOID
MlUpdatePbState(
    IN MLINFO* pInfo );


/*----------------------------------------------------------------------------
** Multi-link configuration dialog
** Listed alphabetically following stub API and dialog proc
**----------------------------------------------------------------------------
*/

BOOL
MultiLinkConfigureDlg(
    IN HWND     hwndOwner,
    IN DTLLIST* pListLinks,
    IN BOOL     fRouter )

    /* Popup the Multi-link configuration dialog.  'HwndOwner' is the owner of
    ** the dialog.  'PListLinks' is a list of PBLINKs to edit.  'FRouter'
    ** indicates router-style labels should be used rather than client-style.
    **
    ** Returns true if user pressed OK and succeeded, false if user pressed
    ** Cancel or encountered an error.
    */
{
    MLARGS args;
    int nStatus;

    TRACE("MultiLinkConfigureDlg");

    args.pList = pListLinks;
    args.fRouter = fRouter;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_ML_MultiLink ),
            hwndOwner,
            MlDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
MlDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Multi-Link Configure dialog.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("MlDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, MlLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return MlInit( hwnd, (MLARGS* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwMlHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            return MlCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case LVN_ITEMCHANGED:
                {
                    MLINFO* pInfo = (MLINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    MlUpdatePbState( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            MlTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
MlCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    /* Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    ** the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    DWORD dwErr;

    TRACE2("DmCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_ML_PB_Edit:
        {
            MLINFO* pInfo = (MLINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);
            MlPbEdit( pInfo );
            return TRUE;
        }

        case CID_ML_PB_Configure:
        {
            MLINFO* pInfo = (MLINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);
            MlPbConfigure( pInfo );
            return TRUE;
        }

        case IDOK:
        {
            MLINFO* pInfo;

            TRACE("OK pressed");

            pInfo = (MLINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            if (ListView_GetCheckedCount( pInfo->hwndLv ) <= 0)
            {
                MsgDlg( pInfo->hwndDlg, SID_SelectOneLink, NULL );
                return TRUE;
            }

            MlSave( pInfo );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
MlFillLv(
    IN MLINFO* pInfo )

    /* Fill the listview with devices and phone numbers.  'PInfo' is the
    ** dialog context.
    **
    ** Note: This routine should be called only once.
    */
{
    INT      iItem;
    DTLLIST* pListLinks;
    DTLNODE* pNode;

    TRACE("MlFillLv");

    ListView_DeleteAllItems( pInfo->hwndLv );

    /* Install "listview of check boxes" handling.
    */
    pInfo->fChecksInstalled =
        ListView_InstallChecks( pInfo->hwndLv, g_hinstDll );
    if (!pInfo->fChecksInstalled)
        return;

    /* Add columns.
    */
    {
        LV_COLUMN col;
        TCHAR*    pszHeader0;
        TCHAR*    pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_DeviceColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_PhoneNumbersColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( pInfo->hwndLv, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    /* Duplicate caller's list of links.
    */
    pListLinks = DtlDuplicateList(
        pInfo->pList, DuplicateLinkNode, DestroyLinkNode );
    if (!pListLinks)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadDlg,
            ERROR_NOT_ENOUGH_MEMORY, NULL );
        EndDialog( pInfo->hwndDlg, FALSE );
        return;
    }

    /* Add each link to the listview.
    */
    for (pNode = DtlGetFirstNode( pListLinks ), iItem = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++iItem)
    {
        PBLINK* pLink;
        LV_ITEM item;
        TCHAR*  psz;

        pLink = (PBLINK* )DtlGetData( pNode );

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
        item.iItem = iItem;

        psz = DisplayPszFromDeviceAndPort(
            pLink->pbport.pszDevice, pLink->pbport.pszPort );
        if (!psz)
            continue;
        item.pszText = psz;

        item.iImage =
            (pLink->pbport.pbdevicetype == PBDT_Modem)
                ? DI_Modem : DI_Adapter;

        item.lParam = (LPARAM )pNode;

        ListView_InsertItem( pInfo->hwndLv, &item );
        Free( psz );

        psz = PszFromPhoneNumberList( pLink->pdtllistPhoneNumbers );
        if (psz)
        {
            ListView_SetItemText( pInfo->hwndLv, iItem, 1, psz );
            Free( psz );
        }

        ListView_SetCheck( pInfo->hwndLv, iItem, pLink->fEnabled );
    }

    /* Auto-size columns to look good with the text they contain.
    */
    ListView_SetColumnWidth( pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    ListView_SetColumnWidth( pInfo->hwndLv, 1, LVSCW_AUTOSIZE_USEHEADER );

    /* Select the first item.
    */
    ListView_SetItemState( pInfo->hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );
}


BOOL
MlInit(
    IN HWND    hwndDlg,
    IN MLARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    ** 'PArgs' is the caller's stub API argument block.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    MLINFO* pInfo;

    TRACE("MlInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pList = pArgs->pList;
        pInfo->fRouter = pArgs->fRouter;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndLv = GetDlgItem( hwndDlg, CID_ML_LV_Devices );
    ASSERT(pInfo->hwndLv);
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_ML_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbConfigure = GetDlgItem( hwndDlg, CID_ML_PB_Configure );
    ASSERT(pInfo->hwndPbConfigure);

    /* Initialize the list view, selecting the first item.
    */
    MlFillLv( pInfo );

    /* Position the dialog at our standard offset from the owner.
    */
    {
        HWND hwndOwner;
        RECT rect;

        hwndOwner = GetParent( hwndDlg );
        ASSERT(hwndOwner);
        GetWindowRect( hwndOwner, &rect );
        PositionDlg( hwndDlg, TRUE, rect.left + DXSHEET, rect.top + DYSHEET );
    }

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


LVXDRAWINFO*
MlLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 2, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}


VOID
MlPbConfigure(
    IN MLINFO* pInfo )

    /* Called when the Configure button is pressed.
    */
{
    DTLNODE* pNode;
    PBLINK*  pLinkFirst;

    TRACE("MlPbConfigure");

    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    ASSERT(pNode);
    pLinkFirst = (PBLINK* )DtlGetData( pNode );
    ASSERT(pLinkFirst);

    if (DeviceConfigureDlg( pInfo->hwndDlg, pLinkFirst, FALSE ))
    {
        if (ListView_GetSelectedCount( pInfo->hwndLv ) > 1)
        {
            INT i;

            /* OK pressed on configure dialog and multiple items were
            ** selected.  Transfer changes to other selected items.
            */
            i = ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_SELECTED );
            while ((i = ListView_GetNextItem(
                pInfo->hwndLv, i, LVNI_SELECTED )) >= 0)
            {
                LV_ITEM item;
                PBLINK* pLink;

                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_PARAM;
                item.iItem = i;

                if (!ListView_GetItem( pInfo->hwndLv, &item ))
                    break;

                ASSERT(item.lParam);
                pLink = (PBLINK* )DtlGetData( (DTLNODE* )item.lParam );
                ASSERT(pLink);
                ASSERT(pLink->pbport.pbdevicetype==PBDT_Isdn);

                pLink->lLineType = pLinkFirst->lLineType;
                pLink->fFallback = pLinkFirst->fFallback;
            }
        }
    }
}


VOID
MlPbEdit(
    IN MLINFO* pInfo )

    /* Called when the Edit button is pressed.
    */
{
    INT      i;
    DTLNODE* pNode;
    PBLINK*  pLink;
    PBLINK*  pFirstLink;

    TRACE("MlPbEdit");

    /* Get the first selected link and edit the phonenumber list and option.
    */
    i = ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_SELECTED );
    ASSERT(i>=0);
    pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );
    ASSERT(pNode);
    pFirstLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pFirstLink);

    if (PhoneNumberDlg(
            pInfo->hwndDlg,
            pInfo->fRouter,
            pFirstLink->pdtllistPhoneNumbers,
            &pFirstLink->fPromoteHuntNumbers ))
    {
        TCHAR* psz;

        /* User pressed OK on phone number list dialog so update the phone
        ** number column text.
        */
        psz = PszFromPhoneNumberList( pFirstLink->pdtllistPhoneNumbers );
        if (psz)
        {
            ListView_SetItemText( pInfo->hwndLv, i, 1, psz );
            Free( psz );
        }

        /* Duplicate the first selected links new phone number information to
        ** any other selected links.
        */
        while ((i = ListView_GetNextItem(
                        pInfo->hwndLv, i, LVNI_SELECTED )) >= 0)
        {
            DTLLIST* pList;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );
            ASSERT(pNode);
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            pList = DtlDuplicateList( pFirstLink->pdtllistPhoneNumbers,
                DuplicatePszNode, DestroyPszNode );
            if (!pList)
                break;

            DtlDestroyList( pLink->pdtllistPhoneNumbers, DestroyPszNode );
            pLink->pdtllistPhoneNumbers = pList;
            pLink->fPromoteHuntNumbers = pFirstLink->fPromoteHuntNumbers;

            psz = PszFromPhoneNumberList( pLink->pdtllistPhoneNumbers );
            if (psz)
            {
                ListView_SetItemText( pInfo->hwndLv, i, 1, psz );
                Free( psz );
            }
        }
    }
}


VOID
MlSave(
    IN MLINFO* pInfo )

    /* Save control settings in caller's list of links.  'PInfo' is the dialog
    ** context.
    */
{
    INT      i;
    DTLLIST* pList;
    DTLNODE* pNode;
    DTLNODE* pNodeCheck;

    TRACE("MlSave");

    while (pNode = DtlGetFirstNode( pInfo->pList ))
    {
        DtlRemoveNode( pInfo->pList, pNode );
        DestroyLinkNode( pNode );
    }

    i = -1;
    pNodeCheck = NULL;
    while ((i = ListView_GetNextItem( pInfo->hwndLv, i, LVNI_ALL )) >= 0)
    {
        LV_ITEM item;
        PBLINK* pLink;

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_PARAM;
        item.iItem = i;
        if (!ListView_GetItem( pInfo->hwndLv, &item ))
            continue;

        pNode = (DTLNODE* )item.lParam;
        ASSERT(pNode);
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT(pLink);
        pLink->fEnabled = ListView_GetCheck( pInfo->hwndLv, i );

        /* Save with checkeds followed by uncheckeds.
        */
        if (pLink->fEnabled)
        {
            DtlAddNodeAfter( pInfo->pList, pNodeCheck, pNode );
            pNodeCheck = (DTLNODE* )item.lParam;
        }
        else
        {
            DtlAddNodeLast( pInfo->pList, (DTLNODE* )item.lParam );
        }
    }

    /* Delete all the items from the listview so MlTerm doesn't free them
    ** during clean up.
    */
    while ((i = ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_ALL )) >= 0)
        ListView_DeleteItem( pInfo->hwndLv, i );
}


VOID
MlTerm(
    IN HWND hwndDlg )

    /* Dialog termination.  Releases the context block.  'HwndDlg' is the
    ** handle of a dialog.
    */
{
    MLINFO* pInfo;

    TRACE("MlTerm");

    pInfo = (MLINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        INT i;

        /* Release any link nodes still in the list, e.g. if user Canceled.
        */
        i = -1;
        while ((i = ListView_GetNextItem( pInfo->hwndLv, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNode;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );
            DestroyLinkNode( pNode );
        }

        if (pInfo->fChecksInstalled)
            ListView_UninstallChecks( pInfo->hwndLv );

        Free( pInfo );
        TRACE("Context freed");
    }
}


VOID
MlUpdatePbState(
    IN MLINFO* pInfo )

    /* Enable/disable Edit and Configure button based on ListView selection.
    ** 'PInfo' is the dialog context.
    */
{
    BOOL fEnableEdit;
    BOOL fEnableConfigure;
    UINT unSels;
    INT  i;

    TRACE("MlUpdatePbState");

    fEnableEdit = fEnableConfigure = FALSE;

    unSels = ListView_GetSelectedCount( pInfo->hwndLv );

    if (unSels <= 0)
    {
        /* No selected items so disable both buttons.
        */
        fEnableEdit = fEnableConfigure = FALSE;
    }
    else
    {
        /* There's a selection.
        */
        fEnableEdit = fEnableConfigure = TRUE;

        if (unSels > 1)
        {
            /* There's more than one selection.  Only ISDN lines are allowed
            ** to be simultaneously configured.  (Could do RASMXS modems of
            ** the same type but for now we don't)
            */
            i = -1;
            while ((i = ListView_GetNextItem(
                            pInfo->hwndLv, i, LVNI_SELECTED )) >= 0)
            {
                LV_ITEM  item;
                DTLNODE* pNode;
                PBLINK*  pLink;

                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_PARAM;
                item.iItem = i;
                if (!ListView_GetItem( pInfo->hwndLv, &item ))
                    continue;

                pNode = (DTLNODE* )item.lParam;
                if (!pNode)
                {
                    /* If non-zero here it's because of the "set to NULL" in
                    ** MlSave, which means we're wasting our time worrying
                    ** about button state.
                    */
                    return;
                }

                pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT(pLink);

                if (pLink->pbport.pbdevicetype != PBDT_Isdn)
                {
                    fEnableConfigure = FALSE;
                    break;
                }
            }
        }
    }

    EnableWindow( pInfo->hwndPbEdit, fEnableEdit );
    EnableWindow( pInfo->hwndPbConfigure, fEnableConfigure );
}


/*----------------------------------------------------------------------------
** Multi-link dialing dialog
** Listed alphabetically following stub API and dialog proc
**----------------------------------------------------------------------------
*/

BOOL
MultiLinkDialingDlg(
    IN  HWND     hwndOwner,
    OUT PBENTRY* pEntry )

    /* Popup the Multi-link dialing dialog.  'HwndOwner' is the owner of the
    ** dialog.  'PEntry' is a phonebook entry to edit.
    **
    ** Returns true if user pressed OK and succeeded, false if user pressed
    ** Cancel or encountered an error.
    */
{
    int nStatus;

    TRACE("MultiLinkConfigureDlg");

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DM_DialingMultipleLines ),
            hwndOwner,
            DmDlgProc,
            (LPARAM )pEntry );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DmDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Multi-Link dialing dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("DmDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return DmInit( hwnd, (PBENTRY* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwDmHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            return DmCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            DmTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
DmCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    /* Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    ** the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    DWORD dwErr;

    TRACE2("DmCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_DM_RB_DialAll:
        case CID_DM_RB_DialAsNeeded:
        {
            DMINFO* pInfo = (DMINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);
            DmUpdateAsNeededState( pInfo );
            break;
        }

        case IDOK:
        {
            DMINFO* pInfo;

            TRACE("OK pressed");

            pInfo = (DMINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);
            DmSave( pInfo );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DmInit(
    IN HWND     hwndDlg,
    IN PBENTRY* pEntry )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    ** 'PEntry' is the caller's stub API argument.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    DMINFO* pInfo;

    TRACE("DmInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pEntry = pEntry;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndRbDialAll = GetDlgItem( hwndDlg, CID_DM_RB_DialAll );
    ASSERT(pInfo->hwndRbDialAll);
    pInfo->hwndRbDialAsNeeded = GetDlgItem( hwndDlg, CID_DM_RB_DialAsNeeded );
    ASSERT(pInfo->hwndRbDialAsNeeded);
    pInfo->hwndStDial = GetDlgItem( hwndDlg, CID_DM_ST_Dial );
    ASSERT(pInfo->hwndStDial);
    pInfo->hwndLbDialPercent = GetDlgItem( hwndDlg, CID_DM_LB_DialPercent );
    ASSERT(pInfo->hwndLbDialPercent);
    pInfo->hwndStDialOrMore = GetDlgItem( hwndDlg, CID_DM_ST_DialOrMore );
    ASSERT(pInfo->hwndStDialOrMore);
    pInfo->hwndEbDialMinutes = GetDlgItem( hwndDlg, CID_DM_EB_DialMinutes );
    ASSERT(pInfo->hwndEbDialMinutes);
    pInfo->hwndStDialMinutes = GetDlgItem( hwndDlg, CID_DM_ST_DialMinutes );
    ASSERT(pInfo->hwndStDialMinutes);
    pInfo->hwndStHangUp = GetDlgItem( hwndDlg, CID_DM_ST_HangUp );
    ASSERT(pInfo->hwndStHangUp);
    pInfo->hwndLbHangUpPercent = GetDlgItem( hwndDlg, CID_DM_LB_HangUpPercent );
    ASSERT(pInfo->hwndLbHangUpPercent);
    pInfo->hwndStHangUpOrLess = GetDlgItem( hwndDlg, CID_DM_ST_HangUpOrLess );
    ASSERT(pInfo->hwndStHangUpOrLess);
    pInfo->hwndEbHangUpMinutes = GetDlgItem( hwndDlg, CID_DM_EB_HangUpMinutes );
    ASSERT(pInfo->hwndEbHangUpMinutes);
    pInfo->hwndStHangUpMinutes = GetDlgItem( hwndDlg, CID_DM_ST_HangUpMinutes );
    ASSERT(pInfo->hwndStHangUpMinutes);

    /* Install the spin-button controls and initialize the edit fields.
    */
    {
        HWND hwndUdDialMinutes;
        HWND hwndUdHangUpMinutes;

        hwndUdDialMinutes = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER + UDS_SETBUDDYINT +
                UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
            0, 0, 0, 0, hwndDlg, 100, g_hinstDll, pInfo->hwndEbDialMinutes,
            UD_MAXVAL, 0, 0 );
        ASSERT(hwndUdDialMinutes);
        Edit_LimitText( pInfo->hwndEbDialMinutes, 7 );
        SetDlgItemInt( hwndDlg, CID_DM_EB_DialMinutes,
            pEntry->dwDialSeconds / 60, FALSE );

        hwndUdHangUpMinutes = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER + UDS_SETBUDDYINT +
                UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
            0, 0, 0, 0, hwndDlg, 101, g_hinstDll, pInfo->hwndEbHangUpMinutes,
            UD_MAXVAL, 0, 0 );
        ASSERT(hwndUdHangUpMinutes);
        Edit_LimitText( pInfo->hwndEbHangUpMinutes, 7 );
        SetDlgItemInt( hwndDlg, CID_DM_EB_HangUpMinutes,
            pEntry->dwHangUpSeconds / 60, FALSE );
    }

    /* Initialize the drop lists.
    */
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("0%"), (VOID* )0 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("10%"), (VOID* )10 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("20%"), (VOID* )20 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("30%"), (VOID* )30 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("40%"), (VOID* )40 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("50%"), (VOID* )50 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("60%"), (VOID* )60 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("70%"), (VOID* )70 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("80%"), (VOID* )80 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("90%"), (VOID* )90 );
    ComboBox_AddItem( pInfo->hwndLbDialPercent, TEXT("100%"), (VOID* )100 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("0%"), (VOID* )0 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("10%"), (VOID* )10 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("20%"), (VOID* )20 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("30%"), (VOID* )30 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("40%"), (VOID* )40 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("50%"), (VOID* )50 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("60%"), (VOID* )60 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("70%"), (VOID* )70 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("80%"), (VOID* )80 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("90%"), (VOID* )90 );
    ComboBox_AddItem( pInfo->hwndLbHangUpPercent, TEXT("100%"), (VOID* )100 );

    ComboBox_SetCurSel( pInfo->hwndLbDialPercent,
        (min( pEntry->dwDialPercent, 100 )) / 10 );
    ComboBox_SetCurSel( pInfo->hwndLbHangUpPercent,
        (min( pEntry->dwHangUpPercent, 100 )) / 10 );

    /* Set the radio button selection, triggering appropriate
    ** enabling/disabling.
    */
    {
        HWND hwndRb;

        if (pEntry->dwDialMode = RASEDM_DialAll)
            hwndRb = pInfo->hwndRbDialAll;
        else
            hwndRb = pInfo->hwndRbDialAsNeeded;

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
DmSave(
    IN DMINFO* pInfo )

    /* Save the current dialog state in the stub API entry buffer.  'PInfo' is
    ** the dialog context.
    */
{
    UINT unValue;
    BOOL f;

    TRACE("DmSave");

    if (Button_GetCheck( pInfo->hwndRbDialAll ))
        pInfo->pEntry->dwDialMode = RASEDM_DialAll;
    else
        pInfo->pEntry->dwDialMode = RASEDM_DialAsNeeded;

    pInfo->pEntry->dwDialPercent = (DWORD)
        ComboBox_GetItemData( pInfo->hwndLbDialPercent,
            ComboBox_GetCurSel( pInfo->hwndLbDialPercent ) );

    unValue = GetDlgItemInt(
        pInfo->hwndDlg, CID_DM_EB_DialMinutes, &f, FALSE );
    if (f && unValue <= 9999999)
        pInfo->pEntry->dwDialSeconds = (DWORD )unValue * 60;

    pInfo->pEntry->dwHangUpPercent = (DWORD)
        ComboBox_GetItemData( pInfo->hwndLbHangUpPercent,
            ComboBox_GetCurSel( pInfo->hwndLbHangUpPercent ) );

    unValue = GetDlgItemInt(
        pInfo->hwndDlg, CID_DM_EB_HangUpMinutes, &f, FALSE );
    if (f && unValue <= 9999999)
        pInfo->pEntry->dwHangUpSeconds = (DWORD )unValue * 60;

    pInfo->pEntry->fDirty = TRUE;
}


VOID
DmTerm(
    IN HWND hwndDlg )

    /* Dialog termination.  Releases the context block.  'HwndDlg' is the
    ** handle of a dialog.
    */
{
    DMINFO* pInfo;

    TRACE("DmTerm");

    pInfo = (DMINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE("Context freed");
    }
}


VOID
DmUpdateAsNeededState(
    IN DMINFO* pInfo )

    /* Enable/disable "as needed" controls based on radio button selection.
    ** 'PInfo' is the dialog context.
    */
{
    BOOL f;

    TRACE("DmUpdateAsNeededState");

    f = Button_GetCheck( pInfo->hwndRbDialAsNeeded );

    EnableWindow( pInfo->hwndStDial, f );
    EnableWindow( pInfo->hwndLbDialPercent, f );
    EnableWindow( pInfo->hwndStDialOrMore, f );
    EnableWindow( pInfo->hwndEbDialMinutes, f );
    EnableWindow( pInfo->hwndStDialMinutes, f );
    EnableWindow( pInfo->hwndStHangUp, f );
    EnableWindow( pInfo->hwndLbHangUpPercent, f );
    EnableWindow( pInfo->hwndStHangUpOrLess, f );
    EnableWindow( pInfo->hwndEbHangUpMinutes, f );
    EnableWindow( pInfo->hwndStHangUpMinutes, f );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\tcpip.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** tcpip.c
** Remote Access Common Dialog APIs
** TCPIP Settings dialogs
**
** 08/28/95 Steve Cobb
*/

#include "rasdlgp.h"


/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwPtHelp[] =
{
    CID_IP_RB_ServerAssigned,   HID_PT_RB_ServerAssigned,
    CID_IP_RB_SpecificIp,       HID_PT_RB_SpecificIp,
    CID_IP_GB_SpecificIp,       HID_PT_RB_SpecificIp,
    CID_IP_ST_IpAddress,        HID_PT_CC_IpAddress,
    CID_IP_CC_IpAddress,        HID_PT_CC_IpAddress,
    CID_IP_RB_AssignedName,     HID_PT_RB_AssignedName,
    CID_IP_RB_SpecificNames,    HID_PT_RB_SpecificNames,
    CID_IP_RB_NoNames,          HID_PT_RB_NoNames,
    CID_IP_GB_SpecificName,     HID_PT_RB_SpecificNames,
    CID_IP_ST_Dns,              HID_PT_CC_Dns,
    CID_IP_CC_Dns,              HID_PT_CC_Dns,
    CID_IP_ST_DnsBackup,        HID_PT_CC_DnsBackup,
    CID_IP_CC_DnsBackup,        HID_PT_CC_DnsBackup,
    CID_IP_ST_Wins,             HID_PT_CC_Wins,
    CID_IP_CC_Wins,             HID_PT_CC_Wins,
    CID_IP_ST_WinsBackup,       HID_PT_CC_WinsBackup,
    CID_IP_CC_WinsBackup,       HID_PT_CC_WinsBackup,
    CID_IP_CB_Vj,               HID_PT_CB_Vj,
    CID_IP_CB_PrioritizeRemote, HID_PT_CB_PrioritizeRemote,
    0, 0
};

static DWORD g_adwStHelp[] =
{
    CID_IP_ST_IpAddress,        HID_ST_CC_IpAddress,
    CID_IP_CC_IpAddress,        HID_ST_CC_IpAddress,
    CID_IP_GB_SpecificName,     HID_ST_GB_SpecificName,
    CID_IP_ST_Dns,              HID_ST_CC_Dns,
    CID_IP_CC_Dns,              HID_ST_CC_Dns,
    CID_IP_ST_DnsBackup,        HID_ST_CC_DnsBackup,
    CID_IP_CC_DnsBackup,        HID_ST_CC_DnsBackup,
    CID_IP_ST_Wins,             HID_ST_CC_Wins,
    CID_IP_CC_Wins,             HID_ST_CC_Wins,
    CID_IP_ST_WinsBackup,       HID_ST_CC_WinsBackup,
    CID_IP_CC_WinsBackup,       HID_ST_CC_WinsBackup,
    CID_IP_CB_Vj,               HID_ST_CB_Vj,
    CID_IP_CB_PrioritizeRemote, HID_ST_CB_PrioritizeRemote,
    CID_IP_ST_FrameSize,        HID_ST_LB_FrameSize,
    CID_IP_LB_FrameSize,        HID_ST_LB_FrameSize,
    0, 0
};

/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* PPP TCP/IP Settings dialog context block.
*/
#define PTINFO struct tagPTINFO
PTINFO
{
    /* Caller's arguments to the dialog.
    */
    PBENTRY* pEntry;
    BOOL     fRouter;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndRbAssignedIp;
    HWND hwndRbSpecificIp;
    HWND hwndRbAssignedNames;
    HWND hwndRbNoNames;
    HWND hwndRbSpecificNames;
    HWND hwndCcIp;
    HWND hwndCcDns;
    HWND hwndCcDnsBackup;
    HWND hwndCcWins;
    HWND hwndCcWinsBackup;
    HWND hwndCbCompress;
    HWND hwndCbRemote;
    HWND hwndStSpecificIp;
    HWND hwndStDns;
    HWND hwndStDnsBackup;
    HWND hwndStWins;
    HWND hwndStWinsBackup;
};


/* Dialog argument block.
*/
#define PTARGS struct tagPTARGS
PTARGS
{
    PBENTRY* pEntry;
    BOOL     fRouter;
};


/* SLIP TCP/IP Settings dialog context block.
*/
#define STINFO struct tagSTINFO
STINFO
{
    /* Caller's arguments to the dialog.
    */
    PBENTRY* pEntry;

    /* Handle of this dialog and some of it's controls.
    */
    HWND hwndDlg;
    HWND hwndCcIp;
    HWND hwndCcDns;
    HWND hwndCcDnsBackup;
    HWND hwndCcWins;
    HWND hwndCcWinsBackup;
    HWND hwndCbCompress;
    HWND hwndCbRemote;
    HWND hwndLbFrameSize;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

BOOL
PtCommand(
    IN PTINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
PtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
PtEnableIpAddressFields(
    IN PTINFO* pInfo,
    IN BOOL    fEnable );

VOID
PtEnableNameServerFields(
    IN PTINFO* pInfo,
    IN BOOL    fEnable );

BOOL
PtInit(
    IN HWND    hwndDlg,
    IN PTARGS* pArgs );

BOOL
PtSaveSettings(
    IN PTINFO* pInfo );

VOID
PtTerm(
    IN HWND hwndDlg );

BOOL
StCommand(
    IN STINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
StDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
StInit(
    IN HWND     hwndDlg,
    IN PBENTRY* pEntry );

BOOL
StSaveSettings(
    IN STINFO* pInfo );

VOID
StTerm(
    IN HWND hwndDlg );


/*----------------------------------------------------------------------------
** PPP TCP/IP entry point
**----------------------------------------------------------------------------
*/

BOOL
PppTcpipDlg(
    IN     HWND     hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN     BOOL     fRouter )

    /* Pops-up the TCPIP info dialog for PPP.  Initial address settings are
    ** read from 'pEntry' and the result of user's edits written there on "OK"
    ** exit.  'HwndOwner' is the window owning the dialog.  'FRouter' is set
    ** when the router version of the dialog should be displayed.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    int    nStatus;
    PTARGS args;

    TRACE("PppTcpipDlg");

    args.pEntry = pEntry;
    args.fRouter = fRouter;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (fRouter)
                ? MAKEINTRESOURCE( DID_PT_RouterPppTcpipSettings )
                : MAKEINTRESOURCE( DID_PT_PppTcpipSettings ),
            hwndOwner,
            PtDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


/*----------------------------------------------------------------------------
** PPP TCP/IP Settings dialog
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
PtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the TCPIP Settings dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("PtDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return PtInit( hwnd, (PTARGS* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwPtHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            PTINFO* pInfo = (PTINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return PtCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            PtTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
PtCommand(
    IN PTINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("PtCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case CID_IP_RB_ServerAssigned:
            PtEnableIpAddressFields( pInfo, FALSE );
            return TRUE;

        case CID_IP_RB_SpecificIp:
            PtEnableIpAddressFields( pInfo, TRUE );
            return TRUE;

        case CID_IP_RB_AssignedName:
        case CID_IP_RB_NoNames:
            PtEnableNameServerFields( pInfo, FALSE );
            return TRUE;

        case CID_IP_RB_SpecificNames:
            PtEnableNameServerFields( pInfo, TRUE );
            return TRUE;

        case IDOK:
            if (PtSaveSettings( pInfo ))
                EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;

        case IDCANCEL:
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
    }

    return FALSE;
}


VOID
PtEnableIpAddressFields(
    IN PTINFO* pInfo,
    IN BOOL    fEnable )

    /* Enable or disable the IP address fields based on 'fEnable'.  'PInfo' is
    ** the dialog context block.
    */
{
    TRACE1("PtEnableIpAddressFields(f=%d)",fEnable);

    EnableWindow( pInfo->hwndStSpecificIp, fEnable );
    EnableWindow( pInfo->hwndCcIp, fEnable );
}


VOID
PtEnableNameServerFields(
    IN PTINFO* pInfo,
    IN BOOL    fEnable )

    /* Enable or disable the name server IP address fields based on 'fEnable'.
    ** 'PInfo' is the dialog context block.
    */
{
    TRACE1("PtEnableNameServerFields(f=%d)",fEnable);

    EnableWindow( pInfo->hwndStDns, fEnable );
    EnableWindow( pInfo->hwndCcDns, fEnable );
    EnableWindow( pInfo->hwndStDnsBackup, fEnable );
    EnableWindow( pInfo->hwndCcDnsBackup, fEnable );
    EnableWindow( pInfo->hwndStWins, fEnable );
    EnableWindow( pInfo->hwndCcWins, fEnable );
    EnableWindow( pInfo->hwndStWinsBackup, fEnable );
    EnableWindow( pInfo->hwndCcWinsBackup, fEnable );
}


BOOL
PtInit(
    IN HWND    hwndDlg,
    IN PTARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    ** dialog window.  'pArgs' is caller's arguments as passed to the stub
    ** API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    PTINFO* pInfo;

    TRACE("PtInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pEntry = pArgs->pEntry;
        pInfo->fRouter = pArgs->fRouter;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndRbAssignedIp = GetDlgItem( hwndDlg, CID_IP_RB_ServerAssigned );
    ASSERT(pInfo->hwndRbAssignedIp);
    pInfo->hwndRbSpecificIp = GetDlgItem( hwndDlg, CID_IP_RB_SpecificIp );
    ASSERT(pInfo->hwndRbSpecificIp);
    pInfo->hwndRbAssignedNames = GetDlgItem( hwndDlg, CID_IP_RB_AssignedName );
    ASSERT(pInfo->hwndRbAssignedNames);
    pInfo->hwndRbSpecificNames = GetDlgItem( hwndDlg, CID_IP_RB_SpecificNames );
    ASSERT(pInfo->hwndRbSpecificNames);
    pInfo->hwndCcIp = GetDlgItem( hwndDlg, CID_IP_CC_IpAddress );
    ASSERT(pInfo->hwndCcIp);
    pInfo->hwndCcDns = GetDlgItem( hwndDlg, CID_IP_CC_Dns );
    ASSERT(pInfo->hwndCcDns);
    pInfo->hwndCcDnsBackup = GetDlgItem( hwndDlg, CID_IP_CC_DnsBackup );
    ASSERT(pInfo->hwndCcDnsBackup);
    pInfo->hwndCcWins = GetDlgItem( hwndDlg, CID_IP_CC_Wins );
    ASSERT(pInfo->hwndCcWins);
    pInfo->hwndCcWinsBackup = GetDlgItem( hwndDlg, CID_IP_CC_WinsBackup );
    ASSERT(pInfo->hwndCcWinsBackup);
    pInfo->hwndCbCompress = GetDlgItem( hwndDlg, CID_IP_CB_Vj );
    ASSERT(pInfo->hwndCbCompress);
    pInfo->hwndStSpecificIp = GetDlgItem( hwndDlg, CID_IP_ST_IpAddress );
    ASSERT(pInfo->hwndStSpecificIp);
    pInfo->hwndStDns = GetDlgItem( hwndDlg, CID_IP_ST_Dns );
    ASSERT(pInfo->hwndStDns);
    pInfo->hwndStDnsBackup = GetDlgItem( hwndDlg, CID_IP_ST_DnsBackup );
    ASSERT(pInfo->hwndStDnsBackup);
    pInfo->hwndStWins = GetDlgItem( hwndDlg, CID_IP_ST_Wins );
    ASSERT(pInfo->hwndStWins);
    pInfo->hwndStWinsBackup = GetDlgItem( hwndDlg, CID_IP_ST_WinsBackup );
    ASSERT(pInfo->hwndStWinsBackup);

    if (pInfo->fRouter)
    {
        pInfo->hwndRbNoNames = GetDlgItem( hwndDlg, CID_IP_RB_NoNames );
        ASSERT(pInfo->hwndRbNoNames);
    }
    else
    {
        pInfo->hwndCbRemote = GetDlgItem( hwndDlg, CID_IP_CB_PrioritizeRemote );
        ASSERT(pInfo->hwndCbRemote);
    }

    /* Select the IP address and name server address radio buttons as defined
    ** in the entry.  This also triggers appropriate enable/disable status.
    */
    SendMessage(
        (pInfo->pEntry->dwIpAddressSource == ASRC_RequireSpecific)
            ? pInfo->hwndRbSpecificIp : pInfo->hwndRbAssignedIp,
        BM_CLICK, 0, 0 );

    {
        HWND hwndRb;

        if (pInfo->pEntry->dwIpNameSource == ASRC_ServerAssigned)
            hwndRb = pInfo->hwndRbAssignedNames;
        else if (pInfo->pEntry->dwIpNameSource == ASRC_RequireSpecific)
            hwndRb = pInfo->hwndRbSpecificNames;
        else
            hwndRb = pInfo->hwndRbNoNames;

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    /* Set the IP address and name server addresses as defined in the entry.
    */
    SetWindowText( pInfo->hwndCcIp, pInfo->pEntry->pszIpAddress );
    SetWindowText( pInfo->hwndCcDns, pInfo->pEntry->pszIpDnsAddress );
    SetWindowText( pInfo->hwndCcDnsBackup, pInfo->pEntry->pszIpDns2Address );
    SetWindowText( pInfo->hwndCcWins, pInfo->pEntry->pszIpWinsAddress );
    SetWindowText( pInfo->hwndCcWinsBackup, pInfo->pEntry->pszIpWins2Address );

    /* Select check box settings as defined in the entry.
    */
    if (pInfo->pEntry->fIpHeaderCompression)
        SendMessage( pInfo->hwndCbCompress, BM_CLICK, 0, 0 );

    if (!pInfo->fRouter)
    {
        if (pInfo->pEntry->fIpPrioritizeRemote)
            SendMessage( pInfo->hwndCbRemote, BM_CLICK, 0, 0 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    /* Set initial focus to selected IP address radio button.
    */
    SetFocus(
        (pInfo->pEntry->dwIpAddressSource == ASRC_RequireSpecific)
            ? pInfo->hwndRbSpecificIp : pInfo->hwndRbAssignedIp );

    return FALSE;
}


BOOL
PtSaveSettings(
    IN PTINFO* pInfo )

    /* Saves dialog settings in the entry.  'PInfo' is the dialog context.
    **
    ** Returns true if successful, false if does not validate.
    */
{
    PBENTRY* pEntry;
    DWORD    dwIpAddressSource;
    TCHAR*   pszIpAddress;

    TRACE("PtSaveSettings");

    pEntry = pInfo->pEntry;

    dwIpAddressSource =
        (Button_GetCheck( pInfo->hwndRbSpecificIp ))
            ? ASRC_RequireSpecific : ASRC_ServerAssigned;

    pszIpAddress = GetText( pInfo->hwndCcIp );

    if (dwIpAddressSource == ASRC_RequireSpecific
        && (!pszIpAddress || lstrcmp( pszIpAddress, TEXT("0.0.0.0") ) == 0))
    {
        MsgDlg( pInfo->hwndDlg, SID_NoIpAddress, NULL );
        SetFocus( pInfo->hwndCcIp );
        Free0( pszIpAddress );
        return FALSE;
    }

    pEntry->dwIpAddressSource = dwIpAddressSource;
    Free0( pEntry->pszIpAddress );
    pEntry->pszIpAddress = pszIpAddress;

    pEntry->dwIpNameSource =
        (Button_GetCheck( pInfo->hwndRbSpecificNames ))
            ? ASRC_RequireSpecific
            : (Button_GetCheck( pInfo->hwndRbAssignedNames )
                  ? ASRC_ServerAssigned
                  : ASRC_None);

    Free0( pEntry->pszIpDnsAddress );
    pEntry->pszIpDnsAddress = GetText( pInfo->hwndCcDns );
    Free0( pEntry->pszIpDns2Address );
    pEntry->pszIpDns2Address = GetText( pInfo->hwndCcDnsBackup );
    Free0( pEntry->pszIpWinsAddress );
    pEntry->pszIpWinsAddress = GetText( pInfo->hwndCcWins );
    Free0( pEntry->pszIpWins2Address );
    pEntry->pszIpWins2Address = GetText( pInfo->hwndCcWinsBackup );

    pEntry->fIpHeaderCompression = Button_GetCheck( pInfo->hwndCbCompress );

    if (!pInfo->fRouter)
        pEntry->fIpPrioritizeRemote = Button_GetCheck( pInfo->hwndCbRemote );

    pEntry->fDirty = TRUE;
    return TRUE;
}


VOID
PtTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    PTINFO* pInfo = (PTINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("PtTerm");

    if (pInfo)
        Free( pInfo );
}


/*----------------------------------------------------------------------------
** SLIP TCP/IP entry point
**----------------------------------------------------------------------------
*/

BOOL
SlipTcpipDlg(
    IN     HWND     hwndOwner,
    IN OUT PBENTRY* pEntry )

    /* Pops-up the TCPIP info dialog for SLIP.  Initial address settings are
    ** read from 'pEntry' and the result of user's edits written there on "OK"
    ** exit.  'HwndOwner' is the window owning the dialog.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    int nStatus;

    TRACE("SlipTcpipDlg");

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_ST_SlipTcpipSettings ),
            hwndOwner,
            StDlgProc,
            (LPARAM )pEntry );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


/*----------------------------------------------------------------------------
** SLIP TCP/IP Settings dialog
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
StDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the TCPIP Settings dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("StDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return StInit( hwnd, (PBENTRY* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwStHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            STINFO* pInfo = (STINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return StCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            StTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
StCommand(
    IN STINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE2("StCommand(n=%d,i=%d)",
        (DWORD)wNotification,(DWORD)wId);

    switch (wId)
    {
        case IDOK:
            if (StSaveSettings( pInfo ))
                EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;

        case IDCANCEL:
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
    }

    return FALSE;
}


BOOL
StInit(
    IN HWND     hwndDlg,
    IN PBENTRY* pEntry )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    ** dialog window.  'pEntry' is caller's entry as passed to the stub API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    STINFO* pInfo;

    TRACE("StInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pEntry = pEntry;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)pInfo );
        TRACE("Context set");
    }

    pInfo->hwndCcIp = GetDlgItem( hwndDlg, CID_IP_CC_IpAddress );
    ASSERT(pInfo->hwndCcIp);
    pInfo->hwndCcDns = GetDlgItem( hwndDlg, CID_IP_CC_Dns );
    ASSERT(pInfo->hwndCcDns);
    pInfo->hwndCcDnsBackup = GetDlgItem( hwndDlg, CID_IP_CC_DnsBackup );
    ASSERT(pInfo->hwndCcDnsBackup);
    pInfo->hwndCcWins = GetDlgItem( hwndDlg, CID_IP_CC_Wins );
    ASSERT(pInfo->hwndCcWins);
    pInfo->hwndCcWinsBackup = GetDlgItem( hwndDlg, CID_IP_CC_WinsBackup );
    ASSERT(pInfo->hwndCcWinsBackup);
    pInfo->hwndCbCompress = GetDlgItem( hwndDlg, CID_IP_CB_Vj );
    ASSERT(pInfo->hwndCbCompress);
    pInfo->hwndCbRemote = GetDlgItem( hwndDlg, CID_IP_CB_PrioritizeRemote );
    ASSERT(pInfo->hwndCbRemote);
    pInfo->hwndLbFrameSize = GetDlgItem( hwndDlg, CID_IP_LB_FrameSize );
    ASSERT(pInfo->hwndLbFrameSize);

    /* Set the IP address and name server addresses as defined in the entry.
    */
    SetWindowText( pInfo->hwndCcIp, pEntry->pszIpAddress );
    SetWindowText( pInfo->hwndCcDns, pEntry->pszIpDnsAddress );
    SetWindowText( pInfo->hwndCcDnsBackup, pEntry->pszIpDns2Address );
    SetWindowText( pInfo->hwndCcWins, pEntry->pszIpWinsAddress );
    SetWindowText( pInfo->hwndCcWinsBackup, pEntry->pszIpWins2Address );

    /* Select check box settings as defined in the entry.
    */
    if (pEntry->fIpHeaderCompression)
        SendMessage( pInfo->hwndCbCompress, BM_CLICK, 0, 0 );
    if (pEntry->fIpPrioritizeRemote)
        SendMessage( pInfo->hwndCbRemote, BM_CLICK, 0, 0 );

    /* Fill frame size list and select as defined in the entry.
    */
    ComboBox_AddItem( pInfo->hwndLbFrameSize, TEXT("1006"), (VOID* )1006 );
    ComboBox_AddItem( pInfo->hwndLbFrameSize, TEXT("1500"), (VOID* )1500 );

    if (pEntry->dwFrameSize == 1006)
        ComboBox_SetCurSel( pInfo->hwndLbFrameSize, 0 );
    else if (pEntry->dwFrameSize == 1500)
        ComboBox_SetCurSel( pInfo->hwndLbFrameSize, 1 );
    else
    {
        TCHAR szBuf[ MAXLTOTLEN + 1 ];

        LToT( pEntry->dwFrameSize, szBuf, 10 );
        ComboBox_AddItem( pInfo->hwndLbFrameSize,
            szBuf, (VOID* )UlongToPtr(pEntry->dwFrameSize));
        ComboBox_SetCurSel( pInfo->hwndLbFrameSize, 2 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    /* Add context help button to title bar.  Dlgedit.exe doesn't currently
    ** support this at resource edit time.  When that's fixed set
    ** DS_CONTEXTHELP there and remove this call.
    */
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


BOOL
StSaveSettings(
    IN STINFO* pInfo )

    /* Saves dialog settings in the entry.  'PInfo' is the dialog context.
    **
    ** Returns true if successful, false if does not validate.
    */
{
    PBENTRY* pEntry;

    TRACE("StSaveSettings");

    pEntry = pInfo->pEntry;

    Free0( pEntry->pszIpAddress );
    pEntry->pszIpAddress = GetText( pInfo->hwndCcIp );
    Free0( pEntry->pszIpDnsAddress );
    pEntry->pszIpDnsAddress = GetText( pInfo->hwndCcDns );
    Free0( pEntry->pszIpDns2Address );
    pEntry->pszIpDns2Address = GetText( pInfo->hwndCcDnsBackup );
    Free0( pEntry->pszIpWinsAddress );
    pEntry->pszIpWinsAddress = GetText( pInfo->hwndCcWins );
    Free0( pEntry->pszIpWins2Address );
    pEntry->pszIpWins2Address = GetText( pInfo->hwndCcWinsBackup );

    pEntry->fIpHeaderCompression = Button_GetCheck( pInfo->hwndCbCompress );
    pEntry->fIpPrioritizeRemote = Button_GetCheck( pInfo->hwndCbRemote );

    pEntry->dwFrameSize = (DWORD)
        ComboBox_GetItemData( pInfo->hwndLbFrameSize,
            ComboBox_GetCurSel( pInfo->hwndLbFrameSize ) );

    pEntry->fDirty = TRUE;
    return TRUE;
}


VOID
StTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    STINFO* pInfo = (STINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("StTerm");

    if (pInfo)
        Free( pInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\status.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    status.h
//
// History:
//  Abolade Gbadegesin  Nov-06-1995     Created.
//
// Declarations for RAS status dialog.
//============================================================================


#ifndef _STATUS_H_
#define _STATUS_H_

#include "status.rch"


//
// Number of pages on the Dial-Up Monitor property sheet
//
#define RASMDPAGE_Count                 3
//
// IDs for timers used by Status and Summary pages
//
#define RM_LSTIMERID                    1
#define RM_SMTIMERID                    2
//
// value used as frequency for updates of dial-in display on Summary page
//
#define RM_SMDIALINFREQUENCY            4
//
// macros used to get icon IDs from array indices and vice-versa
//
#define RM_ICONCOUNT                    (IID_RM_IconLast - IID_RM_IconBase + 1)
#define RM_ICONID(index)                ((index) + IID_RM_IconBase)
#define RM_ICONINDEX(id)                ((id) - IID_RM_IconBase)
//
// flags used on the Summary page for efficient list refreshing
//
#define RMFLAG_DELETE                   0x80000000
#define RMFLAG_INSERT                   0x40000000
#define RMFLAG_MODIFY                   0x20000000
//
// error dialog macro used by all Connection Status property pages
//
#define RmErrorDlg(h,o,e,a) \
        ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_RM_RasMonitor,SID_FMT_ErrorMsg)
#define RmMsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_RM_RasMonitor)



//
// definition for arguments passed to RmPropertySheet
//
#define RMARGS struct tagRMARGS
RMARGS {

    BOOL            fUserHangUp;
    PTSTR           pszDeviceName;
    RASMONITORDLG  *pApiArgs;

};



//
// definition for each entry in the list of devices
// which are displayed on the Line Status property page
//
#define LSDEVICE    struct tagLSDEVICE
LSDEVICE {

    LIST_ENTRY          leDevices;

    RASDEV             *prasdev;
    UINT                dwFlags;
    
};


//
// definition of the header for each item in the treelist
// which is displayed on the Summary property page
//
#define SMENTRYHDR \
    DWORD               dwType; \
    UINT                dwFlags; \
    DWORD               dwDuration; \
    HTLITEM             hItem; \
    LIST_ENTRY          leNode


//
// definition of the base-portion of each item in the Summary page treelist
//
#define SMENTRY struct tagSMENTRY
SMENTRY {
    SMENTRYHDR;
};


//
// values used in the dwType field for Summary page treelist-entries
//
#define SMTYPE_Network      0
#define SMTYPE_Link         1
#define SMTYPE_Client       2
#define SMTYPE_Port         3
#define SMTYPE_IdleLines    4
#define SMTYPE_IdleDevice   5


//
// definition for each entry in the list of networks
// which is displayed on the Summary property page;
// note that the lhLinks field is in the same position
// as the lhPorts field of the SMCLIENT structure
//
#define SMNETWORK struct tagSMNETWORK
SMNETWORK {

    SMENTRYHDR;

    LIST_ENTRY          lhLinks;
    PTSTR               pszEntryName;
    HRASCONN            hrasconn;

};



//
// definition for each entry in a network's list of links,
// displayed for each network on the Summary property page;
// note that the first three fields (apart from the header)
// are in the same order as for the SMPORT structure
//
#define SMLINK struct tagSMLINK
SMLINK {

    SMENTRYHDR;

    PTSTR               pszDeviceName;
    DWORD               dwIconIndex;
    RASDEV             *prasdev;
    HRASCONN            hrasconn;

};



//
// definition for each entry in the list of clients
// which is displayed on the Summary property page;
// note that the lhPorts field is in the same position
// as the lhLinks field of the SMNETWORK structure
//
#define SMCLIENT struct tagSMCLIENT
SMCLIENT {

    SMENTRYHDR;

    LIST_ENTRY          lhPorts;
    PTSTR               pszClientName;
    RASDEV             *prasdev;
    DWORD               dwBundle;

};


//
// definition for each entry in a client's list of links.
// displayed for each client on the Summary property page
// note that the first three fields (apart from the header)
// are in the same order as for the SMLINK structure
//
#define SMPORT struct tagSMPORT
SMPORT {

    SMENTRYHDR;

    PTSTR               pszDeviceName;
    DWORD               dwIconIndex;
    RASDEV             *prasdev;
    WCHAR               wszPortName[MAX_PORT_NAME + 1];

};




//
// definition of data for an instance of the RAS Monitor page;
// This structure is global to all the pages in the property sheet.
// The first page to be displayed is responsible for initializing it
// in the pages WM_INITDIALOG handler.
//
#define RMINFO struct tagRMINFO
RMINFO {


    //
    // Sheet-wide variables:
    //
    // arguments passed to RasMonitorDlg
    //
    RMARGS     *pArgs;
    //
    // flag indicating changes need to be applied
    //
    BOOL        bDirty;
    //
    // flag indicating one or more devices is configured for dial-in
    //
    BOOL        bDialIn;
    //
    // id for timer of currently-displayed page
    //
    UINT        uiTimerId;
    //
    // current user preferences for RASMON
    //
    RMUSER      rbRmUser;
    //
    // RAS device count and device table
    //
    DWORD       iRmDevCount;
    RASDEV     *pRmDevTable;
    //
    // TAPI hlineapp for the property sheet
    //
    HLINEAPP    hRmLineApp;
    //
    // property sheet and page window handles
    //
    HWND        hwndDlg;
    HWND        hwndFirstPage;
    HWND        hwndLs;
    HWND        hwndSm;
    HWND        hwndPf;
    HWND        hwndAv;
    //
    // sheet-wide imagelist and icon table
    //
    HIMAGELIST  hIconList;
    INT         pIconTable[RM_ICONCOUNT];
    //
    // handle to shared-memory containing the HWND for the property sheet
    //
    HANDLE      hmap;



    //
    // Status page variables:
    //
    // device combobox window handle,
    // list of LSDEVICE structures for installed devices,
    // stats for currently selected device,
    // and flag indicating first-time refresh
    //
    HWND        hwndLsDevices;
    LIST_ENTRY  lhLsDevices;
    RASDEVSTATS rdsLsStats;
    BOOL        bLsFirst;
    BOOL        bLsSetCondition;



    //
    // Summary page variables:
    //
    // connection treelist window handle,
    // list of SMNETWORK structures for outgoing calls,
    // list of SMCLIENT structures for incoming calls,
    // flag indicating first-time refresh,
    // and DWORD used to see whether or not to refresh the dial-in display
    //
    HWND        hwndSmNetworks;
    LIST_ENTRY  lhSmNetworks;
    LIST_ENTRY  lhSmClients;
    BOOL        bSmFirst;
    DWORD       dwSmDialInUpdate;


    //
    // Preferences page variables:
    //
    // locations combobox window handle,
    // locations checkbox listview window handle,
    // and flag set when checkbox-listview is initialized.
    //
#ifdef BETAHACK
    HWND        hwndPfLbLocations;
    BOOL        fPfChecks;
    HWND        hwndPfLvEnable;
#endif

};




//
// RAS Monitor property sheet function prototypes
//

RMINFO *
RmContext(
    HWND hwndPage
    );

RMINFO *
RmInit(
    HWND hwndFirstPage,
    RMARGS *pArgs
    );

VOID
RmInitFail(
    RMINFO *pInfo,
    DWORD dwOp,
    DWORD dwErr
    );

BOOL
RmApply(
    HWND hwndPage
    );

VOID
RmExit(
    HWND hwndPage,
    DWORD dwErr
    );

VOID
RmPropertySheet(
    RMARGS *pArgs
    );


DWORD
RmArgsInit(
    PTSTR pszDeviceName,
    RASMONITORDLG *pInfo,
    RMARGS *pArgs
    );

DWORD
RmArgsFree(
    RMARGS *pArgs
    );


//
// Status property page function prototypes
//

INT_PTR 
CALLBACK
LsDlgProc(
    HWND hwndPage,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
LsInit(
    HWND hwndPage,
    RMARGS *pArgs
    );

DWORD
LsLoadDeviceList(
    RMINFO *pInfo
    );

BOOL
LsCommand(
    RMINFO *pInfo,
    WORD wNotification,
    WORD wCtrlId,
    HWND hwndCtrl
    );

DWORD
LsRefresh(
    RMINFO *pInfo
    );

VOID
LsUpdateConnectResponse(
    RMINFO* pInfo,
    RASDEV* prasdev,
    RASDEVSTATS* pstats
    );

DWORD
LsUpdateDeviceList(
    RMINFO *pInfo
    );

LSDEVICE *
LsCreateDevice(
    RASDEV *pdev
    );

TCHAR*
LsFormatPszFromId(
    UINT    idsFmt,
    TCHAR*  pszArg
    );


//
// Summary property page function prototypes
//

INT_PTR 
CALLBACK
SmDlgProc(
    HWND hwndDlg,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
SmInit(
    HWND hwndDlg,
    RMARGS *pArgs
    );

LRESULT
SmFrameProc(
    HWND hwndFrame,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
SmCommand(
    RMINFO *pInfo,
    WORD wNotification,
    WORD wCtrlId,
    HWND hwndCtrl
    );

DWORD
SmRefresh(
    RMINFO *pInfo
    );

DWORD
SmUpdateItemList(
    RMINFO *pInfo,
    BOOL bDialInUpdate
    );

SMENTRY *
SmDisplayItemList(
    RMINFO *pInfo,
    LIST_ENTRY *phead,
    SMENTRY *pprev
    );

SMNETWORK *
SmCreateNetwork(
    RASCONN *pconn,
    RASDEV *prasdev
    );

SMCLIENT *
SmCreateClient(
    RMINFO *pInfo,
    RAS_PORT_0 *prp0,
    RASDEV *prasdev
    );

SMLINK *
SmCreateLink(
    RMINFO *pInfo,
    RASCONN *pconn,
    RASDEV *prasdev
    );

SMPORT *
SmCreatePort(
    RMINFO *pInfo,
    RAS_PORT_0 *prp0,
    RASDEV *prasdev
    );

SMLINK *
SmCreateLinkInactive(
    RMINFO *pInfo,
    RASDEV *prasdev
    );



//
// Preferences property page function prototypes
//

INT_PTR 
CALLBACK
PfDlgProc(
    HWND hwndDlg,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PfInit(
    HWND hwndDlg,
    RMARGS *pArgs
    );

VOID
PfApply(
    RMINFO *pInfo
    );

DWORD
PfGetFlags(
    RMINFO *pInfo
    );

BOOL
PfCommand(
    RMINFO *pInfo,
    WORD wNotification,
    WORD wCtrlId,
    HWND hwndCtrl
    );

VOID
PfUpdateWindowControls(
    RMINFO* pInfo
    );

#ifdef BETAHACK

LVXDRAWINFO *
PfLvEnableCallback(
    HWND    hwndLv,
    DWORD   dwItem
    );

DWORD
PfFillLocationList(
    RMINFO* pInfo
    );

VOID
PfLocationChange(
    RMINFO* pInfo
    );

VOID
PfEditSelectedLocation(
    RMINFO* pInfo
    );

#endif  // BETAHACK


#endif // _STATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\rasdlgp.h ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** rasdlgp.h
** Remote Access Common Dialog APIs
** Private pre-compiled header
**
** 06/18/95 Steve Cobb
*/

#ifndef _RASDLGP_H_
#define _RASDLGP_H_

#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <ras.h>

#include <commctrl.h> // Win32 common controls
#include <prsht.h>    // Win32 property sheets
#include <tapi.h>     // Telephony API
#include <rasdlg.h>   // Win32 RAS common dialogs (our public header)
#include <raserror.h> // Win32 RAS error codes
#include <pbk.h>      // RAS phonebook library
#include <tapiutil.h> // TAPI helper library
#include <nouiutil.h> // No-HWND helper library
#include <phonenum.h> // Phone number helper library
#include <debug.h>    // Trace/assert library
#include <uiutil.h>   // HWND helper library
#include <rmmem.h>    // RASDLG->RASMON shared memory
#include <wait.rch>   // LoadRas resource constants
#include "rasdlg.rch" // Our resource constants
#include "rasdlg.hch" // Our help context constants


/* Positional offset of property sheets and wizards from the main dialog.
*/
#define DXSHEET 12
#define DYSHEET 25

/* List editor dialog option flags
*/
#define LEDFLAG_NoDeleteLastItem 0x00000001
#define LEDFLAG_Sorted           0x00000002
#define LEDFLAG_Unique           0x00000004


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Defines arguments passed internally via reserved words in the public
** interface.  This is done so an API doesn't have to re-load the phonebook
** and user preferences when serving another API.
*/
#define INTERNALARGS struct tagINTERNALARGS
INTERNALARGS
{
    PBFILE*    pFile;
    PBUSER*    pUser;
    RASNOUSER* pNoUser;
    BOOL       fNoUser;
    BOOL       fNoUserChanged;
    BOOL       fMoveOwnerOffDesktop;
    BOOL       fForceCloseOnDial;
};


/*----------------------------------------------------------------------------
** Global declarations (defined in main.c)
**----------------------------------------------------------------------------
*/

extern HINSTANCE g_hinstDll;
extern LPCWSTR g_contextId;
extern HBITMAP g_hbmWizard;
extern TCHAR* g_pszHelpFile;
extern TCHAR* g_pszRouterHelpFile;
extern HANDLE g_hRmmem;
extern RMMEM* g_pRmmem;


/*----------------------------------------------------------------------------
** Macros
**----------------------------------------------------------------------------
*/

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)

#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

/* Extended tracing macros.  Specifying a flag by name in the first parameter
** allows the caller to categorize messages printed e.g.
**
**     TRACEX(RASDLG_TIMER,"entering LsRefresh")
*/
#define RASDLG_TIMER  ((DWORD)0x80000000|0x00000002)


/*----------------------------------------------------------------------------
** Cross-file prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

BOOL
AllLinksAreModems(
    IN PBENTRY* pEntry );

BOOL
AllLinksAreMxsModems(
    IN PBENTRY* pEntry );

VOID
ContextHelp(
    IN DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
ContextHelpHack(
    IN DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
	IN LPARAM lparam,
    IN BOOL	  fRouter);

HWND
CreateWizardBitmap(
    IN HWND hwndDlg,
    IN BOOL fPage );

BOOL
DeviceConfigureDlg(
    IN HWND    hwndOwner,
    IN PBLINK* pLink,
    IN BOOL    fSingleLink );

TCHAR*
DisplayPszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

TCHAR*
FirstPhoneNumberFromEntry(
    IN PBENTRY* pEntry );

TCHAR*
FirstPszFromList(
    IN DTLLIST* pPszList );

DWORD
FirstPhoneNumberToEntry(
    IN PBENTRY* pEntry,
    IN TCHAR*   pszPhoneNumber );

DWORD
FirstPszToList(
    IN DTLLIST* pPszList,
    IN TCHAR*   psz );

TCHAR*
GetComputer(
    void );

DWORD
GetDefaultEntryName(
    IN  DTLLIST* pdtllistEntries,
    IN  BOOL     fRouter,
    OUT TCHAR**  ppszName );

TCHAR*
GetLogonDomain(
    void );

TCHAR*
GetLogonUser(
    void );

BOOL
IsLocalPad(
    IN PBENTRY* pEntry );

VOID
LaunchMonitor(
    IN HWND hwndNotify );

BOOL
ListEditorDlg(
    IN     HWND         hwndOwner,
    IN OUT DTLLIST*     pList,
    IN OUT BOOL*        pfCheck,
    IN     DWORD        dwMaxItemLen,
    IN     TCHAR*       pszTitle,
    IN     TCHAR*       pszItemLabel,
    IN     TCHAR*       pszListLabel,
    IN     TCHAR*       pszCheckLabel,
    IN     TCHAR*       pszDefaultItem,
    IN     INT          iSelInitial,
    IN     DWORD*       pdwHelp,
    IN     DWORD        dwfFlags,
    IN     PDESTROYNODE pDestroyId );

BOOL
MultiLinkConfigureDlg(
    IN HWND     hwndOwner,
    IN DTLLIST* pListLinks,
    IN BOOL     fRouter );

BOOL
MultiLinkDialingDlg(
    IN  HWND     hwndOwner,
    OUT PBENTRY* pEntry );

BOOL
NwConnectionCheck(
    IN HWND     hwndOwner,
    IN BOOL     fPosition,
    IN LONG     xDlg,
    IN LONG     yDlg,
    IN PBFILE*  pFile,
    IN PBENTRY* pEntry );

BOOL
PhoneNumberDlg(
    IN     HWND     hwndOwner,
    IN     BOOL     fRouter,
    IN OUT DTLLIST* pList,
    IN OUT BOOL*    pfCheck );

VOID
PositionDlg(
    IN HWND hwndDlg,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg );

LRESULT CALLBACK
PositionDlgStdCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
PppTcpipDlg(
    IN     HWND     hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN     BOOL     fRouter );

BOOL
PrefixSuffixLocationDlg(
    IN     HWND      hwndOwner,
    IN     TCHAR*    pszLocation,
    IN     DWORD     dwLocationId,
    IN OUT PBUSER*   pUser,
    IN OUT HLINEAPP* pHlineapp );

TCHAR*
PszFromPhoneNumberList(
    IN DTLLIST* pList );

LRESULT CALLBACK
SelectDesktopCallWndRetProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
SlipTcpipDlg(
    IN     HWND     hwndOwner,
    IN OUT PBENTRY* pEntry );

BOOL
StringEditorDlg(
    IN     HWND    hwndOwner,
    IN     TCHAR*  pszIn,
    IN     DWORD   dwSidTitle,
    IN     DWORD   dwSidLabel,
    IN     DWORD   cbMax,
    IN     DWORD   dwHelpId,
    IN OUT TCHAR** ppszOut );

BOOL
TerminalDlg(
    IN     PBENTRY*         pEntry,
    IN     RASDIALPARAMS*   pRdp,
    IN     HWND             hwndOwner,
    IN     HRASCONN         hrasconn,
    IN     DWORD            sidTitle,
    IN OUT TCHAR*           pszIpAddress );

VOID
TweakTitleBar(
    IN HWND hwndDlg );

int CALLBACK
UnHelpCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam );

BOOL
UserPreferencesDlg(
    IN  HLINEAPP hlineapp,
    IN  HWND     hwndOwner,
    IN  BOOL     fLogon,
    OUT PBUSER*  pUser,
    OUT PBFILE** ppFile );


#endif // _RASDLGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\nt4\rasdlg\util.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** util.c
** Remote Access Common Dialog APIs
** Utility routines
** Listed alphabetically
*/

#include "rasdlgp.h"   // Our private header
#include <dlgs.h>      // Common dialog resource constants
#include <lmwksta.h>   // NetWkstaGetInfo
#include <lmapibuf.h>  // NetApiBufferFree


/* Cached workstation and logon information.  See GetLogonUser,
** GetLogonDomain, and GetComputer.
*/
static TCHAR g_szLogonUser[ UNLEN + 1 ];
static TCHAR g_szLogonDomain[ DNLEN + 1 ];
static TCHAR g_szComputer[ CNLEN + 1 ];


/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwPnHelp[] =
{
    CID_LE_ST_Item,    HID_PN_EB_NewNumber,
    CID_LE_EB_Item,    HID_PN_EB_NewNumber,
    CID_LE_PB_Add,     HID_PN_PB_Add,
    CID_LE_PB_Replace, HID_PN_PB_Replace,
    CID_LE_ST_List,    HID_PN_LB_List,
    CID_LE_LB_List,    HID_PN_LB_List,
    CID_LE_PB_Up,      HID_PN_PB_Up,
    CID_LE_PB_Down,    HID_PN_PB_Down,
    CID_LE_PB_Delete,  HID_PN_PB_Delete,
    CID_LE_CB_Promote, HID_PN_CB_Promote,
    0, 0
};


/*----------------------------------------------------------------------------
** Local helper prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
GetWkstaUserInfo(
    void );

/*----------------------------------------------------------------------------
** Utility routines (alphabetically)
**----------------------------------------------------------------------------
*/

BOOL
AllLinksAreModems(
    IN PBENTRY* pEntry )

    /* Returns true if all links associated with the entry are modem links
    ** (MXS or Unimodem), false otherwise.
    */
{
    DTLNODE* pNode;

    if (pEntry->pdtllistLinks)
    {
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

            if (pLink->pbport.pbdevicetype != PBDT_Modem)
                return FALSE;
        }
    }

    return TRUE;
}


BOOL
AllLinksAreMxsModems(
    IN PBENTRY* pEntry )

    /* Returns true if all links associated with the entry are MXS modem
    ** links, false otherwise.
    */
{
    DTLNODE* pNode;

    if (pEntry->pdtllistLinks)
    {
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

            if (pLink->pbport.pbdevicetype != PBDT_Modem
                || !pLink->pbport.fMxsModemPort)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


/*---------------------------------------------------------------------------
	This is a hack!  At this point, the router portions should call to
	mpradmin.hlp not rasphone.hlp.  To minimize code churn, only those
	portions of the code that can determine if they are for a router will
	call ContextHelpHack().  The rest of the code can call ContextHelp().
 ---------------------------------------------------------------------------*/

VOID
ContextHelpHack(
    IN DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam,
	IN BOOL   fRouter)

    /* Calls WinHelp to popup context sensitive help.  'PadwMap' is an array
    ** of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
    ** WM_HELP or WM_CONTEXTMENU indicating the message received requesting
    ** help.  'Wparam' and 'lparam' are the parameters of the message received
    ** requesting help.
    */
{
    HWND hwnd;
    UINT unType;
 	TCHAR *	pszHelpFile;
	

    ASSERT(unMsg==WM_HELP||unMsg==WM_CONTEXTMENU);

    /* Don't try to do help if it won't work.  See common\uiutil\ui.c.
    */
    {
        extern BOOL g_fNoWinHelp;
        if (g_fNoWinHelp)
            return;
    }

    if (unMsg == WM_HELP)
    {
        LPHELPINFO p = (LPHELPINFO )lparam;;

        TRACE3("ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x)",
            p->iContextType,p->iCtrlId,p->hItemHandle);

        if (p->iContextType != HELPINFO_WINDOW)
            return;

        hwnd = p->hItemHandle;
        ASSERT(hwnd);
        unType = HELP_WM_HELP;
    }
    else
    {
        /* Standard Win95 method that produces a one-item "What's This?" menu
        ** that user must click to get help.
        */
        TRACE1("ContextHelp(WM_CONTEXTMENU,h=$%08x)",wparam);

        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    };

	if (fRouter)
		pszHelpFile = g_pszRouterHelpFile;
	else
		pszHelpFile = g_pszHelpFile;
	TRACE1("WinHelp(%s)", pszHelpFile);
    WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR)padwMap );
}


VOID
ContextHelp(
    IN DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
	ContextHelpHack(padwMap, hwndDlg, unMsg, wparam, lparam, FALSE);
}


HWND
CreateWizardBitmap(
    IN HWND hwndDlg,
    IN BOOL fPage )

    /* Create a static control that displays the RAS wizard bitmap at the
    ** standard place on dialog 'hwndDlg'.  'FPage' is set if the bitmap is
    ** being placed on a property page, false for the equivalent placement on
    ** a dialog.
    **
    ** Returns the bitmap window handle or NULL or error.
    */
{
    HWND hwnd;
    INT  x;
    INT  y;

    if (fPage)
        x = y = 0;
    else
        x = y = 10;

    hwnd =
        CreateWindowEx(
            0,
            TEXT("static"),
            NULL,
            WS_VISIBLE | WS_CHILD | SS_SUNKEN | SS_BITMAP,
            x, y, 80, 140,
            hwndDlg,
            (HMENU )CID_BM_Wizard,
            g_hinstDll,
            NULL );

    if (hwnd)
    {
        if (!g_hbmWizard)
        {
            g_hbmWizard = LoadBitmap(
                g_hinstDll, MAKEINTRESOURCE( BID_Wizard ) );
        }

        SendMessage( hwnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM )g_hbmWizard );
    }

    return hwnd;
}


TCHAR*
DisplayPszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort )

    /* Returns address of heap block psz containing the MXS modem list display
    ** form, i.e. the device name 'pszDevice' followed by the port name
    ** 'pszPort'.  It's caller's responsibility to Free the returned string.
    */
{
    TCHAR* pszResult;
    TCHAR* pszD;

    if (pszDevice)
        pszD = NULL;
    else
        pszD = pszDevice = PszFromId( g_hinstDll, SID_UnknownDevice );

    pszResult = PszFromDeviceAndPort( pszDevice, pszPort );
    Free0( pszD );

    return pszResult;
}


TCHAR*
FirstPhoneNumberFromEntry(
    IN PBENTRY* pEntry )

    /* Returns the first phone number of the first link of entry 'pEntry' or
    ** an empty string if none.  The returned address is into the list of
    ** phone numbers and should be copied if it needs to be stored.
    */
{
    TCHAR*   pszPhoneNumber;
    DTLNODE* pNode;
    PBLINK*  pLink;

    TRACE("FirstPhoneNumberFromEntry");

    ASSERT(pEntry->pdtllistLinks);
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT(pNode);
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pLink);

    return FirstPszFromList( pLink->pdtllistPhoneNumbers );
}


TCHAR*
FirstPszFromList(
    IN DTLLIST* pPszList )

    /* Returns the first string from the first node of 'pPszList' or an empty
    ** string if none.  The returned address is into the list and should be
    ** copied if it needs to be stored.
    */
{
    TCHAR*   psz;
    DTLNODE* pNode;

    TRACE("FirstPszFromList");

    if (DtlGetNodes( pPszList ) > 0)
    {
        pNode = DtlGetFirstNode( pPszList );
        ASSERT(pNode);
        psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );
    }
    else
        psz = TEXT("");

    return psz;
}


DWORD
FirstPhoneNumberToEntry(
    IN PBENTRY* pEntry,
    IN TCHAR*   pszPhoneNumber )

    /* Sets the first phone number of the first link of entry 'pEntry' to
    ** 'pszPhoneNumber'.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DTLNODE* pNode;
    PBLINK*  pLink;
    TCHAR*   pszNew;

    TRACE("FirstPhoneNumberToEntry");

    ASSERT(pEntry->pdtllistLinks);
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT(pNode);
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pLink);
    ASSERT(pLink->pdtllistPhoneNumbers);

    return FirstPszToList( pLink->pdtllistPhoneNumbers, pszPhoneNumber );
}


DWORD
FirstPszToList(
    IN DTLLIST* pPszList,
    IN TCHAR*   psz )

    /* Sets the string of the first node of the list 'pPszList' to a copy of
    ** 'psz'.  If 'psz' is "" the first node is deleted.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DTLNODE* pNode;
    TCHAR*   pszNew;

    ASSERT(pPszList);

    /* Delete the existing first node, if any.
    */
    if (DtlGetNodes( pPszList ) > 0)
    {
        pNode = DtlGetFirstNode( pPszList );
        DtlRemoveNode( pPszList, pNode );
        DestroyPszNode( pNode );
    }

    /* Create a new first node and link it.  An empty string is not added.
    */
    if (*psz == TEXT('\0'))
        return 0;

    pszNew = StrDup( psz );
    pNode = DtlCreateNode( pszNew, 0 );
    if (!pszNew || !pNode)
    {
        Free0( pszNew );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeFirst( pPszList, pNode );
    return 0;
}


TCHAR*
GetComputer(
    void )

    /* Returns the address of a static buffer containing the local
    ** workstation's computer name.
    */
{
    if (g_szComputer[ 0 ] == TEXT('\0'))
    {
        DWORD           dwErr;
        WKSTA_INFO_100* pInfo;

        pInfo = NULL;
        TRACE("NetWkstaGetInfo");
        dwErr = NetWkstaGetInfo( NULL, 100, (LPBYTE* )&pInfo );
        TRACE1("NetWkstaGetInfo=%d",dwErr);

        if (pInfo)
        {
            if (dwErr == 0)
                lstrcpy( g_szComputer, pInfo->wki100_computername );
            NetApiBufferFree( pInfo );
        }
    }

    TRACEW1("GetComputer=%s",g_szComputer);
    return g_szComputer;
}


DWORD
GetDefaultEntryName(
    IN  DTLLIST* pdtllistEntries,
    IN  BOOL     fRouter,
    OUT TCHAR**  ppszName )

    /* Loads a default entry name into '*ppszName' that is unique in the list
    ** of phonebook entries 'pdtllistEntries'.  'FRouter' is set if a
    ** router-style name should be chosen rather than a client-style name.  It
    ** is caller's responsibility to Free the returned string.
    **
    ** Returns 0 if successful or an error code.
    */
{
    TCHAR  szBuf[ RAS_MaxEntryName + 1 ];
    TCHAR* pszDefault;
    DWORD  dwDefaultLen;
    LONG   lNum;

    *ppszName = NULL;

    pszDefault = PszFromId( g_hinstDll,
        (fRouter) ? SID_DefaultRouterEntry : SID_DefaultEntry );
    if (!pszDefault)
        return ERROR_NOT_ENOUGH_MEMORY;

    dwDefaultLen = lstrlen( pszDefault );
    lstrcpy( szBuf, pszDefault );

    lNum = 2;
    while (EntryNodeFromName( pdtllistEntries, szBuf ))
    {
        lstrcpy( szBuf, pszDefault );
        LToT( lNum, szBuf + dwDefaultLen, 10 );
        ++lNum;
    }

    Free( pszDefault );

    *ppszName = StrDup( szBuf );
    if (!*ppszName)
        return ERROR_NOT_ENOUGH_MEMORY;

    return 0;
}


TCHAR*
GetLogonDomain(
    void )
{
    if (g_szLogonDomain[ 0 ] == TEXT('\0'))
        GetWkstaUserInfo();

    TRACEW1("GetLogonDomain=%s",g_szLogonDomain);
    return g_szLogonDomain;
}


TCHAR*
GetLogonUser(
    void )

    /* Returns the address of a static buffer containing the logged on user's
    ** account name.
    */
{
    if (g_szLogonUser[ 0 ] == TEXT('\0'))
        GetWkstaUserInfo();

    TRACEW1("GetLogonUser=%s",g_szLogonUser);
    return g_szLogonUser;
}


VOID
GetWkstaUserInfo(
    void )

    /* Helper to load statics with NetWkstaUserInfo information.  See
    ** GetLogonUser and GetLogonDomain.
    */
{
    DWORD              dwErr;
    WKSTA_USER_INFO_1* pInfo;

    pInfo = NULL;
    TRACE("NetWkstaUserGetInfo");
    dwErr = NetWkstaUserGetInfo( NULL, 1, (LPBYTE* )&pInfo );
    TRACE1("NetWkstaUserGetInfo=%d",dwErr);

    if (pInfo)
    {
        if (dwErr == 0)
        {
            lstrcpy( g_szLogonUser, pInfo->wkui1_username );
            lstrcpy( g_szLogonDomain, pInfo->wkui1_logon_domain );
        }

        NetApiBufferFree( pInfo );
    }
}


BOOL
IsLocalPad(
    IN PBENTRY* pEntry )

    /* Returns true if 'pEntry' is a local PAD device, i.e. the first link of
    ** the entry has device type "pad", false otherwise.
    */
{
    PBLINK*  pLink;
    DTLNODE* pNode;

    if (!pEntry)
        return FALSE;

    ASSERT(pEntry->pdtllistLinks);
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT(pNode);
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT(pLink);

    return (pLink->pbport.pbdevicetype == PBDT_Pad);
}


VOID
LaunchMonitor(
    IN HWND hwndNotify )

    /* Launch the Dial-Up Networking monitor.  'HwndNotify' is the window to
    ** be reactivated when the monitor is up.
    */
{
    TRACE("LaunchMonitor");

    if (FindWindow( TEXT("RasmonWinClass"), NULL ))
        return;

    /* Write our hwnd in shared memory for rasmon to read.
    */
    if (!g_pRmmem)
    {
        g_hRmmem = CreateFileMapping(
            (HANDLE )INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
            0L, sizeof(RMMEM), RMMEMRASPHONE );
        if (g_hRmmem)
            g_pRmmem = MapViewOfFile( g_hRmmem, FILE_MAP_WRITE, 0L, 0L, 0L );
        else
        {
            TRACE("CreateFileMapping failed");
        }
    }

    if (g_pRmmem)
    {
        g_pRmmem->hwnd = hwndNotify;
        g_pRmmem->pid = GetCurrentProcessId();

        TRACE2("RmMem:h=$%08x,pid=$%08x",g_pRmmem->hwnd,g_pRmmem->pid);
    }

    /* Start RASMON.EXE.
    */
    WinExec( "rasmon.exe", SW_SHOWNA );

    TRACE("LaunchMonitor done");
}


BOOL
PhoneNumberDlg(
    IN     HWND     hwndOwner,
    IN     BOOL     fRouter,
    IN OUT DTLLIST* pList,
    IN OUT BOOL*    pfCheck )

    /* Popup the phone number list dialog.  'HwndOwner' is the owner of the
    ** created dialog.  'FRouter' indicates router-style labels should be used
    ** rather than client-style.  'PList' is a list of Psz nodes containing
    ** the phone numbers.  'PfCheck' is the address that contains the initial
    ** "promote number" checkbox setting and which receives the value set by
    ** user.
    **
    ** Returns true if user presses OK and succeeds, false if he presses
    ** Cancel or encounters an error.
    */
{
    DWORD dwErr;
    DWORD sidHuntTitle;
    DWORD sidHuntItemLabel;
    DWORD sidHuntListLabel;
    DWORD sidHuntCheckLabel;
    TCHAR *pszTitle = NULL, *pszItem = NULL, *pszList = NULL, *pszCheck = NULL;

    TRACE("PhoneNumberDlg");

    if (fRouter)
    {
        sidHuntTitle = SID_RouterHuntTitle;
        sidHuntItemLabel = SID_RouterHuntItemLabel;
        sidHuntListLabel = SID_RouterHuntListLabel;
        sidHuntCheckLabel = SID_RouterHuntCheckLabel;
    }
    else
    {
        sidHuntTitle = SID_HuntTitle;
        sidHuntItemLabel = SID_HuntItemLabel;
        sidHuntListLabel = SID_HuntListLabel;
        sidHuntCheckLabel = SID_HuntCheckLabel;
    }

    pszTitle = PszFromId( g_hinstDll, sidHuntTitle );
    pszItem = PszFromId( g_hinstDll, sidHuntItemLabel );
    pszList = PszFromId( g_hinstDll, sidHuntListLabel );
    pszCheck = PszFromId( g_hinstDll, sidHuntCheckLabel );

    dwErr = 
        ListEditorDlg(
            hwndOwner,
            pList,
            pfCheck,
            RAS_MaxPhoneNumber,
            pszTitle,
            pszItem,
            pszList,
            pszCheck,
            NULL,
            0,
            g_adwPnHelp,
            0,
            NULL );

    Free0( pszTitle );
    Free0( pszItem ); 
    Free0( pszList ); 
    Free0( pszCheck );

    return dwErr;
}


VOID
PositionDlg(
    IN HWND hwndDlg,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg )

    /* Positions the dialog 'hwndDlg' based on caller's API settings, where
    ** 'fPosition' is the RASxxFLAG_PositionDlg flag and 'xDlg' and 'yDlg' are
    ** the coordinates.
    */
{
    if (fPosition)
    {
        /* Move it to caller's coordinates.
        */
        SetWindowPos( hwndDlg, NULL, xDlg, yDlg, 0, 0,
            SWP_NOZORDER + SWP_NOSIZE );
        UnclipWindow( hwndDlg );
    }
    else
    {
        /* Center it on the owner window, or on the screen if none.
        */
        CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    }
}


LRESULT CALLBACK
PositionDlgStdCallWndProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndProc hook callback that positions the next dialog
    ** to start in this thread at our standard offset relative to owner.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to position
        ** the dialog at the standard place relative to the calling dialog.
        */
        if (p->message == WM_INITDIALOG)
        {
            RECT rect;
            HWND hwndOwner;

            hwndOwner = GetParent( p->hwnd );
            GetWindowRect( hwndOwner, &rect );
            SetWindowPos( p->hwnd, NULL,
                rect.left + DXSHEET, rect.top + DYSHEET,
                0, 0, SWP_NOZORDER + SWP_NOSIZE );
            UnclipWindow( p->hwnd );
        }
    }

    return 0;
}


TCHAR*
PszFromPhoneNumberList(
    IN DTLLIST* pList )

    /* Returns the phone numbers in phone number list 'pList' in a comma
    ** string or NULL on error.  It is caller's responsiblity to Free the
    ** returned string.
    */
{
    TCHAR*   pszResult;
    DTLNODE* pNode;
    DWORD    cb;

    const TCHAR* pszSeparator = TEXT(", ");

    cb = (DtlGetNodes( pList ) *
             (RAS_MaxPhoneNumber + lstrlen( pszSeparator )) + 1)
             * sizeof(TCHAR);
    pszResult = Malloc( cb );
    if (!pszResult)
        return NULL;

    *pszResult = TEXT('\0');

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz = (TCHAR* )DtlGetData( pNode );
        ASSERT(psz);

        if (*pszResult)
            lstrcat( pszResult, pszSeparator );
        lstrcat( pszResult, psz );
    }

    pszResult = Realloc( pszResult,
        (lstrlen( pszResult ) + 1) * sizeof(TCHAR) );
    ASSERT(pszResult);

    return pszResult;
}


#if 0
LRESULT CALLBACK
SelectDesktopCallWndRetProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    /* Standard Win32 CallWndRetProc hook callback that makes "Desktop" the
    ** initial selection of the FileOpen "Look in" combo-box.
    */
{
    /* Arrive here when any window procedure associated with our thread is
    ** called.
    */
    if (!wparam)
    {
        CWPRETSTRUCT* p = (CWPRETSTRUCT* )lparam;

        /* The message is from outside our process.  Look for the MessageBox
        ** dialog initialization message and take that opportunity to set the
        ** "Look in:" combo box to the first item, i.e. "Desktop".  FileOpen
        ** keys off CBN_CLOSEUP rather than CBN_SELCHANGE to update the
        ** "contents" listbox.
        */
        if (p->message == WM_INITDIALOG)
        {
            HWND hwndLbLookIn;

            hwndLbLookIn = GetDlgItem( p->hwnd, cmb2 );
            ComboBox_SetCurSel( hwndLbLookIn, 0 );
            SendMessage( p->hwnd, WM_COMMAND,
                MAKELONG( cmb2, CBN_CLOSEUP ), (LPARAM )hwndLbLookIn );
        }
    }

    return 0;
}
#endif


VOID
TweakTitleBar(
    IN HWND hwndDlg )

    /* Adjust the title bar to include an icon if unowned and the modal frame
    ** if not.  'HwndDlg' is the dialog window.
    */
{
    if (GetParent( hwndDlg ))
    {
        LONG lStyle;
        LONG lStyleAdd;

        /* Drop the system menu and go for the dialog look.
        */
        lStyleAdd = WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE;;

        lStyle = GetWindowLong( hwndDlg, GWL_EXSTYLE );
        if (lStyle)
            SetWindowLong( hwndDlg, GWL_EXSTYLE, lStyle | lStyleAdd );
    }
    else
    {
        /* Stick a rasphone icon in the upper left of the dialog, and
        ** more importantly on the task bar
        */
        SendMessage( hwndDlg, WM_SETICON, TRUE,
            (LPARAM)LoadIcon( g_hinstDll, MAKEINTRESOURCE( IID_Rasphone ) ) );
    }
}


int CALLBACK
UnHelpCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    /* A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    **
    ** Returns 0 always.
    */
{
    TRACE2("UnHelpCallbackFunc(m=%d,l=%08x)",unMsg,lparam);

    if (unMsg == PSCB_PRECREATE)
    {
        extern BOOL g_fNoWinHelp;

        /* Turn off context help button if WinHelp won't work.  See
        ** common\uiutil\ui.c.
        */
        if (g_fNoWinHelp)
        {
            DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
            pDlg->style &= ~(DS_CONTEXTHELP);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\globals.h ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Global variables, except for the ones in dataras.c, for rasctr.dll.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History


--*/

#ifndef GLOBALS_H
#define GLOBALS_H

//
//  Include Files
//

#include <nt.h>

#include <rasman.h>
#include <serial.h>

#endif // GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\dataras.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      dataras.h

Abstract:

    Header file for the RAS Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Russ Blake		02/24/93
   Thomas J. Dimitri	05/28/93

Revision History:

   Patrick Y. Ng        08/12/93


--*/

#ifndef _DATARAS_H_
#define _DATARAS_H_

/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//

#include <winperf.h>
#include <rasman.h>

#define ALIGN8(_x)   (((_x) + 7) & ~7)

#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define RAS_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  RAS Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define NUM_BYTESTX_OFFSET	    	sizeof(DWORD) // The DWORD is for the
                                                      // field ByteLength

#define NUM_BYTESRX_OFFSET	    	( NUM_BYTESTX_OFFSET + sizeof(DWORD) )

#define NUM_FRAMESTX_OFFSET	    	( NUM_BYTESRX_OFFSET + sizeof(DWORD) )
#define NUM_FRAMESRX_OFFSET	    	( NUM_FRAMESTX_OFFSET + sizeof(DWORD) )

#define NUM_PERCENTTXC_OFFSET	        ( NUM_FRAMESRX_OFFSET + sizeof(DWORD) )
#define NUM_PERCENTRXC_OFFSET	        ( NUM_PERCENTTXC_OFFSET + sizeof(DWORD) )

#define NUM_CRCERRORS_OFFSET	        ( NUM_PERCENTRXC_OFFSET + sizeof(DWORD) )
#define NUM_TIMEOUTERRORS_OFFSET	( NUM_CRCERRORS_OFFSET + sizeof(DWORD) )
#define NUM_SERIALOVERRUNS_OFFSET	( NUM_TIMEOUTERRORS_OFFSET + sizeof(DWORD) )
#define NUM_ALIGNMENTERRORS_OFFSET	( NUM_SERIALOVERRUNS_OFFSET + sizeof(DWORD) )
#define NUM_BUFFEROVERRUNS_OFFSET	( NUM_ALIGNMENTERRORS_OFFSET + sizeof(DWORD) )

#define NUM_TOTALERRORS_OFFSET	        ( NUM_BUFFEROVERRUNS_OFFSET + sizeof(DWORD) )

#define NUM_BYTESTXSEC_OFFSET	        ( NUM_TOTALERRORS_OFFSET + sizeof(DWORD) )
#define NUM_BYTESRXSEC_OFFSET	        ( NUM_BYTESTXSEC_OFFSET + sizeof(DWORD) )

#define NUM_FRAMESTXSEC_OFFSET	        ( NUM_BYTESRXSEC_OFFSET + sizeof(DWORD) )
#define NUM_FRAMESRXSEC_OFFSET	        ( NUM_FRAMESTXSEC_OFFSET + sizeof(DWORD) )

#define NUM_TOTALERRORSSEC_OFFSET	( NUM_FRAMESRXSEC_OFFSET + sizeof(DWORD) )

#define SIZE_OF_RAS_PORT_PERFORMANCE_DATA ( NUM_TOTALERRORSSEC_OFFSET + sizeof(DWORD) )


#define NUM_TOTALCONNECTIONS_OFFSET     ( NUM_TOTALERRORSSEC_OFFSET + sizeof(DWORD) )

#define SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA  ( NUM_TOTALCONNECTIONS_OFFSET + sizeof(DWORD) )


//
//  This is the counter structure presently returned by RAS for
//  each Resource.  Each Resource is an Instance, named by its number.
//


//
// Data structure returned for RAS Port Object.  Note that the instance
// definitions for all port will be appended to it.
//

typedef struct _RAS_PORT_DATA_DEFINITION 
{

    PERF_OBJECT_TYPE		RasObjectType;

    PERF_COUNTER_DEFINITION	BytesTx;
    PERF_COUNTER_DEFINITION	BytesRx;

    PERF_COUNTER_DEFINITION	FramesTx;
    PERF_COUNTER_DEFINITION	FramesRx;

    PERF_COUNTER_DEFINITION	PercentTxC;
    PERF_COUNTER_DEFINITION	PercentRxC;

    PERF_COUNTER_DEFINITION	CRCErrors;
    PERF_COUNTER_DEFINITION	TimeoutErrors;
    PERF_COUNTER_DEFINITION	SerialOverruns;
    PERF_COUNTER_DEFINITION	AlignmentErrors;
    PERF_COUNTER_DEFINITION	BufferOverruns;

    PERF_COUNTER_DEFINITION	TotalErrors;

    PERF_COUNTER_DEFINITION	BytesTxSec;
    PERF_COUNTER_DEFINITION	BytesRxSec;

    PERF_COUNTER_DEFINITION	FramesTxSec;
    PERF_COUNTER_DEFINITION	FramesRxSec;

    PERF_COUNTER_DEFINITION	TotalErrorsSec;

} RAS_PORT_DATA_DEFINITION, *PRAS_PORT_DATA_DEFINITION;


//
// Structure returned for each instance of object RAS Port.  Note that data
// for all counters will be appended to it.
//

typedef struct _RAS_PORT_INSTANCE_DEFINITION
{

    PERF_INSTANCE_DEFINITION    RasInstanceType;

    WCHAR                       InstanceName[ MAX_PORT_NAME ];

} RAS_PORT_INSTANCE_DEFINITION, *PRAS_PORT_INSTANCE_DEFINITION;


//
// Data structure returned for RAS Total Object.  Note that data for each
// counter will be appended to it.
//

typedef struct _RAS_TOTAL_DATA_DEFINITION 
{

    PERF_OBJECT_TYPE		RasObjectType;

    PERF_COUNTER_DEFINITION	BytesTx;
    PERF_COUNTER_DEFINITION	BytesRx;

    PERF_COUNTER_DEFINITION	FramesTx;
    PERF_COUNTER_DEFINITION	FramesRx;

    PERF_COUNTER_DEFINITION	PercentTxC;
    PERF_COUNTER_DEFINITION	PercentRxC;

    PERF_COUNTER_DEFINITION	CRCErrors;
    PERF_COUNTER_DEFINITION	TimeoutErrors;
    PERF_COUNTER_DEFINITION	SerialOverruns;
    PERF_COUNTER_DEFINITION	AlignmentErrors;
    PERF_COUNTER_DEFINITION	BufferOverruns;

    PERF_COUNTER_DEFINITION	TotalErrors;

    PERF_COUNTER_DEFINITION	BytesTxSec;
    PERF_COUNTER_DEFINITION	BytesRxSec;

    PERF_COUNTER_DEFINITION	FramesTxSec;
    PERF_COUNTER_DEFINITION	FramesRxSec;

    PERF_COUNTER_DEFINITION	TotalErrorsSec;

    PERF_COUNTER_DEFINITION     TotalConnections;

} RAS_TOTAL_DATA_DEFINITION, *PRAS_TOTAL_DATA_DEFINITION;

#pragma pack ()


extern RAS_PORT_DATA_DEFINITION gRasPortDataDefinition;
extern RAS_TOTAL_DATA_DEFINITION gRasTotalDataDefinition;

//
// External functions
//

VOID InitObjectCounterIndex ( DWORD dwFirstCounter, DWORD dwFirstHelp );

#endif //_DATARAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\dataras.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dataras.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the RAS Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the RAS Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake 		 26 Feb 93
    Thomas J. Dimitri	 28 May 93

Revision History:

    Patrick Y. Ng        12 Aug 93      

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include "rasctrnm.h"
#include "dataras.h"

//
//  Constant structure initializations
//      defined in dataras.h
//
//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


RAS_PORT_DATA_DEFINITION gRasPortDataDefinition = 
{
    {
	// TotalByteLength.  Undefined until RasPortInit() is 
        // called.
	0,

	// DefinitionLength
	sizeof(RAS_PORT_DATA_DEFINITION),

	// HeaderLength
    	sizeof(PERF_OBJECT_TYPE),

	// ObjectNameTitleIndex
    	RASPORTOBJ,

	// ObjectNameTitle
    	0,

	// ObjectHelpTitleIndex
	RASPORTOBJ,

	// ObjectHelpTitle
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// NumCounters
	(sizeof(RAS_PORT_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/ sizeof(PERF_COUNTER_DEFINITION),

	// DefaultCounter
	0,

	// NumInstances.  Undefined until RasPortInit() is called.
    	0,

	// CodePage
    	0,

	//PerfTime
	{0,1},

	//PerfFreq
	{0,5}
    },

    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTX_OFFSET
    },

    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTTXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTTXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTTXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTRXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTRXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTRXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	CRCERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	CRCERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_CRCERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TIMEOUTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TIMEOUTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TIMEOUTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	SERIALOVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	SERIALOVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_SERIALOVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	ALIGNMENTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	ALIGNMENTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_ALIGNMENTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BUFFEROVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BUFFEROVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BUFFEROVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORSSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORSSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORSSEC_OFFSET
    }
};


RAS_TOTAL_DATA_DEFINITION gRasTotalDataDefinition = 
{
    {
	// TotalByteLength
	sizeof(RAS_TOTAL_DATA_DEFINITION) + ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA),

	// DefinitionLength
	sizeof(RAS_TOTAL_DATA_DEFINITION),

	// HeaderLength
    	sizeof(PERF_OBJECT_TYPE),

	// ObjectNameTitleIndex
    	RASTOTALOBJ,

	// ObjectNameTitle
    	0,

	// ObjectHelpTitleIndex
	RASTOTALOBJ,

	// ObjectHelpTitle
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// NumCounters
	(sizeof(RAS_TOTAL_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/ sizeof(PERF_COUNTER_DEFINITION),

	// DefaultCounter
	0,

	// NumInstances
    	-1,

	// CodePage
    	0,

	//PerfTime
	{0,1},

	//PerfFreq
	{0,5}
    },

    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRX,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRX,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRX_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTTXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTTXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
        PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTTXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	PERCENTRXC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	PERCENTRXC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
        PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_PERCENTRXC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	CRCERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	CRCERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_CRCERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TIMEOUTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TIMEOUTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TIMEOUTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	SERIALOVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	SERIALOVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_SERIALOVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	ALIGNMENTERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	ALIGNMENTERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_ALIGNMENTERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BUFFEROVERRUNS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BUFFEROVERRUNS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BUFFEROVERRUNS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORS_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	BYTESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	BYTESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_BYTESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESTXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESTXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESTXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	FRAMESRXSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	FRAMESRXSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_FRAMESRXSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALERRORSSEC,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALERRORSSEC,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_COUNTER,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALERRORSSEC_OFFSET
    },
    {
	// ByteLength
	sizeof(PERF_COUNTER_DEFINITION),

	// CounterNameTitleIndex
	TOTALCONNECTIONS,

	// CounterNameTitle
    	0,

	// CounterHelpTitleIndex
	TOTALCONNECTIONS,

	// CounterHelpTitle
    	0,

	// DefaultScale
    	0,

	// DetailLevel
	PERF_DETAIL_NOVICE,

	// CounterType
	PERF_COUNTER_RAWCOUNT,

	// CounterSize
        sizeof(DWORD),

	// CounterOffset
	NUM_TOTALCONNECTIONS_OFFSET
    }

};


//***
// 
// Routine Description:
//
//      Initiailizes all the indexes in the counter definitions in all objects.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      None.
//
//***

VOID InitObjectCounterIndex ( DWORD dwFirstCounter, DWORD dwFirstHelp )
{

    //
    // Init the counter definition structures for the object RAS Port.
    //

    gRasPortDataDefinition.RasObjectType.ObjectNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.RasObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.BytesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.BytesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.FramesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.FramesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.PercentTxC.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.PercentTxC.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.PercentRxC.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.PercentRxC.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.CRCErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.CRCErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.TimeoutErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.TimeoutErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.SerialOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.SerialOverruns.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.AlignmentErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.AlignmentErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.BufferOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BufferOverruns.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.TotalErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.TotalErrors.CounterHelpTitleIndex += dwFirstHelp;
	
    gRasPortDataDefinition.BytesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.BytesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.BytesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.FramesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasPortDataDefinition.FramesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.FramesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasPortDataDefinition.TotalErrorsSec.CounterNameTitleIndex += dwFirstCounter;
    gRasPortDataDefinition.TotalErrorsSec.CounterHelpTitleIndex += dwFirstHelp;


    //
    // Init the counter definition structures for the object RAS Total.
    //

    gRasTotalDataDefinition.RasObjectType.ObjectNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.RasObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.BytesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.BytesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.FramesTx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesTx.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.FramesRx.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesRx.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.PercentTxC.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.PercentTxC.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.PercentRxC.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.PercentRxC.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.CRCErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.CRCErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.TimeoutErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TimeoutErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.SerialOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.SerialOverruns.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.AlignmentErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.AlignmentErrors.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.BufferOverruns.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BufferOverruns.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.TotalErrors.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TotalErrors.CounterHelpTitleIndex += dwFirstHelp;
	
    gRasTotalDataDefinition.BytesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.BytesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.BytesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.FramesTxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesTxSec.CounterHelpTitleIndex += dwFirstHelp;
    gRasTotalDataDefinition.FramesRxSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.FramesRxSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.TotalErrorsSec.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TotalErrorsSec.CounterHelpTitleIndex += dwFirstHelp;

    gRasTotalDataDefinition.TotalConnections.CounterNameTitleIndex += dwFirstCounter;
    gRasTotalDataDefinition.TotalConnections.CounterHelpTitleIndex += dwFirstHelp;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\makefile.inc ===
ver.rc: rasctrs.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\globals.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfras.c

Abstract:

    Global variables, except for the ones in dataras.c, for rasctr.dll.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "rasctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l)

#define REPORT_INFORMATION(i,l)

#define REPORT_WARNING(i,l)

#define REPORT_ERROR(i,l)

#define REPORT_INFORMATION_DATA

#define REPORT_WARNING_DATA(i,l,d,s)

#define REPORT_ERROR_DATA(i,l,d,s)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  		07/30/92
	Thomas J. Dimitri	05/28/93
Revision History:

--*/
//
//  include files
//
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "rasctrs.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
            hEventLog = NULL;
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\perfras.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfras.c

Abstract:

    This file implements the Extensible Objects for  the Ras object type

Created:

    Russ Blake			           24 Feb 93
    Thomas J. Dimitri	        28 May 93

Revision History

    Ram Cherala                 15 Feb 96

      Don't hard code the length of the instance name in
      CollectRasPerformanceData.
      PerfMon checks the actual instance name length to determine
      if the name is properly formatted, so compute it for each
      instance name.

    Patrick Y. Ng               12 Aug 93


--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>

#include <malloc.h>
#include <ntprfctr.h>

#include "globals.h"
#include "rasctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "dataras.h"
#include "port.h"

#include <rasman.h>
#include <serial.h>
#include <isdn.h>
#include <raserror.h>

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

//
//  References to constants which initialize the Object type definitions
//

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenRasPerformanceData;
PM_COLLECT_PROC         CollectRasPerformanceData;
PM_CLOSE_PROC           CloseRasPerformanceData;


//***
//
// Routine Description:
//
//      This routine will open and map the memory used by the RAS driver to
//      pass performance data in. This routine also initializes the data
//      structures used to pass data back to the registry
//
// Arguments:
//
//      Pointer to object ID of each device to be opened (RAS)
//
//
// Return Value:
//
//      None.
//
//***

DWORD OpenRasPerformanceData( LPWSTR lpDeviceNames )
{
    LONG status;

    HKEY hKeyDriverPerf;
    DWORD size;
    DWORD type;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {

        //
        // open Eventlog interface
        //

        hEventLog = MonOpenEventLog();


        //
        // Load rasman.dll and get all the required functions.
        //

        status = InitRasFunctions();

        if( status != ERROR_SUCCESS )
        {

            REPORT_ERROR (RASPERF_UNABLE_DO_IOCTL, LOG_USER);

            // this is fatal, if we can't get data then there's no
            // point in continuing.

            goto OpenExitPoint;

        }

        InitObjectCounterIndex( RAS_FIRST_COUNTER_INDEX,
                                RAS_FIRST_HELP_INDEX );

        //
        // Initialize all the port information.
        //

        status = InitPortInfo();

        if (status != ERROR_SUCCESS)
        {
            REPORT_ERROR_DATA (RASPERF_UNABLE_CREATE_PORT_TABLE, LOG_USER,
                &status, sizeof(status));

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.

            goto OpenExitPoint;
        }

        bInitOK = TRUE; // ok to use this function
    }


    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit


OpenExitPoint:

    return status;
}


//***
//
// Routine Description:
//
//      This routine will return the data for the RAS counters.
//
// Arguments:
//
//    IN OUT    LPWSTR  lpValueName
//		        pointer to a wide character string passed by registry.
//
//    IN OUT	LPVOID   *lppData
//    IN:	        pointer to the address of the buffer to receive the completed
//                PerfDataBlock and subordinate structures. This routine will
//                append its data to the buffer starting at the point referenced
//                by *lppData.
//    OUT:	points to the first byte after the data structure added by this
//                routine. This routine updated the value at lppdata after appending
//                its data.
//
//    IN OUT	LPDWORD  lpcbTotalBytes
//    IN:		the address of the DWORD that tells the size in bytes of the
//                buffer referenced by the lppData argument
//    OUT:	the number of bytes added by this routine is written to the
//                DWORD pointed to by this argument
//
//    IN OUT	LPDWORD  NumObjectTypes
//    IN:		the address of the DWORD to receive the number of objects added
//                by this routine
//    OUT:	the number of objects added by this routine is written to the
//                DWORD pointed to by this argument
//
// Return Value:
//
//      ERROR_MORE_DATA if buffer passed is too small to hold data
//         any error conditions encountered are reported to the event log if
//         event logging is enabled.
//
//      ERROR_SUCCESS  if success or any other error. Errors, however are
//         also reported to the event log.
//
//***

DWORD CollectRasPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes )
{

    //  Variables for reformating the data

    NTSTATUS    Status;
    ULONG       SpaceNeeded;
    PBYTE       pbIn = (PBYTE) *lppData;


    // variables used for error logging

    DWORD       dwQueryType;


    // Variables used to record which objects are required

    static BOOL IsRasPortObject;
    static BOOL IsRasTotalObject;


    //
    // Reset some output variables.
    //

    *lpNumObjectTypes = 0;


    //
    // before doing anything else, see if Open went OK
    //

    if (!bInitOK)
    {
        // unable to continue because open failed.
	*lpcbTotalBytes = (DWORD) 0;
	*lpNumObjectTypes = (DWORD) 0;

        return ERROR_SUCCESS; // yes, this is a successful exit
    }


    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
	*lpcbTotalBytes = (DWORD) 0;
	*lpNumObjectTypes = (DWORD) 0;

        return ERROR_SUCCESS;
    }
    else if (dwQueryType == QUERY_ITEMS)
    {
        IsRasPortObject = IsNumberInUnicodeList (gRasPortDataDefinition.RasObjectType.ObjectNameTitleIndex,
                                                        lpValueName);

        IsRasTotalObject = IsNumberInUnicodeList (gRasTotalDataDefinition.RasObjectType.ObjectNameTitleIndex,
                                                        lpValueName);

	if ( !IsRasPortObject && !IsRasTotalObject )
        {
            //
            // request received for data object not provided by this routine
            //

            *lpcbTotalBytes = (DWORD) 0;
    	    *lpNumObjectTypes = (DWORD) 0;

            return ERROR_SUCCESS;
        }
    }
    else if( dwQueryType == QUERY_GLOBAL )
    {
        IsRasPortObject = IsRasTotalObject = TRUE;
    }


    //
    // Now check to see if we have enough space to hold all the data
    //

    SpaceNeeded = GetSpaceNeeded(IsRasPortObject, IsRasTotalObject);

    // DbgPrint("RASCTRS: IN TotalBytes=0x%x, SpaceNeeded=0x%x\n", 
    //        *lpcbTotalBytes, SpaceNeeded);

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
	*lpcbTotalBytes = (DWORD) 0;
	*lpNumObjectTypes = (DWORD) 0;

        return ERROR_MORE_DATA;
    }


    //
    // Collect all the RAS statistics now.
    //

    Status = CollectRasStatistics();

    if( Status != ERROR_SUCCESS )
    {
        REPORT_ERROR_DATA (RASPERF_CANNOT_GET_RAS_STATISTICS, LOG_USER,
                &Status, sizeof(Status));

	*lpcbTotalBytes = (DWORD) 0;
	*lpNumObjectTypes = (DWORD) 0;

        return ERROR_SUCCESS;
    }

    //DbgPrint("RASCTRS: pbIn = 0x%x\n", pbIn);

    //
    // We first fill in the data for object Ras Port, if needed.
    //

    if( IsRasPortObject )
    {
        PRAS_PORT_DATA_DEFINITION pRasPortDataDefinition;
        RAS_PORT_INSTANCE_DEFINITION RasPortInstanceDefinition;
        PRAS_PORT_INSTANCE_DEFINITION pRasPortInstanceDefinition;
        DWORD    cPorts;
        DWORD     i;
        PVOID   pData;


        cPorts = GetNumOfPorts();

        pRasPortDataDefinition = (PRAS_PORT_DATA_DEFINITION) *lppData;

        //DbgPrint("RASCTRS: pRasPortDataDefinition = 0x%x\n", pRasPortDataDefinition);


        //
        // Copy the (constant, initialized) Object Type and counter definitions
        // to the caller's data buffer
        //

        memcpy( pRasPortDataDefinition,
		 &gRasPortDataDefinition,
		 sizeof(RAS_PORT_DATA_DEFINITION));


        //
        // Now copy the instance definition and counter block.
        //


        //
        // First construct the default perf instance definition.
        //

        RasPortInstanceDefinition.RasInstanceType.ByteLength =
                                ALIGN8(sizeof(RAS_PORT_INSTANCE_DEFINITION));

        RasPortInstanceDefinition.RasInstanceType.ParentObjectTitleIndex = 0;

        RasPortInstanceDefinition.RasInstanceType.ParentObjectInstance = 0;

        RasPortInstanceDefinition.RasInstanceType.NameOffset =
                                sizeof(PERF_INSTANCE_DEFINITION);

        //DbgPrint("RASCTRS: RasPortinstanceDefinition.ByteLength = 0x%x\n",
        //        RasPortInstanceDefinition.RasInstanceType.ByteLength);
                

/*      Don't hard code the length of the instance name.
**      PerfMon checks the actual instance name length to determine
**      if the name is properly formatted, so compute it for
**      each instance name. ramc 2/15/96.
**        RasPortInstanceDefinition.RasInstanceType.NameLength =
**                                sizeof( WCHAR ) * MAX_PORT_NAME;
*/

        //
        // Get to the end of the data definition.
        //

        // pData = (PVOID) &(pRasPortDataDefinition[1]);

        pData = ((PBYTE) pRasPortDataDefinition + ALIGN8(sizeof(RAS_PORT_DATA_DEFINITION)));


        for( i=0; i < cPorts; i++ )
        {

            //DbgPrint("RASCTRS: port %d, pData = 0x%x\n", i, pData);
        
            //
            // First copy the instance definition data.
            //

            RasPortInstanceDefinition.RasInstanceType.UniqueID = PERF_NO_UNIQUE_ID;

            lstrcpyW( (LPWSTR)&RasPortInstanceDefinition.InstanceName,
                      GetInstanceName(i) );

            // Compute the instance name length

            RasPortInstanceDefinition.RasInstanceType.NameLength =
                (lstrlenW(RasPortInstanceDefinition.InstanceName) + 1) *
                sizeof( WCHAR );


            memcpy( pData, &RasPortInstanceDefinition,
                     sizeof( RasPortInstanceDefinition ) );

            //
            // Move pPerfInstanceDefinition to the beginning of data block.
            //

            pData = (PVOID)((PBYTE) pData + ALIGN8(sizeof(RAS_PORT_INSTANCE_DEFINITION)));


            //
            // Get the data block.  Note that pPerfInstanceDefinition will be
            // set to the next available byte.
            //

            GetInstanceData( i, &pData );
        }

        //
        // Set *lppData to the next available byte.
        //

        *lppData = pData;

        (*lpNumObjectTypes)++;


    }
    


    //
    // Then we fill in the data for object Ras Total, if needed.
    //

    if( IsRasTotalObject )
    {
        PRAS_TOTAL_DATA_DEFINITION pRasTotalDataDefinition;
        PVOID   pData;

        pRasTotalDataDefinition = (PRAS_TOTAL_DATA_DEFINITION) *lppData;


        //DbgPrint("RASCTRS: RasTotalDataDefinition = 0x%x\n", 
        //        pRasTotalDataDefinition);

        //
        // Copy the (constant, initialized) Object Type and counter definitions
        // to the caller's data buffer
        //

        memcpy( pRasTotalDataDefinition,
		 &gRasTotalDataDefinition,
		 sizeof(RAS_TOTAL_DATA_DEFINITION));


        //
        // Now copy the counter block.
        //


        //
        // Set pRasTotalDataDefinition to the beginning of counter block.
        //

        // pData = (PVOID) &(pRasTotalDataDefinition[1]);
        pData = (PBYTE) pRasTotalDataDefinition + ALIGN8(sizeof(RAS_TOTAL_DATA_DEFINITION));

        //DbgPrint("RASCTRS: pData for total = 0x%x\n", pData);

        GetTotalData( &pData );

        //
        // Set *lppData to the next available byte.
        //

        *lppData = pData;

        (*lpNumObjectTypes)++;
    }

    //DbgPrint("RASCTRS: pbOut = 0x%x\n", *lppData);

    *lpcbTotalBytes = SpaceNeeded;

    /*
    DbgPrint("pbIn+SpaceNeeded=0x%x, *lppData=0x%x\n",
            pbIn+SpaceNeeded,
            *lppData);
    */            

    ASSERT((pbIn + SpaceNeeded) == (PBYTE) *lppData);

    //DbgPrint("RASCTRS: OUT TotalBytes=0x%x\n", *lpcbTotalBytes);

    return ERROR_SUCCESS;
}


//***
//
// Routine Description:
//
//      This routine closes the open handles to RAS device performance
//      counters.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS
//
//***

DWORD CloseRasPerformanceData()
{
    if (!(--dwOpenCount))
    {
        // when this is the last thread...

        MonCloseEventLog();
        ClosePortInfo();
    }

    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\rasctrnm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    rasctrnm.h

Abstract:

    This file defines the ras symbols used in the rasctrs.ini file for
    loading the counters to registry. 

Created:

    Thomas J. Dimitri	        28 May 93

Revision History

    Ram Cherala                 04 Nov 93   Added this header 


--*/
//
//  rasctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//


#define RASPORTOBJ 		0


//
// The following constants are good for both Total and individual port.
//

#define BYTESTX			2
#define BYTESRX			4

#define FRAMESTX		6
#define FRAMESRX		8

#define PERCENTTXC		10
#define PERCENTRXC		12

#define CRCERRORS		14
#define TIMEOUTERRORS	        16
#define SERIALOVERRUNS	        18
#define ALIGNMENTERRORS	        20
#define BUFFEROVERRUNS	        22

#define TOTALERRORS		24

#define BYTESTXSEC 		26
#define BYTESRXSEC 		28

#define FRAMESTXSEC		30
#define FRAMESRXSEC		32

#define TOTALERRORSSEC          34


//
// The following constants are good only for Total.
//

#define RASTOTALOBJ             36

#define TOTALCONNECTIONS        38
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\port.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    port.c

Abstract:

    Contains functions responsible for data collection from the RAS ports.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History

--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <raserror.h>
#include <malloc.h>
#include <windows.h>
#include <string.h>
#include <wcstr.h>

#include "rasctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "dataras.h"
#include "globals.h"
#include "port.h"

#include <rasman.h>
#include <serial.h>
#include <isdn.h>


HANDLE   ghRasmanLib;             // Handle of RASMAN.DLL

#define RASMAN_DLL              "rasman.dll"


//
// Function types for the functions in RASMAN.DLL
//

typedef DWORD ( WINAPI *FPRASPORTENUM ) ( HANDLE, LPBYTE, LPDWORD, LPDWORD );
typedef DWORD ( WINAPI *FPRASGETINFO ) (HANDLE,  HPORT, RASMAN_INFO* );
typedef DWORD ( WINAPI *FPRASPORTGETSTATISTICS ) (HANDLE,  HPORT, LPBYTE, LPDWORD );
typedef DWORD ( WINAPI *FPRASINITIALIZE) ();
typedef DWORD ( WINAPI *FPRASPORTGETBUNDLE) (HANDLE, HPORT, HBUNDLE*);

FPRASPORTENUM                   lpRasPortEnum;
FPRASGETINFO                    lpRasGetInfo;
FPRASPORTGETSTATISTICS          lpRasPortGetStatistics;
FPRASINITIALIZE                 lpRasInitialize;
FPRASPORTGETBUNDLE				lpRasPortGetBundle;

//
// Pointer to the port table array.
//

PRAS_PORT_DATA	gpPortDataArray;
RAS_PORT_STAT	gTotalStat;

DWORD				gcPorts;
RASMAN_PORT		*gpPorts = NULL;
DWORD				gPortEnumSize;

DWORD			gTotalConnections;
		
//***
//
// Routine Description:
//
//      It will load rasman.dll and call GetProcAddress to obtain all the
//      necessary RAS functions.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS - Successful.
//      ERROR_CAN_NOT_COMPLETE - Otherwise.
//
//***

LONG InitRasFunctions()
{
    ghRasmanLib = LoadLibrary( RASMAN_DLL );

    // log error if unsuccessful

    if( !ghRasmanLib )
    {
        REPORT_ERROR (RASPERF_OPEN_FILE_DRIVER_ERROR, LOG_USER);

        // this is fatal, if we can't get data then there's no
        // point in continuing.

        return ERROR_CAN_NOT_COMPLETE;

    }

    lpRasInitialize =
	(FPRASPORTENUM) GetProcAddress( ghRasmanLib, "RasInitialize" );

    lpRasPortEnum =
	(FPRASPORTENUM) GetProcAddress( ghRasmanLib, "RasPortEnum" );

    lpRasGetInfo =
	(FPRASGETINFO) GetProcAddress( ghRasmanLib, "RasGetInfo" );

    lpRasPortGetStatistics =
	(FPRASPORTGETSTATISTICS) GetProcAddress( ghRasmanLib, "RasPortGetStatistics" );

    lpRasPortGetBundle =
	(FPRASPORTGETBUNDLE) GetProcAddress( ghRasmanLib, "RasPortGetBundle" );

    if( !lpRasInitialize || !lpRasPortEnum || !lpRasGetInfo
	        || !lpRasPortGetStatistics || !lpRasPortGetBundle)
	        // || lpRasInitialize() )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
        SC_HANDLE schandle = NULL;
        SC_HANDLE svchandle = NULL;
        DWORD dwErr = NO_ERROR;
        
        //
        // Check to see if rasman service is started.
        // fail if it isn't - we don't want ras perf
        // to start rasman service.
        //
        schandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

        if(NULL != schandle)
        {
            svchandle = OpenService(schandle,
                                    "RASMAN",
                                    SERVICE_QUERY_STATUS);

            if(NULL != svchandle)
            {
                SERVICE_STATUS status;
                
                if(     (!QueryServiceStatus(svchandle, &status))
                    ||  (status.dwCurrentState != SERVICE_RUNNING))
                {
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                }

                CloseServiceHandle(svchandle);
            }

            CloseServiceHandle(schandle);
        }

        return dwErr;

    }
}


//***
//
// Routine Description:
//
//      This routine will call lpRasPortEnum() and generate an array of port
//      tables which contains all the information for all the ports such as
//      number of bytes transferred, and number of errors, etc.
//
//      The remaining initialization work of gRasPortDataDefinition is also
//      finished here.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS - Successful.
//      ERROR_CAN_NOT_COMPLETE - Otherwise.
//
//***

LONG InitPortInfo()
{
    DWORD        Size;
    DWORD         i;


    if( lpRasPortEnum(NULL, NULL, &gPortEnumSize, &gcPorts) != ERROR_BUFFER_TOO_SMALL )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    gpPorts = (RASMAN_PORT *) malloc( gPortEnumSize );

    if (!gpPorts)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }


    if (lpRasPortEnum(NULL, (LPBYTE) gpPorts, &gPortEnumSize, &gcPorts))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }



    //
    // Generate the array of data tables for all the ports, and fill up the
    // name of each port.
    //

    Size = gcPorts * sizeof( RAS_PORT_DATA );

    gpPortDataArray = ( PRAS_PORT_DATA ) malloc( Size );

    if( gpPortDataArray == NULL )
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    memset( gpPortDataArray, 0, Size );



    //
    // Fill up the names.
    //

    for( i = 0; i < gcPorts; i++ )
    {
        //
        // Note that the names passed to perfmon are in Unicodes.
        //

        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                             gpPorts[i].P_PortName,
                             MAX_PORT_NAME,
                             gpPortDataArray[i].PortName,
                             sizeof(WCHAR) * MAX_PORT_NAME);
    }


    //
    // Finish the initialization of gRasPortDataDefinition.
    //

    gRasPortDataDefinition.RasObjectType.TotalByteLength =
                sizeof( RAS_PORT_DATA_DEFINITION ) +
                gcPorts * ( sizeof( RAS_PORT_INSTANCE_DEFINITION ) +
                           SIZE_OF_RAS_PORT_PERFORMANCE_DATA );

    gRasPortDataDefinition.RasObjectType.NumInstances = gcPorts;

    return ERROR_SUCCESS;
}


VOID ClosePortInfo()
{
    free( gpPortDataArray );

    free( gpPorts );
}


DWORD GetNumOfPorts()
{
    return gcPorts;
}


LPWSTR GetInstanceName( INT i )
{
    return (LPWSTR) gpPortDataArray[i].PortName;
}


VOID GetInstanceData( INT Port, PVOID *lppData )
{
    PPERF_COUNTER_BLOCK pPerfCounterBlock;
    PDWORD              pdwCounter;
    PRAS_PORT_STAT      pRasPortStat;


    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) *lppData;

    pPerfCounterBlock->ByteLength = SIZE_OF_RAS_PORT_PERFORMANCE_DATA;

    pRasPortStat = &gpPortDataArray[Port].RasPortStat;


    //
    // Go to end of PerfCounterBlock to get of array of counters
    //

    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    {
       ULONG ulBxu      = pRasPortStat->BytesTransmittedUncompressed;
       ULONG ulBxc      = pRasPortStat->BytesTransmittedCompressed;
       ULONG ulBx       = pRasPortStat->BytesTransmitted;
       ULONG ulBxGone   = 0;
       ULONG ulBxResult = 0;
       ULONG ulBru      = pRasPortStat->BytesReceivedUncompressed;
       ULONG ulBrc      = pRasPortStat->BytesReceivedCompressed;
       ULONG ulBr       = pRasPortStat->BytesReceived;
       ULONG ulBrGone   = 0;
       ULONG ulBrResult = 0;

       if (ulBxc <ulBxu) {
          ulBxGone = ulBxu - ulBxc;
       }

       if (ulBrc <ulBru) {
          ulBrGone = ulBru - ulBrc;
       }

       *pdwCounter++ = pRasPortStat->BytesTransmitted + ulBxGone;
       *pdwCounter++ = pRasPortStat->BytesReceived + ulBrGone;
       *pdwCounter++ = pRasPortStat->FramesTransmitted;
       *pdwCounter++ = pRasPortStat->FramesReceived;

       if (ulBx + ulBxGone > 100) {
          ULONG ulDen = (ulBx + ulBxGone) / 100;
          ULONG ulNum = ulBxGone + (ulDen / 2);
          ulBxResult = ulNum / ulDen;
       }

	*pdwCounter++ = ulBxResult;  // % bytes compress out

       if (ulBr + ulBrGone > 100) {
          ULONG ulDen = (ulBr + ulBrGone) / 100;
          ULONG ulNum = ulBrGone + (ulDen / 2);
          ulBrResult = ulNum / ulDen;
       }
	*pdwCounter++ = ulBrResult;  // % bytes compress in

       *pdwCounter++ = pRasPortStat->CRCErrors;
       *pdwCounter++ = pRasPortStat->TimeoutErrors;
       *pdwCounter++ = pRasPortStat->SerialOverrunErrors;
       *pdwCounter++ = pRasPortStat->AlignmentErrors;
       *pdwCounter++ = pRasPortStat->BufferOverrunErrors;

       *pdwCounter++ = pRasPortStat->TotalErrors;

       *pdwCounter++ = pRasPortStat->BytesTransmitted + ulBxGone;
       *pdwCounter++ = pRasPortStat->BytesReceived + ulBrGone;

       *pdwCounter++ = pRasPortStat->FramesTransmitted;
       *pdwCounter++ = pRasPortStat->FramesReceived;

       *pdwCounter++ = pRasPortStat->TotalErrors;
    }
    //
    // Update *lppData to the next available byte.
    //

    *lppData = (PVOID) pdwCounter;

}


VOID GetTotalData( PVOID *lppData )
{
    PPERF_COUNTER_BLOCK pPerfCounterBlock;
    PDWORD              pdwCounter;


    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) *lppData;

    //DbgPrint("RASCTRS: total bytelength before align = 0x%x\n",
    //            SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);

    pPerfCounterBlock->ByteLength = ALIGN8(SIZE_OF_RAS_TOTAL_PERFORMANCE_DATA);

    //DbgPrint("RASCTRS: total bytelength after align = 0x%x\n",
    //            pPerfCounterBlock->ByteLength);


    //
    // Go to end of PerfCounterBlock to get of array of counters
    //

    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    {
       ULONG ulBxu      = gTotalStat.BytesTransmittedUncompressed;
       ULONG ulBxc      = gTotalStat.BytesTransmittedCompressed;
       ULONG ulBx       = gTotalStat.BytesTransmitted;
       ULONG ulBxGone   = 0;
       ULONG ulBxResult = 0;
       ULONG ulBru      = gTotalStat.BytesReceivedUncompressed;
       ULONG ulBrc      = gTotalStat.BytesReceivedCompressed;
       ULONG ulBr       = gTotalStat.BytesReceived;
       ULONG ulBrGone   = 0;
       ULONG ulBrResult = 0;


       if (ulBxc <ulBxu) {
          ulBxGone = ulBxu - ulBxc;
       }

       if (ulBrc <ulBru) {
          ulBrGone = ulBru - ulBrc;
       }

       *pdwCounter++ = gTotalStat.BytesTransmitted + ulBxGone;
       *pdwCounter++ = gTotalStat.BytesReceived + ulBrGone;
       *pdwCounter++ = gTotalStat.FramesTransmitted;
       *pdwCounter++ = gTotalStat.FramesReceived;

       if (ulBx + ulBxGone > 100) {
          ULONG ulDen = (ulBx + ulBxGone) / 100;
          ULONG ulNum = ulBxGone + (ulDen / 2);
          ulBxResult = ulNum / ulDen;
       }

	*pdwCounter++ = ulBxResult;  // % bytes compress out

       if (ulBr + ulBrGone > 100) {
          ULONG ulDen = (ulBr + ulBrGone) / 100;
          ULONG ulNum = ulBrGone + (ulDen / 2);
          ulBrResult = ulNum / ulDen;
       }
	*pdwCounter++ = ulBrResult;  // % bytes compress in

       *pdwCounter++ = gTotalStat.CRCErrors;
       *pdwCounter++ = gTotalStat.TimeoutErrors;
       *pdwCounter++ = gTotalStat.SerialOverrunErrors;
       *pdwCounter++ = gTotalStat.AlignmentErrors;
       *pdwCounter++ = gTotalStat.BufferOverrunErrors;

       *pdwCounter++ = gTotalStat.TotalErrors;

       *pdwCounter++ = gTotalStat.BytesTransmitted + ulBxGone;
       *pdwCounter++ = gTotalStat.BytesReceived + ulBrGone;

       *pdwCounter++ = gTotalStat.FramesTransmitted;
       *pdwCounter++ = gTotalStat.FramesReceived;

       *pdwCounter++ = gTotalStat.TotalErrors;
       *pdwCounter++ = gTotalConnections;
    }

    //
    // Update *lppData to the next available byte.
    //

    *lppData = (PVOID) ((PBYTE) pPerfCounterBlock + pPerfCounterBlock->ByteLength);

    //DbgPrint("RASCTRS : totalcount *lppdata = 0x%x\n", *lppData);

}


//***
//
// Routine Description:
//
//      This routine will return the number of gTotalStat.Bytes needed for all the
//      objects requested.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      The number of gTotalStat.Bytes.
//
//***

ULONG GetSpaceNeeded( BOOL IsRasPortObject, BOOL IsRasTotalObject )
{
    ULONG       Space = 0;

    if( IsRasPortObject )
    {
        Space += gRasPortDataDefinition.RasObjectType.TotalByteLength;
    }

    if( IsRasTotalObject )
    {
        Space += gRasTotalDataDefinition.RasObjectType.TotalByteLength;
    }

    return Space;
}


//***
//
// Routine Description:
//
//      This routine will return the number of bytes needed for all the
//      objects requested.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      The number of bytes.
//
//***

NTSTATUS CollectRasStatistics()
{
    NTSTATUS    status;
    DWORD         i;
	HBUNDLE		*hBundleArray = NULL;

    gTotalConnections = 0;

    //
    // We also initialize the data structure for the total.
    //

    memset( &gTotalStat, 0, sizeof( gTotalStat ) );

    //
    // First we do a lpRasPortEnum to obtain the port connection info.
    //

    status = lpRasPortEnum(NULL, (LPBYTE) gpPorts, &gPortEnumSize, &gcPorts);

    if( status != ERROR_SUCCESS )
    {
        REPORT_ERROR_DATA (RASPERF_RASPORTENUM_FAILED, LOG_USER,
                &status, sizeof(status));

        return ERROR_CAN_NOT_COMPLETE;
    }

	hBundleArray = (HBUNDLE*)malloc(gcPorts * sizeof(HBUNDLE));

	if(NULL == hBundleArray)
	{
	    return ERROR_NOT_ENOUGH_MEMORY;
	}

	memset (hBundleArray, 0, gcPorts * sizeof(HBUNDLE)) ;

	if (hBundleArray == NULL) {
		DbgPrint("Failed allocating memory for bundle array\n");
		return ERROR_CAN_NOT_COMPLETE;
	}

    for( i = 0; i < gcPorts; i++ )
    {
        RASMAN_INFO	RasmanInfo;
        HPORT           hPort;
        DWORD            wSize;
        RAS_STATISTICS  *pStats;
        PRAS_PORT_STAT  pData;
		BOOLEAN			AddTotal;
		DWORD				n;
		HBUNDLE			hBundle;


        //
        // First we want to know if the port is open.
        //

	if( gpPorts[i].P_Status != OPEN )
        {
            //
            // Reset the port data and continue with next port.
            //

            memset( &gpPortDataArray[i].RasPortStat,0, sizeof(RAS_PORT_STAT));

            continue;
        }

        hPort = gpPorts[i].P_Handle;


        //
        // Check if the port is connected.
        //

        lpRasGetInfo(NULL, hPort, &RasmanInfo );

        if( RasmanInfo.RI_ConnState != CONNECTED )
        {
            //
            // Reset the port data and continue with next port.
            //

            memset( &gpPortDataArray[i].RasPortStat,0, sizeof(RAS_PORT_STAT));

            continue;
        }

        gTotalConnections++;


        //
        //
        // Obtain the statistics for the port.
        //

        wSize = sizeof(RAS_STATISTICS) +
                        (NUM_RAS_SERIAL_STATS * sizeof(ULONG));

        pStats = (RAS_STATISTICS* )malloc( wSize );

        if (!pStats)
        {
            //
            // If it fails then we should return error.
            //

            status = ERROR_NOT_ENOUGH_MEMORY;

            REPORT_ERROR_DATA (RASPERF_NOT_ENOUGH_MEMORY, LOG_USER,
                &status, sizeof(status));

            return status;
        }

        lpRasPortGetStatistics( NULL, hPort, (PVOID)pStats, &wSize );

        //
        // Now store the data in the data array.
        //

        pData = &(gpPortDataArray[i].RasPortStat);


        pData->BytesTransmitted =     pStats->S_Statistics[ BYTES_XMITED ];
        pData->BytesReceived =        pStats->S_Statistics[ BYTES_RCVED ];
        pData->FramesTransmitted =    pStats->S_Statistics[ FRAMES_XMITED ];
        pData->FramesReceived =       pStats->S_Statistics[ FRAMES_RCVED ];
	
	
         pData->CRCErrors =            pStats->S_Statistics[ CRC_ERR ];
         pData->TimeoutErrors =        pStats->S_Statistics[ TIMEOUT_ERR ];
         pData->SerialOverrunErrors =  pStats->S_Statistics[ SERIAL_OVERRUN_ERR ];
         pData->AlignmentErrors =      pStats->S_Statistics[ ALIGNMENT_ERR ];
         pData->BufferOverrunErrors =  pStats->S_Statistics[ BUFFER_OVERRUN_ERR ];

         pData->TotalErrors =   pStats->S_Statistics[ CRC_ERR ] +
                                pStats->S_Statistics[ TIMEOUT_ERR ] +
                                pStats->S_Statistics[ SERIAL_OVERRUN_ERR ] +
                                pStats->S_Statistics[ ALIGNMENT_ERR ] +
                                pStats->S_Statistics[ BUFFER_OVERRUN_ERR ];

			
        pData->BytesTransmittedUncompressed = pStats->S_Statistics[ BYTES_XMITED_UNCOMP ];

        pData->BytesReceivedUncompressed = pStats->S_Statistics[ BYTES_RCVED_UNCOMP ];

        pData->BytesTransmittedCompressed = pStats->S_Statistics[ BYTES_XMITED_COMP ];

        pData->BytesReceivedCompressed = pStats->S_Statistics[ BYTES_RCVED_COMP ];

		lpRasPortGetBundle( NULL, hPort, &hBundle);

		//
		// See if we have already added in this bundle's stats
		// to the total stats!
		//
		AddTotal = TRUE;

		for (n = 0; n < gcPorts; n++) {

			if (hBundle == hBundleArray[n]) {

				AddTotal = FALSE;
				break;
			}

			if (NULL == (PVOID)hBundleArray[n]) {
				break;
			}
			
		}

		if (AddTotal) {

			hBundleArray[n] = hBundle;

			//
			// Also update the total data structure
			//
	
			gTotalStat.BytesTransmitted +=  pData->BytesTransmitted;
			gTotalStat.BytesReceived +=	pData->BytesReceived;
			gTotalStat.FramesTransmitted += pData->FramesTransmitted;
			gTotalStat.FramesReceived +=    pData->FramesReceived;
	
			gTotalStat.CRCErrors +=           pData->CRCErrors;
			gTotalStat.TimeoutErrors +=       pData->TimeoutErrors;
			gTotalStat.SerialOverrunErrors += pData->SerialOverrunErrors;
			gTotalStat.AlignmentErrors +=     pData->AlignmentErrors;
			gTotalStat.BufferOverrunErrors += pData->BufferOverrunErrors;
	
			gTotalStat.BytesTransmittedUncompressed += pData->BytesTransmittedUncompressed;
			gTotalStat.BytesReceivedUncompressed +=    pData->BytesReceivedUncompressed;
			gTotalStat.BytesTransmittedCompressed +=   pData->BytesTransmittedCompressed;
			gTotalStat.BytesReceivedCompressed +=      pData->BytesReceivedCompressed;
	
			gTotalStat.TotalErrors +=      pData->TotalErrors;
		}

        free( pStats );
    }

	free (hBundleArray);

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\perf\port.h ===
/*++ 

Copyright (c) 1992  Microsoft Corporation

Module Name:

    port.h

Abstract:

    Header file information for port.h.

Created:

    Patrick Y. Ng               12 Aug 93

Revision History

--*/

#ifndef PORT_H
#define PORT_H

#include <rasman.h>

//
// Data structure used to store the statistics for each open port.
//

typedef struct _RAS_PORT_STAT
{

    ULONG BytesTransmitted;
    ULONG BytesReceived;
    ULONG FramesTransmitted;
    ULONG FramesReceived;

    ULONG CRCErrors;
    ULONG TimeoutErrors;
    ULONG SerialOverrunErrors;
    ULONG AlignmentErrors;
    ULONG BufferOverrunErrors;
    
    ULONG BytesTransmittedUncompressed;
    ULONG BytesReceivedUncompressed;
    ULONG BytesTransmittedCompressed;
    ULONG BytesReceivedCompressed;
    
    ULONG TotalErrors;
    
} RAS_PORT_STAT, *PRAS_PORT_STAT;


//
// Data structure used to store both the statistics and the name of each
// open port.
//

typedef struct _RAS_PORT_DATA
{
    RAS_PORT_STAT       RasPortStat;

    WCHAR               PortName[ MAX_PORT_NAME ];

} RAS_PORT_DATA, *PRAS_PORT_DATA;



//
// Exported functions
//

extern LONG InitPortInfo();

extern LONG InitRasFunctions();

extern ULONG GetSpaceNeeded( BOOL IsRasPortObject, BOOL IsRasTotalObject );

extern NTSTATUS CollectRasStatistics();

extern DWORD GetNumOfPorts();

extern LPWSTR GetInstanceName( INT i );

extern VOID GetInstanceData( INT Port, PVOID *lppData );

extern VOID GetTotalData( PVOID *lppData );

extern VOID ClosePortInfo();

//
// Internal functions
//

#endif // PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\dllinit.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1995                 *
\******************************************************************/

/*++

Module Name:

    DLLINIT.C


Description:

    This module contains code for the rasadm.dll initialization.
Author:

    Janakiram Cherala (RamC)    November 29, 1995

Revision History:

--*/

#include <windows.h>

BOOL RasAdminDLLInit( HINSTANCE, DWORD, LPVOID );

HINSTANCE ThisDLLHandle;

BOOL
RasAdminDLLInit(
    IN HINSTANCE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\lists.c ===
#include <windows.h>
#include <malloc.h>

#include <sdebug.h>


typedef struct _LIST_NODE
{
    DWORD PointerType;
    PVOID Pointer;
    DWORD NumItems;
    struct _LIST_NODE *Next;
} LIST_NODE, *PLIST_NODE;


PLIST_NODE ListHeader = NULL;
BOOL NeedCriticalSection = FALSE;


HANDLE mutex;

#define ENTER_CRITICAL_SECTION \
        if (WaitForSingleObject(mutex, INFINITE)) { SS_ASSERT(FALSE); }

#define EXIT_CRITICAL_SECTION \
        if (!ReleaseMutex(mutex)) { SS_ASSERT(FALSE); }


DWORD MakeCriticalSection()
{
    NeedCriticalSection = TRUE;

    if ((mutex = CreateMutex(NULL, FALSE, NULL)) == NULL)
    {
        SS_ASSERT(FALSE);

        return (1L);
    }

    return (0L);
}


DWORD insert_list_head(
    IN PVOID Pointer,
    IN DWORD PointerType,
    IN DWORD NumItems
    )
{
    PLIST_NODE pListNode;


    if (NeedCriticalSection)
        ENTER_CRITICAL_SECTION;


    IF_DEBUG(HEAP_MGMT)
        SS_PRINT(("try: insert_list_head: pointer=%lx\n", (ULONG_PTR)Pointer));

    pListNode = (PLIST_NODE) GlobalAlloc(GMEM_FIXED, sizeof(LIST_NODE));
    if (!pListNode)
    {
        if (NeedCriticalSection)
            EXIT_CRITICAL_SECTION;

        return (1L);
    }

    IF_DEBUG(HEAP_MGMT)
        SS_PRINT(("insert_list_head: pointer=%lx\n", (ULONG_PTR)Pointer));

    pListNode->PointerType = PointerType;
    pListNode->Pointer = Pointer;
    pListNode->NumItems = NumItems;

    pListNode->Next = ListHeader;
    ListHeader = pListNode;

    if (NeedCriticalSection)
        EXIT_CRITICAL_SECTION;

    return (0L);
}


DWORD remove_list(
    IN PVOID Pointer,
    OUT PDWORD PointerType,
    OUT PDWORD NumItems
    )
{
    PLIST_NODE pListNode;
    PLIST_NODE pPrevListNode;


    if (NeedCriticalSection)
        ENTER_CRITICAL_SECTION;


    IF_DEBUG(HEAP_MGMT)
        SS_PRINT(("try: remove_list: pointer=%lx\n", (ULONG_PTR) Pointer));

    pListNode = ListHeader;
    pPrevListNode = ListHeader;


    if (!pListNode)
    {
        if (NeedCriticalSection)
            EXIT_CRITICAL_SECTION;

        return (1L);
    }

    while (pListNode)
    {
        if (pListNode->Pointer == Pointer)
        {
            IF_DEBUG(HEAP_MGMT)
                SS_PRINT(("remove_list: pointer=%lx\n", (ULONG_PTR) Pointer));

            //
            // We have a winner!
            //
            *PointerType = pListNode->PointerType;
            *NumItems = pListNode->NumItems;

            pPrevListNode->Next = pListNode->Next;

            if (ListHeader == pListNode)
            {
                ListHeader = pListNode->Next;
            }

            GlobalFree(pListNode);

            if (NeedCriticalSection)
                EXIT_CRITICAL_SECTION;

            return (0L);
        }

        pPrevListNode = pListNode;
        pListNode = pListNode->Next;
    }


    if (NeedCriticalSection)
        EXIT_CRITICAL_SECTION;

    return (1L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\compress.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Filename:    COMPRESS.C

Description: Contains procedures to compress and decompress phone
             numbers stored in the user parms field in the UAS.

Note:
             The routines were originally developed to operate on
             Multi-byte strings.  A Unicode wrapper using wcstombs()
             and mbstowcs() functions was written around the original
             functions and so you see the malloc() and free() usage
             as well.  Both these routines should be rewritten to be
             native Unicode routines when time permits.

History:
   June 4,1996.   RamC       Allow any alphanumeric character to be
                             specified in the Callback phone number.
   July 6,1992.   RamC       Ported to NT - removed several
                             header file includes and changed
                             memsetf to memset & strchrf to strchr

   July 1,1991.   NarenG     Created original version.
--*/

#include <windows.h>
#include <string.h>
#include <lm.h>
#include <stdlib.h>
#include <memory.h>
#include <usrparms.h>   // UP_LEN_DIAL
#include <raserror.h>
#include <rassapi.h>
#include <rassapip.h>
#include <util.h>       // function prototypes

// some convenient defines

static CHAR * CompressMap = "() tTpPwW,-@*#";

#define UNPACKED_DIGIT     100
#define COMPRESS_MAP_BEGIN 110
#define COMPRESS_MAP_END   (COMPRESS_MAP_BEGIN + strlen(CompressMap))
#define UNPACKED_OTHER     (COMPRESS_MAP_END + 1)


USHORT
RasAdminCompressPhoneNumber(
   IN  LPWSTR UncompNumber,
   OUT LPWSTR CompNumber
   )

/*

Routine Description:

    Will compress a phone number so that it may fit in the
    userparms field.


Arguments

    UncompNumber -  Pointer to the phone number that
                    will be compressed.

    CompNumber   -  Pointer to a buffer that is at least as long
                    as the Uncompressed number. On return
                    this will contain the compressed
                    phone number.

Return Value:

    0 if successful

    One of the following error codes otherwise:

        ERROR_INVALID_CALLBACK_NUMBER - failure, if the Uncompressed number
                                    has invalid chars.
        ERROR_BAD_LENGTH          - failure, if the compressed
                                    phone number will not fit
                                    in the userparms field.

Algortithm Used:

    An attempt is made to fit the given string in half the number of
    bytes by packing two adjacent numbers (in the phone number) in
    one byte.  For example if the phone number is "8611824", instead
    of storing it in 8 bytes (including the trailing NULL), it is
    stored in 4 bytes.  '0' is special case because it cannot be a
    byte by itself - will be interpreted as the terminating NULL.
    So, if two zeros appear next to each other as in "96001234", the
    two zeros are stored as the value 100.  Also the special characters
    which are allowed in the phone number string -  "() tTpPwW,-@*#"
    are stored as 110 + the index position in the above string. So,
    the '(' character would be stored as 110 (110+0) and the letter
    't' as 113 (110+3).
*/

{
CHAR *  Uncompressed;
CHAR *  Compressed;
CHAR *  UncompressedPtr;
CHAR *  CompressedPtr;
CHAR *  CharPtr;
USHORT  Packed;        // Indicates if the current byte is in the
                       // process of being paired.

    if(!(Uncompressed = calloc(1, RASSAPI_MAX_CALLBACK_NUMBER_SIZE+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    if(!(Compressed = calloc(1, RASSAPI_MAX_CALLBACK_NUMBER_SIZE+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    CompressedPtr   = Compressed;
    UncompressedPtr = Uncompressed;

    // convert unicode string to multi byte string for compression

    wcstombs(Uncompressed, UncompNumber, RASSAPI_MAX_CALLBACK_NUMBER_SIZE);


    for( Packed = 0; *Uncompressed; Uncompressed++ ) {

        switch( *Uncompressed ) {

            case '0':

                if ( Packed ){

                    // Put zero as the second paired digit

                    if ( *Compressed ) {
                        *Compressed =  (UCHAR)(*Compressed * 10);
                        Compressed++;
                        Packed = 0;
                    }

                    // We have a zero, we cant put a second zero or that
                    // will be a null byte. So, we store the value
                    // UNPACKED_DIGIT to fake this.

                    else {

                    *Compressed = UNPACKED_DIGIT;
                    *(++Compressed) = 0;
                    Packed = 1;
                    }
                }
                else {
                    *Compressed = 0;
                    Packed = 1;
                }

                break;

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':

                // If this is the second digit that is going to be
                // packed into one byte

                if ( Packed ) {
                    *Compressed = (UCHAR)((*Compressed*10)+(*Uncompressed-'0'));
                    // we need to special case number 32 which maps to a blank
                    if(*Compressed == ' ' )
                        *Compressed = COMPRESS_MAP_END;
                    Compressed++;
                    Packed = 0;
                }
                else {

                    *Compressed += ( *Uncompressed - '0' );
                    Packed = 1;

                }

                break;

            case '(':
            case ')':
            case ' ':
            case 't':
            case 'T':
            case 'p':
            case 'P':
            case 'w':
            case 'W':
            case ',':
            case '-':
            case '@':
            case '*':
            case '#':
                // if the byte was packed then we unpack it

                if ( Packed ) {
                    *Compressed += UNPACKED_DIGIT;
                    ++Compressed;
                    Packed = 0;
                }

                if ((CharPtr=strchr(CompressMap, *Uncompressed)) == NULL) {
                    free(UncompressedPtr);
                    free(CompressedPtr);
                    return( ERROR_INVALID_CALLBACK_NUMBER );
                }

                *Compressed = (UCHAR)(COMPRESS_MAP_BEGIN+
                                     (UCHAR)(CharPtr-CompressMap));
                Compressed++;
                break;

            default:
                // if the chracter is none of the above specially recognized characters
                // then copy the value + UNPACKED_OTHER to make it possible to decompress
                // at the other end. [ 6/4/96 RamC ]

                if ( Packed) {
                   *Compressed += UNPACKED_DIGIT;
                   ++Compressed;
                   Packed = 0;
                }
                *Compressed = *Uncompressed + UNPACKED_OTHER;
                Compressed++;
#if 0
                // Nothing is invalid any more  [ 6/4/96 RamC ]
                free(UncompressedPtr);
                free(CompressedPtr);
                return( ERROR_INVALID_CALLBACK_NUMBER );
#endif
        }

    }

    free(UncompressedPtr);

    // If we are in the middle of packing something
    // then we unpack it

    if ( Packed )
        *Compressed += UNPACKED_DIGIT;

    // Check if it will fit in the userparms field or not

    if ( strlen( CompressedPtr ) > UP_LEN_DIAL ) {
        free(CompressedPtr);
        return( ERROR_BAD_LENGTH );
    }

    // convert to unicode string before returning

    mbstowcs(CompNumber, CompressedPtr, RASSAPI_MAX_CALLBACK_NUMBER_SIZE);

    free(CompressedPtr);

    return(0);

}


USHORT
RasAdminDecompressPhoneNumber(
  IN  LPWSTR CompNumber,
  OUT LPWSTR DecompNumber
  )

/*++


Routine Description:

    Will decompress a phone number.

Arguments:

    CompNumber        - Pointer to a compressed phone number.
    DecompNumber      - Pointer to a buffer that is large enough to
                        hold the Decompressed number.

Return Value:

    0 on success

    ERROR_INVALID_CALLBACK_NUMBER - failure, if the Compressed number
                                contains unrecognizable chars.

Algortithm Used:

    We just do the opposite of the algorithm used in RasAdminCompressPhoneNumber.

--*/

{
CHAR * Decompressed;
CHAR * Compressed;
CHAR * DecompressedPtr;
CHAR * CompressedPtr;


    if(!(Decompressed = calloc(1, RASSAPI_MAX_CALLBACK_NUMBER_SIZE+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    if(!(Compressed = calloc(1, RASSAPI_MAX_CALLBACK_NUMBER_SIZE+1))) {
       return(ERROR_NOT_ENOUGH_MEMORY);
    }
    DecompressedPtr = Decompressed;
    CompressedPtr   = Compressed;

    // convert unicode string to multi byte string for decompression

    wcstombs(Compressed, CompNumber, RASSAPI_MAX_CALLBACK_NUMBER_SIZE+1);

    for(; *Compressed; Compressed++, Decompressed++ ) {

        // If this byte is packed then we unpack it

        if ( (UINT)*Compressed < UNPACKED_DIGIT ) {
            *Decompressed = (UCHAR)(((*Compressed) / 10) + '0' );
            *(++Decompressed) = (UCHAR)( ((*Compressed) % 10) + '0' );
            continue;
        }
        // we need to special case number 32 which maps to a blank
        else if ( (UINT)*Compressed == COMPRESS_MAP_END ) {
            *Decompressed = (UCHAR) '3';
            *(++Decompressed) = (UCHAR)'2';
            continue;
        }

        // the number is an unpacked digit

        else if ( (UINT)*Compressed < COMPRESS_MAP_BEGIN ) {
            *Decompressed = (UCHAR)((*Compressed -(UCHAR)UNPACKED_DIGIT ) +
                            '0' );
            continue;
        }

        // Otherwise the byte was not packed

        else if ( (UINT)*Compressed < 128 ) {
            *Decompressed = CompressMap[(*Compressed -
                                        (UCHAR)COMPRESS_MAP_BEGIN)];
            continue;
        }

        // otherwise the byte is an unpacked character  [ 6/4/96 RamC ]
        else
        {
           *Decompressed = *Compressed - UNPACKED_OTHER;
        }
#if 0
        // Nothing is invalid any more  [ 6/4/96 RamC ]
        free(DecompressedPtr);
        free(CompressedPtr);

        return( ERROR_INVALID_CALLBACK_NUMBER );
#endif
    }

    // convert to unicode string before returning

    mbstowcs(DecompNumber, DecompressedPtr, RASSAPI_MAX_CALLBACK_NUMBER_SIZE+1);

    free(DecompressedPtr);
    free(CompressedPtr);
    return( 0 );

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\lists.h ===
#include <windows.h>

DWORD insert_list_head(
    IN DWORD PointerType,
    IN PVOID Pointer,
    IN DWORD NumItems
    );


DWORD remove_list(
    IN PVOID Pointer,
    OUT PDWORD PointerType,
    OUT DWORD NumItems
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\sdebug.c ===
/*****************************************************************************/
/**			 Microsoft LAN Manager				    **/
/**		   Copyright (C) Microsoft Corp., 1992			    **/
/*****************************************************************************/


//
// *** Main For Supervisor Debug ***
//

#include <windows.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#include "sdebug.h"


#if  DBG

VOID AaAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN DWORD LineNumber
    )
{
    BOOL ok;
    BYTE choice[16];
    DWORD bytes;
    DWORD error;

    AaPrintf( "\nAssertion failed: %s\n  at line %ld of %s\n",
                FailedAssertion, LineNumber, FileName );
    do {
        AaPrintf( "Break or Ignore [bi]? " );
        bytes = sizeof(choice);
        ok = ReadFile(
                GetStdHandle(STD_INPUT_HANDLE),
                &choice,
                bytes,
                &bytes,
                NULL
                );
        if ( ok ) {
            if ( toupper(choice[0]) == 'I' ) {
                break;
            }
            if ( toupper(choice[0]) == 'B' ) {
		DbgUserBreakPoint( );
            }
        } else {
            error = GetLastError( );
        }
    } while ( TRUE );

    return;

} // AaAssert

#endif


#if DBG

static BOOL first = TRUE;
DWORD g_dbgaction = 0L;

VOID AaGetDebugConsole(VOID)
{
    if ((g_dbgaction==1) && first)
    {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        COORD coord;

        first = FALSE;
        g_dbgaction = 0;

        AllocConsole( );
        GetConsoleScreenBufferInfo( GetStdHandle(STD_OUTPUT_HANDLE), &csbi );
        coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
        coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
        SetConsoleScreenBufferSize( GetStdHandle(STD_OUTPUT_HANDLE), coord );
    }
}
#endif


#if  DBG

VOID AaPrintf(
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    DWORD length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), (LPVOID )OutputBuffer, length, &length, NULL );

} // AaPrintf

#endif


#if DBG


DWORD g_level;


#undef GlobalAlloc
#undef GlobalLock
#undef GlobalReAlloc
#undef GlobalFree
#undef GlobalUnlock


// Get a dword from on-the-wire format to the host format
#define GETULONG(DstPtr, SrcPtr)                 \
    *(unsigned long *)(DstPtr) =                 \
        ((*((unsigned char *)(SrcPtr)+3) << 24) +\
        (*((unsigned char *)(SrcPtr)+2) << 16) + \
        (*((unsigned char *)(SrcPtr)+1) << 8)  + \
        (*((unsigned char *)(SrcPtr)+0)))


// Put a ulong from the host format to on-the-wire format
#define PUTULONG(DstPtr, Src)   \
    *((unsigned char *)(DstPtr)+3)=(unsigned char)((unsigned long)(Src) >> 24),\
    *((unsigned char *)(DstPtr)+2)=(unsigned char)((unsigned long)(Src) >> 16),\
    *((unsigned char *)(DstPtr)+1)=(unsigned char)((unsigned long)(Src) >>  8),\
    *((unsigned char *)(DstPtr)+0)=(unsigned char)(Src)



HGLOBAL DEBUG_MEM_ALLOC(UINT allocflags, DWORD numbytes)
{
    HGLOBAL retval;
    PBYTE pb;

    retval = GlobalAlloc(allocflags, numbytes + 3 * sizeof(DWORD));
    if ((retval) && !(allocflags & GMEM_MOVEABLE))
    {
        pb = (PBYTE) retval;
        PUTULONG(pb, BEG_SIGNATURE_DWORD);

        pb += sizeof(DWORD);
        PUTULONG(pb, numbytes);

        pb += sizeof(DWORD);


        IF_DEBUG(MEMORY_TRACE)
            SS_PRINT(("**ALLOC MEM %li (%li) BYTES BEGINNING AT %lx (%lx)\n",
                    numbytes, numbytes + 3 * sizeof(DWORD), pb, retval));


        retval = (HGLOBAL) pb;

        pb += numbytes;
        PUTULONG(pb, END_SIGNATURE_DWORD);
    }

    return (retval);
}

LPVOID DEBUG_MEM_LOCK(HGLOBAL hglbl)
{
    PBYTE pb;

    pb = GlobalLock(hglbl);
    if (pb)
    {
        DWORD numbytes = (DWORD)(GlobalSize(hglbl) - 3 * sizeof(DWORD));
        PBYTE pEnd;

        PUTULONG(pb, BEG_SIGNATURE_DWORD);

        pb += sizeof(DWORD);
        PUTULONG(pb, numbytes);

        pb += sizeof(DWORD);


        IF_DEBUG(MEMORY_TRACE)
            SS_PRINT(("**LOCKED MEM %li (%li) BYTES BEGINNING AT %lx (%lx)\n",
                    numbytes, numbytes + 3 * sizeof(DWORD), pb, pb-2*sizeof(DWORD)));

        pEnd = pb + numbytes;
        PUTULONG(pEnd, END_SIGNATURE_DWORD);
    }

    return (pb);
}

HGLOBAL DEBUG_MEM_REALLOC(HGLOBAL hmem, DWORD numbytes, UINT flags)
{
    IF_DEBUG(MEMORY_TRACE)
        SS_PRINT(("**REALLOCING HGLOBAL %lx\n", hmem));

    hmem = GlobalReAlloc(hmem, numbytes + 3 * sizeof(DWORD), flags);

    return (hmem);
}

HGLOBAL DEBUG_MEM_FREE(HGLOBAL hmem)
{
    HGLOBAL hglbl;
    DWORD Signature;
    DWORD numbytes;
    PBYTE pb;

    pb = (PBYTE) hmem;

    pb -= 2 * sizeof(DWORD);
    hglbl = (HGLOBAL) pb;


    GETULONG(&Signature, pb);
    SS_ASSERT(Signature == BEG_SIGNATURE_DWORD);

    pb += sizeof(DWORD);
    GETULONG(&numbytes, pb);

    pb += sizeof(DWORD);

    pb += numbytes;
    GETULONG(&Signature, pb);
    SS_ASSERT(Signature == END_SIGNATURE_DWORD);


    IF_DEBUG(MEMORY_TRACE)
        SS_PRINT(("**FREED MEM %li (%li) BYTES BEGINNING AT %lx (%lx)\n",
                numbytes, numbytes + 3 * sizeof(DWORD), hmem, hglbl));


    return (GlobalFree(hglbl));
}

HGLOBAL DEBUG_MEM_UNLOCK(HGLOBAL hmem)
{
    IF_DEBUG(MEMORY_TRACE)
        SS_PRINT(("**UNLOCKED HGLOBAL %lx\n", hmem));

    return (HGLOBAL)(ULONG_PTR) (GlobalUnlock(hmem));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\sdebug.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	sdebug.h
//
// Description: This module debug definitions for
//		the supervisor module.
//
// Author:	Stefan Solomon (stefans)    May 22, 1992.
//
// Revision History:
//
//***


#ifndef _SDEBUG_
#define _SDEBUG_

#if DBG


VOID DbgUserBreakPoint(VOID);

#define BEG_SIGNATURE_DWORD   0x4DEEFDABL
#define END_SIGNATURE_DWORD   0xBADFEED4L

#define GlobalAlloc       DEBUG_MEM_ALLOC
#define GlobalLock        DEBUG_MEM_LOCK
#define GlobalReAlloc     DEBUG_MEM_REALLOC
#define GlobalFree        DEBUG_MEM_FREE
#define GlobalUnlock      DEBUG_MEM_UNLOCK

HGLOBAL DEBUG_MEM_ALLOC(UINT, DWORD);
LPVOID DEBUG_MEM_LOCK(HGLOBAL hglbl);
HGLOBAL DEBUG_MEM_REALLOC(HGLOBAL, DWORD, UINT);
HGLOBAL DEBUG_MEM_FREE(HGLOBAL);
HGLOBAL DEBUG_MEM_UNLOCK(HGLOBAL hmem);


//
// Debug levels
//
#define DEBUG_HEAP_MGMT       0x00000001
#define DEBUG_MEMORY_TRACE    0x00000002
#define DEBUG_STACK_TRACE     0x00000004

extern DWORD g_level;
extern DWORD g_dbgaction;

#define DEBUG if ( TRUE )
#define IF_DEBUG(flag) if (g_level & (DEBUG_ ## flag))

VOID AaPrintf(
    char *Format,
    ...
    );

#define SS_PRINT(args) AaPrintf args


VOID AaAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );

VOID AaGetDebugConsole(VOID);

#define GET_CONSOLE AaGetDebugConsole()


#define SS_ASSERT(exp) if (!(exp)) AaAssert( #exp, __FILE__, __LINE__ )

#else

#define DEBUG if ( FALSE )
#define IF_DEBUG(flag) if (FALSE)

#define SS_PRINT(args)

#define SS_ASSERT(exp)

#define GET_CONSOLE

#endif	// DBG

//*** Definitions to enable emulated modules ***

#define RASMAN_EMULATION
#define SERVICE_CONTROL_EMULATION

//*** Definitions to enable debug printing

#define DEFAULT_DEBUG = DEBUG_INITIALIZATION | DEBUG_TERMINATION | DEBUG_FSM

#endif // ndef _SDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\nmapi.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    NMAPI.C


Description:

    This module contains code for all the RASADMIN APIs
    that communicate with the server using Named pipes.

    RasAdminPortEnum
    RasAdminPortGetInfo
    RasAdminPortClearStatistics
    RasAdminServerGetInfo
    RasAdminPortDisconnect
    BuildPipeName         - internal routine
    GetRasServerVersion   - internal routine

Author:

    Janakiram Cherala (RamC)    July 7,1992

Revision History:

    Jan 04,1993    RamC    Set the Media type to MEDIA_RAS10_SERIAL in
                           RasAdminPortEnum to fix a problem with port
                           enumeration against downlevel servers.
                           Changed the hardcoded stats indices to defines

    Aug 25,1992    RamC    Code review changes:

                           o changed all lpbBuffers to actual structure
                             pointers.
                           o changed all LPWSTR to LPWSTR

    July 7,1992    RamC    Ported from RAS 1.0 (Original version
                           written by Narendra Gidwani - nareng)

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <lm.h>
#include <malloc.h>
#include <memory.h>
#include <raserror.h>
#include <rassapi.h>
#include <rassapip.h>
#include <util.h>  // utility function prototypes

#include "sdebug.h"

#define NUM_PIPE_TRIES 2

static HANDLE hmem, hnewmem;

DWORD PipeRequest(
    const WCHAR * Server,
    PBYTE Request,
    DWORD SizeOfRequest,
    PBYTE Response,
    DWORD SizeOfResponse
    );

DWORD APIENTRY RasAdminPortEnum(
    IN const WCHAR * lpszServer,
    OUT PRAS_PORT_0 *ppRasPort0,
    OUT WORD *pcEntriesRead
    )
/*++

Routine Description:

    This routine enumerates all the ports on the specified server
    and fills up the caller's lpBuffer with an array of RAS_PORT_0
    structures for each port.  A NULL lpszServer indicates the
    local server.

Arguments:

    lpszServer      name of the server to enumerate ports on.

    pRasPort0       pointer to a buffer in which port information is
                    returned as an array of RAS_PORT_0 structures.

    pcEntriesRead   The number of RAS_PORT_0 entries loaded.

Return Value:

    ERROR_SUCCESS if successful

    One of the following non-zero error codes indicating failure:

        NERR_ItemNotFound indicates no ports were found.
        error codes from CallNamedPipe.
        ERROR_MORE_DATA indicating more data is available.
--*/
{
    WORD i;
    DWORD dwRetCode;
    DWORD dwVersion;
    PRAS_PORT_0 pRasPort0;

    ASSERT( lpszServer );

    // find the RasServer Version first

    if (dwRetCode = GetRasServerVersion(lpszServer, &dwVersion))
    {
       return(dwRetCode);
    }


    IF_DEBUG(STACK_TRACE)
        SS_PRINT(("RasAdminPortEnum: Ras Server %ws is Version %d\n",
                lpszServer, dwVersion));


    //
    // do the downlevel thing
    //
    if (dwVersion == RASDOWNLEVEL)
    {
        struct PortEnumRequestPkt SendEnum;
        P_PORT_ENUM_REQUEST_PKT PSendEnum;
        struct PortEnumReceivePkt ReceiveEnum;
        P_PORT_ENUM_RECEIVE_PKT PReceiveEnum;

        IF_DEBUG(STACK_TRACE)
            SS_PRINT(("RasAdminPortEnum: Processing Downlevel code\n"));

        SendEnum.Request = RASADMINREQ_ENUM_PORTS;

        PackPortEnumRequestPkt(&SendEnum, &PSendEnum);

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendEnum,
                sizeof(PSendEnum),
                (PBYTE) &PReceiveEnum,
                sizeof(PReceiveEnum)) )
        {
            return (dwRetCode);
        }

        UnpackPortEnumReceivePkt(&PReceiveEnum, &ReceiveEnum);

        if (ReceiveEnum.RetCode)
        {
            return(ReceiveEnum.RetCode);
        }


        //
        // We have the data.  So we'll allocate a buffer for the app
        // that we'll copy the data in to and return.
        //
        *ppRasPort0 = GlobalAlloc(GMEM_FIXED,
                ReceiveEnum.TotalAvail * sizeof(RAS_PORT_0));

        if (!*ppRasPort0)
        {
           return (GetLastError());
        }


        // else copy the data to users buffer item by item

        *pcEntriesRead = ReceiveEnum.TotalAvail;

        for (i=0, pRasPort0 = *ppRasPort0; i<*pcEntriesRead; i++, pRasPort0++)
        {
            // convert RAS1.0 info to RAS 2.0 info

            struct dialin_port_info_0 *pRas10PortInfo0 = &ReceiveEnum.Data[i];


            // get the port name from the RAS 1.0 style PortID

            GetPortName(pRas10PortInfo0->dporti0_comid, pRasPort0->wszPortName);


            pRasPort0->Flags = MESSENGER_PRESENT;

            if ((pRas10PortInfo0->dporti0_modem_condition ==
                            RAS_MODEM_OPERATIONAL) &&
                    (pRas10PortInfo0->dporti0_line_condition ==
                            RAS_PORT_AUTHENTICATED))
            {
                pRasPort0->Flags |= USER_AUTHENTICATED;
            }

            // force these flags for a downlevel server
            // because these Flags were not available for the downlevel server.
            pRasPort0->Flags |= REMOTE_LISTEN;
            pRasPort0->Flags |= GATEWAY_ACTIVE;

            lstrcpy((LPTSTR) pRasPort0->wszDeviceType,
                    (LPCTSTR) DEVICE_TYPE_DEFAULT);
            lstrcpy((LPTSTR) pRasPort0->wszDeviceName,
                    (LPCTSTR) DEVICE_NAME_DEFAULT);

            lstrcpy((LPTSTR) pRasPort0->wszMediaName,
                    (LPCTSTR) MEDIA_NAME_DEFAULT);
            pRasPort0->reserved = MEDIA_RAS10_SERIAL;


            // rest of info is only valid if authenticated

            if (pRasPort0->Flags & USER_AUTHENTICATED)
            {
                mbstowcs(pRasPort0->wszUserName,
                        pRas10PortInfo0->dporti0_username, LM20_UNLEN);


                mbstowcs(pRasPort0->wszComputer,
                        pRas10PortInfo0->dporti0_computer, NETBIOS_NAME_LEN+1);


                pRasPort0->dwStartSessionTime =
                        pRas10PortInfo0->dporti0_time;
            }
            else
            {
                lstrcpyW(pRasPort0->wszUserName, L"");
                lstrcpyW(pRasPort0->wszComputer, L"");
                pRasPort0->dwStartSessionTime = 0L;
            }

            //
            // Logon domain not supplied by RAS 1.x server, so we NULL it out
            //
            lstrcpyW(pRasPort0->wszLogonDomain, L"");
            pRasPort0->fAdvancedServer = TRUE;
        }
    } // end if RASDOWNLEVEL
    else
    {
        // RAS 2.0 or greater

        CLIENT_REQUEST SendEnum;
        P_CLIENT_REQUEST PSendEnum;
        PORT_ENUM_RECEIVE RecvEnum;
        PP_PORT_ENUM_RECEIVE pPRecvEnum;
        DWORD cbPRecvBuf;
        DWORD BytesToWrite = sizeof(PSendEnum);
        USHORT ResumePort = 0; // if there is > 64K data this resume port
                               // is used to retrieve additional data

        IF_DEBUG(STACK_TRACE)
            SS_PRINT(("RasAdminPortEnum: Processing RAS 2.0+ code\n"));

        SendEnum.RequestCode = RASADMIN20_REQ_ENUM_PORTS;
        SendEnum.RcvBufSize = 0L;  // this will force server to tell us how
                                   // many ports there are


        pPRecvEnum = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                sizeof(P_PORT_ENUM_RECEIVE));
        if (!pPRecvEnum)
        {
            return (GetLastError());
        }


        //
        // Early versions of NT Admin do not support client version
        // number in the request, so we won't write it.
        //
        if (dwVersion == RAS_SERVER_20)
        {
            BytesToWrite -= 4;
        }

        //
        // Send the request to the server to find out the buffer size
        // required.  This call should always fail with
        // ReceiveEnum.TotalAvail indicating how many ports are being
        // enumerated.  We can then get memory for the data and send
        // the request to the server again.
        //
        PackClientRequest(&SendEnum, &PSendEnum);

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendEnum,
                BytesToWrite,
                (PBYTE) pPRecvEnum,
                sizeof(P_PORT_ENUM_RECEIVE) ))
        {
            GlobalFree(pPRecvEnum);
            return (dwRetCode);
        }


        if (dwRetCode = UnpackPortEnumReceive(pPRecvEnum, &RecvEnum))
        {
            GlobalFree(pPRecvEnum);
            return (dwRetCode);
        }

        GlobalFree(pPRecvEnum);


        // check the result of the request

        if (RecvEnum.RetCode)
        {
            SS_PRINT(("RasAdminPortEnum: server result code=%li\n",
                    RecvEnum.RetCode));

            if (RecvEnum.RetCode == NERR_BufTooSmall)
            {
                // -1 accounts for the fact that P_PORT_ENUM_RECEIVE contains
                // space for 1 P_RAS_PORT_0 structure.

                cbPRecvBuf = sizeof(P_PORT_ENUM_RECEIVE) +
                        sizeof(P_RAS_PORT_0) * (RecvEnum.TotalAvail - 1);

                pPRecvEnum = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, cbPRecvBuf);
                if (!pPRecvEnum)
                {
                    return (GetLastError());
                }

                SendEnum.RcvBufSize = cbPRecvBuf;

                PackClientRequest(&SendEnum, &PSendEnum);

                if (dwRetCode = PipeRequest(
                        lpszServer,
                        (PBYTE) &PSendEnum,
                        BytesToWrite,
                        (PBYTE) pPRecvEnum,
                        cbPRecvBuf ))
                {
                    GlobalFree(pPRecvEnum);
                    return (dwRetCode);
                }

                dwRetCode = UnpackPortEnumReceive(pPRecvEnum, &RecvEnum);
                GlobalFree(pPRecvEnum);

                if (dwRetCode)
                {
                    return (dwRetCode);
                }

                if (RecvEnum.RetCode)
                {
                   // check for more data from the server
                   if(RecvEnum.RetCode == ERROR_MORE_DATA)
                   {
                       // while there are more ports, get them all
                       while(RecvEnum.RetCode == ERROR_MORE_DATA)
                       {
                           ResumePort += RecvEnum.TotalAvail;
                           SendEnum.RequestCode = RASADMIN20_REQ_ENUM_RESUME;

                           cbPRecvBuf = sizeof(P_PORT_ENUM_RECEIVE) +
                                        sizeof(P_RAS_PORT_0) *
                                        (RecvEnum.TotalAvail - 1);

                           pPRecvEnum = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,
                                                    cbPRecvBuf);
                           if (!pPRecvEnum)
                           {
                               GlobalFree(pPRecvEnum);
                               return (GetLastError());
                           }

                           SendEnum.RcvBufSize = cbPRecvBuf;

                           PackResumeRequest(&SendEnum, &PSendEnum, ResumePort);

                           if (dwRetCode = PipeRequest(lpszServer,
                                                       (PBYTE) &PSendEnum,
                                                       BytesToWrite,
                                                       (PBYTE) pPRecvEnum,
                                                       cbPRecvBuf ))
                           {
                               GlobalFree(pPRecvEnum);
                               return (dwRetCode);
                           }

                           dwRetCode = UnpackResumeEnumReceive(pPRecvEnum,
                                                               &RecvEnum,
                                                               ResumePort);
                           GlobalFree(pPRecvEnum);
                           if (dwRetCode)
                           {
                               return (dwRetCode);
                           }
                       }
                   }
                   else
                   {
                       SS_PRINT(("RasAdminPortEnum: server result code=%li\n",
                               RecvEnum.RetCode));

                       return (RecvEnum.RetCode);
                   }
                }
            }
            else
            {
                return (RecvEnum.RetCode);
            }
        }

        //
        // if no entries found we indicate that
        //
        *pcEntriesRead = RecvEnum.TotalAvail + ResumePort;
        if (*pcEntriesRead == 0)
        {
            return (NERR_ItemNotFound);
        }

        //
        // We have some ports.  Now, get the port information.
        //
        RecvEnum.Data = (RAS_PORT_0 *)GlobalLock(hmem);

        if (!RecvEnum.Data)
        {
            return (GetLastError());
        }

        // Allocate the required memory
        *ppRasPort0 = GlobalAlloc(GMEM_FIXED,
                                   *pcEntriesRead * sizeof(RAS_PORT_0));

        if (!*ppRasPort0)
        {
           return (GetLastError());
        }

        // Copy it to the destination buffer
        memcpy( *ppRasPort0,
                RecvEnum.Data,
                *pcEntriesRead * sizeof(RAS_PORT_0));

        GlobalUnlock((HGLOBAL)RecvEnum.Data);

        GlobalFree(RecvEnum.Data);

        if (dwVersion == RAS_SERVER_20)
        {
            for (i=0, pRasPort0 = *ppRasPort0;
                                  i<*pcEntriesRead; i++, pRasPort0++)
            {
                // force these flags for a downlevel server
                // because these Flags were not available for the downlevel server.
                pRasPort0->Flags |= REMOTE_LISTEN;
                pRasPort0->Flags |= GATEWAY_ACTIVE;
            }
        }
    } // end else RASDOWNLEVEL


    if (insert_list_head(*ppRasPort0, RASADMIN_PORT_ENUM_PTR, 0L))
    {
        GlobalFree(*ppRasPort0);
        return (ERROR_NOT_ENOUGH_MEMORY);
    }


    SS_PRINT(("RasAdminPortEnum: Completed successfully\n"));

    return(ERROR_SUCCESS);
}

DWORD APIENTRY RasAdminPortGetInfo(
  IN const WCHAR          *  lpszServer,
  IN const WCHAR          *  lpszPort,
  OUT RAS_PORT_1          *  pRasPort1,
  OUT RAS_PORT_STATISTICS *  pRasStats,
  OUT RAS_PARAMETERS      ** ppRasParams
  )
/*++

Routine Description:

    This routine retrieves information associated with a port on the
    server. It loads the caller's pRasPort1 with a RAS_PORT_1 structure.

Arguments:

    lpszServer  name of the server which has the port, eg.,"\\SERVER"

    lpszPort    port name to retrieve information for, e.g. "COM1".

    pRasPort1   pointer to a buffer in which port information is
                returned.  The returned info is a RAS_PORT_1 structure.

    pRasStats   pointer to a buffer in which port statistics information is
                returned.  The returned info is a RAS_PORT_STATISTICS structure.

    ppRasParams pointer to a buffer in which port parameters information is
                returned.  The returned info is an array of RAS_PARAMETERS structure.
                It is the responsibility of the caller to free this buffer calling
                RasAdminBufferFree.

Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        ERROR_MORE_DATA indicating that more data than can fit in
                        pRasPort1 is available
        return codes from CallNamedPipe.
        ERROR_DEV_NOT_EXIST indicating requested port is invalid.
--*/
{
    DWORD dwVersion;
    DWORD dwRetCode;
    WCHAR portname[RAS10_MAX_PORT_NAME]; // used in GetPortName
    WCHAR tmpbuffer[UNLEN+1];            // used in mbs-wcs conversion
    DWORD RasStatsSize;
    DWORD NumParms;


    ASSERT (lpszServer);
    ASSERT (lpszPort);

    // find the RasServer Version first

    if (dwRetCode = GetRasServerVersion(lpszServer, &dwVersion))
    {
       return(dwRetCode);
    }

    if (dwVersion == RASDOWNLEVEL)
    {
        struct PortInfoRequestPkt SendInfo;
        P_PORT_INFO_REQUEST_PKT PSendInfo;
        struct PortInfoReceivePkt ReceiveInfo;
        P_PORT_INFO_RECEIVE_PKT PReceiveInfo;

        SendInfo.Request = RASADMINREQ_GET_PORT_INFO;

        if ((SendInfo.ComId = GetPortId(lpszPort)) == -1 ) {
            return(ERROR_DEV_NOT_EXIST);
        }

        PackPortInfoRequestPkt(&SendInfo, &PSendInfo);

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendInfo,
                sizeof(PSendInfo),
                (PBYTE) &PReceiveInfo,
                sizeof(PReceiveInfo) ))
        {
            return (dwRetCode);
        }

        UnpackPortInfoReceivePkt(&PReceiveInfo, &ReceiveInfo);

        if (ReceiveInfo.RetCode)
        {
            return (ReceiveInfo.RetCode);
        }
        else
        {
            // convert RAS1.0 info to RAS 2.0 info

            PRAS_PORT_0 pRasPort0 = &pRasPort1->rasport0;
            struct dialin_port_info_1 *pRas10Port1 =  &ReceiveInfo.Data;
            WpdStatisticsInfo *pRas10Stats = &pRas10Port1->dporti1_stats;
            struct dialin_port_info_0 *pRas10Port0 =  &pRas10Port1->dporti0;


            mbstowcs(tmpbuffer, pRas10Port0->dporti0_username, LM20_UNLEN + 1);
            lstrcpy((LPTSTR) pRasPort0->wszUserName, (LPCTSTR) tmpbuffer);

            mbstowcs(tmpbuffer, pRas10Port0->dporti0_computer,
                    NETBIOS_NAME_LEN + 1);

            lstrcpy((LPTSTR) pRasPort0->wszComputer, (LPCTSTR) tmpbuffer);
            lstrcpy((LPTSTR) pRasPort0->wszLogonDomain, (LPCTSTR) "");
            pRasPort0->fAdvancedServer = TRUE;


            // get the port name from the RAS 1.0 style PortID

            GetPortName(pRas10Port0->dporti0_comid, portname);
            lstrcpy((LPTSTR) pRasPort0->wszPortName, (LPCTSTR) portname);

            lstrcpy((LPTSTR) pRasPort0->wszDeviceType,
                    (LPCTSTR) DEVICE_TYPE_DEFAULT);
            lstrcpy((LPTSTR) pRasPort0->wszDeviceName,
                    (LPCTSTR) DEVICE_NAME_DEFAULT);

            lstrcpy((LPTSTR) pRasPort0->wszMediaName,
                    (LPCTSTR) MEDIA_NAME_DEFAULT);
            pRasPort0->reserved = MEDIA_RAS10_SERIAL;

            pRasPort0->dwStartSessionTime = pRas10Port0->dporti0_time;


            pRasPort0->Flags = MESSENGER_PRESENT;

            if ((pRas10Port0->dporti0_modem_condition ==
                            RAS_MODEM_OPERATIONAL) &&
                    (pRas10Port0->dporti0_line_condition ==
                            RAS_PORT_AUTHENTICATED))
            {
                pRasPort0->Flags |= USER_AUTHENTICATED;
            }

            // force these flags for a downlevel server
            // because these Flags were not available for the downlevel server.
            pRasPort0->Flags |= REMOTE_LISTEN;
            pRasPort0->Flags |= GATEWAY_ACTIVE;

            pRasPort1->LineSpeed = pRas10Port1->dporti1_baud;
            pRasPort1->LineCondition = pRas10Port0->dporti0_line_condition;
            pRasPort1->HardwareCondition = pRas10Port0->dporti0_modem_condition;

            // We have no Projection Result information, so just stub out
            // the information and copy the computer name into the nbf
            // address

            if (pRasPort0->Flags & USER_AUTHENTICATED)
            {
                pRasPort1->ProjResult.nbf.dwError = SUCCESS;
                pRasPort1->ProjResult.nbf.dwNetBiosError = 0;

                lstrcpy((LPTSTR) pRasPort1->ProjResult.nbf.wszWksta,
                        (LPTSTR) pRasPort0->wszComputer);
            }
            else
            {
                pRasPort1->ProjResult.nbf.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
            }

            pRasPort1->ProjResult.ip.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
            pRasPort1->ProjResult.ipx.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
            pRasPort1->ProjResult.at.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
            // Copy the statistics info

            pRasPort1->NumStatistics = RAS10_MAX_STATISTICS;

            memset( pRasStats, 0, sizeof(RAS_PORT_STATISTICS));

            pRasStats->dwBytesRcved         = pRas10Stats->stat_bytesreceived;
            pRasStats->dwBytesXmited        = pRas10Stats->stat_bytesxmitted;
            pRasStats->dwHardwareOverrunErr = pRas10Stats->stat_overrunerr;
            pRasStats->dwTimeoutErr         = pRas10Stats->stat_timeouterr;
            pRasStats->dwFramingErr         = pRas10Stats->stat_framingerr;
            pRasStats->dwCrcErr             = pRas10Stats->stat_crcerr;


            // And, we have no media parameters

            NumParms = 0L;
            pRasPort1->NumMediaParms = 0L;

            *ppRasParams = (RAS_PARAMETERS *) NULL;

        }
    } // end if RASDOWNLEVEL
    else
    {
        // RAS 2.0 or greater

        CLIENT_REQUEST SendInfo;
        P_CLIENT_REQUEST PSendInfo;
        PORT_INFO_RECEIVE ReceiveInfo;
        PP_PORT_INFO_RECEIVE pPReceiveInfo;
        PP_PORT_INFO_RECEIVE pSavePReceiveInfo;
        DWORD BytesToWrite = sizeof(PSendInfo);
        WORD  NumStatistics;

        //
        // We need to make 2 calls to the server.  First is to tell
        // us how big a buffer we need for getting all the the port
        // data.  Second is to get all the data.
        //

        SendInfo.RequestCode = RASADMIN20_REQ_GET_PORT_INFO;
        SendInfo.RcvBufSize = sizeof(P_PORT_INFO_RECEIVE);
        lstrcpy((LPTSTR) SendInfo.PortName, (LPCTSTR) lpszPort);

        PackClientRequest(&SendInfo, &PSendInfo);

        pPReceiveInfo = GlobalAlloc(GMEM_FIXED, sizeof(P_PORT_INFO_RECEIVE));
        if (!pPReceiveInfo)
        {
            return (GetLastError());
        }

        pSavePReceiveInfo = pPReceiveInfo;

        //
        // Early versions of NT Admin do not support client version
        // number in the request, so we won't write it.
        //
        if (dwVersion == RAS_SERVER_20)
        {
            BytesToWrite -= 4;
        }

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendInfo,
                BytesToWrite,
                (PBYTE) pPReceiveInfo,
                sizeof(P_PORT_INFO_RECEIVE) ))
        {
            SS_PRINT(("RasAdminPortGetInfo: - CallNamedPipe (1) rc=%li\n",
                    dwRetCode));

            GlobalFree(pPReceiveInfo);

            return (dwRetCode);
        }

        UnpackPortInfoReceive(pPReceiveInfo, &ReceiveInfo, dwVersion);

        if (ReceiveInfo.RetCode)
        {
            if ((ReceiveInfo.RetCode == ERROR_MORE_DATA) ||
                    (ReceiveInfo.RetCode == NERR_BufTooSmall))
            {
                //
                // Now that we know how much space we need, let's get
                // some memory and make the call again.
                //
                SendInfo.RequestCode = RASADMIN20_REQ_GET_PORT_INFO;
                SendInfo.RcvBufSize = ReceiveInfo.ReqBufSize;
                lstrcpy((LPTSTR) SendInfo.PortName, (LPCTSTR) lpszPort);

                PackClientRequest(&SendInfo, &PSendInfo);

                GlobalFree(pPReceiveInfo);

                pPReceiveInfo = GlobalAlloc(GMEM_FIXED, ReceiveInfo.ReqBufSize);
                if (!pPReceiveInfo)
                {
                    return (GetLastError());
                }

                pSavePReceiveInfo = pPReceiveInfo;


                if (dwRetCode = PipeRequest(
                        lpszServer,
                        (PBYTE) &PSendInfo,
                        BytesToWrite,
                        (PBYTE) pPReceiveInfo,
                        SendInfo.RcvBufSize ))
                {
                    SS_PRINT(("RasPortGetInfo: - CallNamedPipe (2) rc=%li\n",
                            dwRetCode));

                    GlobalFree(pSavePReceiveInfo);

                    return (dwRetCode);
                }

                UnpackPortInfoReceive(pPReceiveInfo, &ReceiveInfo, dwVersion);
            }
            else
            {
                GlobalFree(pPReceiveInfo);

                return (ReceiveInfo.RetCode);
            }
        }


        //
        // Ok, we have all the data.  Let's unpack it and give it to the app.
        //

        pPReceiveInfo++;

        if (dwVersion == RAS_SERVER_20)
        {
            pPReceiveInfo = (PP_PORT_INFO_RECEIVE)
                    (((PBYTE) pPReceiveInfo) - sizeof(P_PPP_PROJECTION_RESULT));
        }

        *pRasPort1 = ReceiveInfo.Data;

        NumStatistics = pRasPort1->NumStatistics;

        if (dwVersion == RAS_SERVER_20)
        {
            PRAS_PORT_0 pRasPort0 = &(pRasPort1->rasport0);

            // force these flags for a downlevel server
            // because these Flags were not available for the downlevel server.
            pRasPort0->Flags |= REMOTE_LISTEN;
            pRasPort0->Flags |= GATEWAY_ACTIVE;

            // if the downlevel server port is of type ISDN, we need to
            // bump up the number of statistics to account for
            // BYTES_XMITED_UNCOMP, BYTES_RCVED_UNCOMP, BYTES_XMITED_COMP
            // and BYTES_RCVED_COMP which was not part of the ISDN stats

            if( pRasPort0->reserved == MEDIA_ISDN)
                NumStatistics += 4;
        }

        // zero the statistics array so that unfilled array members will
        // be zero - to account for the RAS_SERVER_20 ISDN server port

        memset( pRasStats, 0, sizeof(RAS_PORT_STATISTICS));

        // note that even though we use NumStatistics to allocate memory,
        // we actually pass (*ppRasPort1)->NumStatistics to UnpackStats
        // function.  This is to ensure that we don't try to fetch data
        // past the number of statistics in the pPReceiveInfo buffer.

        UnpackStats(dwVersion, pRasPort1->NumStatistics, (PP_RAS_STATISTIC) pPReceiveInfo, pRasStats);

        NumParms = ReceiveInfo.Data.NumMediaParms;

        *ppRasParams = GlobalAlloc(GMEM_FIXED, NumParms*sizeof(RAS_PARAMETERS));
        if (!*ppRasParams)
        {
            DWORD dwErr = GetLastError();

            GlobalFree(pSavePReceiveInfo);

            return (dwErr);
        }

        pPReceiveInfo = (PP_PORT_INFO_RECEIVE) (((PBYTE) pPReceiveInfo) +
                        (pRasPort1->NumStatistics * sizeof(DWORD)));

        if (dwRetCode = UnpackParams(ReceiveInfo.Data.NumMediaParms,
                (PP_RAS_PARAMS) pPReceiveInfo, *ppRasParams))
        {
            GlobalFree(*ppRasParams);
            GlobalFree(pSavePReceiveInfo);

            return(dwRetCode);
        }


        GlobalFree(pSavePReceiveInfo);
    } // end else RASDOWNLEVEL


    // add the pointers to our list - be sure to check that we are not
    // adding a null pointer to the list.

    if ((*ppRasParams?
         insert_list_head(*ppRasParams,RASADMIN_PORT_PARAMS_PTR,NumParms):
         0))
    {
        if (RasAdminFreeBuffer(*ppRasParams))
        {
            FreeParams(*ppRasParams, NumParms);
            GlobalFree(*ppRasParams);
        }
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    return (ERROR_SUCCESS);
}

DWORD APIENTRY RasAdminPortClearStatistics(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    )
/*++

Routine Description:

    This routine clears the statistics associated with the specified
    port.

Arguments:

    lpszServer    name of the server which has the port, eg.,"\\SERVER"

    lpszPort      port name to retrieve information for, e.g. "COM1".


Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        return codes from CallNamedPipe.
        ERROR_DEV_NOT_EXIST if the specified port does not belong
                            to RAS.
--*/
{
    DWORD dwVersion;
    DWORD dwRetCode;


    ASSERT(lpszServer);
    ASSERT(lpszPort);

    // find the RasServer Version first

    if (dwRetCode = GetRasServerVersion(lpszServer, &dwVersion))
    {
        return(dwRetCode);
    }


    if (dwVersion == RASDOWNLEVEL)
    {
        struct PortClearRequestPkt SendClear;
        P_PORT_CLEAR_REQUEST_PKT PSendClear;
        struct PortClearReceivePkt ReceiveClear;
        P_PORT_CLEAR_RECEIVE_PKT PReceiveClear;

        SendClear.Request = RASADMINREQ_CLEAR_PORT_STATS;

        if((SendClear.ComId = GetPortId(lpszPort)) == -1 ) {
            return(ERROR_DEV_NOT_EXIST);
        }

        PackPortClearRequestPkt(&SendClear, &PSendClear);

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendClear,
                sizeof(PSendClear),
                (PBYTE) &PReceiveClear,
                sizeof(PReceiveClear) ))
        {
            return (dwRetCode);
        }

        UnpackPortClearReceivePkt(&PReceiveClear, &ReceiveClear);

        if (ReceiveClear.RetCode)
        {
            return(ReceiveClear.RetCode);
        }
    }
    else
    {
        // RAS 2.0 or greater

        CLIENT_REQUEST SendClear;
        P_CLIENT_REQUEST PSendClear;
        PORT_CLEAR_RECEIVE ReceiveClear;
        P_PORT_CLEAR_RECEIVE PReceiveClear;
        DWORD BytesToWrite = sizeof(PSendClear);

        SendClear.RequestCode = RASADMIN20_REQ_CLEAR_PORT_STATS;

        lstrcpy((LPTSTR) SendClear.PortName, (LPCTSTR) lpszPort);

        PackClientRequest(&SendClear, &PSendClear);

        //
        // Early versions of NT Admin do not support client version
        // number in the request, so we won't write it.
        //
        if (dwVersion == RAS_SERVER_20)
        {
            BytesToWrite -= 4;
        }

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendClear,
                BytesToWrite,
                (PBYTE) &PReceiveClear,
                sizeof(PReceiveClear) ))
        {
            return (dwRetCode);
        }

        UnpackPortClearReceive(&PReceiveClear, &ReceiveClear);

        if (ReceiveClear.RetCode)
        {
            return(ReceiveClear.RetCode);
        }
    }

    return(ERROR_SUCCESS);
}

DWORD APIENTRY RasAdminServerGetInfo(
    IN  const WCHAR * lpszServer,
    OUT PRAS_SERVER_0 pRasServer0
    )
/*++

Routine Description:

    This routine retrieves RAS specific information from the specified
    RAS server.  The server name can be NULL in which case the local
    machine is assumed.

Arguments:

    lpszServer  name of the RAS server to get information from or
                NULL for the local machine.

    pRasServer0 points to a buffer to store the returned data. On
                successful return this buffer contains a
                RAS_SERVER_0 structure.

Return Value:

    ERROR_SUCCESS on successful return.

    one of the following non-zero error codes on failure:

        error codes from CallNamedPipe.
        NERR_BufTooSmall indicating that the input buffer is smaller
        than size of RAS_SERVER_0.
--*/
{
    CLIENT_REQUEST SendInfo;
    P_CLIENT_REQUEST PSendInfo;
    SERVER_INFO_RECEIVE ReceiveInfo;
    P_SERVER_INFO_RECEIVE PReceiveInfo;
    DWORD dwRetCode;

    // zero the buffer to eliminate junk

    memset(&ReceiveInfo, '\0', sizeof(SERVER_INFO_RECEIVE));
    memset(&PReceiveInfo, '\0', sizeof(P_SERVER_INFO_RECEIVE));

    SendInfo.RequestCode = RASADMIN20_REQ_GET_SERVER_INFO;

    PackClientRequest(&SendInfo, &PSendInfo);

    if (dwRetCode = PipeRequest(
            lpszServer,
            (PBYTE) &PSendInfo,
            sizeof(PSendInfo.RequestCode),  // this sizeof VERY IMPORTANT!!!
            (PBYTE) &PReceiveInfo,
            sizeof(PReceiveInfo) ))
    {
        return (dwRetCode);
    }

    UnpackServerInfoReceive(&PReceiveInfo, &ReceiveInfo);

    if (ReceiveInfo.RetCode)
    {
        IF_DEBUG(STACK_TRACE)
            SS_PRINT(("RasAdminServerGetInfo: server return code=%li\n",
                    ReceiveInfo.RetCode));

        return (ReceiveInfo.RetCode);
    }
    else
    {
        IF_DEBUG(STACK_TRACE)
            SS_PRINT(("RasAdminServerGetInfo: #ports=%i, ports in use=%i,"
                    " version=%li\n", ReceiveInfo.Data.TotalPorts,
                    ReceiveInfo.Data.PortsInUse, ReceiveInfo.Data.RasVersion));

        memcpy(pRasServer0, &(ReceiveInfo.Data), sizeof(RAS_SERVER_0));

        return(ERROR_SUCCESS);
    }
}

DWORD APIENTRY RasAdminPortDisconnect(
    IN const WCHAR * lpszServer,
    IN const WCHAR * lpszPort
    )
/*++

Routine Description:

    This routine disconnects the user attached to the specified
    port on the server lpszServer.

Arguments:

    lpszServer  name of the RAS server.

    lpszPort    name of the port, e.g. "COM1"

Return Value:

    ERROR_SUCCESS on successful return.

    one of the following non-zero error codes on failure:

        ERROR_INVALID_PORT indicating the port name is invalid.
        error codes from CallNamedPipe.
        NERR_UserNotFound indicating that no user is logged on
        at the specified port.
--*/
{
    DWORD dwVersion;
    DWORD dwRetCode;

    ASSERT( lpszServer );
    ASSERT( lpszPort );

    // find the RasServer Version first

    if (dwRetCode = GetRasServerVersion(lpszServer, &dwVersion))
    {
        return(dwRetCode);
    }


    if (dwVersion == RASDOWNLEVEL)
    {
        struct DisconnectUserRequestPkt SendDisconnect;
        P_DISCONNECT_USER_REQUEST_PKT PSendDisconnect;
        struct DisconnectUserReceivePkt ReceiveDisconnect;
        P_DISCONNECT_USER_RECEIVE_PKT PReceiveDisconnect;

        SendDisconnect.Request = RASADMINREQ_DISCONNECT_USER;

        // get RAS 1.0 style port number from port name

        if ((SendDisconnect.ComId = GetPortId(lpszPort)) == -1 )
        {
            return(ERROR_DEV_NOT_EXIST);
        }

        PackDisconnectUserRequestPkt(&SendDisconnect, &PSendDisconnect);

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE) &PSendDisconnect,
                sizeof(PSendDisconnect),
                (PBYTE) &PReceiveDisconnect,
                sizeof(PReceiveDisconnect) ))
        {
            return (dwRetCode);
        }

        UnpackDisconnectUserReceivePkt(&PReceiveDisconnect, &ReceiveDisconnect);

        if (ReceiveDisconnect.RetCode)
        {
            return(ReceiveDisconnect.RetCode);
        }
    }
    else
    {
        // RAS 2.0 or greater

        CLIENT_REQUEST SendDisconnect;
        P_CLIENT_REQUEST PSendDisconnect;
        DISCONNECT_USER_RECEIVE ReceiveDisconnect;
        P_DISCONNECT_USER_RECEIVE PReceiveDisconnect;
        DWORD BytesToWrite = sizeof(PSendDisconnect);

        SendDisconnect.RequestCode = RASADMIN20_REQ_DISCONNECT_USER;

        lstrcpy((LPTSTR) SendDisconnect.PortName, (LPCTSTR) lpszPort);

        PackClientRequest(&SendDisconnect, &PSendDisconnect);

        //
        // Early versions of NT Admin do not support client version
        // number in the request, so we won't write it.
        //
        if (dwVersion == RAS_SERVER_20)
        {
            BytesToWrite -= 4;
        }

        if (dwRetCode = PipeRequest(
                lpszServer,
                (PBYTE)&PSendDisconnect,
                BytesToWrite,
                (PBYTE)&PReceiveDisconnect,
                sizeof(PReceiveDisconnect) ))
        {
            return (dwRetCode);
        }


        UnpackDisconnectUserReceive(&PReceiveDisconnect, &ReceiveDisconnect);

        if (ReceiveDisconnect.RetCode)
        {
            return(ReceiveDisconnect.RetCode);
        }
    }

    return(ERROR_SUCCESS);
}

DWORD RasAdminFreeBuffer(PVOID Pointer)
{
    DWORD PointerType;
    DWORD NumStructs;

    if (remove_list(Pointer, &PointerType, &NumStructs))
    {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (PointerType)
    {
        case RASADMIN_PORT_ENUM_PTR:
        case RASADMIN_PORT1_PTR:
        case RASADMIN_PORT_STATS_PTR:
            GlobalFree(Pointer);
            break;

        case RASADMIN_PORT_PARAMS_PTR:
        {
            FreeParams(Pointer, NumStructs);
            GlobalFree(Pointer);
            break;
        }


        case LANMAN_API_PTR:
            NetApiBufferFree(Pointer);
            break;


        default:
            SS_ASSERT(TRUE);
            break;
    }

    return (ERROR_SUCCESS);
}

VOID FreeParams(PVOID Pointer, DWORD NumParms)
{
    DWORD i;

    for (i=0; i<NumParms; i++)
    {
        if (((RAS_PARAMETERS *) Pointer)[i].P_Type == ParamString)
        {
            GlobalFree(((RAS_PARAMETERS *) Pointer)[i].P_Value.String.Data);
        }
    }
}


VOID BuildPipeName(
    IN const WCHAR * lpszServer,
    OUT LPWSTR lpszPipeName
    )
/*++

Routine Description:

    This routine creates the full UNC path name of the pipe from
    the server name specified in lpszServer and returns it in
    lpszPipeName

Return Value:

    NONE
--*/
{
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cbComputerNameLen = MAX_COMPUTERNAME_LENGTH+1;

    GET_CONSOLE;    // for debugging

    // adminstrating a remote server

    if ((lpszServer) && (*lpszServer))
    {
       // If the specified server name is the same as the local server name, then
       // use the LOCAL_PIPE name. This is an optimization.
       if(GetComputerName(szComputerName, &cbComputerNameLen))
       {
           CHAR szServer[MAX_COMPUTERNAME_LENGTH+3];
           CHAR szComputer[MAX_COMPUTERNAME_LENGTH+1];

           // need to handle extended characters in the computer name here
           // OemToCharW is not returning a unicode string, so we have to
           // do the conversion ourselves ;-(

           wcstombs(szServer, lpszServer, MAX_COMPUTERNAME_LENGTH+3);
           OemToCharA(szServer, szServer);

           wcstombs(szComputer, szComputerName, MAX_COMPUTERNAME_LENGTH+1);
           OemToCharA(szComputer, szComputer);

           // +2 accounts for the leading \\ characters
           if(!_stricmp(szServer+2, szComputer))
           {
               // the computer name specified is the same as the local
               // computer name. Use the LOCAL_PIPE name.

               lstrcpy((LPTSTR) lpszPipeName, LOCAL_PIPE);
           }

           else
               lstrcpy((LPTSTR) lpszPipeName, (LPCTSTR) lpszServer);
       }
    }
    else
    {
        // local machine is the server
        lstrcpy((LPTSTR) lpszPipeName, LOCAL_PIPE);
    }

    lstrcat((LPTSTR) lpszPipeName, RASADMIN_PIPE);
    return;
}

DWORD GetRasServerVersion(
    IN const WCHAR * lpszServerName,
    OUT DWORD *pdwVersion
    )
/*++

Routine Description:

    This routine obtains the RAS version number from the server.

    The RAS 2.0 server info structure is a superset of the
    RAS 1.0 structure. So, we send a server info request to the
    RAS server with a zeroed RAS 2.0 structure.  If we get back
    a non-zero version number we assume the server is a RAS 2.0
    and greater server, else the server is 1.0.

Parameters:

    lpszServerName - name of the server whose version number
                     is required.

    pdwVersion     - pointer to the variable to receive the
                     version number. We return the version number
                     if the server is a RAS 2.0 or greater server
                     else RASDOWNLEVEL to indicate a RAS 1.0 server.
Return Value:

    ERROR_SUCCESS on successful execution.

    one of the following non-zero error codes on failure:

        error codes from RasAdminServerGetInfo

--*/
{
    RAS_SERVER_0 ServerInfo;
    NET_API_STATUS dwRetCode;

    ASSERT( lpszServerName );

    // zero the structure to make sure we have no garbage

    memset(&ServerInfo, '\0', sizeof(RAS_SERVER_0));

    if (dwRetCode = RasAdminServerGetInfo(lpszServerName, &ServerInfo))
    {
        IF_DEBUG(STACK_TRACE)
            SS_PRINT(("GetRasServerVersion: dwRetCode = %lx\n", dwRetCode));

        return (dwRetCode);
    }
    else
    {
        if (ServerInfo.RasVersion)
        {
            *pdwVersion = ServerInfo.RasVersion;
        }
        else
        {
            *pdwVersion = RASDOWNLEVEL;
        }
    }

    return (ERROR_SUCCESS);
}

SHORT GetPortId(
    IN  const WCHAR * lpszPort
    )
/*++

Routine Description:

    This routine converts the RAS 2.0 style port name to RAS 1.0
    style Port ID. Valid Port names are "COM1" - "COM16"

Parameters:

    lpszPort - name of the port

Return Value:

    returns the Port number equivalent to the port name or
    -1 on error.

--*/

{
    CHAR PortName[RASSAPI_MAX_PORT_NAME+1];

    ASSERT( lpszPort );

    wcstombs(PortName, lpszPort, RASSAPI_MAX_PORT_NAME);

    if (_strnicmp(PortName, "COM", 3))
    {
        return (-1);
    }

    return ((USHORT)atoi(PortName+3));
}

VOID GetPortName(
    IN USHORT PortId,
    OUT LPWSTR PortName
    )
/*++

Routine Description:

    This routine converts the RAS 1.0 style port ID to RAS 2.0
    style Port name. Valid Port ID's are 1 to 16.

Parameters:

    PortId   - COM port number.

    PortName -  returns the Port name equivalent of the Port number.
                i.e., returns "COM1" if PortId is 1, "COM2" if 2
                and so on.

Return Value:

    NONE

--*/
{
    CHAR buffer[3];   // port ID can be a max of 16 so 3 bytes should suffice
    WCHAR wcbuffer[3];   // port ID can be a max of 16 so 3 bytes should suffice

    lstrcpy((LPTSTR) PortName, TEXT("COM"));

    // convert port ID to string

    _itoa(PortId, buffer, 10);

    mbstowcs(wcbuffer, buffer, sizeof(wcbuffer)/sizeof(WCHAR));

    lstrcat((LPTSTR) PortName, (LPCTSTR) wcbuffer);
}

DWORD PipeRequest(
    const WCHAR * Server,
    PBYTE Request,
    DWORD SizeOfRequest,
    PBYTE Response,
    DWORD SizeOfResponse
    )
{
    DWORD i;
    DWORD dwRetCode = 1L;
    DWORD BytesRead;
    WCHAR PipePath[PATHLEN+1];

    //
    // build pipe name from the given server name
    //
    wcscpy(PipePath, L"");
    BuildPipeName(Server, PipePath);

    IF_DEBUG(STACK_TRACE)
        SS_PRINT(("PipeRequest: PipeName is %ws\n", PipePath));

    for (i=0; i<NUM_PIPE_TRIES; i++)
    {
        DWORD Ticker = GetTickCount();

        if (CallNamedPipe(PipePath, Request, SizeOfRequest, Response,
                SizeOfResponse, &BytesRead, NMPWAIT_NOWAIT))
        {
            return (0L);
        }
        else
            dwRetCode = GetLastError();

        // wait for a while before attempting to connect to the pipe again.

        Sleep(250);

        SS_PRINT(("Time (in msec) for CallNamedPipe to complete: %li\n",
                GetTickCount() - Ticker));
    }

    return (dwRetCode);
}

VOID PackClientRequest(
    IN PCLIENT_REQUEST Request,
    OUT PP_CLIENT_REQUEST PRequest
    )
{
    int i;

    PUTUSHORT(PRequest->RequestCode, Request->RequestCode);

    for (i=0; i<RASSAPI_MAX_PORT_NAME; i++)
    {
        PUTUSHORT(&PRequest->PortName[i*2], Request->PortName[i]);
    }

    PUTULONG(PRequest->RcvBufSize, Request->RcvBufSize);
    // identify our version so the server knows what information to pass back
    PUTULONG(PRequest->ClientVersion, RASADMIN_CURRENT);
}

VOID
PackResumeRequest(
    IN PCLIENT_REQUEST Request,
    OUT PP_CLIENT_REQUEST PRequest,
    IN USHORT ResumePort)
{
    PUTUSHORT(PRequest->RequestCode, Request->RequestCode);

    // use the unused port name field to send the resume port number to
    // the server.
    PUTUSHORT(&PRequest->PortName[0], ResumePort);

    PUTULONG(PRequest->RcvBufSize, Request->RcvBufSize);
    // identify our version so the server knows what information to pass back
    PUTULONG(PRequest->ClientVersion, RASADMIN_CURRENT);
}

VOID UnpackRasPort0(
    IN PP_RAS_PORT_0 pprp0,
    OUT PRAS_PORT_0 prp0
    )
{
    int i;

    for (i = 0; i < RASSAPI_MAX_PORT_NAME; i++)
    {
        GETUSHORT(&prp0->wszPortName[i], &pprp0->wszPortName[i*2]);
    }

    for (i = 0; i < RASSAPI_MAX_DEVICETYPE_NAME; i++)
    {
        GETUSHORT(&prp0->wszDeviceType[i], &pprp0->wszDeviceType[i*2]);
    }

    for (i = 0; i < RASSAPI_MAX_DEVICE_NAME; i++)
    {
        GETUSHORT(&prp0->wszDeviceName[i], &pprp0->wszDeviceName[i*2]);
    }

    for (i = 0; i < RASSAPI_MAX_MEDIA_NAME; i++)
    {
        GETUSHORT(&prp0->wszMediaName[i], &pprp0->wszMediaName[i*2]);
    }

    GETULONG(&prp0->reserved, pprp0->reserved);

    GETULONG(&prp0->Flags, pprp0->Flags);

    for (i = 0; i < (UNLEN + 1); i++)
    {
        GETUSHORT(&prp0->wszUserName[i], &pprp0->wszUserName[i*2]);
    }

    for (i = 0; i < (DNLEN + 1); i++)
    {
        GETUSHORT(&prp0->wszLogonDomain[i], &pprp0->wszLogonDomain[i*2]);
    }

    for (i = 0; i < NETBIOS_NAME_LEN; i++)
    {
        GETUSHORT(&prp0->wszComputer[i], &pprp0->wszComputer[i*2]);
    }

    GETULONG(&prp0->dwStartSessionTime, pprp0->dwStartSessionTime);

    GETULONG(&prp0->fAdvancedServer, pprp0->fAdvancedServer);
}


VOID UnpackRasPort1(
    IN PP_RAS_PORT_1 pprp1,
    OUT PRAS_PORT_1 prp1,
    DWORD dwServerVersion
    )
{
    DWORD i;

    UnpackRasPort0(&pprp1->rasport0, &prp1->rasport0);

    GETULONG(&prp1->LineCondition, pprp1->LineCondition);
    GETULONG(&prp1->HardwareCondition, pprp1->HardwareCondition);

    GETULONG(&prp1->LineSpeed, pprp1->LineSpeed);
    GETUSHORT(&prp1->NumStatistics, pprp1->NumStatistics);
    GETUSHORT(&prp1->NumMediaParms, pprp1->NumMediaParms);
    GETULONG(&prp1->SizeMediaParms, pprp1->SizeMediaParms);

    if ((dwServerVersion == RAS_SERVER_20) ||
            (!(prp1->rasport0.Flags & PPP_CLIENT)))
    {
        if (prp1->rasport0.Flags & USER_AUTHENTICATED)
        {
            prp1->ProjResult.nbf.dwError = SUCCESS;
            prp1->ProjResult.nbf.dwNetBiosError = 0;

            lstrcpy((LPTSTR) prp1->ProjResult.nbf.wszWksta,
                    (LPTSTR) prp1->rasport0.wszComputer);
        }
        else
        {
            prp1->ProjResult.nbf.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
        }

        prp1->ProjResult.ip.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
        prp1->ProjResult.ipx.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
        prp1->ProjResult.at.dwError = ERROR_PPP_NO_PROTOCOLS_CONFIGURED;
    }
    else
    {
        GETULONG(&prp1->ProjResult.nbf.dwError, pprp1->ProjResult.nbf.dwError);
        GETULONG(&prp1->ProjResult.nbf.dwNetBiosError,
                pprp1->ProjResult.nbf.dwNetBiosError);

        memcpy(prp1->ProjResult.nbf.szName, pprp1->ProjResult.nbf.szName,
                NETBIOS_NAME_LEN+1);

        for (i=0; i<NETBIOS_NAME_LEN+1; i++)
        {
            GETUSHORT(&prp1->ProjResult.nbf.wszWksta[i],
                &pprp1->ProjResult.nbf.wszWksta[i*2]);
        }

        GETULONG(&prp1->ProjResult.ip.dwError, pprp1->ProjResult.ip.dwError);

        for (i=0; i<RAS_IPADDRESSLEN+1; i++)
        {
            GETUSHORT(&prp1->ProjResult.ip.wszAddress[i],
                &pprp1->ProjResult.ip.wszAddress[i*2]);
        }

        /* The server's IP address is not part of the RASADMIN protocol,
        ** though the PPP engine now reports this for servers that provide it.
        ** Avoid reporting garbage, just in case.
        */

/*      Since we are exposing RAS server side APIs to 3rd parties, let us
**      not expose this field that is not set for the server side. We did
**      this because we don't want to break compatibility with older version
**      of rasadmin
**
**      prp1->ProjResult.ip.wszServerAddress[ 0 ] = L'\0';
*/

        GETULONG(&prp1->ProjResult.ipx.dwError, pprp1->ProjResult.ipx.dwError);

        for (i=0; i<RAS_IPXADDRESSLEN+1; i++)
        {
            GETUSHORT(&prp1->ProjResult.ipx.wszAddress[i],
                &pprp1->ProjResult.ipx.wszAddress[i*2]);
        }

        GETULONG(&prp1->ProjResult.at.dwError, pprp1->ProjResult.at.dwError);

        for (i=0; i<RAS_ATADDRESSLEN+1; i++)
        {
            GETUSHORT(&prp1->ProjResult.at.wszAddress[i],
                &pprp1->ProjResult.at.wszAddress[i*2]);
        }
    }

    return;
}


VOID UnpackRasServer0(
    IN PP_RAS_SERVER_0 pprs0,
    OUT PRAS_SERVER_0 prs0
    )
{
    GETUSHORT(&prs0->TotalPorts, pprs0->TotalPorts);
    GETUSHORT(&prs0->PortsInUse, pprs0->PortsInUse);
    GETULONG(&prs0->RasVersion, pprs0->RasVersion);
}


DWORD UnpackPortEnumReceive(
    IN PP_PORT_ENUM_RECEIVE ppper,
    OUT PPORT_ENUM_RECEIVE pper
    )
{
    GETULONG(&pper->RetCode, ppper->RetCode);
    GETUSHORT(&pper->TotalAvail, ppper->TotalAvail);

    if (!pper->RetCode || pper->RetCode == ERROR_MORE_DATA)
    {
        WORD i;

        //
        // Get some memory for the port structures
        //
        hmem = GlobalAlloc(GMEM_MOVEABLE,
                           sizeof(RAS_PORT_0) * pper->TotalAvail);
        if (!hmem)
        {
            return (GetLastError());
        }

        pper->Data = (RAS_PORT_0 *)GlobalLock(hmem);
        if (!pper->Data)
        {
            return (GetLastError());
        }

        for (i=0; i<pper->TotalAvail; i++)
        {
            UnpackRasPort0(&ppper->Data[i], &pper->Data[i]);
        }

        GlobalUnlock(hmem);
    }

    return (0L);
}

DWORD UnpackResumeEnumReceive(
    IN PP_PORT_ENUM_RECEIVE ppper,
    OUT PPORT_ENUM_RECEIVE pper,
    IN USHORT ResumePort
    )
{
    GETULONG(&pper->RetCode, ppper->RetCode);
    GETUSHORT(&pper->TotalAvail, ppper->TotalAvail);

    if (!pper->RetCode || pper->RetCode == ERROR_MORE_DATA)
    {
        WORD i;

        //
        // Reallocate memory for the port structures
        //
        hnewmem = GlobalReAlloc(hmem,
                                sizeof(RAS_PORT_0) *
                                (pper->TotalAvail + ResumePort),
                                GMEM_MOVEABLE);
        if (!hnewmem)
        {
            return (GetLastError());
        }
        hmem = hnewmem;

        pper->Data = (RAS_PORT_0 *)GlobalLock(hmem);

        if (!pper->Data)
        {
            return (GetLastError());
        }

        pper->Data += ResumePort;

        for (i=0; i<pper->TotalAvail; i++)
        {
            UnpackRasPort0(&ppper->Data[i], &pper->Data[i]);
        }

        GlobalUnlock(hmem);
    }

    return (0L);
}


VOID UnpackServerInfoReceive(
    IN PP_SERVER_INFO_RECEIVE ppsir,
    OUT PSERVER_INFO_RECEIVE psir
    )
{
    GETUSHORT(&psir->RetCode, ppsir->RetCode);

    UnpackRasServer0(&ppsir->Data, &psir->Data);
}


VOID UnpackPortClearReceive(
    IN PP_PORT_CLEAR_RECEIVE pppcr,
    OUT PPORT_CLEAR_RECEIVE ppcr
    )
{
    GETULONG(&ppcr->RetCode, pppcr->RetCode);
}



VOID UnpackDisconnectUserReceive(
    IN PP_DISCONNECT_USER_RECEIVE ppdur,
    OUT PDISCONNECT_USER_RECEIVE pdur
    )
{
    GETULONG(&pdur->RetCode, ppdur->RetCode);
}


VOID UnpackPortInfoReceive(
    IN PP_PORT_INFO_RECEIVE pppir,
    OUT PPORT_INFO_RECEIVE ppir,
    DWORD dwServerVersion
    )
{
    GETULONG(&ppir->RetCode, pppir->RetCode);
    GETULONG(&ppir->ReqBufSize, pppir->ReqBufSize);

    if (!ppir->RetCode)
    {
        UnpackRasPort1(&pppir->Data, &ppir->Data, dwServerVersion);
    }
}


VOID UnpackStats(
    IN DWORD dwVersion,
    IN WORD NumStats,
    IN PP_RAS_STATISTIC PStats,
    OUT PRAS_PORT_STATISTICS Stats
    )
{
    WORD i;

    PDWORD pdw   = (PDWORD) Stats;
    PDWORD pdwIn = (PDWORD) PStats;

    for (i=0; i<NumStats; i++, PStats++)
    {
        GETULONG(&pdw[i], PStats->Stat);
    }

    // NT 3.5x version didn't report both bundle and link stats, so
    // we just copy the bundle stats as link stats.

    PStats = (PP_RAS_STATISTIC) pdwIn;

    if (dwVersion <= RASADMIN_35) {
       for (i=NumStats; i<(NumStats*2); i++, PStats++)
       {
           GETULONG(&pdw[i], PStats->Stat);
       }

    }

    return;
}


DWORD UnpackParams(
    IN WORD NumOfParams,
    IN PP_RAS_PARAMS PParams,
    OUT RAS_PARAMETERS *Params
    )
{
    WORD i;
    RAS_PARAMETERS *TempParams = Params;
    PBYTE PParamData = (PBYTE) (PParams + NumOfParams);

    for (i=0; i<NumOfParams; i++, Params++, PParams++)
    {
        //
        // P_Key field
        //
        memcpy(Params->P_Key, PParams->P_Key, RASSAPI_MAX_PARAM_KEY_SIZE);

        //
        // P_Type field
        //
        GETULONG(&Params->P_Type, PParams->P_Type.Format);

        //
        // P_Attribute field
        //
        Params->P_Attributes = PParams->P_Attributes;


        //
        // P_Value field
        //
        if (Params->P_Type == ParamNumber)
        {
            //
            // Union member Number
            //
            GETULONG(&Params->P_Value.Number, PParams->P_Value.Number);
        }
        else
        {
            //
            // Union member String
            //
            GETULONG(&Params->P_Value.String.Length,
                    PParams->P_Value.String.Length);

            Params->P_Value.String.Data = GlobalAlloc(GMEM_FIXED,
                    Params->P_Value.String.Length);

            if (!Params->P_Value.String.Data)
            {
                WORD k;
                DWORD dwErr = GetLastError();

                //
                // Start deallocating mem for any previously allocated param
                //
                for (k=i, Params--; k>0; k--, Params--)
                {
                    if (Params->P_Type == ParamString)
                    {
                        GlobalFree(Params->P_Value.String.Data);
                    }
                }

                return (dwErr);
            }

            memcpy(Params->P_Value.String.Data, PParamData,
                    Params->P_Value.String.Length);

            PParamData += Params->P_Value.String.Length;
        }
    }

    return(0L);
}


VOID UnpackWpdStatistics(
    IN PP_WPD_STATISTICS_INFO PWpdStats,
    OUT WpdStatisticsInfo *WpdStats
    )
{
    GETULONG(&WpdStats->stat_bytesreceived, PWpdStats->stat_bytesreceived);
    GETULONG(&WpdStats->stat_bytesxmitted, PWpdStats->stat_bytesxmitted);
    GETUSHORT(&WpdStats->stat_overrunerr, PWpdStats->stat_overrunerr);
    GETUSHORT(&WpdStats->stat_timeouterr, PWpdStats->stat_timeouterr);
    GETUSHORT(&WpdStats->stat_framingerr, PWpdStats->stat_framingerr);
    GETUSHORT(&WpdStats->stat_crcerr, PWpdStats->stat_crcerr);

    return;
}


VOID UnpackDialinPortInfo0(
    IN PP_DIALIN_PORT_INFO_0 PPortInfo0,
    struct dialin_port_info_0 *PortInfo0
    )
{
    memcpy(PortInfo0->dporti0_username, PPortInfo0->dporti0_username,
            LM20_UNLEN+1);

    memcpy(PortInfo0->dporti0_computer, PPortInfo0->dporti0_computer,
            NETBIOS_NAME_LEN);

    GETUSHORT(&PortInfo0->dporti0_comid, PPortInfo0->dporti0_comid);

    GETULONG(&PortInfo0->dporti0_time, PPortInfo0->dporti0_time);

    GETUSHORT(&PortInfo0->dporti0_line_condition,
            PPortInfo0->dporti0_line_condition);

    GETUSHORT(&PortInfo0->dporti0_modem_condition,
            PPortInfo0->dporti0_modem_condition);

    return;
}


VOID UnpackDialinPortInfo1(
    IN PP_DIALIN_PORT_INFO_1 PPortInfo1,
    struct dialin_port_info_1 *PortInfo1
    )
{
    UnpackDialinPortInfo0(&PPortInfo1->dporti0, &PortInfo1->dporti0);

    GETULONG(&PortInfo1->dporti1_baud, PPortInfo1->dporti1_baud);

    UnpackWpdStatistics(&PPortInfo1->dporti1_stats, &PortInfo1->dporti1_stats);

    return;
}


VOID UnpackDialinServerInfo0(
        IN PP_DIALIN_SERVER_INFO_0 PServerInfo0,
        OUT struct dialin_server_info_0 *ServerInfo0
    )
{
    GETUSHORT(&ServerInfo0->dserveri0_total_ports,
            PServerInfo0->dserveri0_total_ports);

    GETUSHORT(&ServerInfo0->dserveri0_ports_in_use,
            PServerInfo0->dserveri0_ports_in_use);

    return;
}



VOID UnpackPortEnumReceivePkt(
    IN PP_PORT_ENUM_RECEIVE_PKT PEnumRecv,
    OUT struct PortEnumReceivePkt *EnumRecv
    )
{
    WORD i;

    GETUSHORT(&EnumRecv->RetCode, PEnumRecv->RetCode);
    GETUSHORT(&EnumRecv->TotalAvail, PEnumRecv->TotalAvail);

    for (i=0; i<EnumRecv->TotalAvail; i++)
    {
        UnpackDialinPortInfo0(&PEnumRecv->Data[i], &EnumRecv->Data[i]);
    }

    return;
}


VOID UnpackDisconnectUserReceivePkt(
    IN PP_DISCONNECT_USER_RECEIVE_PKT PDisconnectUser,
    OUT struct DisconnectUserReceivePkt *DisconnectUser
    )
{
    GETUSHORT(&DisconnectUser->RetCode, PDisconnectUser->RetCode);

    return;
}


VOID UnpackPortClearReceivePkt(
    IN PP_PORT_CLEAR_RECEIVE_PKT PClearRecv,
    OUT struct PortClearReceivePkt *ClearRecv
    )
{
    GETUSHORT(&ClearRecv->RetCode, PClearRecv->RetCode);

    return;
}


VOID UnpackServerInfoReceivePkt(
    IN PP_SERVER_INFO_RECEIVE_PKT PInfoRecv,
    OUT struct ServerInfoReceivePkt *InfoRecv
    )
{
    GETUSHORT(&InfoRecv->RetCode, PInfoRecv->RetCode);

    UnpackDialinServerInfo0(&PInfoRecv->Data, &InfoRecv->Data);

    return;
}


VOID UnpackPortInfoReceivePkt(
    IN PP_PORT_INFO_RECEIVE_PKT PInfoRecv,
    struct PortInfoReceivePkt *InfoRecv
    )
{
    GETUSHORT(&InfoRecv->RetCode, PInfoRecv->RetCode);

    UnpackDialinPortInfo1(&PInfoRecv->Data, &InfoRecv->Data);

    return;
}


VOID PackPortEnumRequestPkt(
    IN struct PortEnumRequestPkt *EnumReq,
    OUT PP_PORT_ENUM_REQUEST_PKT PEnumReq
    )
{
    PUTUSHORT(PEnumReq->Request, EnumReq->Request);

    return;
}


VOID PackDisconnectUserRequestPkt(
    IN struct DisconnectUserRequestPkt *DisconnectReq,
    OUT PP_DISCONNECT_USER_REQUEST_PKT PDisconnectReq
    )
{
    PUTUSHORT(PDisconnectReq->Request, DisconnectReq->Request);
    PUTUSHORT(PDisconnectReq->ComId, DisconnectReq->ComId);

    return;
}


VOID PackPortClearRequestPkt(
    IN struct PortClearRequestPkt *ClearReq,
    OUT PP_PORT_CLEAR_REQUEST_PKT PClearReq
    )
{
    PUTUSHORT(PClearReq->Request, ClearReq->Request);
    PUTUSHORT(PClearReq->ComId, ClearReq->ComId);

    return;
}


VOID PackServerInfoRequestPkt(
    IN struct ServerInfoRequestPkt *InfoReq,
    OUT PP_SERVER_INFO_REQUEST_PKT PInfoReq
    )
{
    PUTUSHORT(PInfoReq->Request, InfoReq->Request);

    return;
}


VOID PackPortInfoRequestPkt(
    IN struct PortInfoRequestPkt *InfoReq,
    OUT PP_PORT_INFO_REQUEST_PKT PInfoReq
    )
{
    PUTUSHORT(PInfoReq->Request, InfoReq->Request);
    PUTUSHORT(PInfoReq->ComId, InfoReq->ComId);

    return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\userapi.c ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*++

Module Name:

    USERAPI.C


Description:

    This module contains code for all the RASADMIN APIs
    that require RAS information from the UAS.

//     RasAdminUserEnum
     RasAdminGetUserAccountServer
     RasAdminUserSetInfo
     RasAdminUserGetInfo
     RasAdminGetErrorString

Author:

    Janakiram Cherala (RamC)    July 6,1992

Revision History:

    Feb  1,1996    RamC    Changes to export these APIs to 3rd parties. These APIs
                           are now part of RASSAPI.DLL. Added a couple new routines
                           and renamed some. RasAdminUserEnum is not exported any more.
    June 8,1993    RamC    Changes to RasAdminUserEnum to speed up user enumeration.
    May 13,1993    AndyHe  Modified to coexist with other apps using user parms

    Mar 16,1993    RamC    Change to speed up User enumeration. Now, when
                           RasAdminUserEnum is invoked, only the user name
                           information is returned. RasAdminUserGetInfo should
                           be invoked to get the Ras permissions and Callback
                           information.

    Aug 25,1992    RamC    Code review changes:

                           o changed all lpbBuffers to actual structure
                             pointers.
                           o changed all LPTSTR to LPWSTR
                           o Added a new function RasPrivilegeAndCallBackNumber
    July 6,1992    RamC    Begun porting from RAS 1.0 (Original version
                           written by Narendra Gidwani - nareng)

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <windows.h>
#include <lm.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <malloc.h>
#include <raserror.h>
#include <rassapi.h>
#include <rassapip.h>
#include <util.h>         // for Compress & Decompress fns.
#include <usrparms.h>     // for UP_CLIENT_DIAL
#include <dsgetdc.h>
#include "sdebug.h"       // this is required for the global alloc/free wrapper


DWORD APIENTRY
MprAdminUserGetInfo(
    IN      const WCHAR *           lpszServer,
    IN      const WCHAR *           lpszUser,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE                  lpbBuffer
);


DWORD APIENTRY
MprAdminUserSetInfo(
    IN      const WCHAR *           lpszServer,
    IN      const WCHAR *           lpszUser,
    IN      DWORD                   dwLevel,
    IN      const LPBYTE            lpbBuffer
);

// constants used to increase the number of users enumerated.

#define USERS_INITIAL_COUNT  0x00200    // 512
#define USERS_MAX_COUNT      0X01000    // 4 K

#define BYTES_INITIAL_COUNT  0x03FFF    // 16 K
#define BYTES_MAX_COUNT      0x1FFFF    // 128 K

/* Forward declarations of private functions */

BOOL CheckIfNT(const WCHAR * lpszServer);
VOID ConvertUnicodeStringToWcs(WCHAR *szUserName, PUNICODE_STRING pUnicode);

DWORD GetAccountDomain( PUNICODE_STRING Server,PUNICODE_STRING Domain);
NTSTATUS OpenLsa(PUNICODE_STRING pSystem, PLSA_HANDLE phLsa );

#if 0

DWORD APIENTRY
RasAdminUserEnum(
    IN  const WCHAR *      lpszServer,
    OUT       RAS_USER_1  **ppRasUser1,
    OUT       DWORD*      pcEntriesRead
    )
/*++

Routine Description:

    This routine enumerates all the users in the user database for
    a particular server.

Arguments:

    lpszServer      name of the server which has the user database,
                    eg., "\\\\UASSRVR" (the server must be one on which
                    the UAS can be changed i.e., the name returned by
                    RasAdminGetUserAccountServer).

    ppRasUser1      pointer to a pointer to a buffer in which user information
                    is returned.  The returned info is an array of
                    RAS_USER_1 structures. This routine allocates the buffer.
                    Invoke the RasAdminBufferFree routine to free the allocated
                    memory.

                    NOTE: We only return the user name information, though
                    we continue to return an array of RAS_USER_1 structures.
                    This was done for speeding up user enumeration. Call
                    RasAdminUserGetInfo to get Ras Access and Callback info
                    for the required user.

    pcEntriesRead   The number of users enumerated is returned via this
                    pointer. It is valid only if the return value is
                    either ERROR_SUCCESS or ERROR_MORE_DATA.
Return Value:

    ERROR_SUCCESS if successful

    One of the following non-zero error codes indicating failure:

        error codes from NetUserEnum indicating failure.

        ERROR_NOT_ENOUGH_MEMORY indicating insert_list_head failed due to
        lack of memory.
Revision History:

    June 5 1993    RamC   Changed the routine to allocate memory on behalf
                          of the caller and eliminated some parameters.

    Feb 18,1993    RamC   changed the cbUserInfo calculation to include
                          Max of two buffers to make sure we have enough
                          space for the number of users.

                          Commented out printing names - should speed up
                          name enumeration.
--*/
{
    PUSER_INFO_1 pUserInfo;
    PUSER_INFO_1 pUserInfoPtr;
    DWORD dwIndex;
    NET_API_STATUS dwRetCode;
    NTSTATUS       Status = 0;
    BOOL bMoreData = FALSE;

    DWORD cHandle = 0;
    DWORD cEntriesRead = 0;
    DWORD cTotalAvail  = 0;
    RAS_USER_1 * pRasUser1Ptr;
    HANDLE hmem, hnewmem;

    // nothing read yet

    *pcEntriesRead = 0;

    // we first allocate 1 byte and then resize the buffer to fit the
    // number of entries read. We could have allocated 0 bytes, but when
    // the GMEM_MOVEABLE flag is specified, the block of memory is marked
    // as discarded and we can't lock the memory block nor can we resize it.

    hmem = GlobalAlloc(GMEM_MOVEABLE, 1);

    if(!hmem)
    {
        DbgPrint("Could not allocate memory for *ppRasUser1.\n");
        return GetLastError();
    }

    *ppRasUser1 = (RAS_USER_1*) GlobalLock(hmem);
    if(!*ppRasUser1)
    {
        DbgPrint("Could not lock memory segment for *ppRasUser1.\n");
        return GetLastError();
    }

    if (!CheckIfNT(lpszServer))
    {
        while(1)
        {
            bMoreData = FALSE;

            if( dwRetCode = NetUserEnum((WCHAR *)lpszServer,
                                    1,                        // info level
                                    FILTER_NORMAL_ACCOUNT,
                                    (LPBYTE *)&pUserInfo,     // buffer
                                    (DWORD)-1,                // prefered max len
                                    &cEntriesRead,
                                    &cTotalAvail,
                                    &cHandle                  // resume handle
                                    ))
            {

                if ( dwRetCode != ERROR_MORE_DATA)
                {
                    DbgPrint("RasAdminUserEnum: NetUserEnum error %d\n", dwRetCode);
                    return( dwRetCode);
                }
                bMoreData = TRUE;
            }

            GlobalUnlock(hmem);

            hnewmem = GlobalReAlloc(hmem,
                                    ((*pcEntriesRead) + cEntriesRead) *
                                    sizeof(RAS_USER_1),
                                    GMEM_MOVEABLE);
            if(!hnewmem)
            {
                DWORD LastError = GetLastError();
                DbgPrint("Could not reallocate memory for *ppRasUser1.\n");
                return (LastError);
            }

            hmem = hnewmem;
            *ppRasUser1 = (RAS_USER_1*) GlobalLock(hmem);

            if(!*ppRasUser1)
            {
                DWORD LastError = GetLastError();

                DbgPrint("Could not reallocate memory for *ppRasUser1.\n");
                if( pUserInfo )
                    NetApiBufferFree(pUserInfo);
                return (LastError);
            }

            pRasUser1Ptr = (*ppRasUser1) + (*pcEntriesRead);

            (*pcEntriesRead) += cEntriesRead;

            for(dwIndex = cEntriesRead, pUserInfoPtr = pUserInfo;

                  dwIndex > 0;

                  pRasUser1Ptr++, pUserInfoPtr++, dwIndex-- )
           {
               memset(&(pRasUser1Ptr->rasuser0), '\0', sizeof(RAS_USER_0));

               pRasUser1Ptr->szUser = (WCHAR*)
                                      GlobalAlloc(GMEM_FIXED,
                                               sizeof(TCHAR) *
                                               lstrlen(pUserInfoPtr->usri1_name)+
                                               sizeof(TCHAR));
               if( !pRasUser1Ptr->szUser)
               {
                   NetApiBufferFree(pUserInfo);
                   GlobalUnlock(hmem);
                   GlobalFree(hmem);
                   return GetLastError();
               }

               lstrcpy((LPTSTR) pRasUser1Ptr->szUser, (LPCTSTR) pUserInfoPtr->usri1_name);
           }
           if( pUserInfo)
               NetApiBufferFree(pUserInfo);

           if(!bMoreData)
               break;
        }
    }
    else           // this is an NT server - use SAM calls
    {
        DWORD                       err;
        OBJECT_ATTRIBUTES           ObjectAttributes;
        SECURITY_QUALITY_OF_SERVICE SecurityQos;
        SAM_HANDLE                  SamHandle = NULL;
        SAM_HANDLE                  DomainHandle = NULL;
        UNICODE_STRING              Domain;
        UNICODE_STRING              Server;
        PSID                        DomainSid = NULL;
        UINT                        cUsersPerRequest;
        ULONG                       cbBytesRequested;

        ULONG TotalAvailable, TotalReturned, i;
        PDOMAIN_DISPLAY_USER SortedUsers;

        //
        // Setup ObjectAttributes for SamConnect call.
        //

        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
        ObjectAttributes.SecurityQualityOfService = &SecurityQos;

        SecurityQos.Length = sizeof(SecurityQos);
        SecurityQos.ImpersonationLevel = SecurityIdentification;
        SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
        SecurityQos.EffectiveOnly = FALSE;

        RtlInitUnicodeString(&Server, lpszServer);

        Status = SamConnect(
                     &Server,
                     &SamHandle,
                     GENERIC_EXECUTE,
                     &ObjectAttributes
                     );

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("SamConnect failed, status %8.8x\n", Status);
            goto Cleanup;
        }

        if(err = GetAccountDomain(&Server, &Domain))
        {
            DbgPrint("GetAccountDomain failed, status %d\n", err);
            goto Cleanup;
        }

        Status = SamLookupDomainInSamServer(
                     SamHandle,
                     &Domain,
                     &DomainSid
                     );

        free(Domain.Buffer);

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("Cannot find account domain, status %8.8x\n", Status);
            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            goto Cleanup;
        }

        Status = SamOpenDomain(
                     SamHandle,
                     GENERIC_EXECUTE,
                     DomainSid,
                     &DomainHandle
                     );

        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("Cannot open account domain, status %8.8x\n", Status);
            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            goto Cleanup;
        }

        cUsersPerRequest = USERS_INITIAL_COUNT;
        cbBytesRequested = BYTES_INITIAL_COUNT;

        while(1)
        {
            bMoreData = FALSE;
            Status =  SamQueryDisplayInformation (
                          DomainHandle,
                          DomainDisplayUser,
                          cHandle,                         //Index
                          cUsersPerRequest,
                          cbBytesRequested,
                          &TotalAvailable,
                          &TotalReturned,
                          &cEntriesRead,
                          (PVOID*)&SortedUsers
                          );

            // increment the index to take care of the entries read

            cHandle += cEntriesRead;

            // increase the request size

            cUsersPerRequest *= 2;
            if(cUsersPerRequest > USERS_MAX_COUNT)
                cUsersPerRequest = USERS_MAX_COUNT;

            cbBytesRequested *= 2;
            if(cbBytesRequested > BYTES_MAX_COUNT)
                cbBytesRequested = BYTES_MAX_COUNT;

            if(Status == STATUS_MORE_ENTRIES)
                 bMoreData = TRUE;

            if (NT_SUCCESS(Status))
            {
                WCHAR *szUserName;

                szUserName = (WCHAR*)GlobalAlloc(GMEM_FIXED, sizeof(TCHAR)*UNLEN);
                if( !szUserName)
                {
                    DbgPrint("Could not allocate memory for szUserName.\n");
                    return GetLastError();
                }

                GlobalUnlock(hmem);

                hnewmem = GlobalReAlloc(hmem,
                                        ((*pcEntriesRead) + cEntriesRead) *
                                        sizeof(RAS_USER_1),
                                        GMEM_MOVEABLE);
                if(!hnewmem)
                {
                    DWORD LastError = GetLastError();
                    DbgPrint("Could not reallocate memory for *ppRasUser1.\n");
                    SamFreeMemory( SortedUsers );
                    return (LastError);
                }

                hmem = hnewmem;
                *ppRasUser1 = (RAS_USER_1*) GlobalLock(hmem);
                if(!*ppRasUser1)
                {
                    DbgPrint("Could not lock memory segment for *ppRasUser1.\n");
                    return GetLastError();
                }

                pRasUser1Ptr = (*ppRasUser1) + (*pcEntriesRead);
                (*pcEntriesRead) += cEntriesRead;

                for (i=0;i<cEntriesRead ; i++, pRasUser1Ptr++)
                {
                    ConvertUnicodeStringToWcs(szUserName, &SortedUsers[i].LogonName);
                    memset(&(pRasUser1Ptr->rasuser0), '\0', sizeof(RAS_USER_0));
                    pRasUser1Ptr->szUser = (WCHAR*)
                                           GlobalAlloc(GMEM_FIXED,
                                                    sizeof(TCHAR)*
                                                    lstrlen(szUserName)+
                                                    sizeof(TCHAR));
                    if( !pRasUser1Ptr->szUser)
                    {
                        DbgPrint("Could not allocate memory for pRasUser1->szUser.\n");
                        SamFreeMemory( SortedUsers );
                        if(szUserName)
                            GlobalFree(szUserName);
                        GlobalUnlock(hmem);
                        GlobalFree(hmem);
                        return GetLastError();
                    }
                    lstrcpy(pRasUser1Ptr->szUser, szUserName);
                }
                if(szUserName)
                    GlobalFree(szUserName);

                Status = SamFreeMemory( SortedUsers );
                if (!NT_SUCCESS(Status))
                {
                    DbgPrint("\n\n\n ********  SamFreeMemory() failed.  *********\n");
                    DbgPrint("\n\n\n ********  Status: 0x%lx            *********\n", Status);
                }
            }
            if(!bMoreData)
                break;
        } // end while

        //
        // Close DomainHandle if open.
        //
Cleanup:

        if (DomainHandle) {
            SamCloseHandle(DomainHandle);
        }

        //
        // Close SamHandle if open.
        //

        if (SamHandle) {
            SamCloseHandle(SamHandle);
        }

    } //else

    if (insert_list_head(*ppRasUser1, RASADMIN_RAS_USER_1_PTR, *pcEntriesRead))
    {
        FreeUser1(*ppRasUser1, *pcEntriesRead);
        GlobalUnlock((HGLOBAL)*ppRasUser1);
        GlobalFree(*ppRasUser1);
        Status = ERROR_NOT_ENOUGH_MEMORY;
    }

    return( (NT_SUCCESS(Status)) ? ERROR_SUCCESS : Status );
}
#endif


DWORD APIENTRY
RasAdminUserSetInfo(
    IN const WCHAR        * lpszServer,
    IN const WCHAR        * lpszUser,
    IN const PRAS_USER_0    pRasUser0
    )
/*++

Routine Description:

    This routine allows the admin to change the RAS permission for a
    user.  If the user parms field of a user is being used by another
    application, it will be destroyed.

Arguments:

    lpszServer      name of the server which has the user database,
                    eg., "\\\\UASSRVR" (the server must be one on which
                    the UAS can be changed i.e., the name returned by
                    RasAdminGetUserAccountServer).

    lpszUser        user account name to retrieve information for,
                    e.g. "USER".

    pRasUser0       pointer to a buffer in which user information is
                    provided.  The buffer should contain a filled
                    RAS_USER_0 structure.


Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        return codes from NetUserGetInfo or NetUserSetInfo

        ERROR_INVALID_DATA indicates that the data in pRasUser0 is bad.
--*/
{
    return MprAdminUserSetInfo(lpszServer, lpszUser, 0, (LPBYTE)pRasUser0);
}


DWORD APIENTRY
RasAdminSetUserParms(
    IN OUT   WCHAR    * lpszParms,
    IN DWORD          cchNewParms,
    IN PRAS_USER_0    pRasUser0
    )
/*++

Routine Description:

    This routine is used to modify the RAS user permission and call back number in lpszParms
    from the information in pRasuser0.

Arguments:

    lpszParms       pointer to UsrParms buffer.

    pRasUser0       pointer to a buffer in which user information is
                    provided.  The buffer should contain a filled
                    RAS_USER_0 structure.


Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        ERROR_INVALID_DATA indicates that the data in pRasUser0 is bad.
--*/
{
    RAS_USER_0 User0;
    USER_PARMS UserParms;
    DWORD dwRetCode;
    WCHAR wchBuffer[sizeof(USER_PARMS)];


    ASSERT(lpszParms != NULL);
    ASSERT(pRasUser0 != NULL);

    CopyMemory(&User0, pRasUser0, sizeof(RAS_USER_0));

    //
    // This will initialize a USER_PARMS structure with a template
    // for default Macintosh and Ras data.
    //
    InitUsrParams(&UserParms);

    //
    // We are sharing the user parms field with LM SFM, and want to
    // preserver it's portion.  So we'll get the user parms and put
    // the Mac primary group into our template, which is what we'll
    // eventually store back to the user parms field.
    //

    //
    // usr_parms comes back as a wide character string.  The MAC Primary
    // Group is at offset 1.  We'll convert this part to ASCII and store
    // it in our template.
    //
    if (lstrlenW(lpszParms+1) >= UP_LEN_MAC)
    {
        wcstombs(UserParms.up_PriGrp, lpszParms+1, UP_LEN_MAC);
    }

    //
    // Compress Callback number (the compressed phone number is placed
    // back in the RAS_USER_0 structure.  The permissions byte may also
    // be affected if the phone number is not compressable.
    //
    if (dwRetCode = RasPrivilegeAndCallBackNumber(TRUE, &User0))
    {
        return(dwRetCode);
    }

    //
    // Now put the dialin privileges and compressed phone number into
    // the USER_PARMS template.  Note that the privileges byte is the
    // first byte of the callback number field.
    //
    UserParms.up_CBNum[0] = User0.bfPrivilege;

    wcstombs( &UserParms.up_CBNum[1], 
              User0.szPhoneNumber,  
              sizeof(UserParms.up_CBNum) - 1);

    //
    // Wow, that was tough.  Now, we'll convert our template into
    // wide characters for storing back into user parms field.
    //

    //
    //  Fill in the remaining data with ' ' up to the bounds of USER_PARMS.
    //

    {
        USHORT  Count;

        for (Count = 0; Count < sizeof(UserParms.up_CBNum); Count++ )
        {
            if (UserParms.up_CBNum[Count] == '\0')
            {
                UserParms.up_CBNum[Count] = ' ';
            }
        }
    }

    UserParms.up_Null = '\0';

    if ( lstrlenW( lpszParms ) <= ( sizeof( USER_PARMS ) - 1 ) ) 
    {
        mbstowcs( lpszParms, (PBYTE)(&UserParms), sizeof(USER_PARMS) );
    }
    else
    {
        mbstowcs( wchBuffer, (PBYTE)(&UserParms), sizeof(USER_PARMS) );

        CopyMemory( (PBYTE)lpszParms, 
                    (PBYTE)wchBuffer, 
                    sizeof( wchBuffer ) - sizeof( WCHAR ) );
    }

    return(ERROR_SUCCESS);
}


DWORD APIENTRY
RasAdminUserGetInfo(
    IN const WCHAR   * lpszServer,
    IN const WCHAR   * lpszUser,
    OUT PRAS_USER_0    pRasUser0
    )
/*++

Routine Description:

    This routine retrieves RAS and other UAS information for a user
    in the domain the specified server belongs to. It loads the caller's
    pRasUser0 with a RAS_USER_0 structure.

Arguments:

    lpszServer      name of the server which has the user database,
                    eg., "\\\\UASSRVR" (the server must be one on which
                    the UAS can be changed i.e., the name returned by
                    RasAdminGetUserAccountServer).

    lpszUser        user account name to retrieve information for,
                    e.g. "USER".

    pRasUser0       pointer to a buffer in which user information is
                    returned.  The returned info is a RAS_USER_0 structure.

Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        return codes from NetUserGetInfo or NetUserSetInfo

        ERROR_INVALID_DATA indicates that user parms is invalid.
--*/
{
    return MprAdminUserGetInfo(lpszServer, lpszUser, 0, (LPBYTE)pRasUser0);
}

DWORD APIENTRY
RasAdminGetUserParms(
    IN     WCHAR          * lpszParms,
    IN OUT PRAS_USER_0      pRasUser0
    )
/*++

Routine Description:

    This routine fills  the caller's pRasUser0 with a RAS_USER_0 structure information
    extracted from lpszParms.

Arguments:

    lpszParms       UsrParms buffer

    pRasUser0       pointer to a buffer in which user information is
                    returned.  The returned info is a RAS_USER_0 structure.

Return Value:

    ERROR_SUCCESS on successful return.

    One of the following non-zero error codes indicating failure:

        ERROR_INVALID_DATA indicates that user parms is invalid.
--*/
{
    ASSERT(lpszParms);
    ASSERT(pRasUser0);

    memset(pRasUser0, '\0', sizeof(RAS_USER_0));

    //
    // if usr_parms not initialized, default to no RAS privilege
    //
    if (lpszParms == NULL)
    {
        pRasUser0->bfPrivilege = RASPRIV_NoCallback;
        pRasUser0->szPhoneNumber[0] = UNICODE_NULL;
    }
    else
    {
        WCHAR wchUserParms[sizeof(USER_PARMS)];

        //
        //  AndyHe... truncate user_info_2 at sizeof USER_PARMS
        //

        if ( lstrlenW( lpszParms ) > ( sizeof( USER_PARMS ) - 1 ) )
        {
            CopyMemory( wchUserParms, 
                        lpszParms, 
                        sizeof( USER_PARMS ) * sizeof( WCHAR ) );

            //
            // we slam in a null at sizeof(USER_PARMS)-1 which corresponds to
            // user_parms.up_Null
            //

            wchUserParms[sizeof(USER_PARMS)-1] = L'\0';
        }
        else
        {
            lstrcpyW( wchUserParms, lpszParms );
        }

        //
        // get RAS info (and validate) from usr_parms
        //
        if (GetUsrParams(UP_CLIENT_DIAL,
                         (LPWSTR) wchUserParms,
                         (LPWSTR) pRasUser0))
        {
            pRasUser0->bfPrivilege = RASPRIV_NoCallback;
            pRasUser0->szPhoneNumber[0] = UNICODE_NULL;
        }
        else
        {
            //
            // get RAS Privilege and callback number
            //
            RasPrivilegeAndCallBackNumber(FALSE, pRasUser0);
        }
    }
    return (ERROR_SUCCESS);
}

DWORD APIENTRY
RasAdminGetUserAccountServer(
    IN const WCHAR * lpszDomain,
    IN const WCHAR * lpszServer,
    OUT LPWSTR lpszUasServer
    )
/*++

Routine Description:

    This routine finds the server with the master UAS (the PDC) from
    either a domain name or a server name.  Either the domain or the
    server (but not both) may be NULL.

Arguments:

    lpszDomain      Domain name or NULL if none.

    lpszServer      name of the server which has the user database.

    lpszUasServer   Caller's buffer for the returned UAS server name.
                    The buffer should be atleast UNCLEN + 1 characters
                    long.

Return Value:

    ERROR_SUCCESS on successful return.
    ERROR_INVALID_PARAMETER if both lpszDomain and lpszServer are NULL.

    one of the following non-zero error codes on failure:

        return codes from NetGetDCName

--*/
{
    PUSER_MODALS_INFO_1 pModalsInfo1 = NULL;
    PDOMAIN_CONTROLLER_INFO pControllerInfo = NULL;
    DWORD dwErr = NO_ERROR;
    WCHAR TempName[UNCLEN + 1];

    //
    // Check the caller's buffer. Must be UNCLEN+1 bytes
    //
    lpszUasServer[0] = 0;
    lpszUasServer[UNCLEN] = 0;

    if ((lpszDomain) && (*lpszDomain))
    {
        //
        // This code will get the name of a DC for this domain.
        //
        dwErr = DsGetDcName(
                    NULL,
                    lpszDomain,
                    NULL,
                    NULL,
                    DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED,
                    &pControllerInfo);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }

        // 
        // Return the name of the DC
        //
        wcscpy(lpszUasServer, pControllerInfo->DomainControllerName);

        // Cleanup
        //
        NetApiBufferFree(pControllerInfo);
    }
    else
    {
        if ((lpszServer) && (*lpszServer))
        {
            lstrcpyW(TempName, lpszServer);
        }
        else
        {
            //
            // Should have specified a computer name
            //
	         return (ERROR_INVALID_PARAMETER);
        }
        //
        // Ok, we have the name of a server to use - now find out it's
        // server role.
        //
        if (dwErr = NetUserModalsGet(TempName, 1, (LPBYTE *) &pModalsInfo1))
        {
            DbgPrint("Admapi: NetUserModalGet error - server %ws\n", TempName);
            return dwErr;
        }
        if (pModalsInfo1 == NULL)
        {
            return ERROR_CAN_NOT_COMPLETE;
        }

        //
        // Examine the role played by this server
        //
        switch (pModalsInfo1->usrmod1_role)
        {
            case UAS_ROLE_STANDALONE:
            case UAS_ROLE_PRIMARY:
                //
        	    // In this case our server is a primary or a standalone.
                // in either case we use it.
                //
                break;				


            case UAS_ROLE_BACKUP:
            case UAS_ROLE_MEMBER:
                //
                // Use the primary domain controller as the remote server
                // in this case.
                //
                wsprintf(TempName, L"\\\\%s", pModalsInfo1->usrmod1_primary);
                break;
        }

        lstrcpyW(lpszUasServer, TempName);

        NetApiBufferFree(pModalsInfo1);
    }        

    return (dwErr);
}

DWORD APIENTRY
RasAdminGetErrorString(
    IN  UINT    ResourceId,
    OUT WCHAR * lpszString,
    IN  DWORD   InBufSize )

    /* Load caller's buffer 'lpszString' of length 'InBufSize' with the
    ** resource string associated with ID 'ResourceId'.
    **
    ** Returns 0 if successful, otherwise a non-0 error code.
    **
    */
{
    DWORD dwErr = 0;
    HINSTANCE hMsgDll;

    if (ResourceId < RASBASE || ResourceId > RASBASEEND || !lpszString)
        return ERROR_INVALID_PARAMETER;

    if (InBufSize == 1)
    {
        /* strange case, but a bug was filed...
        */
        lpszString[ 0 ] = '\0';
        return ERROR_INSUFFICIENT_BUFFER;
    }

    if ((hMsgDll = LoadLibraryA("rasmsg.dll")) == NULL) {
        return GetLastError();
    }

    if (!FormatMessageW(
          FORMAT_MESSAGE_FROM_HMODULE,
          hMsgDll,
          ResourceId,
          0,
          lpszString,
          InBufSize,
          NULL))
    {
       dwErr = GetLastError();
    }

    return dwErr;
}


DWORD
RasPrivilegeAndCallBackNumber(
    BOOL Compress,
    PRAS_USER_0 pRasUser0
    )
/*++

Routine Description:

    This routine either compresses or decompresses the users call
    back number depending on the boolean value Compress.

Return Value:

    ERROR_SUCCESS on successful return.

    one of the following non-zero error codes on failure:

       ERROR_INVALID_DATA indicating that usr_parms is invalid

--*/
{
DWORD dwRetCode;

    switch( pRasUser0->bfPrivilege & RASPRIV_CallbackType)    {

        case RASPRIV_NoCallback:
        case RASPRIV_AdminSetCallback:
        case RASPRIV_CallerSetCallback:

             if (Compress == TRUE)
             {
                 WCHAR compressed[ RASSAPI_MAX_CALLBACK_NUMBER_SIZE + 1];

                 // compress the phone number to fit in the
                 // user parms field

                 if (dwRetCode = RasAdminCompressPhoneNumber(pRasUser0->szPhoneNumber,
                         compressed))
                 {
                     return (dwRetCode);
                 }
                 else
                 {
                     lstrcpy((LPTSTR) pRasUser0->szPhoneNumber,
                             (LPCTSTR) compressed);
                 }
             }
             else
             {
                 WCHAR decompressed[ RASSAPI_MAX_CALLBACK_NUMBER_SIZE + 1];

                 //
                 // decompress the phone number
                 //
                 if (RasAdminDecompressPhoneNumber(pRasUser0->szPhoneNumber,
                         decompressed))
                 {
                     pRasUser0->bfPrivilege =  RASPRIV_NoCallback;
                     pRasUser0->szPhoneNumber[0] =  UNICODE_NULL;
                 }
                 else
                 {
                     lstrcpy((LPTSTR) pRasUser0->szPhoneNumber,
                             (LPCTSTR) decompressed);
                 }
             }

             break;


        default:
             if (Compress == TRUE)
             {
                 return(ERROR_INVALID_DATA);
             }
             else
             {
                pRasUser0->bfPrivilege = RASPRIV_NoCallback;
                pRasUser0->szPhoneNumber[0] = UNICODE_NULL;
             }
             break;
    }

    return(ERROR_SUCCESS);
}

BOOL
CheckIfNT(const WCHAR * lpszServer)
/*
 * Check to see if the server lpszServer is an NT or a downlevel server.
 *
 * We assume here that the server service is running on the server lpszServer
 *
 */
{
    PSERVER_INFO_101 ServerInfo101;

    if(NetServerGetInfo(
            (WCHAR *)lpszServer,
            101,                       // level 101 info
            (LPBYTE *) &ServerInfo101
            ))
    {
       return FALSE;
    }

    return((ServerInfo101->sv101_type & SV_TYPE_NT) ? TRUE:FALSE);
}

VOID
ConvertUnicodeStringToWcs(WCHAR *szUserName, PUNICODE_STRING pUnicode)
{
    USHORT cbLen = pUnicode->Length/sizeof(WCHAR);
    WCHAR  *pwc  = pUnicode->Buffer;

    *szUserName = L'\0';

    if(cbLen == 0)
       return;

    while( (cbLen-- > 0) && (*pwc != L'\0'))
    {
       *szUserName++ = *pwc++;
    }
    *szUserName = L'\0';
}



DWORD GetAccountDomain(
    IN  PUNICODE_STRING Server,
    OUT PUNICODE_STRING Domain
    )
/*
 *  Given the server name, this routine determines the Account Domain for
 *  the given server.  This is an NT only routine.
 *
 *  For example if the server name is \\ramc2 and the local domain name is
 *  ramc2, this routine will return ramc2.
 *  If the server \\ramc2 were a BDC in the domain NTWINS, the domain name
 *  returned will be NTWINS.
 *
 *  This routine allocates memory for storing the domain name. It is the
 *  responsiblity of the caller to free Domain->Buffer using free().
 *
 */
{
    DWORD rc = 0;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LSA_HANDLE hLsa = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAcctDomainInfo = NULL;
    PUNICODE_STRING DomainName;

    //
    // Open the LSA
    //

    if ((ntStatus = OpenLsa(Server, &hLsa)) != NO_ERROR)
    if (!NT_SUCCESS(ntStatus))
    {
        return (1L);
    }

    //
    // Get the account domain
    //
    ntStatus = LsaQueryInformationPolicy(hLsa, PolicyAccountDomainInformation,
            (PVOID *) &pAcctDomainInfo);

    if (!NT_SUCCESS(ntStatus))
    {
        rc = 1L;
        goto clean;
    }

    DomainName = &pAcctDomainInfo->DomainName;

    Domain->Length = DomainName->Length;
    Domain->MaximumLength = DomainName->MaximumLength;
    Domain->Buffer = malloc(DomainName->Length);
    if(!(Domain->Buffer))
    {
       rc = 1L;
       goto clean;
    }
    RtlMoveMemory(Domain->Buffer, DomainName->Buffer, DomainName->Length);

clean:

    if (pAcctDomainInfo != NULL)
    {
        LsaFreeMemory(pAcctDomainInfo);
    }

    if (hLsa != NULL)
    {
        LsaClose(hLsa);
    }

    return (rc);
}


//**
//
// Call:        OpenLsa
//
// Returns:     Returns from LsaOpenPolicy.
//
// Description: The LSA will be opened.
//
NTSTATUS OpenLsa(
    IN PUNICODE_STRING pSystem OPTIONAL,
    IN OUT PLSA_HANDLE phLsa
    )
{
    SECURITY_QUALITY_OF_SERVICE QOS;
    OBJECT_ATTRIBUTES ObjAttribs;
    NTSTATUS ntStatus;

    //
    // Open the LSA and obtain a handle to it.
    //
    QOS.Length = sizeof(QOS);
    QOS.ImpersonationLevel = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&ObjAttribs, NULL, 0L, NULL, NULL);

    ObjAttribs.SecurityQualityOfService = &QOS;

    ntStatus = LsaOpenPolicy(pSystem, &ObjAttribs,
            POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES, phLsa);

    return (ntStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\usrparms.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/

/*++

Filename:

   USRPARMS.C

Description:

   Contains code to get set and initialize the user_parms field.

   The 49-byte user params structure is laid out as follows:

   NOTE that the buffer is 48 byte + NULL byte.

   +-+-------------------+-+------------------------+-+
   |m|Macintosh Pri Group|d|Dial-in CallBack Number |0|
   +-+-------------------+-+------------------------+-+
    |                     |                          |
    +---------------------+------ Signature          +- NULL terminator

   The routines were originally written for RAS 1.0 and deal only with
   multi-byte strings.  For NT unicodification, wcstombs() and mbstowcs()
   have been used to convert string formats.  Eventually these routines
   can be converted to be native Unicode.

History:
   20/3/91     Narendra Gidwani    Created original version
   July 14 92  Janakiram Cherala   Modified for NT
   May 13 93   Andy Herron         Coexist with other apps using user parms


--*/

#include <windows.h>
#include <string.h>
#include <lm.h>
#include <stdlib.h>
#include <rassapi.h>
#include "usrparms.h"


/*++

Routine Description:

    Initializes the user params buffer.

Arguments:

    UserParms - Pointer to a USER_PARMS structure which is initialized.
                After initializing, the UserParms structure would look
                like:

                0                                                49
                +-+-------------------+-+------------------------+-+
                |m|:                  |d|1                       |0|
                +-+-------------------+-+------------------------+-+

Return Value:

   None.

--*/

void InitUsrParams(
    USER_PARMS *pUserParms
    )
{
    //
    // Null the whole structure and check for GP fault.
    //

    memset(pUserParms, '\0', sizeof(USER_PARMS));

    //
    // Initialize Macintosh fields
    //
    pUserParms->up_MACid = UP_CLIENT_MAC;

    memset(pUserParms->up_PriGrp, ' ', UP_LEN_MAC);

    pUserParms->up_PriGrp[0] = ':';
    pUserParms->up_MAC_Terminater = ' ';


    //
    // Initialize RAS fields
    //
    pUserParms->up_DIALid   = UP_CLIENT_DIAL;
    pUserParms->up_CBNum[0] = 1;
}

USHORT SetUsrParams(
    USHORT InfoType,
    LPWSTR InBuf,
    LPWSTR OutBuf
    )
/*++

Routine Description:

    Sets either dialin information or mac information into
    the user_parms field in the proper format.

Arguments:

    InfoType  - An unsigned short representing the type of information
                to be set: UP_CLIENT_DIAL or UP_CLIENT_MAC.

    InBuf     - Pointer to string ie either call back number and permissions
                for dialin or primary group name for Macintosh.

    OutBuf    - Pointer to a USER_PARMS that has been initialized or is in
                the correct format. This is loaded with the information
                passed in InBuf.

Return Value:

       0 indicating success
       ERROR_INVALID_DATA        - failure.
       ERROR_INVALID_PARAMETER - failure

--*/
{
    USHORT len;
    char Buffer[sizeof(USER_PARMS)];
    char uBuffer[sizeof(USER_PARMS)];
    USER_PARMS FAR * OutBufPtr;
    char FAR * InBufPtr = Buffer;


    //
    // convert the unicode string to multi byte for processing
    //
    wcstombs(Buffer, InBuf, sizeof(USER_PARMS));
    wcstombs(uBuffer, OutBuf, sizeof(USER_PARMS));

    OutBufPtr = (USER_PARMS FAR *)uBuffer;


    //
    // Validate InfoType
    //
    if (InfoType != UP_CLIENT_MAC && InfoType != UP_CLIENT_DIAL )
    {
        return( ERROR_INVALID_PARAMETER );
    }


    //
    // Make sure the field to be set is in the correct format
    //
    if (( OutBufPtr->up_MACid  != UP_CLIENT_MAC  ) ||
        ( OutBufPtr->up_DIALid != UP_CLIENT_DIAL ) )
    {
        return( ERROR_INVALID_DATA );
    }


    len = (USHORT)strlen( InBufPtr );

    switch ( InfoType )
    {
        case UP_CLIENT_MAC:

            if ( len > UP_LEN_MAC )
            {
                return( ERROR_INVALID_DATA );
            }


            //
            // Set the MAC information
            //
            if ( len > 0 )
            {
                strcpy( OutBufPtr->up_PriGrp, InBufPtr );
            }

            OutBufPtr->up_PriGrp[len] = ':';

            break;


        case UP_CLIENT_DIAL:

            if ( len > UP_LEN_DIAL )
            {
                return( ERROR_INVALID_DATA );
            }


            //
            // Set the dialin information
            //
            if ( len > 0 )
            {
                strcpy( OutBufPtr->up_CBNum, InBufPtr );
            }

            break;


        default:
            return( ERROR_INVALID_PARAMETER );
    }


    //
    // convert multicode string to unicode
    //
    mbstowcs(OutBuf, uBuffer, sizeof(USER_PARMS));


    return( 0 );
}




USHORT FAR
GetUsrParams(
    USHORT    InfoType,
    LPWSTR    InBuf,
    LPWSTR    OutBuf
    )
/*++

Routine Description:

    Extracts dialin or mac information from the user_parms

Arguments:

    InfoType      - An unsigned short representing the
                    type of information to be extracted.
                    UP_CLIENT_DIAL or UP_CLIENT_MAC.

    InBuf         - Pointer to a USER_PARMS that has been
                    initialized or is in the correct format.
                    and contains the information to be
                    extracted. This should be NULL
                    terminated.

    OutBuf        - Contains the extracted information.
                    This buffer should be large enough to
                    hold the information requested as well
                    as a NULL terminater.


Returns:
       0 on success
       ERROR_INVALID_DATA            - failure
       ERROR_INVALID_PARAMETER     - failure
--*/
{
USER_PARMS FAR * InBufPtr;
USHORT           len;
char       FAR * TerminaterPtr;
char       FAR * OutBufPtr;
char             Buffer[sizeof(USER_PARMS)];
char             uBuffer[sizeof(USER_PARMS)];

    // convert string to mulitbyte before processing

    wcstombs(Buffer, InBuf, sizeof(USER_PARMS));

    InBufPtr = (USER_PARMS FAR *)Buffer;

    // Validate InfoType
    //
    if ( InfoType != UP_CLIENT_MAC && InfoType != UP_CLIENT_DIAL )
        return( ERROR_INVALID_PARAMETER );

    // First make sure the user parms field is at least the minimum length.
    //
    len = (USHORT)strlen( Buffer );

    // 3 = 1 for MAC_Terminater + 1 for up_MACid + 1 for up_DIALid
    //

    if ( len <  ( UP_LEN_MAC + 3 ) )
        return( ERROR_INVALID_DATA );


    // Check for correct signatures.
    //

    if ( ( InBufPtr->up_MACid != UP_CLIENT_MAC) ||
         ( InBufPtr->up_DIALid != UP_CLIENT_DIAL ))
        return( ERROR_INVALID_DATA );

    switch( InfoType ) {

        case UP_CLIENT_MAC:

            OutBufPtr = InBufPtr->up_PriGrp;

            // Validate the information
            //
            if ( ( TerminaterPtr = strchr( OutBufPtr, ':')) == NULL)
                return( ERROR_INVALID_DATA );

            if ( ( len = (USHORT)( TerminaterPtr - OutBufPtr ) ) > UP_LEN_MAC)
               return( ERROR_INVALID_DATA );

            // Copy the data
            //
            strcpy( uBuffer, OutBufPtr);

            break;

       case UP_CLIENT_DIAL:


            OutBufPtr = InBufPtr->up_CBNum;

            len = (USHORT)strlen( OutBufPtr );

            //
            // AndyHe... Peal off all trailing blanks
            //

            while (len > 1 && *(OutBufPtr+len-1) == ' ')
            {
                *(OutBufPtr+len-1) = '\0';
                len--;
            }
            if ( len > UP_LEN_DIAL)
               return( ERROR_INVALID_DATA );

            if ( len > 0 )
               strcpy( uBuffer, OutBufPtr);

            break;

        default:
            return( ERROR_INVALID_PARAMETER );
    }

    // convert string to unicode before returning

    mbstowcs(OutBuf, uBuffer, sizeof(USER_PARMS));

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdial\src\rasdial.h ===
/*****************************************************************************/
/**                         Microsoft LAN Manager                           **/
/**                   Copyright (C) 1993 Microsoft Corp.                    **/
/*****************************************************************************/

//***
//    File Name:
//       RASDIAL.H
//
//    Function:
//        Header information for RASDIAL command line interface.
//
//    History:
//        03/18/93 - Michael Salamone (MikeSa) - Original Version 1.0
//***

#ifndef _RASDIAL_H_
#define _RASDIAL_H_

#define ENUMERATE_CONNECTIONS  0
#define DIAL                   1
#define DISCONNECT             2
#define HELP                   3

void _cdecl main(int argc, char *argv[]);

VOID Dial(VOID);
VOID Disconnect(VOID);
VOID EnumerateConnections(VOID);
VOID Usage(VOID);

DWORD Enumerate(RASCONNA **RasConn, PDWORD NumEntries);
DWORD WINAPI
RasDialFunc2(
    DWORD        dwCallbackId,
    DWORD        dwSubEntry,
    HRASCONN     hrasconn,
    UINT         unMsg,
    RASCONNSTATE state,
    DWORD        dwError,
    DWORD        dwExtendedError
    );
BOOL DialControlSignalHandler(DWORD ControlType);
BOOL DisconnectControlSignalHandler(DWORD ControlType);
VOID WaitForRasCompletion(VOID);

BOOL is_valid_entryname(char *candidate);
BOOL match(char *str1, char *str2);

DWORD ParseCmdLine(int argc, char *argv[]);
VOID PrintMessage(DWORD MsgId, PBYTE *pArgs);

USHORT GetPasswdStr(UCHAR *buf, WORD buflen, WORD *len);

USHORT GetString(
    register UCHAR *buf,
    register WORD buflen,
    register WORD *len,
    register UCHAR *terminator
    );

#endif  // _RASDIAL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\usrparms.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/

//***
//
// Filename:	usrparms.h
//
// Description:
//
// History:
//

#define	UP_CLIENT_MAC	'm'
#define	UP_CLIENT_DIAL	'd'


//	The 49-byte user params structure is laid out as follows:
// 	NOTE that the buffer is 48 byte + NULL byte.
// 
//	+-+-------------------+-+------------------------+-+
//	|m|Macintosh Pri Group|d|Dial-in CallBack Number | |
//	+-+-------------------+-+------------------------+-+
//	 |		       |			  |
//	 +---------------------+------ Signature	  +- NULL terminator
//

#define	UP_LEN_MAC		( LM20_UNLEN )

#define	UP_LEN_DIAL		( LM20_MAXCOMMENTSZ - 3 - UP_LEN_MAC )

typedef	struct {
	char	up_MACid;
	char	up_PriGrp[UP_LEN_MAC];
	char    up_MAC_Terminater;
	char	up_DIALid;
	char	up_CBNum[UP_LEN_DIAL];
	char    up_Null;
} USER_PARMS;

typedef	USER_PARMS FAR *PUP;

extern void InitUsrParams(USER_PARMS *UserParms);
extern USHORT SetUsrParams(USHORT InfoType,  LPWSTR InBuf, LPWSTR OutBuf); 
extern USHORT FAR GetUsrParams(USHORT InfoType, LPWSTR InBuf, LPWSTR OutBuf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\alternat.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// alternat.c
// Remote Access Common Dialog APIs
// Alternate phone number dialogs
//
// 11/06/97 Steve Cobb


#include "rasdlgp.h"


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwAnHelp[] =
{
    CID_AN_ST_Explain,       HID_AN_ST_Explain,
    CID_AN_ST_Numbers,       HID_AN_LV_Numbers,
    CID_AN_LV_Numbers,       HID_AN_LV_Numbers,
    CID_AN_PB_Up,            HID_AN_PB_Up,
    CID_AN_PB_Down,          HID_AN_PB_Down,
    CID_AN_PB_Add,           HID_AN_PB_Add,
    CID_AN_PB_Edit,          HID_AN_PB_Edit,
    CID_AN_PB_Delete,        HID_AN_PB_Delete,
    CID_AN_CB_MoveToTop,     HID_AN_CB_MoveToTop,
    CID_AN_CB_TryNextOnFail, HID_AN_CB_TryNextOnFail,
    0, 0
};


static DWORD g_adwCeHelp[] =
{
    CID_CE_GB_PhoneNumber,     HID_CE_GB_PhoneNumber,
    CID_CE_ST_AreaCodes,       HID_CE_CLB_AreaCodes,
    CID_CE_CLB_AreaCodes,      HID_CE_CLB_AreaCodes,
    CID_CE_ST_PhoneNumber,     HID_CE_EB_PhoneNumber,
    CID_CE_EB_PhoneNumber,     HID_CE_EB_PhoneNumber,
    CID_CE_ST_CountryCodes,    HID_CE_LB_CountryCodes,
    CID_CE_LB_CountryCodes,    HID_CE_LB_CountryCodes,
    CID_CE_GB_Comment,         HID_CE_GB_Comment,
    CID_CE_EB_Comment,         HID_CE_EB_Comment,
    CID_CE_CB_UseDialingRules, HID_CE_CB_UseDialingRules,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Alternate Phone Number dialog argument block.
//
typedef struct
_ANARGS
{
    DTLNODE* pLinkNode;
    DTLLIST* pListAreaCodes;
}
ANARGS;


// Alternate Phone Number dialog context block.
//
typedef struct
_ANINFO
{
    // Caller's arguments to the dialog.
    //
    ANARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLv;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndPbAdd;
    HWND hwndPbEdit;
    HWND hwndPbDelete;
    HWND hwndCbTryNext;
    HWND hwndCbMoveToTop;
    HWND hwndPbOk;

    // Up/down arrow icons.
    //
    HANDLE hiconUpArr;
    HANDLE hiconDnArr;
    HANDLE hiconUpArrDis;
    HANDLE hiconDnArrDis;

    // The state to display in the "move to top" checkbox should it be
    // enabled.
    //
    BOOL fMoveToTop;

    // Link node containing edited phone number list and check box settings
    // and a shortcut to the contained link.
    //
    DTLNODE* pNode;
    PBLINK* pLink;

    // List of area codes passed to CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one in 'pArgs'.
    //
    DTLLIST* pListAreaCodes;
}
ANINFO;


// Phone number editor dialog argument block
//
typedef struct
_CEARGS
{
    DTLNODE* pPhoneNode;
    DTLLIST* pListAreaCodes;
    DWORD sidTitle;
}
CEARGS;


// Phone number editor dialog context block.
//
typedef struct
_CEINFO
{
    // Caller's arguments to the dialog.
    //
    CEARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStAreaCodes;
    HWND hwndClbAreaCodes;
    HWND hwndEbPhoneNumber;
    HWND hwndLbCountryCodes;
    HWND hwndStCountryCodes;
    HWND hwndCbUseDialingRules;
    HWND hwndEbComment;

    // Phone node containing edited phone number settings and a shortcut to
    // the contained PBPHONE.
    //
    DTLNODE* pNode;
    PBPHONE* pPhone;

    // List of area codes passed to CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one in 'pArgs'.
    //
    DTLLIST* pListAreaCodes;

    // Area-code and country-code helper context block, and a flag indicating
    // if the block has been initialized.
    //
    CUINFO cuinfo;
    BOOL fCuInfoInitialized;
}
CEINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
AnAddNumber(
    IN ANINFO* pInfo );

BOOL
AnCommand(
    IN ANINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
AnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
AnDeleteNumber(
    IN ANINFO* pInfo );

VOID
AnEditNumber(
    IN ANINFO* pInfo );

VOID
AnFillLv(
    IN ANINFO* pInfo,
    IN DTLNODE* pNodeToSelect );

BOOL
AnInit(
    IN HWND hwndDlg,
    IN ANARGS* pArgs );

VOID
AnInitLv(
    IN ANINFO* pInfo );

VOID
AnListFromLv(
    IN ANINFO* pInfo );

LVXDRAWINFO*
AnLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem );

VOID
AnMoveNumber(
    IN ANINFO* pInfo,
    IN BOOL fUp );

BOOL
AnSave(
    IN ANINFO* pInfo );

VOID
AnTerm(
    IN HWND hwndDlg );

VOID
AnUpdateButtons(
    IN ANINFO* pInfo );

VOID
AnUpdateCheckboxes(
    IN ANINFO* pInfo );

BOOL
CeCommand(
    IN CEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CeInit(
    IN HWND hwndDlg,
    IN CEARGS* pArgs );

BOOL
CeSave(
    IN CEINFO* pInfo );

VOID
CeTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Alternate Phone Number dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
AlternatePhoneNumbersDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pLinkNode,
    IN OUT DTLLIST* pListAreaCodes )

    // Popup a dialog to edit the phone number list for in 'pLinkNode'.
    // 'HwndOwner' is the owning window.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.
    //
{
    INT_PTR nStatus;
    ANARGS args;

    TRACE( "AlternatePhoneNumbersDlg" );

    args.pLinkNode = pLinkNode;
    args.pListAreaCodes = pListAreaCodes;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_AN_AlternateNumbers ),
            hwndOwner,
            AnDlgProc,
            (LPARAM )(&args) );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
AnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Alternate Phone Number dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "AnDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, AnLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return AnInit( hwnd, (ANARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwAnHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            ANINFO* pInfo = (ANINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return AnCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case LVN_ITEMCHANGED:
                {
                    NM_LISTVIEW* p;

                    p = (NM_LISTVIEW* )lparam;
                    if ((p->uNewState & LVIS_SELECTED)
                        && !(p->uOldState & LVIS_SELECTED))
                    {
                        ANINFO* pInfo;

                        // This item was just selected.
                        //
                        pInfo = (ANINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                        ASSERT( pInfo );
                        AnUpdateButtons( pInfo );
                    }
                    break;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            AnTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
AnCommand(
    IN ANINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "AnCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_AN_PB_Up:
        {
            AnMoveNumber( pInfo, TRUE );
            return TRUE;
        }

        case CID_AN_PB_Down:
        {
            AnMoveNumber( pInfo, FALSE );
            return TRUE;
        }

        case CID_AN_PB_Add:
        {
            AnAddNumber( pInfo );
            return TRUE;
        }

        case CID_AN_PB_Edit:
        {
            AnEditNumber( pInfo );
            return TRUE;
        }

        case CID_AN_PB_Delete:
        {
            AnDeleteNumber( pInfo );
            return TRUE;
        }

        case CID_AN_CB_TryNextOnFail:
        {
            AnUpdateCheckboxes( pInfo );
            return TRUE;
        }

        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, AnSave( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
AnAddNumber(
    IN ANINFO* pInfo )

    // Add a new phone number to the bottom of the ListView, by prompting user
    // with dialog.  'PInfo' is the dialog context.
    //
{
    DTLNODE* pNode;

    pNode = CreatePhoneNode();
    if (!pNode)
    {
        return;
    }

    if (!EditPhoneNumberDlg(
            pInfo->hwndDlg,
            pNode,
            pInfo->pListAreaCodes,
            SID_AddAlternateTitle ))
    {
        DestroyPhoneNode( pNode );
        return;
    }

    AnListFromLv( pInfo );
    DtlAddNodeLast( pInfo->pLink->pdtllistPhones, pNode );
    AnFillLv( pInfo, pNode );

}


VOID
AnDeleteNumber(
    IN ANINFO* pInfo )

    // Deletes the selected phone number in the ListView.  'PInfo' is the
    // dialog context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pSelNode;

    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    if (!pNode)
    {
        ASSERT( FALSE );
        return;
    }

    AnListFromLv( pInfo );

    // The item under the deleted selection gets the selection unless the
    // lowest item was deleted.  In that case the item above the deleted item
    // is selected.
    //
    pSelNode = DtlGetNextNode( pNode );
    if (!pSelNode)
    {
        pSelNode = DtlGetPrevNode( pNode );
    }

    DtlRemoveNode( pInfo->pLink->pdtllistPhones, pNode );
    DestroyPhoneNode( pNode );

    AnFillLv( pInfo, pSelNode );
}


VOID
AnEditNumber(
    IN ANINFO* pInfo )

    // Edit the selected phone number in the ListView, by prompting user with
    // dialog.  'PInfo' is the dialog context.
    //
{
    DTLNODE* pNode;

    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    if (!pNode)
    {
        ASSERT( FALSE );
        return;
    }

    if (!EditPhoneNumberDlg(
            pInfo->hwndDlg,
            pNode,
            pInfo->pListAreaCodes,
            SID_EditAlternateTitle ))
    {
        return;
    }

    AnListFromLv( pInfo );
    AnFillLv( pInfo, pNode );
}


VOID
AnFillLv(
    IN ANINFO* pInfo,
    IN DTLNODE* pNodeToSelect )

    // Fill the ListView from the edit node, and select the 'pNodeToSelect'
    // node.  'PInfo' is the dialog context.
    //
{
    INT iItem;
    INT iSelItem;
    DTLNODE* pNode;

    TRACE( "AnFillLv" );
    ASSERT( ListView_GetItemCount( pInfo->hwndLv ) == 0 );

    // Transfer nodes from the edit node list to the ListView one at a time,
    // noticing the item number of the node we'll need to select later.
    //
    iSelItem = 0;

    iItem = 0;
    while (pNode = DtlGetFirstNode( pInfo->pLink->pdtllistPhones ))
    {
        PBPHONE* pPhone;
        LV_ITEM item;
        TCHAR* psz;

        DtlRemoveNode( pInfo->pLink->pdtllistPhones, pNode );

        if (PhoneNodeIsBlank( pNode ))
        {
            // "Blank" numbers are discarded.
            //
            DestroyPhoneNode( pNode );
            continue;
        }

        pPhone = (PBPHONE* )DtlGetData( pNode );
        ASSERT( pPhone );

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = iItem;
        item.pszText = pPhone->pszPhoneNumber;
        item.lParam = (LPARAM )pNode;

        ListView_InsertItem( pInfo->hwndLv, &item );
        if (pNode == pNodeToSelect)
        {
            iSelItem = iItem;
        }

        ListView_SetItemText( pInfo->hwndLv, iItem, 1, pPhone->pszComment );
        ++iItem;
    }

    if (ListView_GetItemCount( pInfo->hwndLv ) > 0)
    {
        // Select the specified node, or if none, the first node which
        // triggers updates of the button states.
        //
        ListView_SetItemState(
            pInfo->hwndLv, iSelItem, LVIS_SELECTED, LVIS_SELECTED );
    }
    else
    {
        // Trigger the button state update directly when the list is redrawn
        // empty.
        //
        AnUpdateButtons( pInfo );
    }
}


BOOL
AnInit(
    IN HWND hwndDlg,
    IN ANARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    ANINFO* pInfo;
    DTLNODE* pNode;
    PBPHONE* pPhone;

    TRACE( "AnInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLv = GetDlgItem( hwndDlg, CID_AN_LV_Numbers );
    ASSERT( pInfo->hwndLv );
    pInfo->hwndPbUp = GetDlgItem( hwndDlg, CID_AN_PB_Up );
    ASSERT( pInfo->hwndPbUp );
    pInfo->hwndPbDown = GetDlgItem( hwndDlg, CID_AN_PB_Down );
    ASSERT( pInfo->hwndPbDown );
    pInfo->hwndPbAdd = GetDlgItem( hwndDlg, CID_AN_PB_Add );
    ASSERT( pInfo->hwndPbAdd );
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_AN_PB_Edit );
    ASSERT( pInfo->hwndPbEdit );
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_AN_PB_Delete );
    ASSERT( pInfo->hwndPbDelete );
    pInfo->hwndCbMoveToTop = GetDlgItem( hwndDlg, CID_AN_CB_MoveToTop );
    ASSERT( pInfo->hwndCbMoveToTop );
    pInfo->hwndCbTryNext = GetDlgItem( hwndDlg, CID_AN_CB_TryNextOnFail );
    ASSERT( pInfo->hwndCbTryNext );
    pInfo->hwndPbOk = GetDlgItem( hwndDlg, IDOK );
    ASSERT( pInfo->hwndPbOk );

    // Load the up and down arrow icons, enabled and disabled versions,
    // loading the disabled version into the move up and move down buttons.
    // Making a selection in the ListView will trigger the enabled version to
    // be loaded if appropriate.  From what I can tell tell in MSDN, you don't
    // have to close or destroy the icon handle.
    //
    pInfo->hiconUpArr = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_UpArr ), IMAGE_ICON, 0, 0, 0 );
    pInfo->hiconDnArr = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_DnArr ), IMAGE_ICON, 0, 0, 0 );
    pInfo->hiconUpArrDis = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_UpArrDis ), IMAGE_ICON, 0, 0, 0 );
    pInfo->hiconDnArrDis = LoadImage(
        g_hinstDll, MAKEINTRESOURCE( IID_DnArrDis ), IMAGE_ICON, 0, 0, 0 );

    // Make a copy of the argument node and list for editing since user can
    // Cancel the dialog and discard any edits.
    //
    pInfo->pNode = CreateLinkNode();
    if (!pInfo->pNode)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
        EndDialog( hwndDlg, FALSE );
        return TRUE;
    }

    CopyLinkPhoneNumberInfo( pInfo->pNode, pInfo->pArgs->pLinkNode );
    pInfo->pLink = (PBLINK* )DtlGetData( pInfo->pNode );
    ASSERT( pInfo->pLink );

    pInfo->pListAreaCodes = DtlDuplicateList(
        pArgs->pListAreaCodes, DuplicatePszNode, DestroyPszNode );

    // Fill the ListView of phone numbers and select the first one.
    //
    AnInitLv( pInfo );
    AnFillLv( pInfo, NULL );

    // Initialize the check boxes.
    //
    Button_SetCheck( pInfo->hwndCbTryNext,
        pInfo->pLink->fTryNextAlternateOnFail );
    Button_SetCheck( pInfo->hwndCbMoveToTop,
        pInfo->pLink->fPromoteAlternates );
    pInfo->fMoveToTop = pInfo->pLink->fPromoteAlternates;
    AnUpdateCheckboxes( pInfo );

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
AnInitLv(
    IN ANINFO* pInfo )

    // Fill the ListView with phone numbers and comments.  'PInfo' is the
    // dialog context.
    //
{
    TRACE( "AnInitLv" );

    // Add columns.
    //
    {
        LV_COLUMN col;
        TCHAR* pszHeader0;
        TCHAR* pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_PhoneNumbersColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_CommentColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( pInfo->hwndLv, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    // Size columns.  Gives half for phone number and half for comment.
    //
    {
        RECT rect;
        LONG dx;
        LONG dxPhone;
        LONG dxComment;

        // The (2 * 2) is 2 columns of 2-pel column separator which the
        // ListView doesn't seem to account for when accepting column widths.
        // This gives a full ListView with no horizontal scroll bar.
        //
        GetWindowRect( pInfo->hwndLv, &rect );
        dx = rect.right - rect.left - (2 * 2);
        dxPhone = dx / 2;
        dxComment = dx - dxPhone;
        ListView_SetColumnWidth( pInfo->hwndLv, 0, dxPhone );
        ListView_SetColumnWidth( pInfo->hwndLv, 1, dxComment );
    }
}


VOID
AnListFromLv(
    IN ANINFO* pInfo )

    // Rebuild the edit link's PBPHONE list from the ListView.  'PInfo' is the
    // dialog context.
    //
{
    INT i;

    i = -1;
    while ((i = ListView_GetNextItem( pInfo->hwndLv, i, LVNI_ALL )) >= 0)
    {
        DTLNODE* pNode;

        pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            continue;
        }

        if (PhoneNodeIsBlank( pNode ))
        {
            // "Blank" numbers are discarded.
            //
            DestroyPhoneNode( pNode );
            continue;
        }

        DtlAddNodeLast( pInfo->pLink->pdtllistPhones, pNode );
    }

    ListView_DeleteAllItems( pInfo->hwndLv );
}


LVXDRAWINFO*
AnLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 2, 0, 0, { 0, 0 } };

    return &info;
}


VOID
AnMoveNumber(
    IN ANINFO* pInfo,
    IN BOOL fUp )

    // Refill the ListView of devices with the selected item moved up or down
    // one position.  'FUp' is set to move up, otherwise moves down.  'PInfo'
    // is the property sheeet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pPrevNode;
    DTLNODE* pNextNode;
    DTLLIST* pList;

    // Notice which node is selected, then rebuild the edit link's PBPHONE
    // list from the ListView.
    //
    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    if (pNode == NULL)
    {
        return;
    }
    AnListFromLv( pInfo );
    pList = pInfo->pLink->pdtllistPhones;

    // Move the selected node forward or backward a node in the chain.
    //
    if (fUp)
    {
        pPrevNode = DtlGetPrevNode( pNode );
        if (pPrevNode)
        {
            DtlRemoveNode( pList, pNode );
            DtlAddNodeBefore( pList, pPrevNode, pNode );
        }
    }
    else
    {
        pNextNode = DtlGetNextNode( pNode );
        if (pNextNode)
        {
            DtlRemoveNode( pList, pNode );
            DtlAddNodeAfter( pList, pNextNode, pNode );
        }
    }

    // Refill the ListView with the new order.
    //
    AnFillLv( pInfo, pNode );
}


BOOL
AnSave(
    IN ANINFO* pInfo )

    // Load the contents of the dialog into caller's stub API output argument.
    // 'PInfo' is the dialog context.
    //
    // Returns true if succesful, false otherwise.
    //
{
    TRACE( "AnSave" );

    // Rebuild the edit link's PBPHONE list from the ListView.
    //
    AnListFromLv( pInfo );

    // Retrieve check box settings.
    //
    pInfo->pLink->fPromoteAlternates =
        Button_GetCheck( pInfo->hwndCbMoveToTop );
    pInfo->pLink->fTryNextAlternateOnFail =
        Button_GetCheck( pInfo->hwndCbTryNext );

    // Copy the edit buffer to caller's output argument.
    //
    CopyLinkPhoneNumberInfo( pInfo->pArgs->pLinkNode, pInfo->pNode );

    // Swap lists, saving updates to caller's global list of area codes.
    // Caller's original list will be destroyed by AnTerm.
    //
    if (pInfo->pListAreaCodes)
    {
        DtlSwapLists( pInfo->pArgs->pListAreaCodes, pInfo->pListAreaCodes );
    }

    return TRUE;
}


VOID
AnTerm(
    IN HWND hwndDlg )

    // Dialog termination.
    //
{
    ANINFO* pInfo;

    TRACE( "AnTerm" );

    pInfo = (ANINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        // Release any PBPHONE nodes still in the list, e.g. if user Canceled.
        //
        if (pInfo->pNode)
        {
            AnListFromLv( pInfo );
            DestroyLinkNode( pInfo->pNode );
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}


VOID
AnUpdateButtons(
    IN ANINFO* pInfo )

    // Determine if the Up, Down, Edit, and Delete operations make sense and
    // enable/disable those buttons accordingly.  If a disabled button has
    // focus, focus is given to the ListView.  'PInfo' is the dialog context.
    //
{
    INT iSel;
    INT cItems;
    BOOL fSel;

    iSel = ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_SELECTED );
    fSel = (iSel >= 0);
    cItems = ListView_GetItemCount( pInfo->hwndLv );

    // "Up" button.
    //
    if (iSel > 0)
    {
        EnableWindow( pInfo->hwndPbUp, TRUE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbUp, FALSE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArrDis );
    }

    // "Down" button.
    //
    if (fSel && (iSel < cItems - 1))
    {
        EnableWindow( pInfo->hwndPbDown, TRUE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbDown, FALSE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArrDis );
    }

    // "Edit" and "Delete" buttons.
    //
    EnableWindow( pInfo->hwndPbEdit, fSel );
    EnableWindow( pInfo->hwndPbDelete, fSel );

    // If the focus button is disabled, move focus to the ListView and make OK
    // the default button.
    //
    if (!IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndLv );
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
    }
}


VOID
AnUpdateCheckboxes(
    IN ANINFO* pInfo )

    // Update so "move to top" checkbox is enabled only when "try next" is set
    // maintaining a restore state for "move to top".  'PInfo' is the dialog
    // context.
    //
{
    if (Button_GetCheck( pInfo->hwndCbTryNext ))
    {
        Button_SetCheck( pInfo->hwndCbMoveToTop, pInfo->fMoveToTop );
        EnableWindow( pInfo->hwndCbMoveToTop, TRUE );
    }
    else
    {
        pInfo->fMoveToTop = Button_GetCheck( pInfo->hwndCbMoveToTop );
        Button_SetCheck( pInfo->hwndCbMoveToTop, FALSE );
        EnableWindow( pInfo->hwndCbMoveToTop, FALSE );
    }
}


//----------------------------------------------------------------------------
// Phone number editor dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
EditPhoneNumberDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pPhoneNode,
    IN OUT DTLLIST* pListAreaCodes,
    IN DWORD sidTitle )

    // Popup a dialog to edit the phone number in 'pPhoneNode' and update the
    // area code list 'pListAreaCodes'.  'HwndOwner' is the owning window.
    // 'SidTitle' is the string ID of the title for the dialog.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.
    //
{
    INT_PTR nStatus;
    CEARGS args;

    TRACE( "EditPhoneNumberDlg" );

    args.pPhoneNode = pPhoneNode;
    args.pListAreaCodes = pListAreaCodes;
    args.sidTitle = sidTitle;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CE_ComplexPhoneEditor ),
            hwndOwner,
            CeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
CeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the phone number editor dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CeInit( hwnd, (CEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            CEINFO* pInfo = (CEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return CeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CeCommand(
    IN CEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_CE_CB_UseDialingRules:
        {
            if (CuDialingRulesCbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_CE_LB_CountryCodes:
        {
            if (CuCountryCodeLbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, CeSave( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CeInit(
    IN HWND hwndDlg,
    IN CEARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's link node argument as passed to the
    // stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    CEINFO* pInfo;
    DTLNODE* pNode;
    PBPHONE* pPhone;

    TRACE( "CeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndStAreaCodes =
        GetDlgItem( hwndDlg, CID_CE_ST_AreaCodes );
    ASSERT( pInfo->hwndStAreaCodes );

    pInfo->hwndClbAreaCodes =
        GetDlgItem( hwndDlg, CID_CE_CLB_AreaCodes );
    ASSERT( pInfo->hwndClbAreaCodes );

    pInfo->hwndEbPhoneNumber =
        GetDlgItem( hwndDlg, CID_CE_EB_PhoneNumber );
    ASSERT( pInfo->hwndEbPhoneNumber );

    pInfo->hwndLbCountryCodes =
        GetDlgItem( hwndDlg, CID_CE_LB_CountryCodes );
    ASSERT( pInfo->hwndLbCountryCodes );

    pInfo->hwndCbUseDialingRules =
        GetDlgItem( hwndDlg, CID_CE_CB_UseDialingRules );
    ASSERT( pInfo->hwndCbUseDialingRules );

    pInfo->hwndEbComment =
        GetDlgItem( hwndDlg, CID_CE_EB_Comment );
    ASSERT( pInfo->hwndEbComment );

    // Set title to caller's resource string.
    //
    {
        TCHAR* pszTitle;

        pszTitle = PszFromId( g_hinstDll, pArgs->sidTitle );
        if (pszTitle)
        {
            SetWindowText( hwndDlg, pszTitle );
            Free( pszTitle );
        }
    }

    // Make an edit copy of the argument node and area-code list.
    //
    pInfo->pNode = DuplicatePhoneNode( pArgs->pPhoneNode );
    if (!pInfo->pNode)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
        EndDialog( hwndDlg, FALSE );
        return TRUE;
    }

    pInfo->pPhone = (PBPHONE* )DtlGetData( pInfo->pNode );
    ASSERT( pInfo->pPhone );

    pInfo->pListAreaCodes = DtlDuplicateList(
        pArgs->pListAreaCodes, DuplicatePszNode, DestroyPszNode );

    // Initialize area-code/country-code helper context.
    //
    CuInit( &pInfo->cuinfo,
        pInfo->hwndStAreaCodes, pInfo->hwndClbAreaCodes,
        NULL, pInfo->hwndEbPhoneNumber,
        pInfo->hwndStCountryCodes, pInfo->hwndLbCountryCodes,
        pInfo->hwndCbUseDialingRules, NULL, 
        NULL,
        NULL, pInfo->hwndEbComment,
        pInfo->pListAreaCodes );

    pInfo->fCuInfoInitialized = TRUE;

    // Load the fields.
    //
    CuSetInfo( &pInfo->cuinfo, pInfo->pNode, FALSE );

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Initial focus is on the phone number.
    //
    Edit_SetSel( pInfo->hwndEbPhoneNumber, 0, -1 );
    SetFocus( pInfo->hwndEbPhoneNumber );

    return FALSE;
}


BOOL
CeSave(
    IN CEINFO* pInfo )

    // Load the contents of the dialog into caller's stub API output argument.
    // 'PInfo' is the dialog context.
    //
    // Returns true if succesful, false otherwise.
    //
{
    PBPHONE* pSrcPhone;
    PBPHONE* pDstPhone;

    TRACE( "CeSave" );

    // Load the settings in the controls into the edit node.
    //
    CuGetInfo( &pInfo->cuinfo, pInfo->pNode );

    // Copy the edit node to the stub API caller's argument node.
    //
    pDstPhone = (PBPHONE* )DtlGetData( pInfo->pArgs->pPhoneNode );
    pSrcPhone = pInfo->pPhone;

    pDstPhone->dwCountryCode = pSrcPhone->dwCountryCode;
    pDstPhone->dwCountryID = pSrcPhone->dwCountryID;
    pDstPhone->fUseDialingRules = pSrcPhone->fUseDialingRules;
    Free0( pDstPhone->pszPhoneNumber );
    pDstPhone->pszPhoneNumber = StrDup( pSrcPhone->pszPhoneNumber );
    Free0( pDstPhone->pszAreaCode );
    pDstPhone->pszAreaCode = StrDup( pSrcPhone->pszAreaCode );
    Free0( pDstPhone->pszComment );
    pDstPhone->pszComment = StrDup( pSrcPhone->pszComment );

    // Swap lists, saving updates to caller's global list of area codes.
    // Caller's original list will be destroyed by AnTerm.
    //
    if (pInfo->pListAreaCodes)
    {
        DtlSwapLists( pInfo->pArgs->pListAreaCodes, pInfo->pListAreaCodes );
    }

    return TRUE;
}


VOID
CeTerm(
    IN HWND hwndDlg )

    // Dialog termination.
    //
{
    CEINFO* pInfo;

    TRACE( "CeTerm" );

    pInfo = (CEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        if (pInfo->pNode)
        {
            DestroyPhoneNode( pInfo->pNode );
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

        if (pInfo->fCuInfoInitialized)
        {
            CuFree( &pInfo->cuinfo );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdial\src\rasdial.c ===
/*****************************************************************************/
/**                         Microsoft LAN Manager                           **/
/**                   Copyright (C) 1993 Microsoft Corp.                    **/
/*****************************************************************************/

//***
//    File Name:
//       RASDIAL.C
//
//    Function:
//        Command line interface for making Remote Access connections,
//        as well as disconnecting from and enumerating these connections.
//
//    History:
//        03/18/93 - Michael Salamone (MikeSa) - Original Version 1.0
//***


#ifdef UNICODE
#error This program is built ANSI-only so it will run, as is, on Chicago.
#undef UNICODE
#endif

#include <windows.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <io.h>

#include <lmcons.h>
#include <lmerr.h>

#include <mbstring.h>

#include <ras.h>
#include <raserror.h>

#include "rasdial.h"
#include "rasdial.rch"
#include <mprerror.h>


char g_progname[MAX_PATH + 1];
char g_username[UNLEN + 1];
char g_password[PWLEN + 1];
char g_domain[DNLEN + 1];
char g_entryname[RAS_MaxEntryName * sizeof( USHORT ) + 1];
char g_phone_num[RAS_MaxPhoneNumber + 1];
char g_callback_num[RAS_MaxCallbackNumber + 1];
char g_phone_book[MAX_PATH];
BOOL g_OpenPortBefore = FALSE;
BOOL g_UsePrefixSuffix = FALSE;

HANDLE g_hEvent;
DWORD g_exitcode;
BOOL g_fHangupCalled = FALSE;
PBYTE g_Args[9];
BOOL g_fNotDialAll = FALSE;


HRASCONN g_hRasConn = NULL;
DWORD g_dbg = 0;

DWORD dwSubEntries = 0;
PBOOLEAN pSubEntryDone = NULL;
BOOLEAN fSubEntryConnected = FALSE;

void _cdecl main(int argc, char *argv[])
{
    WORD len;
    UCHAR term;
    DWORD Action;
    BYTE ErrorMsg[1024];

    g_exitcode = 0L;

    Action = ParseCmdLine(argc, argv);

    switch (Action)
    {
        case HELP:
            Usage();
            break;


        case DIAL:
            //
            // Was username specified on command line?  If not, prompt for it.
            //
            if (!strcmp(g_username, "*"))
            {
                PrintMessage(DIAL_USERNAME_PROMPT, NULL);
                GetString(g_username, UNLEN + 1, &len, &term);
            }

            //
            // Was password specified on command line?  If not, prompt for it.
            //
            if (!strcmp(g_password, "*"))
            {
                PrintMessage(DIAL_PASSWORD_PROMPT, NULL);
                GetPasswdStr(g_password, PWLEN + 1, &len);
            }

            Dial();
            break;


        case DISCONNECT:
            Disconnect();
            break;


        case ENUMERATE_CONNECTIONS:
            EnumerateConnections();
            break;
    }


    if (g_exitcode)
    {
        if (     ((g_exitcode >= RASBASE) && (g_exitcode <= RASBASEEND))
            ||  ((g_exitcode >= ROUTEBASE) && (g_exitcode <= ROUTEBASEEND)))
        {
            BYTE str[10];

            g_Args[0] = _itoa(g_exitcode, str, 10);
            g_Args[1] = NULL;
            PrintMessage(DIAL_ERROR_PREFIX, g_Args);

            RasGetErrorStringA(g_exitcode, ErrorMsg, 1024L);

            CharToOemA(ErrorMsg, ErrorMsg);
            fprintf(stdout, ErrorMsg);

            PrintMessage(DIAL_MORE_HELP, g_Args);
        }
        else
        {
            FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS |
                    FORMAT_MESSAGE_MAX_WIDTH_MASK | FORMAT_MESSAGE_FROM_SYSTEM,
                    GetModuleHandle(NULL), g_exitcode, 0, ErrorMsg, 1024, NULL);

            CharToOemA(ErrorMsg, ErrorMsg);
            fprintf(stdout, ErrorMsg);
        }
    }
    else
    {
        PrintMessage(DIAL_COMMAND_SUCCESS, NULL);
    }

    exit(g_exitcode);
}


VOID Dial(VOID)
{
    DWORD rc;
    LPSTR pPhoneFile = NULL;
    RASDIALPARAMSA DialParms;
    RASDIALEXTENSIONS DialExts;
    RASDIALEXTENSIONS* pDialExts;
    RASEAPUSERIDENTITYA* pRasEapUserIdentity = NULL;
    DWORD NumEntries;
    RASCONNA *RasConn = NULL;
    RASCONNA *SaveRasConn = NULL;
    LPRASENTRY lpEntry;
    DWORD dwcbEntry, dwcbIgnored;


    //
    // This just gets us an array of RASCONN structs
    //
    if (Enumerate(&RasConn, &NumEntries))
    {
        return;
    }

    SaveRasConn = RasConn;


    while (NumEntries--)
    {
        if (!_mbscmp(g_entryname, RasConn->szEntryName))
        {
            g_Args[0] = RasConn->szEntryName;
            g_Args[1] = NULL;
            PrintMessage(DIAL_ALREADY_CONNECTED, g_Args);

            GlobalFree(SaveRasConn);
            return;
        }

        RasConn++;
    }

    GlobalFree(SaveRasConn);


    //
    // This is the structure we pass to RasDial
    //
    DialParms.dwSize = sizeof(RASDIALPARAMSA);

    strcpy(DialParms.szUserName, g_username);
    strcpy(DialParms.szPassword, g_password);

    strcpy(DialParms.szEntryName, g_entryname);
    strcpy(DialParms.szDomain, g_domain);
    strcpy(DialParms.szPhoneNumber, g_phone_num);
    strcpy(DialParms.szCallbackNumber, g_callback_num);

    ZeroMemory((PBYTE) &DialExts, sizeof(RASDIALEXTENSIONS));

    //
    // The parameter extension structure passed to RasDial
    //
    if (g_UsePrefixSuffix)
    {
        DialExts.dwSize = sizeof(DialExts);
        DialExts.dwfOptions = RDEOPT_UsePrefixSuffix;
#if DBG
        DialExts.dwfOptions |= (RDEOPT_IgnoreModemSpeaker/*|RDEOPT_SetModemSpeaker*/);
#endif
        DialExts.hwndParent = NULL;
        DialExts.reserved = 0;

        pDialExts = &DialExts;
    }
    else
        pDialExts = NULL;


    //
    // This event will get signaled in the RasDialCallback routine
    // once dial has completed (either successfully or because of error.
    //
    g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!g_hEvent)
    {
        g_exitcode = GetLastError();

#if DBG
        if (g_dbg)
            printf("Error creating event - rc=%li\n", g_exitcode);
#endif

        return;
    }


    //
    // We need a routine to handle CTRL-C, CTRL-BREAK, etc.
    //
    if (!SetConsoleCtrlHandler(DialControlSignalHandler, TRUE))
    {
#if DBG
        printf("SetConsoleCtrlHandler returned error\n");
#endif
    }


    if (g_phone_book[0])
    {
        pPhoneFile = g_phone_book;
    }

    //
    // Get the number of subentries in this connection.
    //
    rc = RasGetEntryProperties(
           pPhoneFile,
           g_entryname,
           NULL,
           &dwcbEntry,
           NULL,
           &dwcbIgnored);
    if (rc != ERROR_BUFFER_TOO_SMALL) {
        g_exitcode = rc;
        return;
    }
    lpEntry = LocalAlloc(LPTR, dwcbEntry);
    if (lpEntry == NULL) {
        rc = GetLastError();
        g_exitcode = rc;
        return;
    }
    lpEntry->dwSize = sizeof (RASENTRY);
    rc = RasGetEntryProperties(
           pPhoneFile,
           g_entryname,
           lpEntry,
           &dwcbEntry,
           NULL,
           &dwcbIgnored);
    if (rc) {
        g_exitcode = rc;
        return;
    }
    dwSubEntries = lpEntry->dwSubEntries;
#if DBG
    if (g_dbg)
        printf("%s has %d subentries\n", g_entryname, dwSubEntries);
#endif

    g_fNotDialAll = !(lpEntry->dwDialMode & RASEDM_DialAll);

    LocalFree(lpEntry);
    //
    // Allocate an array to keep the completion
    // status for each subentry.
    //
    pSubEntryDone = LocalAlloc(LPTR, dwSubEntries * sizeof (BOOLEAN));
    if (pSubEntryDone == NULL) {
        rc = GetLastError();
        g_exitcode = rc;
        return;
    }

    {
        rc = RasGetEapUserIdentity(
               pPhoneFile,
               g_entryname,
               RASEAPF_NonInteractive,
               NULL,
               &pRasEapUserIdentity);

        switch (rc)
        {
        case ERROR_INVALID_FUNCTION_FOR_ENTRY:

            break;

        case NO_ERROR:

            strcpy(DialParms.szUserName, pRasEapUserIdentity->szUserName);
            DialExts.dwSize = sizeof(DialExts);
            pDialExts = &DialExts;
            pDialExts->RasEapInfo.dwSizeofEapInfo =
                pRasEapUserIdentity->dwSizeofEapInfo;
            pDialExts->RasEapInfo.pbEapInfo =
                pRasEapUserIdentity->pbEapInfo;

            break;

        default:

            g_exitcode = rc;
            return;
        }
    }

    //
    // Now dial
    //
    if (rc = RasDialA(
            pDialExts, pPhoneFile, &DialParms, 2, RasDialFunc2,
            &g_hRasConn))
    {
        g_exitcode = rc;

#if DBG
        if (g_dbg)
            printf("Error from RasDial = %li\n", rc);
#endif

        RasFreeEapUserIdentity(pRasEapUserIdentity);
        return;
    }


#ifdef PRINTDOTS

    //
    // Now we just print "." every second until dial has completed.
    //
    while (1)
    {
        rc = WaitForSingleObject(g_hEvent, 1000L);
        if (rc == WAIT_TIMEOUT)
        {
            PrintMessage(DIAL_DOT, NULL);
        }
        else
        {
            break;
        }
    }

#else

    WaitForSingleObject(g_hEvent, INFINITE);

#endif

    if (g_fHangupCalled)
    {
        WaitForRasCompletion();
    }


    RasFreeEapUserIdentity(pRasEapUserIdentity);
    return;
}


VOID EnumerateConnections(VOID)
{
    DWORD NumEntries;
    RASCONNA *RasConn = NULL, *SaveRasConn;


    //
    // This just gets us an array of RASCONN structs
    //
    if (Enumerate(&RasConn, &NumEntries))
    {
        if(NULL != RasConn)
        {
            GlobalFree(RasConn);
        }
        return;
    }

    SaveRasConn = RasConn;


    //
    // Now, go thru array of RASCONN structs and print out each connection.
    //
    if (!NumEntries)
    {
        PrintMessage(DIAL_NO_CONNECTIONS, NULL);
    }
    else
    {
        PrintMessage(DIAL_ENUM_HEADER, NULL);

        while (NumEntries--)
        {
            g_Args[0] = RasConn->szEntryName;
            g_Args[1] = NULL;
            PrintMessage(DIAL_ENUM_ENTRY, g_Args);

            RasConn++;
        }
    }


    //
    // This was allocated for us by the Enumerate call above
    //
    GlobalFree(SaveRasConn);

    return;
}


VOID Disconnect(VOID)
{
    DWORD rc;
    DWORD NumEntries;
    RASCONNA *RasConn = NULL, *SaveRasConn;
    BOOL fFoundEntry = FALSE;


    //
    // This just gets us an array of RASCONN structs
    //
    if (Enumerate(&RasConn, &NumEntries))
    {
        if(NULL != RasConn)
        {
            GlobalFree(RasConn);
        }
        return;
    }

    SaveRasConn = RasConn;


    //
    // Now, go thru array of RASCONN structs searching for the
    // right entry to disconnect.
    //
    // Also, If no entryname specified on cmd line AND there
    // is only one connection, we'll set the entryname to that
    // one (thus having the effect of disconnecting that one).
    // If no entryname given AND more than one connection, we
    // won't disconnect anything - we'll enumerate the connections
    // and give the user an error message.
    //
    if (!g_entryname[0] & (NumEntries > 1))
    {
        PrintMessage(DIAL_DISCONNECT_ERROR, NULL);
        EnumerateConnections();

        goto Done;
    }


    if (!NumEntries)
    {
        PrintMessage(DIAL_NO_CONNECTIONS, NULL);

        goto Done;
    }


    if (!g_entryname[0] & (NumEntries == 1))
    {
        strcpy(g_entryname, RasConn->szEntryName);
    }


    while (NumEntries-- && !fFoundEntry)
    {
        if (!_mbsicmp(g_entryname, RasConn->szEntryName))
        {
            fFoundEntry = TRUE;

            if (!SetConsoleCtrlHandler(DisconnectControlSignalHandler, TRUE))
            {
#if DBG
                printf("SetConsoleCtrlHandler returned error\n");
#endif
            }

            if (rc = RasHangUpA(RasConn->hrasconn))
            {
                g_exitcode = rc;

#if DBG
                if (g_dbg)
                    printf("Error from RasHangUp = %li\n", rc);
#endif

            }

            WaitForRasCompletion();

            break;
        }

        RasConn++;
    }


    if (!fFoundEntry)
    {
        g_Args[0] = g_entryname;
        g_Args[1] = NULL;
        PrintMessage(DIAL_NOT_CONNECTED, g_Args);
    }


Done:

    //
    // This was allocated for us by the Enumerate call above
    //
    GlobalFree(SaveRasConn);


    return;
}


//
// To get array of RASCONN structures
//
DWORD Enumerate(RASCONNA **RasConn, PDWORD NumEntries)
{
    DWORD rc;
    DWORD EnumSize = 0L;

    *NumEntries = 0;

    *RasConn = (RASCONNA *) GlobalAlloc(GMEM_FIXED, sizeof(RASCONNA));
    if (!*RasConn)
    {
        g_exitcode = GetLastError();

#if DBG
        if (g_dbg)
            printf("No memory for enumerating connections!\n");
#endif

        *NumEntries = 0;
        return (1L);
    }

    (*RasConn)->dwSize = sizeof(RASCONNA);


    //
    // This first call will tell us how much space we need to
    // fit in all the structures.
    //
    rc = RasEnumConnectionsA(*RasConn, &EnumSize, NumEntries);
    if (!rc && !*NumEntries)
    {
        return (0L);
    }


    if (NumEntries && (rc != ERROR_BUFFER_TOO_SMALL))
    {
        g_exitcode = rc;

#if DBG
        if (g_dbg)
            printf("Error from RasEnumConnectionsA = %li!\n", rc);
#endif

        GlobalFree(*RasConn);
        *RasConn = NULL;

        *NumEntries = 0;
        return (1L);
    }

    //
    // Now we get memory for the structures.
    //
    GlobalFree(*RasConn);
    *RasConn = (RASCONNA *) GlobalAlloc(GMEM_FIXED, EnumSize);

    if (!*RasConn)
    {
        g_exitcode = GetLastError();

#if DBG
        if (g_dbg)
            printf("No memory for enumerating connections!\n");
#endif

        *NumEntries = 0;
        return (1L);
    }


    (*RasConn)->dwSize = sizeof(RASCONNA);

    //
    // This second call will now fill up our buffer with the
    // RASCONN structures.
    //
    if (rc = RasEnumConnectionsA(*RasConn, &EnumSize, NumEntries))
    {
        g_exitcode = rc;

#if DBG
        if (g_dbg)
            printf("Error from RasEnumConnectionsA = %li!\n", rc);
#endif

        *NumEntries = 0;
        GlobalFree(*RasConn);
        *RasConn = NULL;

        return (1L);
    }

    return (0L);
}


VOID Usage(VOID)
{
    g_Args[0] = g_progname;
    g_Args[1] = NULL;
    PrintMessage(DIAL_USAGE, g_Args);

    return;
}


DWORD ParseCmdLine(int argc, char *argv[])
{
    int i;
    BYTE CmdLineSwitch[80];
    PCHAR pColon;


    strcpy(g_progname, argv[0]);

    //
    // Set up defaults for these, in case switch isn't given on the
    // command line for them.
    //
    g_username[0] = '\0';       // means use name user is logged on with
    g_password[0] = '\0';       // means use password user is logged on with
    strcpy(g_domain, "*");      // means use domain stored in phonebook
    g_phone_num[0] = '\0';      // means use phone number stored in phonebook
    g_phone_book[0] = '\0';     // means use default phone book file
    g_callback_num[0] = '\0';   // means don't callback if user-specified
    g_UsePrefixSuffix = FALSE;  // means don't use prefix/suffix, if defined


    if (argc == 1)
    {
        //
        // In this case, only the name of the program was specified,
        // which means all we have to do is enumerate connections.
        //
        return (ENUMERATE_CONNECTIONS);
    }


    //
    // see if an entryname is present (must be 1st argument if it is)
    //
    if (is_valid_entryname(argv[1]))
    {
        //
        // We have a valid entryname - user either wants to dial to
        // it or disconnect from it.
        //

        strcpy(g_entryname, argv[1]);
        _mbsupr(g_entryname);
        LoadStringA(GetModuleHandle(NULL), DIAL_DISCONNECT_SWITCH,
                CmdLineSwitch, 80);
        if ((argc == 3) && (argv[2][0] == '/') && (strlen(&argv[2][1])) &&
                match(&argv[2][1], CmdLineSwitch))
        {
            return (DISCONNECT);
        }
        else
        {
            if ((argc > 3) && (argv[2][0] == '/') && (strlen(&argv[2][1])) &&
                    match(&argv[2][1], CmdLineSwitch))
            {
                return (HELP);
            }
        }


        //
        // User wants to connect - get username, password, and options
        //

        //
        // Username specified?  If next arg doesn't start with "/", then
        // YEA!.  If it does, then neither username or password are
        // specified.
        //
        if ((argc > 2) && (argv[2][0] != '/'))
        {
            if (strlen(argv[2]) > UNLEN)
            {
                return (HELP);
            }

            strcpy(g_username, argv[2]);


            //
            // Password specified?  If next arg doesn't start with "/", then
            // YEA!.
            //
            if ((argc > 3) && (argv[3][0] != '/'))
            {
                if (strlen(argv[3]) > PWLEN)
                {
                    return (HELP);
                }

                strcpy(g_password, argv[3]);
                i = 4;
            }
            else
            {
                i = 3;
            }
        }
        else
        {
            //
            // No username or password specified
            //
            i = 2;
        }


        //
        // Now get any other options.  If any cmd line switch is
        // invalid, or is specified more than once, we'll bail
        // out.
        //
        for (; i<argc; i++)
        {
            BOOL fDomainSpecified = FALSE;
            BOOL fCallbackSpecified = FALSE;


            //
            // Command line switched must be designated by '/'!
            if (argv[i][0] != '/')
            {
                return (HELP);
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_DOMAIN_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                //
                // Switch previously specified?
                //
                if (fDomainSpecified)
                {
                    return (HELP);
                }

                fDomainSpecified = TRUE;

                pColon = strchr(argv[i], ':');
                if (pColon)
                {
                    strncpy(g_domain, pColon+1, DNLEN);
                    g_domain[DNLEN] = '\0';
                    _strupr(g_domain);
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_PHONE_NO_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                //
                // Switch previously specified?
                //
                if (g_phone_num[0])
                {
                    return (HELP);
                }

                pColon = strchr(argv[i], ':');
                if (pColon && strlen(pColon+1))
                {
                    strncpy(g_phone_num, pColon+1, RAS_MaxPhoneNumber);
                    g_phone_num[RAS_MaxPhoneNumber] = '\0';
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_PHONE_BOOK_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                OFSTRUCT of_struct;

                //
                // Switch previously specified?
                //
                if (g_phone_book[0])
                {
                    return (HELP);
                }


                //
                // This is the default path for the phone book file.
                // Our method is, if the phone book switch is supplied,
                // we will append it to this string and check for file
                // existence.  If it does not exist, we will test for
                // existence of the literal value supplied.  If that
                // still does not exist, we give a help message and exit.
                //
                ExpandEnvironmentStringsA("%windir%\\system32\\ras\\",
                        g_phone_book, MAX_PATH);

                pColon = strchr(argv[i], ':');
                if (pColon && strlen(pColon+1))
                {
                    if ((strlen(pColon+1) + strlen(g_phone_book)) > MAX_PATH-1)
                    {
                        //
                        // The catenated string would exceed MAX_PATH, so
                        // forget it - just use the string supplied.
                        //
                        strncpy(g_phone_book, pColon+1, MAX_PATH);
                        g_phone_book[MAX_PATH] = '\0';
                    }
                    else
                    {
                        strcat(g_phone_book, pColon+1);
                        if (OpenFile(g_phone_book, &of_struct, OF_EXIST) ==
                                HFILE_ERROR)
                        {
                            //
                            // The file doesn't exist in the default directory,
                            // so we'll use the value supplied straight away.
                            //
                            strncpy(g_phone_book, pColon+1, MAX_PATH);
                            g_phone_book[MAX_PATH] = '\0';
                        }
                    }

                    // OpenFile here previously removed, so the case falls thru
                    // and sets exit code correctly.  See bug 73798.
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_CALLBACK_NO_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                //
                // Switch previously specified?
                //
                if (fCallbackSpecified)
                {
                    return (HELP);
                }

                fCallbackSpecified = TRUE;

                pColon = strchr(argv[i], ':');
                if (pColon && strlen(pColon+1))
                {
                    strncpy(g_callback_num, pColon+1, RAS_MaxCallbackNumber);
                    g_callback_num[RAS_MaxCallbackNumber] = '\0';
                }
                else
                {
                    return (HELP);
                }

                continue;
            }


            LoadStringA(GetModuleHandle(NULL), DIAL_PREFIXSUFFIX_SWITCH,
                    CmdLineSwitch, 80);
            if (match(&argv[i][1], CmdLineSwitch))
            {
                g_UsePrefixSuffix = TRUE;
                continue;
            }


            //
            // Invalid switch, so we're out of here
            //
            return (HELP);
        }

        return (DIAL);
    }
    else
    {
        //
        // since no entryname was specified, there are 2 possibilities:
        //    1. user wants help
        //    2. user wants to disconnect
        //
        LoadStringA(GetModuleHandle(NULL), DIAL_HELP_SWITCH,
                CmdLineSwitch, 80);
        if (match(&argv[1][1], CmdLineSwitch))
        {
            return (HELP);
        }

        LoadStringA(GetModuleHandle(NULL), DIAL_DISCONNECT_SWITCH,
                CmdLineSwitch, 80);
        if (match(&argv[1][1], CmdLineSwitch))
        {
            //
            // Ok, user wants to disconnect, but we don't know what the
            // entryname is.  We'll just put in blank for now.
            //
            g_entryname[0] = '\0';

            if (argc == 2)
            {
                return (DISCONNECT);
            }
            else
            {
                return (HELP);
            }
        }


        //
        // Invalid command line if we get here
        //
        return (HELP);
    }
}


BOOLEAN
AllSubEntriesCompleted(VOID)
{
    DWORD i;
    BOOLEAN bCompleted = TRUE;

    for (i = 0; i < dwSubEntries; i++) {
#if DBG
        if (g_dbg)
            printf("pSubEntryDone[%d]=%d\n", i, pSubEntryDone[i]);
#endif
        if (!pSubEntryDone[i]) {
            bCompleted = FALSE;
            break;
        }
    }
    return bCompleted;
}


DWORD WINAPI
RasDialFunc2(
    DWORD        dwCallbackId,
    DWORD        dwSubEntry,
    HRASCONN     hrasconn,
    UINT         unMsg,
    RASCONNSTATE state,
    DWORD        dwError,
    DWORD        dwExtendedError
    )
{
#if DBG
    if (g_dbg)
        printf("%d: state=%d, dwError=%d\n", dwSubEntry, state, dwError);
#endif

    if (dwError ||
        state == RASCS_SubEntryDisconnected ||
        state == RASCS_Disconnected)
    {
        DWORD i, dwErr;
        HRASCONN hrassubcon;
        BOOLEAN bDropConnection = TRUE;

        pSubEntryDone[dwSubEntry - 1] = TRUE;

        if ((   !g_fNotDialAll
            &&  AllSubEntriesCompleted())
            ||  g_fNotDialAll
            ||  state == RASCS_Disconnected) {
#ifdef DBG
            if (g_dbg)
                printf("hanging up connection\n");
#endif

            if (!fSubEntryConnected) {
                g_exitcode = dwError;

                RasHangUpA(g_hRasConn);
                g_fHangupCalled = TRUE;

            }

            SetEvent(g_hEvent);
        }

        return 1;
    }


    switch (state)
    {
        case RASCS_OpenPort:
            g_Args[0] = g_entryname;
            g_Args[1] = NULL;
            if (g_OpenPortBefore)
                PrintMessage(DIAL_CONNECTING2, g_Args);
            else
            {
                PrintMessage(DIAL_CONNECTING, g_Args);
                g_OpenPortBefore = TRUE;
            }
            break;

        case RASCS_PortOpened:
        case RASCS_ConnectDevice:
        case RASCS_DeviceConnected:
        case RASCS_AllDevicesConnected:
            break;

        case RASCS_Authenticate:
            PrintMessage(DIAL_AUTHENTICATING, NULL);
            break;

        case RASCS_ReAuthenticate:
            PrintMessage(DIAL_REAUTHENTICATING, NULL);
            break;

        case RASCS_AuthNotify:
        case RASCS_AuthCallback:
        case RASCS_AuthAck:
        case RASCS_AuthChangePassword:
        case RASCS_AuthRetry:
            break;

        case RASCS_AuthProject:
            PrintMessage(DIAL_PROJECTING, NULL);
            break;

        case RASCS_AuthLinkSpeed:
            PrintMessage(DIAL_LINK_SPEED, NULL);
            break;

        case RASCS_Authenticated:
            //PrintMessage(DIAL_NEWLINE, NULL);
            break;

        case RASCS_PrepareForCallback:
            PrintMessage(DIAL_CALLBACK, NULL);
            break;

        case RASCS_WaitForModemReset:
        case RASCS_WaitForCallback:
            break;

        case RASCS_Interactive:
        case RASCS_RetryAuthentication:
        case RASCS_CallbackSetByCaller:
        case RASCS_PasswordExpired:
        {
            BYTE str[8];

            g_Args[0] = _itoa(state, str, 10);
            g_Args[1] = NULL;
            PrintMessage(DIAL_AUTH_ERROR, g_Args);

            RasHangUpA(g_hRasConn);
            g_fHangupCalled = TRUE;

            SetEvent(g_hEvent);
            break;
        }

        case RASCS_SubEntryConnected:
        case RASCS_Connected:
            fSubEntryConnected = TRUE;
            pSubEntryDone[dwSubEntry-1] = TRUE;
            if (    AllSubEntriesCompleted()
                ||  g_fNotDialAll) {
                g_Args[0] = g_entryname;
                g_Args[1] = NULL;
                PrintMessage(DIAL_CONNECT_SUCCESS, g_Args);
                SetEvent(g_hEvent);
            }

            break;

        case RASCS_Disconnected:
            PrintMessage(DIAL_DISCONNECTED, NULL);
            SetEvent(g_hEvent);
            break;
    }


    return 1;
}


BOOL DialControlSignalHandler(DWORD ControlType)
{
    //
    // Do we have a handle back from Rasdial call?
    //
    if (g_hRasConn)
    {
        RasHangUpA(g_hRasConn);
    }

    WaitForRasCompletion();

    PrintMessage(DIAL_CONTROL_C, NULL);

    exit(1L);

    return (TRUE);    // have to satisfy the compiler, you know.
}


BOOL DisconnectControlSignalHandler(DWORD ControlType)
{
    return (TRUE);
}


VOID WaitForRasCompletion(VOID)
{
    RASCONNSTATUSA Status;

    Status.dwSize = sizeof(RASCONNSTATUSA);

    while (RasGetConnectStatusA(g_hRasConn, &Status) != ERROR_INVALID_HANDLE)
    {
        Sleep(125L);
    }
}


BOOL is_valid_entryname(char *candidate)
{
    if (_mbslen(candidate) > RAS_MaxEntryName)
    {
        return (FALSE);
    }

    if (candidate[0] == '/')
    {
        return (FALSE);
    }

    return (TRUE);
}


//
// Returns TRUE if str1 is a substr of str2, starting at the beginning
// of str2 and ignoring case.  I.e. "Mike" will match "MIKESA".  "MIKESA"
// will not match "Mike"
//
BOOL match(
    char *str1,
    char *str2
    )
{
    BOOL retval;
    char *tstr1;
    char *tstr2;
    char *pcolon;

    tstr1 = (char *) GlobalAlloc(GMEM_FIXED, strlen(str1) + 1);
    if (!tstr1)
    {
        return (FALSE);
    }

    tstr2 = (char *) GlobalAlloc(GMEM_FIXED, strlen(str2) + 1);
    if (!tstr2)
    {
        GlobalFree(tstr1);
        return (FALSE);
    }


    strcpy(tstr1, str1);
    strcpy(tstr2, str2);

    _strupr(tstr1);
    _strupr(tstr2);

    pcolon = strchr(tstr1, ':');
    if (pcolon)
    {
        *pcolon = '\0';
    }

    if (strstr(tstr2, tstr1) == tstr2)
    {
        retval = TRUE;
    }
    else
    {
        retval = FALSE;
    }

    GlobalFree(tstr1);
    GlobalFree(tstr2);

    return (retval);
}


/***    GetPasswdStr -- read in password string
 *
 *      USHORT LUI_GetPasswdStr(char far *, USHORT);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.
 *
 *      History:
 *              who     when    what
 *              erichn  5/10/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              erichn  7/04/89 handles backspaces
 *              danhi   4/16/91 32 bit version for NT
 */
#define CR              0xD
#define BACKSPACE       0x8

USHORT GetPasswdStr(
    UCHAR *buf,
    USHORT buflen,
    USHORT *len
    )
{
    USHORT ch;
    CHAR *bufPtr = buf;

    buflen -= 1;    // make space for null terminator
    *len = 0;       // GP fault probe (a la API's)

    while (TRUE)
    {
        ch = LOWORD(_getch());                   // grab char silently
        if ((ch == CR) || (ch == 0xFFFF))       // end of the line
        {
            break;
        }

        if (ch == BACKSPACE)    // back up one or two
        {
            //
            // IF bufPtr == buf then the next two lines are
            // a no op.
            //
            if (bufPtr != buf)
            {
                bufPtr--;
                (*len)--;
            }
            continue;           // bail out, start loop over
        }

        *bufPtr = (UCHAR) ch;

        bufPtr += (*len < buflen) ? 1 : 0;   // don't overflow buf
        (*len)++;               // always increment len
    }

    *bufPtr = '\0';             // null terminate the string

    putchar('\n');

    return((*len <= buflen) ? (USHORT) 0 : (USHORT) NERR_BufTooSmall);
}


#define MAX_ARGS 9

VOID PrintMessage(
    DWORD MsgId,
    PBYTE *pArgs
    )
{
    DWORD NumArgs;
    DWORD BufSize;
    BOOL BufAllocated = FALSE;
    PBYTE Buf;
    PBYTE *pTmpArgs;
    PBYTE pSub;
    BYTE MsgBuf[256];
    PBYTE pMsgBuf = MsgBuf;

    if (!LoadStringA(GetModuleHandle(NULL), MsgId, MsgBuf, sizeof(MsgBuf)))
    {
        return;
    }

    if (pArgs)
    {
        //
        // Find out how many arguments were passed in.  We do this to detect
        // if the string requires a parameter that wasn't supplied.  If that
        // happens, we just won't substitute anything.
        //
        for (NumArgs=0, pTmpArgs=pArgs; *pTmpArgs!=NULL; NumArgs++, pTmpArgs++);

        if (NumArgs >= MAX_ARGS)
        {
            return;
        }


        //
        // We'll figure out how large our buffer should be to contain the
        // final output (length of string + sum(length of substitution params)
        //
        BufSize = strlen(MsgBuf) + 1;

        while (pSub = strchr(pMsgBuf, '%'))
        {
            DWORD Num = *(pSub+1) - '0';
            if (Num >=1 && Num <=NumArgs)
            {
                BufSize += strlen(pArgs[Num-1]) - 2;

                pMsgBuf = pSub+2;
            }
            else
            {
                pMsgBuf = pSub+1;
            }
        }


        //
        // Get space for our buffer (we multiply by 2 because we want buf to
        // be big enough for Oem character set.
        //
        Buf = GlobalAlloc(GMEM_FIXED, BufSize * 2);
        if (!Buf)
        {
            return;
        }

        BufAllocated = TRUE;


        Buf[0] = '\0';
        pMsgBuf = MsgBuf;


        //
        // Now make our final output buffer.  Strategy is to strcat
        // the first part of the string up to where the 1st substitution
        // goes, then strcat the substitution param.  Do this until no
        // more substitutions.
        //
        while (pSub = strchr(pMsgBuf, '%'))
        {
            DWORD Num = *(pSub+1) - '0';
            if (Num >=1 && Num <=NumArgs)
            {
                *pSub = '\0';

                strcat(Buf, pMsgBuf);
                strcat(Buf, pArgs[Num-1]);

                pMsgBuf = pSub+2;
            }
            else
            {
                strcat(Buf, pMsgBuf);
                strcat(Buf, pArgs[Num-1]);

                pMsgBuf = pSub+1;
            }
        }

        //
        // Now get everything after the last substitution.
        //
        if (*pMsgBuf)
        {
            strcat(Buf, pMsgBuf);
        }
    }
    else
    {
        Buf = MsgBuf;
    }

    CharToOemA(Buf, Buf);

    fprintf(stdout, Buf);

    if (BufAllocated)
    {
        GlobalFree(Buf);
    }

    return;
}


/***    GetString -- read in string with echo
 *
 *      USHORT LUI_GetString(char far *, USHORT, USHORT far *, char far *);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *              &terminator     holds the char used to terminate the string
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.  Len is ALWAYS valid.
 *
 *      OTHER EFFECTS:
 *              len is set to hold number of bytes typed, regardless of
 *              buffer length.  Terminator (Arnold) is set to hold the
 *              terminating character (newline or EOF) that the user typed.
 *
 *      Read in a string a character at a time.  Is aware of DBCS.
 *
 *      History:
 *              who     when    what
 *              erichn  5/11/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              danhi   3/20/91 ported to 32 bits
 */

USHORT GetString(
    register UCHAR *buf,
    register USHORT buflen,
    register USHORT *len,
    register UCHAR *terminator
    )
{
    buflen -= 1;                        // make space for null terminator
    *len = 0;                           // GP fault probe (a la API's)

    while (TRUE)
    {
        *buf = (UCHAR) getchar();
        if (*buf == '\n' || *buf == (UCHAR) EOF)
        {
            break;
        }

        buf += (*len < buflen) ? 1 : 0; // don't overflow buf
        (*len)++;                       // always increment len
    }

    *terminator = *buf;                 // set terminator
    *buf = '\0';                        // null terminate the string

    return ((*len <= buflen) ? (USHORT) 0 : (USHORT) NERR_BufTooSmall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\autodial.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// autodial.c
// Remote Access Common Dialog APIs
// Autodial APIs, currently private
//
// 11/19/95 Steve Cobb


#include "rasdlgp.h"
#include "shlobjp.h"


//-----------------------------------------------------------------------------
// Local datatypes
//-----------------------------------------------------------------------------

// Auto-dial query dialog argument block.
//
typedef struct
_AQARGS
{
    WCHAR* pszDestination;
    WCHAR* pszEntry;
    WCHAR* pszNewEntry;  // points a buffer at least [RAS_MaxEntryName + 1]
    DWORD  dwTimeout;
    UINT_PTR nIdTimer;   //add for bug 336524       gangz
}
AQARGS;


// Auto-dial query dialog context block.
//
typedef struct
_AQINFO
{
    // RAS API arguments.
    //
    AQARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStText;
    HWND hwndAqPbNo;
    HWND hwndAqPbSettings;
    HWND hwndAqLvConnections;
}
AQINFO;


//-----------------------------------------------------------------------------
// External entry points
//-----------------------------------------------------------------------------

DWORD APIENTRY
RasAutodialQueryDlgA(
    IN HWND hwndOwner,
    IN LPSTR lpszDestination,
    IN LPSTR lpszEntry,
    IN DWORD dwTimeout,
    OUT LPSTR lpszEntryUserSelected);

BOOL APIENTRY
RasAutodialDisableDlgA(
    IN HWND hwndOwner );

DWORD
APIENTRY
RasUserPrefsDlgAutodial (
    HWND hwndParent);

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
AqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
AqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
AqInit(
    IN HWND hwndDlg,
    IN AQARGS* pArgs );
    
LVXDRAWINFO*
AqLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem );
    
BOOL
AqNotify(
    HWND hwnd, 
    int idCtrl, 
    LPNMHDR pnmh);
    
VOID
AqTerm(
    IN HWND hwndDlg );

//Add the timer function for bug 336524
//
BOOL
AqTimer(
    IN HWND hwndDlg );

INT_PTR CALLBACK
DqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
DqInit(
    IN HWND hwndDlg );


//-----------------------------------------------------------------------------
// Auto-Dial Query dialog Listed alphabetically following API and dialog proc
//-----------------------------------------------------------------------------

DWORD APIENTRY
RasAutodialQueryDlgW(
    IN HWND  hwndOwner,
    IN LPWSTR lpszDestination,
    IN LPWSTR lpszEntry,
    IN DWORD dwTimeout,
    OUT PWCHAR lpszNewEntry)

    // Private external entry point to popup the Auto-Dial Query, i.e. the
    // "Cannot reach 'pszDestination'.  Do you want to dial?" dialog.
    // 'HwndOwner' is the owning window or NULL if none.  'PszDestination' is
    // the network address that triggered the auto-dial for display.
    // 'DwTimeout' is the initial seconds on the countdown timer that ends the
    // dialog with a "do not dial" selection on timeout, or 0 for none.
    //
    // Returns true if user chooses to dial, false otherwise.
    //
{
    INT_PTR nStatus;
    AQARGS args;
    DWORD dwErr = NO_ERROR;

    TRACE1( "RasAutodialQueryDlgW(t=%d)", dwTimeout );

    ZeroMemory(&args, sizeof(args));
    args.dwTimeout = dwTimeout;
    args.pszDestination = StrDup( lpszDestination );
    args.pszNewEntry = lpszNewEntry;
    if (lpszEntry)
    {
        args.pszEntry = StrDup( lpszEntry );
    }        

    if (args.pszDestination == NULL)
    {
        Free0(args.pszEntry);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_AQ_AutoDialQuery ),
            hwndOwner,
            AqDlgProc,
            (LPARAM )&args );

    Free0( args.pszDestination );
    Free0( args.pszEntry );

    if (nStatus == -1)
    {
        dwErr = GetLastError();
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, dwErr, NULL );
        nStatus = FALSE;
    }
    else
    {
        dwErr = (DWORD)nStatus;
    }

    return dwErr;
}

DWORD APIENTRY
RasAutodialQueryDlgA(
    IN HWND  hwndOwner,
    IN LPSTR lpszDestination,
    IN LPSTR lpszEntry,
    IN DWORD dwTimeout,
    OUT LPSTR lpszEntryUserSelected)

    // Private external entry point to popup the Auto-Dial Query, i.e. the
    // "Cannot reach 'pszDestination'.  Do you want to dial?" dialog.
    // 'HwndOwner' is the owning window or NULL if none.  'PszDestination' is
    // the network address that triggered the auto-dial for display.
    // 'DwTimeout' is the initial seconds on the countdown timer that ends the
    // dialog with a "do not dial" selection on timeout, or 0 for none.
    //
    // Returns true if user chooses to dial, false otherwise.
    //
{
    WCHAR* pszDestinationW = NULL, *pszEntryW = NULL;
    WCHAR pszNewEntryW[RAS_MaxEntryName + 1];
    BOOL dwErr = ERROR_NOT_ENOUGH_MEMORY;

    pszNewEntryW[0] = L'\0';
    pszDestinationW = StrDupWFromAUsingAnsiEncoding( lpszDestination );
    if ( lpszEntry )
    {
        pszEntryW = StrDupWFromAUsingAnsiEncoding ( lpszEntry );
    }        

    if (NULL != pszDestinationW)
    {
        dwErr = RasAutodialQueryDlgW(
                    hwndOwner, 
                    pszDestinationW, 
                    pszEntryW, 
                    dwTimeout, 
                    pszNewEntryW);
                    
        Free( pszDestinationW );
    }    

    Free0( pszEntryW );

    StrCpyAFromWUsingAnsiEncoding(
        lpszEntryUserSelected,
        pszNewEntryW,
        sizeof(pszNewEntryW) / sizeof(WCHAR));
    
    return dwErr;
}

INT_PTR CALLBACK
AqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Auto-Dial Query dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, AqLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return AqInit( hwnd, (AQARGS* )lparam );
        }

        case WM_COMMAND:
        {
            return AqCommand(
               hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_NOTIFY:
        {
            return AqNotify(hwnd, (int)wparam, (LPNMHDR) lparam);
        }

        case WM_TIMER:
        {
            return AqTimer( hwnd );
        }

        case WM_DESTROY:
        {
            AqTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
AqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;
    INT iSelected;
    AQINFO* pInfo = NULL;

    TRACE3( "AqCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    pInfo = (AQINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
    
    switch (wId)
    {
        case CID_AQ_PB_Settings:
        {
            if (pInfo)
            {

                //For whistler bug 357164       gangz
                // Save the "disable current session" checkbox, 
                //
                {
                     DWORD dwFlag = (DWORD )IsDlgButtonChecked(
                                                   hwnd, 
                                                   CID_AQ_CB_DisableThisSession );

                    dwErr = g_pRasSetAutodialParam( 
                                RASADP_LoginSessionDisable,
                                &dwFlag, 
                                sizeof(dwFlag) );
                }
            
                //For whistler bug 336524
                //Kill the timer
                ASSERT( pInfo->pArgs );
                if( pInfo->pArgs->nIdTimer )
                {
                    KillTimer( hwnd, 
                           pInfo->pArgs->nIdTimer );
                           
                    pInfo->pArgs->nIdTimer = 0;
                }
                
                RasUserPrefsDlgAutodial(pInfo->hwndDlg);

             //For whistler bug 357164       gangz
             // Initialize the "disable current session" checkbox
             //
            {
                DWORD dwFlag = FALSE, dwErr = NO_ERROR;
                DWORD cb = sizeof(dwFlag);
            
                dwErr = g_pRasGetAutodialParam(
                                        RASADP_LoginSessionDisable, 
                                        &dwFlag, 
                                        &cb );
            
                CheckDlgButton( 
                    hwnd, 
                    CID_AQ_CB_DisableThisSession, 
                    (BOOL )dwFlag );
                }
                
            }                
            
            return TRUE;
        }

        case CID_AQ_PB_Dial:
        case CID_AQ_PB_DoNotDial:
        {
            TRACE( "(No)Dial pressed" );

            if (wId == CID_AQ_PB_Dial && pInfo)
            {
                iSelected = 
                    ListView_GetSelectionMark(pInfo->hwndAqLvConnections);

                // If user does not select a connection, then default to the 
                // first one.  Alternatively, an error popup could be 
                // raised here but that is annoying.
                //
                if (iSelected == -1)
                {
                    iSelected = 0;                    
                }

                // Get the name of the selected connection
                //
                if (pInfo)
                {
                    ListView_GetItemText(
                        pInfo->hwndAqLvConnections,
                        iSelected,
                        0,
                        pInfo->pArgs->pszNewEntry,
                        RAS_MaxEntryName + 1);
                }                        
            }

            //For whistler bug 357164       gangz
            // Save the "disable current session" checkbox, 
            //
            {
                 DWORD dwFlag = (DWORD )IsDlgButtonChecked(
                                                   hwnd, 
                                                   CID_AQ_CB_DisableThisSession );

                dwErr = g_pRasSetAutodialParam( 
                            RASADP_LoginSessionDisable,
                            &dwFlag, 
                            sizeof(dwFlag) );
            }
        
            EndDialog( hwnd, (wId == CID_AQ_PB_Dial) ? NO_ERROR : ERROR_CANCELLED );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, ERROR_CANCELLED );
            return TRUE;
        }
    }

    return FALSE;
}

// Fills the list view of connections and selects the appropriate one to 
// dial
//
DWORD
AqFillListView(
    IN AQINFO* pInfo)
{
    DWORD dwErr = NO_ERROR, cb, cEntries = 0, i;
    RASENTRYNAME ren, *pRasEntryNames = NULL;
    LVITEM lvItem;
    INT iIndex, iSelect = 0;

    do
    {
        // Enumerate entries across all phonebooks. 
        //
        cb = ren.dwSize = sizeof(RASENTRYNAME);
        ASSERT( g_pRasEnumEntries );
        dwErr = g_pRasEnumEntries(NULL, NULL, &ren, &cb, &cEntries);

        // If there are no entries, then we return an error to signal that
        // there is no point to the dialog.
        //
        if ((SUCCESS == dwErr) && (0 == cEntries))
        {
            dwErr = ERROR_CANCELLED;
            break;
        }

        // Allocate a buffer to receive the connections
        //
        if(     (   (ERROR_BUFFER_TOO_SMALL == dwErr)
                ||   (SUCCESS == dwErr))
            &&  (cb >= sizeof(RASENTRYNAME)))
        {
            pRasEntryNames = (RASENTRYNAME *) Malloc(cb);
            if(NULL == pRasEntryNames)
            {
                // Nothing else can be done in this case
                //
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            pRasEntryNames->dwSize = sizeof(RASENTRYNAME);
            dwErr = g_pRasEnumEntries(NULL, NULL, pRasEntryNames, &cb, &cEntries);
            if ( NO_ERROR != dwErr )
            {
                break;
            }
        }
        else
        {
            break;
        }

        // Initialize the list view
        //
        if (ListView_GetItemCount( pInfo->hwndAqLvConnections ) == 0)
        {
            // Add a single column exactly wide enough to fully display
            // the widest member of the list.
            //
            LV_COLUMN col;

            ZeroMemory( &col, sizeof(col) );
            col.mask = LVCF_FMT;
            col.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( pInfo->hwndAqLvConnections, 0, &col );
            ListView_SetColumnWidth( 
                pInfo->hwndAqLvConnections, 
                0, 
                LVSCW_AUTOSIZE_USEHEADER );
        }
        else
        {
            ListView_DeleteAllItems( pInfo->hwndAqLvConnections );
        }

        // Fill the list view
        //
        for (i = 0; i < cEntries; i++)
        {
            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT;
            lvItem.pszText = pRasEntryNames[i].szEntryName;
            lvItem.iItem = i;
            iIndex = ListView_InsertItem( pInfo->hwndAqLvConnections, &lvItem );
            if ((pInfo->pArgs->pszEntry) &&
                (wcsncmp(
                    pInfo->pArgs->pszEntry, 
                    pRasEntryNames[i].szEntryName,
                    sizeof(pRasEntryNames[i].szEntryName) / sizeof(WCHAR)) == 0))
            {
                iSelect = (iIndex != -1) ? iIndex : 0;
            }
        }
    }while (FALSE);

    // Select the appropriate connection
    //
    ListView_SetItemState( 
        pInfo->hwndAqLvConnections, 
        iSelect, 
        LVIS_SELECTED | LVIS_FOCUSED, 
        LVIS_SELECTED | LVIS_FOCUSED);

    // Cleanup
    {
        Free0(pRasEntryNames);
    }

    return dwErr;
}

BOOL
AqInit(
    IN HWND hwndDlg,
    IN AQARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the RAS API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    AQINFO* pInfo;

    TRACE( "AqInit" );

    // Load the Rasapi32Dll so that we can enumerate connections
    // and set autodial properties
    //
    dwErr = LoadRasapi32Dll();
    if (dwErr != NO_ERROR)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, dwErr, NULL );
        EndDialog( hwndDlg, FALSE);
        return TRUE;
    }
    
    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "AQ: Context set" );
    }

    pInfo->hwndStText = GetDlgItem( hwndDlg, CID_AQ_ST_Text );
    ASSERT( pInfo->hwndStText );
    pInfo->hwndAqPbNo = GetDlgItem( hwndDlg, CID_AQ_PB_DoNotDial );
    ASSERT( pInfo->hwndAqPbNo );
    pInfo->hwndAqPbSettings = GetDlgItem( hwndDlg, CID_AQ_PB_Settings );
    ASSERT( pInfo->hwndAqPbSettings );
    pInfo->hwndAqLvConnections = GetDlgItem( hwndDlg, CID_AQ_LV_Connections );
    ASSERT( pInfo->hwndAqLvConnections );
    
    // Fill in the listview of connections
    //
    dwErr = AqFillListView(pInfo);
    if (dwErr != NO_ERROR)
    {
        EndDialog(hwndDlg, dwErr);
        return TRUE;
    }

    // Fill in the argument in the explanatory text.
    //
    {
        TCHAR* pszTextFormat;
        TCHAR* pszText;
        TCHAR* apszArgs[ 1 ];

        pszTextFormat = PszFromId( g_hinstDll, SID_AQ_Text );
        if (pszTextFormat)
        {
            apszArgs[ 0 ] = pArgs->pszDestination;
            pszText = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTextFormat, 0, 0, (LPTSTR )&pszText, 1,
                (va_list* )apszArgs );

            Free( pszTextFormat );

            if (pszText)
            {
                SetWindowText( pInfo->hwndStText, pszText );
                LocalFree( pszText );
            }
        }
    }

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    // for whistler bug 391195
    // Default is to connect, so set the focus on list box and default button 
    // to connect
    //
    SetFocus( GetDlgItem( hwndDlg, CID_AQ_LV_Connections) ); //CID_AQ_PB_DoNotDial ) );


    //For whistler bug 357164       gangz
    // Initialize the "disable current session" checkbox
    //
    {
        DWORD dwFlag = FALSE, dwErr = NO_ERROR;
        DWORD cb = sizeof(dwFlag);
        
        dwErr = g_pRasGetAutodialParam(
                                        RASADP_LoginSessionDisable, 
                                        &dwFlag, 
                                        &cb );
            
        CheckDlgButton( 
            hwndDlg, 
            CID_AQ_CB_DisableThisSession, 
            (BOOL )dwFlag );
    }
    
    //Set up the timer for bug 336524   gangz
    //
    pInfo->pArgs->nIdTimer = 1;
    SetTimer( hwndDlg,
              pInfo->pArgs->nIdTimer,              
              (pInfo->pArgs->dwTimeout) *1000,//in milliseconds
              NULL);
              
    return FALSE;
}

LVXDRAWINFO*
AqLvCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, 0, { 0, 0 } };

    return &info;
}

BOOL
AqNotify(
    HWND hwnd, 
    int idCtrl, 
    LPNMHDR pnmh)    
{
    AQINFO* pInfo = (AQINFO* )GetWindowLongPtr( hwnd, DWLP_USER );

    ASSERT(pInfo);
    ASSERT(pnmh);

    if(!pnmh || !pInfo)
    {
        return FALSE;
    }
     
    switch ( pnmh->code)
    {
        case LVN_ITEMACTIVATE:
        case LVN_KEYDOWN:
        case LVN_ITEMCHANGED:
        case LVN_ODSTATECHANGED:
        case LVN_COLUMNCLICK:
        case LVN_HOTTRACK:

        //re-set up the timer   
        //

        ASSERT( pInfo->pArgs );
              
        if ( pInfo->pArgs->nIdTimer )
        {
           KillTimer( hwnd,
                     pInfo->pArgs->nIdTimer);            
         }
         break;

         default:  
            break;
     }

    return FALSE;
}

VOID
AqTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    AQINFO* pInfo = (AQINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "AqTerm" );

    if (pInfo)
    {
        ASSERT(pInfo->pArgs);

        if( pInfo->pArgs->nIdTimer )
        {
            KillTimer( hwndDlg, 
                       pInfo->pArgs->nIdTimer );
         }
        
        Free( pInfo );
    }
}

//Add the timer function for bug 336524
//
BOOL
AqTimer(
    IN HWND hwndDlg )
{
    AQINFO* pInfo = (AQINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "AqTimer" );

    pInfo->pArgs->nIdTimer = 0;
    EndDialog( hwndDlg, ERROR_CANCELLED );

    return TRUE;
}

//----------------------------------------------------------------------------
// Auto-Dial Disable dialog
// Listed alphabetically following API and dialog proc
//----------------------------------------------------------------------------

BOOL APIENTRY
RasAutodialDisableDlgW(
    IN HWND hwndOwner )

    // Private external entry point to popup the Auto-Dial Disable Query, i.e.
    // the "Attempt failed Do you want to disable auto-dial for this
    // location?" dialog.  'HwndOwner' is the owning window or NULL if none.
    //
    // Returns true if user chose to disable, false otherwise.
    //
{
    INT_PTR nStatus;

    TRACE( "RasAutodialDisableDlgA" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DQ_DisableAutoDialQuery ),
            hwndOwner,
            DqDlgProc,
            (LPARAM )0 );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}

BOOL APIENTRY
RasAutodialDisableDlgA(
    IN HWND hwndOwner )
{
    return RasAutodialDisableDlgW( hwndOwner );
}

INT_PTR CALLBACK
DqDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Auto-Dial Query dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "AqDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DqInit( hwnd );
        }

        case WM_COMMAND:
        {
            return DqCommand(
               hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
DqCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DqCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            DWORD dwId;
            HLINEAPP hlineapp;

            TRACE( "Yes pressed" );

            // User chose to permanently disable auto-dial for the current
            // TAPI location.
            //
            dwErr = LoadRasapi32Dll();
            if (dwErr == 0)
            {
                hlineapp = 0;
                dwId = GetCurrentLocation( g_hinstDll, &hlineapp );
                ASSERT( g_pRasSetAutodialEnable );
                TRACE1( "RasSetAutodialEnable(%d)", dwId );
                dwErr = g_pRasSetAutodialEnable( dwId, FALSE );
                TRACE1( "RasSetAutodialEnable=%d", dwErr );
                TapiShutdown( hlineapp );
            }

            if (dwErr != 0)
            {
                ErrorDlg( hwnd, SID_OP_SetADialInfo, dwErr, NULL );
            }

            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "No or cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DqInit(
    IN HWND hwndDlg )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    TRACE( "DqInit" );

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    // Default is to not disable auto-dial.
    //
    SetFocus( GetDlgItem( hwndDlg, IDCANCEL ) );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasadmin\api\util.h ===
/******************************************************************\
*                     Microsoft Windows NT                         *
*               Copyright(c) Microsoft Corp., 1992                 *
\******************************************************************/

/*
 *
 * Filename:	UTIL.H
 *
 * Description:	Contains the function prototypes for all RASADMIN API
 *              utility routines.
 *
 * History:     Janakiram Cherala (ramc)   7/6/92
 *
 */

VOID
BuildPipeName(
    IN  const WCHAR *     lpszServer,
    OUT       LPWSTR     lpszPipeName
    );

USHORT
RasAdminCompressPhoneNumber(
    IN  LPWSTR Uncompressed,
    OUT LPWSTR Compressed
    );

USHORT
RasAdminDecompressPhoneNumber(
    IN  LPWSTR Compressed,
    OUT LPWSTR Decompressed
    );

DWORD APIENTRY
GetRasServerVersion(
    IN  const WCHAR * lpszServerName,
    OUT       DWORD  *pdwVersion
    );

SHORT
GetPortId(
    IN  const WCHAR * lpszPort
    );

VOID
GetPortName(
    IN  USHORT PortId,
    OUT LPWSTR PortName
    );

DWORD
RasPrivilegeAndCallBackNumber (
    BOOL        Compress,
    PRAS_USER_0 pRasUser0
    );


#define RASADMIN_PORT_ENUM_PTR    1L
#define RASADMIN_PORT1_PTR        2L
#define RASADMIN_PORT_STATS_PTR   3L
#define RASADMIN_PORT_PARAMS_PTR  4L
#define LANMAN_API_PTR            5L

VOID FreeParams(PVOID Pointer, DWORD NumParms);

DWORD insert_list_head(
    IN PVOID Pointer,
    IN DWORD PointerType,
    IN DWORD NumItems
    );


DWORD remove_list(
    IN PVOID Pointer,
    OUT PDWORD PointerType,
    OUT PDWORD NumItems
    );


VOID PackClientRequest(
    IN PCLIENT_REQUEST PRequest,
    OUT PP_CLIENT_REQUEST Request
    );

VOID PackResumeRequest(
    IN PCLIENT_REQUEST PRequest,
    OUT PP_CLIENT_REQUEST Request,
    IN USHORT ResumePort
    );

VOID UnpackRasPort0(
    IN PP_RAS_PORT_0 pprp0,
    OUT PRAS_PORT_0 prp0
    );

VOID UnpackRasPort1(
    IN PP_RAS_PORT_1 pprp1,
    OUT PRAS_PORT_1 prp1,
    DWORD dwServerVersion
    );

VOID UnpackRasServer0(
    IN PP_RAS_SERVER_0 pprs0,
    OUT PRAS_SERVER_0 prs0
    );

DWORD UnpackPortEnumReceive(
    IN PP_PORT_ENUM_RECEIVE ppper,
    OUT PPORT_ENUM_RECEIVE pper
    );

DWORD UnpackResumeEnumReceive(
    IN PP_PORT_ENUM_RECEIVE ppper,
    OUT PPORT_ENUM_RECEIVE pper,
    IN USHORT ResumePort
    );

VOID UnpackServerInfoReceive(
    IN PP_SERVER_INFO_RECEIVE ppsir,
    OUT PSERVER_INFO_RECEIVE psir
    );

VOID UnpackPortClearReceive(
    IN PP_PORT_CLEAR_RECEIVE pppcr,
    OUT PPORT_CLEAR_RECEIVE ppcr
    );

VOID UnpackDisconnectUserReceive(
    IN PP_DISCONNECT_USER_RECEIVE ppdur,
    OUT PDISCONNECT_USER_RECEIVE pdur
    );

VOID UnpackPortInfoReceive(
    IN PP_PORT_INFO_RECEIVE pppir,
    OUT PPORT_INFO_RECEIVE ppir,
    DWORD dwServerVersion
    );

VOID UnpackStats(
    DWORD dwVersion,
    WORD NumStats,
    IN PP_RAS_STATISTIC PStats,
    OUT PRAS_PORT_STATISTICS Stats
    );

DWORD UnpackParams(
    IN WORD NumOfParams,
    IN PP_RAS_PARAMS PParams,
    OUT RAS_PARAMETERS *Params
    );

VOID UnpackWpdStatistics(
    IN PP_WPD_STATISTICS_INFO PWpdStats,
    OUT WpdStatisticsInfo *WpdStats
    );

VOID UnpackDialinPortInfo0(
    IN PP_DIALIN_PORT_INFO_0 PPortInfo0,
    struct dialin_port_info_0 *PortInfo0
    );

VOID UnpackDialinPortInfo1(
    IN PP_DIALIN_PORT_INFO_1 PPortInfo1,
    struct dialin_port_info_1 *PortInfo1
    );

VOID UnpackDialinServerInfo0(
    IN PP_DIALIN_SERVER_INFO_0 PServerInfo0,
    OUT struct dialin_server_info_0 *ServerInfo0
    );

VOID UnpackPortEnumReceivePkt(
    IN PP_PORT_ENUM_RECEIVE_PKT PEnumRecv,
    OUT struct PortEnumReceivePkt *EnumRecv
    );

VOID UnpackDisconnectUserReceivePkt(
    IN PP_DISCONNECT_USER_RECEIVE_PKT PDisconnectUser,
    OUT struct DisconnectUserReceivePkt *DisconnectUser
    );

VOID UnpackPortClearReceivePkt(
    IN PP_PORT_CLEAR_RECEIVE_PKT PClearRecv,
    OUT struct PortClearReceivePkt *ClearRecv
    );

VOID UnpackServerInfoReceivePkt(
    IN PP_SERVER_INFO_RECEIVE_PKT PInfoRecv,
    OUT struct ServerInfoReceivePkt *InfoRecv
    );

VOID UnpackPortInfoReceivePkt(
    IN PP_PORT_INFO_RECEIVE_PKT PInfoRecv,
    OUT struct PortInfoReceivePkt *InfoRecv
    );

VOID PackPortEnumRequestPkt(
    IN struct PortEnumRequestPkt *EnumReq,
    OUT PP_PORT_ENUM_REQUEST_PKT PEnumReq
    );

VOID PackDisconnectUserRequestPkt(
    IN struct DisconnectUserRequestPkt *DisconnectReq,
    OUT PP_DISCONNECT_USER_REQUEST_PKT PDisconnectReq
    );

VOID PackPortClearRequestPkt(
    IN struct PortClearRequestPkt *ClearReq,
    OUT PP_PORT_CLEAR_REQUEST_PKT PClearReq
    );

VOID PackServerInfoRequestPkt(
    IN struct ServerInfoRequestPkt *InfoReq,
    OUT PP_SERVER_INFO_REQUEST_PKT PInfoReq
    );

VOID PackPortInfoRequestPkt(
    IN struct PortInfoRequestPkt *InfoReq,
    OUT PP_PORT_INFO_REQUEST_PKT PInfoReq
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\devcfg.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// devcfg.c
// Remote Access Common Dialog APIs
// Device configuration dialogs
//
// 10/20/95 Steve Cobb


#include "rasdlgp.h"
#include "mcx.h"

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwIcHelp[] =
{
    CID_IC_ST_LineType,    HID_IC_LB_LineType,
    CID_IC_LB_LineType,    HID_IC_LB_LineType,
    CID_IC_CB_Fallback,    HID_IC_CB_Fallback,
    CID_IC_GB_DownLevel,   HID_IC_CB_DownLevel,
    CID_IC_CB_DownLevel,   HID_IC_CB_DownLevel,
    CID_IC_CB_Compression, HID_IC_CB_Compression,
    CID_IC_ST_Channels,    HID_IC_EB_Channels,
    CID_IC_EB_Channels,    HID_IC_EB_Channels,
    0, 0
};

static DWORD g_adwMcHelp[] =
{
    CID_MC_I_Modem,           HID_MC_I_Modem,
    CID_MC_EB_ModemValue,     HID_MC_EB_ModemValue,
    CID_MC_ST_MaxBps,         HID_MC_LB_MaxBps,
    CID_MC_LB_MaxBps,         HID_MC_LB_MaxBps,
    CID_MC_GB_Features,       HID_MC_GB_Features,
    CID_MC_CB_FlowControl,    HID_MC_CB_FlowControl,
    CID_MC_CB_ErrorControl,   HID_MC_CB_ErrorControl,
    CID_MC_CB_Compression,    HID_MC_CB_Compression,
    CID_MC_CB_Terminal,       HID_MC_CB_Terminal,
    CID_MC_CB_EnableSpeaker,  HID_MC_CB_EnableSpeaker,
    CID_MC_ST_ModemProtocol,  HID_MC_LB_ModemProtocol,
    CID_MC_LB_ModemProtocol,  HID_MC_LB_ModemProtocol,
    0, 0
};

static DWORD g_adwXsHelp[] =
{
    CID_XS_ST_Explain,    HID_XS_ST_Explain,
    CID_XS_ST_Networks,   HID_XS_LB_Networks,
    CID_XS_LB_Networks,   HID_XS_LB_Networks,
    CID_XS_ST_Address,    HID_XS_EB_Address,
    CID_XS_EB_Address,    HID_XS_EB_Address,
    CID_XS_GB_Optional,   HID_XS_GB_Optional,
    CID_XS_ST_UserData,   HID_XS_EB_UserData,
    CID_XS_EB_UserData,   HID_XS_EB_UserData,
    CID_XS_ST_Facilities, HID_XS_EB_Facilities,
    CID_XS_EB_Facilities, HID_XS_EB_Facilities,
    0, 0
};

//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// ISDN Configuration dialog argument block.
//
typedef struct
_ICARGS
{
    BOOL fShowProprietary;
    PBLINK* pLink;
}
ICARGS;


// ISDN Configuration dialog context block.
//
typedef struct
_ICINFO
{
    // Stub API arguments including shortcut to link associated with the
    // entry.
    //
    ICARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbLineType;
    HWND hwndCbFallback;
    HWND hwndCbProprietary;
    HWND hwndCbCompression;
    HWND hwndStChannels;
    HWND hwndEbChannels;
    HWND hwndUdChannels;
}
ICINFO;

typedef struct
_MC_INIT_INFO
{
    PBLINK* pLink;
    BOOL fRouter;
} 
MC_INIT_INFO;

// Modem Configuration dialog context block.
//
typedef struct
_MCINFO
{
    // Stub API arguments.  Shortcut to link associated with the entry.
    //
    PBLINK* pLink;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbModemValue;
    HWND hwndLbBps;
    HWND hwndCbHwFlow;
    HWND hwndCbEc;
    HWND hwndCbEcc;
    HWND hwndCbTerminal;
    HWND hwndCbEnableSpeaker;
    HWND hwndLbModemProtocols;

    // Script utilities context.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;
    BOOL fRouter;
}
MCINFO;


// X.25 Logon Settings dialog argument block.
//
typedef struct
_XSARGS
{
    BOOL fLocalPad;
    PBENTRY* pEntry;
}
XSARGS;


// X.25 Logon Settings dialog context block.
//
typedef struct
_XSINFO
{
    // Caller's arguments to the dialog.
    //
    XSARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbNetworks;
    HWND hwndEbAddress;
    HWND hwndEbUserData;
    HWND hwndEbFacilities;
}
XSINFO;

//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
IcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
IcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
IcInit(
    IN HWND hwndDlg,
    IN ICARGS* pArgs );

VOID
IcTerm(
    IN HWND hwndDlg );

BOOL
IsdnConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN BOOL fShowProprietary );

BOOL
ModemConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN BOOL fRouter);

INT_PTR CALLBACK
McDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
McCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
McInit(
    IN HWND hwndDlg,
    IN MC_INIT_INFO* pInitInfo );

VOID
McTerm(
    IN HWND hwndDlg );

BOOL
XsCommand(
    IN XSINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
XsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
XsFillPadsList(
    IN XSINFO* pInfo );

BOOL
XsInit(
    IN HWND hwndDlg,
    IN XSARGS* pArgs );

BOOL
XsSave(
    IN XSINFO* pInfo );

VOID
XsTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Device configuration dialog
//----------------------------------------------------------------------------

BOOL
DeviceConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN PBENTRY* pEntry,
    IN BOOL fSingleLink,
    IN BOOL fRouter)

    // Popup a dialog to edit the device 'PLink'.  'HwndOwner' is the owner of
    // the dialog.  'PEntry' is the phonebook entry containing the X.25
    // settings or NULL if X.25 settings should not be displayed for PAD and
    // X.25 devices.  'FSingleLink' is true if 'pLink' is a single link
    // entry's link and false if multi-link.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
    //
{
    DWORD dwErr;
    PBDEVICETYPE pbdt;

    pbdt = pLink->pbport.pbdevicetype;
    if (!pEntry && (pbdt == PBDT_Pad || pbdt == PBDT_X25))
    {
        pbdt = PBDT_None;
    }

    // pmay: 245860
    //
    // We need to allow the editing of null modems too.
    //
    if ( pLink->pbport.dwFlags & PBP_F_NullModem )
    {
        pbdt = PBDT_Modem;
    }
    
    switch (pbdt)
    {
        case PBDT_Isdn:
        {
            return IsdnConfigureDlg( hwndOwner, pLink, fSingleLink );
        }

        case PBDT_Modem:
        {
            return ModemConfigureDlg( hwndOwner, pLink, fRouter );
        }

        case PBDT_Pad:
        {
            return X25LogonSettingsDlg( hwndOwner, TRUE, pEntry );
        }

        case PBDT_X25:
        {
            return X25LogonSettingsDlg( hwndOwner, FALSE, pEntry );
        }

        default:
        {
            MsgDlg( hwndOwner, SID_NoConfigure, NULL );
            return FALSE;
        }
    }
}


//----------------------------------------------------------------------------
// ISDN configuration dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
IsdnConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN BOOL fShowProprietary )

    // Popup the ISDN device configuration dialog.  'HwndOwner' is the owner
    // of the dialog.  'PLink' is the link to edit.  'FShowProprietary'
    // indicates the old proprietary Digiboard options should be shown.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    ICARGS args;

    TRACE( "IsdnConfigureDlg" );

    args.fShowProprietary = fShowProprietary;
    args.pLink = pLink;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (fShowProprietary)
                ? MAKEINTRESOURCE( DID_IC_IsdnConfigure )
                : MAKEINTRESOURCE( DID_IC_IsdnConfigureMlink ),
            hwndOwner,
            IcDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
IcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the ISDN Configure dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "IcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return IcInit( hwnd, (ICARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwIcHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return IcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            IcTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
IcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "IcCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_IC_CB_DownLevel:
        {
            if (wNotification == BN_CLICKED)
            {
                BOOL fCheck;
                ICINFO* pInfo;

                pInfo = (ICINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (pInfo->pArgs->fShowProprietary)
                {
                    fCheck = Button_GetCheck( pInfo->hwndCbProprietary );

                    EnableWindow( pInfo->hwndCbCompression, fCheck );
                    EnableWindow( pInfo->hwndStChannels, fCheck );
                    EnableWindow( pInfo->hwndEbChannels, fCheck );
                    EnableWindow( pInfo->hwndUdChannels, fCheck );
                }
            }
            return TRUE;
        }

        case IDOK:
        {
            ICINFO* pInfo;
            INT iSel;

            TRACE( "OK pressed" );

            pInfo = (ICINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            iSel = ComboBox_GetCurSel( pInfo->hwndLbLineType );
            if (iSel >= 0)
            {
                pInfo->pArgs->pLink->lLineType = iSel;
            }

            pInfo->pArgs->pLink->fFallback =
                Button_GetCheck( pInfo->hwndCbFallback );

            pInfo->pArgs->pLink->fProprietaryIsdn =
                Button_GetCheck( pInfo->hwndCbProprietary );

            if (pInfo->pArgs->fShowProprietary)
            {
                BOOL f;
                UINT unValue;

                pInfo->pArgs->pLink->fCompression =
                    Button_GetCheck( pInfo->hwndCbCompression );

                unValue = GetDlgItemInt(
                    pInfo->hwndDlg, CID_IC_EB_Channels, &f, FALSE );
                if (f && unValue >= 1 && unValue <= 999999999)
                {
                    pInfo->pArgs->pLink->lChannels = unValue;
                }
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
IcInit(
    IN HWND hwndDlg,
    IN ICARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is the caller's stub API arguments.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    ICINFO* pInfo;

    TRACE( "IcInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLbLineType = GetDlgItem( hwndDlg, CID_IC_LB_LineType );
    ASSERT( pInfo->hwndLbLineType );
    pInfo->hwndCbFallback = GetDlgItem( hwndDlg, CID_IC_CB_Fallback );
    ASSERT( pInfo->hwndCbFallback );
    if (pArgs->fShowProprietary)
    {
        pInfo->hwndCbProprietary = GetDlgItem( hwndDlg, CID_IC_CB_DownLevel );
        ASSERT( pInfo->hwndCbProprietary );
        pInfo->hwndCbCompression = GetDlgItem( hwndDlg, CID_IC_CB_Compression );
        ASSERT( pInfo->hwndCbCompression );
        pInfo->hwndStChannels = GetDlgItem( hwndDlg, CID_IC_ST_Channels );
        ASSERT( pInfo->hwndStChannels );
        pInfo->hwndEbChannels = GetDlgItem( hwndDlg, CID_IC_EB_Channels );
        ASSERT( pInfo->hwndEbChannels );
    }

    // Initialize fields.
    //
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType0, NULL );
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType1, NULL );
    ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbLineType,
        SID_IsdnLineType2, NULL );
    ComboBox_SetCurSel( pInfo->hwndLbLineType, pArgs->pLink->lLineType );

    Button_SetCheck( pInfo->hwndCbFallback, pArgs->pLink->fFallback );

    if (pArgs->fShowProprietary)
    {
        // Send click to triggle window enable update.
        //
        Button_SetCheck( pInfo->hwndCbProprietary,
            !pArgs->pLink->fProprietaryIsdn );
        SendMessage( pInfo->hwndCbProprietary, BM_CLICK, 0, 0 );

        Button_SetCheck( pInfo->hwndCbCompression, pArgs->pLink->fCompression );

        pInfo->hwndUdChannels = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER +
                UDS_SETBUDDYINT + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS +
                UDS_ARROWKEYS,
            0, 0, 0, 0, hwndDlg, 100, g_hinstDll, pInfo->hwndEbChannels,
            UD_MAXVAL, 1, 0 );
        ASSERT( pInfo->hwndUdChannels );
        Edit_LimitText( pInfo->hwndEbChannels, 9 );
        SetDlgItemInt( hwndDlg, CID_IC_EB_Channels,
            pArgs->pLink->lChannels, FALSE );
    }

    // Position the dialog centered on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
IcTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    ICINFO* pInfo;

    TRACE( "IcTerm" );

    pInfo = (ICINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}


//----------------------------------------------------------------------------
// Modem configuration dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
ModemConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink, 
    IN BOOL fRouter)

    // Popup the modem configuration dialog.  'HwndOwner' is the owner of the
    // dialog.  'PLink' is the link to edit.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    MC_INIT_INFO InitInfo;

    TRACE( "ModemConfigureDlg" );

    ZeroMemory(&InitInfo, sizeof(InitInfo));
    InitInfo.pLink = pLink;
    InitInfo.fRouter = fRouter;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_MC_ModemConfigure ),
            hwndOwner,
            McDlgProc,
            (LPARAM ) &InitInfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
McDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Modem Settings dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "McDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return McInit( hwnd, (MC_INIT_INFO* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwMcHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return McCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            McTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
McCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "McCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_MC_CB_FlowControl:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (!Button_GetCheck( pInfo->hwndCbHwFlow ))
                {
                    Button_SetCheck( pInfo->hwndCbEc, FALSE );
                    Button_SetCheck( pInfo->hwndCbEcc, FALSE );
                }
                return TRUE;
            }
            break;
        }

        case CID_MC_CB_ErrorControl:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (Button_GetCheck( pInfo->hwndCbEc ))
                {
                    Button_SetCheck( pInfo->hwndCbHwFlow, TRUE );
                }
                else
                {
                    Button_SetCheck( pInfo->hwndCbEcc, FALSE );
                }
                return TRUE;
            }
            break;
        }

        case CID_MC_CB_Compression:
        {
            if (wNotification == BN_CLICKED)
            {
                MCINFO* pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                ASSERT( pInfo );

                if (Button_GetCheck( pInfo->hwndCbEcc ))
                {
                    Button_SetCheck( pInfo->hwndCbHwFlow, TRUE );
                    Button_SetCheck( pInfo->hwndCbEc, TRUE );
                }
                return TRUE;
            }
            break;
        }

        case IDOK:
        {
            MCINFO* pInfo;
            PBLINK* pLink;
            BOOL    fScriptBefore = FALSE;

            TRACE( "OK pressed" );

            pInfo = (MCINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            pLink = pInfo->pLink;

            pLink->dwBps =
                (DWORD)ComboBox_GetItemData(
                        pInfo->hwndLbBps,
                        (INT)ComboBox_GetCurSel( pInfo->hwndLbBps ) );

            pLink->fHwFlow = Button_GetCheck( pInfo->hwndCbHwFlow );
            pLink->fEc = Button_GetCheck( pInfo->hwndCbEc );
            pLink->fEcc = Button_GetCheck( pInfo->hwndCbEcc );
            pLink->fSpeaker = Button_GetCheck( pInfo->hwndCbEnableSpeaker );
            
            // pmay: 228565
            // Find the selected modem protocol
            //
            if (IsWindowEnabled( pInfo->hwndLbModemProtocols ))
            {
                DTLNODE* pNode;
                INT iSel;

                iSel = ComboBox_GetCurSel( pInfo->hwndLbModemProtocols );
                pNode = (DTLNODE*) 
                    ComboBox_GetItemDataPtr(pInfo->hwndLbModemProtocols, iSel);

                if ( pNode )
                {
                    pLink->dwModemProtocol = (DWORD) DtlGetNodeId( pNode );
                }
            }

            Free0( pLink->pbport.pszScriptBefore );

            // Whistler bug: 308135 Dialup Scripting: Pre-Dial scripts can be
            // selected but are not executed
            //
            SuGetInfo( &pInfo->suinfo,
                &fScriptBefore,
                &pLink->pbport.fScriptBeforeTerminal,
                NULL );

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
McInit(
    IN HWND hwndDlg,
    IN MC_INIT_INFO* pInitInfo )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PLink' is the link information to be edited.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr, dwFlags = 0;
    MCINFO* pInfo;
    PBLINK* pLink = pInitInfo->pLink;

    TRACE( "McInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pLink = pInitInfo->pLink;
        pInfo->fRouter = pInitInfo->fRouter;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndEbModemValue = GetDlgItem( hwndDlg, CID_MC_EB_ModemValue );
    ASSERT( pInfo->hwndEbModemValue );
    pInfo->hwndLbBps = GetDlgItem( hwndDlg, CID_MC_LB_MaxBps );
    ASSERT( pInfo->hwndLbBps );
    pInfo->hwndCbHwFlow = GetDlgItem( hwndDlg, CID_MC_CB_FlowControl );
    ASSERT( pInfo->hwndCbHwFlow );
    pInfo->hwndCbEc = GetDlgItem( hwndDlg, CID_MC_CB_ErrorControl );
    ASSERT( pInfo->hwndCbEc );
    pInfo->hwndCbEcc = GetDlgItem( hwndDlg, CID_MC_CB_Compression );
    ASSERT( pInfo->hwndCbEcc );
    pInfo->hwndCbTerminal = GetDlgItem( hwndDlg, CID_MC_CB_Terminal );
    ASSERT( pInfo->hwndCbTerminal );
    pInfo->hwndCbEnableSpeaker = GetDlgItem( hwndDlg, CID_MC_CB_EnableSpeaker );
    ASSERT( pInfo->hwndCbEnableSpeaker );
    pInfo->hwndLbModemProtocols = GetDlgItem( hwndDlg, CID_MC_LB_ModemProtocol );
    ASSERT( pInfo->hwndLbModemProtocols );

    Button_SetCheck( pInfo->hwndCbHwFlow, pLink->fHwFlow );
    Button_SetCheck( pInfo->hwndCbEc, pLink->fEc );
    Button_SetCheck( pInfo->hwndCbEcc, pLink->fEcc );
    Button_SetCheck( pInfo->hwndCbEnableSpeaker, pLink->fSpeaker );

    // Fill in the modem name.
    //
    {
        TCHAR* psz;
        psz = DisplayPszFromDeviceAndPort(
            pLink->pbport.pszDevice, pLink->pbport.pszPort );
        if (psz)
        {
            SetWindowText( pInfo->hwndEbModemValue, psz );
            Free( psz );
        }
    }

    // Fill in the BPS list.
    //
    {
        TCHAR szBps[ MAXLTOTLEN + 1 ];
        DWORD* pdwBps;
        INT i;

        //Add 230400 for whistler bug 307879
        //
        static DWORD adwBps[] =
        {
            1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600,
            0
        };

        for (pdwBps = adwBps; *pdwBps; ++pdwBps)
        {
            LToT( *pdwBps, szBps, 10 );
            i = ComboBox_AddString( pInfo->hwndLbBps, szBps );
            ComboBox_SetItemData( pInfo->hwndLbBps, i, *pdwBps );
            if (*pdwBps == pLink->dwBps)
            {
                ComboBox_SetCurSel( pInfo->hwndLbBps, i );
            }
        }

        if (ComboBox_GetCurSel( pInfo->hwndLbBps ) < 0)
        {
            // Entry lists an unknown BPS rate.  Add it to the end of the
            // list.
            //
            TRACE( "Irregular BPS" );
            LToT( pLink->dwBps, szBps, 10 );
            i = ComboBox_AddString( pInfo->hwndLbBps, szBps );
            ComboBox_SetItemData( pInfo->hwndLbBps, i, pLink->dwBps );
            ComboBox_SetCurSel( pInfo->hwndLbBps, i );
        }
    }
    
    // Fill in the modem protocol list
    //
    {
        PBPORT* pPort = &(pLink->pbport);
        DTLNODE* pNode;
        WCHAR pszBuffer[64];
        INT iItemSel = 0, iItem = 0;

        DbgPrint("pListProtocols=0x%x\n", pPort->pListProtocols);
        
        // Only fill in the modem protocol information 
        // if it was supplied by the link
        //
        if ((pPort->pListProtocols) && 
            (DtlGetNodes (pPort->pListProtocols))
           )
        {
            for (pNode = DtlGetFirstNode( pPort->pListProtocols );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {   
                iItem = ComboBox_AddItem(
                            pInfo->hwndLbModemProtocols,
                            (PWCHAR) DtlGetData(pNode),
                            (VOID*) pNode);
                            
                if (DtlGetNodeId(pNode) == (LONG_PTR)pLink->dwModemProtocol)
                {
                    iItemSel = iItem;
                }
            }

            ComboBox_SetCurSelNotify(
                pInfo->hwndLbModemProtocols,
                iItemSel);
        }

        // Otherwise, disable the protocol selector
        //       
        else
        {
            EnableWindow( pInfo->hwndLbModemProtocols, FALSE );
        }
    }

    // Set up the before-dial scripting controls.
    //
    // Whistler bug 181371 re-enabled pre-dial scripting from Win2K
    //
    // Whistler bug: 308135 Dialup Scripting: Pre-Dial scripts can be selected
    // but are not executed
    //
    // We QFE'd re-enabling this for SP2. According to the Unimodem guys this
    // has never worked and isn't supported. I had test verify that even with
    // the SP2 fix on 2195, although the UI is re-enabled, the scripts fail.
    //
    dwFlags |= SU_F_DisableScripting;

    SuInit( &pInfo->suinfo,
        NULL,
        pInfo->hwndCbTerminal,
        NULL,
        NULL,
        NULL,
        dwFlags);
    pInfo->fSuInfoInitialized = TRUE;

    SuSetInfo( &pInfo->suinfo,
        FALSE,
        pLink->pbport.fScriptBeforeTerminal,
        NULL );

    // Position the dialog centered on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Set focust to Bps since the default focus in the not very useful device
    // name.
    //
    SetFocus( pInfo->hwndLbBps );

    return FALSE;
}

VOID
McTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    MCINFO* pInfo;

    TRACE( "McTerm" );

    pInfo = (MCINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        if (pInfo->fSuInfoInitialized)
        {
            SuFree( &pInfo->suinfo );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}


//----------------------------------------------------------------------------
// X.25 Logon Settings dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
X25LogonSettingsDlg(
    IN HWND hwndOwner,
    IN BOOL fLocalPad,
    IN OUT PBENTRY* pEntry )

    // Popup a dialog to set X.25 logon settings for phonebook entry 'pEntry'.
    // 'HwndOwner' is the owning window.  'FLocalPad' is set when the selected
    // device is a local X.25 PAD device.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.
    //
{
    INT_PTR nStatus;
    XSARGS args;

    TRACE( "X25LogonSettingsDlg" );

    args.fLocalPad = fLocalPad;
    args.pEntry = pEntry;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_XS_X25Settings ),
            hwndOwner,
            XsDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
XsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the X.25 Logon Settings dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "XsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return XsInit( hwnd, (XSARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwXsHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            XSINFO* pInfo = (XSINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return XsCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            XsTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
XsCommand(
    IN XSINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "XsCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, XsSave( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
XsFillPadsList(
    IN XSINFO* pInfo )

    // Fill PADs list and selects the PAD from user's entry.  'PInfo' is the
    // dialog context.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    PBENTRY* pEntry;
    INT nIndex;

    TRACE( "XsFillPadsList" );

    // Add the "(none)" item.
    //
    ComboBox_AddItemFromId(
        g_hinstDll, pInfo->hwndLbNetworks, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( pInfo->hwndLbNetworks, 0 );

    if (!pInfo->pArgs->fLocalPad)
    {
        DTLLIST* pListPads;

        dwErr = LoadPadsList( &pListPads );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadX25Info, dwErr, NULL );
            return;
        }

        pEntry = pInfo->pArgs->pEntry;

        for (pNode = DtlGetFirstNode( pListPads );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            TCHAR* psz;

            psz = (TCHAR* )DtlGetData( pNode );
            nIndex = ComboBox_AddString( pInfo->hwndLbNetworks, psz );

            if (pEntry->pszX25Network
                && lstrcmp( psz, pEntry->pszX25Network ) == 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbNetworks, nIndex );
            }
        }

        DtlDestroyList( pListPads, DestroyPszNode );

        if (pEntry->pszX25Network
            && ComboBox_GetCurSel( pInfo->hwndLbNetworks ) == 0)
        {
            // The PAD from the phonebook entry is not in the PAD list.  Add
            // it and select it.
            //
            nIndex = ComboBox_AddString(
                pInfo->hwndLbNetworks, pEntry->pszX25Network );
            ComboBox_SetCurSel( pInfo->hwndLbNetworks, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbNetworks );
}


BOOL
XsInit(
    IN HWND hwndDlg,
    IN XSARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    XSINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "XsInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLbNetworks = GetDlgItem( hwndDlg, CID_XS_LB_Networks );
    ASSERT( pInfo->hwndLbNetworks );
    pInfo->hwndEbAddress = GetDlgItem( hwndDlg, CID_XS_EB_Address );
    ASSERT( pInfo->hwndEbAddress );
    pInfo->hwndEbUserData = GetDlgItem( hwndDlg, CID_XS_EB_UserData );
    ASSERT( pInfo->hwndEbUserData );
    pInfo->hwndEbFacilities = GetDlgItem( hwndDlg, CID_XS_EB_Facilities );
    ASSERT( pInfo->hwndEbFacilities );

    XsFillPadsList( pInfo );

    pEntry = pArgs->pEntry;

    Edit_LimitText( pInfo->hwndEbAddress, RAS_MaxX25Address );
    if (pEntry->pszX25Address)
    {
        SetWindowText( pInfo->hwndEbAddress, pEntry->pszX25Address );
    }

    Edit_LimitText( pInfo->hwndEbUserData, RAS_MaxUserData );
    if (pEntry->pszX25UserData)
    {
        SetWindowText( pInfo->hwndEbUserData, pEntry->pszX25UserData );
    }

    Edit_LimitText( pInfo->hwndEbFacilities, RAS_MaxFacilities );
    if (pEntry->pszX25Facilities)
    {
        SetWindowText( pInfo->hwndEbFacilities, pEntry->pszX25Facilities );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    if (pArgs->fLocalPad)
    {
        // No point in setting focus to "X.25 Network" on local PAD, so set to
        // X.25 Address field instead.
        //
        SetFocus( pInfo->hwndEbAddress );
        Edit_SetSel( pInfo->hwndEbAddress, 0, -1 );
        return FALSE;
    }

    return TRUE;
}


BOOL
XsSave(
    IN XSINFO* pInfo )

    // Load the contents of the dialog into caller's stub API output argument.
    // 'PInfo' is the dialog context.
    //
    // Returns true if succesful, false otherwise.
    //
{

    INT iPadSelection;
    PBENTRY* pEntry;

    TRACE( "XsSave" );

    pEntry = pInfo->pArgs->pEntry;

    iPadSelection = ComboBox_GetCurSel( pInfo->hwndLbNetworks );
    Free0( pEntry->pszX25Network );
    if (iPadSelection > 0)
    {
        pEntry->pszX25Network = GetText( pInfo->hwndLbNetworks );
    }
    else
    {
        pEntry->pszX25Network = NULL;
    }

    Free0( pEntry->pszX25Address );
    pEntry->pszX25Address = GetText( pInfo->hwndEbAddress );

    Free0( pEntry->pszX25UserData );
    pEntry->pszX25UserData = GetText( pInfo->hwndEbUserData );

    Free0( pEntry->pszX25Facilities );
    pEntry->pszX25Facilities = GetText( pInfo->hwndEbFacilities );

    pEntry->fDirty = TRUE;

    if (!pEntry->pszX25Address
        || !pEntry->pszX25UserData
        || !pEntry->pszX25Facilities)
    {
        Free0( pEntry->pszX25Address );
        Free0( pEntry->pszX25UserData );
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData,
            ERROR_NOT_ENOUGH_MEMORY, NULL );
        return FALSE;
    }

    return TRUE;
}


VOID
XsTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    XSINFO* pInfo;

    TRACE( "XsTerm" );

    pInfo = (XSINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\edit.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// edit.c
// Remote Access Common Dialog APIs
// List editor, string editor dialog routines
//
// 08/28/95 Steve Cobb


#include "rasdlgp.h"


//-----------------------------------------------------------------------------
// Local datatypes (alphabetically)
//-----------------------------------------------------------------------------

// List editor dialog argument block.
//
typedef struct
_LEARGS
{
    // Caller's arguments to the stub API.
    //
    DTLLIST*     pList;
    BOOL*        pfCheck;
    DWORD        dwMaxItemLen;
    TCHAR*       pszTitle;
    TCHAR*       pszItemLabel;
    TCHAR*       pszListLabel;
    TCHAR*       pszCheckLabel;
    TCHAR*       pszDefaultItem;
    INT          iSelInitial;
    DWORD*       pdwHelp;
    DWORD        dwfFlags;
    PDESTROYNODE pDestroyId;
}
LEARGS;


// List editor dialog context block.
//
typedef struct
_LEINFO
{
    // Caller's arguments to the dialog.
    //
    LEARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStItem;
    HWND hwndStList;
    HWND hwndPbAdd;
    HWND hwndPbReplace;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndPbDelete;
    HWND hwndPbOk;
    HWND hwndEb;
    HWND hwndLb;
    HWND hwndCb;

    // Convenient alternatives to (pInfo->pArgs->dwFlags & LEDFLAG_Sorted) and
    // (pInfo->pArgs->dwFlags & LEDFLAG_NoDeleteLastItem).
    //
    BOOL fSorted;
    BOOL fNoDeleteLast;

    // Button bitmaps.
    //
    HBITMAP hbmUp;
    HBITMAP hbmDown;

    // List of empty nodes whose node-IDs should be 'pDestroyId'ed if user
    // presses OK.
    //
    DTLLIST* pListDeletes;
}
LEINFO;


// String Editor dialog arument block.
//
typedef struct
_ZEARGS
{
    /* Caller's aruments to the stub API.
    */
    TCHAR*  pszIn;
    DWORD   dwSidTitle;
    DWORD   dwSidLabel;
    DWORD   cbMax;
    DWORD   dwHelpId;
    TCHAR** ppszOut;
}
ZEARGS;


// String Editor dialog context block.
//
typedef struct
_ZEINFO
{
    // Caller's arguments to the stub API.
    //
    ZEARGS* pArgs;

    // Dialog and control handles.
    //
    HWND hwndDlg;
    HWND hwndEb;
}
ZEINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

INT_PTR CALLBACK
LeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
LeAdd(
    IN LEINFO* pInfo );

BOOL
LeCommand(
    IN LEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
LeDelete(
    IN LEINFO* pInfo );

VOID
LeDown(
    IN LEINFO* pInfo );

VOID
LeEnableUpAndDownButtons(
    IN LEINFO* pInfo );

VOID
LeExitNoMemory(
    IN LEINFO* pInfo );

BOOL
LeInit(
    IN HWND hwndDlg,
    IN LEARGS* pArgs );

VOID
LeItemTextFromListSelection(
    IN LEINFO* pInfo );

VOID
LeReplace(
    IN LEINFO* pInfo );

BOOL
LeSaveSettings(
    IN LEINFO* pInfo );

VOID
LeTerm(
    IN HWND hwndDlg );

VOID
LeUp(
    IN LEINFO* pInfo );

INT_PTR CALLBACK
ZeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ZeCommand(
    IN ZEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
ZeInit(
    IN HWND hwndDlg,
    IN ZEARGS* pArgs );

VOID
ZeTerm(
    IN HWND hwndDlg );


//-----------------------------------------------------------------------------
// List Editor dialog entry point
//-----------------------------------------------------------------------------


BOOL
ListEditorDlg(
    IN HWND hwndOwner,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck,
    IN DWORD dwMaxItemLen,
    IN TCHAR* pszTitle,
    IN TCHAR* pszItemLabel,
    IN TCHAR* pszListLabel,
    IN TCHAR* pszCheckLabel,
    IN TCHAR* pszDefaultItem,
    IN INT iSelInitial,
    IN DWORD* pdwHelp,
    IN DWORD dwfFlags,
    IN PDESTROYNODE pDestroyId )

    // Pops-up the List Editor dialog.
    //
    // 'HwndOwner' is the owner of the dialog.  'PList' is, on entry, the Psz
    // list to display initially, and on successful exit, the result list.
    // 'PfCheck' is the state of the check box or NULL for the non-checkbox
    // style.  'DwMaxItemLen' is the maximum length of an individual list
    // item.  'PszTitle' is the dialog title.  'PszItemLabel' is the label
    // (and hotkey) associated with the item box.  'PszListLabel' is the label
    // (and hotkey) associated with the list.  'PszCheckLabel' is the label
    // (and hotkey) associated with the checkbox.  'PszDefaultItem' is the
    // default contents of the edit box or for the selected list text.
    // 'ISelInitial' is the item the list to initally select.  'PdwHelp' is
    // the array of CID_LE_* help contexts to use.  'DwfFlags' indicates
    // LEDFLAG_* behavior options.  'PDestroyId' is the routine to use to
    // destroy node IDs when they are deleted or NULL if none.
    //
    // Returns true if user pressed OK and succeeded, false if he pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    LEARGS args;

    TRACE( "ListEditorDlg" );

    args.pList = pList;
    args.pfCheck = pfCheck;
    args.dwMaxItemLen = dwMaxItemLen;
    args.pszTitle = pszTitle;
    args.pszItemLabel = pszItemLabel;
    args.pszListLabel = pszListLabel;
    args.pszCheckLabel = pszCheckLabel;
    args.pszDefaultItem = pszDefaultItem;
    args.iSelInitial = iSelInitial;
    args.pdwHelp = pdwHelp;
    args.dwfFlags = dwfFlags;
    args.pDestroyId = pDestroyId;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            (pfCheck)
                ? MAKEINTRESOURCE( DID_LE_ListEditor2 )
                : ((dwfFlags & LEDFLAG_Sorted)
                       ? MAKEINTRESOURCE( DID_LE_ListEditor3 )
                       : MAKEINTRESOURCE( DID_LE_ListEditor )),
            hwndOwner,
            LeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


//----------------------------------------------------------------------------
// List Editor dialog routines
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
LeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the List Editor dialog.  Parameters and return
    // value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "LeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return LeInit( hwnd, (LEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            ContextHelp( pInfo->pArgs->pdwHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return LeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            LeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
LeAdd(
    IN LEINFO* pInfo )

    // Add button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEb );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    if (pInfo->pArgs->dwfFlags & LEDFLAG_Unique)
    {
        if (ListBox_IndexFromString( pInfo->hwndLb, psz ) >= 0)
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.apszArgs[ 0 ] = psz;
            MsgDlg( pInfo->hwndDlg, SID_NotUnique, &msgargs );
            Edit_SetSel( pInfo->hwndEb, 0, -1 );
            SetFocus( pInfo->hwndEb );
            Free( psz );
            return;
        }
    }

    ListBox_SetCurSel( pInfo->hwndLb,
        ListBox_AddItem( pInfo->hwndLb, psz, 0 ) );
    Free( psz );
    LeEnableUpAndDownButtons( pInfo );
    EnableWindow( pInfo->hwndPbReplace, FALSE );

    if (!pInfo->fNoDeleteLast || ListBox_GetCount( pInfo->hwndLb ) > 1)
    {
        EnableWindow( pInfo->hwndPbDelete, TRUE );
    }

    SetWindowText( pInfo->hwndEb, TEXT("") );
    SetFocus( pInfo->hwndEb );
}


BOOL
LeCommand(
    IN LEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "LeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_LE_PB_Add:
        {
            LeAdd( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Replace:
        {
            LeReplace( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Up:
        {
            LeUp( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Down:
        {
            LeDown( pInfo );
            return TRUE;
        }

        case CID_LE_PB_Delete:
        {
            LeDelete( pInfo );
            return TRUE;
        }

        case CID_LE_EB_Item:
        {
            if (wNotification == EN_SETFOCUS || wNotification == EN_UPDATE)
            {
                TCHAR* psz = GetText( pInfo->hwndEb );

                if (psz && lstrlen( psz ) > 0 && !IsAllWhite( psz ))
                {
                    EnableWindow( pInfo->hwndPbAdd, TRUE );
                    EnableWindow( pInfo->hwndPbReplace, TRUE );
                    Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbAdd );
                }
                else
                {
                    EnableWindow( pInfo->hwndPbAdd, FALSE );
                    EnableWindow( pInfo->hwndPbReplace, FALSE );
                    Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
                }

                Free0( psz );
            }
            return TRUE;
        }

        case CID_LE_LB_List:
        {
            if (wNotification == LBN_SELCHANGE)
            {
                LeEnableUpAndDownButtons( pInfo );
                if (ListBox_GetCurSel( pInfo->hwndLb ) >= 0)
                {
                    LeItemTextFromListSelection( pInfo );
                }
            }
            return TRUE;
        }

        case CID_LE_CB_Promote:
        {
            if (wNotification == BN_SETFOCUS)
            {
                Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbOk );
            }
            return TRUE;
        }

        case IDOK:
        {
            EndDialog( pInfo->hwndDlg, LeSaveSettings( pInfo ) );
            return TRUE;
        }

        case IDCANCEL:
        {
            DTLLIST* pList;
            DTLNODE* pNode;

            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
LeDelete(
    IN LEINFO* pInfo )

    // Delete button click handler.  'PInfo' is the dialog context.
    //
{
    INT i;
    INT c;

    i = ListBox_GetCurSel( pInfo->hwndLb );
    if (pInfo->pArgs->pDestroyId)
    {
        LONG_PTR lId = ListBox_GetItemData( pInfo->hwndLb, i );
        if (lId != 0)
        {
            DTLNODE* pNode;

            pNode = DtlCreateNode( NULL, lId );
            if (!pNode)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_DisplayData,
                    ERROR_NOT_ENOUGH_MEMORY, NULL );
                EndDialog( pInfo->hwndDlg, FALSE );
                return;
            }

            DtlAddNodeFirst( pInfo->pListDeletes, pNode );
        }
    }
    ListBox_DeleteString( pInfo->hwndLb, i );
    c = ListBox_GetCount( pInfo->hwndLb );

    if (c == 0)
    {
        EnableWindow( pInfo->hwndPbReplace, FALSE );
        EnableWindow( pInfo->hwndPbDelete, FALSE );
        SetFocus( pInfo->hwndEb );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
    else
    {
        if (c == 1 && pInfo->fNoDeleteLast)
        {
            EnableWindow( pInfo->hwndPbDelete, FALSE );
        }

        if (i >= c)
        {
            i = c - 1;
        }

        ListBox_SetCurSel( pInfo->hwndLb, i );
    }

    LeEnableUpAndDownButtons( pInfo );

    if (IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndEb );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
}


VOID
LeDown(
    IN LEINFO* pInfo )

    // Down button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT i;
    LONG_PTR lId;

    ASSERT( !pInfo->fSorted );

    i = ListBox_GetCurSel( pInfo->hwndLb );
    psz = ListBox_GetPsz( pInfo->hwndLb, i );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    lId = ListBox_GetItemData( pInfo->hwndLb, i );
    ListBox_InsertString( pInfo->hwndLb, i + 2, psz );
    ListBox_SetItemData( pInfo->hwndLb, i + 2, lId );
    Free( psz );
    ListBox_DeleteString( pInfo->hwndLb, i );
    ListBox_SetCurSel( pInfo->hwndLb, i + 1 );

    if (i == ListBox_GetCount( pInfo->hwndLb ))
    {
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbUp );
        SetFocus( pInfo->hwndPbUp );
    }

    LeEnableUpAndDownButtons( pInfo );
}


VOID
LeEnableUpAndDownButtons(
    IN LEINFO* pInfo )

    // Determine if the Up and Down operations make sense and enable/disable
    // the buttons as appropriate.  'PInfo' is the dialog context.
    //
{
    INT i;
    INT c;

    if (pInfo->fSorted)
    {
        return;
    }

    i = ListBox_GetCurSel( pInfo->hwndLb );
    c = ListBox_GetCount( pInfo->hwndLb );

    EnableWindow( pInfo->hwndPbDown, (i < c - 1 ) );
    EnableWindow( pInfo->hwndPbUp, (i > 0) );
}


VOID
LeExitNoMemory(
    IN LEINFO* pInfo )

    // End the dialog reporting a memory.  'PInfo' is the dialog context.
    //
{
    ErrorDlg( pInfo->hwndDlg,
        SID_OP_DisplayData, ERROR_NOT_ENOUGH_MEMORY, NULL );
    EndDialog( pInfo->hwndDlg, FALSE );
}


BOOL
LeInit(
    IN HWND hwndDlg,
    IN LEARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    LEINFO* pInfo;
    DTLNODE* pNode;
    INT c;

    TRACE( "LeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    // Set up convenient shortcuts.
    //
    if (pArgs->dwfFlags & LEDFLAG_Sorted)
    {
        pInfo->fSorted = TRUE;
    }

    if (pArgs->dwfFlags & LEDFLAG_NoDeleteLastItem)
    {
        pInfo->fNoDeleteLast = TRUE;
    }

    pInfo->hwndStItem = GetDlgItem( hwndDlg, CID_LE_ST_Item );
    ASSERT( pInfo->hwndStItem );
    pInfo->hwndStList = GetDlgItem( hwndDlg, CID_LE_ST_List );
    ASSERT( pInfo->hwndStList );
    pInfo->hwndPbAdd = GetDlgItem( hwndDlg, CID_LE_PB_Add );
    ASSERT( pInfo->hwndPbAdd );
    pInfo->hwndPbReplace = GetDlgItem( hwndDlg, CID_LE_PB_Replace );
    ASSERT( pInfo->hwndPbReplace );
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_LE_PB_Delete );
    ASSERT( pInfo->hwndPbDelete );
    pInfo->hwndPbOk = GetDlgItem( hwndDlg, IDOK );
    ASSERT( pInfo->hwndPbOk );
    pInfo->hwndEb = GetDlgItem( hwndDlg, CID_LE_EB_Item );
    ASSERT( pInfo->hwndEb );
    pInfo->hwndLb = GetDlgItem( hwndDlg, CID_LE_LB_List );
    ASSERT( pInfo->hwndLb );

    if (pArgs->pDestroyId)
    {
        // Create the empty list of deletions.
        //
        pInfo->pListDeletes = DtlCreateList( 0L );
        if (!pInfo->pListDeletes)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    if (!pInfo->fSorted)
    {
        pInfo->hwndPbUp = GetDlgItem( hwndDlg, CID_LE_PB_Up );
        ASSERT( pInfo->hwndPbUp );
        pInfo->hwndPbDown = GetDlgItem( hwndDlg, CID_LE_PB_Down );
        ASSERT( pInfo->hwndPbDown );

        // Draw the graphical up and down arrow indicators.
        //
        pInfo->hbmUp = Button_CreateBitmap(
            pInfo->hwndPbUp, BMS_UpArrowOnRight );
        if (pInfo->hbmUp)
        {
            SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, 0,
                (LPARAM )pInfo->hbmUp );
        }

        pInfo->hbmDown = Button_CreateBitmap(
            pInfo->hwndPbDown, BMS_DownArrowOnRight );
        if (pInfo->hbmDown)
        {
            SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, 0,
                (LPARAM )pInfo->hbmDown );
        }
    }

    if (pArgs->pfCheck)
    {
        pInfo->hwndCb = GetDlgItem( hwndDlg, CID_LE_CB_Promote );
        ASSERT( pInfo->hwndCb );
        SetWindowText( pInfo->hwndCb, pArgs->pszCheckLabel );
        Button_SetCheck( pInfo->hwndCb, *pArgs->pfCheck );
    }

    Edit_LimitText( pInfo->hwndEb, pArgs->dwMaxItemLen );

    // Set caller-defined dialog title and labels.
    //
    SetWindowText( pInfo->hwndDlg, pArgs->pszTitle );
    SetWindowText( pInfo->hwndStItem, pArgs->pszItemLabel );
    SetWindowText( pInfo->hwndStList, pArgs->pszListLabel );

    // Fill the listbox.
    //
    for (pNode = DtlGetFirstNode( pArgs->pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );

        ListBox_AddItem( pInfo->hwndLb, psz, (VOID* ) DtlGetNodeId( pNode ) );
    }

    c = ListBox_GetCount( pInfo->hwndLb );
    if (c > 0)
    {
        // Select item selected by caller.
        //
        ListBox_SetCurSelNotify( pInfo->hwndLb, pArgs->iSelInitial );
        LeEnableUpAndDownButtons( pInfo );

        if (c == 1 && pInfo->fNoDeleteLast)
        {
            EnableWindow( pInfo->hwndPbDelete, FALSE );
        }
    }
    else
    {
        // Empty list.
        //
        if (!pInfo->fSorted)
        {
            EnableWindow( pInfo->hwndPbUp, FALSE );
            EnableWindow( pInfo->hwndPbDown, FALSE );
        }
        EnableWindow( pInfo->hwndPbDelete, FALSE );
    }

    // Set default edit box contents, if any.
    //
    if (pArgs->pszDefaultItem)
    {
        SetWindowText( pInfo->hwndEb, pArgs->pszDefaultItem );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }
    else
    {
        EnableWindow( pInfo->hwndPbAdd, FALSE );
        EnableWindow( pInfo->hwndPbReplace, FALSE );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.  Dlgedit.exe doesn't currently
    // support this at resource edit time.  When that's fixed set
    // DS_CONTEXTHELP there and remove this call.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
LeItemTextFromListSelection(
    IN LEINFO* pInfo )

    // Copies the currently selected item in the list to the edit box.
    // 'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT iSel;

    iSel = ListBox_GetCurSel( pInfo->hwndLb );
    if (iSel >= 0)
    {
        psz = ListBox_GetPsz( pInfo->hwndLb, iSel );
        if (psz)
        {
            SetWindowText( pInfo->hwndEb, psz );
            Free( psz );
            return;
        }
    }

    SetWindowText( pInfo->hwndEb, TEXT("") );
}


VOID
LeReplace(
    IN LEINFO* pInfo )

    // Replace button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT i;
    LONG_PTR lId;

    psz = GetText( pInfo->hwndEb );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    if (pInfo->pArgs->dwfFlags & LEDFLAG_Unique)
    {
        if (ListBox_IndexFromString( pInfo->hwndLb, psz ) >= 0)
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.apszArgs[ 0 ] = psz;
            MsgDlg( pInfo->hwndDlg, SID_NotUnique, &msgargs );
            Edit_SetSel( pInfo->hwndEb, 0, -1 );
            SetFocus( pInfo->hwndEb );
            Free( psz );
            return;
        }
    }

    i = ListBox_GetCurSel( pInfo->hwndLb );
    lId = ListBox_GetItemData( pInfo->hwndLb, i );
    ListBox_DeleteString( pInfo->hwndLb, i );

    if (pInfo->fSorted)
    {
        i = ListBox_AddItem( pInfo->hwndLb, psz, (VOID* )lId );
    }
    else
    {
        ListBox_InsertString( pInfo->hwndLb, i, psz );
        ListBox_SetItemData( pInfo->hwndLb, i, lId );
    }

    Free( psz );
    ListBox_SetCurSel( pInfo->hwndLb, i );
    SetFocus( pInfo->hwndEb );
    SetWindowText( pInfo->hwndEb, TEXT("") );
}


BOOL
LeSaveSettings(
    IN LEINFO* pInfo )

    // Saves dialog settings in the stub API caller's list.  'PInfo' is the
    // dialog context.
    //
    // Returns true if successful, false if does not validate.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    DTLLIST* pList;
    DTLLIST* pListNew;
    TCHAR* psz;
    LONG_PTR lId;
    INT c;
    INT i;

    // Make new list from list box contents.
    //
    do
    {
        pListNew = DtlCreateList( 0L );
        if (!pListNew)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = 0;
        c = ListBox_GetCount( pInfo->hwndLb );

        for (i = 0; i < c; ++i)
        {
            psz = ListBox_GetPsz( pInfo->hwndLb, i );
            if (!psz)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            lId = ListBox_GetItemData( pInfo->hwndLb, i );
            ASSERT( lId>=0 );

            pNode = DtlCreateNode( psz, lId );
            if (!pNode)
            {
                Free( psz );
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            DtlAddNodeLast( pListNew, pNode );
        }
    }
    while (FALSE);

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_DisplayData, dwErr, NULL );
        DtlDestroyList( pListNew, DestroyPszNode );
        return FALSE;
    }

    // Free all data in the old list.
    //
    while (pNode = DtlGetFirstNode( pInfo->pArgs->pList ))
    {
        Free( (TCHAR* )DtlGetData( pNode ) );
        DtlDeleteNode( pInfo->pArgs->pList, pNode );
    }

    // Free the node-IDs in the list of deletions.
    //
    if (pInfo->pListDeletes)
    {
        while (pNode = DtlGetFirstNode( pInfo->pListDeletes ))
        {
            pInfo->pArgs->pDestroyId( (DTLNODE* )DtlGetNodeId( pNode ) );
            DtlDeleteNode( pInfo->pListDeletes, pNode );
        }
    }

    // Move the new list onto caller's list.
    //
    while (pNode = DtlGetFirstNode( pListNew ))
    {
        DtlRemoveNode( pListNew, pNode );
        DtlAddNodeLast( pInfo->pArgs->pList, pNode );
    }
    DtlDestroyList( pListNew, DestroyPszNode );

    // Tell caller what the checkbox setting is.
    //
    if (pInfo->pArgs->pfCheck)
    {
        *pInfo->pArgs->pfCheck = Button_GetCheck( pInfo->hwndCb );
    }

    return TRUE;
}


VOID
LeTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    LEINFO* pInfo = (LEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "LeTerm" );

    if (pInfo)
    {
        if (pInfo->hbmUp)
        {
            DeleteObject( pInfo->hbmUp );
        }

        if (pInfo->hbmDown)
        {
            DeleteObject( pInfo->hbmDown );
        }

        DtlDestroyList( pInfo->pListDeletes, NULL );
        Free( pInfo );
    }
}


VOID
LeUp(
    IN LEINFO* pInfo )

    // Up button click handler.  'PInfo' is the dialog context.
    //
{
    TCHAR* psz;
    INT i;
    LONG_PTR lId;

    ASSERT( !pInfo->fSorted );

    i = ListBox_GetCurSel( pInfo->hwndLb );
    psz = ListBox_GetPsz( pInfo->hwndLb, i );
    if (!psz)
    {
        LeExitNoMemory( pInfo );
        return;
    }

    ListBox_InsertString( pInfo->hwndLb, i - 1, psz );
    Free( psz );
    lId = ListBox_GetItemData( pInfo->hwndLb, i + 1 );
    ListBox_DeleteString( pInfo->hwndLb, i + 1 );
    ListBox_SetItemData( pInfo->hwndLb, i - 1, lId );
    ListBox_SetCurSel( pInfo->hwndLb, i - 1 );

    if (i == 1)
    {
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbDown );
        SetFocus( pInfo->hwndPbDown );
    }

    LeEnableUpAndDownButtons( pInfo );
}


//-----------------------------------------------------------------------------
// String Editor dialog entry point
//-----------------------------------------------------------------------------

BOOL
StringEditorDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszIn,
    IN DWORD dwSidTitle,
    IN DWORD dwSidLabel,
    IN DWORD cbMax,
    IN DWORD dwHelpId,
    IN OUT TCHAR** ppszOut )

    // Pops-up the String Editor dialog.  'PszIn' is the initial setting of
    // the edit box or NULL for blank.  'DwSidTitle' and 'dwSidLabel' are the
    // string resource IDs of the dialog title and edit box label.  'CbMax' is
    // the maximum length of the to allow or 0 for no limit.  'DwHelpId' is
    // the HID_* constant to associate with the label and edit field or -1 if
    // none.
    //
    // Returns true if user pressed OK and succeeded, false if he pressed
    // Cancel or encountered an error.  If true, '*ppszNumber' is a heap block
    // with the edited result.  It is caller's responsibility to Free the
    // returned block.
    //
{
    INT_PTR nStatus;
    ZEARGS args;

    TRACE( "StringEditorDlg" );

    args.pszIn = pszIn;
    args.dwSidTitle = dwSidTitle;
    args.dwSidLabel = dwSidLabel;
    args.cbMax = cbMax;
    args.dwHelpId = dwHelpId;
    args.ppszOut = ppszOut;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_ZE_StringEditor ),
            hwndOwner,
            ZeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


//----------------------------------------------------------------------------
// String Editor dialog routines
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ZeDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Edit Phone Number dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "ZeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return ZeInit( hwnd, (ZEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ZEINFO* pInfo;

            pInfo = (ZEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            if (pInfo && pInfo->pArgs->dwHelpId != (DWORD )-1)
            {
                DWORD adwZeHelp[ (2 + 1) * 2 ];

                ZeroMemory( adwZeHelp, sizeof(adwZeHelp) );
                adwZeHelp[ 0 ] = CID_ZE_ST_String;
                adwZeHelp[ 2 ] = CID_ZE_EB_String;
                adwZeHelp[ 1 ] = adwZeHelp[ 3 ] = pInfo->pArgs->dwHelpId;

                ContextHelp( adwZeHelp, hwnd, unMsg, wparam, lparam );
                break;
            }
        }

        case WM_COMMAND:
        {
            ZEINFO* pInfo = (ZEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return ZeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            ZeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
ZeCommand(
    IN ZEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "ZeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            TRACE( "OK pressed" );
            *pInfo->pArgs->ppszOut = GetText( pInfo->hwndEb );
            EndDialog( pInfo->hwndDlg, (*pInfo->pArgs->ppszOut != NULL) );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ZeInit(
    IN HWND hwndDlg,
    IN ZEARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    TCHAR* psz;
    ZEINFO* pInfo;

    TRACE( "ZeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndEb = GetDlgItem( hwndDlg, CID_ZE_EB_String );
    ASSERT( pInfo->hwndEb );

    if (pArgs->cbMax > 0)
    {
        Edit_LimitText( pInfo->hwndEb, pArgs->cbMax );
    }

    psz = PszFromId( g_hinstDll, pArgs->dwSidTitle );
    if (psz)
    {
        SetWindowText( hwndDlg, psz );
        Free( psz );
    }

    psz = PszFromId( g_hinstDll, pArgs->dwSidLabel );
    if (psz)
    {
        HWND hwndSt = GetDlgItem( hwndDlg, CID_ZE_ST_String );
        ASSERT( hwndSt );
        SetWindowText( hwndSt, psz );
        Free( psz );
    }

    if (pArgs->pszIn)
    {
        SetWindowText( pInfo->hwndEb, pArgs->pszIn );
        Edit_SetSel( pInfo->hwndEb, 0, -1 );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.  Dlgedit.exe doesn't currently
    // support this at resource edit time.  When that's fixed set
    // DS_CONTEXTHELP there and remove this call.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
ZeTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    ZEINFO* pInfo = (ZEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "ZeTerm" );

    if (pInfo)
    {
        Free( pInfo );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\entryps.h ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// entryps.h
// Remote Access Common Dialog APIs
// Phonebook Entry property sheet
//
// 12/14/97 Shaun Cox (split out from entryps.c)


#ifndef _ENTRYPS_H_
#define _ENTRYPS_H_

#include "inetcfgp.h"
#include "netconp.h"

// Phonebook Entry property sheet context block.  All property pages refer to
// the single context block is associated with the sheet.
//
typedef struct
_PEINFO
{
    // Common input arguments.
    //
    EINFO* pArgs;

    // Property sheet dialog and property page handles.  'hwndFirstPage' is
    // the handle of the first property page initialized.  This is the page
    // that allocates and frees the context block.
    //
    // Note the "Network" page is missing.  This "NCPA" page, developed
    // separately by ShaunCo, does not use this shared area for page specfic
    // controls, instead returning users selections via the "penettab.h"
    // interface.
    //
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndGe;
    HWND hwndOe;
    HWND hwndLo;
    HWND hwndFw;

    // General page.
    //
    HWND hwndLvDevices;
    HWND hwndLbDevices;
    HWND hwndPbUp;
    HWND hwndPbDown;
    HWND hwndCbSharedPhoneNumbers;
    HWND hwndPbConfigureDevice;
    HWND hwndGbPhoneNumber;
    HWND hwndStAreaCodes;
    HWND hwndClbAreaCodes;
    HWND hwndStCountryCodes;
    HWND hwndLbCountryCodes;
    HWND hwndStPhoneNumber;
    HWND hwndEbPhoneNumber;
    HWND hwndCbUseDialingRules;
    HWND hwndPbDialingRules;
    HWND hwndPbAlternates;
    HWND hwndCbShowIcon;

    HWND hwndEbHostName;
    HWND hwndCbDialAnotherFirst;
    HWND hwndLbDialAnotherFirst;

    HWND hwndEbBroadbandService;

    // Options page.
    //
    HWND hwndCbDisplayProgress;
    HWND hwndCbPreviewUserPw;
    HWND hwndCbPreviewDomain;
    HWND hwndCbPreviewNumber;
    HWND hwndEbRedialAttempts;
    HWND hwndLbRedialTimes;
    HWND hwndLbIdleTimes;
    HWND hwndCbRedialOnDrop;
    HWND hwndGbMultipleDevices;
    HWND hwndLbMultipleDevices;
    HWND hwndPbConfigureDialing;
    HWND hwndPbX25;
    HWND hwndPbTunnel;
    HWND hwndRbPersistent;  // only for fRouter
    HWND hwndRbDemandDial;  // only for fRouter

    // Security page.
    //
    HWND hwndGbSecurityOptions;
    HWND hwndRbTypicalSecurity;
    HWND hwndStAuths;
    HWND hwndLbAuths;
    HWND hwndCbUseWindowsPw;
    HWND hwndCbEncryption;
    HWND hwndRbAdvancedSecurity;
    HWND hwndStAdvancedText;
    HWND hwndPbAdvanced;
    HWND hwndPbIPSec;       //Only for VPN
    HWND hwndGbScripting;
    HWND hwndCbRunScript;
    HWND hwndCbTerminal;
    HWND hwndLbScripts;
    HWND hwndPbEdit;
    HWND hwndPbBrowse;

    // Networking page.
    //
    HWND hwndLbServerType;
    HWND hwndPbSettings;
    HWND hwndLvComponents;
    HWND hwndPbAdd;
    HWND hwndPbRemove;
    HWND hwndPbProperties;
    HWND hwndDescription;

    // Indicates that the informational popup noting that SLIP does not
    // support any authentication settings should appear the next time the
    // Security page is activated.
    //
    BOOL fShowSlipPopup;

    // The "restore" states of the typical security mode listbox and
    // checkboxes.  Initialized in LoInit and set whenever the controls are
    // disabled.
    //
    DWORD iLbAuths;
    BOOL fUseWindowsPw;
    BOOL fEncryption;

    // MoveUp/MoveDown icons, for enabled/disabled cases.
    //
    HANDLE hiconUpArr;
    HANDLE hiconDnArr;
    HANDLE hiconUpArrDis;
    HANDLE hiconDnArrDis;

    // The currently displayed link node, i.e. either the node of the selected
    // device or the shared node.  This is a shortcut for GeAlternates, that
    // keeps all the lookup code in GeUpdatePhoneNumberFields.
    //
    DTLNODE* pCurLinkNode;

    // The currently selected device.  Used to store phone number information
    // for the just unselected device when a new device is selected.
    //
    INT iDeviceSelected;

    // Complex phone number helper context block, and a flag indicating if the
    // block has been initialized.
    //
    CUINFO cuinfo;
    BOOL fCuInfoInitialized;

    // After dial scripting helper context block, and a flag indicating if the
    // block has been initialized.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;

    // Flags whether the user authorized a reboot after installing or removing
    // and networking component.
    //
    BOOL fRebootAlreadyRequested;

    // List of area codes passed CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one from the
    // PBUSER.
    //
    DTLLIST* pListAreaCodes;

    // Stash/restore values for Options page checkboxes.
    //
    BOOL fPreviewUserPw;
    BOOL fPreviewDomain;

    // Set when user changes to "Typical smartcard" security.  This causes the
    // registry based association of EAP per-user information to be discarded,
    // sort of like flushing cached credentials.
    //
    BOOL fDiscardEapUserData;

    // Set true on the first click of the Typical or Advanced radio button on
    // the security page, false before.  The first click is the one
    // artificially generated in LoInit.  The Advanced click handler uses the
    // information to avoid incorrectly adopting the Typical defaults in the
    // case of Advanced settings.
    //
    BOOL fAuthRbInitialized;

    // Used by the networking page
    //
    INetCfg*                        pNetCfg;
    BOOL                            fInitCom;
    BOOL                            fReadOnly;  // Netcfg was initialized in
                                                // read-only mode
    BOOL                            fNonAdmin;  // Run in non-admin mode (406630)                                                
    BOOL                            fNetCfgLock;// NetCfg needs to be unlocked
                                                // when uninited.
    SP_CLASSIMAGELIST_DATA          cild;
    INetConnectionUiUtilities *     pNetConUtilities;
    IUnknown*                       punkUiInfoCallback;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
    BOOL fComInitialized;

    // Keep track of whether we have shown this warning, or if it was disabled by the user
    //
    BOOL fShowDisableFirewallWarning;
}
PEINFO;

INetCfgComponent*
PComponentFromItemIndex (
    HWND hwndLv,
    int  iItem);

INetCfgComponent*
PComponentFromCurSel (
    HWND hwndLv,
    int* piItem);

HRESULT
HrNeRefreshListView (
    PEINFO* pInfo);


void
NeEnableComponent (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent,
    BOOL                fEnable);

BOOL
NeIsComponentEnabled (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent);

void
NeShowComponentProperties (
    IN PEINFO*  pInfo);

ULONG
ReleaseObj (
    void* punk);


#endif // _ENTRYPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\dial.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// dial.c
// Remote Access Common Dialog APIs
// RasDialDlg APIs
//
// 11/19/95 Steve Cobb


#include "rasdlgp.h"
#include "raseapif.h"
#include "inetcfgp.h"
#include "netconp.h"

// Posted message codes for tasks that should not or cannot occur in the
// RasDial callback.
//
#define WM_RASEVENT       0xCCCC
#define WM_RASERROR       0xCCCD
#define WM_RASDIAL        0xCCCE
#define WM_RASBUNDLEERROR 0xCCCF

// Dialer dialog mode bits
//
#define DR_U 0x00000001 // Username and password present
#define DR_D 0x00000002 // Domain present
#define DR_N 0x00000004 // Phone number present
#define DR_L 0x00000008 // Location controls present
#define DR_I 0x00000010 // Eap identity dialog

// Internal constants used by DrXxx routines to implement the "manual edit"
// combo-box.
//
#define DR_WM_SETTEXT 0xCCC0
#define DR_BOGUSWIDTH 19591

#define EAP_RASTLS      13


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwDrHelp[] =
{
    CID_DR_BM_Useless,      HID_DR_BM_Useless,
    CID_DR_ST_User,         HID_DR_EB_User,
    CID_DR_EB_User,         HID_DR_EB_User,
    CID_DR_ST_Password,     HID_DR_EB_Password,
    CID_DR_EB_Password,     HID_DR_EB_Password,
    CID_DR_ST_Domain,       HID_DR_EB_Domain,
    CID_DR_EB_Domain,       HID_DR_EB_Domain,
    CID_DR_CB_SavePassword, HID_DR_CB_SavePassword,
    CID_DR_ST_Numbers,      HID_DR_CLB_Numbers,
    CID_DR_CLB_Numbers,     HID_DR_CLB_Numbers,
    CID_DR_ST_Locations,    HID_DR_LB_Locations,
    CID_DR_LB_Locations,    HID_DR_LB_Locations,
    CID_DR_PB_Rules,        HID_DR_PB_Rules,
    CID_DR_PB_Properties,   HID_DR_PB_Properties,
    CID_DR_PB_DialConnect,  HID_DR_PB_DialConnect,
    CID_DR_PB_Cancel,       HID_DR_PB_Cancel,
    CID_DR_PB_Help,         HID_DR_PB_Help,
    CID_DR_RB_SaveForMe,    HID_DR_RB_SaveForMe,
    CID_DR_RB_SaveForEveryone, HID_DR_RB_SaveForEveryone,
    0, 0
};

static DWORD g_adwCpHelp[] =
{
    CID_CP_ST_Explain,         HID_CP_ST_Explain,
    CID_CP_ST_OldPassword,     HID_CP_EB_OldPassword,
    CID_CP_EB_OldPassword,     HID_CP_EB_OldPassword,
    CID_CP_ST_Password,        HID_CP_EB_Password,
    CID_CP_EB_Password,        HID_CP_EB_Password,
    CID_CP_ST_ConfirmPassword, HID_CP_EB_ConfirmPassword,
    CID_CP_EB_ConfirmPassword, HID_CP_EB_ConfirmPassword,
    0, 0
};

static DWORD g_adwDcHelp[] =
{
    CID_DC_ST_Explain, HID_DC_ST_Explain,
    CID_DC_ST_Number,  HID_DC_EB_Number,
    CID_DC_EB_Number,  HID_DC_EB_Number,
    0, 0
};

static DWORD g_adwDeHelp[] =
{
    CID_DE_PB_More, HID_DE_PB_More,
    IDOK,           HID_DE_PB_Redial,
    0, 0
};

static DWORD g_adwPrHelp[] =
{
    CID_PR_ST_Text,             HID_PR_ST_Text,
    CID_PR_CB_DisableProtocols, CID_PR_CB_DisableProtocols,
    IDOK,                       HID_PR_PB_Accept,
    IDCANCEL,                   HID_PR_PB_HangUp,
    0, 0
};

static DWORD g_adwUaHelp[] =
{
    CID_UA_ST_UserName,     HID_UA_EB_UserName,
    CID_UA_EB_UserName,     HID_UA_EB_UserName,
    CID_UA_ST_Password,     HID_UA_EB_Password,
    CID_UA_EB_Password,     HID_UA_EB_Password,
    CID_UA_ST_Domain,       HID_UA_EB_Domain,
    CID_UA_EB_Domain,       HID_UA_EB_Domain,
    CID_UA_CB_SavePassword, HID_UA_CB_SavePassword,
    0, 0
};

CONST WCHAR g_pszSavedPasswordToken[] = L"****************";
#define g_dwSavedPasswordTokenLength \
    ( sizeof(g_pszSavedPasswordToken) / sizeof(TCHAR) )

// Save password macro, determines if either User or Global password is saved
// (p) must be a pointer to a DINFO struct (see dial.c)
//
// Whistler bug: 288234 When switching back and forth from "I connect" and
// "Any user connects" password is not caching correctly
//
#define HaveSavedPw(p) \
            ((p)->fHaveSavedPwUser || (p)->fHaveSavedPwGlobal)

//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Dial dialogs common context block.  This block contains information common
// to more than one dialog in the string of dial-related dialogs.
//
typedef struct
_DINFO
{
    // Caller's  arguments to the RAS API.  Outputs in 'pArgs' are visible to
    // the API which has the address of same.  Careful using 'pszEntry' as
    // 'pEntry->pszEntryName' is generally more appropriate, the latter
    // reflecting the name of any prerequisite entry while the prequisite is
    // being dialed.
    //
    LPTSTR pszPhonebook;
    LPTSTR pszEntry;
    LPTSTR pszPhoneNumber;
    RASDIALDLG* pArgs;

    // Phonebook settings read from the phonebook file.  All access should be
    // thru 'pFile'.  'PFile' is set to either '&filePrereq' or 'pFileMain'
    // depending on 'fFilePrereqOpen'.  'File' will only be used in cases
    // where the open phonebook is not passed thru the reserved word hack, and
    // in that case 'pFileMain' will point to it.  'FilePrereq' is the
    // phonebook file of the prequisite entry which may be different from the
    // main entry.  During prerequisite dial 'pFile' points to 'filePrereq'
    // rather than 'file' and 'fFilePrereqOpen is true.  Otherwise, 'pFile'
    // points to whatever 'pFileMain' points at.
    //
    PBFILE* pFile;
    PBFILE* pFileMain;
    PBFILE file;
    PBFILE filePrereq;
    BOOL fFilePrereqOpen;
    BOOL fIsPublicPbk;

    // Global preferences read via phonebook library.  All access should be
    // thru 'pUser' as 'user' will only be used in cases where the preferences
    // are not passed thru the reserved word hack.
    //
    PBUSER* pUser;
    PBUSER user;

    // User credentials provided by API caller for "during logon" dialing
    // where there is no current user.  If user changes the credentials
    // *pfNoUserChanged is set and the 'pNoUser' credentials updated.
    //
    RASNOUSER* pNoUser;
    BOOL* pfNoUserChanged;

    // Set if the call is unattended, i.e. a call by RASAUTO to redial a
    // failed link.
    //
    BOOL fUnattended;

    // Private flags from calling RAS API, the first informing us he wants to
    // be hidden off the desktop while we dial, and the second that he will
    // close if we return "connected" so we can avoid flicker and not bother
    // restoring him.
    //
    BOOL fMoveOwnerOffDesktop;
    BOOL fForceCloseOnDial;

    // Set when something occurs during dial that affects the phonebook entry.
    // The entry is re-read after a successful connection.
    //
    BOOL fResetAutoLogon;
    DWORD dwfExcludedProtocols;
    DTLLIST* pListPortsToDelete;

    // The entry node and a shortcut pointer to the entry inside.
    //
    DTLNODE* pNode;
    PBENTRY* pEntry;

    // The entry of the main entry that referred to any prerequisite entry
    // that might be contained by 'pEntry'.  If no prerequisite entry is
    // involved this is the same as 'pEntry'.
    //
    PBENTRY* pEntryMain;

    // Set is admin has disabled the save password feature in the registry.
    //
    BOOL fDisableSavePw;

    // Set true if a cached password is available for the entry.
    //
    BOOL fHaveSavedPwUser;      // whether there are saved per-user creds
    BOOL fHaveSavedPwGlobal;    // whether there are saved per-connect creds

    // Set when the dial in progress is the prerequisite entry, rather than
    // the main entry.
    //
    BOOL fPrerequisiteDial;

    // Set when calling RasDial on a connected entry to add a reference only.
    // All interaction with user is skipped in this case.  See bug 272794.
    //
    BOOL fDialForReferenceOnly;

    // The dial parameters used on this connection attempt.  Initialized in
    // RasDialDlgW.  Credentials are updated by DialerDlg.  Callback number is
    // updated by DialProgressDlg.
    //
    RASDIALPARAMS rdp;      // actual dial parameters passed to RasDial
    RASDIALPARAMS rdpu;     // per-user credentials
    RASDIALPARAMS rdpg;     // per-connection credentials

    // The dial parameter extensions used on this connection attempt.  Set in
    // RasDialDlgW, except hwndOwner which is set in DialProgressDlg.
    //
    RASDIALEXTENSIONS rde;
}
DINFO;


// Dialer dialogs argument block.  Used for all 5 variations of the dialer.
//
typedef struct
_DRARGS
{
    DINFO* pDinfo;
    DWORD dwfMode;
    DWORD fReload;
}
DRARGS;


// Dialer dialogs context block.  Used for all 5 variations of the dialer.
//
typedef struct
DRINFO
{
    // Common dial context information including the RAS API arguments.
    //
    DRARGS* pArgs;

    // Handle of the dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbUser;
    HWND hwndEbPw;
    HWND hwndEbDomain;
    HWND hwndCbSavePw;
    HWND hwndRbSaveForMe;
    HWND hwndRbSaveForEveryone;
    HWND hwndClbNumbers;
    HWND hwndStLocations;
    HWND hwndLbLocations;
    HWND hwndPbRules;
    HWND hwndPbProperties;
    HWND hwndBmDialer;

    // Whistler bug: 195480 Dial-up connection dialog - Number of
    // asterisks does not match the length of the password and causes
    // confusion
    //
    WCHAR szPasswordChar;
    HFONT hNormalFont;
    HFONT hItalicFont;

    // TAPI session handle.
    //
    HLINEAPP hlineapp;

    // The phonebook entry link containing the displayed phone number list.
    // Set up only when DR_N mode bit is set.
    //
    DTLNODE* pLinkNode;
    PBLINK* pLink;

    // The index of the item initially selected in the phone number list.
    //
    DWORD iFirstSelectedPhone;

    // Window handles and original window procedure of the subclassed
    // 'hwndClbNumbers' control's edit-box and list-box child windows.
    //
    HWND hwndClbNumbersEb;
    HWND hwndClbNumbersLb;
    WNDPROC wndprocClbNumbersEb;
    WNDPROC wndprocClbNumbersLb;
    INetConnectionUiUtilities * pNetConUtilities;

    // Set if COM has been initialized (necessary for calls to netshell).
    //
    BOOL fComInitialized;

    // Handle to the original bitmap for the dialer if it is modified 
    // in DrSetBitmap
    //
    HBITMAP hbmOrig;
    
}
DRINFO;


// Context of an item in the dialer's 'ClbNumbers' list.
//
typedef struct
_DRNUMBERSITEM
{
    TCHAR* pszNumber;
    PBPHONE* pPhone;
}
DRNUMBERSITEM;


// Subentry state information.
//
typedef struct
_DPSTATE
{
    RASCONNSTATE state;
    DWORD dwError;
    DWORD dwExtendedError;
    TCHAR szExtendedError[ NETBIOS_NAME_LEN + 1 ];
    TCHAR* pszStatusArg;
    TCHAR* pszFormatArg;
    PBDEVICETYPE pbdt;
    DWORD sidState;
    DWORD sidFormatMsg;
    DWORD sidPrevState;
    BOOL fNotPreSwitch;
    HRASCONN hrasconnLink;
}
DPSTATE;


// Dial Progress dialog context block.
//
typedef struct
_DPINFO
{
    // When the block is valid contains the value 0xC0BBC0DE, otherwise 0.
    // Used as a workaround until RasDial is fixed to stop calling
    // RasDialFunc2 after being told not to, see bug 49469.
    //
    DWORD dwValid;

    // RAS API arguments.
    //
    DINFO* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndStState;

    // The saved username and password that authenticated but resulted in a
    // change password event.  If the change password operation fails these
    // are restored to make the redial button work properly.
    //
    TCHAR* pszGoodUserName;
    TCHAR* pszGoodPassword;

    // The handle to the RAS connection being initiated.
    //
    HRASCONN hrasconn;

    // The original window proc we subclassed.
    //
    WNDPROC pOldWndProc;

    // Number of auto-redials not yet attempted on the connection.
    //
    DWORD dwRedialAttemptsLeft;

    // Array of RasDial states, one per subentry, set by DpRasDialFunc2 and
    // used by DpRasDialEvent.
    //
    DPSTATE* pStates;
    DWORD cStates;

    // The number of the most advanced subentry and the "latest" state it has
    // reached.  Note that certain states, like RASCS_AuthNotify, are
    // revisited after reaching a "later" state.  Such changes are ignored.
    //
    RASCONNSTATE state;
    DWORD dwSubEntry;

    // Flag indicating that RasDial callbacks are active.  The callback
    // context must not be destroyed when this flag is set.  Access to this
    // field is protected by 'g_hmutexCallbacks'.  See DpCallbacksFlag().
    //
    BOOL fCallbacksActive;

    //Add a per-thread Terminate flag for whistler bug 277365,291613  gangz
    //
    BOOL fTerminateAsap;
    LONG ulCallbacksActive;

    //for whistler bug 381337
    //
    BOOL fCancelPressed;
}
DPINFO;


// Dial Error dialog argument block.
//
typedef struct
_DEARGS
{
    TCHAR* pszEntry;
    DWORD dwError;
    DWORD sidState;
    TCHAR* pszStatusArg;
    DWORD sidFormatMsg;
    TCHAR* pszFormatArg;
    LONG lRedialCountdown;
    BOOL fPopupOnTop;
}
DEARGS;


// Dial Error dialog context block.
//
typedef struct
_DEINFO
{
    // Caller's arguments to the stub API.
    //
    DEARGS* pArgs;

    // Handle of dialog and controls.
    //
    HWND hwndDlg;
    HWND hwndStText;
    HWND hwndPbRedial;
    HWND hwndPbCancel;
    HWND hwndPbMore;

    // Number of seconds remaining in "Redial=x" countdown or -1 if inactive.
    //
    LONG lRedialCountdown;
}
DEINFO;


// Projection Result dialog argument block.
//
typedef struct
_PRARGS
{
    TCHAR* pszLines;
    BOOL* pfDisableFailedProtocols;
}
PRARGS;


// Change Password dialog argument block.
//
typedef struct
_CPARGS
{
    BOOL fOldPassword;
    TCHAR* pszOldPassword;
    TCHAR* pszNewPassword;
}
CPARGS;


// Change Password dialog context block.
// (unconventional name because CPINFO conflicts with a system header)
//
typedef struct
_CPWINFO
{
    // Caller's arguments to the stub API.
    //
    CPARGS* pArgs;

    // Handle of dialog and controls.
    //
    HWND hwndDlg;
    HWND hwndEbOldPassword;
    HWND hwndEbNewPassword;
    HWND hwndEbNewPassword2;
}
CPWINFO;


// Retry Authentication dialog context block.
//
typedef struct
UAINFO
{
    // Commond dial context including original RAS API arguments.
    //
    DINFO* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbUserName;
    HWND hwndEbPassword;
    HWND hwndEbDomain;
    HWND hwndCbSavePw;

    // Set when the password field contains a phony password in place of the
    // "" one we don't really know.
    //
    BOOL fAutoLogonPassword;

    // Set when the Domain field is present.
    //
    BOOL fDomain;
}
UAINFO;

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
BeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
BeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
BeFillLvErrors(
    IN HWND hwndLv,
    IN DPINFO* pInfo );

TCHAR*
BeGetErrorPsz(
    IN DWORD dwError );

BOOL
BeInit(
    IN HWND hwndDlg,
    IN DPINFO* pArgs );

LVXDRAWINFO*
BeLvErrorsCallback(
    IN HWND hwndLv,
    IN DWORD dwItem );

BOOL
BundlingErrorsDlg(
    IN OUT DPINFO* pInfo );

BOOL
ChangePasswordDlg(
    IN HWND hwndOwner,
    IN BOOL fOldPassword,
    OUT TCHAR* pszOldPassword,
    OUT TCHAR* pszNewPassword );

BOOL
CpCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CpInit(
    IN HWND hwndDlg,
    IN CPARGS* pArgs );

BOOL
CcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CcInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo );

VOID
ConnectCompleteDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo );

BOOL
DcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DcInit(
    IN HWND hwndDlg,
    IN TCHAR* pszNumber );

VOID
DeAdjustPbRedial(
    IN DEINFO* pInfo );

BOOL
DeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DeInit(
    IN HWND hwndDlg,
    IN DEARGS* pArgs );

DWORD
DeleteSavedCredentials(
    IN DINFO* pDinfo,
    IN HWND   hwndDlg,
    IN BOOL   fDefault,
    IN BOOL   fDeleteIdentity );

VOID
DeTerm(
    IN HWND hwndDlg );

BOOL
DialCallbackDlg(
    IN HWND hwndOwner,
    IN OUT TCHAR* pszNumber );

BOOL
DialErrorDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszEntry,
    IN DWORD dwError,
    IN DWORD sidState,
    IN TCHAR* pszStatusArg,
    IN DWORD sidFormatMsg,
    IN TCHAR* pszFormatArg,
    IN LONG lRedialCountdown,
    IN BOOL fPopupOnTop );

BOOL
DialerDlg(
    IN HWND hwndOwner,
    IN OUT DINFO* pInfo );

BOOL
DialProgressDlg(
    IN DINFO* pInfo );

VOID
DpAppendBlankLine(
    IN OUT TCHAR* pszLines );

VOID
DpAppendConnectErrorLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol,
    IN DWORD dwError );

VOID
DpAppendConnectOkLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol );

VOID
DpAppendFailCodeLine(
    IN OUT TCHAR* pszLines,
    IN DWORD dw );

VOID
DpAppendNameLine(
    IN OUT TCHAR* pszLines,
    IN TCHAR* psz );

VOID
DpAuthNotify(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpCallbackSetByCaller(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

BOOL
DpCallbacksFlag(
    IN DPINFO* pInfo,
    IN INT nSet );

VOID
DpCancel(
    IN DPINFO* pInfo );

BOOL
DpCommand(
    IN DPINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
DpConnectDevice(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpDeviceConnected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

VOID
DpDial(
    IN DPINFO* pInfo,
    IN BOOL fPauseRestart );

INT_PTR CALLBACK
DpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DpError(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

DWORD
DpEvent(
    IN DPINFO* pInfo,
    IN DWORD dwSubEntry );

BOOL
DpInit(
    IN HWND hwndDlg,
    IN DINFO* pArgs );

VOID
DpInitStates(
    DPINFO* pInfo );

BOOL
DpInteractive(
    IN DPINFO* pInfo,
    IN DPSTATE* pState,
    OUT BOOL* pfChange );

BOOL
DpIsLaterState(
    IN RASCONNSTATE stateNew,
    IN RASCONNSTATE stateOld );

BOOL
DpPasswordExpired(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

BOOL
DpProjected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState );

BOOL
DpProjectionError(
    IN RASPPPNBF* pnbf,
    IN RASPPPIPX* pipx,
    IN RASPPPIP* pip,
    OUT BOOL* pfIncomplete,
    OUT DWORD* pdwfFailedProtocols,
    OUT TCHAR** ppszLines,
    OUT DWORD* pdwError );

DWORD WINAPI
DpRasDialFunc2(
    ULONG_PTR dwCallbackId,
    DWORD dwSubEntry,
    HRASCONN hrasconn,
    UINT unMsg,
    RASCONNSTATE state,
    DWORD dwError,
    DWORD dwExtendedError );

VOID
DpTerm(
    IN HWND hwndDlg );

INT_PTR CALLBACK
DrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL CALLBACK
DrClbNumbersEnumChildProc(
    IN HWND hwnd,
    IN LPARAM lparam );

BOOL CALLBACK
DrClbNumbersEnumWindowsProc(
    IN HWND hwnd,
    IN LPARAM lparam );

BOOL
DrCommand(
    IN DRINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
DrEditSelectedLocation(
    IN DRINFO* pInfo );

DWORD
DrFillLocationList(
    IN DRINFO* pInfo );

VOID
DrFillNumbersList(
    IN DRINFO* pInfo );

DWORD
DrFindAndSubclassClbNumbersControls(
    IN DRINFO* pInfo );

VOID
DrFreeClbNumbers(
    IN DRINFO* pInfo );

BOOL
DrInit(
    IN HWND hwndDlg,
    IN DRARGS* pArgs );

VOID
DrLocationsSelChange(
    IN DRINFO* pInfo );

VOID
DrNumbersSelChange(
    IN DRINFO* pInfo );

DWORD
DrPopulateIdentificationFields(
    IN DRINFO* pInfo, 
    IN BOOL fForMe);

DWORD
DrPopulatePasswordField(
    IN DRINFO* pInfo,
    IN BOOL fInit,
    IN BOOL fDisable );

VOID
DrProperties(
    IN DRINFO* pInfo );

VOID
DrSave(
    IN DRINFO* pInfo );

DWORD
DrSetBitmap(
    IN DRINFO* pInfo);
    
VOID
DrSetClbNumbersText(
    IN DRINFO* pInfo,
    IN TCHAR* pszText );

VOID
DrTerm(
    IN HWND hwndDlg );

LRESULT APIENTRY
DpWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam );

DWORD
FindEntryAndSetDialParams(
    IN DINFO* pInfo );

INT_PTR CALLBACK
PrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PrCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
PrInit(
    IN HWND hwndDlg,
    IN PRARGS* pArgs );

BOOL
ProjectionResultDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszLines,
    OUT BOOL* pfDisableFailedProtocols );

BOOL
RetryAuthenticationDlg(
    IN HWND hwndOwner,
    IN DINFO* pDinfo );

INT_PTR CALLBACK
UaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
UaCommand(
    IN UAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
UaInit(
    IN HWND   hwndDlg,
    IN DINFO* pArgs );

VOID
UaSave(
    IN UAINFO* pInfo );

VOID
UaTerm(
    IN HWND hwndDlg );

BOOL
VpnDoubleDialDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo );

INT_PTR CALLBACK
ViDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ViCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
ViInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo );


//-----------------------------------------------------------------------------
// External entry points
//-----------------------------------------------------------------------------

typedef struct EAPFREE_DATA {
    BOOL bInitialized;
    HINSTANCE hLib;
    RASEAPFREE pFreeFunc;
} EAPFREE_DATA;

//Add those OutputDebug_XXXX() functions for debug use when debugging 291613
//        gangz
//
void    OutputDebug_DWCODE(DWORD dwCode)
{
    WCHAR tmpBuf[100];

    wsprintf(tmpBuf, 
             L"The dwCode returned is %x\n", dwCode);
             
    OutputDebugStringW(tmpBuf);
}

void  OutputDebug_NumOfCallbacksActive(ULONG ulCallbacksActive)
{
    WCHAR tmpBuf[100];

    wsprintf(tmpBuf, 
             L"Current CallbacksActive is %x\n", 
             ulCallbacksActive);
             
    OutputDebugStringW(tmpBuf);
}

void OutputDebug_ThreadId()
{
    DWORD dwId;
    WCHAR tmpBuf[100];


    dwId = GetCurrentThreadId();
    
    wsprintf(tmpBuf, L"Current Thread is %x\n", dwId);
    OutputDebugStringW(tmpBuf);
  
}

void OutputDebug_ProcessThreadId()
{
    DWORD dwIdProc, dwIdThread;
    WCHAR tmpBuf[100];

    dwIdProc    = GetCurrentProcessId();
    dwIdThread  = GetCurrentThreadId();
    
    wsprintf(tmpBuf, L"Current Proc is: %x , Thread is: %x\n", dwIdProc, dwIdThread);
    OutputDebugStringW(tmpBuf);
  
}

//
// Raises the appriate eap indentity dialog
//
DWORD
DialerDlgEap (
    IN  HWND hwndOwner,
    IN  PWCHAR lpszPhonebook,
    IN  PWCHAR lpszEntry,
    IN  PBENTRY * pEntry,
    IN  DINFO *pInfo,
    OUT PBYTE * ppUserDataOut,
    OUT DWORD * lpdwSizeOfUserDataOut,
    OUT LPWSTR * lplpwszIdentity,
    OUT PHANDLE phFree
    )
{
    DWORD dwErr, dwInSize = 0;
    PBYTE pbUserIn = NULL;
    HINSTANCE hLib = NULL;
    EAPFREE_DATA * pFreeData = NULL;
    DTLLIST * pListEaps = NULL;
    DTLNODE * pEapcfgNode = NULL;
    EAPCFG * pEapcfg = NULL;
    RASEAPFREE pFreeFunc = NULL;
    RASEAPGETIDENTITY pIdenFunc = NULL;
    DWORD dwFlags;
    DWORD cbData = 0;
    PBYTE pbData = NULL;

    // Initialize the free data handle we'll return
    pFreeData  = Malloc ( sizeof(EAPFREE_DATA) );
    if (pFreeData == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    ZeroMemory( pFreeData, sizeof(EAPFREE_DATA) );

    // Make sure we're configured with some list of
    // eap configuration options
    pListEaps = ReadEapcfgList( NULL );
    if (pListEaps == NULL)
    {
        Free(pFreeData);
        return ERROR_CAN_NOT_COMPLETE;
    }

    __try {
        // Find the eap node we're interested in
        pEapcfgNode = EapcfgNodeFromKey(
                        pListEaps,
                        pEntry->dwCustomAuthKey );
        if (pEapcfgNode)
            pEapcfg = (EAPCFG*)DtlGetData( pEapcfgNode );
        else
            return ERROR_CAN_NOT_COMPLETE;

        // Only call eap identity ui if we're told not to
        // get the user name through the standard credentials
        // dialog
        if (pEapcfg->dwStdCredentialFlags &
               EAPCFG_FLAG_RequireUsername)
        {
            return NO_ERROR;
        }

        if(!pInfo->pNoUser)
        {
            // Get the size of the input user data
            dwErr = RasGetEapUserData(
                        NULL,
                        lpszPhonebook,
                        lpszEntry,
                        NULL,
                        &dwInSize);

            // Read in the user data
            if (dwErr != NO_ERROR)  {
                if (dwErr == ERROR_BUFFER_TOO_SMALL) {
                    if (dwInSize == 0)
                    {
                        pbUserIn = NULL;
                        // return ERROR_CAN_NOT_COMPLETE;
                    }
                    else
                    {
                        // Allocate a blob to hold the data
                        pbUserIn = Malloc (dwInSize);
                        if (pbUserIn == NULL)
                            return ERROR_NOT_ENOUGH_MEMORY;

                        // Read in the new blob
                        dwErr = RasGetEapUserData(
                                    NULL,
                                    lpszPhonebook,
                                    lpszEntry,
                                    pbUserIn,
                                    &dwInSize);
                        if (dwErr != NO_ERROR)
                            return dwErr;
                    }
                }
                else
                    return dwErr;
            }
        }
        else
        {
            INTERNALARGS *piargs;

            piargs = (INTERNALARGS *) pInfo->pArgs->reserved;

            if(     (NULL != piargs)
                &&  (NULL != piargs->pvEapInfo)
                // pmay: 386489
                //
                &&  (pEntry->dwCustomAuthKey == EAPCFG_DefaultKey))
            {
                pbUserIn = (BYTE *) piargs->pvEapInfo;
                dwInSize = ((EAPLOGONINFO *) piargs->pvEapInfo)->dwSize;
            }
            else
            {
                pbUserIn = NULL;
                dwInSize = 0;
            }
        }

        // Load the identity library
        hLib = LoadLibrary (pEapcfg->pszIdentityDll);
        if (hLib == NULL)
            return GetLastError();

        // Get pointers to the functions we'll be needing
        pIdenFunc = (RASEAPGETIDENTITY)
                        GetProcAddress(hLib, "RasEapGetIdentity");
        pFreeFunc = (RASEAPFREE) GetProcAddress(hLib, "RasEapFreeMemory");
        if ( (pFreeFunc == NULL) || (pIdenFunc == NULL) )
            return ERROR_CAN_NOT_COMPLETE;

        dwFlags = (pInfo->pNoUser) ? RAS_EAP_FLAG_LOGON : 0;
        if (!pEntry->fAutoLogon && pEntry->fPreviewUserPw)
        {
            dwFlags |= RAS_EAP_FLAG_PREVIEW;
        }

        if(pInfo->fUnattended)
        {
            dwFlags &= ~RAS_EAP_FLAG_PREVIEW;
        }
        
        dwErr = DwGetCustomAuthData(
                        pEntry,
                        &cbData,
                        &pbData);

        if(ERROR_SUCCESS != dwErr)
        {
            return dwErr;
        }

        // Call the eap-provided identity UI
        dwErr = (*(pIdenFunc))(
                    pEntry->dwCustomAuthKey,
                    hwndOwner,
                    dwFlags,
                    lpszPhonebook,
                    lpszEntry,
                    pbData,
                    cbData,
                    pbUserIn,
                    dwInSize,
                    ppUserDataOut,
                    lpdwSizeOfUserDataOut,
                    lplpwszIdentity);
        if (dwErr != NO_ERROR)
            return dwErr;

        // Assign the data used to cleanup later
        pFreeData->bInitialized = TRUE;
        pFreeData->hLib = hLib;
        pFreeData->pFreeFunc = pFreeFunc;
        *phFree = (HANDLE)pFreeData;
    }
    __finally {
        if (pListEaps)
            DtlDestroyList(pListEaps, NULL);
        if (    (!pInfo->pNoUser)
            &&  (pbUserIn))
        {
            Free0(pbUserIn);
        }
        if ((pFreeData) && (!pFreeData->bInitialized)) 
        {
            Free(pFreeData);
            if(NULL != hLib)
            {            
                FreeLibrary(hLib);
            }
        }
    }

    return NO_ERROR;
}

DWORD
DialerEapCleanup (
    IN HANDLE hEapFree,
    IN PBYTE pUserDataOut,
    IN LPWSTR lpwszIdentity)
{
    EAPFREE_DATA * pFreeData = (EAPFREE_DATA*)hEapFree;

    if (pFreeData == NULL)
        return ERROR_INVALID_PARAMETER;

    if (pFreeData->pFreeFunc) {
        if (pUserDataOut)
            (*(pFreeData->pFreeFunc))(pUserDataOut);
        if (lpwszIdentity)
            (*(pFreeData->pFreeFunc))((BYTE*)lpwszIdentity);
    }

    if (pFreeData->hLib)
        FreeLibrary(pFreeData->hLib);

    Free (pFreeData);

    return NO_ERROR;
}

//
// Customizes the dialer flags for the eap provider
// of the given entry;
//
// TODO -- try to optimize this.  The list of eaps
// may not need to be read if we keep enough state
// in the phonebook.
//
DWORD DialerEapAssignMode(
        IN  DINFO* pInfo,
        OUT LPDWORD lpdwfMode)
{
    DWORD dwfMode = *lpdwfMode;
    DTLLIST * pListEaps;
    DTLNODE * pEapcfgNode;
    EAPCFG * pEapcfg;

    // If eap is not used in this entry,
    // then no action is required
    if (! (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP))
        return NO_ERROR;

    // Make sure we're configured with some list of
    // eap configuration options
    pListEaps = ReadEapcfgList( NULL );
    if (pListEaps == NULL)
        return ERROR_CAN_NOT_COMPLETE;

    // Find the eap node we're interested in
    pEapcfgNode = EapcfgNodeFromKey(
                    pListEaps,
                    pInfo->pEntry->dwCustomAuthKey );
    if (pEapcfgNode)
        pEapcfg = (EAPCFG*)DtlGetData( pEapcfgNode );
    else
    {
        if (pListEaps)
            DtlDestroyList(pListEaps, NULL);
    
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If eap provider requests user name then
    // request identity.
    if (pEapcfg->dwStdCredentialFlags &
           EAPCFG_FLAG_RequireUsername
       )
    {
        // Use the "I" flavors if the eap wants a user
        // name but no password.  
        //
        if (!(pEapcfg->dwStdCredentialFlags &
               EAPCFG_FLAG_RequirePassword)
           )
        {
            // Clear the username+password property (DR_U) if it
            // exists and replace it with the username property 
            // (DR_I).  Only do this if DR_U is already set.  It
            // wont be set for autodial connections or for connections
            // where that option was specifically disabled as can
            // be seen in the DialerDlg function.
            //
            // See whistler bug 30841
            //
            if (dwfMode & DR_U)
            {
                dwfMode &= ~DR_U;
                dwfMode |= DR_I;
            }                
        }
    }
    else
    {
        // Otherwise, make sure that we request neither user name nor password
        // Since domain cannot appear without username clear that also.
        //
        dwfMode &= ~(DR_U | DR_D);
    }

    // Cleanup
    if (pListEaps)
        DtlDestroyList(pListEaps, NULL);

    // Assign the correct mode
    *lpdwfMode = dwfMode;

    return NO_ERROR;
}

BOOL APIENTRY
RasDialDlgA(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN LPSTR lpszPhoneNumber,
    IN OUT LPRASDIALDLG lpInfo )

    // Win32 ANSI entrypoint that displays the dial progress and related
    // dialogs, including authentication, error w/redial, callback, and retry
    // authentication.  'LpszPhonebook' is the full path the phonebook or NULL
    // indicating the default phonebook.  'LpszEntry' is the entry to dial.
    // 'LpszPhoneNumber' is caller's override phone number or NULL to use the
    // one in the entry.  'LpInfo' is caller's additional input/output
    // parameters.
    //
    // Returns true if user establishes a connection, false otherwise.
    //
{
    WCHAR* pszPhonebookW;
    WCHAR* pszEntryW;
    WCHAR* pszPhoneNumberW;
    BOOL fStatus;

    TRACE( "RasDialDlgA" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!lpszEntry)
    {
        lpInfo->dwError = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASDIALDLG))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Thunk "A" arguments to "W" arguments.
    //
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromAUsingAnsiEncoding( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
        pszPhonebookW = NULL;
    }

    pszEntryW = StrDupTFromAUsingAnsiEncoding( lpszEntry );
    if (!pszEntryW)
    {
        Free0( pszPhonebookW );
        lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    if (lpszPhoneNumber)
    {
        pszPhoneNumberW = StrDupTFromAUsingAnsiEncoding( lpszPhoneNumber );
        if (!pszPhoneNumberW)
        {
            Free0( pszPhonebookW );
            Free( pszEntryW );
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
            pszPhoneNumberW = NULL;
    }

    // Thunk to the equivalent "W" API.
    //
    fStatus = RasDialDlgW( pszPhonebookW, pszEntryW, pszPhoneNumberW, lpInfo );

    Free0( pszPhonebookW );
    Free( pszEntryW );

    return fStatus;
}

DWORD
DoEapProcessing(
    LPRASDIALDLG lpInfo,
    DINFO *pInfo,
    PBYTE *ppbEapUserData,
    WCHAR **ppwszEapIdentity,
    HANDLE *phEapFree,
    BOOL *pfStatus
    )
{
    // If this is an eap connection, then use the eap identity
    // ui to get the user name and password. 
    //
    DWORD dwSize = 0;
    DWORD dwErr = NO_ERROR;

    *pfStatus = TRUE;
                
    // Bring up the Eap dialer dialog
    dwErr = DialerDlgEap(
                lpInfo->hwndOwner,
                pInfo->pFile->pszPath,
                pInfo->pEntry->pszEntryName,
                pInfo->pEntry,
                pInfo,
                ppbEapUserData,
                &dwSize,
                ppwszEapIdentity,
                phEapFree);

    if (dwErr != NO_ERROR)
    {
        if (ERROR_CANCELLED == dwErr)
        {
            dwErr = NO_ERROR;
        }

        *pfStatus = FALSE;

        goto done;
    }

    if(!pInfo->pNoUser)
    {
        // Set the extended dial params accordingly
        pInfo->rde.RasEapInfo.dwSizeofEapInfo = dwSize;
        pInfo->rde.RasEapInfo.pbEapInfo = *ppbEapUserData;
    }
    else if (   (*ppbEapUserData != NULL)
             && (dwSize != 0))
    {
        pInfo->rde.RasEapInfo.dwSizeofEapInfo = dwSize;
        pInfo->rde.RasEapInfo.pbEapInfo = *ppbEapUserData;
    }
    else
    {
        INTERNALARGS *piargs;

        piargs = (INTERNALARGS *) (pInfo->pArgs->reserved);
        if(     (NULL != piargs)
            &&  (NULL != piargs->pvEapInfo)
            // pmay: 386489
            //
            &&  (pInfo->pEntry->dwCustomAuthKey == EAPCFG_DefaultKey))
        {
            pInfo->rde.RasEapInfo.dwSizeofEapInfo =
                        ((EAPLOGONINFO *) piargs->pvEapInfo)->dwSize;

            pInfo->rde.RasEapInfo.pbEapInfo =  (BYTE *) piargs->pvEapInfo;
        }
        else
        {
            pInfo->rde.RasEapInfo.dwSizeofEapInfo = 0;
            pInfo->rde.RasEapInfo.pbEapInfo = NULL;
        }
    }

    if (*ppwszEapIdentity) 
    {
        DWORD dwSize =
            sizeof(pInfo->rdp.szUserName) / sizeof(WCHAR);

        wcsncpy(pInfo->rdp.szUserName, *ppwszEapIdentity,
            dwSize - 1);
        pInfo->rdp.szUserName[dwSize - 1] = 0;

        // Ignore the domain setting if the EAP supplied the 
        // identity.
        pInfo->rdp.szDomain[ 0 ] = L'\0';
    }

done:
    return dwErr;
}

INT
DialDlgDisplayError(
    IN LPRASDIALDLG pInfo,
    IN HWND hwndOwner, 
    IN DWORD dwSid, 
    IN DWORD dwError, 
    IN ERRORARGS* pArgs)
{
    if (pInfo->dwFlags & RASDDFLAG_NoPrompt)
    {
        return 0;
    }

    return ErrorDlg(hwndOwner, dwSid, dwError, pArgs);
}

BOOL APIENTRY
RasDialDlgW(
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN LPWSTR lpszPhoneNumber,
    IN OUT LPRASDIALDLG lpInfo )

    // Win32 UNICODE entrypoint that displays the dial progress and related
    // dialogs, including authentication, error w/redial, callback, and retry
    // authentication.  'LpszPhonebook' is the full path the phonebook or NULL
    // indicating the default phonebook.  'LpszEntry' is the entry to dial.
    // 'LpszPhoneNumber' is caller's override phone number or NULL to use the
    // one in the entry.  'LpInfo' is caller's additional input/output
    // parameters.
    //
    // Returns true if user establishes a connection, false otherwise.  If
    // 'RASDDFLAG_AutoDialQueryOnly' is set, returns true if user pressed
    // "Dial", false otherwise.
    //
{
    DWORD dwErr;
    BOOL fStatus;
    BOOL fFirstPass;
    DINFO* pInfo;
    LPWSTR pwszEapIdentity = NULL;
    PBYTE pbEapUserData = NULL;
    HANDLE hEapFree = NULL;
    BOOL fCustom = FALSE;
    PVOID pvInfo = NULL;
    HRASCONN hrasconnPrereq = NULL;

    TRACE( "RasDialDlgW" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!lpszEntry)
    {
        lpInfo->dwError = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASDIALDLG))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    if (lpszPhoneNumber && lstrlen( lpszPhoneNumber ) > RAS_MaxPhoneNumber)
    {
        lpInfo->dwError = ERROR_INVALID_PARAMETER;
        return FALSE;
    }

    // Load RAS DLL entrypoints which starts RASMAN, if necessary.
    //
    lpInfo->dwError = LoadRas( g_hinstDll, lpInfo->hwndOwner );
    if (lpInfo->dwError != 0)
    {
        // Whistler bug 301784
        //
        // Check specifically for access denied.  
        //
        if (lpInfo->dwError == ERROR_ACCESS_DENIED)
        {
            DialDlgDisplayError( 
                lpInfo,
                lpInfo->hwndOwner, 
                SID_OP_LoadRasAccessDenied, 
                lpInfo->dwError, 
                NULL );
        }
        else
        {
            DialDlgDisplayError(
                lpInfo,
                lpInfo->hwndOwner, 
                SID_OP_LoadRas, 
                lpInfo->dwError, 
                NULL );
        }       
        
        return FALSE;
    }

    // Allocate the context information block and initialize it enough so that
    // it can be destroyed properly.
    //
    pInfo = Malloc( sizeof(*pInfo) );
    if (!pInfo)
    {
        DialDlgDisplayError( 
            lpInfo,
            lpInfo->hwndOwner, 
            SID_OP_LoadDlg,
            ERROR_NOT_ENOUGH_MEMORY, 
            NULL );
            
        lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
        return FALSE;
    }

    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->pszPhonebook = lpszPhonebook;
    pInfo->pszEntry = lpszEntry;
    pInfo->pszPhoneNumber = lpszPhoneNumber;
    pInfo->pArgs = lpInfo;

    fStatus = FALSE;
    dwErr = 0;

    do
    {
        // Load the phonebook file and user preferences, or figure out that
        // caller has already loaded them.
        //
        if (lpInfo->reserved)
        {
            INTERNALARGS* piargs;

            // We've received an open phonebook file and user preferences via
            // the secret hack.
            //
            piargs = (INTERNALARGS* )lpInfo->reserved;
            pInfo->pFile = pInfo->pFileMain = piargs->pFile;
            pInfo->pUser = piargs->pUser;
            pInfo->pNoUser = piargs->pNoUser;
            pInfo->pfNoUserChanged = &piargs->fNoUserChanged;
            pInfo->fMoveOwnerOffDesktop = piargs->fMoveOwnerOffDesktop;
            pInfo->fForceCloseOnDial = piargs->fForceCloseOnDial;

        }
        else
        {
            // Read user preferences from registry.
            //
            dwErr = g_pGetUserPreferences( NULL, &pInfo->user, UPM_Normal );
            if (dwErr != 0)
            {
                DialDlgDisplayError( 
                    lpInfo,
                    lpInfo->hwndOwner, 
                    SID_OP_LoadPrefs, 
                    dwErr, 
                    NULL );
                    
                break;
            }

            pInfo->pUser = &pInfo->user;

            // Load and parse the phonebook file.
            //
            dwErr = ReadPhonebookFile(
                lpszPhonebook, &pInfo->user, NULL, 0, &pInfo->file );
            if (dwErr != 0)
            {
                DialDlgDisplayError( 
                    lpInfo,
                    lpInfo->hwndOwner, 
                    SID_OP_LoadPhonebook,
                    dwErr, 
                    NULL );
                break;
            }

            pInfo->pFile = pInfo->pFileMain = &pInfo->file;
        }

        // Record whether this is a for-all-users phonebook
        //
        // Whistler bug 288596 Autodial has wrong save password option marked -
        // prompts user to save password for all users
        //
        pInfo->fIsPublicPbk =
            (!pInfo->pszPhonebook) || IsPublicPhonebook(pInfo->pszPhonebook);

        if (!pInfo->pNoUser)
        {
            DWORD dwErrR;
            HKEY hkey;

            // See if admin has disabled the "save password" feature.
            //
            pInfo->fDisableSavePw = FALSE;

            dwErrR = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Services\\RasMan\\Parameters"),
                0, KEY_READ, &hkey );

            if (dwErrR == 0)
            {
                DWORD dwResult;

                dwResult = (DWORD )pInfo->fDisableSavePw;
                GetRegDword( hkey, TEXT("DisableSavePassword"), &dwResult );
                pInfo->fDisableSavePw = (BOOL )dwResult;

                RegCloseKey( hkey );
            }
        }

        // Hide parent dialog when initiated by another RAS API that requests
        // it.  This is the first stage of "close on dial" behavior, allowing
        // the parent to appear closed to user though, as owner, it must
        // really stay open until the dial dialogs complete.  At that point it
        // can silently close or reappear as desired.
        //
        if (lpInfo->hwndOwner && pInfo->fMoveOwnerOffDesktop)
        {
            SetOffDesktop( lpInfo->hwndOwner, SOD_MoveOff, NULL );
        }

        // Set true initially, but will be set false by
        // FindEntryAndSetDialParams if the entry has no "dial first" entry
        // associated with it.
        //
        pInfo->fPrerequisiteDial = TRUE;
        fFirstPass = TRUE;
        for (;;)
        {
            pInfo->fDialForReferenceOnly = FALSE;

            // Look up the entry and fill in the RASDIALPARAMS structure
            // accordingly.  This done as a routine so it can be re-done
            // should user press the Properties button.
            //
            dwErr = FindEntryAndSetDialParams( pInfo );
            if (dwErr != 0)
            {
                // we need to maintain 2 phonebooks
                // but we need to do this in case we break existing
                // apps which look specifically in system\ras dir.
                // Feel free to rip this code off, if you feel
                // strongly about it.
                //
                if(     (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwErr)
                    &&  (NULL == lpszPhonebook))
                {
                    DTLNODE *pNode;

                    //
                    // Close the all users phonebook file
                    //
                    ClosePhonebookFile(&pInfo->file);

                    dwErr = GetPbkAndEntryName(
                            lpszPhonebook,
                            lpszEntry,
                            0,
                            &pInfo->file,
                            &pNode);

                    if(     (NULL == pNode)
                        ||  (ERROR_SUCCESS != dwErr))
                    {
                        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                        break;
                    }

                    pInfo->pFile = pInfo->pFileMain = &pInfo->file;

                    dwErr = FindEntryAndSetDialParams(pInfo);

                    if(dwErr != 0)
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            if(lpInfo->reserved)
            {
                INTERNALARGS *piargs = (INTERNALARGS *) lpInfo->reserved;

                if (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    pvInfo = piargs->pvEapInfo;
                }
                else
                {
                    pvInfo = piargs->pNoUser;
                }
            }

            if(pInfo->fPrerequisiteDial
               && (NULL != pInfo->pEntry->pszCustomDialerName)
               && (TEXT('\0') != pInfo->pEntry->pszCustomDialerName[0]))
            {
                RASDIALDLG Info;
                DWORD dwCustomFlags = 0;
                RASNOUSER nouser, *pNoUser = NULL;

                ZeroMemory(&Info, sizeof(RASDIALDLG));
                ZeroMemory(&nouser, sizeof(RASNOUSER));

                Info.dwSize = sizeof(RASDIALDLG);
                Info.hwndOwner = lpInfo->hwndOwner;
                Info.xDlg = lpInfo->xDlg;
                Info.yDlg = lpInfo->yDlg;

                fCustom = TRUE;

                if(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwCustomFlags  |= RCD_Eap;
                }

                if(     (NULL != pInfo->pNoUser)
                    &&  (RASNOUSER_SmartCard & pInfo->pNoUser->dwFlags)
                    &&  (   (0 == (dwCustomFlags & RCD_Eap))
                        ||  (EAP_RASTLS != pInfo->pEntry->dwCustomAuthKey)
                    ))
                {
                    CopyMemory(&nouser, pInfo->pNoUser, sizeof(RASNOUSER));    
                    ZeroMemory(nouser.szPassword, (PWLEN+1) * sizeof(TCHAR));
                    pvInfo = &nouser;
                }

                // DwCustomDialDlg returns ERROR_SUCCESS if it handled
                // the CustomRasDial. returns E_NOINTERFACE otherwise
                // which implies that there is no custom dlg interface
                // supported for this entry and the default dial should
                // happen
                //
                // Whistler bug 314578 When connecting with CM via Winlogon I
                // get the following error "Error 1:  Incorrect function"
                //
                // This is a case where we call into a custom dialer, ie CM,
                // and we are using creds that we got from winlogon. They are
                // currently encoded and must be decoded before we call out.
                // We have to assume that the Custom Dialer leaves the password
                // un-encoded upon return.
                //
                if ( !(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP) )
                {
                    // pNoUser is used to encode/decode passwords.  If this
                    // is an EAP connection, then pvInfo will point to an
                    // eap blob, not a "no user" blob.  
                    //
                    pNoUser = pvInfo;
                }                    
                if ( pNoUser )
                {
                    DecodePassword( pNoUser->szPassword );
                }

                if(pInfo->pNoUser)
                {
                    dwCustomFlags |= RCD_Logon;
                }

                dwErr = DwCustomDialDlg(pInfo->pFile->pszPath,
                                        pInfo->pEntry->pszEntryName,
                                        NULL,
                                        &Info,
                                        dwCustomFlags,
                                        &fStatus,
                                        pvInfo,
                                        pInfo->pEntry->pszCustomDialerName);
                if ( pNoUser )
                {
                    EncodePassword( pNoUser->szPassword );
                }

                if(!fStatus)
                {
                    lpInfo->dwError = Info.dwError;
                    break;
                }
                else
                {
                    pInfo->fPrerequisiteDial = FALSE;
                    fCustom = FALSE;
                    continue;
                }
            }
            else if ((NULL != pInfo->pEntry->pszCustomDialerName)
                    && (TEXT('\0') != pInfo->pEntry->pszCustomDialerName[0]))
            {
                DWORD dwCustomFlags = 0;
                RASNOUSER nouser, *pNoUser = NULL;

                ZeroMemory(&nouser, sizeof(RASNOUSER));

                if(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwCustomFlags  |= RCD_Eap;
                }

                if(     (NULL != pInfo->pNoUser)
                    &&  (RASNOUSER_SmartCard & pInfo->pNoUser->dwFlags)
                    &&  (   (0 == (dwCustomFlags & RCD_Eap))
                        ||  (EAP_RASTLS != pInfo->pEntry->dwCustomAuthKey))
                    )
                {
                    CopyMemory(&nouser, pInfo->pNoUser, sizeof(RASNOUSER));
                    ZeroMemory(nouser.szPassword, (PWLEN+1) * sizeof(TCHAR));
                    pvInfo = &nouser;
                }

                fCustom = TRUE;


                // DwCustomDialDlg returns ERROR_SUCCESS if it handled
                // the CustomRasDial. returns E_NOINTERFACE otherwise
                // which implies that there is no custom dlg interface
                // supported for this entry and the default dial should
                // happen
                //
                // Whistler bug 314578 When connecting with CM via Winlogon I
                // get the following error "Error 1:  Incorrect function"
                //
                // This is a case where we call into a custom dialer, ie CM,
                // and we are using creds that we got from winlogon. They are
                // currently encoded and must be decoded before we call out.
                // We have to assume that the Custom Dialer leaves the password
                // un-encoded upon return.
                //
                if ( !(pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP) )
                {
                    // pNoUser is used to encode/decode passwords.  If this
                    // is an EAP connection, then pvInfo will point to an
                    // eap blob, not a "no user" blob.  
                    //
                    pNoUser = pvInfo;
                }                    
                if ( pNoUser )
                {
                    DecodePassword( pNoUser->szPassword );
                }

                if(pInfo->pNoUser)
                {
                    dwCustomFlags |= RCD_Logon;
                }

                dwErr = DwCustomDialDlg(lpszPhonebook,
                                        lpszEntry,
                                        lpszPhoneNumber,
                                        lpInfo,
                                        dwCustomFlags,
                                        &fStatus,
                                        pvInfo,
                                        pInfo->pEntry->pszCustomDialerName);
                if ( pNoUser )
                {
                    EncodePassword( pNoUser->szPassword );
                }

                break;
            }

            // If a prerequisite entry is already connected, there's no need
            // for any UI but the dial must occur to set the reference in the
            // RASAPI level.
            //
            if (pInfo->fPrerequisiteDial
                && HrasconnFromEntry(
                       pInfo->pFile->pszPath, pInfo->pEntry->pszEntryName ))
            {
                pInfo->fDialForReferenceOnly = TRUE;
            }

            // Set up extension parameter block, except 'hwndOwner' which is
            // set to the Dial Progress dialog window later.
            //
            {
                RASDIALEXTENSIONS* prde = &pInfo->rde;

                ZeroMemory( prde, sizeof(*prde) );
                prde->dwSize = sizeof(*prde);
                prde->dwfOptions = RDEOPT_PausedStates | RDEOPT_PauseOnScript;

                if (pInfo->pNoUser)
                {
                    prde->dwfOptions |= RDEOPT_NoUser;
                }

                if (!pInfo->pszPhoneNumber)
                {
                    prde->dwfOptions |= RDEOPT_UsePrefixSuffix;
                }
            }

            if (        (pInfo->fUnattended)
                &&      ((HaveSavedPw( pInfo ))
                    ||  (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)))
            {
                // Popup the countdown to link failure redial version of the
                // dial error dialog, which will lead to a dial unless user
                // stops it.
                //
                fStatus = DialErrorDlg(
                    lpInfo->hwndOwner, pInfo->pEntry->pszEntryName,
                    0, 0, NULL, 0, NULL,
                    GetOverridableParam(
                        pInfo->pUser, pInfo->pEntry, RASOR_RedialSeconds ),
                    GetOverridableParam(
                        pInfo->pUser, pInfo->pEntry,
                        RASOR_PopupOnTopWhenRedialing ) );

                if(!fStatus)
                {
                    break;
                }
                        
                if (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwErr = DoEapProcessing(
                                lpInfo,
                                pInfo,
                                &pbEapUserData,
                                &pwszEapIdentity,
                                &hEapFree,
                                &fStatus);

                    if(     (NO_ERROR != dwErr)
                        ||  (!fStatus))
                    {
                        break;
                    }
                }
                
            }
            else if (!pInfo->fDialForReferenceOnly)
            {
                if (!pInfo->fUnattended && fFirstPass)
                {
                    // Warn about active NWC LAN connections being blown away,
                    // if indicated.
                    //
                    if (!NwConnectionCheck(
                            lpInfo->hwndOwner,
                            (pInfo->pArgs->dwFlags & RASDDFLAG_PositionDlg),
                            pInfo->pArgs->xDlg, pInfo->pArgs->yDlg,
                            pInfo->pFile, pInfo->pEntry ))
                    {
                        break;
                    }

                    // Popup the double-dial help popup, if indicated.
                    //
                    if (!VpnDoubleDialDlg( lpInfo->hwndOwner, pInfo ))
                    {
                        break;
                    }
                }

                // Check to see if its smartcardlogon case and blank
                // out the password if its not an eap tls connectoid
                //
                if(     (NULL != pInfo->pNoUser)
                    &&  (RASNOUSER_SmartCard & pInfo->pNoUser->dwFlags)
                    &&  (pInfo->pEntry->dwCustomAuthKey != EAP_RASTLS))
                {
                    ZeroMemory(pInfo->rdp.szPassword, (PWLEN+1) * sizeof(TCHAR));
                }

                // Prompt for credentials and/or phone number (or not)
                // as configured in the entry properties.
                //
                if (!DialerDlg( lpInfo->hwndOwner, pInfo ))
                {
                    if(!fFirstPass)
                    {
                        fStatus = FALSE;
                    }
                    break;
                }

                if (pInfo->pEntry->dwAuthRestrictions & AR_F_AuthEAP)
                {
                    dwErr = DoEapProcessing(
                                lpInfo,
                                pInfo,
                                &pbEapUserData,
                                &pwszEapIdentity,
                                &hEapFree,
                                &fStatus);

                    if(     (NO_ERROR != dwErr)
                        ||  (!fStatus))
                    {
                        break;
                    }
                }

                fStatus = TRUE;
            }
            else
            {
                fStatus = TRUE;
            }

            // Dial and show progress.
            //
            if (fStatus
                && !fCustom)
            {

                // Clear this here because beyond this rasman
                // will take care of dropping the prereq link
                // since beyond this point rasdial api will get
                // called. [raos]
                //
                hrasconnPrereq = NULL;

                fStatus = DialProgressDlg( pInfo );

                // Show connect complete dialog unless user has nixed it or
                // it's a prerequisite dial.
                // (AboladeG) Also suppress the dialog in no-prompt mode.
                //
                if (!pInfo->fPrerequisiteDial
                    && fStatus
                    && !pInfo->pUser->fSkipConnectComplete
                    && !(pInfo->pArgs->dwFlags & RASDDFLAG_NoPrompt))
                {
                    //For whistler bug 378078       gangz
                    //We will comment out this status explaination dialog
                    //box because some users complained that it is confusing
                    //
                    // ConnectCompleteDlg( lpInfo->hwndOwner, pInfo );
                }
            }

            // Don't loop a second time to dial the main entry if the
            // prerequisite dial failed.
            //
            if (!fStatus || !pInfo->fPrerequisiteDial)
            {
                break;
            }

            // Save the rasconn of the prereq dial in case we need to hang
            // it up for the case where the vpn dialog fails before rasdial
            // gets called. [raos]
            //
            if (pInfo->fPrerequisiteDial)
            {
                hrasconnPrereq = HrasconnFromEntry(
                   pInfo->pFile->pszPath, pInfo->pEntry->pszEntryName);
            }      
            

            pInfo->fPrerequisiteDial = FALSE;
            fFirstPass = FALSE;
            // Cleanup eap stuff
            if (hEapFree)
            {
                DialerEapCleanup(hEapFree, pbEapUserData, pwszEapIdentity);
                hEapFree = NULL;
                pbEapUserData = NULL;
                pwszEapIdentity = NULL;
            }
        }
    }
    while (FALSE);

    // Unhide parent dialog when initiated by another RAS API.
    //
    if (lpInfo->hwndOwner && pInfo->fMoveOwnerOffDesktop
        && (!fStatus
            || !(pInfo->pUser->fCloseOnDial || pInfo->fForceCloseOnDial)))
    {
        SetOffDesktop( lpInfo->hwndOwner, SOD_MoveBackFree, NULL );
    }

    if(!fCustom)
    {
        // Save the several little user preferences adjustments we may have made.
        //
        g_pSetUserPreferences(
            NULL, pInfo->pUser, (pInfo->pNoUser) ? UPM_Logon : UPM_Normal );

        // Report error, if any.
        //
        if (dwErr)
        {
            DialDlgDisplayError( 
                lpInfo,
                lpInfo->hwndOwner, 
                SID_OP_LoadDlg, 
                dwErr, 
                NULL );
            lpInfo->dwError = dwErr;
        }

        TRACE1("hrasconnPrereq=0x%x",hrasconnPrereq);

        //
        // Drop the connection if we failed to connect the vpn connection
        //
        if(     !fStatus
            &&  (NULL != hrasconnPrereq)
            &&  (pInfo->pEntry)
            &&  (pInfo->pEntry->pszPrerequisiteEntry)
            && *(pInfo->pEntry->pszPrerequisiteEntry))
        {
            g_pRasHangUp(hrasconnPrereq);
        }
    }

    // Clean up.
    //
    if (!lpInfo->reserved)
    {
        if (pInfo->pFileMain)
        {
            ClosePhonebookFile( pInfo->pFileMain );
        }

        if (pInfo->pUser)
        {
            DestroyUserPreferences( pInfo->pUser );
        }
    }

    if (pInfo->fFilePrereqOpen)
    {
        ClosePhonebookFile( &pInfo->filePrereq );
    }

    ZeroMemory( pInfo->rdp.szPassword, sizeof(pInfo->rdp.szPassword) );
    if (pInfo->pListPortsToDelete)
    {
        DtlDestroyList( pInfo->pListPortsToDelete, DestroyPszNode );
    }

    if (hEapFree)
        DialerEapCleanup(hEapFree, pbEapUserData, pwszEapIdentity);
        
    Free( pInfo );

    return fStatus;
}


//----------------------------------------------------------------------------
// Local utilities
// Listed alphabetically
//----------------------------------------------------------------------------

DWORD
RasCredToDialParam(
    IN  TCHAR* pszDefaultUserName,
    IN  TCHAR* pszDefaultDomain,
    IN  RASCREDENTIALS* pCreds,
    OUT RASDIALPARAMS* pParams)
{
    TCHAR* pszComputer = NULL;
    TCHAR* pszLogonDomain = NULL;
    TCHAR* pszUser = NULL;

    // Set the user name, defaulting it if needed
    //
    if (pCreds->dwMask & RASCM_UserName)
    {
        lstrcpyn(
            pParams->szUserName,
            pCreds->szUserName,
            sizeof(pParams->szUserName) / sizeof(TCHAR));
    }            
    else if (pszDefaultUserName)
    {
        lstrcpyn(
            pParams->szUserName,
            pszDefaultUserName,
            sizeof(pParams->szUserName) / sizeof(TCHAR));
    }
    else
    {
        pszUser = GetLogonUser();
        
        if (pszUser)
        {
            lstrcpyn(
                pParams->szUserName,
                pszUser,
                sizeof(pParams->szUserName) / sizeof(TCHAR));
        }
    }

    // Set the domain name, defaulting it if needed
    //
    if (pCreds->dwMask & RASCM_Domain)
    {
        lstrcpyn(
            pParams->szDomain,
            pCreds->szDomain,
            sizeof(pParams->szDomain) / sizeof(TCHAR));
    }            
    else if ( pszDefaultDomain )
    {
        lstrcpyn(
            pParams->szDomain,
            pszDefaultDomain,
            sizeof(pParams->szDomain) / sizeof(TCHAR));
    }
    else
    {
        pszComputer = GetComputer();
        pszLogonDomain = GetLogonDomain();
        
        if ( (pszComputer)      &&
             (pszLogonDomain)   && 
             (lstrcmp( pszComputer, pszLogonDomain ) != 0))
        {
            lstrcpyn( 
                pParams->szDomain, 
                pszLogonDomain,
                sizeof(pParams->szDomain) / sizeof(TCHAR));
        }
    }

    // Fill in the password field
    //
    if (pCreds->dwMask & RASCM_Password)
    {
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pCreds->szPassword );
        lstrcpyn(
            pParams->szPassword,
            pCreds->szPassword,
            sizeof(pParams->szPassword) / sizeof(TCHAR) );
        EncodePassword( pCreds->szPassword );
        EncodePassword( pParams->szPassword );
    }

    return NO_ERROR;
}

DWORD 
FindEntryCredentials(
    IN  TCHAR* pszPath,
    IN  TCHAR* pszEntryName,
    IN  TCHAR* pszDefaultUserName,
    IN  TCHAR* pszDefaultDomain,
    OUT RASDIALPARAMS* pUser,       // per user credentials
    OUT RASDIALPARAMS* pGlobal,     // global credentials
    OUT BOOL* pfUser,               // set true if per user creds found
    OUT BOOL* pfGlobal              // set true if global creds found
    )

// Loads the credentials for the given entry into memory.  This routine 
// determines whether per-user or per-connection credentials exist or 
// both. 
// 
// The logic is a little complicated because RasGetCredentials had to 
// support legacy usage of the API.
//
// Here's how it works.  If only one set of credentials is stored for a 
// connection, then RasGetCredentials will return that set regardless of 
// whether the RASCM_DefalutCreds flag is set.  If two sets of credentials
// are saved, then RasGetCredentials will return the per-user credentials
// if the RASCM_DefaultCreds bit is set, and the per-connection credentials
// otherwise.
//
// Here is the algorithm for loading the credentials
//
// 1. Call RasGetCredentials with the RASCM_DefaultCreds bit cleared
//    1a. If nothing is returned, no credentials are saved
//    1b. If the RASCM_DefaultCreds bit is set on return, then only
//        global credentials are saved.
//
// 2. Call RasGetCredentials with the RASCM_DefaultCreds bit set
//    2a. If the RASCM_DefaultCreds bit is set on return, then 
//        both global and per-connection credentials are saved.
//    2b. Otherwise, only per-user credentials are saved.
//
{
    DWORD dwErr;
    RASCREDENTIALS rc1, rc2;
    BOOL fUseLogonDomain;

    TRACE( "FindEntryCredentials" );

    // Initialize
    //
    *pfUser = FALSE;
    *pfGlobal = FALSE;
    ZeroMemory( &rc1, sizeof(rc1) );
    ZeroMemory( &rc2, sizeof(rc2) );
    rc1.dwSize = sizeof(rc1);
    rc2.dwSize = sizeof(rc2);

    do 
    {

        // Look up per-user cached username, password, and domain.
        // See comment '1.' in the function header
        //
        rc1.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
        ASSERT( g_pRasGetCredentials );
        TRACE( "RasGetCredentials per-user" );
        dwErr = g_pRasGetCredentials(pszPath, pszEntryName, &rc1 );
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc1.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 1a. in the function header comments
        //
        if (rc1.dwMask == 0)
        {
            dwErr = NO_ERROR;
            break;
        }

        // See 1b. in the function header comments
        //
        else if (rc1.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetCredentials()
            //
            EncodePassword( rc1.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pGlobal );

            dwErr = NO_ERROR;
            break;
        }

        // Look up global per-user cached username, password, domain.
        // See comment 2. in the function header
        //
        rc2.dwMask =  
            RASCM_UserName | RASCM_Password | RASCM_Domain | RASCM_DefaultCreds;
        ASSERT( g_pRasGetCredentials );
        TRACE( "RasGetCredentials global" );
        dwErr = g_pRasGetCredentials(pszPath, pszEntryName, &rc2 );
        TRACE2( "RasGetCredentials=%d,m=%d", dwErr, rc2.dwMask );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See 2a. in the function header comments
        //
        if (rc2.dwMask & RASCM_DefaultCreds)
        {
            *pfGlobal = TRUE;

            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetCredentials()
            //
            EncodePassword( rc1.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pUser );

            EncodePassword( rc2.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc2,
                pGlobal );
        }

        // See 2b. in the function header comments
        //
        else
        {
            if (rc1.dwMask & RASCM_Password)
            {
                *pfUser = TRUE;
            }

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetCredentials()
            //
            EncodePassword( rc1.szPassword );
            RasCredToDialParam(
                pszDefaultUserName,
                pszDefaultDomain,
                &rc1,
                pUser );
        }

    }while (FALSE);

    // Cleanup
    //
    {
        // Whistler bug 254385 encode password when not being used
        //
        ZeroMemory( rc1.szPassword, sizeof(rc1.szPassword) );
        ZeroMemory( rc2.szPassword, sizeof(rc2.szPassword) );
    }

    return dwErr;
}

DWORD
FindEntryAndSetDialParams(
    IN DINFO* pInfo )

    // Look up the entry and fill in the RASDIALPARAMS parameters accordingly.
    // This routine contains all DINFO context initialization that can be
    // affected by user actions on the property sheet.  'PInfo' is the
    // partially initialized common dial dialog context.
    //
    // 'pInfo->fPrerequisiteDial'is set at entry if the prerequisite entry, if
    // any, should be dialed first.  If there is no prerequisite entry, the
    // flag is cleared and the main entry dialed.
    //
{
    DWORD dwErr;
    RASDIALPARAMS* prdp, *prdpu, *prdpg;

    if (pInfo->fFilePrereqOpen)
    {
        ClosePhonebookFile( pInfo->pFile );
        pInfo->pFile = pInfo->pFileMain;
        pInfo->fFilePrereqOpen = FALSE;
    }

    // Lookup entry node specified by caller and save reference for
    // convenience elsewhere.
    //
    pInfo->pNode = EntryNodeFromName(
        pInfo->pFile->pdtllistEntries, pInfo->pszEntry );
    if (!pInfo->pNode)
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        return dwErr;
    }

    pInfo->pEntry = pInfo->pEntryMain = (PBENTRY* )DtlGetData( pInfo->pNode );
    ASSERT( pInfo->pEntry );

    // Switch to the prerequisite entry, if indicated.
    //
    if (pInfo->fPrerequisiteDial)
    {
        if (pInfo->pEntry->pszPrerequisiteEntry
            && *(pInfo->pEntry->pszPrerequisiteEntry))
        {
            ASSERT( !pInfo->fFilePrereqOpen );

            // GetPbkAndEntryName first looks in the All Users phonebook file
            // if a phonebook file is not specified.  If the entry is not
            // found there it looks in files present in the Users profile.
            // This needs to be done since we are discontinuing the per-user
            // pbk file being set through user preferences.
            //
            dwErr = GetPbkAndEntryName(
                    pInfo->pEntry->pszPrerequisitePbk,
                    pInfo->pEntry->pszPrerequisiteEntry,
                    0,
                    &pInfo->filePrereq,
                    &pInfo->pNode);

            if (dwErr != 0)
            {
                return dwErr;
            }

            pInfo->pFile = &pInfo->filePrereq;
            pInfo->fFilePrereqOpen = TRUE;

            pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
            ASSERT( pInfo->pEntry );
        }
        else
        {
            pInfo->fPrerequisiteDial = FALSE;
        }
    }

    // Set up RasDial parameter blocks.
    //
    prdp = &pInfo->rdp;
    prdpu = &pInfo->rdpu;
    prdpg = &pInfo->rdpg;
    ZeroMemory( prdp, sizeof(*prdp) );
    pInfo->fUnattended = FALSE;
    prdp->dwSize = sizeof(*prdp);
    
    lstrcpyn( 
        prdp->szEntryName, 
        pInfo->pEntry->pszEntryName,  
        sizeof(prdp->szEntryName) / sizeof(TCHAR));

    if (pInfo->pszPhoneNumber)
    {
        lstrcpyn( 
            prdp->szPhoneNumber, 
            pInfo->pszPhoneNumber,
            RAS_MaxPhoneNumber + 1);
    }

    // Whistler bug 272819 Not prompted for callback number
    // We must do this before the init of per-user and global variants
    //
    if (!pInfo->fUnattended)
    {
        // '*' means "behave as defined in user preferences", while leaving it
        // zero would mean "don't request callback if server offers".
        //
        // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
        //
        lstrcpyn(
            prdp->szCallbackNumber,
            TEXT("*"),
            sizeof(prdp->szCallbackNumber) / sizeof(TCHAR) );
    }

    // Initialze the per-user and global variants
    //
    CopyMemory(prdpu, prdp, sizeof(*prdp));
    CopyMemory(prdpg, prdp, sizeof(*prdp));

    // Set the subentry link to whatever the RasDialDlg caller specified.  See
    // bug 200351.
    //
    prdp->dwSubEntry = pInfo->pArgs->dwSubEntry;

    // If running in "unattended" mode, i.e. called by RASAUTO to redial on
    // link failure, read the user/password/domain and callback number used on
    // the original call.  (Actually found a use for the crappy
    // RasGetEntryDialParams API)
    //
    if (pInfo->pArgs->dwFlags & RASDDFLAG_LinkFailure)
    {
        RASDIALPARAMS rdp;
        BOOL fSavedPw = HaveSavedPw( pInfo );

        ZeroMemory( &rdp, sizeof(rdp) );
        rdp.dwSize = sizeof(rdp);
        
        lstrcpyn( 
            rdp.szEntryName, 
            pInfo->pEntry->pszEntryName,
            sizeof(rdp.szEntryName) / sizeof(TCHAR) 
            );

        //For whistler bug 313509			gangz
        //We use FindEntryCredentials() to get saved password perUser and 
        //perConnection inforation, use RasGetEntryDialParams() to get back
        //Callback Numbers
        //
       {
            RASDIALPARAMS rdTemp; 
            TCHAR * pszTempUser, * pszTempDomain;
            DWORD dwErr = NO_ERROR;

            pszTempUser = pszTempDomain = NULL;
            dwErr = FindEntryCredentials(
                        pInfo->pFile->pszPath,
                        pInfo->pEntry->pszEntryName,
                        pszTempUser,
                        pszTempDomain,                    
                        &rdTemp,
                        &rdTemp,
                        &(pInfo->fHaveSavedPwUser),
                        &(pInfo->fHaveSavedPwGlobal));

             ZeroMemory( &rdTemp, sizeof(rdTemp) );
             Free0(pszTempUser);
             Free0(pszTempDomain);
        }
        
        
        TRACE( "RasGetEntryDialParams" );
        ASSERT( g_pRasGetEntryDialParams );
        dwErr = g_pRasGetEntryDialParams(
            pInfo->pFile->pszPath, &rdp, &fSavedPw );
        TRACE2( "RasGetEntryDialParams=%d,f=%d", dwErr, &fSavedPw );
        TRACEW1( "u=%s", rdp.szUserName );
        //TRACEW1( "p=%s", rdp.szPassword );
        TRACEW1( "d=%s", rdp.szDomain );
        TRACEW1( "c=%s", rdp.szCallbackNumber );

        if (dwErr == 0)
        {
            lstrcpyn( 
                prdp->szUserName, 
                rdp.szUserName,
                sizeof(prdp->szUserName) / sizeof(TCHAR));

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by RasGetEntryDialParams()
            //
            lstrcpyn(
                prdp->szPassword,
                rdp.szPassword,
                sizeof(prdp->szPassword) / sizeof(TCHAR) );
            EncodePassword( prdp->szPassword );

            lstrcpyn( 
                prdp->szDomain, 
                rdp.szDomain,
                sizeof(prdp->szDomain) / sizeof(TCHAR));
            lstrcpyn( 
                prdp->szCallbackNumber, 
                rdp.szCallbackNumber,
                sizeof(prdp->szCallbackNumber) / sizeof(TCHAR));

			
            pInfo->fUnattended = TRUE;
        }

        ZeroMemory( rdp.szPassword, sizeof(rdp.szPassword) );
    }

    if (pInfo->pNoUser)
    {
        // Use the credentials we got from API caller, presumably the ones
        // entered at Ctrl-Alt-Del.
        //
        lstrcpyn( 
            prdp->szUserName, 
            pInfo->pNoUser->szUserName,
            sizeof(prdp->szUserName) / sizeof(TCHAR));

        //
        // Don't copy the password if its smartcard logon 
        // and the entry being used is a non-eap connectoid
        //
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded by caller of RasDialDlg()
        //
        DecodePassword( pInfo->pNoUser->szPassword );
        
        lstrcpyn(
            prdp->szPassword,
            pInfo->pNoUser->szPassword,
            sizeof(prdp->szPassword) / sizeof(TCHAR) );
        EncodePassword( pInfo->pNoUser->szPassword );
        EncodePassword( prdp->szPassword );

        if (pInfo->pEntry->fPreviewDomain)
        {
            lstrcpyn( 
                prdp->szDomain, 
                pInfo->pNoUser->szDomain,
                sizeof(prdp->szDomain) / sizeof(TCHAR));
        }
        else
        {
            // Don't use Winlogon domain unless "include domain" option is
            // selected.  See bug 387266.
            //
            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            lstrcpyn(
                prdp->szDomain,
                TEXT(""),
                sizeof(prdp->szDomain) / sizeof(TCHAR) );
        }
    }
    else if (!pInfo->fUnattended)
    {
        DWORD dwErrRc;
        BOOL fUseLogonDomain;
        TCHAR* pszDefaultUser;

        dwErrRc = FindEntryCredentials(
                    pInfo->pFile->pszPath,
                    pInfo->pEntry->pszEntryName,
                    pInfo->pEntry->pszOldUser,
                    pInfo->pEntry->pszOldDomain,                    
                    prdpu,
                    prdpg,
                    &(pInfo->fHaveSavedPwUser),
                    &(pInfo->fHaveSavedPwGlobal));

        if (! pInfo->pEntry->fAutoLogon)
        {
            // If saved passwords are disabled, clear here
            //
            if (pInfo->fDisableSavePw)
            {
                pInfo->fHaveSavedPwUser = FALSE;
                pInfo->fHaveSavedPwGlobal = FALSE;
                ZeroMemory(prdp->szPassword, sizeof(prdp->szPassword));
                ZeroMemory(prdpu->szPassword, sizeof(prdpu->szPassword));
                ZeroMemory(prdpg->szPassword, sizeof(prdpg->szPassword));
            }

            // If including domains is disabled, clear here
            //
            if (! pInfo->pEntry->fPreviewDomain)
            {
                // (SteveC) Don't do this in the 'fAutoLogon' case.  See bug
                // 207611.
                //
                ZeroMemory(prdp->szDomain, sizeof(prdp->szDomain));
                ZeroMemory(prdpu->szDomain, sizeof(prdpu->szDomain));
                ZeroMemory(prdpg->szDomain, sizeof(prdpg->szDomain));
            }
        }
        
        if(!pInfo->pEntry->fAutoLogon)
        {
            // Initialize the dial params that will be passed to RasDial.
            //
            // Note that per-user credentials are always used when both 
            // per-user and global credentials are saved.  The per-user
            // credentials should be copied even if there is no saved 
            // password since there may be a saved identity.
            //
            CopyMemory(prdp, prdpu, sizeof(*prdp));
            if (pInfo->fHaveSavedPwGlobal && !pInfo->fHaveSavedPwUser)
            {
                CopyMemory(prdp, prdpg, sizeof(*prdp));
            }
        }
    }

    return 0;
}

//----------------------------------------------------------------------------
// Bundling Errors dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
BundlingErrorsDlg(
    IN OUT DPINFO* pInfo )

    // Popup the Bundling Errors dialog.  'PInfo' is the dialing progress
    // dialog context.
    //
    // Returns true if user chooses to accept the results or false if he
    // chooses to hang up.
    //
{
    INT_PTR nStatus;

    TRACE( "BundlingErrorsDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_BE_BundlingErrors ),
            pInfo->hwndDlg,
            BeDlgProc,
            (LPARAM )pInfo );

    if (nStatus == -1)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
BeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Bundling Errors dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "BeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, BeLvErrorsCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return BeInit( hwnd, (DPINFO* )lparam );
        }

        case WM_COMMAND:
        {
            return BeCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
BeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "BeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        case IDCANCEL:
        {
            TRACE1( "%s pressed", (wId==IDOK) ? "OK" : "Cancel" );

            if (IsDlgButtonChecked( hwnd, CID_BE_CB_DisableLink ))
            {
                DWORD i;
                DPINFO* pInfo;
                DPSTATE* pState;

                // Caller says to delete the links that failed in the entry.
                // Create a list of Psz nodes containing the unique port name
                // of each failed link so they can be removed after the state
                // information is freed.
                //
                pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );

                for (i = 0, pState = pInfo->pStates;
                     i < pInfo->cStates;
                     ++i, ++pState)
                {
                    DTLNODE* pNode;
                    DTLNODE* pNodePtd;
                    PBLINK* pLink;

                    if (pState->dwError != 0)
                    {
                        if (!pInfo->pArgs->pListPortsToDelete)
                        {
                            pInfo->pArgs->pListPortsToDelete =
                                DtlCreateList( 0L );
                            if (!pInfo->pArgs->pListPortsToDelete)
                            {
                                continue;
                            }
                        }

                        pNode = DtlNodeFromIndex(
                            pInfo->pArgs->pEntry->pdtllistLinks, (LONG )i );
                        if (!pNode)
                        {
                            continue;
                        }

                        pLink = (PBLINK* )DtlGetData( pNode );

                        pNodePtd = CreatePszNode( pLink->pbport.pszPort );
                        if (!pNodePtd)
                        {
                            continue;
                        }

                        DtlAddNodeLast(
                            pInfo->pArgs->pListPortsToDelete, pNodePtd );
                    }
                }
            }

            EndDialog( hwnd, (wId == IDOK) );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
BeFillLvErrors(
    IN HWND hwndLv,
    IN DPINFO* pInfo )

    // Fill the listview 'hwndLv' with devices and error strings and select
    // the first item.  'PInfo' is the dialing progress dialog context.
    //
{
    INT iItem;
    DWORD i;
    DPSTATE* pState;

    TRACE( "BeFillLvErrors" );

    ListView_DeleteAllItems( hwndLv );

    // Add columns.
    //
    {
        LV_COLUMN col;
        TCHAR* pszHeader0;
        TCHAR* pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_DeviceColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_StatusColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( hwndLv, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( hwndLv, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    // Add the modem and adapter images.
    //
    ListView_SetDeviceImageList( hwndLv, g_hinstDll );

    // Load listview with device/status pairs.
    //
    iItem = 0;
    for (i = 0, pState = pInfo->pStates; i < pInfo->cStates; ++i, ++pState)
    {
        LV_ITEM item;
        DTLNODE* pNode;
        PBLINK* pLink;
        TCHAR* psz;

        pNode = DtlNodeFromIndex(
            pInfo->pArgs->pEntry->pdtllistLinks, (LONG )i );
        if (pNode)
        {
            pLink = (PBLINK* )DtlGetData( pNode );

            psz = DisplayPszFromDeviceAndPort(
                      pLink->pbport.pszDevice, pLink->pbport.pszPort );
            if (psz)
            {
                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE;
                item.iItem = iItem;
                item.pszText = psz;
                item.iImage =
                    (pLink->pbport.pbdevicetype == PBDT_Modem)
                        ? DI_Modem : DI_Adapter;
                ListView_InsertItem( hwndLv, &item );
                Free( psz );

                if (pState->dwError == 0)
                {
                    psz = PszFromId( g_hinstDll, SID_Connected );
                    ListView_SetItemText( hwndLv, iItem, 1, psz );
                    Free( psz );
                }
                else
                {
                    psz = BeGetErrorPsz( pState->dwError );
                    ListView_SetItemText( hwndLv, iItem, 1, psz );
                    LocalFree( psz );
                }

                ++iItem;
            }
        }
    }

    // Auto-size columns to look good with the text they contain.
    //
    ListView_SetColumnWidth( hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    ListView_SetColumnWidth( hwndLv, 1, LVSCW_AUTOSIZE_USEHEADER );

    // Select the first item.
    //
    ListView_SetItemState( hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );
}


TCHAR*
BeGetErrorPsz(
    IN DWORD dwError )

    // Returns a string suitable for the Status column with error 'dwError' or
    // NULL on error.  'DwError' is assumed to be non-0.  It is caller's
    // responsiblility to LocalFree the returned string.
    //
{
    TCHAR* pszErrStr;
    TCHAR szErrNumBuf[ MAXLTOTLEN + 1 ];
    TCHAR* pszLineFormat;
    TCHAR* pszLine;
    TCHAR* apszArgs[ 2 ];

    LToT( dwError, szErrNumBuf, 10 );

    pszErrStr = NULL;
    GetErrorText( dwError, &pszErrStr );

    pszLine = NULL;
    pszLineFormat = PszFromId( g_hinstDll, SID_FMT_Error );
    if (pszLineFormat)
    {
        apszArgs[ 0 ] = szErrNumBuf;
        apszArgs[ 1 ] = (pszErrStr) ? pszErrStr : TEXT("");

        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING
                | FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
            (va_list* )apszArgs );

        Free( pszLineFormat );
    }

    Free0( pszErrStr );
    return pszLine;
}


BOOL
BeInit(
    IN HWND hwndDlg,
    IN DPINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    HWND hwndLvErrors;
    HWND hwndCbDisableLink;

    TRACE( "BeInit" );

    hwndLvErrors = GetDlgItem( hwndDlg, CID_BE_LV_Errors );
    ASSERT( hwndLvErrors );
    hwndCbDisableLink = GetDlgItem( hwndDlg, CID_BE_CB_DisableLink );
    ASSERT( hwndCbDisableLink );

    // Save Dial Progress context as dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pArgs );

    // Load listview with device/error information.
    //
    BeFillLvErrors( hwndLvErrors, pArgs );

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.  Always-on-top alone
    // is incredibly annoying, e.g. it is always on top of the on-line help if
    // user presses the Help button.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    SetFocus( hwndCbDisableLink );
    return FALSE;
}


LVXDRAWINFO*
BeLvErrorsCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the column information.
    //
{
    // Use "wide selection bar" feature and the other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info =
        { 2, 0, LVXDI_Blend50Dis + LVXDI_DxFill, { 0, 0 } };

    return &info;
}


//----------------------------------------------------------------------------
// Change Password dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
ChangePasswordDlg(
    IN HWND hwndOwner,
    IN BOOL fOldPassword,
    OUT TCHAR* pszOldPassword,
    OUT TCHAR* pszNewPassword )

    // Popup the Change Password dialog.  'HwndOwner' is the owning window.
    // 'FOldPassword' is set true if user must supply an old password, false
    // if no old password is required.  'PszOldPassword' and 'pszNewPassword'
    // are caller's buffers for the returned passwords.
    //
    // Returns true if user presses OK and succeeds, false otherwise.
    //
{
    INT_PTR nStatus;
    CPARGS args;

    TRACE( "ChangePasswordDlg" );

    args.fOldPassword = fOldPassword;
    args.pszOldPassword = pszOldPassword;
    args.pszNewPassword = pszNewPassword;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            (fOldPassword)
                ? MAKEINTRESOURCE( DID_CP_ChangePassword2 )
                : MAKEINTRESOURCE( DID_CP_ChangePassword ),
            hwndOwner,
            CpDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
CpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Change Password dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CpInit( hwnd, (CPARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCpHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return CpCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
CpCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "CpCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            CPWINFO* pInfo;
            TCHAR szNewPassword[ PWLEN + 1 ];
            TCHAR szNewPassword2[ PWLEN + 1 ];

            TRACE( "OK pressed" );

            pInfo = (CPWINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            szNewPassword[ 0 ] = TEXT('\0');
            GetWindowText(
                pInfo->hwndEbNewPassword, szNewPassword, PWLEN + 1 );
            szNewPassword2[ 0 ] = TEXT('\0');
            GetWindowText(
                pInfo->hwndEbNewPassword2, szNewPassword2, PWLEN + 1 );

            if (lstrcmp( szNewPassword, szNewPassword2 ) != 0)
            {
                // The two passwords don't match, i.e. user made a typo.  Make
                // him re-enter.
                //
                MsgDlg( hwnd, SID_PasswordsDontMatch, NULL );
                SetWindowText( pInfo->hwndEbNewPassword, TEXT("") );
                SetWindowText( pInfo->hwndEbNewPassword2, TEXT("") );
                SetFocus( pInfo->hwndEbNewPassword );
                ZeroMemory( szNewPassword, sizeof(szNewPassword) );
                ZeroMemory( szNewPassword2, sizeof(szNewPassword2) );
                return TRUE;
            }

            if (pInfo->pArgs->fOldPassword)
            {
                pInfo->pArgs->pszOldPassword[ 0 ] = TEXT('\0');

                // Whistler bug 254385 encode password when not being used
                // Assumed password was not encoded by GetWindowText()
                //
                GetWindowText(
                    pInfo->hwndEbOldPassword,
                    pInfo->pArgs->pszOldPassword,
                    PWLEN + 1 );
                EncodePassword( pInfo->pArgs->pszOldPassword );
            }

            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            // pInfo->pArgs->pszNewPassword points back to RASDIALPARAMS->
            // szPassword[ PWLEN + 1 ]
            //
            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by GetWindowText()
            //
            lstrcpyn(
                pInfo->pArgs->pszNewPassword,
                szNewPassword,
                PWLEN + 1 );
            EncodePassword( pInfo->pArgs->pszNewPassword );
            ZeroMemory( szNewPassword, sizeof(szNewPassword) );
            ZeroMemory( szNewPassword2, sizeof(szNewPassword2) );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CpInit(
    IN HWND hwndDlg,
    IN CPARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the dialog window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    CPWINFO* pInfo;

    TRACE( "CpInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    if (pArgs->fOldPassword)
    {
        pInfo->hwndEbOldPassword =
            GetDlgItem( hwndDlg, CID_CP_EB_OldPassword );
        ASSERT( pInfo->hwndEbOldPassword );
        Edit_LimitText( pInfo->hwndEbOldPassword, PWLEN );
    }
    pInfo->hwndEbNewPassword =
        GetDlgItem( hwndDlg, CID_CP_EB_Password );
    ASSERT( pInfo->hwndEbNewPassword );
    Edit_LimitText( pInfo->hwndEbNewPassword, PWLEN );

    pInfo->hwndEbNewPassword2 =
        GetDlgItem( hwndDlg, CID_CP_EB_ConfirmPassword );
    ASSERT( pInfo->hwndEbNewPassword2 );
    Edit_LimitText( pInfo->hwndEbNewPassword2, PWLEN );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}


//----------------------------------------------------------------------------
// Connect Complete dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

VOID
ConnectCompleteDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo )

    // Popup the connection complete dialog.  'HwndOwner' is the owning
    // window.  'PUser' is the user preferences.
    //
{
    INT_PTR nStatus;

    TRACE( "ConnectCompleteDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CC_ConnectComplete ),
            hwndOwner,
            CcDlgProc,
            (LPARAM )pInfo );
}


INT_PTR CALLBACK
CcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the dialog.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CcInit( hwnd, (DINFO* )lparam );
        }

        case WM_COMMAND:
        {
            return CcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
            //For whistler bug 372078
            //GetCurrentIconEntryType() loads Icon from netshell where the icon is loaded
            //by LoadImage() without LR_SHARED, so I have to destroy it when we are done
            //with it
            //
            {
                HICON hIcon=NULL;
                hIcon = (HICON)SendMessage( GetDlgItem( hwnd, CID_CC_I_Rasmon ),
                                     STM_GETICON,
                                     (WPARAM)0,
                                     (LPARAM)0);
                
                ASSERT(hIcon);
                if( hIcon )
                {
                    DestroyIcon(hIcon);
                }
                else
                {
                    TRACE("CcDlgProc:Destroy Icon");
                }
            }
            
            break;
        
    }

    return FALSE;
}


BOOL
CcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CcCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            DINFO * pInfo = (DINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            PBUSER* pUser = pInfo->pUser;
            ASSERT( pUser );

            if (IsDlgButtonChecked( hwnd, CID_CC_CB_SkipMessage ))
            {
                pUser->fSkipConnectComplete = TRUE;
                pUser->fDirty = TRUE;
            }
        }

        // ...fall thru...

        case IDCANCEL:
        {
            EndDialog( hwnd, TRUE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CcInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of dialog.  'PUser'
    // is caller's argument to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    TRACE( "CcInit" );

    // Set the dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );

    // Set the explanatory text.
    //
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;

        MsgDlgUtil( NULL, SID_ConnectComplete, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( hwndDlg, CID_CC_ST_Text, msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }
    }

    // Set the correct icon.    For whistler bug 372078
    //  
    
    SetIconFromEntryType(
        GetDlgItem( hwndDlg, CID_CC_I_Rasmon ),
        pInfo->pEntry->dwType,
        FALSE); //FALSE means Large Icon
    
    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}


//----------------------------------------------------------------------------
// Dial Callback dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
DialCallbackDlg(
    IN HWND hwndOwner,
    IN OUT TCHAR* pszNumber )

    // Popup the Dial Callback dialog.  'HwndOwner' is the owning window.
    // 'PszNumber' is caller's buffer for the number of the local machine that
    // the server will be told to callback.  It contains the default number on
    // entry and the user-edited number on exit.
    //
    // Returns true if user OK and succeeds, false if Cancel or error.
    //
{
    INT_PTR nStatus;

    TRACE( "DialCallbackDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DC_DialCallback ),
            hwndOwner,
            DcDlgProc,
            (LPARAM )pszNumber );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DcDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Dial Callback dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DcInit( hwnd, (TCHAR* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDcHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return DcCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
DcCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DcCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            BOOL fStatus;
            HWND hwndEbNumber;
            TCHAR* pszNumber;

            TRACE( "OK pressed" );

            hwndEbNumber = GetDlgItem( hwnd, CID_DC_EB_Number );
            ASSERT( hwndEbNumber );
            pszNumber = (TCHAR* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pszNumber );
            GetWindowText( hwndEbNumber, pszNumber, RAS_MaxCallbackNumber + 1 );

            if (IsAllWhite( pszNumber ))
            {
                // OK with blank callback number is same as Cancel.
                //
                TRACE( "Blank number cancel" );
                fStatus = FALSE;
            }
            else
            {
                fStatus = TRUE;
            }

            EndDialog( hwnd, fStatus );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DcInit(
    IN HWND hwndDlg,
    IN TCHAR* pszNumber )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PszNumber' is the callback number.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    HWND hwndEbNumber;

    TRACE( "DcInit" );

    // Stash address of caller's buffer for OK processing.
    //
    ASSERT( pszNumber );
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pszNumber );

    // Initialize edit field to caller's default.
    //
    hwndEbNumber = GetDlgItem( hwndDlg, CID_DC_EB_Number );
    ASSERT( hwndEbNumber );
    Edit_LimitText( hwndEbNumber, RAS_MaxCallbackNumber );
    SetWindowText( hwndEbNumber, pszNumber );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}


//----------------------------------------------------------------------------
// Dial Error dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
DialErrorDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszEntry,
    IN DWORD dwError,
    IN DWORD sidState,
    IN TCHAR* pszStatusArg,
    IN DWORD sidFormatMsg,
    IN TCHAR* pszFormatArg,
    IN LONG lRedialCountdown,
    IN BOOL fPopupOnTop )

    // Popup the Dial Error dialog.  'HwndOwner' is the owning window.
    // 'PszEntry' is the entry being dialed.  'DwError' is the error that
    // occurred or 0 if redialing after a link failure.  'sidStatusArg' is the
    // argument to the 'sidState' 'SidState' is the string ID of the dial
    // state executing when the error occurred.  string or NULL if none.
    // 'SidFormatMsg' is the string containing the format of the error message
    // or 0 to use the default.  'PszFormatArg' is the additional argument to
    // the format message or NULL if none.  'LRedialCountdown' is the number
    // of seconds before auto-redial, or -1 to disable countdown, or -2 to
    // hide the "Redial" button entirely.  'FPopupOnTop' indicates the status
    // window should be brought to the front when redialing.
    //
    // Returns true if user chooses to redial or lets it timeout, false if
    // cancels.
    //
{
    INT_PTR nStatus;
    DEARGS args;

    TRACE( "DialErrorDlg" );

    args.pszEntry = pszEntry;
    args.dwError = dwError;
    args.sidState = sidState;
    args.pszStatusArg = pszStatusArg;
    args.sidFormatMsg = sidFormatMsg;
    args.pszFormatArg = pszFormatArg;
    args.lRedialCountdown = lRedialCountdown;
    args.fPopupOnTop = fPopupOnTop;

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DE_DialError ),
            hwndOwner,
            DeDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Dial Error dialog.  Parameters and return
    // value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DeInit( hwnd, (DEARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return DeCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_TIMER:
        {
            DEINFO* pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            KillTimer( pInfo->hwndDlg, 1 );
            if (pInfo->lRedialCountdown > 0)
            {
                --pInfo->lRedialCountdown;
            }

            DeAdjustPbRedial( pInfo );

            if (pInfo->lRedialCountdown == 0)
            {
                // Fake a press of the Redial button.  Note that BM_CLICK
                // cannot be used because it doesn't generate the WM_COMMAND
                // when the thread is not the foreground window, due to
                // SetCapture use and restriction.
                //
                SendMessage( pInfo->hwndDlg, WM_COMMAND,
                    MAKEWPARAM( IDOK, BN_CLICKED ),
                    (LPARAM )pInfo->hwndPbRedial );
            }
            else
            {
                SetTimer( pInfo->hwndDlg, 1, 1000L, NULL );
            }

            return TRUE;
        }

        case WM_DESTROY:
        {
            DeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
DeAdjustPbRedial(
    IN DEINFO* pInfo )

    // Set the label of the Redial button or disable it as indicated by the
    // redial countdown.  If enabled, the button shows the number of seconds
    // to auto-redial unless this is not the final redial.  'PInfo' is the
    // dialog context block.
    //
{
    TCHAR* psz;

    if (pInfo->lRedialCountdown == -2)
    {
        // Redial button is to be hidden.  See bug 230594.
        //
        SetFocus( pInfo->hwndPbCancel );
        ShowWindow( pInfo->hwndPbRedial, SW_HIDE );
        EnableWindow( pInfo->hwndPbRedial, FALSE );
    }
    else
    {
        // Go ahead and change the label "Redial" or "Redial=%d" as
        // appropriate.
        //
        psz = PszFromId( g_hinstDll, SID_RedialLabel );
        if (psz)
        {
            TCHAR szBuf[ 128 ];

            lstrcpyn( 
                szBuf, 
                psz, 
                (sizeof(szBuf) / sizeof(TCHAR)) - 4);
            Free( psz );

            if (pInfo->lRedialCountdown >= 0)
            {
                TCHAR szNum[ MAXLTOTLEN + 1 ];
                DWORD dwLen, dwSize = sizeof(szBuf)/sizeof(TCHAR);
                LToT( pInfo->lRedialCountdown, szNum, 10 );
                lstrcat( szBuf, TEXT(" = ") );
                dwLen = lstrlen(szBuf) + 1;
                lstrcpyn( szBuf + (dwLen - 1), szNum, dwSize - dwLen );
            }

            SetWindowText( pInfo->hwndPbRedial, szBuf );
        }
    }
}


BOOL
DeCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    TRACE2("Current proces:(0x%d), Current Thread:(0x%d)",
            GetCurrentProcessId(),
            GetCurrentThreadId());

    switch (wId)
    {
        case IDOK:
        {
            TRACE( "Redial pressed" );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }

        case CID_DE_PB_More:
        {
            DEINFO* pInfo;
            DWORD dwContext;

            pInfo = (DEINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            if (pInfo->pArgs->dwError >= RASBASE
                && pInfo->pArgs->dwError <= RASBASEEND)
            {
                dwContext = HID_RASERRORBASE - RASBASE + pInfo->pArgs->dwError;
            }
            else if (pInfo->pArgs->dwError == 0)
            {
                dwContext = HID_RECONNECTING;
            }
            else
            {
                dwContext = HID_NONRASERROR;
            }

            WinHelp( hwnd, g_pszHelpFile, HELP_CONTEXTPOPUP, dwContext );
        }
    }

    return FALSE;
}


BOOL
DeInit(
    IN HWND hwndDlg,
    IN DEARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DEINFO* pInfo;

    TRACE( "DeInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndStText = GetDlgItem( hwndDlg, CID_DE_ST_Text );
    ASSERT( pInfo->hwndStText );
    pInfo->hwndPbRedial = GetDlgItem( hwndDlg, IDOK );
    ASSERT( pInfo->hwndPbRedial );
    pInfo->hwndPbCancel = GetDlgItem( hwndDlg, IDCANCEL );
    ASSERT( pInfo->hwndPbCancel );
    pInfo->hwndPbMore = GetDlgItem( hwndDlg, CID_DE_PB_More );
    ASSERT( pInfo->hwndPbMore );

    // Hide/disable "more info" button if WinHelp won't work.  See
    // common\uiutil\ui.c.
    //
    {
        extern BOOL g_fNoWinHelp;

        if (g_fNoWinHelp)
        {
            ShowWindow( pInfo->hwndPbMore, SW_HIDE );
            EnableWindow( pInfo->hwndPbMore, FALSE );
        }
    }

    if (pArgs->dwError == 0)
    {
        TCHAR* pszFormat;
        TCHAR* psz;
        TCHAR* apszArgs[ 1 ];

        // Redialing on link failure.  Set title to "Dial-Up Networking".
        //
        psz = PszFromId( g_hinstDll, SID_PopupTitle );
        if (psz)
        {
            SetWindowText( hwndDlg, psz );
            Free( psz );
        }

        // Set static placeholder text control to "Link to <entry> failed.
        // Reconnect pending...".
        //
        pszFormat = PszFromId( g_hinstDll, SID_DE_LinkFailed );
        if (pszFormat)
        {
            apszArgs[ 0 ] = pArgs->pszEntry;
            psz = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszFormat, 0, 0, (LPTSTR )&psz, 1,
                (va_list* )apszArgs );

            Free( pszFormat );

            if (psz)
            {
                SetWindowText( pInfo->hwndStText, psz );
                LocalFree( psz );
            }
        }
    }
    else
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];
        ERRORARGS args;

        // Set title to "Error Connecting to <entry>".
        //
        pszTitleFormat = GetText( hwndDlg );
        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pArgs->pszEntry;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }

        // Build the error text and load it into the placeholder text control.
        //
        ZeroMemory( &args, sizeof(args) );
        if (pArgs->pszStatusArg)
            args.apszOpArgs[ 0 ] = pArgs->pszStatusArg;
        if (pArgs->pszFormatArg)
            args.apszAuxFmtArgs[ 0 ] = pArgs->pszFormatArg;
        args.fStringOutput = TRUE;

        ErrorDlgUtil( hwndDlg,
            pArgs->sidState, pArgs->dwError, &args, g_hinstDll, 0,
            (pArgs->sidFormatMsg) ? pArgs->sidFormatMsg : SID_FMT_ErrorMsg );

        if (args.pszOutput)
        {
            SetWindowText( pInfo->hwndStText, args.pszOutput );
            LocalFree( args.pszOutput );
        }
    }

    // Stretch the dialog window to a vertical size appropriate for the text
    // we loaded.
    //
    {
        HDC hdc;
        RECT rect;
        RECT rectNew;
        HFONT hfont;
        LONG dyGrow;
        TCHAR* psz;

        psz = GetText( pInfo->hwndStText );
        if (psz)
        {
            GetClientRect( pInfo->hwndStText, &rect );
            hdc = GetDC( pInfo->hwndStText );

            if(NULL != hdc)
            {

                hfont = (HFONT )SendMessage( pInfo->hwndStText, 
                                            WM_GETFONT, 0, 0 );
                if (hfont)
                {
                    SelectObject( hdc, hfont );
                }

                rectNew = rect;
                DrawText( hdc, psz, -1, &rectNew,
                    DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX );
                ReleaseDC( pInfo->hwndStText, hdc );
            }

            dyGrow = rectNew.bottom - rect.bottom;
            ExpandWindow( pInfo->hwndDlg, 0, dyGrow );
            ExpandWindow( pInfo->hwndStText, 0, dyGrow );
            SlideWindow( pInfo->hwndPbRedial, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndPbCancel, pInfo->hwndDlg, 0, dyGrow );
            SlideWindow( pInfo->hwndPbMore, pInfo->hwndDlg, 0, dyGrow );

            Free( psz );
        }
    }

    // Set Redial button label or disable the button.  Always choose to redial
    // after 5 seconds for the biplex error, since this will normally solve
    // the problem.  Otherwise, no countdown is used.
    //
    if (pArgs->dwError == ERROR_BIPLEX_PORT_NOT_AVAILABLE)
    {
        pInfo->lRedialCountdown = 5;
    }
    else
    {
        pInfo->lRedialCountdown = pArgs->lRedialCountdown;
    }

    DeAdjustPbRedial( pInfo );

    if (pInfo->lRedialCountdown >= 0)
    {
        SetTimer( pInfo->hwndDlg, 1, 1000L, NULL );
    }

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    if (pArgs->fPopupOnTop)
    {
        // Display the finished window above all other windows.  The window
        // position is set to "topmost" then immediately set to "not topmost"
        // because we want it on top but not always-on-top.  Always-on-top
        // alone is too annoying.
        //
        SetWindowPos(
            hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );
    }

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    if (pArgs->fPopupOnTop)
    {
        SetForegroundWindow( hwndDlg );

        SetWindowPos(
            hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );
    }

    return TRUE;
}

// Helper function to delete credentials
//
// fDeleteDefault specifies whether it is the default credentials that 
// should be deleted.
//
// fDeleteIdentity specifies whether to delete the user and domain names
// in addition to the password. 
//
DWORD
DeleteSavedCredentials(
    IN DINFO* pDinfo,
    IN HWND   hwndDlg,
    IN BOOL   fDefault,
    IN BOOL   fDeleteIdentity )
{
    RASCREDENTIALS rc;
    DWORD dwErr = NO_ERROR;

    TRACE2( "DeleteSavedCredentials: %d %d", fDefault, fDeleteIdentity );

    ZeroMemory(&rc, sizeof(rc));
    rc.dwSize = sizeof(RASCREDENTIALS);
    rc.dwMask = RASCM_Password;

    if (fDeleteIdentity)
    {
        rc.dwMask |= (RASCM_UserName | RASCM_Domain);
    }

    if (    (fDefault)
        &&  (IsPublicPhonebook(pDinfo->pFile->pszPath)))
    {
        rc.dwMask |= RASCM_DefaultCreds;
    }

    dwErr = g_pRasSetCredentials(
                pDinfo->pFile->pszPath,
                pDinfo->pEntry->pszEntryName,
                &rc,
                TRUE );

    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_UncachePw, dwErr, NULL );
    }

    TRACE1( "DeleteSavedCredentials: RasSetCredentials=%d", dwErr );

    return dwErr;
}

VOID
DeTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DEINFO* pInfo = (DEINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "DeTerm" );

    if (pInfo)
    {
        Free( pInfo );
    }
}


//----------------------------------------------------------------------------
// Dial Progress dialog
// Listed alphabetically following stub API dialog proc
//----------------------------------------------------------------------------

BOOL
DialProgressDlg(
    IN DINFO* pInfo )

    // Popup the Dial Progress dialog.  'PInfo' is the dialog context.
    //
    // Returns true if user connected successfully, false is he cancelled or
    // hit an error.
    //
{
    INT_PTR nStatus;

    // Run the dialog.
    //
    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DP_DialProgress ),
            pInfo->pArgs->hwndOwner,
            DpDlgProc,
            (LPARAM )pInfo );

    if (nStatus == -1)
    {
        ErrorDlg( pInfo->pArgs->hwndOwner, SID_OP_LoadDlg,
            ERROR_UNKNOWN, NULL );
        pInfo->pArgs->dwError = ERROR_UNKNOWN;
        nStatus = FALSE;
    }

    if (nStatus)
    {
        DWORD  dwErr;
        PBFILE file;

        // Connected successfully, so read possible changes to the entry made
        // by RasDial.
        //
        dwErr = ReadPhonebookFile( pInfo->pFile->pszPath, pInfo->pUser,
                    pInfo->pEntry->pszEntryName, RPBF_ReadOnly, &file );
        if (dwErr == 0)
        {
            DTLNODE* pNodeNew;

            pNodeNew = DtlGetFirstNode( file.pdtllistEntries );
            if (pNodeNew)
            {
                DtlRemoveNode( pInfo->pFile->pdtllistEntries, pInfo->pNode );
                DestroyEntryNode( pInfo->pNode );

                DtlRemoveNode( file.pdtllistEntries, pNodeNew );
                DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pNodeNew );

                pInfo->pNode = pNodeNew;
                pInfo->pEntry = (PBENTRY* )DtlGetData( pNodeNew );
            }

            ClosePhonebookFile( &file );
        }
    }

    // See if we need to change the entry based on what happened while
    // dialing.
    //
    {
        BOOL fChange = FALSE;

        if (pInfo->fResetAutoLogon)
        {
            ASSERT( !pInfo->pNoUser );
            pInfo->pEntry->fAutoLogon = FALSE;
            fChange = TRUE;
        }

        if (pInfo->dwfExcludedProtocols)
        {
            pInfo->pEntry->dwfExcludedProtocols
                |= pInfo->dwfExcludedProtocols;
            fChange = TRUE;
        }

        if (pInfo->pListPortsToDelete)
        {
            DTLNODE* pNode;

            pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            while (pNode)
            {
                DTLNODE* pNodeNext;
                DTLNODE* pNodePtd;
                PBLINK*  pLink;
                TCHAR*   pszPort;

                pNodeNext = DtlGetNextNode( pNode );

                pLink = (PBLINK* )DtlGetData( pNode );
                pszPort = pLink->pbport.pszPort;

                for (pNodePtd = DtlGetFirstNode( pInfo->pListPortsToDelete );
                     pNodePtd;
                     pNodePtd = DtlGetNextNode( pNodePtd ))
                {
                    TCHAR* pszPtd = (TCHAR* )DtlGetData( pNodePtd );

                    if (lstrcmp( pszPtd, pszPort ) == 0)
                    {
                        pNode = DtlRemoveNode(
                            pInfo->pEntry->pdtllistLinks, pNode );
                        DestroyLinkNode( pNode );
                        fChange = TRUE;
                        break;
                    }
                }

                pNode = pNodeNext;
            }
        }

        if (fChange)
        {
            pInfo->pEntry->fDirty = TRUE;
            WritePhonebookFile( pInfo->pFile, NULL );
        }
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the User Authentication dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DpInit( hwnd, (DINFO* )lparam );
        }

        case WM_COMMAND:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return DpCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_RASDIAL:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            Sleep( 0 );
            DpDial( pInfo, (BOOL)wparam );
            return TRUE;
        }

        case WM_RASERROR:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            Sleep( 0 );

            //For whistler bug 381337
            //
            if ( !pInfo->fCancelPressed )
            {
                DpError( pInfo, (DPSTATE* )lparam );
            }
            else
            {
                TRACE("DpDlgProc is already canceled, wont respond to WM_RASERROR");
            }
            
            return TRUE;
        }

        case WM_RASBUNDLEERROR:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            Sleep( 0 );
            if (BundlingErrorsDlg( pInfo ))
            {
                EndDialog( pInfo->hwndDlg, TRUE );
            }
            else
            {
                DpCancel( pInfo );
            }
            return TRUE;
        }

        case WM_DESTROY:
        {
            DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            // Whistler Bugs: 344019 SECBUGBASH: leaving leaked password in
            // memory when user changes password over RAS
            //
            // 289587 Failed RAS connections reset password to blank
            //
            if (pInfo->pszGoodPassword)
            {
                ZeroMemory(
                    pInfo->pszGoodPassword,
                    (lstrlen( pInfo->pszGoodPassword ) + 1) * sizeof(TCHAR) );
                Free( pInfo->pszGoodPassword );
                pInfo->pszGoodPassword = NULL;
            }

            if (pInfo->pszGoodUserName)
            {
                Free( pInfo->pszGoodUserName );
                pInfo->pszGoodUserName = NULL;
            }

            if (DpCallbacksFlag( pInfo, -1 ))
            {
                // Callbacks are active.  Stall until they complete.
                //
                TRACE( "Stall until callbacks disabled" );
                PostMessage( hwnd, WM_DESTROY, wparam, lparam );
                return TRUE;
            }

            DpTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
DpAppendBlankLine(
    IN OUT TCHAR* pszLines )

    // Append a blank line on the end of 'pszLines'.
    //
{
    lstrcat( pszLines, TEXT("\n") );
}


VOID
DpAppendConnectErrorLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol,
    IN DWORD dwError )

    // Append a connect error line for protocol 'sidProtocol' and error
    // 'dwError' onto the end of 'pszLines'.
    //
{
#define MAXRASERRORLEN 256

    TCHAR* pszProtocol;
    TCHAR* pszErrStr;
    TCHAR szErrNumBuf[ MAXLTOTLEN + 1 ];

    // Gather the argument strings.
    //
    pszProtocol = PszFromId( g_hinstDll, sidProtocol );
    if (!pszProtocol)
    {
        return;
    }

    LToT( dwError, szErrNumBuf, 10 );

    pszErrStr = NULL;
    GetErrorText( dwError, &pszErrStr );

    // Format the line and append it to caller's line buffer.
    //
    {
        TCHAR* pszLineFormat;
        TCHAR* pszLine;
        TCHAR* apszArgs[ 3 ];

        pszLineFormat = PszFromId( g_hinstDll, SID_FMT_ProjectError );
        if (pszLineFormat)
        {
            apszArgs[ 0 ] = pszProtocol;
            apszArgs[ 1 ] = szErrNumBuf;
            apszArgs[ 2 ] = (pszErrStr) ? pszErrStr : TEXT("");
            pszLine = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
                (va_list* )apszArgs );

            Free( pszLineFormat );

            if (pszLine)
            {
                lstrcat( pszLines, pszLine );
                LocalFree( pszLine );
            }
        }
    }

    Free( pszProtocol );
    Free0( pszErrStr );
}


VOID
DpAppendConnectOkLine(
    IN OUT TCHAR* pszLines,
    IN DWORD sidProtocol )

    // Append a "connected successfully" line for protocol 'sidProtocol' onto
    // the end of 'pszLines'.
    //
{
    TCHAR* pszProtocol;

    // Get the argument string.
    //
    pszProtocol = PszFromId( g_hinstDll, sidProtocol );
    if (!pszProtocol)
    {
        return;
    }

    // Format the line and append it to caller's line buffer.
    //
    {
        TCHAR* pszLineFormat;
        TCHAR* pszLine;
        TCHAR* apszArgs[ 1 ];

        pszLineFormat = PszFromId( g_hinstDll, SID_FMT_ProjectOk );
        if (pszLineFormat)
        {
            apszArgs[ 0 ] = pszProtocol;
            pszLine = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
                (va_list* )apszArgs );

            Free( pszLineFormat );

            if (pszLine)
            {
                lstrcat( pszLines, pszLine );
                LocalFree( pszLine );
            }
        }
    }

    Free( pszProtocol );
}


VOID
DpAppendFailCodeLine(
    IN OUT TCHAR* pszLines,
    IN DWORD dw )

    // Append hexidecimal fail code 'dw' as an extended error line on the end
    // of 'pszLines'.
    //
{
    TCHAR szNumBuf[ MAXLTOTLEN + 1 ];

    // Get the argument string.
    //
    LToT( dw, szNumBuf, 16 );

    // Format the line and append it to caller's line buffer.
    //
    {
        TCHAR* pszLineFormat;
        TCHAR* pszLine;
        TCHAR* apszArgs[ 1 ];

        pszLineFormat = PszFromId( g_hinstDll, SID_FMT_FailCode );
        if (pszLineFormat)
        {
            apszArgs[ 0 ] = szNumBuf;
            pszLine = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
                (va_list* )apszArgs );

            Free( pszLineFormat );

            if (pszLine)
            {
                lstrcat( pszLines, pszLine );
                LocalFree( pszLine );
            }
        }
    }
}


VOID
DpAppendNameLine(
    IN OUT TCHAR* pszLines,
    IN TCHAR* psz )

    // Append NetBIOS name 'psz' as an extended error line on the end of
    // 'pszLines'.
    //
{
    TCHAR* pszLineFormat;
    TCHAR* pszLine;
    TCHAR* apszArgs[ 1 ];

    pszLineFormat = PszFromId( g_hinstDll, SID_FMT_Name );
    if (pszLineFormat)
    {
        apszArgs[ 0 ] = psz;
        pszLine = NULL;

        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING
                | FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pszLineFormat, 0, 0, (LPTSTR )&pszLine, 1,
            (va_list* )apszArgs );

        Free( pszLineFormat );

        if (pszLine)
        {
            lstrcat( pszLines, pszLine );
            LocalFree( pszLine );
        }
    }
}


VOID
DpAuthNotify(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // Called on an authentication notify, i.e. a message from RASCAUTH.DLL or
    // RASPPPEN.DLL.  'PInfo' is the dialog context.  'PState' is the current
    // link's context.
    //
{
    PBENTRY* pEntry;

    TRACE( "DpAuthNotify" );

    pEntry = pInfo->pArgs->pEntry;

    if (pState->dwError == ERROR_ACCESS_DENIED && pEntry->fAutoLogon)
    {
        // A third party box has negotiated an authentication protocol that
        // can't deal with the NT one-way-hashed password, i.e. something
        // besides MS-extended CHAP or AMB.  Map the error to a more
        // informative error message.
        //
        pState->dwError = ERROR_CANNOT_USE_LOGON_CREDENTIALS;

        if (!pInfo->pArgs->pNoUser)
        {
            TRACE( "Disable auto-logon" );
            pEntry->fAutoLogon = FALSE;
            pInfo->pArgs->fResetAutoLogon = TRUE;
        }
    }

    if (pState->dwError == ERROR_CHANGING_PASSWORD)
    {
        TRACE( "DpAuthNotify - ERROR_CHANGING_PASSWORD" );

        // Change password failed.  Restore the password that worked for the
        // "button" redial.
        //
        if (pInfo->pszGoodPassword)
        {
            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded by DpPasswordExpired()
            //
            DecodePassword( pInfo->pszGoodPassword );
            lstrcpyn(
                pInfo->pArgs->rdp.szPassword,
                pInfo->pszGoodPassword,
                sizeof(pInfo->pArgs->rdp.szPassword) / sizeof(TCHAR) );
            EncodePassword( pInfo->pArgs->rdp.szPassword );

            ZeroMemory(
                pInfo->pszGoodPassword,
                (lstrlen( pInfo->pszGoodPassword ) + 1) * sizeof(TCHAR) );
            Free( pInfo->pszGoodPassword );
            pInfo->pszGoodPassword = NULL;
        }

        if (pInfo->pszGoodUserName)
        {
            lstrcpyn(
                pInfo->pArgs->rdp.szUserName,
                pInfo->pszGoodUserName,
                sizeof(pInfo->pArgs->rdp.szUserName) / sizeof(TCHAR) );
            Free( pInfo->pszGoodUserName );
            pInfo->pszGoodUserName = NULL;
        }
    }

    // Update cached credentials, if any, with new password.
    //
    // Whistler Bugs: 344019 SECBUGBASH: leaving leaked password in memory when
    // user changes password over RAS
    //
    // 289587 Failed RAS connections reset password to blank
    //
    if ((pState->sidState == SID_S_Projected) &&
        (pInfo->pszGoodPassword) &&
        (pInfo->pszGoodUserName))
    {
        DWORD dwErr;
        RASCREDENTIALS rc;

        TRACE( "DpAuthNotify - Success changing password, caching if necessary" );

        ZeroMemory( &rc, sizeof(rc) );
        rc.dwSize = sizeof(rc);

        // Look up cached password. Since we are only calling in with the
        // RASCM_Password flag here, with the current implementation of
        // RasGet/SetCredentials, this works for the Set below whether we are
        // saving a Per-User, Global, or the special case of having both saved
        // at the same time. Whew, complicated!
        //
        rc.dwMask = RASCM_Password;
        ASSERT( g_pRasGetCredentials );
        TRACE( "RasGetCredentials" );
        dwErr = g_pRasGetCredentials(
            pInfo->pArgs->pFile->pszPath,
            pInfo->pArgs->pEntry->pszEntryName,
            &rc );
        TRACE2( "RasGetCredentials=%d,m=%x", dwErr, rc.dwMask );

        if (dwErr == 0 && (rc.dwMask & RASCM_Password))
        {
            // Password was cached, so update it.
            //
            DecodePassword( pInfo->pArgs->rdp.szPassword );
            lstrcpyn(
                rc.szPassword,
                pInfo->pArgs->rdp.szPassword,
                sizeof(rc.szPassword) / sizeof(TCHAR) );
            EncodePassword( pInfo->pArgs->rdp.szPassword );

            ASSERT( g_pRasSetCredentials );
            TRACE( "RasSetCredentials(p,FALSE)" );
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath,
                pInfo->pArgs->pEntry->pszEntryName, &rc, FALSE );
            TRACE1( "RasSetCredentials=%d", dwErr );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_UncachePw, dwErr, NULL );
            }
        }

        // Clean up
        //
        ZeroMemory( rc.szPassword, sizeof(rc.szPassword) );

        ZeroMemory(
            pInfo->pszGoodPassword,
            (lstrlen( pInfo->pszGoodPassword ) + 1) * sizeof(TCHAR) );
        Free( pInfo->pszGoodPassword );
        pInfo->pszGoodPassword = NULL;

        Free( pInfo->pszGoodUserName );
        pInfo->pszGoodUserName = NULL;
    }
}


VOID
DpCallbackSetByCaller(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_CallbackSetByCaller state handling.  'PInfo' is the dialog
    // context.  'PState' is the subentry state.
    //
    // Returns true if successful, or an error code.
    //
{
    TCHAR* pszDefault;
    TCHAR szNum[ RAS_MaxCallbackNumber + 1 ];

    TRACE( "DpCallbackSetByCaller" );

    pszDefault = pInfo->pArgs->pUser->pszLastCallbackByCaller;
    if (!pszDefault)
    {
        pszDefault = TEXT("");
    }

    lstrcpyn( szNum, pszDefault, RAS_MaxCallbackNumber + 1 );

    if (DialCallbackDlg( pInfo->hwndDlg, szNum ))
    {
        lstrcpyn( pInfo->pArgs->rdp.szCallbackNumber, szNum, RAS_MaxCallbackNumber + 1 );

        if (lstrcmp( szNum, pszDefault ) != 0)
        {
            Free0( pInfo->pArgs->pUser->pszLastCallbackByCaller );
            pInfo->pArgs->pUser->pszLastCallbackByCaller = StrDup( szNum );
            pInfo->pArgs->pUser->fDirty = TRUE;
        }
    }
    else
    {
        pInfo->pArgs->rdp.szCallbackNumber[ 0 ] = TEXT('\0');
    }

    pState->sidState = 0;
}


BOOL
DpCallbacksFlag(
    IN DPINFO* pInfo,
    IN INT nSet )

    // If 'nSet' is not less than 0, the 'pInfo->fCallbacksActive' flag is set
    // to the value 'nSet'.
    //
    // Returns true is callbacks are active false otherwise.
    //
{
    BOOL f;

    TRACE1( "DpCallbacksFlag:nSet=(%d)", nSet );

    f = FALSE;
    if (WaitForSingleObject(
            g_hmutexCallbacks, INFINITE ) == WAIT_OBJECT_0)
    {
        TRACE("DpCallbacksFlag begin:");
        TRACE1("Global active:(%d)", g_ulCallbacksActive);
        TRACE1("Current thread active:(%d)", pInfo->ulCallbacksActive);

        f = pInfo->fCallbacksActive;

        if (nSet > 0)
        {
            ASSERT( !pInfo->fCallbacksActive );
            pInfo->fCallbacksActive = TRUE;
            ++g_ulCallbacksActive;

            pInfo->ulCallbacksActive++;
        }
        else if (nSet == 0)
        {
            pInfo->fCallbacksActive = FALSE;
            
            if ( 0 < pInfo->ulCallbacksActive )
            {
            
            // fix for whistler bug 341662  366237    gangz
            //
                if( 0 < g_ulCallbacksActive )
                {
                     --g_ulCallbacksActive;
                }
                
                pInfo->ulCallbacksActive--;
            }
        }

        TRACE("DpCallbacksFlag result:");
        TRACE1("Global active:(%d)", g_ulCallbacksActive);
        TRACE1("Current thread active:(%d)", pInfo->ulCallbacksActive);

        ReleaseMutex( g_hmutexCallbacks );
    }

   
    TRACE1( "DpCallbacksFlag: This thread's active=%d", f );

    return f;
}


VOID
DpCancel(
    IN DPINFO* pInfo )

    // Kill the dialog and any partially initiated call, as when cancel button
    // is pressed.  'PInfo' is the dialog context block.
    //
{
    TRACE( "DpCancel" );

    // Hide window to prevent visual complaints that arise if RasHangUp takes
    // a long time to complete.
    //
    ShowWindow( pInfo->hwndDlg, SW_HIDE );

    if (pInfo->hrasconn)
    {
        DWORD dwErr;

        ASSERT( g_pRasHangUp );
        TRACE( "RasHangUp" );

        TRACE("DpCancel:call RasHangUp");

        dwErr = g_pRasHangUp( pInfo->hrasconn );

        TRACE1("DpCancel:get dwErr from RasHangUp:(%d)", dwErr);
        TRACE1( "RasHangUp=%d", dwErr );
    }

    EndDialog( pInfo->hwndDlg, FALSE );
}

//return the pInfo->ulCallbacksActive, to get the g_ulCallbacksActive
//use  CallbacksActive()
//
long
DpOnOffPerThreadTerminateFlag(
    DPINFO *pInfo,
    INT nSetTerminateAsap,
    BOOL* pfTerminateAsap )

    // If 'fSetTerminateAsap' >= 0, sets 'pInfo->fTerminateAsap' flag to 'nSetTerminateAsap'.
    // If non-NULL, caller's '*pfTerminateAsap' is filled with the current value of
    // 'pInfo->fTerminateAsap'.
    //
    // Returns the number of Rasdial callback threads active.
    //
{
    LONG ul;

    TRACE1( "DpOnOffPerThreadTerminateFlag: Terminate=(%d)", nSetTerminateAsap );

    ASSERT(pInfo);

    ul = 0;
    if (WaitForSingleObject( g_hmutexCallbacks, INFINITE ) == WAIT_OBJECT_0)
    {
       if( pInfo )
       {
          if (pfTerminateAsap)
            {
                *pfTerminateAsap = pInfo->fTerminateAsap;
            }

            if (nSetTerminateAsap >= 0)
            {
                pInfo->fTerminateAsap = (BOOL )nSetTerminateAsap;
            }
        }
        else
        {
            TRACE( "DpOnOffPerThreadTerminateFlag: Invalid DPINFO input parameter" );
        }

       ul = pInfo->ulCallbacksActive;

        ReleaseMutex( g_hmutexCallbacks );
    }

    TRACE1( "DpOnOffPerThreadTerminateFlag:Current Thread Active=%d", ul );

    return ul;
}

BOOL
DpCommand(
    IN DPINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DpCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    TRACE2("DpCommand:pInfo address (0x%x), Dialog Handle (0x%x)",
            pInfo,
            pInfo->hwndDlg);
            
    TRACE2("DpCommand:Current proces:(0x%d), Current Thread:(0x%d)",
            GetCurrentProcessId(),
            GetCurrentThreadId());

    switch (wId)
    {
        case IDCANCEL:
        {
            ULONG ulCallbacksActive;

            ShowWindow( pInfo->hwndDlg, SW_HIDE );

            //For whistler bug 381337
            //
            if( !pInfo->fCancelPressed)
            {
                TRACE("DpCommand:Cancel pressed");
                pInfo->fCancelPressed = TRUE;
            }
            
            if (pInfo->hrasconn)
            {
                DWORD dwErr;

                ASSERT( g_pRasHangUp );
                TRACE( "RasHangUp" );
                dwErr = g_pRasHangUp( pInfo->hrasconn );
                TRACE1( "RasHangUp=%d", dwErr );
            }

			//set pInfo->fTerminateAsap to Terminate the dial
			//in the current thread, also return the pInfo->ulCallbacksActive,
			//if it is already 0, then we dont need to post the CANCEL window
			//Message again    whistler bug#291613      gangz
			//

           ulCallbacksActive = DpOnOffPerThreadTerminateFlag(pInfo, 1, NULL );

            if ( 0 < ulCallbacksActive )           
            {
                TRACE1( "DpCommand stall, current thread's ulCallbacksActive n=%d", ulCallbacksActive );
                PostMessage( pInfo->hwndDlg, WM_COMMAND, 
                             MAKEWPARAM(wId, wNotification), 
                             (LPARAM) hwndCtrl );

                //For whistler bug 378086       gangz
                //to sleep a bit to give the rasman a break to call our callback 
                //function DpRasDialFunc2()
                //
                Sleep(10);
                
                return TRUE;
            }

            EndDialog( pInfo->hwndDlg, FALSE );

            //Reset the pInfo->fTerminateAsap flag
            //
            DpOnOffPerThreadTerminateFlag(pInfo, 0, NULL );            
            return TRUE;
        }
    }

    return FALSE;
}


VOID
DpConnectDevice(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_ConnectDevice state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
{
    DWORD dwErr;
    RASCONNSTATUS rcs;
    DWORD cb;
    HRASCONN hrasconn;
    TCHAR* pszPhoneNumber;

    TRACE( "DpConnectDevice" );

    // Get fully translated phone number, if any.
    //
    ZeroMemory( &rcs, sizeof(rcs) );
    rcs.dwSize = sizeof(rcs);
    ASSERT( g_pRasGetConnectStatus );
    TRACE1( "RasGetConnectStatus($%08x)", pState->hrasconnLink );
    dwErr = g_pRasGetConnectStatus( pState->hrasconnLink, &rcs );
    TRACE1( "RasGetConnectStatus=%d", dwErr );
    TRACEW1( " dt=%s", rcs.szDeviceType );
    TRACEW1( " dn=%s", rcs.szDeviceName );
    TRACEW1( " pn=%s", rcs.szPhoneNumber );
    if (dwErr != 0)
    {
        pState->pbdt = PBDT_None;
    }

    pState->pbdt = PbdevicetypeFromPszType( rcs.szDeviceType );
    pszPhoneNumber = rcs.szPhoneNumber;

    switch (pState->pbdt)
    {
        case PBDT_Modem:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( pszPhoneNumber );

            if (pInfo->pArgs->pUser->fOperatorDial
                && AllLinksAreModems( pInfo->pArgs->pEntry ))
            {
                pState->sidState = SID_S_ConnectModemOperator;
            }
            else if (pInfo->pArgs->pEntry->fPreviewPhoneNumber)
            {
                pState->sidState = SID_S_ConnectNumber;
            }
            else
            {
                pState->sidState = SID_S_ConnectModemNoNum;
            }
            break;
        }

        case PBDT_Pad:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( rcs.szDeviceName );
            pState->sidState = SID_S_ConnectPad;

            if (pState->dwError == ERROR_X25_DIAGNOSTIC)
            {
                TCHAR* psz;

                // Get the X.25 diagnostic string for display in the
                // custom "diagnostics" error message format.
                //
                Free0( pState->pszFormatArg );
                pState->pszFormatArg =
                    GetRasX25Diagnostic( pState->hrasconnLink );
            }
            break;
        }

        case PBDT_Switch:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( rcs.szDeviceName );

            pState->sidState =
                (pState->fNotPreSwitch)
                    ? SID_S_ConnectPostSwitch
                    : SID_S_ConnectPreSwitch;
            break;
        }

        case PBDT_Null:
        {
            pState->sidState = SID_S_ConnectNull;
            break;
        }

        case PBDT_Parallel:
        {
            pState->sidState = SID_S_ConnectParallel;
            break;
        }

        case PBDT_Irda:
        {
            pState->sidState = SID_S_ConnectIrda;
            break;
        }

        case PBDT_Isdn:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( pszPhoneNumber );
            pState->sidState = SID_S_ConnectNumber;
            break;
        }

        case PBDT_Vpn:
        {
            Free0( pState->pszStatusArg );
            pState->pszStatusArg = StrDup( pszPhoneNumber );
            pState->sidState = SID_S_ConnectVpn;
            break;
        }

        default:
        {
            Free0( pState->pszStatusArg );
            if (pszPhoneNumber[ 0 ] != TEXT('\0'))
            {
                pState->pszStatusArg = StrDup( pszPhoneNumber );
                pState->sidState = SID_S_ConnectNumber;
            }
            else
            {
                pState->pszStatusArg = StrDup( rcs.szDeviceName );
                pState->sidState = SID_S_ConnectDevice;
            }
            break;
        }
    }
}

VOID
DpDeviceConnected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_DeviceConnected state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
    // Returns 0 if successful, or an error code.
    //
{
    TRACE( "DpDeviceConnected" );

    switch (pState->pbdt)
    {
        case PBDT_Modem:
        {
            pState->sidState = SID_S_ModemConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Pad:
        {
            pState->sidState = SID_S_PadConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Switch:
        {
            pState->sidState =
                (pState->fNotPreSwitch)
                    ? SID_S_PostSwitchConnected
                    : SID_S_PreSwitchConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Null:
        {
            pState->sidState = SID_S_NullConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Parallel:
        {
            pState->sidState = SID_S_ParallelConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        case PBDT_Irda:
        {
            pState->sidState = SID_S_IrdaConnected;
            pState->fNotPreSwitch = TRUE;
            break;
        }

        default:
        {
            pState->sidState = SID_S_DeviceConnected;
            break;
        }
    }
}


VOID
DpDial(
    IN DPINFO* pInfo,
    IN BOOL fPauseRestart )

    // Dial with the parameters in the 'pInfo' dialog context block.
    // 'FPausedRestart' indicates the dial is restarting from a paused state
    // and dial states should not be reset.
    //
{
    DWORD dwErr;

    TRACE1( "DpDial,fPauseRestart=%d", fPauseRestart );

    if (!fPauseRestart)
    {
        DpInitStates( pInfo );
        
        //comment for bug 277365, 291613 gangz
        //Set the fCallbacksActive to be TRUE
        //
        TRACE("DpDial:Init global actives");

        DpCallbacksFlag( pInfo, 1 );
    }
    else
    {
        TRACE("DpDial:WONT Init global actives for pausedRestart");
    }

    // Whistler bug 254385 encode password when not being used
    // Assumed password was encoded previously
    //
    DecodePassword( pInfo->pArgs->rdp.szPassword );

    TRACE1( "RasDial(h=$%08x)", pInfo->hrasconn );
    ASSERT( g_pRasDial );
    dwErr = g_pRasDial( &pInfo->pArgs->rde, pInfo->pArgs->pFile->pszPath,
            &pInfo->pArgs->rdp, 2, (LPVOID )DpRasDialFunc2, &pInfo->hrasconn );
    TRACE2( "RasDial=%d,h=$%08x", dwErr, pInfo->hrasconn );

    EncodePassword( pInfo->pArgs->rdp.szPassword );

    if (dwErr != 0)
    {
        // This same error will show up via the callback route on restarts
        // from PAUSEd states so avoid double popups in that case.  See bug
        // 367482.
        //
        if (!fPauseRestart)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_RasDial, dwErr, NULL );
            DpCallbacksFlag( pInfo, 0 );
        }
        
        // If we receive error 668 here, it means that a rasevent is currently
        // posted for state RASCS_Disconnected.  We shouldn't cancel in this
        // case since we Normal processing of RASCS_Disconnected will allow the
        // user to redial.  Also, calling DpCancel below will insert
        // WM_DESTROY which will process before the popup that the rasevent
        // produces can display.  367482 
        //
        if (dwErr != ERROR_NO_CONNECTION)
        {
            DpCancel( pInfo );
        }            
    }
}


VOID
DpError(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // Popup error dialog for error identified by 'pState' and cancel or
    // redial as indicated by user.  'PInfo' is the dialog context.
    //
{
    DWORD dwErr;
    DWORD dwRedialAttemptsLeft;
    DWORD sidState;

    TRACE( "DpError" );

    // Retrieve additional text from RASMXS on those special errors where the
    // device returned something useful to display.
    //
    if (pState->dwError == ERROR_FROM_DEVICE
        || pState->dwError == ERROR_UNRECOGNIZED_RESPONSE)
    {
        TCHAR* pszMessage;

        dwErr = GetRasMessage( pInfo->hrasconn, &pszMessage );
        if (dwErr == 0)
        {
            pState->sidFormatMsg = SID_FMT_ErrorMsgResp;
            Free0( pState->pszFormatArg );
            pState->pszFormatArg = pszMessage;
        }
    }

    if (pState->sidFormatMsg == 0)
    {
        if (pState->dwExtendedError != 0)
        {
            // Translate extended error code into arguments.
            //
            TCHAR szNum[ 2 + MAXLTOTLEN + 1 ];

            pState->sidFormatMsg = SID_FMT_ErrorMsgExt;

            szNum[ 0 ] = TEXT('0');
            szNum[ 1 ] = TEXT('x');
            LToT( pState->dwExtendedError, szNum + 2, 16 );

            Free0( pState->pszFormatArg );
            pState->pszFormatArg = StrDup( szNum );
        }
        else if (pState->szExtendedError[ 0 ] != TEXT('\0'))
        {
            // Translate extended error string to argument.  Currently, the
            // string is always a NetBIOS name.
            //
            pState->sidFormatMsg = SID_FMT_ErrorMsgName;
            Free0( pState->pszFormatArg );
            pState->pszFormatArg = StrDup( pState->szExtendedError );
        }
    }

    if (pInfo->hrasconn)
    {
        // Hang up before displaying error popup so server side resources are
        // not tied up waiting for client to acknowledge error.
        //
        ASSERT( g_pRasHangUp );
        TRACE( "RasHangUp" );
        dwErr = g_pRasHangUp( pInfo->hrasconn );
        TRACE1( "RasHangUp=%d", dwErr );
        pInfo->hrasconn = NULL;
    }

    if (pInfo->pArgs->pEntry->pszPrerequisiteEntry
        && *pInfo->pArgs->pEntry->pszPrerequisiteEntry)
    {
        // Select "no Redial button" mode for entries that have prerequisite
        // entries.  This is because RASMAN drops the prerequisite entry as
        // soon as the dependent entry fails, thus dooming to defeat a redial
        // of only the dependent entry.  Yes, it should really redial both
        // entries here, but that is not really feasible with the current
        // non-integrated serial implementation of prerequisite entries.  This
        // at least improves the poor behavior cited in bug 230594.
        //
        dwRedialAttemptsLeft = -2;
    }
    else if (pInfo->dwRedialAttemptsLeft <= 0)
    {
        // No auto-redial countdown, but "Redial" button does appear in place
        // of the default "OK".
        //
        dwRedialAttemptsLeft = -1;
    }
    else
    {
        // Auto-redial countdown based on the entries configuration.
        //
        dwRedialAttemptsLeft =
            GetOverridableParam(
                pInfo->pArgs->pUser,
                pInfo->pArgs->pEntry,
                RASOR_RedialSeconds );
    }

    // This hack works around a bug in RasDial API.  See bug 313102.
    //
    sidState = pState ->sidState;
    if (!sidState)
    {
        sidState = SID_S_AuthNotify;
    }

    if (DialErrorDlg(
            pInfo->hwndDlg,
            pInfo->pArgs->pEntry->pszEntryName,
            pState->dwError,
            sidState,
            pState->pszStatusArg,
            pState->sidFormatMsg,
            pState->pszFormatArg,
            dwRedialAttemptsLeft,
            GetOverridableParam(
                pInfo->pArgs->pUser, pInfo->pArgs->pEntry,
                RASOR_PopupOnTopWhenRedialing ) ))
    {
        TRACE( "User redials" );
        if (pInfo->dwRedialAttemptsLeft > 0)
        {
            --pInfo->dwRedialAttemptsLeft;
        }

        TRACE(" Post(DIAL)" );
        PostMessage( pInfo->hwndDlg, WM_RASDIAL, FALSE, 0 );
    }
    else
    {
        TRACE( "User cancels" );
        DpCancel( pInfo );
    }

    //
    // Set the error so that the error is propagated back
    // to the caller of the RasDialDlg api.
    //
    TRACE2("DpError settings error (0x%x) to %d",
            &pInfo->pArgs->pArgs->dwError,
            pState->dwError);
    pInfo->pArgs->pArgs->dwError = pState->dwError;
}


DWORD
DpEvent(
    IN DPINFO* pInfo,
    IN DWORD dwSubEntry )

    // Handle a RasDial callback event on subentry 'dwSubEntry'.  'PInfo' is
    // the dialog context.
    //
    // Return 0 to stop callbacks from RasDial, or 1 to continue callbacks
    // (normal), or 2 to indicate that the phonebook entry has changed and
    // should be re-read by RasDial.
    //
{
    DWORD dwErr;
    DWORD dwCode;
    BOOL fLeader;
    DWORD dwcSuccessLinks, dwcFailedLinks, i;
    DPSTATE* pState;
    BOOL fPartialMultilink;
    BOOL fIsLaterState;

    TRACE( "DpEvent" );

    // Default to "normal" return.
    //
    dwCode = 1;
    fPartialMultilink = FALSE;

    TRACE2("Current proces:(0x%d), Current Thread:(0x%d)",
            GetCurrentProcessId(),
            GetCurrentThreadId());
            
    // Find the associated state information and figure out if this is the
    // most advanced sub-entry.
    //
    pState = &pInfo->pStates[ dwSubEntry - 1 ];
    fIsLaterState = DpIsLaterState( pState->state, pInfo->state );
    if (dwSubEntry == pInfo->dwSubEntry || fIsLaterState)
    {
        fLeader = TRUE;
        if (fIsLaterState)
        {
            pInfo->dwSubEntry = dwSubEntry;
            pInfo->state = pState->state;
        }
    }
    else
    {
        fLeader = FALSE;
        TRACE( "Trailing" );
    }

    // Execute the state.
    //
    TRACE1("State is:(%d)", pState->state);

    switch (pState->state)
    {
        case RASCS_OpenPort:
        {
            pState->pbdt = PBDT_None;
            pState->sidState = SID_S_OpenPort;
            break;
        }

        case RASCS_PortOpened:
        {
            // Should have an hrasconnLink for this subentry now.  Look it up
            // and stash it in our context.
            //
            ASSERT( g_pRasGetSubEntryHandle );
            TRACE1( "RasGetSubEntryHandle(se=%d)", dwSubEntry );
            dwErr = g_pRasGetSubEntryHandle(
                pInfo->hrasconn, dwSubEntry, &pState->hrasconnLink );
            TRACE2( "RasGetSubEntryHandle=%d,hL=$%08x",
                dwErr, pState->hrasconnLink );
            if (dwErr != 0)
            {
                pState->dwError = dwErr;
            }

            pState->sidState = SID_S_PortOpened;
            break;
        }

        case RASCS_ConnectDevice:
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            pNode = DtlNodeFromIndex(
                pInfo->pArgs->pEntry->pdtllistLinks, dwSubEntry - 1 );
            ASSERT( pNode );

            if(NULL == pNode)
            {
                pState->dwError = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                pLink = (PBLINK* )DtlGetData( pNode );
            }

            if ((pState->dwError == ERROR_PORT_OR_DEVICE
                    && (pLink->pbport.fScriptBeforeTerminal
                        || pLink->pbport.fScriptBefore))
                || (pState->dwError == ERROR_USER_DISCONNECTION
                    && (pInfo->pArgs->pUser->fOperatorDial
                        && AllLinksAreModems( pInfo->pArgs->pEntry ))))
            {
                // This happens when user presses Cancel on the Unimodem
                // "Pre-Dial Terminal Screen" or "Operator Assisted or Manual
                // Dial" dialog.
                //
                TRACE("DpEvent:Call DpCancel() in connectDevice, but still return 1\n");
                DpCancel( pInfo );
                return dwCode;
            }

            DpConnectDevice( pInfo, pState );
            break;
        }

        case RASCS_DeviceConnected:
        {
            DpDeviceConnected( pInfo, pState );
            break;
        }

        case RASCS_AllDevicesConnected:
        {
           pState->sidState = SID_S_AllDevicesConnected;
            break;
        }

        case RASCS_Authenticate:
        {
            pState->sidState = SID_S_Authenticate;
            break;
        }

        case RASCS_AuthNotify:
        {
            DpAuthNotify( pInfo, pState );
            break;
        }

        case RASCS_AuthRetry:
        {
            pState->sidState = SID_S_AuthRetry;
            break;
        }

        case RASCS_AuthCallback:
        {
            pState->sidState = SID_S_AuthCallback;
            break;
        }

        case RASCS_AuthChangePassword:
        {
            pState->sidState = SID_S_AuthChangePassword;
            break;
        }

        case RASCS_AuthProject:
        {
            pState->sidState = SID_S_AuthProject;
            break;
        }

        case RASCS_AuthLinkSpeed:
        {
            pState->sidState = SID_S_AuthLinkSpeed;
            break;
        }

        case RASCS_AuthAck:
        {
            pState->sidState = SID_S_AuthAck;
            break;
        }

        case RASCS_ReAuthenticate:
        {
            pState->sidState = SID_S_ReAuthenticate;
            break;
        }

        case RASCS_Authenticated:
        {
            pState->sidState = SID_S_Authenticated;
            break;
        }

        case RASCS_PrepareForCallback:
        {
            pState->sidState = SID_S_PrepareForCallback;
            break;
        }

        case RASCS_WaitForModemReset:
        {
            pState->sidState = SID_S_WaitForModemReset;
            break;
        }

        case RASCS_WaitForCallback:
        {
            pState->sidState = SID_S_WaitForCallback;
            break;
        }

        case RASCS_Projected:
        {
            if (fLeader)
            {
                // If DpProjected returns FALSE, it detected a fatal error,
                // and the dialing process will stop.  If DpProjected returns
                // with pState->dwError non-zero, we display the error in a
                // redial dialog, if redial is configured.
                //
                if (!DpProjected( pInfo, pState ))
                {
                    TRACE("DpEvent:Call DpCancel() in RASCS_Projected, but still return 1 to DpRasDialFunc2()\n");
                
                    DpCancel( pInfo );
                    return dwCode;
                }
                else if (pState->dwError)
                {
                    TRACE("DpCancel() in RASCS_Projected,return 0 to DpRasDialFunc2()");
                    
                    TRACE( "DpEvent:Post(ERROR), return 0 to DpRasDialFunc2()" );
                    PostMessage( pInfo->hwndDlg,
                        WM_RASERROR, 0, (LPARAM )pState );
                    return 0;
                }
            }
            break;
        }

        case RASCS_Interactive:
        {
            BOOL fChange = FALSE;

            if (!DpInteractive( pInfo, pState, &fChange ))
            {
                DpCancel( pInfo );
                return dwCode;
            }

            if (fChange)
            {
                dwCode = 2;
            }
            break;
        }

        case RASCS_RetryAuthentication:
        {
            if (!RetryAuthenticationDlg(
                pInfo->hwndDlg, pInfo->pArgs ))
            {
                DpCancel( pInfo );
                return dwCode;
            }

            pState->sidState = 0;
            break;
        }

        case RASCS_InvokeEapUI:
        {
            if (g_pRasInvokeEapUI(
                    pInfo->hrasconn, dwSubEntry,
                    &pInfo->pArgs->rde, pInfo->hwndDlg ))
            {
                DpCancel( pInfo );
                return dwCode;
            }

            pState->sidState = 0;
            break;
        }

        case RASCS_CallbackSetByCaller:
        {
            DpCallbackSetByCaller( pInfo, pState );
            break;
        }

        case RASCS_PasswordExpired:
        {
            if (!DpPasswordExpired( pInfo, pState ))
            {
                DpCancel( pInfo );
                return dwCode;
            }
            break;
        }

        case RASCS_SubEntryConnected:
        {
            if (pInfo->cStates > 1)
            {
                pState->sidState = SID_S_SubConnected;
            }
            break;
        }

        case RASCS_SubEntryDisconnected:
        {
            break;
        }

        case RASCS_Connected:
        {
            pState->sidState = SID_S_Connected;
            break;
        }

        case RASCS_Disconnected:
        {
            pState->sidState = SID_S_Disconnected;
            break;
        }

        default:
        {
            pState->sidState = SID_S_Unknown;
            break;
        }
    }

    // Count the successful and failed links.
    //
    {
        DPSTATE* p;

        dwcSuccessLinks = dwcFailedLinks = 0;
        for (i = 0, p = pInfo->pStates; i < pInfo->cStates; ++i, ++p)
        {
            if (p->state == RASCS_SubEntryConnected)
            {
                ++dwcSuccessLinks;
            }

            if (p->dwError)
            {
                ++dwcFailedLinks;
            }
        }
    }
    TRACE3( "s=%d,f=%d,t=%d", dwcSuccessLinks, dwcFailedLinks, pInfo->cStates );

    if (pState->dwError)
    {
        DTLNODE *pdtlnode = NULL;
        DWORD dwIndex = pInfo->pArgs->rdp.dwSubEntry;

        if(0 != dwIndex)
        {

            pdtlnode = DtlNodeFromIndex(
                                pInfo->pArgs->pEntry->pdtllistLinks,
                                dwIndex - 1);
        }

        if (    (dwcFailedLinks == pInfo->cStates)
            ||  (   (RASEDM_DialAll != pInfo->pArgs->pEntry->dwDialMode)
                &&  (dwcSuccessLinks == 0))
            ||  (NULL != pdtlnode))
        {
            // A terminal error state has occurred on all links.  Post a
            // message telling ourselves to popup an error, then release the
            // callback so it doesn't hold the port open while the error popup
            // is up,
            //
            TRACE( "Post(ERROR)" );
            PostMessage( pInfo->hwndDlg, WM_RASERROR, 0, (LPARAM )pState );
            return 0;
        }
        else if (dwcSuccessLinks + dwcFailedLinks == pInfo->cStates)
        {
            // An error occurred on the final link, but some link connected.
            // It would be nice if RasDial would followup with a
            // RASCS_Connected in that case, but it doesn't, so we duplicate
            // the RASCS_Connected-style exit here.
            //
            TRACE( "Post(BUNDLEERROR)" );
            PostMessage( pInfo->hwndDlg,
                WM_RASBUNDLEERROR, 0, (LPARAM )pState );
            return 0;
        }

        // A fatal error has occurred on a link, but there are other links
        // still trying, so let it die quietly.
        //
        TRACE2( "Link %d fails, e=%d", dwSubEntry + 1, pState->dwError );
        return dwCode;
    }

    // Display the status string for this state.
    //
    if (pState->sidState)
    {
        if (pState->sidState != pState->sidPrevState)
        {
            pState->sidPrevState = pState->sidState;
        }

        if (fLeader)
        {
            TCHAR* pszState = PszFromId( g_hinstDll, pState->sidState );

            if (    (NULL != pszState)
                &&  pState->pszStatusArg)
            {
                TCHAR* pszFormattedState;
                TCHAR* pszArg;
                TCHAR* apszArgs[ 1 ];
                DWORD cch;

                pszArg = (pState->pszStatusArg)
                    ? pState->pszStatusArg : TEXT("");

                // Find length of formatted string with text argument (if any)
                // inserted and any progress dots appended.
                //
                cch = lstrlen( pszState ) + lstrlen( pszArg ) + 1;

                pszFormattedState = Malloc( cch * sizeof(TCHAR) );
                if (pszFormattedState)
                {
                    apszArgs[ 0 ] = pszArg;
                    *pszFormattedState = TEXT('\0');

                    FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING
                            | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        pszState, 0, 0, pszFormattedState, cch,
                        (va_list* )apszArgs );

                    Free( pszState );
                    pszState = pszFormattedState;
                }
            }

            TRACE1("DpEvent:State:'%s'",pszState);
    
            if (pszState)
            {
                SetWindowText( pInfo->hwndStState, pszState );
                InvalidateRect( pInfo->hwndStState, NULL, TRUE );
                UpdateWindow( pInfo->hwndStState );
                LocalFree( pszState );
            }
        }
    }

    if (pState->state & RASCS_PAUSED)
    {
        // Paused state just processed.  Release the callback, and dial again
        // to resume.
        //
        TRACE("DpEvent:Paused, will dial again\nthe global callbacks wont init again");
        TRACE( "Post(DIAL)" );
        PostMessage( pInfo->hwndDlg, WM_RASDIAL, TRUE, 0 );
        return dwCode;
    }

    if (pState->state & RASCS_DONE)
    {
        // Terminal state just processed.
        //
        if (pState->state == RASCS_Connected)
        {
            // For multi-link entries, if there is at least one successful
            // line and at least one failed line, popup the bundling error
            // dialog.
            //
            if (pInfo->cStates > 1)
            {
                DPSTATE* p;

                dwcSuccessLinks = dwcFailedLinks = 0;
                for (i = 0, p = pInfo->pStates; i < pInfo->cStates; ++i, ++p)
                {
                    if (p->dwError == 0)
                    {
                        ++dwcSuccessLinks;
                    }
                    else
                    {
                        ++dwcFailedLinks;
                    }
                }

                if (dwcSuccessLinks > 0 && dwcFailedLinks > 0)
                {
                     TRACE( "Post(BUNDLEERROR)" );
                     PostMessage( pInfo->hwndDlg,
                         WM_RASBUNDLEERROR, 0, (LPARAM )pState );
                     return 0;
                }
            }

            EndDialog( pInfo->hwndDlg, TRUE );
        }
        else
        {
            DpCancel( pInfo );
        }   

        return 0;
    }

    TRACE1("DpEvent:returned dwCode:(%d)", dwCode);
    TRACE("End of DpEvent");
    
    return dwCode;
}


BOOL
DpInit(
    IN HWND hwndDlg,
    IN DINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DPINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "DpInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->dwValid = 0xC0BBC0DE;
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        //Add a per-thread Terminate flag for whistler bug 291613 gangz
        //
        pInfo->fTerminateAsap = FALSE;
        pInfo->ulCallbacksActive = 0;
        
        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndStState = GetDlgItem( hwndDlg, CID_DP_ST_State );
    ASSERT( pInfo->hwndStState );

    pEntry = pArgs->pEntry;

    // Set up our context to be returned by the RasDialFunc2 callback.
    //
    pInfo->pArgs->rdp.dwCallbackId = (ULONG_PTR )pInfo;

    // Subclass the dialog so we can get the result from
    // SendMessage(WM_RASDIALEVENT) in RasDlgFunc2.
    //
    pInfo->pOldWndProc =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndDlg, GWLP_WNDPROC, (ULONG_PTR )DpWndProc );

    // Set the title.
    //
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];

        pszTitleFormat = GetText( hwndDlg );
        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pEntry->pszEntryName;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }
    }

    // Set the correct icon. For whistler bug 372078    gangz
    //
    SetIconFromEntryType(
        GetDlgItem( hwndDlg, CID_DP_Icon ),
        pArgs->pEntry->dwType,
        FALSE);     //FALSE means large Icon
    
    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        pArgs->pArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pArgs->xDlg, pArgs->pArgs->yDlg );

    // Hide the dialog if "no progress" user preference is set.
    //
    if (!pArgs->pEntry->fShowDialingProgress
        || pArgs->fDialForReferenceOnly)
    {
        SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    }

    SetForegroundWindow( hwndDlg );

    // Allocate subentry status array.  It's initialized by DpDial.
    //
    {
        DWORD cb;

        ASSERT( pEntry->pdtllistLinks );
        pInfo->cStates = DtlGetNodes( pEntry->pdtllistLinks );
        cb = sizeof(DPSTATE) * pInfo->cStates;
        pInfo->pStates = Malloc( cb );
        if (!pInfo->pStates)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        pInfo->dwRedialAttemptsLeft =
            GetOverridableParam(
                pInfo->pArgs->pUser, pInfo->pArgs->pEntry,
                RASOR_RedialAttempts );
    }

    //for whistler bug 316622   gangz
    //The dwSubEntry is not initialized
    //
    pInfo->pArgs->rdp.dwSubEntry = pInfo->pArgs->pArgs->dwSubEntry;
    
    // Rock and roll.
    //
    DpDial( pInfo, FALSE );

    return TRUE;
}


VOID
DpInitStates(
    DPINFO* pInfo )

    // Resets 'pInfo->pStates' to initial values.  'PInfo' is the dialog
    // context.
    //
{
    DWORD    i;
    DPSTATE* pState;

    for (i = 0, pState = pInfo->pStates; i < pInfo->cStates; ++i, ++pState)
    {
        ZeroMemory( pState, sizeof(*pState) );
        pInfo->state = (RASCONNSTATE )-1;
        pState->dwError = 0;
    }
}


BOOL
DpInteractive(
    IN DPINFO* pInfo,
    IN DPSTATE* pState,
    OUT BOOL* pfChange )

    // RASCS_Interactive handling.  'PInfo' is the dialog context.  'PState'
    // is the subentry state.  '*pfChange' is set true if the entry (i.e. SLIP
    // address) was changed or false otherwise.
    //
    // Returns true if successful, false if cancel.
    //
{
    DWORD dwErr;
    DWORD sidTitle;
    TCHAR szIpAddress[ TERM_IpAddress ];
    TCHAR* pszIpAddress;
    PBENTRY* pEntry;

    TRACE( "DpInteractive" );

    *pfChange = FALSE;
    pEntry = pInfo->pArgs->pEntry;

    if (pEntry->dwBaseProtocol == BP_Slip)
    {
        lstrcpyn( 
            szIpAddress,
            (pEntry->pszIpAddress) ? pEntry->pszIpAddress : TEXT("0.0.0.0"),
            sizeof(szIpAddress) / sizeof(TCHAR));
        pszIpAddress = szIpAddress;
        sidTitle = SID_T_SlipTerminal;
    }
    else
    {
        szIpAddress[0] = TEXT('\0');
        pszIpAddress = szIpAddress;
        sidTitle =
            (pState->sidState == SID_S_ConnectPreSwitch)
                ? SID_T_PreconnectTerminal
                : (pState->sidState == SID_S_ConnectPostSwitch)
                      ? SID_T_PostconnectTerminal
                      : SID_T_ManualDialTerminal;
    }

    if(1 == pEntry->dwCustomScript)
    {
        DWORD dwErr = SUCCESS;

        dwErr = DwCustomTerminalDlg(
                        pInfo->pArgs->pFile->pszPath,
                        pInfo->hrasconn,
                        pEntry,
                        pInfo->hwndDlg,
                        &pInfo->pArgs->rdp,
                        NULL);

        if(SUCCESS == dwErr)
        {
#if 0
            //
            // Reread the phonebook file since the
            // custom script could have written
            // new information to the file.
            // 
            ClosePhonebookFile(pInfo->pArgs->pFile);

            dwErr = ReadPhonebookFile(
                        pInfo->pArgs->pszPhonebook, 
                        &pInfo->pArgs->user, 
                        NULL, 0, &pInfo->pArgs->file );

            if(SUCCESS == dwErr)
            {
                pInfo->pArgs->pFile = &pInfo->pArgs->file;
            }
#endif            
        }
        
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_ScriptHalted, dwErr, NULL );
        }
        
        return (ERROR_SUCCESS == dwErr);
    }

    if (!TerminalDlg(
            pInfo->pArgs->pEntry, &pInfo->pArgs->rdp, pInfo->hwndDlg,
            pState->hrasconnLink, sidTitle, pszIpAddress ))
    {
        TRACE( "TerminalDlg==FALSE" );
        return FALSE;
    }

    TRACE2( "pszIpAddress=0x%08x(%ls)", pszIpAddress,
        pszIpAddress ? pszIpAddress : TEXT("") );
    TRACE2( "pEntry->pszIpAddress=0x%08x(%ls)", pEntry->pszIpAddress,
        pEntry->pszIpAddress ? pEntry->pszIpAddress : TEXT("") );

    if (pszIpAddress[0]
        && (!pEntry->pszIpAddress
            || lstrcmp( pszIpAddress, pEntry->pszIpAddress ) != 0))
    {
        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = StrDup( szIpAddress );
        pEntry->fDirty = TRUE;
        *pfChange = TRUE;

        dwErr = WritePhonebookFile( pInfo->pArgs->pFile, NULL );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook, dwErr, NULL );
        }
    }

    pState->sidState = 0;
    return TRUE;
}


BOOL
DpIsLaterState(
    IN RASCONNSTATE stateNew,
    IN RASCONNSTATE stateOld )

    // Returns true if 'stateNew' is farther along in the connection than
    // 'stateOld' false if the same or not as far along.
    //
{
    // This array is in the order events normally occur.
    //
    // !!! New EAP states?
    //
    static RASCONNSTATE aState[] =
    {
        (RASCONNSTATE )-1,
        RASCS_OpenPort,
        RASCS_PortOpened,
        RASCS_ConnectDevice,
        RASCS_DeviceConnected,
        RASCS_Interactive,
        RASCS_AllDevicesConnected,
        RASCS_StartAuthentication,
        RASCS_Authenticate,
        RASCS_InvokeEapUI,
        RASCS_AuthNotify,
        RASCS_AuthRetry,
        RASCS_AuthAck,
        RASCS_PasswordExpired,
        RASCS_AuthChangePassword,
        RASCS_AuthCallback,
        RASCS_CallbackSetByCaller,
        RASCS_PrepareForCallback,
        RASCS_WaitForModemReset,
        RASCS_WaitForCallback,
        RASCS_CallbackComplete,
        RASCS_RetryAuthentication,
        RASCS_ReAuthenticate,
        RASCS_Authenticated,
        RASCS_AuthLinkSpeed,
        RASCS_AuthProject,
        RASCS_Projected,
        RASCS_LogonNetwork,
        RASCS_SubEntryDisconnected,
        RASCS_SubEntryConnected,
        RASCS_Disconnected,
        RASCS_Connected,
        (RASCONNSTATE )-2,
    };

    RASCONNSTATE* pState;

    for (pState = aState; *pState != (RASCONNSTATE )-2; ++pState)
    {
        if (*pState == stateNew)
        {
            return FALSE;
        }
        else if (*pState == stateOld)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DpPasswordExpired(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_PasswordExpired state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
    // Returns true if successful, false otherwise.
    //
{
    TCHAR szOldPassword[ PWLEN + 1 ];
    BOOL fSuppliedOldPassword;

    TRACE( "DpPasswordExpired" );

    szOldPassword[ 0 ] = TEXT('\0');

    // Stash "good" username and password which are restored if the password
    // change fails.
    //
    pInfo->pszGoodUserName = StrDup( pInfo->pArgs->rdp.szUserName );

    // Whistler bug 254385 encode password when not being used
    // Assumed password was encoded previously
    //
    DecodePassword( pInfo->pArgs->rdp.szPassword );
    pInfo->pszGoodPassword = StrDup( pInfo->pArgs->rdp.szPassword );
    EncodePassword( pInfo->pArgs->rdp.szPassword );
    EncodePassword( pInfo->pszGoodPassword );

    fSuppliedOldPassword =
        (!pInfo->pArgs->pEntry->fAutoLogon || pInfo->pArgs->pNoUser);

    if (!ChangePasswordDlg(
            pInfo->hwndDlg, !fSuppliedOldPassword,
            szOldPassword, pInfo->pArgs->rdp.szPassword ))
    {
        // Whistler bug 254385 encode password when not being used
        //
        ZeroMemory( szOldPassword, sizeof(szOldPassword) );
        return FALSE;
    }

    if (pInfo->pArgs->pNoUser)
    {
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pInfo->pArgs->rdp.szPassword );
        lstrcpyn( 
            pInfo->pArgs->pNoUser->szPassword,
            pInfo->pArgs->rdp.szPassword,
            PWLEN + 1);
        EncodePassword( pInfo->pArgs->rdp.szPassword );
        EncodePassword( pInfo->pArgs->pNoUser->szPassword );
        *pInfo->pArgs->pfNoUserChanged = TRUE;
    }

    // The old password (in text form) is explicitly set, since in AutoLogon
    // case a text form has not yet been specified.  The old password in text
    // form is required to change the password.  The "old" private API expects
    // an ANSI argument.
    //
    if (!fSuppliedOldPassword)
    {
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded by ChangePasswordDlg()
        //
        CHAR* pszOldPasswordA;

        DecodePassword( szOldPassword );
        pszOldPasswordA = StrDupAFromT( szOldPassword );
        if (pszOldPasswordA)
        {
            ASSERT( g_pRasSetOldPassword );
            g_pRasSetOldPassword( pInfo->hrasconn, pszOldPasswordA );
            ZeroMemory( pszOldPasswordA, lstrlenA( pszOldPasswordA ) );
            Free( pszOldPasswordA );
        }
    }

    ZeroMemory( szOldPassword, sizeof(szOldPassword) );

    if (pInfo->pArgs->rdp.szUserName[ 0 ] == TEXT('\0'))
    {
        // Explicitly set the username, effectively turning off AutoLogon for
        // the "resume" password authentication, where the new password should
        // be used.
        //
        lstrcpyn( pInfo->pArgs->rdp.szUserName, GetLogonUser(), UNLEN + 1 );
    }

    pState->sidState = 0;
    return TRUE;
}


BOOL
DpProjected(
    IN DPINFO* pInfo,
    IN DPSTATE* pState )

    // RASCS_Projected state handling.  'PInfo' is the dialog context.
    // 'PState' is the subentry state.
    //
    // Returns true if successful, false otherwise.
    //
{
    DWORD dwErr;
    RASAMB amb;
    RASPPPNBF nbf;
    RASPPPIPX ipx;
    RASPPPIP ip;
    RASPPPLCP lcp;
    RASSLIP slip;
    RASPPPCCP ccp;
    BOOL fIncomplete;
    DWORD dwfProtocols;
    TCHAR* pszLines;

    TRACE( "DpProjected" );

    pState->sidState = SID_S_Projected;

    //
    // If PORT_NOT_OPEN is indicated, it probably means that the 
    // server disconnected the connection before result dialog
    // was dismissed.  In that case, this is the 2nd time DpProjected
    // is called.  This time, the error is indicated by ras and the
    // state remains "projected".
    //
    // We need to return an error in this case so that the connection
    // isn't hung since this is the last indication RAS will give us.
    //
    // See bug 382254
    //

    TRACE1("DpProjected: dwErr:(%d)", pState->dwError);
    
    if ( (pState->dwError == ERROR_PORT_NOT_OPEN) ||
         (pState->dwError == ERROR_NO_CONNECTION) )     //See bug 169111 whistler
    {
        return FALSE;
    }

    // Do this little dance to ignore the error that comes back from the
    // "all-failed" projection since we detect this in the earlier
    // notification where pState->dwError == 0.  This avoids a race where the
    // API comes back with the error before we can hang him up.  This race
    // would not occur if we called RasHangUp from within the callback thread
    // (as recommended in our API doc).  It's the price we pay for posting the
    // error to the other thread in order to avoid holding the port open while
    // an error dialog is up.
    //
    else if (pState->dwError != 0)
    {
        pState->dwError = 0;
        DpCallbacksFlag( pInfo, 0 );
        return TRUE;
    }

    // Read projection info for all protocols, translating "not requested"
    // into an in-structure code for later reference.
    //
    dwErr = GetRasProjectionInfo(
        pState->hrasconnLink, &amb, &nbf, &ip, &ipx, &lcp, &slip, &ccp );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RasGetProtocolInfo, dwErr, NULL );
        return FALSE;
    }

    if (amb.dwError != ERROR_PROTOCOL_NOT_CONFIGURED)
    {
        // It's an AMB projection.
        //
        if (amb.dwError != 0)
        {
            // Translate AMB projection errors into regular error codes.  AMB
            // does not use the special PPP projection error mechanism.
            //
            pState->dwError = amb.dwError;
            lstrcpyn( 
                pState->szExtendedError, 
                amb.szNetBiosError,
                sizeof(pState->szExtendedError) / sizeof(TCHAR));
        }
        return TRUE;
    }

    // At this point, all projection information has been gathered
    // successfully and we know it's a PPP-based projection.  Now analyze the
    // projection results...
    //
    dwfProtocols = 0;
    fIncomplete = FALSE;
    if (DpProjectionError(
            &nbf, &ipx, &ip,
            &fIncomplete, &dwfProtocols, &pszLines, &pState->dwError ))
    {
        // A projection error occurred.
        //
        if (fIncomplete)
        {
            BOOL fStatus;
            BOOL fDisable;

            // An incomplete projection occurred, i.e. some requested CPs
            // connected and some did not.  Ask the user if what worked is
            // good enough or he wants to bail.
            //
            pState->dwError = 0;
            fDisable = FALSE;
            fStatus = ProjectionResultDlg(
                pInfo->hwndDlg, pszLines, &fDisable );
            Free( pszLines );

            if (fDisable)
            {
                pInfo->pArgs->dwfExcludedProtocols = dwfProtocols;
            }

            // Return now if user chose to hang up.
            //
            if (!fStatus)
            {
                return FALSE;
            }
        }
        else
        {
            // All CPs in the projection failed.  Process as a regular fatal
            // error with 'pState->dwError' set to the first error in NBF, IP,
            // or IPX, but with a format that substitutes the status argument
            // for the "Error nnn: Description" text.  This lets us patch in
            // the special multiple error projection text, while still giving
            // a meaningful help context.
            //
            Free0( pState->pszFormatArg );
            pState->pszFormatArg = pszLines;
            pState->sidFormatMsg = SID_FMT_ErrorMsgProject;
        }
    }

    //
    // pmay: 190394
    //
    // If the admin has a message, display it.
    //
    if ( (pState->dwError == NO_ERROR)     &&
         (wcslen (lcp.szReplyMessage) != 0)
       )
    {
        MSGARGS MsgArgs, *pMsgArgs = &MsgArgs;

        ZeroMemory(pMsgArgs, sizeof(MSGARGS));
        pMsgArgs->dwFlags = MB_OK | MB_ICONINFORMATION;
        pMsgArgs->apszArgs[0] = lcp.szReplyMessage;

        //MsgDlg(
        //    pInfo->hwndDlg,
        //    SID_ReplyMessageFmt,
        //    pMsgArgs);
    }

    pState->sidState = SID_S_Projected;
    return TRUE;
}


BOOL
DpProjectionError(
    IN RASPPPNBF* pnbf,
    IN RASPPPIPX* pipx,
    IN RASPPPIP* pip,
    OUT BOOL* pfIncomplete,
    OUT DWORD* pdwfFailedProtocols,
    OUT TCHAR** ppszLines,
    OUT DWORD* pdwError )

    // Figure out if a projection error occurred and, if so, build the
    // appropriate status/error text lines into '*ppszLines'.  '*PfIncomlete'
    // is set true if at least one CP succeeded and at least one failed.
    // '*pdwfFailedProtocols' is set to the bit mask of NP_* that failed.
    // '*pdwError' is set to the first error that occurred in NBF, IP, or IPX
    // in that order or 0 if none.  'pnbf', 'pipx', and 'pip' are projection
    // information for the respective protocols with dwError set to
    // ERROR_PROTOCOL_NOT_CONFIGURED if the protocols was not requested.
    //
    // This routine assumes that at least one protocol was requested.
    //
    // Returns true if a projection error occurred, false if not.  It's
    // caller's responsiblity to free '*ppszLines'.
    //
{
#define MAXPROJERRLEN 1024

    TCHAR szLines[ MAXPROJERRLEN ];
    BOOL fIp = (pip->dwError != ERROR_PROTOCOL_NOT_CONFIGURED);
    BOOL fIpx = (pipx->dwError != ERROR_PROTOCOL_NOT_CONFIGURED);
    BOOL fNbf = (pnbf->dwError != ERROR_PROTOCOL_NOT_CONFIGURED);
    BOOL fIpBad = (fIp && pip->dwError != 0);
    BOOL fIpxBad = (fIpx && pipx->dwError != 0);
    BOOL fNbfBad = (fNbf && pnbf->dwError != 0);

    TRACE( "DpProjectionError" );

    *pdwfFailedProtocols = 0;
    if (!fNbfBad && !fIpxBad && !fIpBad)
    {
        return FALSE;
    }

    if (fNbfBad)
    {
        *pdwfFailedProtocols |= NP_Nbf;
    }
    if (fIpxBad)
    {
        *pdwfFailedProtocols |= NP_Ipx;
    }
    if (fIpBad)
    {
        *pdwfFailedProtocols |= NP_Ip;
    }

    *pfIncomplete =
        ((fIp && pip->dwError == 0)
         || (fIpx && pipx->dwError == 0)
         || (fNbf && pnbf->dwError == 0));

    szLines[ 0 ] = 0;
    *ppszLines = NULL;
    *pdwError = 0;

    if (fIpBad || (*pfIncomplete && fIp))
    {
        if (fIpBad)
        {
            *pdwError = pip->dwError;
            DpAppendConnectErrorLine( szLines, SID_Ip, pip->dwError );
        }
        else
        {
            DpAppendConnectOkLine( szLines, SID_Ip );
        }
        DpAppendBlankLine( szLines );
    }

    if (fIpxBad || (*pfIncomplete && fIpx))
    {
        if (fIpxBad)
        {
            *pdwError = pipx->dwError;
            DpAppendConnectErrorLine( szLines, SID_Ipx, pipx->dwError );
        }
        else
        {
            DpAppendConnectOkLine( szLines, SID_Ipx );
        }
        DpAppendBlankLine( szLines );
    }

    if (fNbfBad || (*pfIncomplete && fNbf))
    {
        if (fNbfBad)
        {
            *pdwError = pnbf->dwError;
            DpAppendConnectErrorLine( szLines, SID_Nbf, pnbf->dwError );

            if (pnbf->dwNetBiosError)
            {
                DpAppendFailCodeLine( szLines, pnbf->dwNetBiosError );
            }

            if (pnbf->szNetBiosError[ 0 ] != '\0')
            {
                DpAppendNameLine( szLines, pnbf->szNetBiosError );
            }
        }
        else
        {
            DpAppendConnectOkLine( szLines, SID_Nbf );
        }
        DpAppendBlankLine( szLines );
    }

    *ppszLines = StrDup( szLines );
    return TRUE;
}


DWORD WINAPI
DpRasDialFunc2(
    ULONG_PTR dwCallbackId,
    DWORD dwSubEntry,
    HRASCONN hrasconn,
    UINT unMsg,
    RASCONNSTATE state,
    DWORD dwError,
    DWORD dwExtendedError )

    // RASDIALFUNC2 callback to receive RasDial events.
    //
    // Returns 0 to stop callbacks, 1 to continue callbacks (normal), and 2 to
    // tell RAS API that relevant entry information (like SLIP IP address) has
    // changed.
    //
{
    DWORD dwErr;
    DWORD dwCode;
    DPINFO* pInfo;
    DPSTATE* pState;
    BOOL fTerminateAsap;

    TRACE4( "/DpRasDialFunc2(rcs=%d,s=%d,e=%d,x=%d)",
        state, dwSubEntry, dwError, dwExtendedError );

            
    pInfo = (DPINFO* )dwCallbackId;
    if (pInfo->dwValid != 0xC0BBC0DE)
    {
        TRACE( "DpRasDialFunc2 returns for Late callback?" );

        return 0;
    }

    if (dwSubEntry == 0 || dwSubEntry > pInfo->cStates)
    {
        TRACE( "DpRasDialFunc2 returns for Subentry out of range?" );
        return 1;
    }

    pState = &pInfo->pStates[ dwSubEntry - 1 ];
    pState->state = state;
    pState->dwError = dwError;
    pState->dwExtendedError = dwExtendedError;

    // Post the event to the Dial Progress window and wait for it to be
    // processed before returning.  This avoids subtle problems with Z-order
    // and focus when a window is manipulated from two different threads.
    //
    TRACE1("Send RasEvent to Dial Progress window, subEntry:(%d)", dwSubEntry);
    TRACE1("Get dwError=(%d) from RasMan",pState->dwError);
    TRACE2("DpRasDialFunc2:Process:(%x),Thread(%x)", 
            GetCurrentProcessId,
            GetCurrentThreadId);
    TRACE2("DpRasDialFunc2:pInfo address (0x%x), Dialog Handle (0x%x)",
            pInfo, 
            pInfo->hwndDlg);
    
    dwCode = (DWORD)SendMessage( pInfo->hwndDlg, WM_RASEVENT, dwSubEntry, 0 );

    TRACE1( "\\DpRasDialFunc2: dwCode from SendMessage()=%d", dwCode );
    TRACE1("dwCode returned:(%d)", dwCode);

    // When callback function DpRasDialFunc2() returns 0, then RasMan wont 
    //call it again, so we wont return 0 unless all the message returned from
    //RasMan has been processed     for whislter bug 291613     gangz
    //
    {
     long ulCallbacksActive;

    //Check if current thread wants to terminate itself
    //
     ulCallbacksActive = DpOnOffPerThreadTerminateFlag(pInfo,  -1, &fTerminateAsap );

     TRACE1("Current thread's active:(%d)", ulCallbacksActive);
     
     if ( fTerminateAsap )
      {
        //decrease  pInfo->ulCallbacksActive and g_ulCallbacksActive
        //if necessary
        //
        TRACE("Current Thread wants to terminate itself, its fterminateASSP=1!");
        TRACE("Current thread will decrease its own and global active!");

        DpCallbacksFlag( pInfo, 0 );

        //reset per-thread terminateASAP flag
        //
        DpOnOffPerThreadTerminateFlag(pInfo,  0, NULL );
      }
      else
      {
        TRACE("Current Thread does NOT want to terminate itself,its fterminateASAP=0!");
      }

      //return the global number of active callbacks
      //
      ulCallbacksActive =  CallbacksActive( -1, NULL );

      TRACE1( "\\DpRasDialFunc2:g_ulCallbacksActive=%ld", ulCallbacksActive );

      //if g_ulCallbacksActive is already zero, we must return 0 to RasMan
      //

      {
          TRACE1("Global active:(%d)", ulCallbacksActive);
          TRACE1("Current thread's active:(%d)", 
                 DpOnOffPerThreadTerminateFlag(pInfo,  -1, NULL ) );
      }
      
      if ( 0 == ulCallbacksActive )
      {

         if ( 0 == DpOnOffPerThreadTerminateFlag(pInfo, -1, NULL ) )
         {
             TRACE( "Will terminate Callbacks " );
             dwCode = 0;
         }
         else
         {
          //For whistler bug 341662 366237     gangz
          //Something messed up the g_ulCallbacksActive flag
          // Now that g_ulCallbacksActive is 0, DpCallbacksFlag( pInfo, 0 ) wont 
          // decrease it now, it only decrease pInfo->ulCallbacksActive by 1
            TRACE("ReSync accured!");
            DpCallbacksFlag( pInfo, 0 );

          //then call  DpCallbacksFlag( pInfo, 1 ); to increase both the global
          // callbacks active flag g_ulCallbacksActive and per thread
          // pInfo->ulCallbacksActive
          //
            DpCallbacksFlag( pInfo, 1 );
          }
          
       }
       else if ( 0 == dwCode )
       {
        //Other callbacks are still active, wait for them
        //
        dwCode = 1;

        //Clear current pInfo->ulCallbacksActive if necessary when
        //this dwCode is returned by SendMessage() at above
        //
        TRACE("Other callbacks are still active, wait for them");
        TRACE("Just Clear current pInfo->ulCallbacksActive\n");

        DpCallbacksFlag( pInfo, 0 );

        //After cleared current pInfo->ulCallbacksActive, if the number
        //of active callbacks becomes zero, then we should return 0 to RasMan
        //
        ulCallbacksActive =  CallbacksActive( -1, &fTerminateAsap );

        TRACE1( "\\DpRasDialFunc2:g_ulCallbacksActive after clearing cur-thread =%ld", ulCallbacksActive );

        if ( 0 == ulCallbacksActive )
        {
             TRACE( "Will terminate Callbacks " );

             dwCode = 0;
         }
       }
     }

    if (dwCode == 0)
    {
        // Set thread-safe flag indicating callbacks have terminated.
        //
        DpCallbacksFlag( pInfo, 0 );
    }

    // Note: If 'dwCode' is 0, the other thread is racing to terminate the
    //       dialog.  Must not dereference 'pInfo' in this case.


    TRACE1( "\\DpRasDialFunc2:final dwCode returned=%d", dwCode );

    return dwCode;
}


VOID
DpTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "DpTerm" );

    if (pInfo)
    {
        if (pInfo->pOldWndProc)
        {
            SetWindowLongPtr( pInfo->hwndDlg,
                GWLP_WNDPROC, (ULONG_PTR )pInfo->pOldWndProc );
        }

        Free0( pInfo->pStates );
        pInfo->dwValid = 0;

        Free( pInfo );
    }

    //For whistler bug 372078       gangz
    //
    {
        HICON hIcon=NULL;
        hIcon = (HICON)SendMessage( GetDlgItem( hwndDlg, CID_DP_Icon ),
                             STM_GETICON,
                             0,
                             0);
                              
        ASSERT(hIcon);
        if( hIcon )
        {
            DestroyIcon(hIcon);
        }
        else
        {
            TRACE("DpTerm:Destroy Icon failed");
        }
     }
    
}


LRESULT APIENTRY
DpWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed dialog window procedure.
    //
{
    DPINFO* pInfo = (DPINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
    ASSERT( pInfo );

    if (unMsg == WM_RASEVENT)
    {
        return DpEvent( pInfo, (DWORD )wParam );
    }

    return
        CallWindowProc(
            pInfo->pOldWndProc, hwnd, unMsg, wParam, lParam );
}


//----------------------------------------------------------------------------
// Dialer dialogs
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
DialerDlg(
    IN HWND hwndOwner,
    IN OUT DINFO* pInfo )

    // Determine if it's necessary, and if so, popup one of the variations of
    // the dialer dialog, i.e. the prompter for user/password/domain, phone
    // number, and location.  'HwndOwner' is the owning window.  'PInfo' is
    // the dial dialog common context.
    //
    // Returns true if no dialog is needed or user chooses OK.
    //
{
    INT_PTR nStatus = FALSE;
    int nDid;
    DWORD dwfMode;
    DRARGS args;

    TRACE( "DialerDlg" );

    do
    {
        dwfMode = 0;

        if (!pInfo->pEntry->fAutoLogon
            && pInfo->pEntry->fPreviewUserPw
            && (!(pInfo->pArgs->dwFlags & RASDDFLAG_NoPrompt)
                || (pInfo->fUnattended && !HaveSavedPw( pInfo ))))
        {
            dwfMode |= DR_U;

            if (pInfo->pEntry->fPreviewDomain)
            {
                dwfMode |= DR_D;
            }
        }

        if (pInfo->pEntry->fPreviewPhoneNumber
            && (!(pInfo->pArgs->dwFlags & RASDDFLAG_NoPrompt)
                || (pInfo->fUnattended && !HaveSavedPw( pInfo ))))
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            dwfMode |= DR_N;

            // Location controls mode only when at least one phone number in
            // the list is TAPI-enabled.
            //
            pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNode );
            for (pNode = DtlGetFirstNode( pLink->pdtllistPhones );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                PBPHONE* pPhone = (PBPHONE* )DtlGetData( pNode );

                if (pPhone->fUseDialingRules)
                {
                    dwfMode |= DR_L;
                    break;
                }
            }
        }

        // Customize the dialing flags for the type of eap authentication
        // specified for this entry (if any)
        if (DialerEapAssignMode(pInfo, &dwfMode) != NO_ERROR)
            break;

        if (dwfMode == DR_U)
        {
            nDid = DID_DR_DialerU;
        }
        else if (dwfMode == (DR_U | DR_D))
        {
            nDid = DID_DR_DialerUD;
        }
        else if (dwfMode == (DR_U | DR_N))
        {
            nDid = DID_DR_DialerUN;
        }
        else if (dwfMode == (DR_U | DR_N | DR_L))
        {
            nDid = DID_DR_DialerUNL;
        }
        else if (dwfMode == (DR_U | DR_D | DR_N))
        {
            nDid = DID_DR_DialerUDN;
        }
        else if (dwfMode == (DR_U | DR_D | DR_N | DR_L))
        {
            nDid = DID_DR_DialerUDNL;
        }
        else if (dwfMode == DR_N)
        {
            nDid = DID_DR_DialerN;
        }
        else if (dwfMode == (DR_N | DR_L))
        {
            nDid = DID_DR_DialerNL;
        }
        else if (dwfMode == DR_I) {
            nDid = DID_DR_DialerI;
        }
        else if (dwfMode == (DR_I | DR_N)) {
            nDid = DID_DR_DialerIN;
        }
        else if (dwfMode == (DR_I | DR_N | DR_L)) {
            nDid = DID_DR_DialerINL;
        }

        // pmay:  The following 3 permutations of the
        // dialer dialog were added for bug 183577 which
        // states that eap modules (that use DR_I) want to
        // have the domain field available to them as well.
        else if (dwfMode == (DR_I | DR_D)) {
            nDid = DID_DR_DialerID;
        }
        else if (dwfMode == (DR_I | DR_D | DR_N)) {
            nDid = DID_DR_DialerIDN;
        }
        else if (dwfMode == (DR_I | DR_D | DR_N | DR_L)) {
            nDid = DID_DR_DialerIDNL;
        }

        else
        {
            ASSERT( dwfMode == 0 );
            return TRUE;
        }

        args.pDinfo = pInfo;
        args.dwfMode = dwfMode;
        args.fReload = FALSE;

        nStatus =
            (BOOL )DialogBoxParam(
                g_hinstDll,
                MAKEINTRESOURCE( nDid ),
                hwndOwner,
                DrDlgProc,
                (LPARAM )&args );

        if (nStatus == -1)
        {
            ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            nStatus = FALSE;
        }
    }
    while (args.fReload);

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
DrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the dialer dialogs.  Parameters and return
    // value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DrInit( hwnd, (DRARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDrHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            DRINFO* pInfo = (DRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return DrCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            DrTerm( hwnd );
            break;
        }
    }

    return FALSE;
}

VOID
DrGetFriendlyFont(
    IN HWND hwnd,
    IN BOOL fUpdate,
    OUT HFONT* phFont )

    // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
    // does not match the length of the password and causes confusion
    //
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    HDC     hdc;

    *phFont = NULL;

    // Get the font used by the specified window
    //
    hFont = (HFONT)SendMessage( hwnd, WM_GETFONT, 0, 0L );
    if (NULL == hFont)
    {
        // If not found then the control is using the system font
        //
        hFont = (HFONT)GetStockObject( SYSTEM_FONT );
    }

    if (hFont && GetObject( hFont, sizeof(BoldLogFont), &BoldLogFont ))
    {
        if (fUpdate)
        {
            BoldLogFont.lfItalic = TRUE;
        }

        hdc = GetDC( hwnd );
        if (hdc)
        {
            *phFont = CreateFontIndirect( &BoldLogFont );
            ReleaseDC( hwnd, hdc );
        }
    }

    return;
}

DWORD
DrEnableDisablePwControls(
    IN DRINFO* pInfo,
    IN BOOL fEnable )
{
    if (pInfo->pArgs->pDinfo->fIsPublicPbk)
    {
        EnableWindow( pInfo->hwndRbSaveForEveryone, fEnable );
    }
    else
    {
        EnableWindow( pInfo->hwndRbSaveForEveryone, FALSE );
    }

    EnableWindow( pInfo->hwndRbSaveForMe, fEnable );

    return NO_ERROR;
}

VOID
DrClearFriendlyPassword(
    IN DRINFO* pInfo,
    IN BOOL fFocus )
{
    SetWindowText( pInfo->hwndEbPw, L"" );

    if (fFocus)
    {
        SendMessage( pInfo->hwndEbPw, EM_SETPASSWORDCHAR,
            pInfo->szPasswordChar, 0 );

        if (pInfo->hNormalFont)
        {
            SendMessage(
                pInfo->hwndEbPw,
                WM_SETFONT,
                (WPARAM)pInfo->hNormalFont,
                MAKELPARAM(TRUE, 0) );
        }

        SetFocus( pInfo->hwndEbPw );
    }

    return;
}

VOID
DrDisplayFriendlyPassword(
    IN DRINFO* pInfo,
    IN TCHAR* pszFriendly )
{
    if (pszFriendly)
    {
        SendMessage( pInfo->hwndEbPw, EM_SETPASSWORDCHAR, 0, 0 );
        SetWindowText( pInfo->hwndEbPw, pszFriendly );
    }
    else
    {
        SetWindowText( pInfo->hwndEbPw, L"" );
    }

    if (pInfo->hItalicFont)
    {
        SendMessage(
            pInfo->hwndEbPw,
            WM_SETFONT,
            (WPARAM)pInfo->hItalicFont,
            MAKELPARAM(TRUE, 0) );
    }

    return;
}

BOOL
DrIsPasswordStyleEnabled(
    IN HWND hWnd )
{
    return SendMessage( hWnd, EM_GETPASSWORDCHAR, 0, 0 ) ? TRUE : FALSE;
}

BOOL
DrCommand(
    IN DRINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DrCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_DR_CLB_Numbers:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                DrNumbersSelChange( pInfo );
                return TRUE;
            }
            break;
        }

        case CID_DR_CB_SavePassword:
        {
            BOOL fEnable = Button_GetCheck( hwndCtrl );
            DrEnableDisablePwControls( pInfo, fEnable );
            DrPopulatePasswordField( pInfo, FALSE, FALSE );
            return TRUE;
        }

        // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
        // does not match the length of the password and causes confusion
        //
        case CID_DR_EB_Password:
        {
            // This is a hack really so that we restore the Tab Stop to the
            // username field. The reason it had to be removed was because we
            // were receiving complaints that the focus shouldn't always go to
            // the username field if it's non-null. The only way to fix this,
            // since windows sets the initial focus to the first visible non-
            // hidden tab stopped field, is to remove the tab stop temporarily
            // from the username field.
            //
            if (wNotification == EN_KILLFOCUS)
            {
                LONG lStyle = GetWindowLong( pInfo->hwndEbUser, GWL_STYLE );

                if (!(lStyle & WS_TABSTOP))
                {
                    // If we detect tap stop removed from the username field,
                    // restore it. Since this case only fires when the password
                    // was not previously saved on init, we can return here.
                    //
                    SetWindowLong( pInfo->hwndEbUser, GWL_STYLE,
                        lStyle | WS_TABSTOP );
                    return TRUE;
                }
                // If the user leaves the password field w/o typing a new
                // password, and a saved password is present, restore the
                // friendly password text.
                //
                DrPopulatePasswordField( pInfo, FALSE, FALSE );
                return TRUE;
            }
            // If the password field ever receives the focus, clear the
            // friendly password text if applicable.
            //
            else if (wNotification == EN_SETFOCUS &&
                     !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))
            {
                DrPopulatePasswordField( pInfo, FALSE, TRUE );
                return TRUE;
            }
            break;
        }

        case CID_DR_LB_Locations:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                DrLocationsSelChange( pInfo );
                return TRUE;
            }
            break;
        }

        case CID_DR_PB_Rules:
        {
            DrEditSelectedLocation( pInfo );
            return TRUE;
        }

        case CID_DR_PB_Properties:
        {
            DrProperties( pInfo );
            DrPopulatePasswordField( pInfo, FALSE, FALSE );
            return TRUE;
        }

        case CID_DR_RB_SaveForMe:
        case CID_DR_RB_SaveForEveryone:
        {
            DrPopulatePasswordField( pInfo, FALSE, FALSE );
            DrPopulateIdentificationFields( pInfo, (wId == CID_DR_RB_SaveForMe));
            return TRUE;
        }

        case IDOK:
        case CID_DR_PB_DialConnect:
        {
            DrSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        case CID_DR_PB_Cancel:
        {
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }

        case IDHELP:
        case CID_DR_PB_Help:
        {
            TCHAR* pszCmdLine;

            // Help button now invokes troubleshooting help per bug 210247.
            //
            pszCmdLine = PszFromId( g_hinstDll, SID_DialerHelpCmdLine );
            if (pszCmdLine)
            {
                STARTUPINFO sInfo;
                PROCESS_INFORMATION pInfo;

                ZeroMemory( &sInfo, sizeof(sInfo) );
                sInfo.cb = sizeof(sInfo);
                ZeroMemory( &pInfo, sizeof(pInfo) );
                CreateProcess(
                    NULL, pszCmdLine, NULL, NULL, FALSE,
                    0, NULL, NULL, &sInfo, &pInfo );

                Free( pszCmdLine );
            }
            return TRUE;
        }
    }

    return FALSE;
}


BOOL CALLBACK
DrClbNumbersEnumChildProc(
    IN HWND hwnd,
    IN LPARAM lparam )

    // Standard Windows EnumChildProc routine called back for each child
    // window of the 'ClbNumbers' control.
    //
{
    DRINFO* pInfo;
    LONG lId;

    pInfo = (DRINFO* )lparam;

    // There only one child window and it's the edit window.
    //
    pInfo->hwndClbNumbersEb = hwnd;

    return FALSE;
}


BOOL CALLBACK
DrClbNumbersEnumWindowsProc(
    IN HWND hwnd,
    IN LPARAM lparam )

    // Standard Windows EnumWindowsProc routine called back for each top-level
    // window.
    //
{
    RECT rect;

    GetWindowRect( hwnd, &rect );
    if (rect.right - rect.left == DR_BOGUSWIDTH)
    {
        // This window has the unusual bogus width, so it must be the
        // list-box.
        //
        ((DRINFO* )lparam)->hwndClbNumbersLb = hwnd;
        return FALSE;
    }

    return TRUE;
}


LRESULT APIENTRY
DrClbNumbersEbWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed combo-box edit-box child window procedure providing "manual
    // edit" behavior.
    //
    // Return value depends on message type.
    //
{
    DRINFO* pInfo;

    switch (unMsg)
    {
        case WM_SETTEXT:
        {
            // Prevent the combo-box from setting the contents of the edit box
            // by discarding the request and reporting success.
            //
            return TRUE;
        }

        case DR_WM_SETTEXT:
        {
            // Convert our private SETTEXT to a regular SETTEXT and pass it on
            // to the edit control.
            //
            unMsg = WM_SETTEXT;
            break;
        }
    }

    // Call the previous window procedure for everything else.
    //
    pInfo = (DRINFO* )GetProp( hwnd, g_contextId );
    ASSERT( pInfo );

    return
        CallWindowProc(
            pInfo->wndprocClbNumbersEb, hwnd, unMsg, wParam, lParam );
}


LRESULT APIENTRY
DrClbNumbersLbWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed combo-box list-box child window procedure providing "manual
    // edit" behavior.
    //
    // Return value depends on message type.
    //
{
    DRINFO* pInfo;

    pInfo = (DRINFO* )GetProp( hwnd, g_contextId );
    ASSERT( pInfo );

    switch (unMsg)
    {
        case LB_FINDSTRINGEXACT:
        case LB_FINDSTRING:
        {
            // This prevents the edit-box "completion" behavior of the
            // combo-box, i.e. it prevents the edit-box contents from being
            // extended to the closest match in the list.
            //
            return -1;
        }

        case LB_SETCURSEL:
        case LB_SETTOPINDEX:
        {
            // Prevent the "match selection to edit-box" combo-box behavior by
            // discarding any attempts to set the selection or top index to
            // anything other than what we set.
            //
            if (wParam != pInfo->pLink->iLastSelectedPhone)
            {
                return -1;
            }
            break;
        }
    }

    // Call the previous window procedure for everything else.
    //
    return
        CallWindowProc(
            pInfo->wndprocClbNumbersLb, hwnd, unMsg, wParam, lParam );
}


VOID
DrEditSelectedLocation(
    IN DRINFO* pInfo )

    // Called when the Dialing Rules button is pressed.  'PInfo' is the dialog
    // context.
    //
{
    DWORD dwErr;
    INT iSel;
    DRNUMBERSITEM* pItem;

    TRACE( "DrEditSelectedLocation" );

    // Look up the phone number information for the selected number.
    //
    pItem = (DRNUMBERSITEM* )ComboBox_GetItemDataPtr(
        pInfo->hwndClbNumbers, ComboBox_GetCurSel( pInfo->hwndClbNumbers ) );
    ASSERT( pItem );

    if(NULL == pItem)
    {   
        return;
    }
    
    ASSERT( pItem->pPhone->fUseDialingRules );

    // Popup TAPI dialing rules dialog.
    //
    dwErr = TapiLocationDlg(
        g_hinstDll,
        &pInfo->hlineapp,
        pInfo->hwndDlg,
        pItem->pPhone->dwCountryCode,
        pItem->pPhone->pszAreaCode,
        pItem->pPhone->pszPhoneNumber,
        0 );

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadTapiInfo, dwErr, NULL );
    }

    // Might have changed the location list so re-fill it.
    //
    DrFillLocationList( pInfo );
}


DWORD
DrFillLocationList(
    IN DRINFO* pInfo )

    // Fills the dropdown list of locations and sets the current selection.
    //
    // Returns 0 if successful, or an error code.
    //
{
    DWORD dwErr;
    LOCATION* pLocations;
    LOCATION* pLocation;
    DWORD cLocations;
    DWORD dwCurLocation;
    DWORD i;

    TRACE( "DrFillLocationList" );

    ComboBox_ResetContent( pInfo->hwndLbLocations );

    pLocations = NULL;
    cLocations = 0;
    dwCurLocation = 0xFFFFFFFF;
    dwErr = GetLocationInfo(
        g_hinstDll, &pInfo->hlineapp,
        &pLocations, &cLocations, &dwCurLocation );
    if (dwErr != 0)
    {
        return dwErr;
    }

    for (i = 0, pLocation = pLocations;
         i < cLocations;
         ++i, ++pLocation)
    {
        INT iItem;

        iItem = ComboBox_AddItem(
            pInfo->hwndLbLocations, pLocation->pszName,
            (VOID* )UlongToPtr(pLocation->dwId ));

        if (pLocation->dwId == dwCurLocation)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbLocations, iItem );
        }
    }

    FreeLocationInfo( pLocations, cLocations );
    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbLocations );

    return dwErr;
}


VOID
DrFillNumbersList(
    IN DRINFO* pInfo )

    // Fill the "Dial" combo-box with phone numbers and comments, and
    // re-select the selected item in the list, or if none, the last one
    // selected as specified in the PBLINK.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    PBPHONE* pPhone;
    INT cItems;
    INT i;

    DrFreeClbNumbers( pInfo );

    for (pNode = DtlGetFirstNode( pInfo->pLink->pdtllistPhones ), i = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++i)
    {
        TCHAR szBuf[ RAS_MaxPhoneNumber + RAS_MaxDescription + 3 + 1 ];
        DRNUMBERSITEM* pItem;

        pPhone = (PBPHONE* )DtlGetData( pNode );
        ASSERT( pPhone );

        pItem = Malloc( sizeof(DRNUMBERSITEM) );
        if (!pItem)
        {
            break;
        }

        // Build the "<number> - <comment>" string in 'szBuf'.
        //
        pItem->pszNumber =
            LinkPhoneNumberFromParts(
                g_hinstDll, &pInfo->hlineapp,
                pInfo->pArgs->pDinfo->pUser,  pInfo->pArgs->pDinfo->pEntry,
                pInfo->pLink, i, NULL, FALSE );

        if (!pItem->pszNumber)
        {
            // Should not happen.
            //
            Free( pItem );
            break;
        }

        lstrcpyn( szBuf, pItem->pszNumber,  RAS_MaxPhoneNumber);
        if (pPhone->pszComment && !IsAllWhite( pPhone->pszComment ))
        {
            DWORD dwLen, dwSize = sizeof(szBuf) / sizeof(TCHAR);
            
            lstrcat( szBuf, TEXT(" - ") );
            dwLen = lstrlen(szBuf) + 1;
            lstrcpyn( 
                szBuf + (dwLen - 1), 
                pPhone->pszComment,
                dwSize - dwLen );
        }

        pItem->pPhone = pPhone;

        ComboBox_AddItem( pInfo->hwndClbNumbers, szBuf, pItem );
    }

    // Make the selection and trigger the update of the edit-box to the number
    // without the comment.
    //
    cItems = ComboBox_GetCount( pInfo->hwndClbNumbers );
    if (cItems > 0)
    {
        if ((INT )pInfo->pLink->iLastSelectedPhone >= cItems)
        {
            pInfo->pLink->iLastSelectedPhone = 0;
        }

        ListBox_SetTopIndex(
            pInfo->hwndClbNumbersLb, pInfo->pLink->iLastSelectedPhone );
        ComboBox_SetCurSelNotify(
            pInfo->hwndClbNumbers, pInfo->pLink->iLastSelectedPhone );
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndClbNumbers );
}


VOID
DrFreeClbNumbers(
    IN DRINFO* pInfo )

    // Free up the displayable number string associated with each entry of the
    // phone number combo-box leaving the box empty.
    //
{
    DRNUMBERSITEM* pItem;

    while (pItem = ComboBox_GetItemDataPtr( pInfo->hwndClbNumbers, 0 ))
    {
        ComboBox_DeleteString( pInfo->hwndClbNumbers, 0 );
        Free( pItem->pszNumber );
        Free( pItem );
    }
}


DWORD
DrFindAndSubclassClbNumbersControls(
    IN DRINFO* pInfo )

    // Locate and sub-class the edit-box and list-box child controls of the
    // phone number combo-box.  This is necessary to get "manual edit"
    // behavior, i.e. prevent the combo-box from automatically updating the
    // edit box at various times.  We need this because the phone number
    // comments are to be appended in the list, but not in the edit box.
    // 'PInfo' is the dialog context.
    //
    // Returns 0 if successful or an error code.
    //
{
    DWORD dxOld;

    // Find the edit window which is simply a child enumeration.
    //
    EnumChildWindows(
        pInfo->hwndClbNumbers,
        DrClbNumbersEnumChildProc,
        (LPARAM)pInfo );

    if (!pInfo->hwndClbNumbersEb)
    {
        return ERROR_NOT_FOUND;
    }

    // Find the list window which *sigh* doesn't show up in the child
    // enumeration though it has WS_CHILD style because Windows sets it's
    // parent window to NULL after it is created.  To find it, we set the
    // dropped width to an unusual bogus value, then search all windows for
    // one with that width.
    //
    dxOld = (DWORD )SendMessage(
        pInfo->hwndClbNumbers, CB_GETDROPPEDWIDTH, 0, 0 );
    SendMessage( pInfo->hwndClbNumbers,
        CB_SETDROPPEDWIDTH, (WPARAM )DR_BOGUSWIDTH, 0 );
    EnumWindows( DrClbNumbersEnumWindowsProc, (LPARAM)pInfo );
    SendMessage( pInfo->hwndClbNumbers,
        CB_SETDROPPEDWIDTH, (WPARAM )dxOld, 0 );

    if (!pInfo->hwndClbNumbersLb)
    {
        return ERROR_NOT_FOUND;
    }

    // Subclass the windows after associating the dialog context with them for
    // retrieval in the WndProcs.
    //
    SetProp( pInfo->hwndClbNumbersEb, g_contextId, pInfo );
    SetProp( pInfo->hwndClbNumbersLb, g_contextId, pInfo );

    pInfo->wndprocClbNumbersEb =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndClbNumbersEb,
            GWLP_WNDPROC, (ULONG_PTR )DrClbNumbersEbWndProc );

    pInfo->wndprocClbNumbersLb =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndClbNumbersLb,
            GWLP_WNDPROC, (ULONG_PTR )DrClbNumbersLbWndProc );


    return 0;
}

void
DrEnsureNetshellLoaded (
    IN DRINFO* pInfo)
{
    // Load the netshell utilities interface.  The interface is freed in PeTerm.
    //
    if (!pInfo->pNetConUtilities)
    {
        // Initialize the NetConnectionsUiUtilities
        //
        HrCreateNetConnectionUtilities( &pInfo->pNetConUtilities );
    }
}

BOOL
DrInit(
    IN HWND hwndDlg,
    IN DRARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DRINFO* pInfo;
    PBENTRY* pEntry;
    BOOL fEnableProperties;

    TRACE( "DrInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pEntry = pArgs->pDinfo->pEntry;

    pInfo->hwndBmDialer = GetDlgItem( hwndDlg, CID_DR_BM_Useless );
    ASSERT( pInfo->hwndBmDialer );

    // Look up control handles.
    //
    if ((pArgs->dwfMode & DR_U) ||
        (pArgs->dwfMode & DR_I))
    {
        pInfo->hwndEbUser = GetDlgItem( hwndDlg, CID_DR_EB_User );
        ASSERT( pInfo->hwndEbUser );

        if (pArgs->dwfMode & DR_U)
        {
            pInfo->hwndEbPw = GetDlgItem( hwndDlg, CID_DR_EB_Password );
            ASSERT( pInfo->hwndEbPw );

            pInfo->hwndCbSavePw = GetDlgItem( hwndDlg, CID_DR_CB_SavePassword );
            ASSERT( pInfo->hwndCbSavePw );
            pInfo->hwndRbSaveForMe = GetDlgItem( hwndDlg, CID_DR_RB_SaveForMe );
            ASSERT( pInfo->hwndRbSaveForMe );
            pInfo->hwndRbSaveForEveryone =
                GetDlgItem( hwndDlg, CID_DR_RB_SaveForEveryone );
            ASSERT( pInfo->hwndRbSaveForEveryone );
        }

        if (pArgs->dwfMode & DR_D)
        {
            pInfo->hwndEbDomain = GetDlgItem( hwndDlg, CID_DR_EB_Domain );
            ASSERT( pInfo->hwndEbDomain );
        }
    }

    if (pArgs->dwfMode & DR_N)
    {
        pInfo->hwndClbNumbers = GetDlgItem( hwndDlg, CID_DR_CLB_Numbers );
        ASSERT( pInfo->hwndClbNumbers );

        if (pArgs->dwfMode & DR_L)
        {
            pInfo->hwndStLocations = GetDlgItem( hwndDlg, CID_DR_ST_Locations );
            ASSERT( pInfo->hwndStLocations );
            pInfo->hwndLbLocations = GetDlgItem( hwndDlg, CID_DR_LB_Locations );
            ASSERT( pInfo->hwndLbLocations );
            pInfo->hwndPbRules = GetDlgItem( hwndDlg, CID_DR_PB_Rules );
            ASSERT( pInfo->hwndPbRules );
        }
    }

    pInfo->hwndPbProperties = GetDlgItem( hwndDlg, CID_DR_PB_Properties );
    ASSERT( pInfo->hwndPbProperties );

    // In location-enabled mode, popup TAPI's "first location" dialog if they
    // are uninitialized.  Typically, this will do nothing.
    //
    if (pArgs->dwfMode & DR_L)
    {
        dwErr = TapiNoLocationDlg( g_hinstDll, &pInfo->hlineapp, hwndDlg );
        if (dwErr != 0)
        {
            // Error here is treated as a "cancel" per bug 288385.
            //
            pArgs->pDinfo->pArgs->dwError = 0;
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    // Set the title.
    //
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];

        if (pArgs->pDinfo->fUnattended)
        {
            pszTitleFormat = PszFromId( g_hinstDll, SID_DR_ReconnectTitle );
        }
        else
        {
            pszTitleFormat = GetText( hwndDlg );
        }

        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pEntry->pszEntryName;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }
    }

    // Change the Dial button to Connect for non-phone devices.
    //
    if (pEntry->dwType != RASET_Phone)
    {
        TCHAR* psz;

        psz = PszFromId( g_hinstDll, SID_ConnectButton );
        if (psz)
        {
            SetWindowText( GetDlgItem( hwndDlg, CID_DR_PB_DialConnect ), psz );
            Free( psz );
        }
    }

    // Initialize credentials section.
    //
    if (pArgs->dwfMode & DR_U)
    {
        ASSERT( !pEntry->fAutoLogon );

        // Fill credential fields with initial values.
        //
        Edit_LimitText( pInfo->hwndEbUser, UNLEN );
        SetWindowText( pInfo->hwndEbUser, pArgs->pDinfo->rdp.szUserName );
        Edit_LimitText( pInfo->hwndEbPw, PWLEN );

        if (pArgs->dwfMode & DR_D)
        {
            Edit_LimitText( pInfo->hwndEbDomain, DNLEN );
            SetWindowText( pInfo->hwndEbDomain, pArgs->pDinfo->rdp.szDomain );
        }

        if (pArgs->pDinfo->pNoUser || pArgs->pDinfo->fDisableSavePw)
        {
            // Can't stash password without a logon context, so hide the
            // checkbox.
            //
            ASSERT( !HaveSavedPw( pArgs->pDinfo )) ;
            EnableWindow( pInfo->hwndCbSavePw, FALSE );
            EnableWindow( pInfo->hwndRbSaveForMe, FALSE );
            EnableWindow( pInfo->hwndRbSaveForEveryone, FALSE );

            // Whistler bug 400714 RAS does not grab password at winlogon time
            // when Connect dialog is displayed
            //
            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pArgs->pDinfo->rdp.szPassword );
            SetWindowText( pInfo->hwndEbPw, pArgs->pDinfo->rdp.szPassword );
            EncodePassword( pArgs->pDinfo->rdp.szPassword );
        }
        else
        {
            // Whistler bug: 195480 Dial-up connection dialog - Number of
            // asterisks does not match the length of the password and causes
            // confusion
            //
            // Init the password character. Default to the round dot if we fail
            // to get it.
            //
            pInfo->szPasswordChar = (WCHAR) SendMessage( pInfo->hwndEbPw,
                                                EM_GETPASSWORDCHAR, 0, 0 );
            if (!pInfo->szPasswordChar)
            {
                pInfo->szPasswordChar = 0x25CF;
            }

            // Init the fonts for the password field
            //
            DrGetFriendlyFont( hwndDlg, TRUE, &(pInfo->hItalicFont) );
            DrGetFriendlyFont( hwndDlg, FALSE, &(pInfo->hNormalFont) );

            // Check "save password" and render the type of saved
            // password.
            //
            Button_SetCheck(
               pInfo->hwndCbSavePw,
               HaveSavedPw( pArgs->pDinfo ));

            if ((!pArgs->pDinfo->fIsPublicPbk) ||
                (!HaveSavedPw( pArgs->pDinfo )))
            {
                // If this is a for-me-only connection or if
                // there is no saved password, then  initialize the 
                // pw save type to save-for-me
                //
                Button_SetCheck( pInfo->hwndRbSaveForMe, TRUE );
            }
            else
            {
                // Check the appropriate radio button
                // Note that a per-user password is always used if
                // both a per-user and global password are saved.
                // Dont check global password if its a per-user connectoid
                //
                Button_SetCheck( 
                    (pArgs->pDinfo->fHaveSavedPwUser)   ?
                        pInfo->hwndRbSaveForMe          :
                        pInfo->hwndRbSaveForEveryone,
                    TRUE);
            }

            DrEnableDisablePwControls( pInfo, HaveSavedPw( pArgs->pDinfo ) );

            // Whistler bug: 195480 Dial-up connection dialog - Number of
            // asterisks does not match the length of the password and causes
            // confusion
            //
            DrPopulatePasswordField( pInfo, TRUE, FALSE );

        }
    }

    if (pArgs->dwfMode & DR_N)
    {
        pInfo->pLinkNode = NULL;
        if (pArgs->pDinfo->pArgs->dwSubEntry > 0)
        {
            // Look up the API caller specified link.
            //
            pInfo->pLinkNode =
                DtlNodeFromIndex(
                    pArgs->pDinfo->pEntry->pdtllistLinks,
                    pArgs->pDinfo->pArgs->dwSubEntry - 1 );
        }

        if (!pInfo->pLinkNode)
        {
            // Look up the default (first) link.
            //
            pInfo->pLinkNode =
                DtlGetFirstNode( pArgs->pDinfo->pEntry->pdtllistLinks );
        }

        ASSERT( pInfo->pLinkNode );
        pInfo->pLink = (PBLINK* )DtlGetData( pInfo->pLinkNode );

        dwErr = DrFindAndSubclassClbNumbersControls( pInfo );
        if (dwErr != 0)
        {
            pArgs->pDinfo->pArgs->dwError = ERROR_NOT_FOUND;
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        // Ignore any "last selected" information when the "try next on fail"
        // flag is set.  New entries will not have "last selected" non-0 in
        // this case but pre-existing entries might, so double-check here.
        // See bug 150958.
        //
        if (pInfo->pLink->fTryNextAlternateOnFail)
        {
            pInfo->pLink->iLastSelectedPhone = 0;
        }

        // Record the initially selected phone number, used to determine
        // whether user has changed the selection.
        //
        pInfo->iFirstSelectedPhone = pInfo->pLink->iLastSelectedPhone;

        DrFillNumbersList( pInfo );

        if (pArgs->dwfMode & DR_L)
        {
            DrFillLocationList( pInfo );
        }
    }

    // danielwe: Bug #222744, scottbri Bug #245310
    // Disable Properties... button if user does not have sufficent rights.
    //
    {
        HRESULT hr;

        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if (hr == RPC_E_CHANGED_MODE)
        {
            hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
        }

        if (hr == S_OK || hr == S_FALSE)
        {
            pInfo->fComInitialized = TRUE;
        }
    }

    fEnableProperties = FALSE;
    DrEnsureNetshellLoaded (pInfo);
    if (NULL != pInfo->pNetConUtilities)
    {
        //For whislter bug 409504           gangz
        //for a VPN double dial scenario,if now it is in the prerequiste dial
        //process, we should use DINFO->pEntryMain->pszPrerequisitePbk to check
        //if it is a publicPhonebook
        //
        BOOL fAllUsers = TRUE;
        
        if( pArgs->pDinfo->fPrerequisiteDial )
        {
            fAllUsers = 
                IsPublicPhonebook(pArgs->pDinfo->pEntryMain->pszPrerequisitePbk);
        }
        else
        {
            fAllUsers = IsPublicPhonebook(pArgs->pDinfo->pszPhonebook);
        }
        
        if (((fAllUsers && INetConnectionUiUtilities_UserHasPermission(
                                        pInfo->pNetConUtilities, 
                                        NCPERM_RasAllUserProperties)) ||
            (!fAllUsers && INetConnectionUiUtilities_UserHasPermission(
                                        pInfo->pNetConUtilities, 
                                        NCPERM_RasMyProperties))) &&
            (NULL == pArgs->pDinfo->pNoUser))
        {
            fEnableProperties = TRUE;
        }

        // We only needed it breifly, release it
        INetConnectionUiUtilities_Release(pInfo->pNetConUtilities);
        pInfo->pNetConUtilities = NULL;
    }

    // stevec: 267157-Allow access at win-login if admin enables.
    //
    if (NULL != pArgs->pDinfo->pNoUser
        && pArgs->pDinfo->pUser->fAllowLogonPhonebookEdits)
    {
        fEnableProperties = TRUE;
    }

    EnableWindow( pInfo->hwndPbProperties, fEnableProperties );

    // The help engine doesn't work at win-logon as it requires a user
    // context, so disable the Help button in that case.  See bug 343030.
    //
    if (pArgs->pDinfo->pNoUser)
    {
        HWND hwndPbHelp;

        hwndPbHelp = GetDlgItem( hwndDlg, CID_DR_PB_Help );
        ASSERT( hwndPbHelp );

        EnableWindow( hwndPbHelp, FALSE );
        ShowWindow( hwndPbHelp, SW_HIDE );
    }

    // Set the bitmap to the low res version if that is appropriate
    //
    // Ignore the error -- it is non-critical
    //
    DrSetBitmap(pInfo);

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        !!(pArgs->pDinfo->pArgs->dwFlags & RASDDFLAG_PositionDlg),
        pArgs->pDinfo->pArgs->xDlg, pArgs->pDinfo->pArgs->yDlg );

    //Add this function for whislter bug  320863    gangz
    //To adjust the bitmap's position and size
    //
    CenterExpandWindowRemainLeftMargin( pInfo->hwndBmDialer,
                                        hwndDlg,
                                        TRUE,
                                        TRUE,
                                        pInfo->hwndEbUser);

    // Adjust the title bar widgets.
    //
    //TweakTitleBar( hwndDlg );
    AddContextHelpButton( hwndDlg );

    return TRUE;
}

VOID
DrLocationsSelChange(
    IN DRINFO* pInfo )

    // Called when a location is selected from the list.  'PInfo' is the
    // dialog context.
    //
{
    DWORD dwErr;
    DWORD dwLocationId;

    TRACE("DuLocationChange");

    // Set global TAPI location based on user's selection.
    //
    dwLocationId = (DWORD )ComboBox_GetItemData(
        pInfo->hwndLbLocations, ComboBox_GetCurSel( pInfo->hwndLbLocations ) );

    dwErr = SetCurrentLocation( g_hinstDll, &pInfo->hlineapp, dwLocationId );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_SaveTapiInfo, dwErr, NULL );
    }

    // Location change may cause changes in built numbers so re-fill the
    // numbers combo-box.
    //
    DrFillNumbersList( pInfo );
}


VOID
DrNumbersSelChange(
    IN DRINFO* pInfo )

    // Called when a phone number is selected from the list.  'PInfo' is the
    // dialog context.
    //
{
    INT iSel;
    BOOL fEnable;
    DRNUMBERSITEM* pItem;

    iSel = ComboBox_GetCurSel( pInfo->hwndClbNumbers );
    if (iSel >= 0)
    {
        if (iSel != (INT )pInfo->pLink->iLastSelectedPhone)
        {
            pInfo->pArgs->pDinfo->pEntry->fDirty = TRUE;
        }
        pInfo->pLink->iLastSelectedPhone = (DWORD )iSel;
    }

    pItem = (DRNUMBERSITEM* )ComboBox_GetItemDataPtr(
        pInfo->hwndClbNumbers, iSel );
    ASSERT( pItem );

    if(NULL == pItem)
    {
        return;
    }

    // Enable/disable the location fields based on whether they are relevant
    // to the selected number.
    //
    if (pInfo->pArgs->dwfMode & DR_L)
    {
        fEnable = pItem->pPhone->fUseDialingRules;
        EnableWindow( pInfo->hwndStLocations, fEnable );
        EnableWindow( pInfo->hwndLbLocations, fEnable );
        EnableWindow( pInfo->hwndPbRules, fEnable );
    }

    DrSetClbNumbersText( pInfo, pItem->pszNumber );
}


DWORD
DrPopulateIdentificationFields(
    IN DRINFO* pInfo,
    IN BOOL fForMe )

    // Updates the identification fields in the dialer
    // UI according to whether the all-user or per-user
    // dialparms should be used.
    //
    
{
    RASDIALPARAMS* prdp, *prdpOld;
    BOOL fUpdate;
    TCHAR pszUser[UNLEN + 1];
    INT iCount;

    prdp = (fForMe) 
        ? &(pInfo->pArgs->pDinfo->rdpu) : &(pInfo->pArgs->pDinfo->rdpg);
    prdpOld = (fForMe) 
        ? &(pInfo->pArgs->pDinfo->rdpg) : &(pInfo->pArgs->pDinfo->rdpu);

    iCount = GetWindowText(
                pInfo->hwndEbUser,
                pszUser, 
                UNLEN + 1);
    if (iCount == 0)
    {
        fUpdate = TRUE;
    }
    else
    {
        if (lstrcmp(prdpOld->szUserName, pszUser) == 0)
        {
            fUpdate = TRUE;
        }
        else
        {
            fUpdate = FALSE;
        }
    }

    if (fUpdate)
    {
        if (pInfo->hwndEbUser && *(prdp->szUserName))
        {
            SetWindowText(pInfo->hwndEbUser, prdp->szUserName);
        }
        if (pInfo->hwndEbDomain && *(prdp->szDomain))
        {
            SetWindowText(pInfo->hwndEbDomain, prdp->szDomain);
        }
    }

    return NO_ERROR;
}

DWORD
DrPopulatePasswordField(
    IN DRINFO* pInfo,
    IN BOOL fInit,
    IN BOOL fDisable )
{
    BOOL fSave, fMeOnly;
    TCHAR* pszFriendly = NULL;

    // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
    // does not match the length of the password and causes confusion
    //
    // Case 1. The user has clicked on the password field. We clear the
    // friendly password and set the font back to normal.
    //
    if (fDisable)
    {
        DrClearFriendlyPassword( pInfo, TRUE );
        return NO_ERROR;
    }

    // Initialze
    //
    fSave = Button_GetCheck( pInfo->hwndCbSavePw );
    fMeOnly = Button_GetCheck( pInfo->hwndRbSaveForMe );
    pszFriendly = PszFromId( g_hinstDll, SID_SavePasswordFrndly );

    // Case 2. Clear the password field if the user a) choose not to save the
    // password and b) has not manually entered a password.
    //
    if ( (!fSave) && !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ) )
    {
        DrClearFriendlyPassword( pInfo, FALSE );
    }

    // Case 3. Show the friendly saved password text if the user a) choose to
    // save the password of himself only and b) there is a per-user password
    // saved and c) the user has not entered a password manually.
    //
    else if ( (fSave) && (fMeOnly) &&
              ((fInit) || ( !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))) )
    {
        // Whistler bug: 288234 When switching back and forth from
        // "I connect" and "Any user connects" password is not
        // caching correctly
        //
        if (pInfo->pArgs->pDinfo->fHaveSavedPwUser)
        {
            DrDisplayFriendlyPassword(pInfo, pszFriendly );
        }
        else
        {
            DrClearFriendlyPassword( pInfo, FALSE );
        }
    }

    // Case 4. Show the friendly saved password text if the user a) choose to
    // save the password for everyone and b) there is a default password saved
    // and c) the user has not entered a password manually.
    //
    else if ( (fSave) && (!fMeOnly) &&
             ((fInit) || ( !DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))) )
    {
        if (pInfo->pArgs->pDinfo->fHaveSavedPwGlobal)
        {
            DrDisplayFriendlyPassword( pInfo, pszFriendly );
        }
        else
        {
            DrClearFriendlyPassword( pInfo, FALSE );
        }
    }

    // Case 5. Show the friendly saved password text if the user a) choose to
    // save the password for everyone or himself and b) there is a
    // corresponding password saved and c) the user has not entered a password
    // manually.
    //
    // This case catches a) when the user is switching between "me" and
    // "everyone" and b) when the user leaves the focus of the password field
    // but hasn't changed the password
    //
    else if ( (fSave) && !GetWindowTextLength( pInfo->hwndEbPw ) &&
              DrIsPasswordStyleEnabled( pInfo->hwndEbPw ) &&
              ((pInfo->pArgs->pDinfo->fHaveSavedPwGlobal && !fMeOnly) ||
               (pInfo->pArgs->pDinfo->fHaveSavedPwUser && fMeOnly)) )
    {
        DrDisplayFriendlyPassword( pInfo, pszFriendly );
    }

    // NT5 bug: 215432, Whistler bug: 364341
    //
    // Whistler bug: 195480 Dial-up connection dialog - Number of asterisks
    // does not match the length of the password and causes confusion
    //
    // Set focus appropiately
    //
    if (fInit)
    {
        if (!GetWindowTextLength( pInfo->hwndEbUser ))
        {
            SetFocus( pInfo->hwndEbUser );
        }
        else if (!GetWindowTextLength( pInfo->hwndEbPw ))
        {
            SetFocus( pInfo->hwndEbPw );

            // This removes the tab stop property from the username field. This
            // is a hack so we can set the focus properly. Tab stop is put back
            // in DrCommand.
            //
            SetWindowLong( pInfo->hwndEbUser, GWL_STYLE,
                GetWindowLong( pInfo->hwndEbUser, GWL_STYLE ) & ~WS_TABSTOP );
        }
        else
        {
            SetFocus( pInfo->hwndEbUser );
        }
    }

    // Clean up
    //
    Free0( pszFriendly );

    return NO_ERROR;
}

VOID
DrProperties(
    IN DRINFO* pInfo )

    // Called when the Properties button is pressed.  'PInfo' is the dialog
    // context.
    //
{
    BOOL fOk;
    RASENTRYDLG info;
    INTERNALARGS iargs;
    DINFO* pDinfo;

    // First, save any entry related changes user has made on the dial dialog.
    //
    DrSave( pInfo );

    // Set up for parameters for call to RasEntryDlg.
    //
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    {
        RECT rect;

        info.dwFlags = RASEDFLAG_PositionDlg;
        GetWindowRect( pInfo->hwndDlg, &rect );
        info.xDlg = rect.left + DXSHEET;
        info.yDlg = rect.top + DYSHEET;
    }

    // The secret hack to share information already loaded with the entry API.
    //
    pDinfo = pInfo->pArgs->pDinfo;
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = pDinfo->pFile;
    iargs.pUser = pDinfo->pUser;
    iargs.pNoUser = pDinfo->pNoUser;
    iargs.fNoUser = !!(pDinfo->pNoUser);

    //For whislter bug 234515 set fDisableFirstConnect to be FALSE
    //
    iargs.fDisableFirstConnect = FALSE;
    info.reserved = (ULONG_PTR )&iargs;

    TRACE( "RasEntryDlg" );
    fOk = RasEntryDlg(
        pDinfo->pszPhonebook, pDinfo->pEntry->pszEntryName, &info );
    TRACE1( "RasEntryDlg=%d", fOk );

    if (fOk)
    {
        DWORD dwErr;

        // Reload when user presses OK on properties since that may change the
        // appearance and content of this dialog.  Must first reset the DINFO
        // context parameters based on the replaced PBENTRY from the property
        // sheet.
        //
        dwErr = FindEntryAndSetDialParams( pInfo->pArgs->pDinfo );
        if (dwErr != 0)
        {
            // Should not happen.
            //
            EndDialog( pInfo->hwndDlg, FALSE );
        }

        pInfo->pArgs->fReload = TRUE;
        EndDialog( pInfo->hwndDlg, FALSE );
    }
}

VOID
DrSave(
    IN DRINFO* pInfo )

    // Saves dialog field contents to RASDIALPARAMS, and if appropriate to LSA
    // secret area or NOUSER output argument.  'PInfo' is the dialog context.
    //
{
    DWORD dwErr;
    RASDIALPARAMS* prdp;
    RASCREDENTIALS rc;
    DINFO* pDinfo;

    pDinfo = pInfo->pArgs->pDinfo;

    if ((pInfo->pArgs->dwfMode & DR_U) ||
        (pInfo->pArgs->dwfMode & DR_I))
    {
        // Save credentials into parameter block to be passed to RasDial.
        //
        prdp = &pDinfo->rdp;
        GetWindowText( pInfo->hwndEbUser, prdp->szUserName, UNLEN + 1 );

        if (pInfo->pArgs->dwfMode & DR_U)
        {
            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded by GetWindowText()
            //
            // Whistler bug: 195480 Dial-up connection dialog - Number of
            // asterisks does not match the length of the password and causes
            // confusion
            //
            if (!DrIsPasswordStyleEnabled( pInfo->hwndEbPw ))
            {
                lstrcpyn( prdp->szPassword, g_pszSavedPasswordToken,
                    g_dwSavedPasswordTokenLength );
            }
            else
            {
                GetWindowText( pInfo->hwndEbPw, prdp->szPassword, PWLEN + 1 );
            }

            SetWindowText( pInfo->hwndEbPw, L"" );
            EncodePassword( prdp->szPassword );
        }

        if (pInfo->pArgs->dwfMode & DR_D)
        {
            GetWindowText( pInfo->hwndEbDomain, prdp->szDomain, DNLEN + 1 );
        }

        ZeroMemory( &rc, sizeof(rc) );
        rc.dwSize = sizeof(rc);
        lstrcpyn( rc.szUserName, prdp->szUserName, UNLEN + 1 );

        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( prdp->szPassword );
        lstrcpyn( rc.szPassword, prdp->szPassword, PWLEN + 1 );
        EncodePassword( prdp->szPassword );

        lstrcpyn( rc.szDomain, prdp->szDomain, DNLEN + 1);

        if (pDinfo->pNoUser)
        {
            // Save credentials into output block for return to caller,
            // typically WinLogon.
            //
            lstrcpyn( pDinfo->pNoUser->szUserName, rc.szUserName, UNLEN + 1 );

            // Whistler bug 254385 encode password when not being used
            // Assumed password was not encoded previously
            //
            lstrcpyn( pDinfo->pNoUser->szPassword, rc.szPassword, PWLEN + 1 );
            EncodePassword( pDinfo->pNoUser->szPassword );

            lstrcpyn( pDinfo->pNoUser->szDomain, rc.szDomain, DNLEN + 1 );
            *(pDinfo->pfNoUserChanged) = TRUE;
        }
        else if (pInfo->pArgs->dwfMode & DR_I)
        {
            // Nothing to do
        }
        else if (!pDinfo->fDisableSavePw)
        {
            BOOL fGlobalCreds = FALSE;
            ASSERT( g_pRasSetCredentials );

            if (Button_GetCheck( pInfo->hwndCbSavePw ))
            {
                rc.dwMask = 0;
                
                // If the user elected to save the credentials for 
                // everybody, then clear any previously saved per-user
                // credentials
                //
                fGlobalCreds = Button_GetCheck( pInfo->hwndRbSaveForEveryone );
                if(     (fGlobalCreds)
                    &&  IsPublicPhonebook(pDinfo->pFile->pszPath))
                {
                    DeleteSavedCredentials(
                        pDinfo,
                        pInfo->hwndDlg,
                        FALSE,
                        TRUE );
                    pDinfo->fHaveSavedPwUser = FALSE;
                    rc.dwMask = RASCM_DefaultCreds;
                }

                // If there is currently no saved per-user password and the user
                // opts to save the password himself, then ask whetehr the global
                // password should be deleted if it exists.
                //
                else if (pDinfo->fHaveSavedPwGlobal && !pDinfo->fHaveSavedPwUser)
                {
                    MSGARGS msgargs;
                    ZeroMemory( &msgargs, sizeof(msgargs) );
                    msgargs.dwFlags = MB_ICONQUESTION | MB_YESNO;

                    // Delete the default credentials if the user answers yes
                    //
                    if (IDYES == 
                       MsgDlg(pInfo->hwndDlg, SID_DR_GlobalPassword, &msgargs))
                    {
                        DeleteSavedCredentials(
                            pDinfo,
                            pInfo->hwndDlg,
                            TRUE,
                            TRUE );
                        pDinfo->fHaveSavedPwGlobal = FALSE;
                    }
                }

                // User chose to save password.  Cache username, password, and
                // domain.
                //
                rc.dwMask |= RASCM_UserName | 
                             RASCM_Password | RASCM_Domain;

                TRACE( "RasSetCredentials(u|p|d,FALSE)" );
                dwErr = g_pRasSetCredentials(
                    pDinfo->pFile->pszPath, pDinfo->pEntry->pszEntryName,
                    &rc, FALSE );
                TRACE1( "RasSetCredentials=%d", dwErr );
                
                if (dwErr != 0)
                {
                    ErrorDlg( pInfo->hwndDlg, SID_OP_CachePw,  dwErr, NULL );
                }
                else
                {
                    if (fGlobalCreds)
                    {
                        pDinfo->fHaveSavedPwGlobal = TRUE;
                    }
                    else
                    {
                        // Whistler bug: 288234 When switching back and forth
                        // from "I connect" and "Any user connects" password is
                        // not caching correctly
                        //
                        pDinfo->fHaveSavedPwUser = TRUE;
                    }
                }
            }
            else
            {
                // Delete the global credentials.
                //
                // Note that we have to delete the global identity 
                // as well because we do not support deleting 
                // just the global password.  This is so that 
                // RasSetCredentials can emulate RasSetDialParams.
                //
                DeleteSavedCredentials(
                    pDinfo,
                    pInfo->hwndDlg,
                    TRUE,
                    TRUE );

                // Delete the password saved per-user.  Keep the user name
                // and domain saved, however.
                //
                DeleteSavedCredentials(
                    pDinfo,
                    pInfo->hwndDlg,
                    FALSE,
                    FALSE );

                pDinfo->fHaveSavedPwUser = FALSE;
                pDinfo->fHaveSavedPwGlobal = FALSE;
            }
        }

        ZeroMemory( rc.szPassword, sizeof(rc.szPassword) );
    }

    if (pInfo->pArgs->dwfMode & DR_N)
    {
        TCHAR* pszNumber;
        TCHAR* pszOriginal;
        DTLNODE* pPhoneNode;
        DRNUMBERSITEM* pItem;
        PBPHONE* pPhone;
        BOOL fUserChange;

        pszNumber = GetText( pInfo->hwndClbNumbers );
        if (!pszNumber)
        {
            return;
        }

        pItem = (DRNUMBERSITEM* )ComboBox_GetItemDataPtr(
            pInfo->hwndClbNumbers, pInfo->pLink->iLastSelectedPhone );
        if (pItem)
        {
            pszOriginal = pItem->pszNumber;
        }
        else
        {
            pszOriginal = TEXT("");
        }

        if (lstrcmp( pszNumber, pszOriginal ) != 0
            || (pInfo->pLink->iLastSelectedPhone != pInfo->iFirstSelectedPhone))
        {
            MSGARGS msgargs;
            BOOL fMultiLink;
            BOOL fSingleNumber;

            // The phone number was edited by user to something not originally
            // on the list OR the user selected a different item on the list.
            //
            fSingleNumber = (DtlGetNodes( pInfo->pLink->pdtllistPhones ) == 1);
            fMultiLink = (DtlGetNodes( pDinfo->pEntry->pdtllistLinks ) > 1);

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2;

            if (fSingleNumber
                && (!fMultiLink || pDinfo->pEntry->fSharedPhoneNumbers)
                    && MsgDlg( pInfo->hwndDlg,
                           SID_SavePreview, &msgargs ) == IDYES)
            {
                // User says he wants to make the change permanent.
                //
                pDinfo->pEntry->fDirty = TRUE;

                if (pItem)
                {
                    pPhone = pItem->pPhone;
                    Free0( pItem->pszNumber );
                    pItem->pszNumber = StrDup( pszNumber );
                }
                else
                {
                    pPhoneNode = CreatePhoneNode();
                    if (pPhoneNode)
                    {
                        DtlAddNodeFirst(
                            pInfo->pLink->pdtllistPhones, pPhoneNode );
                        pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
                    }
                }

                if (pItem)
                {
                    ASSERT( pItem->pPhone );
                    Free0( pPhone->pszPhoneNumber );
                    pPhone->pszPhoneNumber = StrDup( pszNumber );
                    pPhone->fUseDialingRules = FALSE;

                    if (fMultiLink)
                    {
                        DTLNODE* pNode;

                        for (pNode = DtlGetFirstNode(
                                 pDinfo->pEntry->pdtllistLinks );
                             pNode;
                             pNode = DtlGetNextNode( pNode ))
                        {
                            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                            ASSERT( pLink );
                            ASSERT( pLink->fEnabled );
                            CopyLinkPhoneNumberInfo( pNode, pInfo->pLinkNode );
                        }
                    }
                }
            }

            fUserChange = TRUE;
        }
        else
        {
            fUserChange = FALSE;
        }

        if (fUserChange || !pInfo->pLink->fTryNextAlternateOnFail)
        {
            if (!*pszNumber)
            {
                TCHAR* psz;

                // We have a problem when user edits in an empty string,
                // because the RasDial API does not accept an empty override
                // phone number.  Convert it to a single blank string in this
                // case, which is as good as we can do.  If user really needs
                // to dial an empty string they can enter one as the entry's
                // permanent phone number.  See bug 179561.
                //
                psz = StrDup( TEXT(" ") );
                if (psz)
                {
                    Free( pszNumber );
                    pszNumber = psz;
                }
            }

            // Set the override phone number to what user typed or selected.
            //
            lstrcpyn( 
                pDinfo->rdp.szPhoneNumber, 
                pszNumber,
                RAS_MaxPhoneNumber + 1);
        }

        Free( pszNumber );
    }

    if (pDinfo->pEntry->fDirty)
    {
        // Write the new phone number and/or "last selected phone number" to
        // the phonebook.
        //
        dwErr = WritePhonebookFile( pDinfo->pFile, NULL );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook, dwErr, NULL );
        }
    }
}

DWORD
DrSetBitmap(
    IN DRINFO* pInfo)

    // Set the appropriate bitmap for this dialer.
    //
{
    DWORD dwErr = NO_ERROR;
    HBITMAP hbmNew = NULL;
    HDC hdc = NULL;
    INT iDepth = 0;

    do
    {
        if (pInfo->hwndBmDialer == NULL)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    
        // Get the device context for the window
        //
        hdc = GetDC( pInfo->hwndBmDialer );
        if (hdc == NULL)
        {
            dwErr = GetLastError();
            break;
        }

        // If the color depth >= 8bit, the current bitmap
        // is fine (high res is default)
        //
        iDepth = GetDeviceCaps(hdc, NUMCOLORS);
        if ( (iDepth == -1) || (iDepth == 256) )
        {
            dwErr = NO_ERROR;
            break;
        }

        // Load in the low-res bitmap
        //
        hbmNew = LoadBitmap(g_hinstDll, MAKEINTRESOURCE( BID_Dialer ));
        if (hbmNew == NULL)
        {
            dwErr = GetLastError();
            break;
        }

        // Set the low-res bitmap
        //
        pInfo->hbmOrig = (HBITMAP)
            SendMessage( 
                pInfo->hwndBmDialer, 
                STM_SETIMAGE, 
                IMAGE_BITMAP, 
                (LPARAM )hbmNew );
    
    } while (FALSE);

    // Cleanup
    //
    {
        if (hdc)
        {
            ReleaseDC(pInfo->hwndBmDialer, hdc);
        }
    }
    
    return dwErr;
}

VOID
DrSetClbNumbersText(
    IN DRINFO* pInfo,
    IN TCHAR* pszText )

    // Set the text of the 'ClbNumbers' edit box to 'pszText'.  See
    // DrClbNumbersEbWndProc.  'PInfo' is the dialog context.
    //
{
    ASSERT( pInfo->hwndClbNumbersEb );

    SendMessage( pInfo->hwndClbNumbersEb, DR_WM_SETTEXT, 0, (LPARAM )pszText );
}


VOID
DrTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DRINFO* pInfo = (DRINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    HBITMAP hbmNew = NULL;

    TRACE( "DrTerm" );

    if (pInfo)
    {
        // Note: Don't use 'pInfo->pLinkNode' or 'pInfo->pLink' here as they
        //       are not currently restored prior to exit for post-Property
        //       button reloading.
        //
        if (pInfo->hwndClbNumbers)
        {
            DrFreeClbNumbers( pInfo );

            if (pInfo->wndprocClbNumbersEb)
            {
                SetWindowLongPtr( pInfo->hwndClbNumbersEb,
                    GWLP_WNDPROC, (ULONG_PTR )pInfo->wndprocClbNumbersEb );
            }

            if (pInfo->wndprocClbNumbersLb)
            {
                SetWindowLongPtr( pInfo->hwndClbNumbersLb,
                    GWLP_WNDPROC, (ULONG_PTR )pInfo->wndprocClbNumbersLb );
            }
        }

        // Whistler bug: 195480 Dial-up connection dialog - Number of
        // asterisks does not match the length of the password and causes
        // confusion
        //
        if (pInfo->hItalicFont)
        {
            DeleteObject( pInfo->hItalicFont );
        }

        if (pInfo->hNormalFont)
        {
            DeleteObject( pInfo->hNormalFont );
        }

        if (pInfo->fComInitialized)
        {
            CoUninitialize();
        }

        // Clean up the low-res bitmap if appropriate
        //
        if ( pInfo->hbmOrig )
        {
            hbmNew = (HBITMAP)
                SendMessage( 
                    pInfo->hwndBmDialer, 
                    STM_SETIMAGE, 
                    IMAGE_BITMAP, 
                    (LPARAM ) pInfo->hbmOrig );
                    
            if (hbmNew)
            {
                DeleteObject(hbmNew);
            }
        }

        Free( pInfo );
    }
}


//----------------------------------------------------------------------------
// Projection Result dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
ProjectionResultDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszLines,
    OUT BOOL* pfDisableFailedProtocols )

    // Popup the Projection Result dialog.  'HwndOwner' is the owning window.
    // 'PszLines' is the status line text to display.  See DpProjectionError.
    // 'DwfDisableFailedProtocols' indicates user chose to disable the failed
    // protocols.
    //
    // Returns true if user chooses to redial or lets it timeout, false if
    // cancels.
    //
{
    INT_PTR nStatus;
    PRARGS args;

    TRACE( "ProjectionResultDlg" );

    args.pszLines = pszLines;
    args.pfDisableFailedProtocols = pfDisableFailedProtocols;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_PR_ProjectionResult ),
            hwndOwner,
            PrDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
PrDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Projection Result dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "PrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return PrInit( hwnd, (PRARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwPrHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return PrCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
PrCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "PrCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        case IDCANCEL:
        {
            BOOL fCb;
            BOOL* pfDisable;

            TRACE1( "%s pressed", (wId==IDOK) ? "OK" : "Cancel" );

            fCb = IsDlgButtonChecked( hwnd, CID_PR_CB_DisableProtocols );
            pfDisable = (BOOL* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pfDisable );
            *pfDisable = fCb;
            EndDialog( hwnd, (wId == IDOK) );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
PrInit(
    IN HWND hwndDlg,
    IN PRARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    HWND hwndStText;
    HWND hwndPbAccept;
    HWND hwndPbHangUp;
    HWND hwndCbDisable;

    TRACE( "PrInit" );

    hwndStText = GetDlgItem( hwndDlg, CID_PR_ST_Text );
    ASSERT( hwndStText );
    hwndPbAccept = GetDlgItem( hwndDlg, IDOK );
    ASSERT( hwndPbAccept );
    hwndPbHangUp = GetDlgItem( hwndDlg, IDCANCEL );
    ASSERT( hwndPbHangUp );
    hwndCbDisable = GetDlgItem( hwndDlg, CID_PR_CB_DisableProtocols );
    ASSERT( hwndCbDisable );

    {
        TCHAR szBuf[ 1024 ];
        TCHAR* psz;

        // Build the message text.
        //
        szBuf[ 0 ] = TEXT('\0');
        psz = PszFromId( g_hinstDll, SID_ProjectionResult1 );
        if (psz)
        {
            lstrcat( szBuf, psz );
            Free( psz );
        }
        lstrcat( szBuf, pArgs->pszLines );
        psz = PszFromId( g_hinstDll, SID_ProjectionResult2 );
        if (psz)
        {
            lstrcat( szBuf, psz );
            Free( psz );
        }

        // Load the text into the static control, then stretch the window to a
        // vertical size appropriate for the text.
        //
        {
            HDC hdc;
            RECT rect;
            RECT rectNew;
            HFONT hfont;
            LONG dyGrow;

            SetWindowText( hwndStText, szBuf );
            GetClientRect( hwndStText, &rect );
            hdc = GetDC( hwndStText );

            if(NULL != hdc)
            {

                hfont = (HFONT )SendMessage( hwndStText, WM_GETFONT, 0, 0 );
                if (hfont)
                    SelectObject( hdc, hfont );

                rectNew = rect;
                DrawText( hdc, szBuf, -1, &rectNew,
                    DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX );
                ReleaseDC( hwndStText, hdc );
            }

            dyGrow = rectNew.bottom - rect.bottom;
            ExpandWindow( hwndDlg, 0, dyGrow );
            ExpandWindow( hwndStText, 0, dyGrow );
            SlideWindow( hwndPbAccept, hwndDlg, 0, dyGrow );
            SlideWindow( hwndPbHangUp, hwndDlg, 0, dyGrow );
            SlideWindow( hwndCbDisable, hwndDlg, 0, dyGrow );
        }
    }

    // Save address of caller's BOOL as the dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pArgs->pfDisableFailedProtocols );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Display the finished window above all other windows.  The window
    // position is set to "topmost" then immediately set to "not topmost"
    // because we want it on top but not always-on-top.  Always-on-top alone
    // is incredibly annoying, e.g. it is always on top of the on-line help if
    // user presses the Help button.
    //
    SetWindowPos(
        hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    ShowWindow( hwndDlg, SW_SHOW );

    SetWindowPos(
        hwndDlg, HWND_NOTOPMOST, 0, 0, 0, 0,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE );

    return TRUE;
}


//----------------------------------------------------------------------------
// Retry Authentication dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
RetryAuthenticationDlg(
    IN HWND hwndOwner,
    IN DINFO* pDinfo )

    // Pops up the retry authentication dialog.  'PDinfo' is the dial dialog
    // common context.
    //
    // Returns true if user presses OK, false if Cancel or an error occurs.
    //
{
    INT_PTR nStatus;

    TRACE( "RetryAuthenticationDlg" );

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_UA_RetryAuthenticationUD ),
            hwndOwner,
            UaDlgProc,
            (LPARAM )pDinfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (BOOL )nStatus;
}


INT_PTR CALLBACK
UaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the User Authentication dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "UaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return UaInit( hwnd, (DINFO* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwUaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            UAINFO* pInfo = (UAINFO* )GetWindowLongPtr( hwnd, DWLP_USER );

            if (!pInfo)
            {
                // This happened in stress one night.  Don't understand how
                // unless it was a WinUser bug or something.  Anyhow, this
                // avoids an AV in such case.
                //
                break;
            }

            return UaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            UaTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
UaCommand(
    IN UAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "UaCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_UA_EB_UserName:
        {
            if (pInfo->fAutoLogonPassword && wNotification == EN_CHANGE)
            {
                // User's changing the username in auto-logon retry mode,
                // which means we have to admit we don't really have the text
                // password and force him to re-enter it.
                //
                pInfo->fAutoLogonPassword = FALSE;
                SetWindowText( pInfo->hwndEbPassword, TEXT("") );
            }
            break;
        }

        case CID_UA_EB_Password:
        {
            if (wNotification == EN_CHANGE)
            {
                pInfo->fAutoLogonPassword = FALSE;
            }
            break;
        }

        case IDOK:
        {
            UaSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
UaInit(
    IN HWND   hwndDlg,
    IN DINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    UAINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "UaInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->fDomain = TRUE;

    pInfo->hwndEbUserName = GetDlgItem( hwndDlg, CID_UA_EB_UserName );
    ASSERT( pInfo->hwndEbUserName );
    pInfo->hwndEbPassword = GetDlgItem( hwndDlg, CID_UA_EB_Password );
    ASSERT( pInfo->hwndEbPassword );
    if (pInfo->fDomain)
    {
        pInfo->hwndEbDomain = GetDlgItem( hwndDlg, CID_UA_EB_Domain );
        ASSERT( pInfo->hwndEbDomain );
    }
    pInfo->hwndCbSavePw = GetDlgItem( hwndDlg, CID_UA_CB_SavePassword );
    ASSERT( pInfo->hwndCbSavePw );

    pEntry = pArgs->pEntry;

    // Set the title.
    //
    {
        TCHAR* pszTitleFormat;
        TCHAR* pszTitle;
        TCHAR* apszArgs[ 1 ];

        pszTitleFormat = GetText( hwndDlg );
        if (pszTitleFormat)
        {
            apszArgs[ 0 ] = pEntry->pszEntryName;
            pszTitle = NULL;

            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING
                    | FORMAT_MESSAGE_ALLOCATE_BUFFER
                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                pszTitleFormat, 0, 0, (LPTSTR )&pszTitle, 1,
                (va_list* )apszArgs );

            Free( pszTitleFormat );

            if (pszTitle)
            {
                SetWindowText( hwndDlg, pszTitle );
                LocalFree( pszTitle );
            }
        }
    }

    // Fill edit fields with initial values.
    //
    Edit_LimitText( pInfo->hwndEbUserName, UNLEN );
    Edit_LimitText( pInfo->hwndEbPassword, PWLEN );
    if (pInfo->fDomain)
    {
        Edit_LimitText( pInfo->hwndEbDomain, DNLEN );
    }

    {
        BOOL fUserNameSet = FALSE;
        BOOL fPasswordSet = FALSE;

        if (pEntry->fAutoLogon && !pInfo->pArgs->pNoUser)
        {
            // On the first retry use the logged on user's name.  Act like the
            // user's password is in the edit box.  If he changes the username
            // or password we'll have to admit we don't have it, but he'll
            // probably just change the domain.
            //
            if (pArgs->rdp.szUserName[ 0 ] == TEXT('\0'))
            {
                SetWindowText( pInfo->hwndEbUserName, GetLogonUser() );
                fUserNameSet = TRUE;
            }

            if (pArgs->rdp.szPassword[ 0 ] == TEXT('\0'))
            {
                SetWindowText( pInfo->hwndEbPassword, TEXT("********") );
                pInfo->fAutoLogonPassword = TRUE;
                fPasswordSet = TRUE;
            }
        }

        if (!fUserNameSet)
        {
            SetWindowText( pInfo->hwndEbUserName, pArgs->rdp.szUserName );
        }

        if (!fPasswordSet)
        {
            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pArgs->rdp.szPassword );
            SetWindowText( pInfo->hwndEbPassword, pArgs->rdp.szPassword );
            EncodePassword( pArgs->rdp.szPassword );
        }

        if (pInfo->fDomain)
        {
            SetWindowText( pInfo->hwndEbDomain, pArgs->rdp.szDomain );
        }
    }

    if (pArgs->pNoUser || pArgs->fDisableSavePw)
    {
        // Can't stash password without a logon context, so hide the checkbox.
        //
        ASSERT( !HaveSavedPw( pArgs ) );
        EnableWindow( pInfo->hwndCbSavePw, FALSE );
        ShowWindow( pInfo->hwndCbSavePw, SW_HIDE );
    }
    else
    {
        // Check "save  password" if a password was previously  cached.  Maybe
        // he changed the password while on the LAN.
        //
        Button_SetCheck( pInfo->hwndCbSavePw, HaveSavedPw( pArgs ) );
    }

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        (pArgs->pArgs->dwFlags & RASDDFLAG_PositionDlg),
        pArgs->pArgs->xDlg, pArgs->pArgs->yDlg );
    SetForegroundWindow( hwndDlg );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Set focus to the empty username or empty password, or if both are
    // present to the domain if auto-logon or the password if not.
    //
    if (Edit_GetTextLength( pInfo->hwndEbUserName ) == 0)
    {
        Edit_SetSel( pInfo->hwndEbUserName, 0, -1 );
        SetFocus( pInfo->hwndEbUserName );
    }
    else if (Edit_GetTextLength( pInfo->hwndEbPassword ) == 0
             || !pEntry->fAutoLogon
             || !pInfo->fDomain)
    {
        Edit_SetSel( pInfo->hwndEbPassword, 0, -1 );
        SetFocus( pInfo->hwndEbPassword );
    }
    else
    {
        ASSERT( pInfo->fDomain );
        Edit_SetSel( pInfo->hwndEbDomain, 0, -1 );
        SetFocus( pInfo->hwndEbDomain );
    }

    // Hide the Dial Progress dialog.
    //
    SetOffDesktop( GetParent( hwndDlg ), SOD_MoveOff, NULL );

    return FALSE;
}


VOID
UaSave(
    IN UAINFO* pInfo )

    // Called when the OK button is pressed.
    //
    // Returns true if user presses OK, false if Cancel or an error occurs.
    //
{
    DWORD dwErr;
    PBENTRY* pEntry;
    BOOL fSavePw;
    RASDIALPARAMS* prdp;
    RASCREDENTIALS rc;

    TRACE( "UaSave" );

    prdp = &pInfo->pArgs->rdp;
    GetWindowText( pInfo->hwndEbUserName, prdp->szUserName, UNLEN + 1 );

    // Whistler bug 254385 encode password when not being used
    // Assumed password was not encoded by GetWindowText()
    //
    GetWindowText( pInfo->hwndEbPassword, prdp->szPassword, PWLEN + 1 );
    EncodePassword( prdp->szPassword );
    if (pInfo->fDomain)
    {
        GetWindowText( pInfo->hwndEbDomain, prdp->szDomain, DNLEN + 1 );
        //
        //if the Domain is not empty, set the "include Windows Logon Domain check box on Option Tab" 
        //        for bug  167229 whistler
        //
        if ( ( 0 < lstrlen ( prdp->szDomain ) ) && (!pInfo->pArgs->pEntry->fPreviewDomain ))
        {
            pInfo->pArgs->pEntry->fPreviewDomain = TRUE;
            pInfo->pArgs->pEntry->fDirty = TRUE;
            dwErr = WritePhonebookFile( pInfo->pArgs->pFile, NULL );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook, dwErr, NULL );
            }
        }
    }

    pEntry = pInfo->pArgs->pEntry;
    if (pEntry->fAutoLogon && !pInfo->pArgs->pNoUser)
    {
        if (pInfo->fAutoLogonPassword)
        {
            // User did not change username or password, so continue to
            // retrieve logon username and password credentials.
            //
            TRACE( "Retain auto-logon" );
            prdp->szUserName[ 0 ] = TEXT('\0');
            prdp->szPassword[ 0 ] = TEXT('\0');
        }
        else
        {
            // User changed username and/or password so we can no longer
            // retrieve the logon username and password credentials from the
            // system.  Switch the entry to non-auto-logon mode.
            //
            TRACE( "Disable auto-logon" );
            pEntry->fAutoLogon = FALSE;
            pInfo->pArgs->fResetAutoLogon = TRUE;
        }
    }

    ZeroMemory( &rc, sizeof(rc) );
    rc.dwSize = sizeof(rc);
    lstrcpyn( rc.szUserName, prdp->szUserName, UNLEN + 1 );

    // Whistler bug 254385 encode password when not being used
    // Assumed password was encoded previously
    //
    DecodePassword( prdp->szPassword );
    lstrcpyn( rc.szPassword, prdp->szPassword, PWLEN + 1 );
    EncodePassword( prdp->szPassword );

    lstrcpyn( rc.szDomain, prdp->szDomain, DNLEN + 1 );

    if (pInfo->pArgs->pNoUser)
    {
        lstrcpyn( pInfo->pArgs->pNoUser->szUserName, rc.szUserName, UNLEN + 1 );

        // Whistler bug 254385 encode password when not being used
        // Assumed password was not encoded previously
        //
        lstrcpyn( pInfo->pArgs->pNoUser->szPassword, rc.szPassword, PWLEN + 1 );
        EncodePassword( pInfo->pArgs->pNoUser->szPassword );

        lstrcpyn( pInfo->pArgs->pNoUser->szDomain, rc.szDomain, DNLEN + 1 );
        *pInfo->pArgs->pfNoUserChanged = TRUE;
    }
    else if (!pInfo->pArgs->fDisableSavePw)
    {
        ASSERT( g_pRasSetCredentials );

        if (Button_GetCheck( pInfo->hwndCbSavePw ))
        {
            // User chose "save password".  Cache username, password, and
            // domain.
            //
            rc.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;

            // Whistler bug: 288234 When switching back and forth from
            // "I connect" and "Any user connects" password is not
            // caching correctly
            //
            if(     (pInfo->pArgs->fHaveSavedPwGlobal)
                &&  !pInfo->pArgs->fHaveSavedPwUser
                &&  IsPublicPhonebook(pInfo->pArgs->pFile->pszPath))
            {
                rc.dwMask |= RASCM_DefaultCreds;
            }
            
            TRACE( "RasSetCredentials(u|p|d,FALSE)" );
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath,
                pInfo->pArgs->pEntry->pszEntryName,
                &rc, FALSE );
            TRACE1( "RasSetCredentials=%d", dwErr );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_CachePw,  dwErr, NULL );
            }
        }
        else
        {
            // Whistler bug: 288234 When switching back and forth from
            // "I connect" and "Any user connects" password is not
            // caching correctly
            //
            // User chose not to save password; Cache username and domain only
            //
            rc.dwMask = RASCM_UserName | RASCM_Domain;

            TRACE( "RasSetCredentials(u|d,FALSE)" );
            dwErr = g_pRasSetCredentials(
                pInfo->pArgs->pFile->pszPath,
                pInfo->pArgs->pEntry->pszEntryName,
                &rc, FALSE );
            TRACE1( "RasSetCredentials=%d", dwErr );

            if (dwErr != 0)
            {
                ErrorDlg( pInfo->hwndDlg, SID_OP_UncachePw, dwErr, NULL );
            }

            // Whistler bug: 288234 When switching back and forth from
            // "I connect" and "Any user connects" password is not
            // caching correctly
            //

            // Delete the password saved per-user; Keep the user name
            // and domain saved, however.
            //
            if (pInfo->pArgs->fHaveSavedPwUser)
            {
                DeleteSavedCredentials(
                    pInfo->pArgs,
                    pInfo->hwndDlg,
                    FALSE,
                    FALSE );
                pInfo->pArgs->fHaveSavedPwUser = FALSE;
            }

            // Delete the global credentials.  
            //
            // Note that we have to delete the global identity 
            // as well because we do not support deleting 
            // just the global password.  This is so that 
            // RasSetCredentials can emulate RasSetDialParams.
            //
            else if (pInfo->pArgs->fHaveSavedPwGlobal)
            {
                DeleteSavedCredentials(
                    pInfo->pArgs,
                    pInfo->hwndDlg,
                    TRUE,
                    TRUE );
                pInfo->pArgs->fHaveSavedPwGlobal = FALSE;
            }
        }
    }

    ZeroMemory( rc.szPassword, sizeof(rc.szPassword) );
}


VOID
UaTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    UAINFO* pInfo = (UAINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "UaTerm" );

    if (pInfo)
    {
        // Restore the Dial Progress dialog.
        //
        SetOffDesktop( GetParent( hwndDlg ), SOD_MoveBackFree, NULL );

        Free( pInfo );
    }
}


//----------------------------------------------------------------------------
// VPN Double Dial help dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
VpnDoubleDialDlg(
    IN HWND hwndOwner,
    IN DINFO* pInfo )

    // Popup the VPN double dial help dialog.  'HwndOwner' is the owning
    // window.  'PInfo' is the dialing context information.
    //
    // Returns false if user sees the dialog and decides not to continue, true
    // otherwise.
    //
{
    INT_PTR nStatus;

    TRACE( "VpnDoubleDialDlg" );

    if (pInfo->pEntryMain->dwType != RASET_Vpn
        || !pInfo->fPrerequisiteDial
        || pInfo->pEntryMain->fSkipDoubleDialDialog)
    {
        return TRUE;
    }

    nStatus =
        (BOOL )DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_VI_VpnInitial ),
            hwndOwner,
            ViDlgProc,
            (LPARAM )pInfo );

    if (nStatus == -1)
    {
        nStatus = FALSE;
    }

    return !!(nStatus);
}


INT_PTR CALLBACK
ViDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the dialog.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "ViDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return ViInit( hwnd, (DINFO* )lparam );
        }

        case WM_COMMAND:
        {
            return ViCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
ViCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "ViCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDYES:
        case IDNO:
        {
            // Per bug 261955, the box setting is saved when either the Yes or
            // No, but not the 'X' button, is pressed.
            //
            DINFO* pInfo = (DINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            if (IsDlgButtonChecked( hwnd, CID_VI_CB_SkipMessage ))
            {
                pInfo->pEntryMain->fSkipDoubleDialDialog = TRUE;
                pInfo->pEntryMain->fDirty = TRUE;
                WritePhonebookFile( pInfo->pFileMain, NULL );
            }

            EndDialog( hwnd, (wId == IDYES) );
            return TRUE;
        }

        case IDCANCEL:
        {
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
ViInit(
    IN HWND hwndDlg,
    IN DINFO* pInfo )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of dialog.  'PUser'
    // is caller's argument to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    TRACE( "ViInit" );

    // Set the dialog context.
    //
    SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );

    // Set the explanatory text.
    //
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pEntryMain->pszEntryName;
        msgargs.apszArgs[ 1 ] = pInfo->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;

        MsgDlgUtil( NULL, SID_VI_ST_Explain, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( hwndDlg, CID_VI_ST_Explain, msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }
    }

    // Display finished window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetForegroundWindow( hwndDlg );

    return TRUE;
}

DWORD
DwTerminalDlg(
    LPCWSTR lpszPhonebook,
    LPCWSTR lpszEntry,
    RASDIALPARAMS *prdp,
    HWND hwndOwner,
    HRASCONN hRasconn)
{
    DWORD dwErr = ERROR_SUCCESS;
    PBENTRY *pEntry = NULL;
    PBFILE pbfile;
    DTLNODE *pNode = NULL;
    WCHAR szIpAddress[ TERM_IpAddress ];
    DWORD sidTitle;
    WCHAR *pszIpAddress;

    //
    //Initialize memory for Whistler bug 160888
    //
    ZeroMemory(&pbfile, sizeof(PBFILE)); 
    pbfile.hrasfile = -1;

    dwErr = LoadRas( g_hinstDll, hwndOwner );

    if (ERROR_SUCCESS != dwErr)
    {
        goto done;
    }
    
    
    dwErr = GetPbkAndEntryName(
            lpszPhonebook,
            lpszEntry,
            0,
            &pbfile,
            &pNode);

    if(     (NULL == pNode)
        ||  (ERROR_SUCCESS != dwErr))
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
        goto done;
    }

    pEntry = (PBENTRY *) DtlGetData(pNode);
    ASSERT(NULL != pEntry);

    if(NULL == pEntry)
    {
        goto done;
    }

    if (pEntry->dwBaseProtocol == BP_Slip)
    {
        lstrcpyn( 
            szIpAddress,
            (pEntry->pszIpAddress) ? pEntry->pszIpAddress : TEXT("0.0.0.0"),
            sizeof(szIpAddress) / sizeof(TCHAR));
        pszIpAddress = szIpAddress;
        sidTitle = SID_T_SlipTerminal;
    }
    else
    {
        szIpAddress[0] = TEXT('\0');
        pszIpAddress = szIpAddress;
        sidTitle = SID_T_PostconnectTerminal;
    }


    if (!TerminalDlg(
            pEntry, prdp, hwndOwner,
            hRasconn, sidTitle, pszIpAddress ))
    {
        TRACE( "TerminalDlg==FALSE" );
        dwErr = E_FAIL;
        goto done;
    }

    TRACE2( "pszIpAddress=0x%08x(%ls)", pszIpAddress,
        pszIpAddress ? pszIpAddress : TEXT("") );
    TRACE2( "pEntry->pszIpAddress=0x%08x(%ls)", pEntry->pszIpAddress,
        pEntry->pszIpAddress ? pEntry->pszIpAddress : TEXT("") );

    if (pszIpAddress[0]
        && (!pEntry->pszIpAddress
            || lstrcmp( pszIpAddress, pEntry->pszIpAddress ) != 0))
    {
        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = StrDup( szIpAddress );
        pEntry->fDirty = TRUE;
        
        dwErr = WritePhonebookFile( &pbfile, NULL );
        if (dwErr != 0)
        {
            ErrorDlg( hwndOwner, SID_OP_WritePhonebook, dwErr, NULL );
        }
    }
    
    done:
        ClosePhonebookFile(&pbfile);
        return dwErr;
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\entryps.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entryps.c
// Remote Access Common Dialog APIs
// Phonebook Entry property sheet
//
// 06/20/95 Steve Cobb
//


#include "rasdlgp.h"
#include "entryps.h"
#include "uiinfo.h"
#include "inetcfgp.h"
#include "netcon.h"
#include "rassrvrc.h"
#include "shlobjp.h"
#include "shellapi.h"
#include "iphlpapi.h"
#include "prsht.h"
#include "pbkp.h"

// Page definitions.
//
#define PE_GePage 0
#define PE_OePage 1
#define PE_LoPage 2
#define PE_NePage 3
#define PE_SaPage 4

#define PE_PageCount 5


// (Router) Callback context block.
//
#define CRINFO struct tagCRINFO
CRINFO
{
    /* Caller's argument to the stub API.
    */
    EINFO* pArgs;

    /* Dialog and control handles.
    */
    HWND hwndDlg;
    HWND hwndRbNo;
    HWND hwndRbYes;
    HWND hwndLvNumbers;
    HWND hwndPbEdit;
    HWND hwndPbDelete;
};

static TCHAR g_pszFirewallRegKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetworking\\PersonalFirewall");
static TCHAR g_pszDisableFirewallWarningValue[] = TEXT("ShowDisableFirewallWarning");

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static const DWORD g_adwGeHelp[] =
{
    CID_GE_GB_ConnectUsing,      HID_GE_LV_Device, //HID_GE_GB_ConnectUsing,
    CID_GE_LV_Device,            HID_GE_LV_Device,
    CID_GE_LV_Devices,           HID_GE_LV_Devices,
    CID_GE_PB_MoveUp,            HID_GE_PB_MoveUp,
    CID_GE_PB_MoveDown,          HID_GE_PB_MoveDown,
    CID_GE_CB_SharedPhoneNumber, HID_GE_CB_SharedPhoneNumber,
    CID_GE_PB_Configure,         HID_GE_PB_Configure,
    CID_GE_ST_AreaCodes,         HID_GE_CLB_AreaCodes,
    CID_GE_CLB_AreaCodes,        HID_GE_CLB_AreaCodes,
    CID_GE_ST_PhoneNumber,       HID_GE_EB_PhoneNumber,
    CID_GE_EB_PhoneNumber,       HID_GE_EB_PhoneNumber,
    CID_GE_ST_CountryCodes,      HID_GE_LB_CountryCodes,
    CID_GE_LB_CountryCodes,      HID_GE_LB_CountryCodes,
    CID_GE_CB_UseDialingRules,   HID_GE_CB_UseDialingRules,
    CID_GE_PB_Alternates,        HID_GE_PB_Alternates,
    CID_GE_CB_ShowIcon,          HID_GE_CB_ShowIcon,
    CID_GE_ST_HostName,          HID_GE_EB_HostName,
    CID_GE_EB_HostName,          HID_GE_EB_HostName,
    CID_GE_ST_ServiceName,       HID_GE_EB_ServiceName, //Add for whistler bug 343249
    CID_GE_EB_ServiceName,       HID_GE_EB_ServiceName,
    CID_GE_GB_FirstConnect,      -1, //HID_GE_GB_FirstConnect,
    CID_GE_ST_Explain,           HID_GE_GB_FirstConnect,
    CID_GE_CB_DialAnotherFirst,  HID_GE_CB_DialAnotherFirst,
    CID_GE_LB_DialAnotherFirst,  HID_GE_LB_DialAnotherFirst,
    CID_GE_ST_Devices,           HID_GE_LB_Devices,
    CID_GE_LB_Devices,           HID_GE_LB_Devices,
    CID_GE_PB_DialingRules,      HID_GE_PB_DialingRules,
    CID_GE_GB_PhoneNumber,       -1,
    0, 0
};

static const DWORD g_adwOeHelp[] =
{
    CID_OE_GB_Progress,        -1,      //commented for bug 15738//HID_OE_GB_Progress,
    CID_OE_CB_DisplayProgress, HID_OE_CB_DisplayProgress,
    CID_OE_CB_PreviewUserPw,   HID_OE_CB_PreviewUserPw,
    CID_OE_CB_PreviewDomain,   HID_OE_CB_PreviewDomain,
    CID_OE_CB_PreviewNumber,   HID_OE_CB_PreviewNumber,
    CID_OE_GB_Redial,          -1,      //commented for bug 15738//HID_OE_GB_Redial,
    CID_OE_ST_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_EB_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_ST_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_LB_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_ST_IdleTimes,       HID_OE_LB_IdleTimes,
    CID_OE_LB_IdleTimes,       HID_OE_LB_IdleTimes,
    CID_OE_CB_RedialOnDrop,    HID_OE_CB_RedialOnDrop,
    CID_OE_GB_MultipleDevices, -1,      //commented for bug 15738//HID_OE_GB_MultipleDevices,
    CID_OE_LB_MultipleDevices, HID_OE_LB_MultipleDevices,
    CID_OE_PB_Configure,       HID_OE_PB_Configure,
    CID_OE_PB_X25,             HID_OE_PB_X25,
    CID_OE_PB_Tunnel,          HID_OE_PB_Tunnel,
    CID_OE_RB_DemandDial,      HID_OE_RB_DemandDial,
    CID_OE_RB_Persistent,      HID_OE_RB_Persistent,
    0, 0
};

static const DWORD g_adwOeRouterHelp[] =
{
    CID_OE_GB_Progress,        -1,      //commented for bug 15738//HID_OE_GB_Progress,
    CID_OE_CB_DisplayProgress, HID_OE_CB_DisplayProgress,
    CID_OE_CB_PreviewUserPw,   HID_OE_CB_PreviewUserPw,
    CID_OE_CB_PreviewDomain,   HID_OE_CB_PreviewDomain,
    CID_OE_CB_PreviewNumber,   HID_OE_CB_PreviewNumber,
    CID_OE_GB_Redial,          -1,      //commented for bug 15738//HID_OE_GB_Redial,
    CID_OE_ST_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_EB_RedialAttempts,  HID_OE_EB_RedialAttempts,
    CID_OE_ST_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_LB_RedialTimes,     HID_OE_LB_RedialTimes,
    CID_OE_ST_IdleTimes,       HID_OE_LB_IdleTimesRouter,
    CID_OE_LB_IdleTimes,       HID_OE_LB_IdleTimesRouter,
    CID_OE_CB_RedialOnDrop,    HID_OE_CB_RedialOnDrop,
    CID_OE_GB_MultipleDevices, -1,      //commented for bug 15738//HID_OE_GB_MultipleDevices,
    CID_OE_LB_MultipleDevices, HID_OE_LB_MultipleDevices,
    CID_OE_PB_Configure,       HID_OE_PB_Configure,
    CID_OE_PB_X25,             HID_OE_PB_X25,
    CID_OE_PB_Tunnel,          HID_OE_PB_Tunnel,
    CID_OE_RB_DemandDial,      HID_OE_RB_DemandDial,
    CID_OE_RB_Persistent,      HID_OE_RB_Persistent,
    CID_OE_PB_Callback,        HID_OE_PB_Callback,
    0, 0
};

//Get rid of the const qualifire for whistler bug#276452
static DWORD g_adwLoHelp[] =
{
    CID_LO_GB_SecurityOptions,  -1,     //commented for bug 15738//HID_LO_GB_SecurityOptions,
    CID_LO_RB_TypicalSecurity,  HID_LO_RB_TypicalSecurity,
    CID_LO_ST_Auths,            HID_LO_LB_Auths,
    CID_LO_LB_Auths,            HID_LO_LB_Auths,
    CID_LO_CB_UseWindowsPw,     HID_LO_CB_UseWindowsPw,
    CID_LO_CB_Encryption,       HID_LO_CB_Encryption,
    CID_LO_RB_AdvancedSecurity, HID_LO_RB_AdvancedSecurity,
    CID_LO_ST_AdvancedText,     HID_LO_PB_Advanced,
    CID_LO_PB_Advanced,         HID_LO_PB_Advanced,
    CID_LO_GB_Scripting,        -1,     //commented for bug 15738//HID_LO_GB_Scripting,
    CID_LO_CB_RunScript,        HID_LO_CB_RunScript,
    CID_LO_CB_Terminal,         HID_LO_CB_Terminal,
    CID_LO_LB_Scripts,          HID_LO_LB_Scripts,
    CID_LO_PB_Edit,             HID_LO_PB_Edit,
    CID_LO_PB_Browse,           HID_LO_PB_Browse,
    CID_LO_ST_IPSecText,        HID_LO_PB_IPSec,
    CID_LO_PB_IPSec,            HID_LO_PB_IPSec,//On Server, this help ID will be HID_LO_PB_IPSecServer
    0, 0
};

static const DWORD g_adwNeHelp[] =
{
    CID_NE_ST_ServerType,           HID_NE_LB_ServerType,
    CID_NE_LB_ServerType,           HID_NE_LB_ServerType,
    CID_NE_PB_Settings,             HID_NE_PB_Settings,
    CID_NE_ST_Components,           HID_NE_LV_Components,
    CID_NE_LV_Components,           HID_NE_LV_Components,
    CID_NE_PB_Add,                  HID_NE_PB_Add,
    CID_NE_PB_Remove,               HID_NE_PB_Remove,
    CID_NE_PB_Properties,           HID_NE_PB_Properties,
    CID_NE_GB_Description,          -1,     //commented for bug 15738//HID_NE_LB_ComponentDesc,
    CID_NE_LB_ComponentDesc,        HID_NE_LB_ComponentDesc,
    0, 0
};

static const DWORD g_adwPpHelp[] =
{
    CID_NE_EnableLcp,               HID_NE_EnableLcp,
    CID_NE_EnableCompression,       HID_NE_EnableCompression,
    CID_NE_NegotiateMultilinkAlways,HID_NE_NegotiateMultilinkAlways,
    0, 0
};

static DWORD g_adwCrHelp[] =
{
    CID_CR_RB_No,      HID_CR_RB_No,
    CID_CR_RB_Yes,     HID_CR_RB_Yes,
    CID_CR_PB_Edit,    HID_CR_PB_Edit,
    CID_CR_PB_Delete,  HID_CR_PB_Delete,
    CID_CR_LV_Numbers, HID_CR_LV_Numbers,
    0, 0
};

static DWORD g_adwSaHelp[] =
{
    CID_SA_PB_Shared,       HID_SA_PB_Shared,
    CID_SA_GB_Shared,       -1,
    CID_SA_PB_DemandDial,   HID_SA_PB_DemandDial,
    CID_SA_ST_DemandDial,   HID_SA_PB_DemandDial,
    CID_SA_PB_Settings,     HID_SA_PB_Settings,
    CID_SA_GB_PrivateLan,   -1,
    CID_SA_ST_PrivateLan,   HID_SA_LB_PrivateLan,
    CID_SA_LB_PrivateLan,   HID_SA_LB_PrivateLan,
    0, 0
};

//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
RouterCallbackDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo );

INT_PTR CALLBACK
CrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CrCommand(
    IN CRINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

BOOL
CrInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs );

VOID
CrSave(
    IN CRINFO* pInfo );

VOID
CrTerm(
    IN HWND hwndDlg );

VOID
CrUpdateLvAndPbState(
    IN CRINFO* pInfo );

VOID
GeAlternates(
    IN PEINFO* pInfo );

VOID
GeDialingRules(
    IN PEINFO* pInfo );

INT_PTR CALLBACK
GeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
GeDlgProcMultiple(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
GeDlgProcSingle(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
GeClearLbDialAnotherFirst(
    IN HWND hwndLbDialAnotherFirst );

BOOL
GeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
GeConfigure(
    IN PEINFO* pInfo );

VOID
GeDialAnotherFirstSelChange(
    IN PEINFO* pInfo );

BOOL
GeFillLbDialAnotherFirst(
    IN PEINFO* pInfo,
    IN BOOL fAbortIfPrereqNotFound );

VOID
GeGetPhoneFields(
    IN PEINFO* pInfo,
    OUT DTLNODE* pDstLinkNode );

BOOL
GeInit(
    IN HWND hwndPage,
    IN OUT EINFO* pArgs );

LVXDRAWINFO*
GeLvDevicesCallbackMultiple(
    IN HWND hwndLv,
    IN DWORD dwItem );

LVXDRAWINFO*
GeLvDevicesCallbackSingle(
    IN HWND hwndLv,
    IN DWORD dwItem );

VOID
GeMoveDevice(
    IN PEINFO* pInfo,
    IN BOOL fUp );

DWORD
GeSaveLvDeviceChecks(
    IN PEINFO* pInfo );

VOID
GeUpdateDialAnotherFirstState(
    IN PEINFO* pInfo );

VOID
GeSetPhoneFields(
    IN PEINFO* pInfo,
    IN DTLNODE* pSrcLinkNode,
    IN BOOL fDisableAll );

VOID
GeUpdatePhoneNumberFields(
    IN PEINFO* pInfo,
    IN BOOL fSharedToggle );

VOID
GeUpdatePhoneNumberTitle(
    IN PEINFO* pInfo,
    IN TCHAR* pszDevice );

VOID
GeUpdateUpDownButtons(
    IN PEINFO* pInfo );

BOOL
LoCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
LoDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
LoEnableSecuritySettings(
    IN PEINFO* pInfo,
    IN BOOL fTypical,
    IN BOOL fAdvanced );

VOID
LoFillLbAuths(
    IN PEINFO* pInfo );

BOOL
LoInit(
    IN HWND hwndPage );

VOID
LoLbAuthsSelChange(
    IN PEINFO* pInfo );

VOID
LoRefreshSecuritySettings(
    IN PEINFO* pInfo );

VOID
LoSaveTypicalAuthSettings(
    IN PEINFO* pInfo );

INT_PTR CALLBACK
NeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NeInit(
    IN HWND hwndPage );

void
NeServerTypeSelChange (
    IN PEINFO* pInfo);

void
NeAddComponent (
    IN PEINFO*  pInfo);

void
NeEnsureNetshellLoaded (
    IN PEINFO* pInfo);

void
NeRemoveComponent (
    IN PEINFO* pInfo);

void
NeLvClick (
    IN PEINFO* pInfo,
    IN BOOL fDoubleClick);

void
NeLvItemChanged (
    IN PEINFO* pInfo);

void
NeSaveBindingChanges (
    IN PEINFO* pInfo);

void
NeLvDeleteItem (
    IN PEINFO* pInfo,
    IN NM_LISTVIEW* pnmlv);

BOOL
OeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
OeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
OeEnableMultipleDeviceGroup(
    IN PEINFO* pInfo,
    IN BOOL fEnable );

BOOL
OeInit(
    IN HWND hwndPage );

VOID
OeTunnel(
    IN PEINFO* pInfo );

VOID
OeUpdateUserPwState(
    IN PEINFO* pInfo );

VOID
OeX25(
    IN PEINFO* pInfo );

BOOL
PeApply(
    IN HWND hwndPage );

PEINFO*
PeContext(
    IN HWND hwndPage );

DWORD
PeCountEnabledLinks(
    IN PEINFO* pInfo );

VOID
PeExit(
    IN PEINFO* pInfo,
    IN DWORD dwError );

VOID
PeExitInit(
    IN HWND hwndDlg,
    IN EINFO* pEinfo,
    IN DWORD dwError );

PEINFO*
PeInit(
    IN HWND hwndFirstPage,
    IN EINFO* pArgs );

VOID
PeTerm(
    IN HWND hwndPage );

INT_PTR CALLBACK
PpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
RdDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SaCommand(
    IN PEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

INT_PTR CALLBACK
SaUnavailDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SaInit(
    IN HWND   hwndDlg );

INT_PTR CALLBACK
SaDisableFirewallWarningDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL SaIsAdapterDHCPEnabled(
    IN IHNetConnection* pConnection);

// wrapper to load homenet page:  used in PePropertySheet(...)
HRESULT HrLoadHNetGetFirewallSettingsPage (PROPSHEETPAGEW * ppsp, EINFO* pInfo)
{
    PROPSHEETPAGEW psp;
    HRESULT hr;
    HNET_CONN_PROPERTIES *pProps;
    IHNetConnection *pHNetConn = NULL;
    IHNetCfgMgr *pHNetCfgMgr = NULL;

//  _asm int 3

    ZeroMemory (&psp, sizeof(PROPSHEETPAGEW));
    psp.dwSize = sizeof(PROPSHEETPAGEW);
    *ppsp = psp;

    // Make sure COM is initialized on this thread.
    //
    hr = CoInitializeEx(
            NULL, 
            COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE
            );

    if (SUCCEEDED(hr))
    {
        pInfo->fComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr)) {
        // pass the Guid to the export from hnetcfg ("HNetGetFirewallSettingsPage").
        HINSTANCE hinstDll = LoadLibrary (TEXT("hnetcfg.dll"));
        if (hinstDll == NULL)
            hr = HRESULT_FROM_WIN32 (GetLastError());
        else {
            HRESULT (*pfnGetPage) (PROPSHEETPAGEW *, GUID *);
            pfnGetPage = (HRESULT (*)(PROPSHEETPAGEW *, GUID *))GetProcAddress (hinstDll, "HNetGetFirewallSettingsPage");
            if (!pfnGetPage)
                hr = HRESULT_FROM_WIN32 (GetLastError());
            else
                hr = pfnGetPage (&psp, pInfo->pEntry->pGuid);

            FreeLibrary (hinstDll);
        }
        if (hr == S_OK)
            *ppsp = psp;
    }
    return pInfo->hShowHNetPagesResult = hr;
}

//----------------------------------------------------------------------------
// Phonebook Entry property sheet entrypoint
//----------------------------------------------------------------------------

VOID
PePropertySheet(
    IN OUT EINFO* pEinfo )

    // Runs the Phonebook entry property sheet.  'PEinfo' is the API caller's
    // arguments.
    //
{
    PROPSHEETPAGE apage[ PE_PageCount ];
    PROPSHEETPAGE* ppage;
    INT nPages;
    INT nPageIndex;

    TRACE( "PePropertySheet" );

    nPages = PE_PageCount;
    ZeroMemory( apage, sizeof(apage) );

    // General page.
    //
    ppage = &apage[ PE_GePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    if (pEinfo->pEntry->dwType == RASET_Vpn)
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_GE_GeneralVpn );
        ppage->pfnDlgProc = GeDlgProc;
    }
    else if (pEinfo->pEntry->dwType == RASET_Broadband)
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_GE_GeneralBroadband );
        ppage->pfnDlgProc = GeDlgProc;
    }
    else if (pEinfo->pEntry->dwType == RASET_Phone)
    {
        if (pEinfo->fMultipleDevices)
        {
            if (pEinfo->fRouter)
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_RouterGeneralMultiple );
            }
            else
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_GeneralMultiple );
            }

            ppage->pfnDlgProc = GeDlgProcMultiple;
        }
        else
        {
            if (pEinfo->fRouter)
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_RouterGeneralSingle );
            }
            else
            {
                ppage->pszTemplate =
                    MAKEINTRESOURCE( PID_GE_GeneralSingle );
            }

            ppage->pfnDlgProc = GeDlgProcSingle;
        }
    }
    else
    {
        ASSERT( pEinfo->pEntry->dwType == RASET_Direct );
        ppage->pszTemplate = MAKEINTRESOURCE( PID_GE_GeneralDirect );
        ppage->pfnDlgProc = GeDlgProc;
    }

    ppage->lParam = (LPARAM )pEinfo;

    // Options page.
    //
    ppage = &apage[ PE_OePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (pEinfo->fRouter)
            ? MAKEINTRESOURCE( PID_OE_OptionsRouter )
            : ((pEinfo->pEntry->dwType == RASET_Phone)
                  ? MAKEINTRESOURCE( PID_OE_Options )
                  : MAKEINTRESOURCE( PID_OE_OptionsVD ));
    ppage->pfnDlgProc = OeDlgProc;

    // Security page.
    //
    ppage = &apage[ PE_LoPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;

    //
    //Add new Security Page for bug 193987 PSK
    //

    if ( pEinfo->pEntry->dwType == RASET_Vpn )
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_LO_SecurityVpn );
    }
    else
    {
        ppage->pszTemplate = MAKEINTRESOURCE( PID_LO_Security );
    }
    ppage->pfnDlgProc = LoDlgProc;

    // Network page.
    //
    ppage = &apage[ PE_NePage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_NE_Network );
    ppage->pfnDlgProc = NeDlgProc;

    // Advanced page.
    // (AboladeG) The page is shown if the user is admin and
    // there is at least one LAN connection, or if this phonebook entry
    // is already shared.
    //
    nPageIndex = PE_SaPage;

    if(!pEinfo->fIsUserAdminOrPowerUser)
    {
        --nPages;
    }
    else
    {
        HRESULT hr;
        BOOL fShowAdvancedUi = TRUE;
        INetConnectionUiUtilities* pncuu = NULL;

        // Check if ZAW is denying access to the Shared Access UI
        //
        hr = HrCreateNetConnectionUtilities(&pncuu);
        if (SUCCEEDED(hr))
        {
            if(FALSE == INetConnectionUiUtilities_UserHasPermission(pncuu, NCPERM_ShowSharedAccessUi) && 
                    FALSE == INetConnectionUiUtilities_UserHasPermission(pncuu, NCPERM_PersonalFirewallConfig))
            fShowAdvancedUi = FALSE;
                
            INetConnectionUiUtilities_Release(pncuu);
        }

        if (!fShowAdvancedUi)
        {
            --nPages;
        }
        else
        {
            // Finally, check whether TCP/IP is installed or not.
            //
            if (!FIsTcpipInstalled())
            {
                --nPages;
            }
            else
            {
                ppage = &apage[ nPageIndex++ ];
                ppage->dwSize = sizeof(PROPSHEETPAGE);
                ppage->hInstance = g_hinstDll;
                {
                    PROPSHEETPAGEW psp;
                    hr = HrLoadHNetGetFirewallSettingsPage (&psp, pEinfo);
                    if (hr == S_OK)
                       *ppage = psp;
                }
                if (hr != S_OK)
                {
                    ppage->pszTemplate = MAKEINTRESOURCE( PID_SA_HomenetUnavailable );
                    ppage->pfnDlgProc = SaUnavailDlgProc;
                }
            }
        }
    }

    if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        INT i;
        BOOL fStatus;
        RASEDSHELLOWNEDR2* pShellOwnedInfo;

        pShellOwnedInfo = (RASEDSHELLOWNEDR2*)pEinfo->pApiArgs->reserved2;

        // The property sheet is to be invoked by the shell, using the shell
        // convention of adding pages via callback.
        //
        for (i = 0; i < nPages; ++i)
        {
            HPROPSHEETPAGE h;

            h = CreatePropertySheetPage( &apage[ i ] );
            if (!h)
            {
                TRACE( "CreatePage failed" );
                break;
            }

            fStatus = pShellOwnedInfo->pfnAddPage( h, pShellOwnedInfo->lparam );

            if (!fStatus)
            {
                TRACE( "AddPage failed" );
                DestroyPropertySheetPage( h );
                break;
            }
        }

        if (i < nPages)
        {
            ErrorDlg( pEinfo->pApiArgs->hwndOwner,
                SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        }
    }
    else
    {
        PROPSHEETHEADER header;
        PWSTR pszBuf = NULL;
        PWSTR pszHeader;
        DWORD cb;
        HICON hIcon         = NULL;
        DWORD dwDisplayIcon = 0;
        int i;
        HPROPSHEETPAGE hPages[PE_PageCount];

        //For whistler bug 382720 349866        gangz
        //to fusionalize well for both rasdlg pages in NCW and
        //property pages launched by pressing "Property" button
        //besides following the normal fusion steps: we have to
        // (1) add _WIN32_WINNT=0x501 in files sources
        // (2) use the phpage member in PROPSHEETHEADER structure, that is
        //    use CreatePropertySheetPage() to create page handles

        for (i = 0; i < nPages; ++i)
        {
            hPages[i] = CreatePropertySheetPage( &apage[ i ] );
            if ( !hPages[i] )
            {
                TRACE( "CreatePage failed" );
                break;
            }
        }
        
        if (i < nPages)
        {
            ErrorDlg( pEinfo->pApiArgs->hwndOwner,
                SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        }
        else
       {
        // Create the correct properties header 
        pszHeader = PszFromId(g_hinstDll, SID_PropertiesHeader);
        if (pszHeader)
        {
            cb = lstrlenW(pEinfo->pEntry->pszEntryName) +
                 1 +  
                 lstrlenW(pszHeader) + 
                 1; 

            pszBuf = Malloc(cb * sizeof(TCHAR));
            if (!pszBuf)
            {
                TRACE("Properties header allocation failed");
            }
            else
            {
                lstrcpyW(pszBuf, pEinfo->pEntry->pszEntryName);
                lstrcatW(pszBuf, L" ");
                lstrcatW(pszBuf, pszHeader);
            }

            Free(pszHeader);
        }

        //For whistler bug 372078 364876   gangz
        //
        hIcon = GetCurrentIconEntryType(pEinfo->pEntry->dwType,
                                        TRUE); //TRUE means small Icon
        
        if (hIcon)
        {
            dwDisplayIcon = PSH_USEHICON;
        }

        // The property sheet is to be invoked directly.
        //
        ZeroMemory( &header, sizeof(header) );

        header.dwSize       = sizeof(PROPSHEETHEADER);
//        header.dwFlags      = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK | dwDisplayIcon;
        header.dwFlags      = PSH_NOAPPLYNOW | PSH_USECALLBACK | dwDisplayIcon;
        header.hwndParent   = pEinfo->pApiArgs->hwndOwner;
        header.hInstance    = g_hinstDll;
        header.pszCaption   = (pszBuf)?(pszBuf):(pEinfo->pEntry->pszEntryName);
        header.nPages       = nPages;
//        header.ppsp         = apage;
        header.phpage       = hPages;
        header.hIcon        = hIcon;
        header.pfnCallback  = UnHelpCallbackFunc;

        if (PropertySheet( &header ) == -1)
        {
            TRACE( "PropertySheet failed" );
            ErrorDlg( pEinfo->pApiArgs->hwndOwner,
                SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        }

        Free0(pszBuf);

        //For whistler bug 372078
        //GetCurrentIconEntryType() loads Icon from netshell where the icon is loaded
        //by LoadImage() without LR_SHARED, so I have to destroy it when we are done
        //with it
        //
        if (hIcon)
        {
            DestroyIcon( hIcon );
        }
       }    
    }
}

//----------------------------------------------------------------------------
// Phonebook Entry property sheet
// Listed alphabetically
//----------------------------------------------------------------------------

BOOL
PeApply(
    IN HWND hwndPage )

    // Saves the contents of the property sheet.  'HwndPage is the handle of a
    // property page.  Pops up any errors that occur.
    //
    // Returns true is page can be dismissed, false otherwise.
    //
{
    DWORD dwErr;
    PEINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "PeApply" );

    pInfo = PeContext( hwndPage );
    ASSERT( pInfo );
    if (pInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pEntry = pInfo->pArgs->pEntry;
    ASSERT( pEntry );

    // Save General page fields.
    //
    ASSERT( pInfo->hwndGe );
    {
        DTLNODE* pNode;

        // Retrieve the lone common control.
        //
        pEntry->fShowMonitorIconInTaskBar =
            Button_GetCheck( pInfo->hwndCbShowIcon );

        if (pEntry->dwType == RASET_Phone)
        {
            DWORD dwCount;

            dwCount = GeSaveLvDeviceChecks( pInfo );

            // Don't allow the user to deselect all of the
            // devices
            if ( (pInfo->pArgs->fMultipleDevices) && (dwCount == 0) )
            {
                MsgDlg( hwndPage, SID_SelectDevice, NULL );
                PropSheet_SetCurSel ( pInfo->hwndDlg, pInfo->hwndGe, 0 );
                SetFocus ( pInfo->hwndLvDevices );
                return FALSE;
            }

            // Save the "shared phone number" setting.  As usual, single
            // device mode implies shared mode, allowing things to fall
            // through correctly.
            //
            if (pInfo->pArgs->fMultipleDevices)
            {
                pEntry->fSharedPhoneNumbers =
                    Button_GetCheck( pInfo->hwndCbSharedPhoneNumbers );
            }
            else
            {
                pEntry->fSharedPhoneNumbers = TRUE;
            }

            // Set the phone number set for the first phone number of the
            // current link (shared or selected) to the contents of the phone
            // number controls.
            //
            GeGetPhoneFields( pInfo, pInfo->pCurLinkNode );

            // Swap lists, saving updates to caller's global list of area
            // codes.  Caller's original list will be destroyed by PeTerm.
            //
            if (pInfo->pListAreaCodes)
            {
                DtlSwapLists(
                    pInfo->pArgs->pUser->pdtllistAreaCodes,
                    pInfo->pListAreaCodes );
                pInfo->pArgs->pUser->fDirty = TRUE;
            }
        }
        else if (pEntry->dwType == RASET_Vpn)
        {
            DTLNODE* pNode;
            PBLINK* pLink;
            PBPHONE* pPhone;

            // Save host name, i.e. the VPN phone number.
            //
            pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNode );
            pLink = (PBLINK* )DtlGetData( pNode );
            pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNode)
            {
                return FALSE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNode );
            Free0( pPhone->pszPhoneNumber );
            pPhone->pszPhoneNumber = GetText( pInfo->hwndEbHostName );
            FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

            // Any prequisite entry selection change has been saved already.
            // Just need to toss it if disabled.
            //
            if (!Button_GetCheck( pInfo->hwndCbDialAnotherFirst ))
            {
                Free0( pEntry->pszPrerequisiteEntry );
                pEntry->pszPrerequisiteEntry = NULL;
                Free0( pEntry->pszPrerequisitePbk );
                pEntry->pszPrerequisitePbk = NULL;
            }
        }
        else if (pEntry->dwType == RASET_Broadband)
        {
            DTLNODE* pNode;
            PBLINK* pLink;
            PBPHONE* pPhone;

            // Save service name, i.e. the broadband phone number.
            //
            pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNode );
            pLink = (PBLINK* )DtlGetData( pNode );
            pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNode)
            {
                return FALSE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNode );
            Free0( pPhone->pszPhoneNumber );
            pPhone->pszPhoneNumber = GetText( pInfo->hwndEbBroadbandService );
            FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );
        }
        else if (pEntry->dwType == RASET_Direct)
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            // The currently enabled device is the one
            // that should be used for the connection.  Only
            // one device will be enabled (DnUpdateSelectedDevice).
            for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT(pLink);

                if ( pLink->fEnabled )
                    break;
            }

            // If we found a link successfully, deal with it
            // now.
            if ( pLink && pLink->fEnabled ) {
                if (pLink->pbport.pbdevicetype == PBDT_ComPort)
                    MdmInstallNullModem (pLink->pbport.pszPort);
            }
        }
    }

    // Save Options page fields.
    //
    if (pInfo->hwndOe)
    {
        UINT unValue;
        BOOL f;
        INT iSel;

        pEntry->fShowDialingProgress =
            Button_GetCheck( pInfo->hwndCbDisplayProgress );

        // Note: The'fPreviewUserPw', 'fPreviewDomain' fields are updated as
        //       they are changed.

        pEntry->fPreviewPhoneNumber =
            Button_GetCheck( pInfo->hwndCbPreviewNumber );

        unValue = GetDlgItemInt(
            pInfo->hwndOe, CID_OE_EB_RedialAttempts, &f, FALSE );
        if (f && unValue <= RAS_MaxRedialCount)
        {
            pEntry->dwRedialAttempts = unValue;
        }

        iSel = ComboBox_GetCurSel( pInfo->hwndLbRedialTimes );
        pEntry->dwRedialSeconds =
            (DWORD )ComboBox_GetItemData( pInfo->hwndLbRedialTimes, iSel );

        iSel = ComboBox_GetCurSel( pInfo->hwndLbIdleTimes );
        pEntry->lIdleDisconnectSeconds =
            (LONG )ComboBox_GetItemData( pInfo->hwndLbIdleTimes, iSel );

        if (pInfo->pArgs->fRouter)
        {
            pEntry->fRedialOnLinkFailure =
                Button_GetCheck( pInfo->hwndRbPersistent );
        }
        else
        {
            pEntry->fRedialOnLinkFailure =
                Button_GetCheck( pInfo->hwndCbRedialOnDrop );
        }

        // Note: dwDialMode is saved as changed.
        // Note: X.25 settings are saved at OK on that dialog.
    }

    // Save Security page fields.
    //
    if (pInfo->hwndLo)
    {
        if (Button_GetCheck( pInfo->hwndRbTypicalSecurity ))
        {
            LoSaveTypicalAuthSettings( pInfo );

            if (pEntry->dwTypicalAuth == TA_CardOrCert)
            {
                /*
                // Toss any existing advanced EAP configuration remnants when
                // typical smartcard, per bug 262702 and VBaliga email.
                //
                Free0( pEntry->pCustomAuthData );
                pEntry->pCustomAuthData = NULL;
                pEntry->cbCustomAuthData = 0;

                */
                (void) DwSetCustomAuthData(
                            pEntry,
                            0,
                            NULL);

                TRACE( "RasSetEapUserData" );
                ASSERT( g_pRasSetEapUserData );
                g_pRasSetEapUserData(
                    INVALID_HANDLE_VALUE,
                    pInfo->pArgs->pFile->pszPath,
                    pEntry->pszEntryName,
                    NULL,
                    0 );
                TRACE( "RasSetEapUserData done" );
            }
        }

        if (pEntry->dwType == RASET_Phone)
        {
            Free0( pEntry->pszScriptAfter );
            SuGetInfo( &pInfo->suinfo,
                &pEntry->fScriptAfter,
                &pEntry->fScriptAfterTerminal,
                &pEntry->pszScriptAfter );
        }
    }

    // Save Network page fields.
    // We won't have anything to do if we never initialized pNetCfg.
    //
    if (pInfo->pNetCfg)
    {
        HRESULT             hr;

        // Update the phone book entry with the enabled state of the components.
        // Do this by enumerating the components from the list view item data
        // and consulting the check state for each.
        //
        NeSaveBindingChanges(pInfo);

        hr = INetCfg_Apply (pInfo->pNetCfg);
        if (((NETCFG_S_REBOOT == hr) || (pInfo->fRebootAlreadyRequested)) &&
              pInfo->pNetConUtilities)
        {
            DWORD dwFlags = QUFR_REBOOT;
            if (!pInfo->fRebootAlreadyRequested)
                dwFlags |= QUFR_PROMPT;

            //$TODO NULL caption?
            INetConnectionUiUtilities_QueryUserForReboot (
                    pInfo->pNetConUtilities, pInfo->hwndDlg, NULL, dwFlags);
        }
    }


#if 0 //!!!
    if ((fLocalPad || iPadSelection != 0)
        && (!pEntry->pszX25Address || IsAllWhite( pEntry->pszX25Address )))
    {
        // Address field is blank with X.25 dial-up or local PAD chosen.
        //
        MsgDlg( pInfo->hwndDlg, SID_NoX25Address, NULL );
        PropSheet_SetCurSel( pInfo->hwndDlg, NULL, PE_XsPage );
        SetFocus( pInfo->hwndEbX25Address );
        Edit_SetSel( pInfo->hwndEbX25Address, 0, -1 );
        return FALSE;
    }
#endif

    // Make sure proprietary ISDN options are disabled if more than one link
    // is enabled.  The proprietary ISDN option is only meaningful when
    // calling a down-level server that needs Digiboard channel aggragation
    // instead of PPP multi-link.
    //
    {
        DTLNODE* pNode;
        DWORD cIsdnLinks;

        cIsdnLinks = 0;
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if (pLink->fEnabled && pLink->pbport.pbdevicetype == PBDT_Isdn)
            {
                ++cIsdnLinks;
            }
        }

        if (cIsdnLinks > 1)
        {
            for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT(pLink);

                if (pLink->fEnabled && pLink->fProprietaryIsdn)
                {
                    pLink->fProprietaryIsdn = FALSE;
                }
            }
        }
    }

    // Inform user that edits to the connected entry won't take affect until
    // the entry is hung up and re-dialed, per PierreS's insistence.
    //
    if (HrasconnFromEntry( pInfo->pArgs->pFile->pszPath, pEntry->pszEntryName ))
    {
        MsgDlg( pInfo->hwndDlg, SID_EditConnected, NULL );
    }

    // It's a valid new/changed entry.  Commit the changes to the phonebook
    // and preferences.  This occurs immediately in "ShellOwned" mode where
    // the RasEntryDlg API has already returned, but is otherwise deferred
    // until the API is ready to return.
    //
    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        EuCommit( pInfo->pArgs );
    }
    else
    {
        pInfo->pArgs->fCommit = TRUE;
    }
    return TRUE;
}


PEINFO*
PeContext(
    IN HWND hwndPage )

    // Retrieve the property sheet context from a property page handle.
    //
{
    return (PEINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


DWORD
PeCountEnabledLinks(
    IN PEINFO* pInfo )

    // Returns the number of enabled links in the entry.
    //
{
    DWORD c;
    DTLNODE* pNode;

    c = 0;

    for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

        if (pLink->fEnabled)
        {
            ++c;
        }
    }

    TRACE1( "PeCountEnabledLinks=%d", c );
    return c;
}


VOID
PeExit(
    IN PEINFO* pInfo,
    IN DWORD dwError )

    // Forces an exit from the dialog, reporting 'dwError' to the caller.
    // 'PInfo' is the dialog context.
    //
    // Note: This cannot be called during initialization of the first page.
    //       See PeExitInit.
    //
{
    TRACE( "PeExit" );

    // In "ShellOwned" mode where the RasEntryDlg API has already returned,
    // output arguments are not recorded.
    //
    if (!(pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
    {
        pInfo->pArgs->pApiArgs->dwError = dwError;
    }

    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
PeExitInit(
    IN HWND hwndDlg,
    IN EINFO* pEinfo,
    IN DWORD dwError )

    // Utility to report errors within PeInit and other first page
    // initialization.  'HwndDlg' is the dialog window.  'PEinfo' is the
    // common context block, i.e. the PropertySheet argument.  'DwError' is
    // the error that occurred.
    //
{
    // In "ShellOwned" mode where the RasEntryDlg API has already returned,
    // output arguments are not recorded.
    //
    if (!(pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
    {
        pEinfo->pApiArgs->dwError = dwError;
    }

    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


PEINFO*
PeInit(
    IN HWND hwndFirstPage,
    IN EINFO* pArgs )

    // Property sheet level initialization.  'HwndPage' is the handle of the
    // first page.  'PArgs' is the common entry input argument block.
    //
    // Returns address of the context block if successful, NULL otherwise.  If
    // NULL is returned, an appropriate message has been displayed, and the
    // property sheet has been cancelled.
    //
{
    DWORD dwErr;
    DWORD dwOp;
    PEINFO* pInfo;
    HWND hwndDlg;

    TRACE( "PeInit" );

    hwndDlg = GetParent( hwndFirstPage );

    // Allocate the context information block.  Initialize it enough so that
    // it can be destroyed properly, and associate the context with the
    // window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE( "Context NOT allocated" );
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            PeExitInit( hwndDlg, pArgs, ERROR_NOT_ENOUGH_MEMORY );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(PEINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE(" Context NOT set" );
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            Free( pInfo );
            PeExitInit( hwndDlg, pArgs, ERROR_UNKNOWN );
            return NULL;
        }

        TRACE( "Context set" );
    }

    // Position the dialog per API caller's instructions.
    //
    //For whislter bug 238459, we center the Property dialog box on its
    //parent window rather than shift it as before.         gangz
    //
    PositionDlg( hwndDlg,
        0, 
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    // Mess with the title bar gadgets.
    //
    //TweakTitleBar( hwndDlg );

    // Indicate no device has yet been selected.
    //
    pInfo->iDeviceSelected = -1;

    // Indicate the "no security settings for SLIP" popup is appropriate for
    // the entry and has not been viewed yet during this visit.
    //
    if (pArgs->pEntry->dwBaseProtocol == BP_Slip)
    {
        pInfo->fShowSlipPopup = TRUE;
    }

    // Initialize COM which may be needed by netshell calls.
    //
    {
        HRESULT hr;

        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if (hr == RPC_E_CHANGED_MODE)
        {
            hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
        }

        if (hr == S_OK || hr == S_FALSE)
        {
            pInfo->fComInitialized = TRUE;
        }
    }

#if 0
    // Set even fixed tab widths.
    //
    SetEvenTabWidths( hwndDlg, PE_PageCount );
#endif

    return pInfo;
}


VOID
PeTerm(
    IN HWND hwndPage )

    // Property sheet level termination.  Releases the context block.
    // 'HwndPage' is the handle of a property page.
    //
{
    PEINFO* pInfo;

    TRACE( "PeTerm" );

    pInfo = PeContext( hwndPage );
    if (pInfo)
    {
        if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
        {
            EuFree(pInfo->pArgs);
            pInfo->pArgs = NULL;
        }

        if (pInfo->hwndLbDialAnotherFirst)
        {
            GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

#if 0
        if (pInfo->pListEapcfgs)
        {
            DtlDestroyList( pInfo->pListEapcfgs, DestroyEapcfgNode );
        }
#endif

        if (pInfo->fCuInfoInitialized)
        {
            CuFree( &pInfo->cuinfo );
        }

        if (pInfo->fSuInfoInitialized)
        {
            SuFree( &pInfo->suinfo );
        }

        // Cleanup networking page context.
        //
        {
            // Release our UI info callback object after revoking its info.
            //
            if (pInfo->punkUiInfoCallback)
            {
                RevokePeinfoFromUiInfoCallbackObject (pInfo->punkUiInfoCallback);
                ReleaseObj (pInfo->punkUiInfoCallback);
            }

            //!!! Major hack: Get the list view on the networking page
            // to dump its items before the pInfo and pInfo->pNetCfg go away.
            // We have to do this here when we dismiss the property sheet
            // from the General tab.  When this happens, the general page
            // is destroyed first (causing us to wind up here in PeTerm)
            // before the networking page is destroyed.  When the networking
            // page is destroyed, its listview will also get destroyed
            // causing all of its items to be deleted.  If those LVN_ITEMDELETED
            // notifications show up after pInfo and pInfo->pNetCfg are long
            // gone, badness ensues.  We need to solve this by decoupling
            // PeTerm from a WM_DESTROY message and hooking it up to some
            // later notification (like a page callback).
            //
            ListView_DeleteAllItems (pInfo->hwndLvComponents);

            if (pInfo->pNetConUtilities)
            {
                INetConnectionUiUtilities_Release(pInfo->pNetConUtilities);
            }

            if (pInfo->pNetCfg)
            {
                HrUninitializeAndReleaseINetCfg (pInfo->fInitCom,
                    pInfo->pNetCfg, pInfo->fNetCfgLock);
            }

            SetupDiDestroyClassImageList (&pInfo->cild);
        }

        if (pInfo->fComInitialized)
        {
            CoUninitialize();
        }

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}


//----------------------------------------------------------------------------
// General property page (non-VPN)
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
GeDlgProcSingle(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the General page of the Entry Property sheet
    // when in single device mode.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "GeDlgProcS(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, GeLvDevicesCallbackSingle ))
    {
        return TRUE;
    }

    return GeDlgProc( hwnd, unMsg, wparam, lparam );
}


INT_PTR CALLBACK
GeDlgProcMultiple(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the General page of the Entry Property sheet
    // when in multiple device mode.  Parameters and return value are as
    // described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "GeDlgProcS(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, GeLvDevicesCallbackMultiple ))
    {
        return TRUE;
    }

    return GeDlgProc( hwnd, unMsg, wparam, lparam );
}


INT_PTR CALLBACK
GeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the General page of the Entry Property sheet.
    // Called directly for VPNs or called by one of the two non-VPN stubs so
    // 'pInfo' lookup is not required for every messages.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                GeInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwGeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;

                    TRACE( "GeAPPLY" );
                    fValid = PeApply( hwnd );

                    SetWindowLong(
                        hwnd, DWLP_MSGRESULT,
                        (fValid)
                            ? PSNRET_NOERROR
                            : PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                }

                case PSN_RESET:
                {
                    TRACE( "GeRESET" );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    break;
                }

                case LVXN_SETCHECK:
                {
                    PEINFO* pInfo;

                    // An item was just checked or unchecked.
                    //
                    pInfo = PeContext( hwnd );
                    ASSERT( pInfo );
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    GeUpdatePhoneNumberFields( pInfo, FALSE );
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    NM_LISTVIEW* p;

                    p = (NM_LISTVIEW* )lparam;
                    if ((p->uNewState & LVIS_SELECTED)
                        && !(p->uOldState & LVIS_SELECTED))
                    {
                        PEINFO* pInfo;

                        // This item was just selected.
                        //
                        pInfo = PeContext( hwnd );
                        ASSERT( pInfo );
                        if (pInfo == NULL)
                        {
                            break;
                        }
                        GeUpdatePhoneNumberFields( pInfo, FALSE );
                        GeUpdateUpDownButtons( pInfo );
                    }
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return GeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            PeTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
GeAlternates(
    IN PEINFO* pInfo )

    // Called when the "Alternates" button is pressed to popup the alternate
    // phone number dialog.
    //
{
    // Pick up any control window changes into the underlying link so the
    // dialog will reflect them.
    //
    GeGetPhoneFields( pInfo, pInfo->pCurLinkNode );

    if (pInfo->pArgs->fRouter)
    {
        PBLINK* pLink;
        DTLLIST* pListPsz;
        DTLNODE* pNode;

        // TAPI modifiers are not offered in the demand dial connection case,
        // where user enters only a simple string phone number.  The old
        // NT4-style Alternates dialog that allows simple string edits only is
        // used here.  First, must convert the NT5-style list of PBPHONE nodes
        // to a list of PSZ nodes that the old dialog expects.
        //
        pListPsz = DtlCreateList( 0L );
        if (!pListPsz)
        {
            return;
        }

        pLink = (PBLINK* )DtlGetData( pInfo->pCurLinkNode );
        for (pNode = DtlGetFirstNode( pLink->pdtllistPhones );
             pNode;
             pNode = DtlGetNextNode( pNode ) )
        {
            PBPHONE* pPhone;
            DTLNODE* pNodePsz;

            pPhone = (PBPHONE* )DtlGetData( pNode );
            ASSERT( pPhone );
            if (pPhone->pszPhoneNumber && *(pPhone->pszPhoneNumber))
            {
                pNodePsz = CreatePszNode( pPhone->pszPhoneNumber );
                if (pNodePsz)
                {
                    DtlAddNodeLast( pListPsz, pNodePsz );
                }
            }
        }

        // Call the old-sytle Alternates dialog which is shared with the
        // demand dial wizard.
        //
        if (PhoneNumberDlg(
                pInfo->hwndGe, TRUE, pListPsz, &pLink->fPromoteAlternates ))
        {
            // User pressed OK.  Convert back to a PBPHONE node list.
            //
            while (pNode = DtlGetFirstNode( pLink->pdtllistPhones ))
            {
                DtlRemoveNode( pLink->pdtllistPhones, pNode );
                DestroyPhoneNode( pNode );
            }

            for (pNode = DtlGetFirstNode( pListPsz );
                 pNode;
                 pNode = DtlGetNextNode( pNode ) )
            {
                TCHAR* psz;
                DTLNODE* pPhoneNode;
                PBPHONE* pPhone;

                psz = (TCHAR* )DtlGetData( pNode );
                if (!psz)
                {
                    continue;
                }

                pPhoneNode = CreatePhoneNode();
                if (!pPhoneNode)
                {
                    continue;
                }

                pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
                if (!pPhone)
                {
                    continue;
                }

                pPhone->pszPhoneNumber = psz;
                DtlPutData( pNode, NULL );
                DtlAddNodeLast( pLink->pdtllistPhones, pPhoneNode );
            }

            // Refresh the displayed phone number information, since user's
            // edits in the dialog may have changed them.
            //
            GeSetPhoneFields( pInfo, pInfo->pCurLinkNode, FALSE );
        }

        DtlDestroyList( pListPsz, DestroyPszNode );
    }
    else
    {
        // Popup the Alternate Phone Number dialog on the link.
        //
        if (AlternatePhoneNumbersDlg(
                pInfo->hwndDlg, pInfo->pCurLinkNode, pInfo->pListAreaCodes ))
        {
            // User pressed OK.  Refresh the displayed phone number
            // information, since user's edits in the dialog may have changed
            // them.
            //
            GeSetPhoneFields( pInfo, pInfo->pCurLinkNode, FALSE );
        }
    }
}

VOID
GeDialingRules(
    IN PEINFO* pInfo )

    // Called when the "Rules" button is press to popup the tapi
    // dialing rules dialog.
    //
{
    TCHAR pszAreaCode[RAS_MaxPhoneNumber];
    TCHAR pszPhoneNumber[RAS_MaxPhoneNumber];
    DWORD dwErr, dwCountryCode, dwLineId;
    COUNTRY* pCountry = NULL;
    INT iSel;

    TRACE( "GeDialingRules" );

    // Get the current phone number
    //
    GetWindowText ( pInfo->hwndEbPhoneNumber,
                    pszPhoneNumber,
                    sizeof(pszPhoneNumber) / sizeof(TCHAR) );

    // Get the current area code
    //
    GetWindowText ( pInfo->hwndClbAreaCodes,
                    pszAreaCode,
                    sizeof(pszAreaCode) / sizeof(TCHAR) );

    // Get the current country code
    //
    iSel = ComboBox_GetCurSel ( pInfo->hwndLbCountryCodes );
    if (iSel >= 0)
    {
        pCountry = (COUNTRY*) ComboBox_GetItemDataPtr (
                                pInfo->hwndLbCountryCodes, iSel );
    }
    dwCountryCode = (pCountry) ? pCountry->dwCode : 0;

    // Popup TAPI dialing rules dialog.
    //
    dwErr = TapiLocationDlg(
        g_hinstDll,
        &(pInfo->cuinfo.hlineapp),
        pInfo->hwndDlg,
        dwCountryCode,
        pszAreaCode,
        pszPhoneNumber,
        0 );

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadTapiInfo, dwErr, NULL );
    }
}


VOID
GeClearLbDialAnotherFirst(
    IN HWND hwndLbDialAnotherFirst )

    // Clear prerequisite entry list box.  'hwndLbDialAnotherFirst' is the
    // window handle of the listbox control.  context.
    //
{
    PREREQITEM* pItem;

    while (pItem = ComboBox_GetItemDataPtr( hwndLbDialAnotherFirst, 0 ))
    {
        ComboBox_DeleteString( hwndLbDialAnotherFirst, 0 );
        Free0( pItem->pszEntry );
        Free0( pItem->pszPbk );
        Free( pItem );
    }
}


BOOL
GeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "GeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_GE_PB_MoveUp:
        {
            GeMoveDevice( pInfo, TRUE );
            return TRUE;
        }

        case CID_GE_PB_MoveDown:
        {
            GeMoveDevice( pInfo, FALSE );
            return TRUE;
        }

        case CID_GE_PB_Configure:
        {
            GeConfigure( pInfo );
            return TRUE;
        }

        case CID_GE_PB_Alternates:
        {
            GeAlternates( pInfo );
            return TRUE;
        }

        case CID_GE_PB_DialingRules:
        {
            GeDialingRules( pInfo );
            return TRUE;
        }

        case CID_GE_CB_SharedPhoneNumber:
        {
            GeUpdatePhoneNumberFields( pInfo, TRUE );
            return TRUE;
        }

        case CID_GE_CB_UseDialingRules:
        {
            if (CuDialingRulesCbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_GE_LB_CountryCodes:
        {
            if (CuCountryCodeLbHandler( &pInfo->cuinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_GE_CB_DialAnotherFirst:
        {
            GeUpdateDialAnotherFirstState( pInfo );
            return TRUE;
        }

        case CID_GE_LB_DialAnotherFirst:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                GeDialAnotherFirstSelChange( pInfo );
                return TRUE;
            }
            break;
        }

        case CID_GE_LB_Devices:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                DTLLIST* pList;
                DTLNODE* pNode, *pNode2;
                PBLINK * pLink;

                pList = pInfo->pArgs->pEntry->pdtllistLinks;

                // Get node from current selection
                pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
                    pInfo->hwndLbDevices,
                    ComboBox_GetCurSel( pInfo->hwndLbDevices ) );

                if(NULL == pNode)
                {
                    break;
                }

                // Remove selected item from list of links
                // and disable all other links
                DtlRemoveNode ( pList, pNode );

                for (pNode2 = DtlGetFirstNode (pList);
                     pNode2;
                     pNode2 = DtlGetNextNode (pNode2))
                {
                    pLink = (PBLINK* )DtlGetData( pNode2 );
                    pLink->fEnabled = FALSE;
                }

                // Enable selected device and Re-add
                // in list of links at front
                pLink = (PBLINK* )DtlGetData( pNode );
                pLink->fEnabled = TRUE;
                DtlAddNodeFirst( pList, pNode );
            }
            break;
        }
    }

    return FALSE;
}


VOID
GeConfigure(
    IN PEINFO* pInfo )

    // Called when the "Configure" button is pressed to popup the appropriate
    // device configuration dialog.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    PBENTRY* pEntry;
    BOOL fMultilinking = FALSE;

    pEntry = pInfo->pArgs->pEntry;

    // pmay: 245860
    //
    // Need to allow config of null modem speed.
    //
    if ( pEntry->dwType == RASET_Direct )
    {
        INT iSel;

        iSel = ComboBox_GetCurSel( pInfo->hwndLbDevices );
        pNode = (DTLNODE*)
            ComboBox_GetItemDataPtr ( pInfo->hwndLbDevices, iSel );
    }
    else
    {
        pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLvDevices );
        fMultilinking =
            (ListView_GetCheckedCount( pInfo->hwndLvDevices ) > 1
             && pEntry->dwDialMode == RASEDM_DialAll);

    }

    if (!pNode)
    {
        return;
    }
    pLink = (PBLINK* )DtlGetData( pNode );

    DeviceConfigureDlg(
        pInfo->hwndDlg,
        pLink,
        pEntry,
        !fMultilinking,
        pInfo->pArgs->fRouter);
}


VOID
GeDialAnotherFirstSelChange(
    IN PEINFO* pInfo )

    // Called when the prerequisite entry selection changes.  'PInfo' is the
    // property sheet context.
    //
{
    PBENTRY* pEntry;
    PREREQITEM* pItem;
    INT iSel;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialAnotherFirst );
    if (iSel < 0)
    {
        return;
    }

    pEntry = pInfo->pArgs->pEntry;

    Free0( pEntry->pszPrerequisiteEntry );
    Free0( pEntry->pszPrerequisitePbk );

    pItem = (PREREQITEM* )
        ComboBox_GetItemDataPtr( pInfo->hwndLbDialAnotherFirst, iSel );

    if(NULL != pItem)
    {
        pEntry->pszPrerequisiteEntry = StrDup( pItem->pszEntry );
        pEntry->pszPrerequisitePbk = StrDup( pItem->pszPbk );
    }

    
    pEntry->fDirty = TRUE;
}


BOOL
GeFillLbDialAnotherFirst(
    IN PEINFO* pInfo,
    IN BOOL fAbortIfPrereqNotFound )

    // Fill prerequisite entry list box with all non-VPN entries in the
    // phonebook, and select the prerequiste one.  'PInfo' is the property
    // sheet context.  'FAbortIfPrereqNotFound' means the list should not be
    // filled unless the entry's prerequisite entry is found and selected.
    //
    // Returns TRUE if a selection was made, FALSE otherwise.
    //
{
    DWORD i;
    INT iThis;
    INT iSel;
    TCHAR* pszEntry;
    TCHAR* pszPrerequisiteEntry = NULL;
    RASENTRYNAME* pRens;
    RASENTRYNAME* pRen;
    DWORD dwRens;

    GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );

    iSel = -1;
    pszEntry = pInfo->pArgs->pEntry->pszEntryName;

    //
    // Make a dup of this prerequisite entry here. Otherwise
    // this leads to accessing freed memory when _SetCurSelNotify
    // frees pszPrerequisiteEntry - [raos].
    //
    if(NULL != pInfo->pArgs->pEntry->pszPrerequisiteEntry)
    {
        pszPrerequisiteEntry = StrDup(
                        pInfo->pArgs->pEntry->pszPrerequisiteEntry);
    }
    
    if (GetRasEntrynameTable( &pRens, &dwRens ) != 0)
    {
        return FALSE;
    }

    for (i = 0, pRen = pRens; i < dwRens; ++i, ++pRen )
    {
        PREREQITEM* pItem;

        if (lstrcmp( pRen->szEntryName, pszEntry ) == 0)
        {
            continue;
        }

        pItem = Malloc( sizeof(PREREQITEM) );
        if (!pItem)
        {
            continue;
        }

        pItem->pszEntry = StrDup( pRen->szEntryName );
        pItem->pszPbk = StrDup( pRen->szPhonebookPath );

        if (!pItem->pszEntry || !pItem->pszPbk)
        {
            Free0( pItem->pszEntry );
            Free( pItem );
            continue;
        }

        iThis = ComboBox_AddItem(
            pInfo->hwndLbDialAnotherFirst, pItem->pszEntry,  pItem );

        if (pszPrerequisiteEntry && *(pszPrerequisiteEntry)
            && lstrcmp( pItem->pszEntry, pszPrerequisiteEntry ) == 0)
        {
            iSel = iThis;
            ComboBox_SetCurSelNotify( pInfo->hwndLbDialAnotherFirst, iSel );
        }
    }

    Free( pRens );

    if (iSel < 0)
    {
        if (fAbortIfPrereqNotFound)
        {
            GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );
        }
        else
        {
            iSel = 0;
            ComboBox_SetCurSelNotify( pInfo->hwndLbDialAnotherFirst, iSel );
        }
    }

    Free0(pszPrerequisiteEntry);

    return (iSel >= 0);
}


VOID
GeFillLbDevices(
    IN PEINFO* pInfo )

    // Populate the already initialized ListBox of devices, selecting the
    // currently selected item or if none, the first item.  'PInfo' is the
    // property sheet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pSelNode;
    DTLLIST* pListLinks;
    INT iItem;
    INT iSelItem;

    TRACE( "GeFillLbDevices" );

    pSelNode = NULL;
    iSelItem = -1;

    // (Re-)populate the list.
    //
    pListLinks = pInfo->pArgs->pEntry->pdtllistLinks;
    for (pNode = DtlGetFirstNode( pListLinks ), iItem = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++iItem)
    {
        PBLINK* pLink;
        DWORD dwImage;
        TCHAR* pszText;

        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        pszText = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
        if (pszText)
        {
            iItem = ComboBox_AddString( pInfo->hwndLbDevices, pszText );
            ComboBox_SetItemData ( pInfo->hwndLbDevices, iItem, pNode );
            Free (pszText);
        }
    }

    ComboBox_SetCurSelNotify( pInfo->hwndLbDevices, 0 );
}

VOID
GeFillLvDevices(
    IN PEINFO* pInfo )

    // Populate the already initialized ListView of devices, selecting the
    // currently selected item or if none, the first item.  'PInfo' is the
    // property sheet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pSelNode;
    DTLLIST* pListLinks;
    INT iItem;
    INT iSelItem;
    BOOL bFirstTime = TRUE;
    INT cItems;

    TRACE( "GeFillLvDevices" );

    pSelNode = NULL;
    iSelItem = -1;

    if (ListView_GetItemCount( pInfo->hwndLvDevices ) > 0)
    {
        // ListView has been filled.  Lookup the selected link node, if any,
        // then save the check state to the links, and delete all items from
        // the list.
        //
        if (pInfo->iDeviceSelected >= 0)
        {
            pSelNode =
                (DTLNODE* )ListView_GetParamPtr(
                    pInfo->hwndLvDevices, pInfo->iDeviceSelected );
        }

        GeSaveLvDeviceChecks( pInfo );
        ListView_DeleteAllItems( pInfo->hwndLvDevices );

        bFirstTime = FALSE;
    }

    // (Re-)populate the list.
    //
    pListLinks = pInfo->pArgs->pEntry->pdtllistLinks;
    for (pNode = DtlGetFirstNode( pListLinks ), iItem = 0;
         pNode;
         pNode = DtlGetNextNode( pNode ), ++iItem)
    {
        PBLINK* pLink;
        DWORD dwImage;
        TCHAR* pszText;

        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        pszText = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
        if (pszText)
        {
            LV_ITEM item;

            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            item.iItem = iItem;
            item.lParam = (LPARAM )pNode;
            item.pszText = pszText;
            item.cchTextMax = wcslen(pszText) + 1;
            item.iImage = dwImage;

            iItem = ListView_InsertItem( pInfo->hwndLvDevices, &item );
            Free( pszText );

            if (pNode == pSelNode)
            {
                iSelItem = iItem;
                pInfo->iDeviceSelected = iItem;
            }

            /*
            if (pInfo->pArgs->fMultipleDevices)
            {
                ListView_SetCheck(
                    pInfo->hwndLvDevices, iItem, pLink->fEnabled );
            }
            */
        }
    }

    if(pInfo->pArgs->fMultipleDevices)
    {
        INT i = -1;
        while ((i = ListView_GetNextItem(
            pInfo->hwndLvDevices, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, i );
            ASSERT( pNode );

            if(NULL == pNode)
            {
                continue;
            }
            
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT( pLink );
            ListView_SetCheck(
                pInfo->hwndLvDevices, i, pLink->fEnabled);
        }
    }

    if (bFirstTime == TRUE)
    {
        // Add a single column exactly wide enough to fully display
        // the widest member of the list.
        //
        LV_COLUMN col;

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT;
        col.fmt = LVCFMT_LEFT;
        ListView_InsertColumn( pInfo->hwndLvDevices, 0, &col );
        ListView_SetColumnWidth( pInfo->hwndLvDevices, 0, LVSCW_AUTOSIZE_USEHEADER );
    }

    // EuInit creates a bogus device if there are none guaranteeing that the
    // device list is never empty.
    //
    ASSERT( iItem > 0 );

    // Select the previously selected item, or the first item if none.  This
    // will trigger an update of the phone number related controls.  The
    // "previous selection" index is updated to the new index of the same
    // item.
    //
    if (iSelItem >= 0)
    {
        pInfo->iDeviceSelected = iSelItem;
    }
    else
    {
        iSelItem = 0;
    }

    ListView_SetItemState(
        pInfo->hwndLvDevices, iSelItem, LVIS_SELECTED, LVIS_SELECTED );
}


VOID
GeInitLvDevices(
    IN PEINFO* pInfo )

    // Initialize the ListView of devices.
    //
{
    BOOL fChecksInstalled;

    // Install "listview of checkboxes" handling.
    //
    if (pInfo->pArgs->fMultipleDevices)
    {
        fChecksInstalled =
            ListView_InstallChecks( pInfo->hwndLvDevices, g_hinstDll );
        if (!fChecksInstalled)
            return;
    }

    // Set the modem, adapter, and other device images.
    //
    ListView_SetDeviceImageList( pInfo->hwndLvDevices, g_hinstDll );

    // Add a single column exactly wide enough to fully display the widest
    // member of the list.
    //
    ListView_InsertSingleAutoWidthColumn( pInfo->hwndLvDevices );
}


VOID
GeGetPhoneFields(
    IN PEINFO* pInfo,
    OUT DTLNODE* pDstLinkNode )

    // Load the phone number group box field settings into the phone number
    // information of PBLINK node 'pDstLinkNode'.  'PInfo' is the property
    // sheet context.
    //
{
    PBLINK* pLink;
    PBPHONE* pPhone;
    DTLNODE* pPhoneNode;

    TRACE( "GeGetPhoneFields" );

    pLink = (PBLINK* )DtlGetData( pDstLinkNode );
    ASSERT( pLink );

    pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
    if (pPhoneNode)
    {
        CuGetInfo( &pInfo->cuinfo, pPhoneNode );
        FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pPhoneNode );
    }
}


BOOL
GeInit(
    IN HWND hwndPage,
    IN OUT EINFO* pArgs )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.  'PArgs' is the arguments from the PropertySheet caller.
    //
    // Return false if focus was set, true otherwise.
    //
{
    DWORD dwErr;
    PEINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "GeInit" );

    // We're first page, so initialize the property sheet.
    //
    pInfo = PeInit( hwndPage, pArgs );
    if (!pInfo)
    {
        return TRUE;
    }

    pEntry = pInfo->pArgs->pEntry;

    // Initialize page-specific context information.
    //
    pInfo->hwndGe = hwndPage;

    // Initialize the "show icon in the taskbar" button, the lone piece of consistency among
    // the various forms.
    //
    //for bug 154607 whistler, Enable/Disable Show Icon on taskbar 
    //check box according to Policy
    //
    //
    {    
        BOOL fShowStatistics = TRUE;

        NeEnsureNetshellLoaded (pInfo);
        if ( NULL != pInfo->pNetConUtilities)
        {
            fShowStatistics =
            INetConnectionUiUtilities_UserHasPermission(
                        pInfo->pNetConUtilities, NCPERM_Statistics);
        }

        pInfo->hwndCbShowIcon =
               GetDlgItem( hwndPage, CID_GE_CB_ShowIcon );
        ASSERT( pInfo->hwndCbShowIcon );

        if ( pInfo->pArgs->fRouter )
        {
           Button_SetCheck( pInfo->hwndCbShowIcon, FALSE );
           ShowWindow( pInfo->hwndCbShowIcon, SW_HIDE );
         }
         else
        {
           Button_SetCheck(
           pInfo->hwndCbShowIcon, pEntry->fShowMonitorIconInTaskBar );

           if ( !fShowStatistics )
           {
              EnableWindow( pInfo->hwndCbShowIcon, FALSE );
           }
         }
    }
    

    if (pEntry->dwType == RASET_Vpn)
    {
        pInfo->hwndEbHostName =
            GetDlgItem( hwndPage, CID_GE_EB_HostName );
        ASSERT( pInfo->hwndEbHostName );

        pInfo->hwndCbDialAnotherFirst =
            GetDlgItem( hwndPage, CID_GE_CB_DialAnotherFirst );
        ASSERT( pInfo->hwndCbDialAnotherFirst );

        pInfo->hwndLbDialAnotherFirst =
            GetDlgItem( hwndPage, CID_GE_LB_DialAnotherFirst );
        ASSERT( pInfo->hwndLbDialAnotherFirst );

        // Initialize host name, i.e. the "phone number".
        //
        {
            DTLNODE* pNode;
            PBLINK* pLink;
            PBPHONE* pPhone;

            Edit_LimitText( pInfo->hwndEbHostName, RAS_MaxPhoneNumber );

            pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNode );
            pLink = (PBLINK* )DtlGetData( pNode );
            pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNode)
            {
                return TRUE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNode );
            SetWindowText( pInfo->hwndEbHostName, pPhone->pszPhoneNumber );
            DestroyPhoneNode( pNode );
        }

        // Initialize the "dial connected first" controls.
        //
        if (pInfo->pArgs->fRouter)
        {
            Button_SetCheck( pInfo->hwndCbDialAnotherFirst, FALSE );
            EnableWindow( pInfo->hwndCbDialAnotherFirst, FALSE );
            ShowWindow( pInfo->hwndCbDialAnotherFirst, SW_HIDE );
            EnableWindow( pInfo->hwndLbDialAnotherFirst, FALSE );
            ShowWindow(pInfo->hwndLbDialAnotherFirst, SW_HIDE );

            ShowWindow(
                GetDlgItem( hwndPage, CID_GE_GB_FirstConnect ),
                SW_HIDE );

            ShowWindow(
                GetDlgItem( hwndPage, CID_GE_ST_Explain ),
                SW_HIDE );
        }
        else
        {
            BOOL fEnableLb;

            fEnableLb = FALSE;
            if (pEntry->pszPrerequisiteEntry
                 && *(pEntry->pszPrerequisiteEntry))
            {
                if (GeFillLbDialAnotherFirst( pInfo, TRUE ))
                {
                    fEnableLb = TRUE;
                }
                else
                {
                    // Don't enable the listbox if the prerequisite entry
                    // defined no longer exists.  See bug 220420.
                    //
                    Free0( pEntry->pszPrerequisiteEntry );
                    pEntry->pszPrerequisiteEntry = NULL;
                    Free0( pEntry->pszPrerequisitePbk );
                    pEntry->pszPrerequisitePbk = NULL;
                }
            }

            Button_SetCheck( pInfo->hwndCbDialAnotherFirst, fEnableLb );
            EnableWindow( pInfo->hwndLbDialAnotherFirst, fEnableLb );

            if (pArgs->fDisableFirstConnect)
            {
                EnableWindow( pInfo->hwndCbDialAnotherFirst, FALSE );
                EnableWindow( pInfo->hwndLbDialAnotherFirst, FALSE );
            }
        }

        return TRUE;
    }
    else if (pEntry->dwType == RASET_Broadband)
    {
        pInfo->hwndEbBroadbandService =
            GetDlgItem( hwndPage, CID_GE_EB_ServiceName );
        ASSERT( pInfo->hwndEbBroadbandService );

        // Initialize host name, i.e. the "phone number".
        //
        {
            DTLNODE* pNode;
            PBLINK* pLink;
            PBPHONE* pPhone;

            Edit_LimitText( pInfo->hwndEbBroadbandService, RAS_MaxPhoneNumber );

            pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
            ASSERT( pNode );
            pLink = (PBLINK* )DtlGetData( pNode );
            pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

            if(NULL == pNode)
            {
                return TRUE;
            }
            
            pPhone = (PBPHONE* )DtlGetData( pNode );
            SetWindowText( pInfo->hwndEbBroadbandService, pPhone->pszPhoneNumber );
            DestroyPhoneNode( pNode );
        }

        return TRUE;
    }    
    else if (pEntry->dwType == RASET_Phone)
    {
        if (pArgs->fMultipleDevices)
        {
            pInfo->hwndLvDevices =
                GetDlgItem( hwndPage, CID_GE_LV_Devices );
            ASSERT( pInfo->hwndLvDevices );

            pInfo->hwndPbUp =
                GetDlgItem( hwndPage, CID_GE_PB_MoveUp );
            ASSERT( pInfo->hwndPbUp );

            pInfo->hwndPbDown =
                GetDlgItem( hwndPage, CID_GE_PB_MoveDown );
            ASSERT( pInfo->hwndPbDown );

            pInfo->hwndCbSharedPhoneNumbers =
                GetDlgItem( hwndPage, CID_GE_CB_SharedPhoneNumber );
            ASSERT( pInfo->hwndCbSharedPhoneNumbers );
        }
        else
        {
            // The listview has a different control-ID in single mode so that
            // a different help context can be provided.
            //
            pInfo->hwndLvDevices =
                GetDlgItem( hwndPage, CID_GE_LV_Device );
            ASSERT( pInfo->hwndLvDevices );
        }

        pInfo->hwndPbConfigureDevice =
            GetDlgItem( hwndPage, CID_GE_PB_Configure );
        ASSERT( pInfo->hwndPbConfigureDevice );
        if ( pEntry->fGlobalDeviceSettings )
        {
            // Whislter bug 281306.  If the entry is set up to use
            // control panel settings, then hide the option that
            // allows users to configure the devices per-phonebook.
            //
            ShowWindow( pInfo->hwndPbConfigureDevice, SW_HIDE );
        }

        pInfo->hwndStPhoneNumber =
            GetDlgItem( hwndPage, CID_GE_ST_PhoneNumber );
        ASSERT( pInfo->hwndStPhoneNumber );

        pInfo->hwndEbPhoneNumber =
            GetDlgItem( hwndPage, CID_GE_EB_PhoneNumber );
        ASSERT( pInfo->hwndEbPhoneNumber );

        pInfo->hwndPbAlternates =
            GetDlgItem( hwndPage, CID_GE_PB_Alternates );
        ASSERT( pInfo->hwndPbAlternates );

        if (!pInfo->pArgs->fRouter)
        {
            pInfo->hwndGbPhoneNumber =
                GetDlgItem( hwndPage, CID_GE_GB_PhoneNumber );
            ASSERT( pInfo->hwndGbPhoneNumber );

            pInfo->hwndStAreaCodes =
                GetDlgItem( hwndPage, CID_GE_ST_AreaCodes );
            ASSERT( pInfo->hwndStAreaCodes );

            pInfo->hwndClbAreaCodes =
                GetDlgItem( hwndPage, CID_GE_CLB_AreaCodes );
            ASSERT( pInfo->hwndClbAreaCodes );

            pInfo->hwndStCountryCodes =
                GetDlgItem( hwndPage, CID_GE_ST_CountryCodes );
            ASSERT( pInfo->hwndStCountryCodes );

            pInfo->hwndLbCountryCodes =
                GetDlgItem( hwndPage, CID_GE_LB_CountryCodes );
            ASSERT( pInfo->hwndLbCountryCodes );

            pInfo->hwndCbUseDialingRules =
                GetDlgItem( hwndPage, CID_GE_CB_UseDialingRules );
            ASSERT( pInfo->hwndCbUseDialingRules );

            pInfo->hwndPbDialingRules =
                GetDlgItem( hwndPage, CID_GE_PB_DialingRules );
            ASSERT( pInfo->hwndPbDialingRules );
        }

        if (pArgs->fMultipleDevices)
        {
            // Set the shared phone number checkbox.
            //
            Button_SetCheck(
                pInfo->hwndCbSharedPhoneNumbers, pEntry->fSharedPhoneNumbers );

            // Load the icons into the move up and move down buttons.  From
            // what I can tell tell in MSDN, you don't have to close or
            // destroy the icon handle.
            //
            pInfo->hiconUpArr = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_UpArr ), IMAGE_ICON, 0, 0, 0 );
            pInfo->hiconDnArr = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_DnArr ), IMAGE_ICON, 0, 0, 0 );
            pInfo->hiconUpArrDis = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_UpArrDis ), IMAGE_ICON, 0, 0, 0 );
            pInfo->hiconDnArrDis = LoadImage(
                g_hinstDll, MAKEINTRESOURCE( IID_DnArrDis ), IMAGE_ICON, 0, 0, 0 );
        }

        pInfo->pListAreaCodes = DtlDuplicateList(
            pInfo->pArgs->pUser->pdtllistAreaCodes,
            DuplicatePszNode, DestroyPszNode );

        CuInit( &pInfo->cuinfo,
            pInfo->hwndStAreaCodes, pInfo->hwndClbAreaCodes,
            pInfo->hwndStPhoneNumber, pInfo->hwndEbPhoneNumber,
            pInfo->hwndStCountryCodes, pInfo->hwndLbCountryCodes,
            pInfo->hwndCbUseDialingRules, pInfo->hwndPbDialingRules,
            pInfo->hwndPbAlternates,
            NULL, NULL,
            pInfo->pListAreaCodes );

        pInfo->fCuInfoInitialized = TRUE;

        // Configure and populate the device list, selecting the first item.
        //
        GeInitLvDevices( pInfo );
        GeFillLvDevices( pInfo );

        // Set initial focus.
        //
        if (pArgs->fMultipleDevices)
        {
            SetFocus( pInfo->hwndLvDevices );
        }
        else
        {
            ASSERT( IsWindowEnabled( pInfo->hwndEbPhoneNumber ) );
            SetFocus( pInfo->hwndEbPhoneNumber );
            Edit_SetSel( pInfo->hwndEbPhoneNumber, 0, -1 );
        }

        return FALSE;
    }
    else
    {
        ASSERT( pEntry->dwType == RASET_Direct );

        // The listview has a different control-ID in single mode so that
        // a different help context can be provided.
        //
        pInfo->hwndLbDevices =
            GetDlgItem( hwndPage, CID_GE_LB_Devices );
        ASSERT( pInfo->hwndLbDevices );

        // Configure and populate the device list, selecting the first item.
        //
        GeFillLbDevices( pInfo );
    }

    return TRUE;
}


LVXDRAWINFO*
GeLvDevicesCallbackMultiple(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, 0, { 0 } };

    return &info;
}


LVXDRAWINFO*
GeLvDevicesCallbackSingle(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Set up to emulate a static text control but with icon on left.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, LVXDI_DxFill, { LVXDIA_Static } };

    return &info;
}


VOID
GeMoveDevice(
    IN PEINFO* pInfo,
    IN BOOL fUp )

    // Refill the ListView of devices with the selected item moved up or down
    // one position.  'FUp' is set to move up, otherwise moves down.  'PInfo'
    // is the property sheeet context.
    //
{
    DTLNODE* pNode;
    DTLNODE* pPrevNode;
    DTLNODE* pNextNode;
    DTLLIST* pList;

    if (pInfo->iDeviceSelected < 0)
    {
        return;
    }

    pNode =
        (DTLNODE* )ListView_GetParamPtr(
            pInfo->hwndLvDevices, pInfo->iDeviceSelected );
    ASSERT( pNode );

    if(NULL == pNode)
    {
        return;
    }

    pList = pInfo->pArgs->pEntry->pdtllistLinks;

    if (fUp)
    {
        pPrevNode = DtlGetPrevNode( pNode );
        if (!pPrevNode)
        {
            return;
        }

        DtlRemoveNode( pList, pNode );
        DtlAddNodeBefore( pList, pPrevNode, pNode );
    }
    else
    {
        pNextNode = DtlGetNextNode( pNode );
        if (!pNextNode)
        {
            return;
        }

        DtlRemoveNode( pList, pNode );
        DtlAddNodeAfter( pList, pNextNode, pNode );
    }

    GeFillLvDevices( pInfo );
}


DWORD
GeSaveLvDeviceChecks(
    IN PEINFO* pInfo )

    // Mark links enabled/disabled based on it's check box in the ListView of
    // devices.  Returns the count of enabled devices.
    //
{
    DWORD dwCount = 0;

    if (pInfo->pArgs->fMultipleDevices)
    {
        INT i;

        i = -1;
        while ((i = ListView_GetNextItem(
            pInfo->hwndLvDevices, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNode;
            PBLINK* pLink;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, i );
            ASSERT( pNode );
            if(NULL == pNode)
            {
                return 0;
            }
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT( pLink );
            pLink->fEnabled = ListView_GetCheck( pInfo->hwndLvDevices, i );
            dwCount += (pLink->fEnabled) ? 1 : 0;
        }
    }

    return dwCount;
}


VOID
GeSetPhoneFields(
    IN PEINFO* pInfo,
    IN DTLNODE* pSrcLinkNode,
    IN BOOL fDisableAll )

    // Set the phone number group box fields from the phone information in
    // PBLINK node 'pSrcLinkNode'.  'PInfo' is the property sheet context.
    //
{
    PBLINK* pLink;
    DTLNODE* pPhoneNode;

    TRACE( "GeSetPhoneFields" );

    pLink = (PBLINK* )DtlGetData( pSrcLinkNode );
    ASSERT( pLink );

    pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
    if (pPhoneNode)
    {
        CuSetInfo( &pInfo->cuinfo, pPhoneNode, fDisableAll );
        DestroyPhoneNode( pPhoneNode );
    }
}


VOID
GeUpdateDialAnotherFirstState(
    IN PEINFO* pInfo )

    // Update the prequisite entry controls.  'PInfo' is the property sheet
    // context.
    //
{
    if (Button_GetCheck( pInfo->hwndCbDialAnotherFirst ))
    {
        GeFillLbDialAnotherFirst( pInfo, FALSE );
        EnableWindow( pInfo->hwndLbDialAnotherFirst, TRUE );
    }
    else
    {
        GeClearLbDialAnotherFirst( pInfo->hwndLbDialAnotherFirst );
        EnableWindow( pInfo->hwndLbDialAnotherFirst, FALSE );
    }
}


VOID
GeUpdatePhoneNumberFields(
    IN PEINFO* pInfo,
    IN BOOL fSharedToggle )

    // Called when anything affecting the Phone Number group of controls
    // occurs.  'PInfo' is the property sheet context.  'FSharedToggle' is set
    // when the update is due to the toggling of the shared phone number
    // checkbox.
    //
{
    INT i;
    BOOL fShared;
    DTLNODE* pNode;
    PBLINK* pLink;

    TRACE( "GeUpdatePhoneNumberFields" );

    if (pInfo->pArgs->fMultipleDevices)
    {
        fShared = Button_GetCheck( pInfo->hwndCbSharedPhoneNumbers );
    }
    else
    {
        fShared = TRUE;
        ASSERT( !fSharedToggle );
    }

    if (pInfo->iDeviceSelected >= 0)
    {
        // A device was previously selected.
        //
        pNode = (DTLNODE* )ListView_GetParamPtr(
            pInfo->hwndLvDevices, pInfo->iDeviceSelected );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return;
        }

        if (fShared)
        {
            if (fSharedToggle)
            {
                // Shared-mode just toggled on.  Update the selected node from
                // the controls, then copy it's phone settings to the shared
                // node.
                //
                GeGetPhoneFields( pInfo, pNode );
                CopyLinkPhoneNumberInfo( pInfo->pArgs->pSharedNode, pNode );
            }
            else
            {
                // Update the shared node from the controls.
                //
                GeGetPhoneFields( pInfo, pInfo->pArgs->pSharedNode );
            }
        }
        else
        {
            if (fSharedToggle)
            {
                // Shared-mode just toggled off.  Update the shared node from
                // the controls, then copy it's phone settings to the selected
                // node.
                //
                GeGetPhoneFields( pInfo, pInfo->pArgs->pSharedNode );
                CopyLinkPhoneNumberInfo( pNode, pInfo->pArgs->pSharedNode );
            }
            else
            {
                // Update the previously selected node from the controls.
                //
                GeGetPhoneFields( pInfo, pNode );
            }
        }
    }

    // Load the phone number fields and title with the phone number for the
    // selected link.  Save the selected device index in the context block so
    // we'll know where to swap out the phone number when the selection
    // changes.
    //
    i = ListView_GetNextItem( pInfo->hwndLvDevices, -1, LVIS_SELECTED );
    pInfo->iDeviceSelected = i;
    if (i < 0)
    {
        // No device is currently selected.  This occurs because a new
        // selection generates first an "unselect" event, then a separate
        // "select" event.
        //
        return;
    }

    // Set the phone number fields including group box title, all
    // enabling/disabling, and "blanked" handling of area code and country
    // code.  The entire phone number group is disabled when in separate
    // number mode with the selected device unchecked.
    //
    if (fShared)
    {
        pInfo->pCurLinkNode = pInfo->pArgs->pSharedNode;
        GeUpdatePhoneNumberTitle( pInfo, NULL );
        GeSetPhoneFields( pInfo, pInfo->pArgs->pSharedNode, FALSE );
    }
    else
    {
        pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, i );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return;
        }
        
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        if(NULL == pLink)
        {
            return;
        }

        pInfo->pCurLinkNode = pNode;
        GeUpdatePhoneNumberTitle( pInfo, pLink->pbport.pszDevice );
        GeSetPhoneFields( pInfo, pNode,
            !(ListView_GetCheck( pInfo->hwndLvDevices, i )) );
    }

    // When the enabled device count falls below 2 the "Multiple Devices"
    // group box and contained controls on the Options page are disabled.  If
    // 2 or above it is enabled.
    //
    if (pInfo->hwndOe && pInfo->pArgs->fMultipleDevices)
    {
        DWORD cChecked;

        cChecked = ListView_GetCheckedCount( pInfo->hwndLvDevices );
        OeEnableMultipleDeviceGroup( pInfo, (cChecked > 1) );
    }
}


VOID
GeUpdatePhoneNumberTitle(
    IN PEINFO* pInfo,
    IN TCHAR* pszDevice )

    // Update the Phone Number group box title based on the "share" mode.
    // 'PInfo' is the property sheet context.  'PszDevice' is the device name
    // string to display in non-shared mode or NULL in shared mode.
    //
{
    if (!pInfo->hwndGbPhoneNumber)
    {
        return;
    }

    if (pszDevice)
    {
        TCHAR* psz;
        TCHAR* pszFormat;

        // Set the individual title, e.g. "Phone number for K-Tel 28.8
        // Fax/Plus".
        //
        pszFormat = PszFromId( g_hinstDll, SID_LinkPhoneNumber );
        if (pszFormat)
        {
            psz = Malloc(
                (lstrlen( pszFormat ) + lstrlen( pszDevice ))
                 * sizeof(TCHAR) );
            if (psz)
            {
                wsprintf( psz, pszFormat, pszDevice );
                SetWindowText( pInfo->hwndGbPhoneNumber, psz );
                Free( psz );
            }

            Free( pszFormat );
        }
    }
    else
    {
        TCHAR* psz;

        // Set the shared title, e.g. "Phone number".
        //
        psz = PszFromId( g_hinstDll, SID_SharedPhoneNumber );
        if (psz)
        {
            SetWindowText( pInfo->hwndGbPhoneNumber, psz );
            Free( psz );
        }
    }
}


VOID
GeUpdateUpDownButtons(
    IN PEINFO* pInfo )

    // Update the enable/disable and corresponding icon for the
    // move-up/move-down buttons.  Moves focus and default button as
    // necessary.  'PInfo' is the property sheet context.
    //
{
    INT iSel;
    INT cItems;
    BOOL fSel;

    if (!pInfo->pArgs->fMultipleDevices)
    {
        return;
    }

    iSel = ListView_GetNextItem( pInfo->hwndLvDevices, -1, LVNI_SELECTED );
    fSel = (iSel >= 0);
    cItems = ListView_GetItemCount( pInfo->hwndLvDevices );

    // "Up" button, enabled if there is an item above.
    //
    if (iSel > 0)
    {
        EnableWindow( pInfo->hwndPbUp, TRUE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbUp, FALSE );
        SendMessage( pInfo->hwndPbUp, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconUpArrDis );
    }

    // "Down" button, enabled if there is an item below.
    //
    if (fSel && (iSel < cItems - 1))
    {
        EnableWindow( pInfo->hwndPbDown, TRUE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArr );
    }
    else
    {
        EnableWindow( pInfo->hwndPbDown, FALSE );
        SendMessage( pInfo->hwndPbDown, BM_SETIMAGE, IMAGE_ICON,
            (LPARAM )pInfo->hiconDnArrDis );
    }

    // if the focus button is disabled, move focus to the ListView and make OK
    // the default button.
    //
    if (!IsWindowEnabled( GetFocus() ))
    {
        SetFocus( pInfo->hwndLvDevices );
        Button_MakeDefault( pInfo->hwndDlg,
            GetDlgItem( pInfo->hwndDlg, IDOK ) );
    }
}


//----------------------------------------------------------------------------
// Options property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
OeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Options page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
#if 0
    TRACE4( "OeDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return OeInit( hwnd );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            if (pInfo->pArgs->fRouter)
            {
                ContextHelp( g_adwOeRouterHelp, hwnd, unMsg, wparam, lparam );
            }
            else
            {
                ContextHelp( g_adwOeHelp, hwnd, unMsg, wparam, lparam );
            }
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return OeCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    // Because of inter-page dependencies on the 'fAutoLogon'
                    // flag the User/password and subordinate checkbox states
                    // must be reinitialized at each activation.
                    //
                    OeUpdateUserPwState( pInfo );
                    break;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
OeCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "OeCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_OE_CB_PreviewUserPw:
        {
            pInfo->pArgs->pEntry->fPreviewUserPw =
                Button_GetCheck( pInfo->hwndCbPreviewUserPw );
            OeUpdateUserPwState( pInfo );
            return TRUE;
        }

        case CID_OE_CB_PreviewDomain:
        {
            pInfo->pArgs->pEntry->fPreviewDomain =
                Button_GetCheck( pInfo->hwndCbPreviewDomain );
            return TRUE;
        }

        case CID_OE_PB_Configure:
        {
            MultiLinkDialingDlg( pInfo->hwndDlg, pInfo->pArgs->pEntry );
            return TRUE;
        }

        case CID_OE_PB_X25:
        {
            OeX25( pInfo );
            return TRUE;
        }

        case CID_OE_PB_Tunnel:
        {
            OeTunnel( pInfo );
            return TRUE;
        }

        case CID_OE_LB_MultipleDevices:
        {
            pInfo->pArgs->pEntry->dwDialMode =
                (DWORD)ComboBox_GetItemData( pInfo->hwndLbMultipleDevices,
                    ComboBox_GetCurSel( pInfo->hwndLbMultipleDevices ) );

            EnableWindow( pInfo->hwndPbConfigureDialing,
                !!(pInfo->pArgs->pEntry->dwDialMode == RASEDM_DialAsNeeded) );
                
            return TRUE;
        }

        case CID_OE_RB_Persistent:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    ComboBox_SetCurSel( pInfo->hwndLbIdleTimes, 0 );
                    EnableWindow( pInfo->hwndLbIdleTimes, FALSE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_OE_RB_DemandDial:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    EnableWindow( pInfo->hwndLbIdleTimes, TRUE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_OE_PB_Callback:
        {
            RouterCallbackDlg ( pInfo->hwndOe, pInfo->pArgs );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
OeEnableMultipleDeviceGroup(
    IN PEINFO* pInfo,
    IN BOOL fEnable )

    // Enable/disable the Multiple Devices groupbox and all controls it
    // contains based on 'fEnable'.  'PInfo' is the property sheet context.
    //
{
    EnableWindow( pInfo->hwndGbMultipleDevices, fEnable );
    EnableWindow( pInfo->hwndLbMultipleDevices, fEnable );
    EnableWindow( pInfo->hwndPbConfigureDialing,
        (fEnable
         && !!(pInfo->pArgs->pEntry->dwDialMode == RASEDM_DialAsNeeded)) );
}


BOOL
OeInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;
    LBTABLEITEM* pItem;
    HWND hwndLb;
    INT i;
    INT iSel;
    HWND hwndUdRedialAttempts;

    static LBTABLEITEM aRedialTimes[] =
    {
        SID_Time1s,  1,
        SID_Time3s,  3,
        SID_Time5s,  5,
        SID_Time10s, 10,
        SID_Time30s, 30,
        SID_Time1m,  60,
        SID_Time2m,  120,
        SID_Time5m,  300,
        SID_Time10m, RAS_RedialPause10m,
        0, 0
    };

    static LBTABLEITEM aIdleTimes[] =
    {
        SID_TimeNever, 0,
        SID_Time1m,    60,
        SID_Time5m,    300,
        SID_Time10m,   600,
        SID_Time20m,   1200,    //Add for whistler bug 307969
        SID_Time30m,   1800,
        SID_Time1h,    3600,
        SID_Time2h,    7200,
        SID_Time4h,    14400,
        SID_Time8h,    28800,
        SID_Time24h,   86400,
        0, 0
    };

    static LBTABLEITEM aMultipleDeviceOptions[] =
    {
        SID_DialOnlyFirst, 0,
        SID_DialAll,       RASEDM_DialAll,
        SID_DialNeeded,    RASEDM_DialAsNeeded,
        0, 0
    };

    TRACE( "OeInit" );

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    pEntry = pInfo->pArgs->pEntry;

    // Initialize page-specific context information.
    //
    pInfo->hwndOe = hwndPage;

    // Initialize 'Dialing options' group box.
    //
    if (!pInfo->pArgs->fRouter)
    {
        pInfo->hwndCbDisplayProgress =
            GetDlgItem( hwndPage, CID_OE_CB_DisplayProgress );
        ASSERT( pInfo->hwndCbDisplayProgress );
        Button_SetCheck(
            pInfo->hwndCbDisplayProgress, pEntry->fShowDialingProgress );

        pInfo->hwndCbPreviewUserPw =
            GetDlgItem( hwndPage, CID_OE_CB_PreviewUserPw );
        ASSERT( pInfo->hwndCbPreviewUserPw );
        pInfo->fPreviewUserPw = pEntry->fPreviewUserPw;
        Button_SetCheck( pInfo->hwndCbPreviewUserPw, pInfo->fPreviewUserPw );

        pInfo->hwndCbPreviewDomain =
            GetDlgItem( hwndPage, CID_OE_CB_PreviewDomain );
        ASSERT( pInfo->hwndCbPreviewDomain );
        pInfo->fPreviewDomain = pEntry->fPreviewDomain;
        Button_SetCheck( pInfo->hwndCbPreviewDomain, pInfo->fPreviewDomain );

        if (pEntry->dwType == RASET_Phone)
        {
            pInfo->hwndCbPreviewNumber =
                GetDlgItem( hwndPage, CID_OE_CB_PreviewNumber );
            ASSERT( pInfo->hwndCbPreviewNumber );
            Button_SetCheck(
                pInfo->hwndCbPreviewNumber, pEntry->fPreviewPhoneNumber );
        }
    }

    // Initialize 'Redialing options' group box.  In the 'fRouter' case this
    // includes both the 'Dialing policy' and 'Connection type' group boxes.
    //
    {
        // Redial attempts.
        //
        pInfo->hwndEbRedialAttempts =
            GetDlgItem( hwndPage, CID_OE_EB_RedialAttempts );
        ASSERT( pInfo->hwndEbRedialAttempts );

        hwndUdRedialAttempts = CreateUpDownControl(
            WS_CHILD + WS_VISIBLE + WS_BORDER + UDS_SETBUDDYINT
                + UDS_ALIGNRIGHT + UDS_NOTHOUSANDS + UDS_ARROWKEYS,
            0, 0, 0, 0, hwndPage, 100, g_hinstDll, pInfo->hwndEbRedialAttempts,
            UD_MAXVAL, 0, 0 );
        ASSERT( hwndUdRedialAttempts );
        Edit_LimitText( pInfo->hwndEbRedialAttempts, 9 );
        SetDlgItemInt( hwndPage, CID_OE_EB_RedialAttempts,
            pEntry->dwRedialAttempts, FALSE );

        // Redial times.
        //
        pInfo->hwndLbRedialTimes =
            GetDlgItem( hwndPage, CID_OE_LB_RedialTimes );
        ASSERT( pInfo->hwndLbRedialTimes );

        {
            iSel = -1;
            for (pItem = aRedialTimes, i = 0;
                 pItem->sidItem;
                 ++pItem, ++i )
            {
                ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbRedialTimes,
                    pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData ));

                if (iSel < 0
                    && pEntry->dwRedialSeconds <= pItem->dwData)
                {
                    iSel = i;
                    ComboBox_SetCurSel( pInfo->hwndLbRedialTimes, iSel );
                }
            }

            if (iSel < 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbRedialTimes, i - 1 );
            }
        }

        // Idle times.
        //
        pInfo->hwndLbIdleTimes =
            GetDlgItem( hwndPage, CID_OE_LB_IdleTimes );
        ASSERT( pInfo->hwndLbIdleTimes );

        {
            if (pEntry->lIdleDisconnectSeconds < 0)
            {
                pEntry->lIdleDisconnectSeconds = 0;
            }

            iSel = -1;
            for (pItem = aIdleTimes, i = 0;
                 pItem->sidItem;
                 ++pItem, ++i )
            {
                ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbIdleTimes,
                    pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

                if (iSel < 0
                    && pEntry->lIdleDisconnectSeconds <= (LONG )pItem->dwData)
                {
                    iSel = i;
                    ComboBox_SetCurSel( pInfo->hwndLbIdleTimes, iSel );
                }
            }

            if (iSel < 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbIdleTimes, i - 1 );
            }
        }

        if (pInfo->pArgs->fRouter)
        {
            HWND hwndRb;

            //for whistler bug 294271, initialize the window handlers for
            //multiple device group         gangz
            //
            pInfo->hwndGbMultipleDevices =
                GetDlgItem( hwndPage, CID_OE_GB_MultipleDevices );
            ASSERT( pInfo->hwndGbMultipleDevices );

            pInfo->hwndLbMultipleDevices =
                GetDlgItem( hwndPage, CID_OE_LB_MultipleDevices );
            ASSERT( pInfo->hwndLbMultipleDevices );

            pInfo->hwndPbConfigureDialing =
                GetDlgItem( hwndPage, CID_OE_PB_Configure );
            ASSERT( pInfo->hwndPbConfigureDialing );
        
            // Connection type radio buttons.
            //
            pInfo->hwndRbDemandDial =
                GetDlgItem( hwndPage, CID_OE_RB_DemandDial );
            ASSERT( pInfo->hwndRbDemandDial );

            pInfo->hwndRbPersistent =
                GetDlgItem( hwndPage, CID_OE_RB_Persistent );
            ASSERT( pInfo->hwndRbPersistent );

            hwndRb =
                (pEntry->fRedialOnLinkFailure)
                    ? pInfo->hwndRbPersistent
                    : pInfo->hwndRbDemandDial;

            SendMessage( hwndRb, BM_CLICK, 0, 0 );
        }
        else
        {
            // Redial on link failure
            //
            pInfo->hwndCbRedialOnDrop =
                GetDlgItem( hwndPage, CID_OE_CB_RedialOnDrop );
            ASSERT( pInfo->hwndCbRedialOnDrop );

            Button_SetCheck(
                pInfo->hwndCbRedialOnDrop, pEntry->fRedialOnLinkFailure );
        }
    }

    // Initialize 'Multiple devices' group box.
    //
    if (pEntry->dwType == RASET_Phone)
    {
        pInfo->hwndGbMultipleDevices =
            GetDlgItem( hwndPage, CID_OE_GB_MultipleDevices );
        ASSERT( pInfo->hwndGbMultipleDevices );

        pInfo->hwndLbMultipleDevices =
            GetDlgItem( hwndPage, CID_OE_LB_MultipleDevices );
        ASSERT( pInfo->hwndLbMultipleDevices );

        pInfo->hwndPbConfigureDialing =
            GetDlgItem( hwndPage, CID_OE_PB_Configure );
        ASSERT( pInfo->hwndPbConfigureDialing );

        {
            iSel = -1;
            for (pItem = aMultipleDeviceOptions, i = 0;
                 pItem->sidItem;
                 ++pItem, ++i )
            {
                ComboBox_AddItemFromId(
                    g_hinstDll, pInfo->hwndLbMultipleDevices,
                    pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

                if (pEntry->dwDialMode == pItem->dwData)
                {
                    iSel = i;
                    ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, iSel );
                }
            }

            if (iSel < 0)
            {
                ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, 0 );
            }
        }

        if (pInfo->pArgs->fMultipleDevices)
        {
            DWORD cChecked;

            // When the enabled device count falls below 2 the "Multiple
            // Devices" group box and contained controls are disabled.  If 2
            // or above it is enabled.
            //
            if (pInfo->hwndLvDevices)
            {
                cChecked = ListView_GetCheckedCount( pInfo->hwndLvDevices );
                OeEnableMultipleDeviceGroup( pInfo, (cChecked > 1) );
            }
        }
        else
        {
            ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
            ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
            ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
        }
    }
    else if (pInfo->pArgs->fRouter && pEntry->dwType == RASET_Vpn)
    {
        // Make sure that a VPN demand dial interface can't be configured for
        // multilink.
        //
        ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, 0 );
        ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
    }
    else if (pEntry->dwType == RASET_Broadband)
    {
        // Make sure that broadband connections can't be multilinked since
        // it is not possible to select multiple ports.
        //
        ComboBox_SetCurSel( pInfo->hwndLbMultipleDevices, 0 );
        ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
    }
    else if ( pEntry->dwType == RASET_Direct )
    {   
      //for whistler bug 294271, initialize the window handlers for
      //multiple device group         gangz
      //
        ShowWindow( pInfo->hwndGbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndLbMultipleDevices, SW_HIDE );
        ShowWindow( pInfo->hwndPbConfigureDialing, SW_HIDE );
    }

    // Bug 261692: Don't show X.25 button unless "phone" type entry.
    //
    if (pInfo->pArgs->fRouter && pEntry->dwType != RASET_Phone)
    {
        pInfo->hwndPbX25 = GetDlgItem( hwndPage, CID_OE_PB_X25 );
        ASSERT( pInfo->hwndPbX25 );

        ShowWindow( pInfo->hwndPbX25, SW_HIDE );
        EnableWindow( pInfo->hwndPbX25, FALSE );
    }

    return TRUE;
}


VOID
OeTunnel(
    IN PEINFO* pInfo )

    // Called when the "Virtual (tunnel) connection" button is pressed to
    // chain the VPN add entry wizard.
    //
{
    //!!!
}


VOID
OeUpdateUserPwState(
    IN PEINFO* pInfo )

    // Called to update the enabled/disabled save/restore state of the
    // User/password and Domain checkboxes.
    //
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    EnableCbWithRestore(
        pInfo->hwndCbPreviewUserPw,
        !pEntry->fAutoLogon,
        FALSE,
        &pInfo->fPreviewUserPw );

    EnableCbWithRestore(
        pInfo->hwndCbPreviewDomain,
        !pEntry->fAutoLogon,
        FALSE,
        &pInfo->fPreviewDomain );
}


VOID
OeX25(
    IN PEINFO* pInfo )

    // Called when the X.25 button is pressed to popup the X.25 settings
    // dialog.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    BOOL fLocalPad;
    INT iSel;

    // Figure out if the selected device is a local PAD device.
    //
    fLocalPad = FALSE;
    iSel = ListView_GetNextItem( pInfo->hwndLvDevices, -1, LVNI_SELECTED );
    if (iSel >= 0)
    {
        pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLvDevices, iSel );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return;
        }
        
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        if (pLink->pbport.pbdevicetype == PBDT_Pad)
        {
            fLocalPad = TRUE;
        }
    }

    // Popup the X.25 dialog which saves directly to the common context
    // 'pEntry' if user makes changes.
    //
    X25LogonSettingsDlg( pInfo->hwndDlg, fLocalPad, pInfo->pArgs->pEntry );
}


//----------------------------------------------------------------------------
// Security property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
LoDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Security page of the Entry property sheet
    // "Lo" is for Logon, the original name of this page.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "LoDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return LoInit( hwnd );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwLoHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return LoCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    // Because of inter-page dependencies on the framing type,
                    // the typical and advanced sections must be reinitialized
                    // at each activation.
                    //
                    BOOL fEnabled;

                    //This is for pre-shared key bug
                    //
                    fEnabled = ( VS_PptpOnly != pInfo->pArgs->pEntry->dwVpnStrategy );
        
                    EnableWindow( pInfo->hwndPbIPSec, fEnabled );

                    pInfo->fAuthRbInitialized = FALSE;
                    LoRefreshSecuritySettings( pInfo );
                    break;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
LoCommand(
    IN PEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "LoCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_LO_LB_Auths:
        {
            switch (wNotification)
            {
                case CBN_SELCHANGE:
                {
                    LoLbAuthsSelChange( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_CB_UseWindowsPw:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    // Necessary to save 'fAutoLogon' setting immediately as
                    // there is an inter-page dependency with the Option page
                    // 'fPreviewUserPw' and subordinate controls.
                    //
                    LoSaveTypicalAuthSettings( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_RB_TypicalSecurity:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    if (!pInfo->fAuthRbInitialized)
                    {
                        pInfo->fAuthRbInitialized = TRUE;
                    }

                    pInfo->pArgs->pEntry->dwAuthRestrictions
                        &= ~(AR_F_AuthCustom);
                    LoEnableSecuritySettings( pInfo, TRUE, FALSE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_RB_AdvancedSecurity:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    if (!pInfo->fAuthRbInitialized)
                    {
                        pInfo->fAuthRbInitialized = TRUE;
                    }
                    else
                    {
                        // Save the "typical" settings as they will be used as
                        // defaults should user decide to invoke the advanced
                        // security dialog.
                        //
                        LoSaveTypicalAuthSettings( pInfo );
                    }
                    pInfo->pArgs->pEntry->dwAuthRestrictions
                        |= AR_F_AuthCustom;
                    LoEnableSecuritySettings( pInfo, FALSE, TRUE );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_PB_Advanced:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    // At this point, the 'pEntry' authentication settings
                    // match the current "typical" settings, which the
                    // advanced dialog uses as defaults.
                    //
                    AdvancedSecurityDlg( pInfo->hwndDlg, pInfo->pArgs );
                    return TRUE;
                }
            }
            break;
        }

        case CID_LO_PB_IPSec:
        {
            switch (wNotification)
            {
            case BN_CLICKED:
                {
                    IPSecPolicyDlg( pInfo->hwndDlg, pInfo->pArgs );
                    return TRUE;
                }
            }

            break;
        }

        case CID_LO_CB_RunScript:
        {
            if (SuScriptsCbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_LO_PB_Edit:
        {
            if (SuEditPbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_LO_PB_Browse:
        {
            if (SuBrowsePbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}


VOID
LoEnableSecuritySettings(
    IN PEINFO* pInfo,
    IN BOOL fTypical,
    IN BOOL fAdvanced )

    // Enables/disables the typical or advanced security settings based on
    // caller's 'fTypical' and 'fAdvanced' flags.  If neither flag is set all
    // controls including the frames and radio buttons are disabled.  Both
    // flags may not be set.  'PInfo' is the property sheet context.
    //
{
    BOOL fEither;

    ASSERT( !(fTypical && fAdvanced) );

    fEither = (fTypical || fAdvanced);

    EnableWindow( pInfo->hwndGbSecurityOptions, fEither );

    EnableWindow( pInfo->hwndRbTypicalSecurity, fEither );
    EnableWindow( pInfo->hwndStAuths, fTypical );
    EnableLbWithRestore( pInfo->hwndLbAuths, fTypical, &pInfo->iLbAuths );

    // Note: "Use Windows password" and "require encryption" checkbox updates
    //       are triggered by the EnableLbWithRestore above.

    EnableWindow( pInfo->hwndRbAdvancedSecurity, fEither );
    EnableWindow( pInfo->hwndStAdvancedText, fAdvanced );
    EnableWindow( pInfo->hwndPbAdvanced, fAdvanced );
}


VOID
LoFillLbAuths(
    IN PEINFO* pInfo )

    // Fill the authentication list box and set the selection based on the
    // setting in the phonebook entry.  'PInfo' is the property sheet context.
    // This routine should be called only once.
    //
{
    INT i;
    LBTABLEITEM* pItem;
    LBTABLEITEM* pItems;
    PBENTRY* pEntry;

    LBTABLEITEM aItemsPhone[] =
    {
        SID_AuthUnsecured, TA_Unsecure,
        SID_AuthSecured, TA_Secure,
        SID_AuthCardOrCert, TA_CardOrCert,
        0, 0
    };

    LBTABLEITEM aItemsVpn[] =
    {
        SID_AuthSecured, TA_Secure,
        SID_AuthCardOrCert, TA_CardOrCert,
        0, 0
    };

    LBTABLEITEM aItemsPhoneRouter[] =
    {
        SID_AuthUnsecured, TA_Unsecure,
        SID_AuthSecured, TA_Secure,
        0, 0
    };

    LBTABLEITEM aItemsVpnRouter[] =
    {
        SID_AuthSecured, TA_Secure,
        0, 0
    };

    pEntry = pInfo->pArgs->pEntry;

    if (pEntry->dwType == RASET_Vpn)
    {
        pItems = (pInfo->pArgs->fRouter) ? aItemsVpnRouter : aItemsVpn;
    }
    else
    {
        pItems = (pInfo->pArgs->fRouter) ? aItemsPhoneRouter : aItemsPhone;
    }

    for (pItem = pItems; pItem->sidItem; ++pItem)
    {
        i = ComboBox_AddItemFromId(
            g_hinstDll, pInfo->hwndLbAuths,
            pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

        if (pEntry->dwTypicalAuth == pItem->dwData)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbAuths, i );
        }
    }

    if (ComboBox_GetCurSel( pInfo->hwndLbAuths ) < 0)
    {
        ComboBox_SetCurSelNotify( pInfo->hwndLbAuths, 0 );
    }
}


BOOL
LoInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "LoInit" );

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    pEntry = pInfo->pArgs->pEntry;

    // Initialize page-specific context information.
    //
    pInfo->hwndLo = hwndPage;
    pInfo->hwndGbSecurityOptions =
        GetDlgItem( hwndPage, CID_LO_GB_SecurityOptions );
    ASSERT( pInfo->hwndGbSecurityOptions );
    pInfo->hwndRbTypicalSecurity =
        GetDlgItem( hwndPage, CID_LO_RB_TypicalSecurity );
    ASSERT( pInfo->hwndRbTypicalSecurity );
    pInfo->hwndStAuths = GetDlgItem( hwndPage, CID_LO_ST_Auths );
    ASSERT( pInfo->hwndStAuths );
    pInfo->hwndLbAuths = GetDlgItem( hwndPage, CID_LO_LB_Auths );
    ASSERT( pInfo->hwndLbAuths );
    pInfo->hwndCbUseWindowsPw = GetDlgItem( hwndPage, CID_LO_CB_UseWindowsPw );
    ASSERT( pInfo->hwndCbUseWindowsPw );
    pInfo->hwndCbEncryption = GetDlgItem( hwndPage, CID_LO_CB_Encryption );
    ASSERT( pInfo->hwndCbEncryption );
    pInfo->hwndRbAdvancedSecurity =
        GetDlgItem( hwndPage, CID_LO_RB_AdvancedSecurity );
    ASSERT( pInfo->hwndRbAdvancedSecurity );
    pInfo->hwndStAdvancedText = GetDlgItem( hwndPage, CID_LO_ST_AdvancedText );
    ASSERT( pInfo->hwndStAdvancedText );
    pInfo->hwndPbAdvanced = GetDlgItem( hwndPage, CID_LO_PB_Advanced );
    ASSERT( pInfo->hwndPbAdvanced );

    //
    //for VPN's security page show IPSec Policy 
    // for whistler bug 193987
    //
    if ( pInfo->pArgs->pEntry->dwType == RASET_Vpn )
    {
        BOOL  fEnabled;

        pInfo->hwndPbIPSec = GetDlgItem( hwndPage, CID_LO_PB_IPSec );
        ASSERT( pInfo->hwndPbIPSec );

        //  gangz
        //If it is for a remote Win2k server's Demand Dialer
        //dont show the IPSec Policy stuff, because W2k didnt
        //implement this.
        //
        if ( pInfo->pArgs->fW2kRouter )
        {
            ShowWindow( pInfo->hwndPbIPSec, FALSE );
        }
        else
        {
            fEnabled = ( VS_PptpOnly != pInfo->pArgs->pEntry->dwVpnStrategy );
            EnableWindow( pInfo->hwndPbIPSec, fEnabled );
        }

        //for the IPSec Policy dialog, fPSKCached = TRUE means the user already
        //go to the IPSec Policy dialog and saved a PSK     gangz
        //
        pInfo->pArgs->fPSKCached = FALSE; 

        //gangz:  for bug# 276452
        //On a Server OS, the help message for this IPSec pushbutton 
        //should be different from that for a Non-server OS, 
        //so change its help ID when neeeded.
        //
        if ( IsServerOS() )
        {
            DWORD * p = (DWORD *)g_adwLoHelp;

            while( p )
            {
                if ( (p[0] == 0) && ( p[1] == 0 ) )
                {
                    break;
                 }
               
                if ( (p[0] == CID_LO_PB_IPSec) &&
                     (p[1] == HID_LO_PB_IPSec) )
                {
                    p[1] = HID_LO_PB_IPSecServer;
                    break;
                }

                p+=2;
            }
        }
        
    }
    else
    {
        pInfo->hwndGbScripting = GetDlgItem( hwndPage, CID_LO_GB_Scripting );
        ASSERT( pInfo->hwndGbScripting );
        pInfo->hwndCbRunScript = GetDlgItem( hwndPage, CID_LO_CB_RunScript );
        ASSERT( pInfo->hwndCbRunScript );
        pInfo->hwndCbTerminal = GetDlgItem( hwndPage, CID_LO_CB_Terminal );
        ASSERT( pInfo->hwndCbTerminal );
        pInfo->hwndLbScripts = GetDlgItem( hwndPage, CID_LO_LB_Scripts );
        ASSERT( pInfo->hwndLbScripts );
        pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_LO_PB_Edit );
        ASSERT( pInfo->hwndPbEdit );
        pInfo->hwndPbBrowse = GetDlgItem( hwndPage, CID_LO_PB_Browse );
        ASSERT( pInfo->hwndPbBrowse );
    }

    // Initialize the page controls.  Note that the page activation event
    // immediately after this initialization triggers the final security
    // setting enabling/disabling and does any "restore caching".  While this
    // initialization sets the check values and list selection to bootstrap
    // the "restore caching", these settings may be adjusted by the activation
    // refresh.
    //
    if (pInfo->pArgs->fRouter)
    {
        // The "Use Windows credentials" option is removed in the demand-dial
        // case.
        //
        pInfo->fUseWindowsPw = FALSE;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, FALSE );
        EnableWindow ( pInfo->hwndCbUseWindowsPw, FALSE );
        ShowWindow (pInfo->hwndCbUseWindowsPw, SW_HIDE );
    }
    else
    {
        pInfo->fUseWindowsPw = pEntry->fAutoLogon;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, pInfo->fUseWindowsPw  );
    }

    pInfo->fEncryption =
        (pEntry->dwDataEncryption != DE_None
         && pEntry->dwDataEncryption != DE_IfPossible);
    Button_SetCheck( pInfo->hwndCbEncryption, pInfo->fEncryption );

    // Fill authentiction list and set selection, which triggers all
    // appropriate enabling/disabling.
    //
    LoFillLbAuths( pInfo );

    if ((pInfo->pArgs->pEntry->dwType != RASET_Vpn)
         && (pInfo->pArgs->pEntry->dwType != RASET_Direct) 
         && (pInfo->pArgs->pEntry->dwType != RASET_Broadband))
         //&& !pInfo->pArgs->fRouter)
    {
        // Set up the after-dial scripting controls.
        //
        SuInit( &pInfo->suinfo,
            pInfo->hwndCbRunScript,
            pInfo->hwndCbTerminal,
            pInfo->hwndLbScripts,
            pInfo->hwndPbEdit,
            pInfo->hwndPbBrowse,
            pInfo->pArgs->fRouter ? SU_F_DisableTerminal : 0);
        pInfo->fSuInfoInitialized = TRUE;

        SuSetInfo( &pInfo->suinfo,
            pEntry->fScriptAfter,
            pEntry->fScriptAfterTerminal,
            pEntry->pszScriptAfter );
    }
    else
    {
        // Disable/hide the after-dial scripting controls.
        // for VPN there is no need to do this Disable/hide operation
        //
        if (pInfo->pArgs->pEntry->dwType != RASET_Vpn)
        {
            EnableWindow( pInfo->hwndGbScripting, FALSE );
            ShowWindow( pInfo->hwndGbScripting, SW_HIDE );
            EnableWindow( pInfo->hwndCbRunScript, FALSE );
            ShowWindow( pInfo->hwndCbRunScript, SW_HIDE );
            EnableWindow( pInfo->hwndCbTerminal, FALSE );
            ShowWindow( pInfo->hwndCbTerminal, SW_HIDE );
            EnableWindow( pInfo->hwndLbScripts, FALSE );
            ShowWindow( pInfo->hwndLbScripts, SW_HIDE );
            EnableWindow( pInfo->hwndPbEdit, FALSE );
            ShowWindow( pInfo->hwndPbEdit, SW_HIDE );
            EnableWindow( pInfo->hwndPbBrowse, FALSE );
            ShowWindow( pInfo->hwndPbBrowse, SW_HIDE );
        }
    }

    if (pInfo->pArgs->fRouter)
    {
        EnableWindow( pInfo->hwndCbTerminal, FALSE );
        ShowWindow( pInfo->hwndCbTerminal, SW_HIDE );
    }

    return TRUE;
}


VOID
LoLbAuthsSelChange(
    IN PEINFO* pInfo )

    // Called when the selection in the authentication drop list is changed.
    //
{
    INT iSel;
    DWORD dwTaCode;

    // Retrieve the bitmask of authentication protocols associated with the
    // selected authentication level.
    //
    iSel = ComboBox_GetCurSel( pInfo->hwndLbAuths );
    if (iSel < 0)
    {
        dwTaCode = 0;
    }
    else
    {
        dwTaCode = (DWORD )ComboBox_GetItemData( pInfo->hwndLbAuths, iSel );
    }

    if (!pInfo->pArgs->fRouter)
    {
        // Update the "Use Windows NT credentials" checkbox.  Per the spec, it
        // is enabled only for "require secure password", though the real
        // requirement is that MSCHAP (provides NT-style credentials) gets
        // negotiated.
        //
        EnableCbWithRestore(
            pInfo->hwndCbUseWindowsPw,
            (dwTaCode == TA_Secure),
            FALSE,
            &pInfo->fUseWindowsPw );
    }

    // Update the "Require data encryption" checkbox.  Per the spec, it is
    // enabled unless "allow unsecured password" is selected, though the real
    // requirement is that all authentication protocols in the set provide
    // MPPE encryption keys.
    //
    EnableCbWithRestore(
        pInfo->hwndCbEncryption,
        (dwTaCode != 0 && dwTaCode != TA_Unsecure),
        FALSE,
        &pInfo->fEncryption );
}


VOID
LoRefreshSecuritySettings(
    IN PEINFO* pInfo )

    // Sets the contents and state of all typical and advanced security
    // setting fields.
    //
{
    if (pInfo->pArgs->pEntry->dwBaseProtocol & BP_Slip)
    {
        // For SLIP framing, all the typical and advanced controls are
        // disabled and the radio buttons show no selection.
        //
        Button_SetCheck( pInfo->hwndRbTypicalSecurity, FALSE );
        Button_SetCheck( pInfo->hwndRbAdvancedSecurity, FALSE );
        LoEnableSecuritySettings( pInfo, FALSE, FALSE );

        if (pInfo->fShowSlipPopup)
        {
            // Time to show the one-shot informational about SLIP not doing
            // any in-protocol authentication or encryption.
            //
            MsgDlg( pInfo->hwndDlg, SID_NoAuthForSlip, NULL );
            pInfo->fShowSlipPopup = FALSE;
        }
    }
    else
    {
        HWND hwndRb;

        // For PPP framing, select the appropriate security setting radio
        // button which triggers additional enabling/disabling of the framed
        // controls.
        //
        if (pInfo->pArgs->pEntry->dwAuthRestrictions & AR_F_AuthCustom)
        {
            hwndRb = pInfo->hwndRbAdvancedSecurity;
        }
        else
        {
            hwndRb = pInfo->hwndRbTypicalSecurity;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }
}


VOID
LoSaveTypicalAuthSettings(
    IN PEINFO* pInfo )

    // Save the values in the "typical" authentication controls to the
    // phonebook entry.  'PInfo' is the property sheet context.
    //
{
    PBENTRY* pEntry;
    INT iSel;

    pEntry = pInfo->pArgs->pEntry;
    iSel = ComboBox_GetCurSel( pInfo->hwndLbAuths );
    if (iSel >= 0)
    {
        pEntry->dwTypicalAuth =
            (DWORD) ComboBox_GetItemData( pInfo->hwndLbAuths, iSel );

        pEntry->dwAuthRestrictions =
            AuthRestrictionsFromTypicalAuth( pEntry->dwTypicalAuth );

        // Set the default custom authentication key value for smart
        // cards.  RasDial API should assume this default anyway, but we
        // need it before then in DialerDlgEap.
        //
        if (pEntry->dwTypicalAuth == TA_CardOrCert)
        {
            pEntry->dwCustomAuthKey = EAPCFG_DefaultKey;
        }
        else
        {
            pEntry->dwCustomAuthKey = (DWORD )-1;
        }
    }

    if (IsWindowEnabled( pInfo->hwndCbUseWindowsPw ))
    {
        pEntry->fAutoLogon =
            Button_GetCheck( pInfo->hwndCbUseWindowsPw );
    }
    else
    {
        pEntry->fAutoLogon = FALSE;
    }

    if (IsWindowEnabled( pInfo->hwndCbEncryption ))
    {
        pEntry->dwDataEncryption =
            (Button_GetCheck( pInfo->hwndCbEncryption ))
                ? DE_Require : DE_IfPossible;
    }
    else
    {
        pEntry->dwDataEncryption = DE_IfPossible;
    }

    if (pEntry->dwDataEncryption == DE_Require
        && !(pEntry->dwType == RASET_Vpn
             && pEntry->dwVpnStrategy == VS_L2tpOnly))
    {
        // Encryption is required and MPPE will be the encryption method
        // so eliminate authentication protocols that don't support it.
        //
        pEntry->dwAuthRestrictions &= ~(AR_F_AuthNoMPPE);
    }
}


//----------------------------------------------------------------------------
// Networking property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

LVXDRAWINFO*
NeLvComponentsCallback(
    IN HWND hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the draw information.
    //
{
    // Use "full row select" and other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info = { 1, 0, LVXDI_DxFill, { 0 } };

    return &info;
}

INT_PTR CALLBACK
NeDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Network page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(hwnd, unMsg, wparam, lparam, NeLvComponentsCallback))
        return TRUE;

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return NeInit( hwnd );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwNeHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            PEINFO* pInfo = PeContext (hwnd);
            ASSERT (pInfo);

            switch (LOWORD(wparam))
            {
                case CID_NE_LB_ServerType:
                    if (CBN_SELCHANGE == HIWORD(wparam))
                    {
                        NeServerTypeSelChange (pInfo);
                    }
                    break;

                case CID_NE_PB_Settings:
                    DialogBoxParam (g_hinstDll,
                        MAKEINTRESOURCE(DID_NE_PppSettings),
                        hwnd, PpDlgProc, (LPARAM)pInfo);
                    break;

                case CID_NE_PB_Add:
                    NeAddComponent (pInfo);
                    break;

                case CID_NE_PB_Properties:
                    NeShowComponentProperties (pInfo);
                    break;

                case CID_NE_PB_Remove:
                    NeRemoveComponent (pInfo);
                    break;
            }
            break;
        }

        case WM_NOTIFY:
        {
            PEINFO* pInfo = PeContext(hwnd);

            //!!! Hack related to PeTerm in WM_DESTROY.  We still get
            // WM_NOTIFYs after PeTerm is called.  So we commented out the
            // following assert and moved it into each message handler below.
            //ASSERT (pInfo);

            switch (((NMHDR*)lparam)->code)
            {
// !!! See if base lvx.c code can handle inversion of check state on double
// click.
#if 0
                case NM_CLICK:
                    ASSERT (pInfo);
                    if (CID_NE_LV_Components == ((NMHDR*)lparam)->idFrom)
                    {
                        NeLvClick (pInfo, FALSE);
                    }
                    break;
#endif

                case NM_DBLCLK:
                    ASSERT (pInfo);
                    if (CID_NE_LV_Components == ((NMHDR*)lparam)->idFrom)
                    {
                        NeLvClick (pInfo, TRUE);
                    }
                    break;

                case LVN_ITEMCHANGED:
                    ASSERT (pInfo);
                    NeLvItemChanged (pInfo);
                    break;

                case LVN_DELETEITEM:
                    ASSERT (pInfo);
                    NeLvDeleteItem (pInfo, (NM_LISTVIEW*)lparam);
                    break;

                case PSN_SETACTIVE:
                    ASSERT (pInfo);

                    // If we couldn't get INetCfg, we can't show this page.
                    //
                    if (!pInfo->pNetCfg)
                    {
                        MsgDlg( pInfo->hwndDlg, ERR_CANT_SHOW_NETTAB_INETCFG, NULL );
                        SetWindowLong( hwnd, DWLP_MSGRESULT, -1 );
                        return TRUE;
                    }
                    break;
            }
            break;
        }
    }
    return FALSE;
}


void
NeEnsureNetshellLoaded (
    IN PEINFO* pInfo)
{
    // Load the netshell utilities interface.  The interface is freed in PeTerm.
    //
    if (!pInfo->pNetConUtilities)
    {
        // Initialize the NetConnectionsUiUtilities
        //
        HRESULT hr = HrCreateNetConnectionUtilities(&pInfo->pNetConUtilities);
    }
}

BOOL
NeInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;

    pInfo = PeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    // Initialize page-specific context information.
    //
    pInfo->hwndLbServerType =
        GetDlgItem( hwndPage, CID_NE_LB_ServerType );
    ASSERT( pInfo->hwndLbServerType );

    pInfo->hwndPbSettings =
        GetDlgItem( hwndPage, CID_NE_PB_Settings );
    ASSERT( pInfo->hwndPbSettings );

    pInfo->hwndLvComponents =
        GetDlgItem( hwndPage, CID_NE_LV_Components );
    ASSERT( pInfo->hwndLvComponents );

    pInfo->hwndPbAdd =
        GetDlgItem( hwndPage, CID_NE_PB_Add );
    ASSERT( pInfo->hwndPbAdd );

    pInfo->hwndPbRemove =
        GetDlgItem( hwndPage, CID_NE_PB_Remove );
    ASSERT( pInfo->hwndPbRemove );

    pInfo->hwndPbProperties =
        GetDlgItem( hwndPage, CID_NE_PB_Properties );
    ASSERT( pInfo->hwndPbProperties );

    pInfo->hwndDescription =
        GetDlgItem( hwndPage, CID_NE_LB_ComponentDesc );
    ASSERT( pInfo->hwndDescription );

    // Initialize page.
    //
    pEntry = pInfo->pArgs->pEntry;

    // Initialize the server type combo box with the strings and the selection.
    //
    if (pEntry->dwType == RASET_Vpn)
    {
        INT i;
        LBTABLEITEM* pItem;

        // Whistler bug 312921 CM/RAS should default to PPTP instead of L2TP
        //
        LBTABLEITEM aItems[] =
        {
            SID_ST_VpnAuto, VS_PptpFirst,
            SID_ST_VpnPptp, VS_PptpOnly,
            SID_ST_VpnL2tp, VS_L2tpOnly,
            0, 0
        };

        for (pItem = aItems; pItem->sidItem != 0; ++pItem)
        {
            i = ComboBox_AddItemFromId(
                g_hinstDll, pInfo->hwndLbServerType,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (pItem->dwData == pEntry->dwVpnStrategy)
            {
                ComboBox_SetCurSel( pInfo->hwndLbServerType, i );
            }
        }

        // If nothing was selected, then the strategy must have been one of the
        // VS_xxxxFirst values.  Set the current selection to automatic.
        if ( ComboBox_GetCurSel ( pInfo->hwndLbServerType ) < 0 )
            ComboBox_SetCurSel( pInfo->hwndLbServerType, 0 );

        // Change the label to be VPN-specific per bug 307526.
        //
        {
            TCHAR* psz;

            psz = PszFromId( g_hinstDll, SID_NE_VpnServerLabel );
            if (psz)
            {
                SetWindowText(
                    GetDlgItem( hwndPage, CID_NE_ST_ServerType ), psz );
                Free( psz );
            }
        }
    }
    else if (pEntry->dwType == RASET_Broadband)
    {
        INT i;
        LBTABLEITEM* pItem;
        LBTABLEITEM aItems[] =
        {
            SID_ST_BbPppoe, BP_Ppp,
            0, 0
        };

        for (pItem = aItems; pItem->sidItem != 0; ++pItem)
        {
            i = ComboBox_AddItemFromId(
                g_hinstDll, pInfo->hwndLbServerType,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));
        }
        ComboBox_SetCurSel( pInfo->hwndLbServerType, 0 );

        // Change the label to be broadband-specific
        //
        {
            TCHAR* psz;

            psz = PszFromId( g_hinstDll, SID_NE_BbServerLabel );
            if (psz)
            {
                SetWindowText(
                    GetDlgItem( hwndPage, CID_NE_ST_ServerType ), psz );
                Free( psz );
            }
        }
    }
    else
    {
        ComboBox_AddItemFromId (g_hinstDll, pInfo->hwndLbServerType,
            SID_ST_Ppp, (VOID*)BP_Ppp );
        if (!pInfo->pArgs->fRouter)
        {
            ComboBox_AddItemFromId (g_hinstDll, pInfo->hwndLbServerType,
                SID_ST_Slip, (VOID*)BP_Slip );
        }

        if (pEntry->dwBaseProtocol == BP_Ppp)
        {
            ComboBox_SetCurSel(pInfo->hwndLbServerType, 0 );
        }
        else
        {
            ComboBox_SetCurSel( pInfo->hwndLbServerType, 1 );
            EnableWindow( pInfo->hwndPbSettings, FALSE );
        }
    }

    // Set the image list for the state of the check boxes.
    //
    ListView_InstallChecks( pInfo->hwndLvComponents, g_hinstDll );
    ListView_InsertSingleAutoWidthColumn( pInfo->hwndLvComponents );

    // Set the image list for the component bitmaps.  Unfortunately we have to
    // duplicate it (as opposed to share) because the image list for the state
    // icons is not shared.  (If we set the shared style, all image lists would
    // have to be deleted manually.
    //
    {
        ZeroMemory (&pInfo->cild, sizeof(pInfo->cild));
        pInfo->cild.cbSize = sizeof(pInfo->cild);
        if (SetupDiGetClassImageList (&pInfo->cild))
        {
            HIMAGELIST himlSmall = ImageList_Duplicate (pInfo->cild.ImageList);
            ListView_SetImageList (pInfo->hwndLvComponents, himlSmall, LVSIL_SMALL);
        }
    }

    // Get the interface used to change network configuration and lock it.
    // The description of who has the lock (us) comes from the title of our
    // parent dialog.  This is done so that when other applications try to obtain
    // the lock (and fail) they get an indication of who has it locked.  They
    // can then direct the user to close our window to release the lock.
    //
    {
        BOOL fEnableAdd = TRUE;
        HRESULT hr;
        TCHAR pszParentCaption [MAX_PATH] = {0};
        GetWindowText (GetParent(hwndPage), pszParentCaption, MAX_PATH);
        pInfo->fInitCom = TRUE;
        hr = HrCreateAndInitializeINetCfg (&pInfo->fInitCom, &pInfo->pNetCfg,
                        TRUE, 0, pszParentCaption, NULL);
        if (S_OK == hr)
        {
            // Refresh the list view.
            //
            hr = HrNeRefreshListView (pInfo);

            // Reset the state of the buttons as if something changed.
            //
            NeLvItemChanged (pInfo);

            pInfo->fNetCfgLock = TRUE;
        }
        else
        {
            DWORD   dwMsg = SID_NE_ReadOnly;

            //For whistler bug 311566
            //
            if (NETCFG_E_NO_WRITE_LOCK == hr)
            {
                pInfo->fReadOnly = TRUE;
            }                

            if (NETCFG_E_NEED_REBOOT == hr)
            {
                dwMsg = SID_NE_Reboot;
            }
            else if (E_ACCESSDENIED == hr)
            {
                pInfo->fNonAdmin = TRUE;
                dwMsg = SID_NE_AccessDenied;
            }

            // Uh.. ok let's try that again in read-only mode
            hr = HrCreateAndInitializeINetCfg (&pInfo->fInitCom,
                                               &pInfo->pNetCfg,FALSE, 0,
                                               pszParentCaption, NULL);

            if (S_OK == hr)
            {
                // Refresh the list view.
                //
                hr = HrNeRefreshListView (pInfo);

                // Reset the state of the buttons as if something changed.
                //
                NeLvItemChanged (pInfo);

                MsgDlg( pInfo->hwndDlg, dwMsg, NULL );
            }
        }

        // Get the interface so we can check our access rights to the UI
        //
        NeEnsureNetshellLoaded (pInfo);
        if (NULL != pInfo->pNetConUtilities)
        {
            fEnableAdd = INetConnectionUiUtilities_UserHasPermission(
                                            pInfo->pNetConUtilities,
                                            NCPERM_AddRemoveComponents);
        }

        // Disable some buttons if user does not have privilege
        //
        if (pInfo->fReadOnly || (NULL == pInfo->pNetConUtilities))
        {
            EnableWindow(pInfo->hwndPbAdd, FALSE);
            EnableWindow(pInfo->hwndPbRemove, FALSE);
            EnableWindow(pInfo->hwndPbProperties, FALSE);
        }
        // Disable some buttons if running in non-admin mode
        else if (pInfo->fNonAdmin)
        {
            EnableWindow(pInfo->hwndPbAdd, FALSE);
            EnableWindow(pInfo->hwndPbRemove, FALSE);
        }
        else
        {
            EnableWindow(pInfo->hwndPbAdd, fEnableAdd);
            // Other buttons enabled via NeLvItemChanged
        }

        // pmay: 348623
        //
        // Hide some buttons if we're remote admining
        //
        if (pInfo->pArgs->fRemote)
        {
            ShowWindow(pInfo->hwndPbAdd, SW_HIDE);
            ShowWindow(pInfo->hwndPbRemove, SW_HIDE);
        }
    }
    return TRUE;
}

void
NeServerTypeSelChange (
    IN PEINFO* pInfo)
{
    PBENTRY* pEntry;
    int iSel;
    DWORD dwValue;

    pEntry = pInfo->pArgs->pEntry;
    iSel = ComboBox_GetCurSel (pInfo->hwndLbServerType);
    ASSERT (CB_ERR != iSel);

    dwValue = (DWORD) ComboBox_GetItemData (pInfo->hwndLbServerType, iSel);

    // Regular connections choose between slip and ppp
    //
    if (pEntry->dwType != RASET_Vpn)
    {
        pEntry->dwBaseProtocol = dwValue;

        // When SLIP is selected, turn off all protocols but IP and indicate
        // the SLIP security page informational popup should appear.
        //
        if (BP_Slip == dwValue)
        {
            // No need to exclude the protocols. We lose this config state if
            // we remove this and its of no use anyway. PPP won't be done
            // if slip is selected -- [raos].
            //
            // pEntry->dwfExcludedProtocols = ~NP_Ip;

            pInfo->fShowSlipPopup = TRUE;
        }

        HrNeRefreshListView (pInfo);
    }

    // Vpn connections select a strategy.  When automatic is selected,
    // we need to make sure the authentication and encryption is
    // compatible
    //
    else
    {
        pEntry->dwVpnStrategy = dwValue;

        // Whistler bug 312921 CM/RAS should default to PPTP instead of L2TP
        //
        if (dwValue == VS_PptpFirst)
        {
            pEntry->dwDataEncryption = DE_Require;
            pEntry->dwAuthRestrictions = AR_F_TypicalSecure;
            pEntry->dwTypicalAuth = TA_Secure;
        }
    }

    EnableWindow (pInfo->hwndPbSettings, !!(BP_Ppp == pEntry->dwBaseProtocol));
}

BOOL
NeRequestReboot (
    IN PEINFO* pInfo)
{
    NeEnsureNetshellLoaded (pInfo);

    if (pInfo->pNetConUtilities)
    {
        HRESULT     hr;

        // A reboot is required. Ask the user if it is ok to reboot now
        //
        //$TODO NULL caption?
        hr = INetConnectionUiUtilities_QueryUserForReboot(
                        pInfo->pNetConUtilities, pInfo->hwndDlg,
                        NULL, QUFR_PROMPT);
        if (S_OK == hr)
        {
            // User requested a reboot, note this for processing in OnApply
            // which is triggered by the message posted below
            //
            pInfo->fRebootAlreadyRequested = TRUE;

            // Press the cancel button (changes have already been applied)
            // so the appropriate cleanup occurs.
            //
            PostMessage(pInfo->hwndDlg, PSM_PRESSBUTTON,
                        (WPARAM)PSBTN_OK, 0);
        }
        else if (S_FALSE == hr)
        {
            // User denied to request to reboot
            //
            return FALSE;
        }
    }

    return TRUE;
}

void
NeSaveBindingChanges(IN PEINFO* pInfo)
{
    // Won't have changes to keep unless we have a writable INetCfg
    if (pInfo->pNetCfg)
    {
        int                 iItem;
        INetCfgComponent*   pComponent;
        BOOL                fEnabled;
        HRESULT             hr;

        // Update the phone book entry with the enabled state of the components.
        // Do this by enumerating the components from the list view item data
        // and consulting the check state for each.
        //
        iItem = -1;
        while (-1 != (iItem = ListView_GetNextItem (pInfo->hwndLvComponents,
                                iItem, LVNI_ALL)))
        {
            pComponent = PComponentFromItemIndex (pInfo->hwndLvComponents, iItem);
            ASSERT (pComponent);

            fEnabled = ListView_GetCheck (pInfo->hwndLvComponents, iItem);
            if(pComponent)
            {
                NeEnableComponent (pInfo, pComponent, fEnabled);
            }
        }
    }
}

void
NeAddComponent (
    IN PEINFO* pInfo)
{
    NeEnsureNetshellLoaded (pInfo);

    // If we have our pointer to the interface used to bring up the add
    // component dialog (obtained above only once), call it.
    //
    if (pInfo->pNetConUtilities)
    {
        HRESULT hr;

        // We want to filter out protocols that RAS does not care about
        // We do this by sending in a CI_FILTER_INFO structure indicating
        // we want non-RAS protocols filtered out
        //
        CI_FILTER_INFO cfi = {0};
        cfi.eFilter = FC_RASCLI;

        ASSERT (pInfo->pNetCfg);
        hr = INetConnectionUiUtilities_DisplayAddComponentDialog(
                        pInfo->pNetConUtilities, pInfo->hwndDlg,
                        pInfo->pNetCfg, &cfi);

        // If the user didn't cancel, refresh the list view.
        //
        if (S_FALSE != hr)
        {
            if (SUCCEEDED(hr))
            {
                // Change the Cancel Button to CLOSE (because we committed changes)
                //
                PropSheet_CancelToClose(pInfo->hwndDlg);
            }

            // commit binding changes made (Raid #297216)
            NeSaveBindingChanges(pInfo);

            HrNeRefreshListView (pInfo);

            // Reset the state of the buttons as if something changed.
            //
            NeLvItemChanged (pInfo);

            // If reboot is needed request approval for this from the user
            //
            if (NETCFG_S_REBOOT == hr)
            {
                NeRequestReboot (pInfo);
            }
        }
    }
}

void
NeRemoveComponent (
    IN PEINFO* pInfo)
{
    NeEnsureNetshellLoaded (pInfo);

    // If we have our pointer to the function used to bring up the remove
    // component dialog (obtained above only once), call it.
    //
    if (pInfo->pNetConUtilities)
    {
        HRESULT hr;
        INetCfgComponent* pComponent;
        pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, NULL);
        ASSERT (pComponent);

        ASSERT (pInfo->pNetCfg);
        hr = INetConnectionUiUtilities_QueryUserAndRemoveComponent(
                        pInfo->pNetConUtilities, pInfo->hwndDlg,
                        pInfo->pNetCfg, pComponent);

        // If the user didn't cancel, refresh the list view.
        //
        if (S_FALSE != hr)
        {
            if (SUCCEEDED(hr))
            {
                // Change the Cancel Button to CLOSE (because we committed changes)
                //
                PropSheet_CancelToClose(pInfo->hwndDlg);
            }

            NeSaveBindingChanges(pInfo);

            HrNeRefreshListView(pInfo);

            // Reset the state of the buttons as if something changed.
            //
            NeLvItemChanged (pInfo);

            // If reboot is needed request approval for this from the user
            //
            if (NETCFG_S_REBOOT == hr)
            {
                NeRequestReboot (pInfo);
            }
        }
    }
}

void
NeLvClick (
    IN PEINFO* pInfo,
    IN BOOL fDoubleClick)
{
    //Add the IsWindowEnabled for whistler bug #204976
    //Not to pop up the property dialog box if it is a router
    //and the selected List View item is IPX
    //
    if (fDoubleClick && IsWindowEnabled(pInfo->hwndPbProperties))
    {
        INetCfgComponent*   pComponent;
        int iItem;

        pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, &iItem);
        if (pComponent)
        {
            HRESULT hr;
            if ( ListView_GetCheck (pInfo->hwndLvComponents, iItem))
            {
                // Check if the component has property UI
                //

                // Create the UI info callback object if we haven't done so yet.
                // If this fails, we can still show properties.  TCP/IP just might
                // not know which UI-variant to show.
                //
                if (!pInfo->punkUiInfoCallback)
                {
                    HrCreateUiInfoCallbackObject (pInfo, &pInfo->punkUiInfoCallback);
                }

                // Check if the component has property UI
                hr = INetCfgComponent_RaisePropertyUi ( pComponent,
                                                        pInfo->hwndDlg,
                                                        NCRP_QUERY_PROPERTY_UI,
                                                        pInfo->punkUiInfoCallback);

                if (S_OK == hr)
                {
                    NeEnsureNetshellLoaded (pInfo);
                    if ((NULL != pInfo->pNetConUtilities) &&
                        INetConnectionUiUtilities_UserHasPermission(
                                                pInfo->pNetConUtilities,
                                                NCPERM_RasChangeProperties))
                    {
                        NeShowComponentProperties (pInfo);
                    }
                }
            }
        }
    }
}

void
NeLvItemChanged (
    IN PEINFO* pInfo)
{
    LPWSTR              pszwDescription    = NULL;
    BOOL                fEnableRemove      = FALSE;
    BOOL                fEnableProperties  = FALSE;
    INetCfgComponent*   pComponent;
    int iItem;

    // Get the current selection if it exists.
    //
    pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, &iItem);
    if (pComponent)
    {
        NeEnsureNetshellLoaded (pInfo);

        // Determine if removal is allowed
        //
        if (NULL != pInfo->pNetConUtilities)
        {
            DWORD   dwFlags = 0;
            HRESULT hr;
            fEnableRemove = INetConnectionUiUtilities_UserHasPermission(
                                            pInfo->pNetConUtilities,
                                            NCPERM_AddRemoveComponents);
                                            
            //Now disable the user ability to uninstall TCP stack
            //for whistler bug 322846   gangz
            //
            hr = INetCfgComponent_GetCharacteristics(pComponent, &dwFlags );
            if( SUCCEEDED(hr) && (NCF_NOT_USER_REMOVABLE & dwFlags) )
            {
                fEnableRemove = FALSE;
            }
        }

        // See if the properties UI should be allowed.  Only allow it for
        // enabled items that have UI to display.
        //
        {
            HRESULT hr;
            if (ListView_GetCheck (pInfo->hwndLvComponents, iItem))
            {
                // Check if the component has property UI
                //
                INetCfgComponent* pComponent;
                pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, NULL);
                ASSERT (pComponent);

                // Create the UI info callback object if we haven't done so yet.
                // If this fails, we can still show properties.  TCP/IP just might
                // not know which UI-variant to show.
                //
                if (!pInfo->punkUiInfoCallback)
                {
                    HrCreateUiInfoCallbackObject (pInfo, &pInfo->punkUiInfoCallback);
                }

                if(pComponent)
                {

                    // Check if the component has property UI
                    hr = INetCfgComponent_RaisePropertyUi ( pComponent,
                                                        pInfo->hwndDlg,
                                                        NCRP_QUERY_PROPERTY_UI,
                                                        pInfo->punkUiInfoCallback);

                    if ((S_OK == hr) && (NULL != pInfo->pNetConUtilities))
                    {
                        fEnableProperties = INetConnectionUiUtilities_UserHasPermission(
                                                    pInfo->pNetConUtilities,
                                                    NCPERM_RasChangeProperties);
                    }
                }
            }
        }

        // Bug #221837 (danielwe): Set member vars based on whether they
        // are checked in the UI
        //
        {
            PBENTRY *           pEntry;
            BOOL                fIsChecked;
            LPWSTR              pszwId = NULL;

            pEntry = pInfo->pArgs->pEntry;

            fIsChecked = ListView_GetCheck(pInfo->hwndLvComponents, iItem);

            if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
            {
                if (!lstrcmpi(NETCFG_CLIENT_CID_MS_MSClient,
                              pszwId))
                {
                    pEntry->fBindMsNetClient = fIsChecked;
                }
                else if (!lstrcmpi(NETCFG_SERVICE_CID_MS_SERVER,
                                   pszwId))
                {
                    pEntry->fShareMsFilePrint = fIsChecked;
                }

                // pmay 406630
                // 
                // Disable the properties of all components but tcpip if we
                // are running in non-admin mode
                //
                else if (lstrcmpi(NETCFG_TRANS_CID_MS_TCPIP,
                                  pszwId))
                {
                    if (pInfo->fNonAdmin)
                    {
                        fEnableProperties = FALSE;
                    }
                }

                CoTaskMemFree(pszwId);
            }
        }

        // Bug #348623 (pmay): 
        //
        // Ipx is hardcoded to disable properties when remote admining
        // a router.
        //
        if (pInfo->pArgs->fRouter ) //commented for bug #204976 //&& pInfo->pArgs->fRemote)
        {
            LPWSTR              pszwId = NULL;

            if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
            {
                if (!lstrcmpi(NETCFG_TRANS_CID_MS_NWIPX,
                              pszwId))
                {
                    fEnableProperties = FALSE;
                }

                CoTaskMemFree(pszwId);
            }
        }

        // Get the description text.  Failure is okay here.  It just means
        // we'll display nothing.
        //
        INetCfgComponent_GetHelpText (pComponent, &pszwDescription);
    }

    // Update the UI with its new state.
    //
    if (!pInfo->fReadOnly)
    {
        EnableWindow (pInfo->hwndPbRemove,      fEnableRemove);
        EnableWindow (pInfo->hwndPbProperties,  fEnableProperties);
    }

    if(NULL != pszwDescription)
    {
        SetWindowText (pInfo->hwndDescription,  pszwDescription);
        CoTaskMemFree (pszwDescription);
    }
}

void
NeLvDeleteItem (
    IN PEINFO* pInfo,
    IN NM_LISTVIEW* pnmlv)
{
    // Release our component object stored as the lParam of the list view
    // item.
    //
    INetCfgComponent* pComponent;
    pComponent = PComponentFromItemIndex (pInfo->hwndLvComponents,
                        pnmlv->iItem);
    ReleaseObj (pComponent);
}


//----------------------------------------------------------------------------
// Networking property page PPP Settings dialog
//----------------------------------------------------------------------------

INT_PTR CALLBACK
PpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    PEINFO*  pInfo;
    PBENTRY* pEntry;

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            pInfo = (PEINFO*)lparam;
            ASSERT (pInfo);

            pEntry = pInfo->pArgs->pEntry;

            CheckDlgButton (hwnd, CID_NE_EnableLcp,
                (pEntry->fLcpExtensions)
                    ? BST_CHECKED : BST_UNCHECKED);

            CheckDlgButton (hwnd, CID_NE_EnableCompression,
                (pEntry->fSwCompression)
                    ? BST_CHECKED : BST_UNCHECKED);

            //Cut Negotiate multi-link for whistler bug 385842
            //
            CheckDlgButton (hwnd, CID_NE_NegotiateMultilinkAlways,
                (pEntry->fNegotiateMultilinkAlways)
                    ? BST_CHECKED : BST_UNCHECKED);

            SetWindowLongPtr (hwnd, DWLP_USER, (ULONG_PTR )lparam);

            // Center dialog on the owner window.
            //
            CenterWindow(hwnd, GetParent(hwnd));

            // Add context help button to title bar.
            //
            AddContextHelpButton(hwnd);

            return TRUE;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwPpHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            if ((IDOK == LOWORD(wparam)) &&
                (BN_CLICKED == HIWORD(wparam)))
            {
                pInfo = (PEINFO*)GetWindowLongPtr (hwnd, DWLP_USER);
                ASSERT (pInfo);

                pEntry = pInfo->pArgs->pEntry;

                pEntry->fLcpExtensions = (BST_CHECKED ==
                            IsDlgButtonChecked (hwnd, CID_NE_EnableLcp));

                pEntry->fSwCompression = (BST_CHECKED ==
                            IsDlgButtonChecked (hwnd, CID_NE_EnableCompression));

               //Cut Negotiate multi-link for whistler bug 385842
               //
               pEntry->fNegotiateMultilinkAlways = (BST_CHECKED ==
                            IsDlgButtonChecked (hwnd, CID_NE_NegotiateMultilinkAlways));
                
		/*
                pEntry->fNegotiateMultilinkAlways = FALSE;
		*/
                EndDialog (hwnd, TRUE);
                return TRUE;
            }

            else if ((IDCANCEL == LOWORD(wparam)) &&
                     (BN_CLICKED == HIWORD(wparam)))
            {
                EndDialog (hwnd, FALSE);
                return TRUE;
            }
            break;
        }
    }
    return FALSE;
}


INT_PTR CALLBACK
SaUnavailDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared Access Unavailable page of the Entry property
    // sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
#if 0
    TRACE4( "SaUnavailDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            LPWSTR pszError;
            PEINFO* pInfo = PeContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            pszError = PszFromId(g_hinstDll, pInfo->pArgs->hShowHNetPagesResult == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) ? SID_SA_NoWMIError : SID_SA_StoreError);
            if(NULL != pszError)
            {
                SetDlgItemText(hwnd, CID_SA_ST_ErrorText, pszError);
                Free(pszError);
            }
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
//            ContextHelp( g_adwSaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

    }

    return FALSE;
}
//----------------------------------------------------------------------------
// Routing property page (PLACEHOLDER only)
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
RdDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Routing page of the Entry property sheet.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    return FALSE;
}


/*----------------------------------------------------------------------------
** (Router) Callback dialog
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/


BOOL
RouterCallbackDlg(
    IN     HWND   hwndOwner,
    IN OUT EINFO* pEinfo )

    /* Pops-up the (Router) Callback dialog.  Initial settings are read from
    ** the working entry (no/yes choice) and router user preferences (number
    ** list) in common entry context 'pEinfo' and the result of user's edits
    ** written there on "OK" exit.  'HwndOwner' is the window owning the
    ** dialog.
    **
    ** Returns true if user pressed OK and succeeded, false if he pressed
    ** Cancel or encountered an error.
    */
{
    INT_PTR nStatus;

    TRACE("RouterCallbackDlg");

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CR_CallbackRouter ),
            hwndOwner,
            CrDlgProc,
            (LPARAM )pEinfo );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
CrDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the (Router) Callback dialog.  Parameters and
    ** return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("CrDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, CbutilLvNumbersCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CrInit( hwnd, (EINFO* )lparam );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwCrHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case NM_DBLCLK:
                {
                    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    SendMessage( pInfo->hwndPbEdit, BM_CLICK, 0, 0 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
                    ASSERT(pInfo);
                    CrUpdateLvAndPbState( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return CrCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CrTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CrCommand(
    IN CRINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("CrCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_CR_RB_No:
        case CID_CR_RB_Yes:
        {
            if (wNotification == BN_CLICKED)
            {
                CrUpdateLvAndPbState( pInfo );

                if (wId == CID_CR_RB_Yes
                    && ListView_GetSelectedCount( pInfo->hwndLvNumbers ) == 0)
                {
                    /* Nothing's selected, so select the first item, if any.
                    */
                    ListView_SetItemState( pInfo->hwndLvNumbers, 0,
                        LVIS_SELECTED, LVIS_SELECTED );
                }
            }
            break;
        }

        case CID_CR_PB_Edit:
        {
            if (wNotification == BN_CLICKED)
                CbutilEdit( pInfo->hwndDlg, pInfo->hwndLvNumbers );
            break;
        }

        case CID_CR_PB_Delete:
        {
            if (wNotification == BN_CLICKED)
                CbutilDelete( pInfo->hwndDlg, pInfo->hwndLvNumbers );
            break;
        }

        case IDOK:
        {
            TRACE("OK pressed");
            CrSave( pInfo );
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CrInit(
    IN HWND   hwndDlg,
    IN EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    ** dialog window.  'pArgs' is caller's argument to the stub API.
    **
    ** Return false if focus was set, true otherwise, i.e. as defined for
    ** WM_INITDIALOG.
    */
{
    DWORD   dwErr;
    CRINFO* pInfo;

    TRACE("CrInit");

    /* Allocate the dialog context block.  Initialize minimally for proper
    ** cleanup, then attach to the dialog window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE("Context set");
    }

    /* Initialize page-specific context information.
    */
    pInfo->hwndRbNo = GetDlgItem( hwndDlg, CID_CR_RB_No );
    ASSERT(pInfo->hwndRbNo);
    pInfo->hwndRbYes = GetDlgItem( hwndDlg, CID_CR_RB_Yes );
    ASSERT(pInfo->hwndRbYes);
    pInfo->hwndLvNumbers = GetDlgItem( hwndDlg, CID_CR_LV_Numbers );
    ASSERT(pInfo->hwndLvNumbers);
    pInfo->hwndPbEdit = GetDlgItem( hwndDlg, CID_CR_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbDelete = GetDlgItem( hwndDlg, CID_CR_PB_Delete );
    ASSERT(pInfo->hwndPbDelete);

    /* Initialize the listview.
    */
    CbutilFillLvNumbers(
        pInfo->hwndDlg, pInfo->hwndLvNumbers,
        pArgs->pUser->pdtllistCallback, pArgs->fRouter );

    /* Set the radio button selection, which triggers appropriate
    ** enabling/disabling.
    */
    {
        HWND  hwndRb;

        if (pArgs->pEntry->dwCallbackMode == CBM_No)
            hwndRb = pInfo->hwndRbNo;
        else
        {
            ASSERT(pArgs->pEntry->dwCallbackMode==CBM_Yes);
            hwndRb = pInfo->hwndRbYes;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    /* Center dialog on the owner window.
    */
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
CrSave(
    IN CRINFO* pInfo )

    /* Saves dialog settings in the entry.  'PInfo' is the dialog context.
    */
{
    PBENTRY* pEntry;

    TRACE("CrSave");

    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    if (IsDlgButtonChecked( pInfo->hwndDlg, CID_CR_RB_No ))
        pEntry->dwCallbackMode = CBM_No;
    else
        pEntry->dwCallbackMode = CBM_Yes;

    pEntry->dwfOverridePref |= RASOR_CallbackMode;
    pEntry->fDirty = TRUE;
    pInfo->pArgs->pUser->fDirty = TRUE;

    CbutilSaveLv(
        pInfo->hwndLvNumbers, pInfo->pArgs->pUser->pdtllistCallback );
}


VOID
CrTerm(
    IN HWND hwndDlg )

    /* Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    */
{
    CRINFO* pInfo = (CRINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE("CrTerm");

    // pmay: 213060
    //
    // Cleanup the numbers
    //
    if ( pInfo->hwndLvNumbers )
    {
        CbutilLvNumbersCleanup( pInfo->hwndLvNumbers );
    }

    if (pInfo)
    {
        Free( pInfo );
    }
}


VOID
CrUpdateLvAndPbState(
    IN CRINFO* pInfo )

    /* Enables/disables the list view and associated buttons.  ListView is
    ** gray unless auto-callback is selected.  Buttons gray unless
    ** auto-callback selected and there is an item selected.
    */
{
    BOOL fEnableList;
    BOOL fEnableButton;

    fEnableList = Button_GetCheck( pInfo->hwndRbYes );
    if (fEnableList)
    {
        fEnableButton =
            ListView_GetSelectedCount( pInfo->hwndLvNumbers );
    }
    else
        fEnableButton = FALSE;

    EnableWindow( pInfo->hwndLvNumbers, fEnableList );
    EnableWindow( pInfo->hwndPbEdit, fEnableButton );
    EnableWindow( pInfo->hwndPbDelete, fEnableButton );
}

INT_PTR CALLBACK
SaDisableFirewallWarningDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch(unMsg)
    {
        case WM_COMMAND:
        {
            switch(LOWORD(wparam))
            {
            case IDYES:
            case IDNO:
                if(BST_CHECKED == IsDlgButtonChecked(hwnd, CID_SA_PB_DisableFirewallWarning))
                {
                    HKEY hFirewallKey;
                    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hFirewallKey, NULL))
                    {
                        DWORD dwValue = TRUE;
                        RegSetValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, 0, REG_DWORD, (CONST BYTE*)&dwValue, sizeof(dwValue));
                        RegCloseKey(hFirewallKey);
                    }
                }

                // fallthru
            case IDCANCEL:
                EndDialog(hwnd, LOWORD(wparam));
                break;

            }
            break;
        }
    }

    return FALSE;
}


BOOL SaIsAdapterDHCPEnabled(IHNetConnection* pConnection)
{
    HRESULT hr;
    BOOL fDHCP = FALSE;
    GUID* pAdapterGuid;
    hr = IHNetConnection_GetGuid(pConnection, &pAdapterGuid);
    if(SUCCEEDED(hr))
    {
        LPOLESTR pAdapterName;
        hr = StringFromCLSID(pAdapterGuid, &pAdapterName);
        if(SUCCEEDED(hr))
        {
            SIZE_T Length = wcslen(pAdapterName);
            LPSTR pszAnsiAdapterName = Malloc(Length + 1);
            if(NULL != pszAnsiAdapterName)
            {
                if(0 != WideCharToMultiByte(CP_ACP, 0, pAdapterName, (int)(Length + 1), pszAnsiAdapterName, (int)(Length + 1), NULL, NULL))
                {
                    HMODULE hIpHelper;
                    hIpHelper = LoadLibrary(L"iphlpapi");
                    if(NULL != hIpHelper)
                    {
                        DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO, PULONG);
                        
                        pGetAdaptersInfo = (DWORD (WINAPI*)(PIP_ADAPTER_INFO, PULONG)) GetProcAddress(hIpHelper, "GetAdaptersInfo");
                        if(NULL != pGetAdaptersInfo)
                        {
                            ULONG ulSize = 0;
                            if(ERROR_BUFFER_OVERFLOW == pGetAdaptersInfo(NULL, &ulSize))
                            {
                                PIP_ADAPTER_INFO pInfo = Malloc(ulSize);
                                if(NULL != pInfo)
                                {
                                    if(ERROR_SUCCESS == pGetAdaptersInfo(pInfo, &ulSize))
                                    {
                                        PIP_ADAPTER_INFO pAdapterInfo = pInfo;
                                        do
                                        {
                                            if(0 == lstrcmpA(pszAnsiAdapterName, pAdapterInfo->AdapterName))
                                            {
                                                fDHCP = !!pAdapterInfo->DhcpEnabled;
                                                break;
                                            }
                                            
                                        } while(NULL != (pAdapterInfo = pAdapterInfo->Next));
                                    }
                                    Free(pInfo);
                                }
                            }
                        }
                        FreeLibrary(hIpHelper);
                    }
                }
                Free(pszAnsiAdapterName);
            }
            CoTaskMemFree(pAdapterName);
        }
        CoTaskMemFree(pAdapterGuid);
    }

    return fDHCP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\entryw.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entryw.c
// Remote Access Common Dialog APIs
// Add Entry wizard
//
// 06/20/95 Steve Cobb
// 11/10/97 Shaun Cox, NT5/Connections rework


#include "rasdlgp.h"
#include "inetcfgp.h"
#include "netcon.h"
#include "rasuip.h"
#include "rassrvp.h"
#include <winscard.h>
#include "hnportmapping.h"
#include <wchar.h>

static int MAX_ENTERCONNECTIONNAME = 200;
DWORD
OpenPhonebookFile(
    BOOL    fForAllUsers,
    PBFILE* pFile )
{
    TCHAR pszPhonebookPath [MAX_PATH];

    pszPhonebookPath[0] = TEXT('\0');

    // Get the correct phonebook file path depending on whether it is
    // for all users or the current one.
    //
    if (fForAllUsers)
    {
        if(!GetPublicPhonebookPath( pszPhonebookPath ))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }
    }
    else
    {
        if(!GetPersonalPhonebookPath( NULL, pszPhonebookPath ))
        {
            return ERROR_CANNOT_OPEN_PHONEBOOK;
        }
    }

    return ReadPhonebookFile( pszPhonebookPath, NULL, NULL, 0, pFile );
}

VOID
ReOpenPhonebookFile(
    BOOL    fForAllUsers,
    PBFILE* pFile )
{
    // Close the previous phonebook file.
    //
    if (pFile)
    {
        ClosePhonebookFile( pFile );
    }

    // Open the one corresponding to the selection.
    //
    OpenPhonebookFile( fForAllUsers, pFile );
}


//----------------------------------------------------------------------------
// Local datatypes (alphabetically)
//----------------------------------------------------------------------------

// Add Entry wizard context block.  All property pages refer to the single
// context block associated with the sheet.
//
typedef struct
_AEINFO
{
    // Common input arguments.
    //
    EINFO* pArgs;

    // Wizard and page handles.
    //
    HWND hwndDlg;
    HWND hwndLa;
    HWND hwndMa;
    HWND hwndCn;    //Add for bug 328673
    HWND hwndPa;
    HWND hwndBs;    
    HWND hwndDa;
    HWND hwndPn;
    HWND hwndUs;
    HWND hwndDt;
    HWND hwndEn;
    HWND hwndGh;
    HWND hwndDn;
    HWND hwndSw;
    HWND hwndSp;
    HWND hwndSc;

    // Legacy application page.
    //
    HFONT hfontBold;

    // Modem/Adapter page.
    //
    HWND hwndLv;

    // Connection Name page.
    //
    HWND hwndCnName;
    HWND hwndCnStHMsg;
    HWND hwndCnStHMsg2;
    HWND hwndCnEbConnectionName;    //Add for bug 328673
    BOOL fCnWizNext;              //if Back button is pressed

    // Phone number page.
    //
    HWND hwndEbNumber;

    // Smart Card page
    //
    HWND hwndScRbYes;
    HWND hwndScRbNo;

    // Destination page.
    //
    HWND hwndEbHostName;

    // Broadband service page
    //
    HWND hwndEbBroadbandService;

    // Public network page.
    //
    HWND hwndLbDialFirst;

    // Entry Name page.
    //
    HWND hwndEbEntryName;

    // Shared Access private-lan page
    //
    HWND hwndSpLbPrivateLan;

    // User/default connection windows
    //
    HWND hwndUsRbForAll;
    HWND hwndUsRbForMe;

    HWND hwndDtCbFirewall;          //add for whistler bug 328673
    HWND hwndDtCbDefault;
    HWND hwndDtCbUseCredentials;
    HWND hwndDtEbUserName;
    HWND hwndDtEbPassword;
    HWND hwndDtEbPassword2;
    HWND hwndDtStUserName;
    HWND hwndDtStPassword;
    HWND hwndDtStPassword2;

    // Set true when there is only one meaningful choice of device.
    //
    BOOL fSkipMa;

    // Set true if the selected device is a modem or null modem.
    //
    BOOL fModem;

    // Set to true if there are no connections to show on the public
    // network page and therefore no reason to show the page.
    //
    BOOL fHidePublicNetworkPage;

    // Set true if administrator/power user wants the entry available to all
    // users.
    //
    BOOL fCreateForAllUsers;
    BOOL fFirewall;     //for whistler bug 328673 

    // The NB_* mask of protocols configured for RAS.
    //
    DWORD dwfConfiguredProtocols;

    // Set true if IP is configured for RAS.
    //
    BOOL fIpConfigured;

    // Area-code and country-code helper context block, and a flag indicating
    // if the block has been initialized.
    //
    CUINFO cuinfo;
    BOOL fCuInfoInitialized;

    // List of area codes passed CuInit plus all strings retrieved with
    // CuGetInfo.  The list is an editing duplicate of the one from the
    // PBUSER.
    //
    DTLLIST* pListAreaCodes;

    // Scripting utility context block, and a flag indicating if the block has
    // been initialized.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;

    // Set to true if we want to show the host pages in the dcc wizard, false
    // otherwise.  If true, rassrvui will administer most of the wizard.
    BOOL fDccHost;

    // The context used to identify the modifications being made through the
    // dcc host wizard
    PVOID pvDccHostContext;

    // Flags that track whether a smart card reader is installed and whether
    // the user has opted to use it.
    BOOL fSmartCardInstalled;
    BOOL fUseSmartCard;

    // Modem device dialog
    BOOL fMaAlreadyInitialized;

    //For Isdn devices on Ma page, for whislter bug 354542
    //
    BOOL fMultilinkAllIsdn;
}
AEINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

AEINFO*
AeContext(
    IN HWND hwndPage );

void
AeSetContext(
    IN HWND   hwndPage,
    IN LPARAM lparam);

void
AeFinish(
    IN AEINFO* pInfo );

DWORD
AeInit(
    IN HWND         hwndOwner,
    IN EINFO*       pEinfo,
    OUT AEINFO**    ppInfo );

VOID
AeTerm(
    IN AEINFO* pInfo );

BOOL
ApCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
BsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
BsInit(
    IN HWND hwndPage );

BOOL
BsKillActive(
    IN AEINFO* pInfo );

BOOL
BsSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
CnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CnInit(
    IN HWND hwndPage );

BOOL
CnKillActive(
    IN AEINFO* pInfo );

BOOL
CnSetActive(
    IN AEINFO* pInfo );

BOOL
CnCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DaInit(
    IN HWND hwndPage );

BOOL
DaKillActive(
    IN AEINFO* pInfo );

BOOL
DaSetActive(
    IN AEINFO* pInfo );

BOOL
DnCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DtCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );
    
BOOL
DnInit(
    IN HWND hwndPage );

BOOL
DnKillActive(
    IN AEINFO* pInfo );

BOOL
DnSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
DtDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DtInit(
    IN HWND hwndPage );

BOOL
DtKillActive(
    IN AEINFO* pInfo );

BOOL
DtSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
EnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
EnInit(
    IN HWND hwndPage );

BOOL
EnKillActive(
    IN AEINFO* pInfo );

BOOL
EnSetActive(
    IN AEINFO* pInfo );

BOOL
GhCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
GhDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
GhInit(
    IN HWND hwndPage );

BOOL
GhKillActive(
    IN AEINFO* pInfo );

BOOL
GhSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
LaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
LaInit(
    IN HWND hwndPage );

BOOL
LaKillActive(
    IN AEINFO* pInfo );

BOOL
LaSetActive(
    IN AEINFO* pInfo );


INT_PTR CALLBACK
MaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
MaInit(
    IN HWND hwndPage );

LVXDRAWINFO*
MaLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

BOOL
MaSetActive(
    IN AEINFO* pInfo );

BOOL
MaKillActive(
    IN AEINFO* pInfo );

BOOL
PaCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
PaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PaInit(
    IN HWND hwndPage );

BOOL
PaKillActive(
    IN AEINFO* pInfo );

BOOL
PaSetActive(
    IN AEINFO* pInfo );

VOID
PnClearLbDialFirst(
    IN HWND hwndLbDialFirst );

INT_PTR CALLBACK
PnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PnInit(
    IN HWND hwndPage );

BOOL
PnKillActive(
    IN AEINFO* pInfo );

BOOL
PnSetActive(
    IN AEINFO* pInfo );

VOID
PnDialAnotherFirstSelChange(
    IN AEINFO* pInfo );

VOID
PnUpdateLbDialAnotherFirst(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
ScDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ScInit(
    IN HWND hwndPage );

BOOL
ScKillActive(
    IN AEINFO* pInfo );

BOOL
ScSetActive(
    IN AEINFO* pInfo );

BOOL
ScSmartCardReaderInstalled(
    IN AEINFO* pInfo);

INT_PTR CALLBACK
SpDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SpInit(
    IN HWND hwndPage );

BOOL
SpKillActive(
    IN AEINFO* pInfo );

BOOL
SpSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
StDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
StInit(
    IN HWND hwndPage,
    IN OUT AEINFO* pInfo );

BOOL
StKillActive(
    IN AEINFO* pInfo );

BOOL
StSetActive(
    IN AEINFO* pInfo );

BOOL
SwCommand(
    IN AEINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SwInit(
    IN HWND hwndPage );

BOOL
SwKillActive(
    IN AEINFO* pInfo );

BOOL
SwSetActive(
    IN AEINFO* pInfo );

INT_PTR CALLBACK
UsDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
UsInit(
    IN HWND hwndPage );

BOOL
UsKillActive(
    IN AEINFO* pInfo );

BOOL
UsSetActive(
    IN AEINFO* pInfo );

// This is as good of a hack as I could think of to incorporate the direct
// connect host ui wizard pages without actually exposing the resources and
// functions that implement them (which are in the project, rassrvui)
#define DCC_HOST_PROCID ((DLGPROC)0x1)

struct PAGE_INFO
{
    DLGPROC     pfnDlgProc;
    INT         nPageId;
    INT         nSidTitle;
    INT         nSidSubtitle;
    DWORD       dwConnectionFlags;
};

static const struct PAGE_INFO c_aWizInfo [] =
{
    { 
        StDlgProc, 
        PID_ST_Start,           
        0,            
        0,               
        RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry
    },
    
    { 
        LaDlgProc, 
        PID_LA_NameAndType,     
        SID_LA_Title, 
        SID_LA_Subtitle, 
        RASEDFLAG_NewEntry 
    },
    
    { 
        MaDlgProc, 
        PID_MA_ModemAdapter,    
        SID_MA_Title, 
        SID_MA_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry  
    },

//put Guest/Host page before Connection Name page for bug 328673
//
    { 
        GhDlgProc, 
        PID_GH_GuestHost,       
        SID_GH_Title, 
        SID_GH_Subtitle, 
        RASEDFLAG_NewDirectEntry 
    },


//Add a new wizard page to get Connection Name, this is not available for rasphone.exe
//for whistler bug 328673       gangz
//
    {
        CnDlgProc,
        PID_CN_ConnectionName,
        SID_CN_Title,
        SID_CN_SubtitleInternet,
        RASEDFLAG_AnyNewEntry | RASEDFLAG_ShellOwned
    },
    
    { 
        PaDlgProc, 
        PID_PA_PhoneNumber,     
        SID_PA_Title, 
        SID_PA_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry  
    },
    
    { 
        PnDlgProc, 
        PID_PN_PublicNetwork,   
        SID_PN_Title, 
        SID_PN_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewTunnelEntry 
    },
    
    { 
        DaDlgProc, 
        PID_DA_VpnDestination,  
        SID_DA_Title, 
        SID_DA_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewTunnelEntry 
    },
    
    { 
        BsDlgProc, 
        PID_BS_BroadbandService,
        SID_BS_Title, 
        SID_BS_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewBroadbandEntry 
    },
    
    { 
        ScDlgProc, 
        PID_SC_SmartCard,       
        SID_SC_Title, 
        SID_SC_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry  
    },
    
    { 
        DnDlgProc, 
        PID_DN_DccDevice,       
        SID_DN_Title, 
        SID_DN_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewDirectEntry 
    },
    
    { 
        DCC_HOST_PROCID,          
        0,       
        0, 
        0, 
        RASEDFLAG_NewDirectEntry 
    },
    
    { 
        UsDlgProc, 
        PID_US_Users,           
        SID_US_Title, 
        SID_US_Subtitle, 
        RASEDFLAG_AnyNewEntry | RASEDFLAG_ShellOwned 
    },
    
    { 
        DtDlgProc, 
        PID_DT_DefaultInternet, 
        SID_DT_Title, 
        SID_DT_Subtitle, 
        RASEDFLAG_AnyNewEntry | RASEDFLAG_ShellOwned 
    },
    
    { 
        SwDlgProc, 
        PID_SW_SharedAccess,    
        SID_SW_Title, 
        SID_SW_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry | RASEDFLAG_NewBroadbandEntry
    },
    
    { 
        SpDlgProc, 
        PID_SP_SharedLan,       
        SID_SP_Title, 
        SID_SP_Subtitle, 
        RASEDFLAG_NewEntry | RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry | RASEDFLAG_NewBroadbandEntry 
    },
    
    { 
        EnDlgProc, 
        PID_EN_EntryName,       
        SID_EN_Title, 
        SID_EN_Subtitle, 
        RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry 
    },
};
#define c_cWizPages    (sizeof (c_aWizInfo) / sizeof(c_aWizInfo[0]))

//----------------------------------------------------------------------------
// Private exports - New client connection wizard
//----------------------------------------------------------------------------

DWORD
APIENTRY
NccCreateNewEntry(
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwPbkFile,
    OUT LPWSTR  pszwEntryName,
    OUT DWORD*  pdwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fIcRunning = FALSE;

    if (!pvData || !pszwPbkFile || !pszwEntryName || !pdwFlags)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;

        // If the direct connect wizard went down the host path, then we
        // need to instruct the shell to create the "Incoming Connections"
        // connection.
        if (pInfo->fDccHost)
        {
            RassrvCommitSettings (pInfo->pvDccHostContext, RASWIZ_TYPE_DIRECT);
            *pdwFlags = NCC_FLAG_CREATE_INCOMING;
            return NO_ERROR;
        }

        // Otherwise, create the phone book entry
        ASSERT (pInfo->pArgs->file.pszPath);
        ASSERT (pInfo->pArgs->pEntry->pszEntryName);

        lstrcpynW( pszwPbkFile,   pInfo->pArgs->file.pszPath,         MAX_PATH );
        lstrcpynW( pszwEntryName, pInfo->pArgs->pEntry->pszEntryName, MAX_PATH );
        *pdwFlags = (pInfo->fCreateForAllUsers) ? NCC_FLAG_ALL_USERS : 0;

        //Add this for the Account and password page, only available for consumer
        //platform. for whistler bug 328673         gangz
        //
        if(pInfo->fFirewall)
        {
            *pdwFlags |= NCC_FLAG_FIREWALL;
        }

        AeFinish( pInfo );

        EuCommit( pInfo->pArgs );

        //Setup port mapping for this new connection
        //According to the VPN enable/disable and
        // IC exist/non-exist condition and 
        // if it is a Firewall available platform
        //
        //Detect if Incoming Connection exists 
        //If it is a DccHost connection, SetPortMapping
        //is already done in RassrvCommitSettings()
        //
        if ( pInfo->fFirewall &&    //For bug 342810
             (NO_ERROR == RasSrvIsServiceRunning( &fIcRunning )) && 
             fIcRunning
             )
        {
            HnPMConfigureSingleConnectionGUIDIfVpnEnabled( pInfo->pArgs->pEntry->pGuid, FALSE, NULL );
        }

        dwErr = pInfo->pArgs->pApiArgs->dwError;
    }
    return dwErr;
}

DWORD
APIENTRY
NccGetSuggestedEntryName(
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (!pvData || !pszwSuggestedName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;
        PBENTRY* pEntry = pInfo->pArgs->pEntry;
        LPTSTR pszName;

        // If this is a dcc host connection, ask the ras server
        // module for the name.
        if (pInfo->fDccHost)
        {
            WCHAR pszBuf[MAX_PATH];
            DWORD dwSize = MAX_PATH;
            DWORD dwErr;
            if ((dwErr = RassrvGetDefaultConnectionName(pszBuf, &dwSize)) != NO_ERROR)
                return dwErr;
            lstrcpynW(pszwSuggestedName, pszBuf, MAX_PATH);
            return NO_ERROR;
        }


        // If pFile is NULL, it probably means that the wizard page
        // to determine where the phonebook should be stored was never
        // visited.
        //
        if (!pInfo->pArgs->pFile)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            dwErr = GetDefaultEntryName(
                NULL,
                pEntry->dwType,
                FALSE, &pszName );
            if (ERROR_SUCCESS == dwErr)
            {
                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                lstrcpynW( pszwSuggestedName, pszName, MAX_PATH );

                Free( pszName );
            }
        }
    }
    return dwErr;
}

DWORD
APIENTRY
NccQueryMaxPageCount()
{
    // Return the number of pages in the array   We subtract
    // 1 from this since DCC_HOST_PROCID takes a space in the array.
    return c_cWizPages - 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   NccSetEntryName
//
//  Purpose:
//
//  Arguments:
//      pvData   []
//      pszwName []
//
//  Returns:    ERROR_SUCCESS, ERROR_INVALID_PARAMETER,
//              ERROR_NOT_ENOUGH_MEMORY or ERROR_DUP_NAME.
//
//  Author:     shaunco   21 Jan 1998
//
//  Notes:
//
DWORD
APIENTRY
NccSetEntryName(
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName)
{
    DWORD dwErr = ERROR_SUCCESS;
    AEINFO* pInfo = (AEINFO*)pvData;

    if (!pvData || !pszwName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else if (pInfo->fDccHost)
    {
        // dwErr = ERROR_CAN_NOT_COMPLETE;
        dwErr = ERROR_SUCCESS;
    }
    else if (ERROR_SUCCESS == (dwErr = LoadRasapi32Dll()))
    {
        // Validate the entry name against the current phonebook.
        // If we can't open the phonebook, its okay.  It just means
        // it hasn't been created yet.  The name is valid in this case.
        //
        dwErr = g_pRasValidateEntryName (pInfo->pArgs->pFile->pszPath,
                    pszwName);
        if (ERROR_ALREADY_EXISTS == dwErr)
        {
            dwErr = ERROR_DUP_NAME;
        }
        else if ((ERROR_SUCCESS == dwErr) ||
                 (ERROR_CANNOT_OPEN_PHONEBOOK == dwErr))
        {
            PBENTRY* pEntry = pInfo->pArgs->pEntry;

            dwErr = ERROR_SUCCESS;

            Free( pEntry->pszEntryName );
            pEntry->pszEntryName = StrDup( pszwName );
            if (!pEntry->pszEntryName)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return dwErr;
}


//+---------------------------------------------------------------------------
//
//  Function:   NccIsEntryRenamable
//
//  Purpose:    Returns whether the user should be allowed
//              to rename the given connection.
//
//  Arguments:
//      pvData   []
//      pfRenamable     // Set to TRUE if renamable
//
//  Returns:    ERROR_SUCCESS, ERROR_INVALID_PARAMETER,
//              ERROR_NOT_ENOUGH_MEMORY or ERROR_DUP_NAME.
//
//  Author:     pmay    2/4/98
//
//  Notes:
//
DWORD
APIENTRY
NccIsEntryRenamable(
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable)
{
    AEINFO* pInfo = (AEINFO*)pvData;

    if (!pInfo || !pfRenamable)
        return ERROR_INVALID_PARAMETER;

    // Only dcc host connections are non-renamable
    *pfRenamable =  !pInfo->fDccHost;

    return NO_ERROR;
}


DWORD
APIENTRY
RasWizCreateNewEntry(
    IN  DWORD    dwRasWizType,
    IN  LPVOID   pvData,
    OUT LPWSTR   pszwPbkFile,
    OUT LPWSTR   pszwEntryName,
    OUT DWORD*   pdwFlags)
{
    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccCreateNewEntry(pvData, pszwPbkFile, pszwEntryName, pdwFlags);
            break;

        case RASWIZ_TYPE_INCOMING:
            return RassrvCommitSettings((HWND)pvData, RASWIZ_TYPE_INCOMING);
            break;
    }

    return ERROR_INVALID_PARAMETER;
}

// Add for whistler bug 328673
// This is function is called by folder team just before the 
// RasWizCreateNewEntry(), because it is only meaningful to call it
// after the rasdlg wizard pages are done

DWORD
APIENTRY
RasWizGetNCCFlags(
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT DWORD * pdwFlags)
{
    DWORD dwErr = NO_ERROR;
    
    if (!pvData || !pdwFlags)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;

        *pdwFlags = 0;
        switch (dwRasWizType)
        {
            case RASWIZ_TYPE_DIRECT:
            case RASWIZ_TYPE_DIALUP:
            case RASWIZ_TYPE_BROADBAND:
                if (pInfo->fDccHost)
                {
                    *pdwFlags |= NCC_FLAG_CREATE_INCOMING;
                    dwErr =  NO_ERROR;
                }
                else
                {
                    if ( pInfo->fCreateForAllUsers )
                    {
                        //the connecntion is created for all users
                        //for Us page
                        //
                        *pdwFlags |= NCC_FLAG_ALL_USERS;    
                    }

                    if(pInfo->fFirewall)
                    {
                         *pdwFlags |= NCC_FLAG_FIREWALL;
                    }

                    if ( IsConsumerPlatform())
                    {
                        if (pInfo->pArgs->fGlobalCred)
                        {
                            //The password is saved for every users
                            //for Dt page
                            //
                            *pdwFlags |= NCC_FLAG_GLOBALCREDS;
                        }
                    }

                    if ( pInfo->pArgs->fDefInternet )
                    {
                        *pdwFlags |= NCC_FLAG_DEFAULT_INTERNET;
                    }

                    if ( pInfo->pArgs->fGlobalCred )
                    {
                        *pdwFlags |= NCC_FLAG_GLOBALCREDS;
                    }
                    
                    dwErr = NO_ERROR;
                }
                break;

            case RASWIZ_TYPE_INCOMING:
                *pdwFlags |= NCC_FLAG_CREATE_INCOMING;
                dwErr =  NO_ERROR;
                break;
                
            default:
                dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    return dwErr;
}

//This is function is called by folder team just before the 
//RasWizCreateNewEntry()
//
DWORD
APIENTRY
RasWizGetUserInputConnectionName (
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwInputName)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (!pvData || !pszwInputName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        AEINFO* pInfo = (AEINFO*)pvData;
        WCHAR * pszwTemp = NULL;
        
        if ( pInfo->pArgs->pEntry->pszEntryName )
        {
            pszwTemp = StrDupWFromT( pInfo->pArgs->pEntry->pszEntryName );
            if (!pszwTemp)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                // Truncate to maximum name length (including terminating NULL) 
                // that rest of MAX_PATH can be appened by netcfg
                //
                lstrcpynW(pszwInputName, pszwTemp, MAX_ENTERCONNECTIONNAME);
                Free0(pszwTemp);
            }
         }
         else
         {
            dwErr = ERROR_NO_DATA;
          }
    }

    return dwErr;
}


DWORD
APIENTRY
RasWizGetSuggestedEntryName (
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT LPWSTR  pszwSuggestedName)
{
    DWORD dwSize = MAX_PATH;

    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccGetSuggestedEntryName(pvData, pszwSuggestedName);
            break;

        case RASWIZ_TYPE_INCOMING:
            return RassrvGetDefaultConnectionName(pszwSuggestedName, &dwSize);
            break;
    }

    return ERROR_INVALID_PARAMETER;
}


DWORD
APIENTRY
RasWizQueryMaxPageCount (
    IN  DWORD    dwRasWizType)
{
    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_BROADBAND:
            return NccQueryMaxPageCount();
            break;

        case RASWIZ_TYPE_DIRECT:
            {
                DWORD dwDirect;

                // Find out whether the dcc wizard option should be disabled
                // based on whether we allow it.
                if (! AllowDccWizard(NULL))
                    return 0;

                // Find out how many pages the server library needs for dcc.
                // If 0 pages are returned from RassrvQueryMaxPageCount, it means
                // that we shouldn't display the direct connect wizard (which is
                // true for member nts or dc nts.)  By returning 0, we tell the
                // shell that the given type isn't available.
                if ((dwDirect = RassrvQueryMaxPageCount (RASWIZ_TYPE_DIRECT)) == 0)
                    return 0;

                return dwDirect + NccQueryMaxPageCount();
            }
            break;

        case RASWIZ_TYPE_INCOMING:
            return RassrvQueryMaxPageCount(RASWIZ_TYPE_INCOMING);
            break;
    }

    return ERROR_INVALID_PARAMETER;
}


DWORD
APIENTRY
RasWizSetEntryName (
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    IN  LPCWSTR pszwName)
{
    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccSetEntryName(pvData, pszwName);
            break;

        case RASWIZ_TYPE_INCOMING:
            // We'll accept it even though we don't do anything with it.
            return NOERROR;
            break;
    }

    return ERROR_INVALID_PARAMETER;
}

DWORD
APIENTRY
RasWizIsEntryRenamable (
    IN  DWORD   dwRasWizType,
    IN  LPVOID  pvData,
    OUT BOOL*   pfRenamable)
{
    if (!pfRenamable)
        return ERROR_INVALID_PARAMETER;

    switch (dwRasWizType)
    {
        case RASWIZ_TYPE_DIALUP:
        case RASWIZ_TYPE_DIRECT:
        case RASWIZ_TYPE_BROADBAND:
            return NccIsEntryRenamable(pvData, pfRenamable);
            break;

        case RASWIZ_TYPE_INCOMING:
            *pfRenamable = FALSE;
            return NO_ERROR;
            break;
    }

    return ERROR_INVALID_PARAMETER;
}


// 232097: (shaunco) Fix a memory leak in the shell-owned case.
// For start pages which don't get created, WM_DESTROY won't be called which
// is where we used to free the memory.  Free the memory via a propsheet
// callback function associated only with the start page in shell-owned mode.
//
UINT
CALLBACK
DestroyStartPageCallback (
    HWND            hwnd,
    UINT            unMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (PSPCB_RELEASE == unMsg)
    {
        AEINFO* pInfo;
        EINFO*  pArgs;

        pInfo = (AEINFO*)ppsp->lParam;
        ASSERT( pInfo );

        ASSERT( pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned );

        pArgs = pInfo->pArgs;

        AeTerm( pInfo );    // pInfo invalid after this call

        EuFree( pArgs );
    }

    // for PSPCB_CREATE == unMsg, returning non-zero means create the page.
    // Ignored for PSPCB_RELEASE.
    //
    return 1;
}


//----------------------------------------------------------------------------
// Add Entry wizard entry point
//----------------------------------------------------------------------------
BOOL
AeIsWorkPlace(DWORD dwFlags)
{
    TRACE("AeIsWorkPlace");

    if( RASEDFLAG_InternetEntry  & dwFlags ||
        RASEDFLAG_NewDirectEntry & dwFlags)
   {
        return FALSE;
    }
   else
   {
        return TRUE;
    }
}


//Add this for whistler 364818  gangz
//
AeTitle(RASENTRYDLG * pArgs,
        struct PAGE_INFO  c_aPageInfo)
{
    INT nTitle = 0;
    
    TRACE("AeTitle");

    if( !pArgs )
    {
        nTitle = c_aPageInfo.nSidTitle;
    }
    else if ( c_aPageInfo.nPageId == PID_DT_DefaultInternet )
    {
        if ( pArgs->dwFlags & RASEDFLAG_InternetEntry )    
        {
            nTitle = SID_DT_Title;
        }
        else if( pArgs->dwFlags & RASEDFLAG_NewDirectEntry )
        {
            nTitle = SID_DT_TitleWork;
        }
        else
        {
            nTitle = SID_DT_TitleWork;
        }
    }
    else
    {
        nTitle = c_aPageInfo.nSidTitle;
     }

   return nTitle;
}


INT
AeSubTitle(RASENTRYDLG * pArgs,
           struct PAGE_INFO  c_aPageInfo)
{
    INT nSubTitle = 0;
    
    TRACE("AeSubTitle");

    if( !pArgs )
    {
        nSubTitle = c_aPageInfo.nSidSubtitle;
    }
    else if ( c_aPageInfo.nPageId == PID_CN_ConnectionName )
    {
    //Return different subtitle for Conneciton Name page
    //
        if( RASEDFLAG_InternetEntry & pArgs->dwFlags )
        {
            nSubTitle =  SID_CN_SubtitleInternet;
        }
        else if( RASEDFLAG_NewDirectEntry & pArgs->dwFlags )
        {
            nSubTitle = SID_CN_SubtitleDccGuest;
        }
        else
        {
            nSubTitle =  SID_CN_SubtitleWork;
        }
    }
    //Add this for whistler 364818
    //
    else if ( c_aPageInfo.nPageId == PID_DT_DefaultInternet )
    {
        if ( RASEDFLAG_InternetEntry & pArgs->dwFlags )    
        {
            nSubTitle = SID_DT_Subtitle;
        }
        else if ( RASEDFLAG_NewDirectEntry & pArgs->dwFlags )
        {
            nSubTitle = SID_DT_SubtitleWork;
        }
        else
        {
            nSubTitle = SID_DT_SubtitleWork;
        }
    }
    //Add this for whistler bug 382701
    //
    else if ( c_aPageInfo.nPageId == PID_PA_PhoneNumber )
    {
        if ( RASEDFLAG_InternetEntry & pArgs->dwFlags )    
        {
            nSubTitle = SID_PA_Subtitle;
        }
        else 
        {
            nSubTitle = SID_PA_SubtitleWork;
        }
        
    }
    else
    {
        nSubTitle = c_aPageInfo.nSidSubtitle;
     }

   return nSubTitle;
}

VOID
AeWizard(
    IN OUT EINFO* pEinfo )

    // Runs the Phonebook entry property sheet.  'PEinfo' is an input block
    // with only caller's API arguments filled in.
    //
{
    AEINFO*             pAeinfo;
    RASEDSHELLOWNEDR2*  pShellOwnedInfo = NULL;
    BOOL                fShellOwned;
    BOOL                fShowSharedAccessUi = TRUE;
    HPROPSHEETPAGE      ahpage [ c_cWizPages ];
    HPROPSHEETPAGE*     phpage = ahpage;
    INT                 i;
    HRESULT             hr;
    INetConnectionUiUtilities * pncuu = NULL;
   

    TRACE("AeWizard");

    if (0 != AeInit( pEinfo->pApiArgs->hwndOwner, pEinfo, &pAeinfo ))
    {
        return;
    }

    fShellOwned = (pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned);

    if (fShellOwned)
    {
        pShellOwnedInfo = (RASEDSHELLOWNEDR2*)pEinfo->pApiArgs->reserved2;
        pShellOwnedInfo->pvWizardCtx = pAeinfo;
    }

    if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewTunnelEntry)
    {
        EuChangeEntryType (pEinfo, RASET_Vpn);
    }
    else if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewDirectEntry)
    {
        EuChangeEntryType (pEinfo, RASET_Direct);
    }
    else if (pEinfo->pApiArgs->dwFlags & RASEDFLAG_NewBroadbandEntry)
    {
        EuChangeEntryType (pEinfo, RASET_Broadband);
    }
    else if (!(pEinfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry))
    {
        ASSERT (RASET_Phone == pEinfo->pEntry->dwType);
    }

    // Check if ZAW is denying access to the Shared Access UI
    //
    hr = HrCreateNetConnectionUtilities(&pncuu);
    if (SUCCEEDED(hr))
    {
        fShowSharedAccessUi = INetConnectionUiUtilities_UserHasPermission(
                                        pncuu, NCPERM_ShowSharedAccessUi);
        INetConnectionUiUtilities_Release(pncuu);
    }
    
    for (i = 0; i < c_cWizPages; i++)
    {
        if (pEinfo->pApiArgs->dwFlags & c_aWizInfo[i].dwConnectionFlags)
        {
            // If the page specifies that it is for shell-owned scenarios
            // only and this is not a shell-owned scenario, then don't add 
            // the page to the property sheet.  (124654)
            //
            if ((c_aWizInfo[i].dwConnectionFlags & RASEDFLAG_ShellOwned) && 
                !(pEinfo->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
            {
                continue;
            }
        
            // HACK: Add the host-side direct connect pages if needed.
            if (c_aWizInfo[i].pfnDlgProc == DCC_HOST_PROCID)
            {
                if (fShellOwned)
                {
                    RassrvAddDccWizPages(
                        pShellOwnedInfo->pfnAddPage, pShellOwnedInfo->lparam,
                        &(pAeinfo->pvDccHostContext) );
                }
            }
            else if ((c_aWizInfo[i].nPageId == PID_SW_SharedAccess) && !fShowSharedAccessUi)
            {
                // Do not add the Shared Access Ui if disallowed by ZAW
                //
                continue;
            }
            else
            {
                // Otherwise, add pages as normal.
                PROPSHEETPAGE page;
                ZeroMemory (&page, sizeof(page));

                page.dwSize       = sizeof(PROPSHEETPAGE);
                page.hInstance    = g_hinstDll;
                page.pszTemplate  = MAKEINTRESOURCE( c_aWizInfo[i].nPageId );
                page.pfnDlgProc   = c_aWizInfo[i].pfnDlgProc;
                page.lParam       = (LPARAM )pAeinfo;

                if (c_aWizInfo[i].nSidTitle)
                {
                    page.dwFlags |= PSP_USEHEADERTITLE;
                    page.pszHeaderTitle = PszLoadString( g_hinstDll,
                            AeTitle(pEinfo->pApiArgs, c_aWizInfo[i]) );  //For whstler bug 364818
                }

                if(c_aWizInfo[i].nSidSubtitle)
                {
                   page.dwFlags |= PSP_USEHEADERSUBTITLE;
                   page.pszHeaderSubTitle = PszLoadString( g_hinstDll,
                            AeSubTitle(pEinfo->pApiArgs, c_aWizInfo[i]) );
                }

                if (fShellOwned &&
                    (PID_ST_Start == c_aWizInfo[i].nPageId))
                {
                    page.dwFlags |= PSP_USECALLBACK;
                    page.pfnCallback = DestroyStartPageCallback;
                }

                *phpage = CreatePropertySheetPage( &page );

                if (fShellOwned)
                {
                    ASSERT (*phpage);
                    pShellOwnedInfo->pfnAddPage (*phpage, pShellOwnedInfo->lparam);
                }

                phpage++;
            }
        }
    }

    if (!fShellOwned)
    {
        PROPSHEETHEADER header;
        ZeroMemory( &header, sizeof(header) );
        header.dwSize           = sizeof(PROPSHEETHEADER);
        header.dwFlags          = PSH_WIZARD | PSH_WIZARD97
                                | PSH_WATERMARK | PSH_HEADER
                                | PSH_STRETCHWATERMARK;
        header.hwndParent       = pEinfo->pApiArgs->hwndOwner;
        header.hInstance        = g_hinstDll;
        header.nPages           = (ULONG)(phpage - ahpage);
        header.phpage           = ahpage;
        header.pszbmHeader      = MAKEINTRESOURCE( BID_WizardHeader );

        if (-1 == PropertySheet( &header ))
        {
            TRACE("PropertySheet failed");
            ErrorDlg( pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg,
                ERROR_UNKNOWN, NULL );
        }

        AeTerm (pAeinfo);
    }
}


//----------------------------------------------------------------------------
// Add Entry wizard
// Listed alphabetically
//----------------------------------------------------------------------------


AEINFO*
AeContext(
    IN HWND hwndPage )

    // Retrieve the property sheet context from a wizard page handle.
    //
{
    return (AEINFO* )GetWindowLongPtr( hwndPage, DWLP_USER );
}

void
AeSetContext(
    IN HWND   hwndPage,
    IN LPARAM lparam)
{
    AEINFO* pInfo = (AEINFO* )(((PROPSHEETPAGE* )lparam)->lParam);
    SetWindowLongPtr( hwndPage, DWLP_USER, (ULONG_PTR )pInfo );
}

void
AeFinish(
    IN AEINFO* pInfo )

    // Saves the contents of the wizard.  'HwndPage is the handle of a
    // property page.  Pops up any errors that occur.  'FPropertySheet'
    // indicates the user chose to edit the property sheet directly.
    //
{
    PBENTRY* pEntry;

    TRACE("AeFinish");

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    // Retrieve information from the phone number set of controls.
    //
    if (RASET_Phone == pEntry->dwType)
    {
        PBLINK* pLink;
        DTLNODE* pPhoneNode;

        pLink = (PBLINK* )DtlGetData( pInfo->pArgs->pSharedNode );
        ASSERT( pLink );

        pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
        if (pPhoneNode)
        {
            CuGetInfo( &pInfo->cuinfo, pPhoneNode );
            FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pPhoneNode );
        }

        /*

        // Bug #221837: (danielwe) Default to disable file and print sharing
        // for dialup connections.
        //
        pEntry->fShareMsFilePrint = FALSE;

        // Disable File and Print services by default
        //
        EnableOrDisableNetComponent( pEntry, TEXT("ms_server"),
            FALSE);

        */            
        
    }

    // Retrieve the hostname information if this is a Vpn wizard.
    //
    else if (RASET_Vpn == pEntry->dwType)
    {
    // !!! Share code with stuff in PeApply.
        DTLNODE* pNode;
        PBLINK* pLink;
        PBPHONE* pPhone;

        // Save host name, i.e. the VPN phone number.
        //
        pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

        if(NULL == pNode)
        {
            return;
        }
        
        pPhone = (PBPHONE* )DtlGetData( pNode );
        Free0( pPhone->pszPhoneNumber );
        pPhone->pszPhoneNumber = GetText( pInfo->hwndEbHostName );
        FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

        // Whistler bug 312921
        //
        // Default the "automatic" setting in the ui to mean 
        // "try pptp first".  This is because in the Whistler timeframe
        // we found that l2tp/ipsec was not being widely deployed so
        // people were more commonly getting unneccessary timeout delays
        // while the client would attempt l2tp to no avail.
        //
        pEntry->dwVpnStrategy = VS_PptpFirst;
        
    }

    // Retrieve the service name information if this is a broadband wizard.
    //
    else if (RASET_Broadband == pEntry->dwType)
    {
        // !!! Share code with stuff in PeApply.
        DTLNODE* pNode;
        PBLINK* pLink;
        PBPHONE* pPhone;

        // Save service name, i.e. the broadband phone number.
        //
        pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        pNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );

        if(NULL == pNode)
        {
            return;
        }
        
        pPhone = (PBPHONE* )DtlGetData( pNode );
        Free0( pPhone->pszPhoneNumber );
        pPhone->pszPhoneNumber = GetText( pInfo->hwndEbBroadbandService );
        FirstPhoneNodeToPhoneList( pLink->pdtllistPhones, pNode );

        // 222177, pppoe connections should default to unsecure
        //
        pEntry->dwTypicalAuth = TA_Unsecure;
        pEntry->dwAuthRestrictions = 
            AuthRestrictionsFromTypicalAuth(TA_Unsecure);
    }

    else if ( RASET_Direct == pEntry->dwType )
    {
        PBLINK* pLink = NULL;
        DTLNODE* pNode = NULL;

        // The currently enabled device is the one
        // that should be used for the connection.  Only
        // one device will be enabled (DnUpdateSelectedDevice).
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if ( pLink->fEnabled )
                break;
        }

        // If we found a link successfully, deal with it
        // now.
        if ( pLink && pLink->fEnabled )
        {
            if (pLink->pbport.pbdevicetype == PBDT_ComPort)
            {
                // Install the null modem
                MdmInstallNullModem (pLink->pbport.pszPort);

                // Delete the bogus device name.  This will cause
                // the device to automatically be mapped to the
                // null modem we just installed when the phonebook
                // is next read.
                Free0 ( pLink->pbport.pszDevice );
                pLink->pbport.pszDevice = NULL;
            }
        }

        // DCC guest should by default enable LM Hash in MSCHAPv1
        // Whistler bug 216458
        //
        pEntry->dwAuthRestrictions |= AR_F_AuthW95MSCHAP | AR_F_AuthCustom;
        
    }

    // If the user opted to use his/her smart card for this
    // connection, set up the entry accordingly now.
    if ( ( pInfo->fSmartCardInstalled ) &&
         ( pInfo->fUseSmartCard ) )
    {
        pEntry->dwAuthRestrictions = AR_F_TypicalCardOrCert;
        pEntry->dwTypicalAuth = TA_CardOrCert;
        pEntry->dwCustomAuthKey = EAPCFG_DefaultKey;
        pEntry->dwDataEncryption = DE_Require;
    }

    // Default Software compression ON.
    //
    pEntry->fSwCompression = TRUE;

    // Set the appropriate defaults if this is an "Internet" 
    // connection
    //
    if ((pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_InternetEntry) ||
         (RASET_Broadband == pEntry->dwType)) // all broadband are to Internet
    {
        // IP only
        //
        pEntry->dwfExcludedProtocols |= (NP_Nbf | NP_Ipx);

        // Disable file and print sharing
        //
        pEntry->fShareMsFilePrint = FALSE;
        pEntry->fBindMsNetClient = FALSE;
        EnableOrDisableNetComponent( pEntry, TEXT("ms_server"), FALSE);
        EnableOrDisableNetComponent( pEntry, TEXT("ms_msclient"), FALSE);
        pEntry->dwIpNbtFlags = 0;

        // Enable redial on link failure
        //
        pEntry->fRedialOnLinkFailure = TRUE;

        // Add default idle timeout for whistler bug 307969     gangz
        //
        if ( RASET_Phone == pEntry->dwType )
        {
            pEntry->lIdleDisconnectSeconds = 1200;
         }
        else
        {
            pEntry->lIdleDisconnectSeconds = 0;
         }

        // Enable PAP -- most common to ISPs
        //
        pEntry->dwTypicalAuth = TA_Unsecure;
        pEntry->dwAuthRestrictions = 
            AuthRestrictionsFromTypicalAuth(pEntry->dwTypicalAuth);

        // Do not include a domain -- not logging into secure domain
        //
        pEntry->fPreviewDomain = FALSE;

        // Record that this is a connection to the Internet
        //
        pEntry->dwUseFlags |= PBK_ENTRY_USE_F_Internet;
        
    }        


    // It's a valid new entry and caller has not chosen to edit properties
    // directly, so mark the entry for commitment.
    //
    if (!pInfo->pArgs->fChainPropertySheet)
        pInfo->pArgs->fCommit = TRUE;
}


DWORD
AeInit(
    IN  HWND        hwndParent,
    IN  EINFO*      pArgs,
    OUT AEINFO**    ppInfo )

    // Wizard level initialization.  'HwndPage' is the handle of the first
    // page.  'pInfo' is the common entry input argument block.
    //
    // Returns address of the context block if successful, NULL otherwise.  If
    // NULL is returned, an appropriate message has been displayed, and the
    // wizard has been cancelled.
    //
{
    AEINFO* pInfo;

    TRACE("AeInit");

    *ppInfo = NULL;

    pInfo = Malloc( sizeof(AEINFO) );
    if (!pInfo)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppInfo = pInfo;

    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->pArgs = pArgs;

    if ( pArgs->fRouter )
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pArgs->pApiArgs->reserved;

        // Check for installed protocols over router and RasServer if router
        // bit is set.
        //
        pInfo->dwfConfiguredProtocols =
            g_pGetInstalledProtocolsEx((pIArgs) ? pIArgs->hConnection : NULL,
                                       TRUE, FALSE, TRUE);
    }
    else
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pArgs->pApiArgs->reserved;

        // Check over which protocols is dial up client enabled.
        //
        pInfo->dwfConfiguredProtocols = g_pGetInstalledProtocolsEx(
                                                (pIArgs) ?
                                                pIArgs->hConnection :
                                                NULL, FALSE, TRUE, FALSE);
    }

    pInfo->fIpConfigured = (pInfo->dwfConfiguredProtocols & NP_Ip);

    //initialization for RasWizGetNCCFlags()
    //
    pInfo->fCreateForAllUsers = TRUE;   //for this for Dt Page
    pInfo->fFirewall = FALSE;
    pInfo->pArgs->fGlobalCred  = FALSE;
    pInfo->pArgs->fDefInternet = FALSE;

    return ERROR_SUCCESS;
}


VOID
AeTerm(
    IN AEINFO* pInfo )
{
    TRACE("AeTerm");

    if (pInfo)
    {
        if (pInfo->hwndLbDialFirst)
        {
            PnClearLbDialFirst( pInfo->hwndLbDialFirst );
        }

        if (pInfo->hfontBold)
        {
            DeleteObject (pInfo->hfontBold);
        }

        if (pInfo->pListAreaCodes)
        {
            DtlDestroyList( pInfo->pListAreaCodes, DestroyPszNode );
        }

        if (pInfo->fCuInfoInitialized)
        {
            CuFree( &pInfo->cuinfo );
        }

        Free (pInfo);
    }
}


//This broadband serice page is shared by AiWizard(ifw.c) and AeWizard(in entryw.c)
//
//----------------------------------------------------------------------------
// Broadband service dialog procedure
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
BsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the broadband service page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return BsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("BsSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = BsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("BsKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = BsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
BsInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("BsInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndBs = hwndPage;
    pInfo->hwndEbBroadbandService = 
        GetDlgItem( hwndPage, CID_BS_EB_ServiceName );
    ASSERT(pInfo->hwndEbBroadbandService);

    Edit_LimitText( pInfo->hwndEbBroadbandService, RAS_MaxPhoneNumber );

    return TRUE;
}


BOOL
BsKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}


BOOL
BsSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);

    //For bug 364818, we decide to remove Broadband's service name
    //From the NCW      gang
    //
    return FALSE;    

    /*
    pEntry = pInfo->pArgs->pEntry;

    if (RASET_Broadband != pEntry->dwType)
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or we have the 
        // LA page before us.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewTunnelEntry))
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
    */
}


//Add ConnectionName Dialog proc for whistler bug 328673
//
//----------------------------------------------------------------------------
// Connection Name property page, this is only for shellowned, the filtering
// is already done in AeWizard()
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------
INT_PTR CALLBACK
CnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Connection Name page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return CnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("CnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = CnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("CnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = CnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    AEINFO* pInfo;

                    TRACE("CnNEXT");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);

                    pInfo->fCnWizNext = TRUE;
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

            }
            break;
        }

    }

    return FALSE;
}


BOOL
CnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    
    TRACE("CnInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    // A DCC host conneciton will be forward to the incoming connection path
    //
    if ( pInfo->fDccHost )
    {
        return TRUE;
     }

    //This page wont be available for rasphone.exe
    //the filtering is done in AeWizard
    //

    pInfo->hwndCn = hwndPage;
    pInfo->hwndCnEbConnectionName = GetDlgItem( hwndPage, CID_CN_EB_ConnectionName );
    ASSERT(pInfo->hwndCnEbConnectionName);
    pInfo->hwndCnStHMsg = GetDlgItem( hwndPage, CID_CN_ST_HMsg );
    ASSERT(pInfo->hwndCnStHMsg);
    pInfo->hwndCnStHMsg2 = GetDlgItem( hwndPage, CID_CN_ST_HMsg2 );
    ASSERT(pInfo->hwndCnStHMsg2);
    pInfo->hwndCnName = GetDlgItem( hwndPage, CID_CN_Name );
    ASSERT(pInfo->hwndCnName);

    //the length does NOT include the terminating NULL character
    //in order to match the RasWizGetUserInputConnectionName()
    //we need to minus one from the lenght limit
    //

    //
    //For whistler bug 270255, for the sake of creating short cut which will be placed
    //under "Documents and Setttings\...", we dynamically limit the maximum connection
    //name
    //
    {
        long lPathLen = 0;
        WCHAR szPath[MAX_PATH];

        if (SHGetSpecialFolderPath(hwndPage, 
                               szPath, 
                               CSIDL_DESKTOPDIRECTORY, 
                               FALSE))
        {
            lPathLen = wcslen(szPath);
        }

        if (SHGetSpecialFolderPath(hwndPage, 
                               szPath, 
                               CSIDL_COMMON_DESKTOPDIRECTORY, 
                               FALSE))
        {
            lPathLen = max(lPathLen, (long)wcslen(szPath));
        }

        // We need to take the following lengths into acount:
        // "\\\\?\\"            - 4
        // "(path)"             - dwPathLen (Desktop path)
        // "\\"                 - 1
        // "(connection name)"  - rest from MAX_PATH
        // "(number)"           - 5 (duplicate counter, should not exceed 5 digits)
        // ".lnk"               - 4
        // "\0"                 - 1
        
        ASSERT( 9 < (MAX_PATH - lPathLen - 15));
        if( 9 >= (MAX_PATH - lPathLen - 15) )
        {
            MAX_ENTERCONNECTIONNAME = 9; //We sacrifice the shortcut for the NCW task
         }
        else
        {
            MAX_ENTERCONNECTIONNAME = min(MAX_ENTERCONNECTIONNAME,
                                          MAX_PATH - lPathLen - 15);
        }
    }

    Edit_LimitText( pInfo->hwndCnEbConnectionName, MAX_ENTERCONNECTIONNAME-1);//RAS_MaxEntryName );

    // Set the static text box
    //
   {
    DWORD dwFlags;
    TCHAR *pszMsg = NULL, *pszSubTitle = NULL, *pszMsg2 = NULL, *pszName=NULL;
    HWND   hwndHMsg = NULL, hwndPage = NULL, hwndHMsg2 = NULL, hwndName = NULL;

    hwndHMsg  = pInfo->hwndCnStHMsg;
    hwndHMsg2 = pInfo->hwndCnStHMsg2;
    hwndPage  = pInfo->hwndCn;
    hwndName  = pInfo->hwndCnName;

    if(!hwndHMsg || !hwndPage || !hwndHMsg2 ||!hwndName)
    {
        return FALSE;
    }

    //Set the  message on this page, the subtitle is set in AeWizard
    //by help function AeSubTitle()
    //
    {
        dwFlags = pInfo->pArgs->pApiArgs->dwFlags;
        
        if (dwFlags & RASEDFLAG_NewDirectEntry) 
        {
            pszMsg = PszFromId( g_hinstDll, SID_CN_HMsgDccGuest );
            pszName = PszFromId( g_hinstDll, SID_CN_NameDccGuest );
        }
        else if( dwFlags & RASEDFLAG_InternetEntry)
        {
            pszMsg = PszFromId( g_hinstDll, SID_CN_HMsgInternet );
            pszName = PszFromId( g_hinstDll, SID_CN_NameInternet );
        }
        else
        {
            pszMsg = PszFromId( g_hinstDll, SID_CN_HMsgWork );
            pszMsg2 = PszFromId( g_hinstDll, SID_CN_HMsgWork2 );
            pszName = PszFromId( g_hinstDll, SID_CN_NameWork );
        }
     }

     if(pszMsg)
     {
        if(hwndHMsg)
        {
          SetWindowText(hwndHMsg, pszMsg);
        }
        
        Free(pszMsg);
     }

     if (pszMsg2)
     {
        if(hwndHMsg2)
        {
          SetWindowText(hwndHMsg2, pszMsg2);
        }
        
        Free(pszMsg2);
     }

    if (pszName)
    {
        if(hwndName)
        {
          SetWindowText(hwndName, pszName);
        }

        Free(pszName);
    }
  }

    return TRUE;
}

//For whistler bug 346886
//

BOOL CnValidName(TCHAR * pszSrc)
{
    WCHAR pszwInvalidChars[] = L"\\/:*?\"<>|\t";
    WCHAR * pszwSrc=NULL;
    BOOL fValid = TRUE;

    if(!pszSrc)
    {
        return FALSE;
     }

    pszwSrc = StrDupWFromT(pszSrc);
    ASSERT(pszwSrc);
    if(!pszwSrc)
    {
        return TRUE;
    }

    fValid= ( !wcspbrk( pszwSrc, pszwInvalidChars ) )?TRUE:FALSE;

     return fValid;
}

BOOL
CnKillActive(
    IN AEINFO* pInfo)

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    TCHAR* psz = NULL;

    TRACE("CnKillActive");
    
    // A DCC host conneciton will be forward to the incoming connection path
    //
    if ( pInfo->fDccHost )
    {
        return FALSE;
    }
     
    Free0( pInfo->pArgs->pEntry->pszEntryName );
    pInfo->pArgs->pEntry->pszEntryName = NULL;

    //this GetText will always return an allocated buffer if memory
    //is availabe, if user input nothing, it will return a string has
    //only a NULL termination, TEXT('\0');
    //
    psz = GetText( pInfo->hwndCnEbConnectionName );
    if (psz)
    {
        // Update the entry name from the editbox.
        // We wont enfore a name to be entered, we also wont check if the
        // the name entered here is a duplicate, because it is just part 
        // of the final name
        //

        // Validate the entry name. It cannot begin with a "."
        //
        
        if( pInfo->fCnWizNext )
        {
            pInfo->fCnWizNext = FALSE;

            if ( 0 < lstrlen( psz ) && 
                 ( (psz[ 0 ] == TEXT('.') ) ||
                   !CnValidName(psz) )
                 )
            {
                Free0(psz);
                MsgDlg( pInfo->hwndDlg, SID_BadEntryWithDot, NULL );
                SetFocus( pInfo->hwndCnEbConnectionName );
                Edit_SetSel( pInfo->hwndCnEbConnectionName, 0, -1 );
                return TRUE;
            }
         }

        if( TEXT('\0') != psz[0] )
        {
            pInfo->pArgs->pEntry->pszEntryName = psz;
        }
        else
        {
            Free0(psz);
        }
    }

    return FALSE;
}

BOOL
CnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    TRACE("CnSetActive");

    // A DCC host conneciton will be forward to the incoming connection path
    //
    if ( pInfo->fDccHost )
    {
    /*
        //when forwarded to incoming connection path, there is no Connection page
        //beside, the incoming conneciton's name is not changable,
        //so we remove the possible entered connection by previous given path
        //like the DCC guest path
        //
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = NULL;
    */
        return FALSE;
     }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );

    return TRUE;
}


//----------------------------------------------------------------------------
// Destination property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Destination page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return DaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
DaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("DaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndDa = hwndPage;
    pInfo->hwndEbHostName = GetDlgItem( hwndPage, CID_DA_EB_HostName );
    ASSERT(pInfo->hwndEbHostName);

    Edit_LimitText( pInfo->hwndEbHostName, RAS_MaxPhoneNumber );

    return TRUE;
}


BOOL
DaKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}


BOOL
DaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (RASET_Vpn != pEntry->dwType)
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or, we have the
        // La page or the Pn page before us.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewTunnelEntry) ||
            !pInfo->fHidePublicNetworkPage)
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}

//----------------------------------------------------------------------------
// Default inTernet wizard page
// This is a personal-sku only page.
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Default inTernet page of the wizard.  
    // Parameters and return value are as described for standard 
    // windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return DtInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DtSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DtSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DtKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DtKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

DWORD
DtEnableDisableControls(
    IN AEINFO* pInfo,
    IN BOOL fEnable)
{
    EnableWindow(pInfo->hwndDtEbUserName,  fEnable );
    EnableWindow(pInfo->hwndDtEbPassword,  fEnable );
    EnableWindow(pInfo->hwndDtEbPassword2, fEnable );
    EnableWindow(pInfo->hwndDtStUserName,  fEnable );
    EnableWindow(pInfo->hwndDtStPassword,  fEnable );
    EnableWindow(pInfo->hwndDtStPassword2, fEnable );

    return NO_ERROR;
}

BOOL
DtInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    BOOL fWork = FALSE;

    TRACE("DtInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndDt           = hwndPage;
    pInfo->hwndDtCbFirewall = GetDlgItem( hwndPage, CID_DT_CB_Firewall );
    pInfo->hwndDtCbDefault  = GetDlgItem( hwndPage, CID_DT_CB_Default );
    pInfo->hwndDtEbUserName = GetDlgItem( hwndPage, CID_DT_EB_UserName );
    pInfo->hwndDtEbPassword = GetDlgItem( hwndPage, CID_DT_EB_Password );
    pInfo->hwndDtEbPassword2= GetDlgItem( hwndPage, CID_DT_EB_Password2 );
    pInfo->hwndDtStUserName = GetDlgItem( hwndPage, CID_DT_ST_UserName  );
    pInfo->hwndDtStPassword = GetDlgItem( hwndPage, CID_DT_ST_Password  );
    pInfo->hwndDtStPassword2= GetDlgItem( hwndPage, CID_DT_ST_Password2 );
    pInfo->hwndDtCbUseCredentials = 
        GetDlgItem( hwndPage, CID_DT_CB_UseSharedCredentials );

    Edit_LimitText( pInfo->hwndDtEbUserName,  UNLEN );
    Edit_LimitText( pInfo->hwndDtEbPassword,  PWLEN );
    Edit_LimitText( pInfo->hwndDtEbPassword2, PWLEN );

    {
        DWORD dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        if ( dwFlags & RASEDFLAG_NewDirectEntry ||
             dwFlags & RASEDFLAG_InternetEntry )
        {
            fWork = FALSE;
        }
        else
        {
            fWork = TRUE;
        }
    }        

    //Turn on the Domain bits for workplace path
    //Per the request of Jenellec and approved by Davidei and pmay,
    //we revert this change
    /*
    if(fWork)
    {
        pInfo->pArgs->pEntry->fPreviewDomain = 1;
    }
    */
    
    //Change the HeadMessage for workplace path
    //For whistler bug 364818       gangz
    //
    if( fWork ||
        (RASEDFLAG_NewDirectEntry & pInfo->pArgs->pApiArgs->dwFlags)
      )
    {
        HWND hwndHeadMsg = GetDlgItem( hwndPage, CID_DT_HeadMessage );

        TCHAR *  pszMsg = PszFromId( g_hinstDll, SID_DT_HMsgWork );

        if(pszMsg)
        {
            if(hwndHeadMsg)
            {
                SetWindowText( hwndHeadMsg, pszMsg);
            }
            Free(pszMsg);
        }
    }

    // Intialize the three check buttons, turn them off for the
    // workplace path        gangz
    //

    Button_SetCheck( pInfo->hwndDtCbDefault, !fWork );
    Button_SetCheck( pInfo->hwndDtCbUseCredentials, !fWork );

    //Show the Firewall check box according to 3 conditions
    //(1) Admin or Power Users
    //(2) only for Personal, Professional and Standard Server
    //(3) Group Policy enable it(GPA is not configues is viewed as enable)

    if (pInfo->pArgs->fIsUserAdminOrPowerUser &&
        IsFirewallAvailablePlatform() &&
        IsGPAEnableFirewall())
    {  
        EnableWindow( pInfo->hwndDtCbFirewall, TRUE );
        Button_SetCheck( pInfo->hwndDtCbFirewall, !fWork );
     }
    else
    {
        EnableWindow( pInfo->hwndDtCbFirewall, FALSE );
        ShowWindow( pInfo->hwndDtCbFirewall, SW_HIDE);
        pInfo->fFirewall = FALSE;
    }

    //Normal user doesnt have the privilege to set a connectoid
    //as a default internet connection
    //
    if ( !pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        Button_SetCheck( pInfo->hwndDtCbDefault, FALSE);
        EnableWindow(pInfo->hwndDtCbDefault, FALSE);
    }
    
    // Reset the title and subtitle if this is the work path
    // this is done in AeWizard() by calling AeTitle() and AeSubtitle()
    //

    // This entry is default to be available for all users
    //
   // pInfo->fCreateForAllUsers = TRUE; //this is done in AeInit()

    return TRUE;
}

BOOL
DtKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    // Remember whether to set this as the default Internet connection
    //
    BOOL fResult = FALSE;

   //Dont show the Account name page for DCC guest connection
   //for whistler bug 364818        gangz
   //
   if( pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_NewDirectEntry )
   {
        return  FALSE;
   }
   
    pInfo->pArgs->fDefInternet = 
        Button_GetCheck( pInfo->hwndDtCbDefault );

    //Add firewall check and GlobalCred for whistler bug 328673
    //
    pInfo->fFirewall = 
        Button_GetCheck( pInfo->hwndDtCbFirewall );

    pInfo->pArgs->fGlobalCred = 
        Button_GetCheck( pInfo->hwndDtCbUseCredentials );
        
    Free0(pInfo->pArgs->pszDefUserName);
    Free0(pInfo->pArgs->pszDefPassword);

    // Get the credentials
    //
    {
        TCHAR pszUserName[UNLEN + 1];
        TCHAR pszPassword[PWLEN + 1];
        TCHAR pszPassword2[PWLEN + 1];
        INT iLen;

        pszUserName[0] = TEXT('\0');
        pszPassword[0] = TEXT('\0');
        pszPassword2[0] = TEXT('\0');

        // Get the credentials
        //
        do {
            GetWindowText( pInfo->hwndDtEbUserName, pszUserName, UNLEN + 1);
            GetWindowText( pInfo->hwndDtEbPassword, pszPassword, PWLEN + 1);
            GetWindowText( pInfo->hwndDtEbPassword2, pszPassword2, PWLEN + 1);

            // Verify there is a user name
            //
            //Add for whistler bug 328673
            //User can leave the credential blank or must fill a complete
            //credential information
            //
        
            if ( 0 == lstrlen(pszUserName) &&
                 0 == lstrlen(pszPassword) &&
                 0 == lstrlen(pszPassword2) )
            {
                fResult = FALSE;
                break;
            }
        
            if (lstrlen(pszUserName) == 0)
            {
                MsgDlg(pInfo->hwndDt, SID_MissingUserName, NULL);
                fResult = TRUE;
                break;
            }

            // Verify the passwords match
            //
            if (lstrcmp(pszPassword, pszPassword2) != 0)
            {
                MsgDlg(pInfo->hwndDt, SID_PasswordMismatch, NULL);
                fResult = TRUE;
                break;
            }

            pInfo->pArgs->pszDefUserName = StrDup(pszUserName);
            if (pInfo->pArgs->pszDefUserName == NULL)
            {
                fResult = TRUE;
                break;
            }

            pInfo->pArgs->pszDefPassword = StrDup(pszPassword);
            if (pInfo->pArgs->pszDefPassword)
            {
                // Scramble the password
                //
                EncodePassword(pInfo->pArgs->pszDefPassword);
                fResult = FALSE;
            }
            else if (lstrlen(pszPassword))
            {
                // Copy failed
                fResult = TRUE;
            }
            else
            {
                fResult = FALSE;
            }
         }
        while(FALSE);
        
        // Clear passwords from temporary stack memory
        //
        ZeroMemory(pszPassword, sizeof(pszPassword));
        ZeroMemory(pszPassword2, sizeof(pszPassword2));
    }

    if ( fResult )
    {
        Free0(pInfo->pArgs->pszDefUserName);
        Free0(pInfo->pArgs->pszDefPassword);
    }
    
    return fResult;
}

BOOL
DtSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    if (pInfo->fDccHost)
    {
        return FALSE;
    }

    // Dont show the Account name page for DCC guest connection
    // or workpath connections
    // for whistler bug 364818  383533      gangz
    //
    if( RASEDFLAG_NewDirectEntry & pInfo->pArgs->pApiArgs->dwFlags ||
        !(RASEDFLAG_InternetEntry & pInfo->pArgs->pApiArgs->dwFlags)
        )
    {
        pInfo->pArgs->fDefInternet = FALSE;
        pInfo->fFirewall = FALSE;
        pInfo->pArgs->fGlobalCred = FALSE;
    
        return  FALSE;
    }

    // If this is a singer-user connection then we hide the option to save the
    // password globally.
    //
    if ( !pInfo->fCreateForAllUsers )
    {
        Button_SetCheck( pInfo->hwndDtCbUseCredentials, FALSE );
        EnableWindow( pInfo->hwndDtCbUseCredentials, FALSE );
        ShowWindow( pInfo->hwndDtCbUseCredentials, SW_HIDE );
    }
    else
    {
       ShowWindow( pInfo->hwndDtCbUseCredentials, SW_SHOW );
       EnableWindow( pInfo->hwndDtCbUseCredentials, TRUE );
       
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}

//----------------------------------------------------------------------------
// Entry Name property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
EnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Entry Name page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return EnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("EnRESET");
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("EnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = EnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("EnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = EnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZBACK:
                {
                    AEINFO* pInfo;

                    TRACE("EnWIZBACK");
                    pInfo = AeContext( hwnd );
                    PropSheet_SetWizButtons(pInfo->hwndDlg, PSWIZB_NEXT | PSWIZB_BACK);
                    return FALSE;
                }

                case PSN_WIZFINISH:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("EnWIZFINISH");

                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);

                    // You'd think pressing Finish would trigger a KILLACTIVE
                    // event, but it doesn't, so we do it ourselves.
                    //
                    fInvalid = EnKillActive( pInfo );
                    if (!fInvalid)
                    {
                        pInfo->pArgs->pUser->fDirty = TRUE;
                        SetUserPreferences(
                            NULL, pInfo->pArgs->pUser,
                            pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                        AeFinish( pInfo );
                    }

                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
EnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    DWORD    dwErr;
    AEINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("EnInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;
        
    // The shell owns the finished page, so if we're shell owned, don't
    // display ours.
    //
    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        return TRUE;
    }


    // Initialize page-specific context information.
    //
    pInfo->hwndEn = hwndPage;
    pInfo->hwndEbEntryName = GetDlgItem( hwndPage, CID_EN_EB_EntryName );
    ASSERT(pInfo->hwndEbEntryName);

    // Initialize the entry name field.
    //
    pEntry = pInfo->pArgs->pEntry;
    if (!pEntry->pszEntryName)
    {
        ASSERT( pInfo->pArgs->pFile );

        // No entry name, so think up a default.
        //
        dwErr = GetDefaultEntryName(
            NULL,
            pEntry->dwType,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
    }

    Edit_LimitText( pInfo->hwndEbEntryName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbEntryName, pEntry->pszEntryName );

    return TRUE;
}


BOOL
EnKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    TCHAR* psz;

    // The shell owns the finished page, so if we're shell owned, don't
    // display ours.
    //
    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        return FALSE;
    }

    psz = GetText( pInfo->hwndEbEntryName );
    if (psz)
    {
        // Update the entry name from the editbox.
        //
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = psz;

        // Validate the entry name.
        //
        if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
        {
            SetFocus( pInfo->hwndEbEntryName );
            Edit_SetSel( pInfo->hwndEbEntryName, 0, -1 );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    LPARAM dwWizButtons = PSWIZB_FINISH;
    DWORD  dwFlags      = pInfo->pArgs->pApiArgs->dwFlags;

    // The shell owns the finished page, so if we're shell owned, don't
    // display ours.
    //
    if (dwFlags & RASEDFLAG_ShellOwned)
    {
        return FALSE;
    }

    if (!(dwFlags & RASEDFLAG_CloneEntry))
    {
        dwWizButtons |= PSWIZB_BACK;
    }
    PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
    return TRUE;
}


INT_PTR CALLBACK
LaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the start page of the wizard.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return LaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("LaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = LaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("LaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = LaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
LaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.  'pInfo' is the arguments from the PropertySheet caller.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    DWORD   dwType;
    INT     nIdButton;
    HFONT   hfont;

    TRACE("LaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndLa = hwndPage;

    // Create the bold font and apply it to the buttons.
    //
    hfont = GetWindowFont (hwndPage);
    if (!hfont)
    {
        // If not found then the dialog is using the system font.
        //
        hfont = (HFONT )GetStockObject (SYSTEM_FONT);
    }
    if (hfont)
    {
        LOGFONT lf;

        // Get the font info so we can generate the bold version.
        //
        if (GetObject (hfont, sizeof(lf), &lf))
        {
            lf.lfWeight = FW_BOLD;
            hfont = CreateFontIndirect (&lf);

            if (hfont)
            {
                // Store this so we can destroy it during cleanup.
                //
                pInfo->hfontBold = hfont;

                // Set the fonts of the radio buttons using this bold font.
                //
                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Phone),
                    hfont, FALSE);

                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Tunnel),
                    hfont, FALSE);

                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Direct),
                    hfont, FALSE);

                SetWindowFont (GetDlgItem (hwndPage, CID_LA_RB_Broadband),
                    hfont, FALSE);
            }
        }
    }

    // Set the radio buttons.
    //
    dwType = pInfo->pArgs->pEntry->dwType;

    if (RASET_Phone == dwType)
    {
        nIdButton = CID_LA_RB_Phone;
    }
    else if (RASET_Vpn == dwType)
    {
        nIdButton = CID_LA_RB_Tunnel;
    }
    else if (RASET_Broadband == dwType)
    {
        nIdButton = CID_LA_RB_Broadband;
    }
    else
    {
        nIdButton = CID_LA_RB_Direct;
    }
    CheckDlgButton( hwndPage, nIdButton, BST_CHECKED );

    return TRUE;
}

BOOL
LaKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndLa, CID_LA_RB_Phone))
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Phone);
    }
    else if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndLa, CID_LA_RB_Tunnel))
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Vpn);
    }
    else if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndLa, CID_LA_RB_Broadband))
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Broadband);
    }
    else
    {
        EuChangeEntryType (pInfo->pArgs, RASET_Direct);
    }

    return FALSE;
}

BOOL
LaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    DWORD dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

    // If we are owned by the shell, then we are not displayed.
    //
    if (dwFlags & RASEDFLAG_ShellOwned)
    {
        return FALSE;
    }

    // If we were told by the caller, which type of entry we should be,
    // then we are not displayed.
    //
    if (dwFlags & (RASEDFLAG_NewPhoneEntry | RASEDFLAG_NewTunnelEntry |
                   RASEDFLAG_NewDirectEntry | RASEDFLAG_NewBroadbandEntry)) //Add _NewBroadbandEntry for bug237175
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    return TRUE;
}


//----------------------------------------------------------------------------
// Modem/Adapter property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
MaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Modem/Adapter page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, MaLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return MaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("MaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = MaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case LVXN_SETCHECK:
                {
                    AEINFO* pInfo;

                    TRACE("MaLVXNSETCHECK");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    if (ListView_GetCheckedCount(pInfo->hwndLv) > 0)
                    {
                        PropSheet_SetWizButtons(pInfo->hwndDlg,
                                                PSWIZB_BACK | PSWIZB_NEXT);
                    }
                    else
                    {
                        // Disable Next button if no items are checked
                        PropSheet_SetWizButtons(pInfo->hwndDlg, PSWIZB_BACK);
                    }
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("MaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = MaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
MaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("MaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndMa = hwndPage;
    pInfo->hwndLv = GetDlgItem( hwndPage, CID_MA_LV_Devices );
    ASSERT(pInfo->hwndLv);

    // Add the modem and adapter images.
    //
    ListView_InstallChecks( pInfo->hwndLv, g_hinstDll );
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    // Add a single column exactly wide enough to fully display
    // the widest member of the list.
    //
    {
        LV_COLUMN col;

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT;
        col.fmt = LVCFMT_LEFT;
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );
        ListView_SetColumnWidth( pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    }

    // Don't bother with this page if there's only one device.
    //
    if (DtlGetNodes( pInfo->pArgs->pEntry->pdtllistLinks ) < 2)
    {
        pInfo->fSkipMa = TRUE;
    }

    //For whislter bug 354542
    //
    pInfo->fMultilinkAllIsdn = FALSE;
    return FALSE;
}


LVXDRAWINFO*
MaLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    // Enhanced list view callback to report drawing information.  'HwndLv' is
    // the handle of the list view control.  'DwItem' is the index of the item
    // being drawn.
    //
    // Returns the address of the column information.
    //
{
    // Use "wide selection bar" feature and the other recommended options.
    //
    // Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    //
    static LVXDRAWINFO info =
        { 1, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}

BOOL
MaKillActive(
    IN AEINFO* pInfo )

    // Called when the modem/adapter page is loosing activation.
{
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (!pInfo->fSkipMa && (RASET_Phone == pEntry->dwType))
    {

        // Initialization of i to -1 is important here.  It means start
        // the search beginning with that item.
        //
        INT i = -1;

        //For whistler bug 354542
        //
        pInfo->fMultilinkAllIsdn = FALSE;

        while ((i = ListView_GetNextItem(pInfo->hwndLv, i, LVNI_ALL )) >= 0)
        {
            DTLNODE* pNode;

            pNode = (DTLNODE* )ListView_GetParamPtr( pInfo->hwndLv, i );

            if (pNode)
            {
                PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                ASSERT( pLink );

                // If we're multilinking all ISDN, we only need to
                // set enabled based on the check state if the device type
                // is not ISDN.  (If it is ISDN and we're multilinking, we've
                // already taken care of it below.
                //
                if (!pInfo->fMultilinkAllIsdn ||
                    (pLink->pbport.pbdevicetype != PBDT_Isdn))
                {
                    pLink->fEnabled = ListView_GetCheck( pInfo->hwndLv, i );
                }
            }
            //Only the Dummy "All available Isdn" item will return the NULL pLink
            //
            else if (ListView_GetCheck( pInfo->hwndLv, i ))
            {
                // ISDN multi-link selected.  Enable the ISDN multi-link
                // nodes, move them to the head of the list, and disable
                // all the other links.
                //
                DTLNODE* pNextNode;
                DTLNODE* pAfterNode;
                DTLLIST* pList;

                //For whistler bug 354542
                //
                pInfo->fMultilinkAllIsdn = TRUE;

                pList = pInfo->pArgs->pEntry->pdtllistLinks;

                pInfo->fModem = FALSE;

                pAfterNode = NULL;
                for (pNode = DtlGetFirstNode( pList );
                     pNode;
                     pNode = pNextNode)
                {
                    PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
                    ASSERT(pLink);

                    pNextNode = DtlGetNextNode( pNode );

                    if (pLink->pbport.pbdevicetype == PBDT_Isdn
                        && !pLink->fProprietaryIsdn)
                    {
                        pLink->fEnabled = TRUE;

                        DtlRemoveNode( pList, pNode );
                        if (pAfterNode)
                            DtlAddNodeAfter( pList, pAfterNode, pNode );
                        else
                            DtlAddNodeFirst( pList, pNode );
                        pAfterNode = pNode;
                    }
                    else
                    {
                        pLink->fEnabled = FALSE;
                    }
                }
            }
        }
    }

    return FALSE;
}

BOOL
MaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (pInfo->fSkipMa || (RASET_Phone != pEntry->dwType))
    {
        fDisplayPage = FALSE;
    }
    else
    {
        TCHAR*   psz;
        DTLNODE* pNode;
        DWORD    cMultilinkableIsdn;
        LV_ITEM  item;
        INT      iItem, iIndex;

        ListView_DeleteAllItems( pInfo->hwndLv );

        // Fill the list of devices and select the first item.
        //
        iItem = 1;
        cMultilinkableIsdn = 0;
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink;
            DWORD dwImage;

            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if ((pLink->pbport.pbdevicetype == PBDT_Isdn) &&
                !pLink->fProprietaryIsdn)
            {
                ++cMultilinkableIsdn;
            }

            psz = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
            if (psz)
            {
                PBLINK* pLink;

                pLink = (PBLINK* )DtlGetData( pNode );

                ZeroMemory( &item, sizeof(item) );
                item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.iItem   = iItem++;
                item.pszText = psz;
                item.iImage  = dwImage;
                item.lParam  = (LPARAM )pNode;

                iIndex = ListView_InsertItem( pInfo->hwndLv, &item );

                if (pInfo->fMaAlreadyInitialized)
                {
                    ListView_SetCheck(pInfo->hwndLv, iIndex, pLink->fEnabled);
                }
                else
                {
                    ListView_SetCheck(pInfo->hwndLv, iIndex, FALSE);
                }
                Free( psz );
            }
        }

        if (cMultilinkableIsdn > 1)
        {
            psz = PszFromId( g_hinstDll, SID_IsdnAdapter );
            if (psz)
            {
                LONG    lStyle;

                // Turn off sorting so the special ISDN-multilink item appears
                // at the top of the list.
                //
                lStyle = GetWindowLong( pInfo->hwndLv, GWL_STYLE );
                SetWindowLong( pInfo->hwndLv, GWL_STYLE,
                    (lStyle & ~(LVS_SORTASCENDING)) );

                ZeroMemory( &item, sizeof(item) );
                item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                item.iItem   = 0;
                item.pszText = psz;
                item.iImage  = DI_Adapter;
                item.lParam  = (LPARAM )NULL;

                iIndex = ListView_InsertItem( pInfo->hwndLv, &item );

                //For whislter bug 354542
                //
                ListView_SetCheck(pInfo->hwndLv, iIndex, pInfo->fMultilinkAllIsdn);
                
                Free( psz );
            }
        }

        // Select the first item.
        //
        ListView_SetItemState( pInfo->hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED );
        
        if (!pInfo->fMaAlreadyInitialized)
        {
            ListView_SetCheck( pInfo->hwndLv, 0, TRUE );

            {
                LPARAM dwWizButtons = PSWIZB_NEXT;
                DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

                if ((dwFlags & RASEDFLAG_ShellOwned) ||
                    !(dwFlags & RASEDFLAG_NewPhoneEntry))
                {
                    dwWizButtons |= PSWIZB_BACK;
                }

                PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
            }

            pInfo->fMaAlreadyInitialized = TRUE;
        }
        else
        {
            if (!ListView_GetCheckedCount(pInfo->hwndLv))
            {
                // Disable next button if no items checked
                PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK );
            }
        }

        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}


//----------------------------------------------------------------------------
// Phone Number property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
PaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Phone Number page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return PaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("PaSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = PaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = PaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

    }

    return FALSE;
}


BOOL
PaInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    CUINFO * pCuInfo = NULL;

    TRACE("PaInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndPa = hwndPage;
    pInfo->hwndEbNumber = GetDlgItem( hwndPage, CID_PA_EB_Number );
    ASSERT(pInfo->hwndEbNumber);

    // Initialize the complex phone number context and use those utilities to
    // set the phone number controls.
    //
    pInfo->pListAreaCodes = DtlDuplicateList(
        pInfo->pArgs->pUser->pdtllistAreaCodes,
        DuplicatePszNode, DestroyPszNode );

//Modify Phonenumber page for bug 328673       gangz
//Initialize pInfo->CuInfoCuInfo 
//
    pCuInfo=&pInfo->cuinfo;
    ZeroMemory(pCuInfo, sizeof(*pCuInfo) );

    pCuInfo->hwndStAreaCodes = NULL;
    pCuInfo->hwndClbAreaCodes = NULL;
    pCuInfo->hwndStPhoneNumber = NULL;
    pCuInfo->hwndEbPhoneNumber = pInfo->hwndEbNumber;
    pCuInfo->hwndStCountryCodes = NULL;
    pCuInfo->hwndLbCountryCodes = NULL;
    pCuInfo->hwndCbUseDialingRules = NULL;
    pCuInfo->hwndPbDialingRules = NULL;
    pCuInfo->hwndPbAlternates = NULL;
    pCuInfo->hwndStComment = NULL;
    pCuInfo->hwndEbComment = NULL;
    pCuInfo->pListAreaCodes = pInfo->pListAreaCodes;

    // Disaster defaults only.  Not used in normal operation.
    //
    pCuInfo->dwCountryId = 1;
    pCuInfo->dwCountryCode = 1;

    Edit_LimitText( pCuInfo->hwndEbPhoneNumber, RAS_MaxPhoneNumber );

    pInfo->fCuInfoInitialized = TRUE;

    // Load the phone number fields from the shared link.
    //
    {
        PBLINK* pLink;
        DTLNODE* pPhoneNode;

        pLink = (PBLINK* )DtlGetData( pInfo->pArgs->pSharedNode );
        ASSERT( pLink );

        pPhoneNode = FirstPhoneNodeFromPhoneList( pLink->pdtllistPhones );
        if (pPhoneNode)
        {
            CuSetInfo( &pInfo->cuinfo, pPhoneNode, FALSE );
            DestroyPhoneNode( pPhoneNode );
        }
    }

    Edit_SetSel( pInfo->hwndEbNumber, 0, -1 );
    SetFocus( pInfo->hwndEbNumber );

    return FALSE;
}


BOOL
PaKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false if it can be dismissed.
    //
{
    return FALSE;
}


BOOL
PaSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (RASET_Phone != pEntry->dwType)
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or, we have the
        // La page or the Ma page before us.  La page will be shown if
        // not RASEDFLAG_NewPhoneEntry.  Ma page will be shown if !fSkipMa.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewPhoneEntry) || !pInfo->fSkipMa)
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}

//----------------------------------------------------------------------------
// Public network property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
PnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Public Network page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return PnInit( hwnd );

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT (pInfo);

            switch (LOWORD(wparam))
            {
                case CID_PN_LB_DialAnotherFirst:
                {
                    if (HIWORD( wparam ) == CBN_SELCHANGE)
                    {
                        PnDialAnotherFirstSelChange( pInfo );
                        return TRUE;
                    }
                    break;
                }

                case CID_PN_RB_DoNotDialFirst:
                case CID_PN_RB_DialFirst:
                {
                    switch (HIWORD( wparam))
                    {
                        case BN_CLICKED:
                        {
                            PnUpdateLbDialAnotherFirst( pInfo );
                            return TRUE;
                        }
                    }
                    break;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("PnSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = PnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PnKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = PnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


VOID
PnClearLbDialFirst(
    IN HWND hwndLbDialFirst )

    // Clear prerequisite entry list box.  'hwndLbDialAnotherFirst' is the
    // window handle of the listbox control.  context.
    //
{
    PREREQITEM* pItem;

    while (pItem = ComboBox_GetItemDataPtr( hwndLbDialFirst, 0 ))
    {
        ComboBox_DeleteString( hwndLbDialFirst, 0 );
        Free0( pItem->pszEntry );
        Free0( pItem->pszPbk );
        Free( pItem );
    }
}


VOID
PnDialAnotherFirstSelChange(
    IN AEINFO* pInfo )
{
    PBENTRY* pEntry;
    PREREQITEM* pItem;
    INT iSel;

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialFirst );
    if (iSel < 0)
    {
        return;
    }

    pEntry = pInfo->pArgs->pEntry;

    Free0( pEntry->pszPrerequisiteEntry );
    Free0( pEntry->pszPrerequisitePbk );

    pItem = (PREREQITEM* )
        ComboBox_GetItemDataPtr( pInfo->hwndLbDialFirst, iSel );

    if(NULL != pItem)
    {
        pEntry->pszPrerequisiteEntry = StrDup( pItem->pszEntry );
        pEntry->pszPrerequisitePbk = StrDup( pItem->pszPbk );
    }
}

// !!! Make this common with GeFillLbDialAnotherFirst
VOID
PnUpdateLbDialAnotherFirst(
    IN AEINFO* pInfo )

    // Fill prerequisite entry list box with all non-VPN entries in the
    // phonebook, and select the prerequiste one.  'pInfo' is the property
    // sheet context.
    //
{
    BOOL fEnabledLb = FALSE;

    ComboBox_ResetContent( pInfo->hwndLbDialFirst );

    if (BST_CHECKED == IsDlgButtonChecked (pInfo->hwndPn,
                            CID_PN_RB_DialFirst))
    {
        DWORD i;
        INT iThis;
        INT iSel;
        TCHAR* pszEntry;
        TCHAR* pszPrerequisiteEntry;
        RASENTRYNAME* pRens;
        RASENTRYNAME* pRen;
        DWORD dwRens;

        PnClearLbDialFirst( pInfo->hwndLbDialFirst );

        iSel = 0;
        pszEntry = pInfo->pArgs->pEntry->pszEntryName;
        pszPrerequisiteEntry = pInfo->pArgs->pEntry->pszPrerequisiteEntry;

        if (GetRasEntrynameTable( &pRens, &dwRens ) != 0)
        {
            return;
        }

        for (i = 0, pRen = pRens; i < dwRens; ++i, ++pRen )
        {
            PREREQITEM* pItem;

            if (lstrcmp( pRen->szEntryName, pszEntry ) == 0)
            {
                continue;
            }

            pItem = Malloc( sizeof(PREREQITEM) );
            if (!pItem)
            {
                continue;
            }

            pItem->pszEntry = StrDup( pRen->szEntryName );
            pItem->pszPbk = StrDup( pRen->szPhonebookPath );

            if (!pItem->pszEntry || !pItem->pszPbk)
            {
                Free0( pItem->pszEntry );
                Free( pItem );
                continue;
            }

            iThis = ComboBox_AddItem(
                pInfo->hwndLbDialFirst, pItem->pszEntry,  pItem );

            if (pszPrerequisiteEntry && *(pszPrerequisiteEntry)
                && lstrcmp( pItem->pszEntry, pszPrerequisiteEntry ) == 0)
            {
                iSel = iThis;
                ComboBox_SetCurSelNotify( pInfo->hwndLbDialFirst, iSel );
            }
        }

        Free( pRens );

        if (iSel == 0)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbDialFirst, iSel );
        }

        fEnabledLb = TRUE;
    }
    else
    {
        // Toss the existing prerequesite entry since its disabled.
        //
        PBENTRY* pEntry = pInfo->pArgs->pEntry;

        Free0( pEntry->pszPrerequisiteEntry );
        pEntry->pszPrerequisiteEntry = NULL;
        Free0( pEntry->pszPrerequisitePbk );
        pEntry->pszPrerequisitePbk = NULL;
    }
    EnableWindow( pInfo->hwndLbDialFirst, fEnabledLb );
}


BOOL
PnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    PBENTRY *pEntry;

    TRACE("PnInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndPn = hwndPage;

    pInfo->hwndLbDialFirst =
        GetDlgItem( hwndPage, CID_PN_LB_DialAnotherFirst );
    ASSERT( pInfo->hwndLbDialFirst );

    pEntry = pInfo->pArgs->pEntry;

    if(RASET_Vpn == pEntry->dwType)
    {

        // Set the dial another first radio button so that the
        // combo box of entries to dial can be filled in.  If it
        // turns out that there were no entries we don't need to show the page.
        //
        CheckDlgButton( hwndPage, CID_PN_RB_DialFirst, BST_CHECKED );
    }

    PnUpdateLbDialAnotherFirst( pInfo );

    if (0 == ComboBox_GetCount( pInfo->hwndLbDialFirst ))
    {
        pInfo->fHidePublicNetworkPage = TRUE;
    }

    return TRUE;
}


BOOL
PnKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}

BOOL
PnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if (pInfo->fHidePublicNetworkPage || (RASET_Vpn != pEntry->dwType))
    {
        fDisplayPage = FALSE;
    }
    else
    {
        LPARAM dwWizButtons = PSWIZB_NEXT;
        DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

        // Show the back button if we're shell owned or, we have the
        // La page before us.  La page will be shown if
        // not RASEDFLAG_NewTunnelEntry.
        //
        if ((dwFlags & RASEDFLAG_ShellOwned) ||
            !(dwFlags & RASEDFLAG_NewTunnelEntry))
        {
            dwWizButtons |= PSWIZB_BACK;
        }

        PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
        fDisplayPage = TRUE;
    }

    return fDisplayPage;
}

//----------------------------------------------------------------------------
// Smart card wizard page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ScDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Smart Card page of the wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return ScInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("ScSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = ScSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("MaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = ScKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
ScInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("ScInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
     }

    //Smart card page is shown only for workplace path
    //
    if ( !AeIsWorkPlace(pInfo->pArgs->pApiArgs->dwFlags) )
    {
        pInfo->fSmartCardInstalled = FALSE;
        pInfo->fUseSmartCard = FALSE;

        return TRUE;
    }
    // Initialize page-specific context information.
    //
    pInfo->hwndSc = hwndPage;
    pInfo->hwndScRbYes = GetDlgItem ( hwndPage, CID_SC_RB_YesSmartCard );
    pInfo->hwndScRbNo = GetDlgItem ( hwndPage, CID_SC_RB_NoSmartCard );

    // Discover whether a smart card reader is installed.  If so, default
    // to not use it.
    //
    pInfo->fSmartCardInstalled = ScSmartCardReaderInstalled( pInfo );
    pInfo->fUseSmartCard = FALSE;

    return FALSE;
}

BOOL
ScKillActive(
    IN AEINFO* pInfo )

    // Called when the smart card page is loosing activation.  Records
    // whether the use selected to use his/her smart card.
{
    //Smart card page is shown only for workplace path
    //
    if ( !AeIsWorkPlace(pInfo->pArgs->pApiArgs->dwFlags) )
    {
        return FALSE;
    }

    pInfo->fUseSmartCard =
        ( SendMessage(pInfo->hwndScRbYes, BM_GETCHECK, 0, 0) == BST_CHECKED );

    return FALSE;
}

BOOL
ScSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    //Smart card page is shown only for workplace path
    //
    if ( !AeIsWorkPlace(pInfo->pArgs->pApiArgs->dwFlags) )
    {
        return FALSE;
    }

    // Initialize the "use smart card" check
    SendMessage (
        pInfo->hwndScRbYes,
        BM_SETCHECK,
        (pInfo->fUseSmartCard) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Initialize the "use smart card" check
    SendMessage (
        pInfo->hwndScRbNo,
        BM_SETCHECK,
        (pInfo->fUseSmartCard) ? BST_UNCHECKED : BST_CHECKED,
        0);

    // Only show the page when a smart card reader is installed
    return pInfo->fSmartCardInstalled;
}

BOOL
ScSmartCardReaderInstalled(
    IN AEINFO* pInfo)

    // Returns TRUE iff there is a smart card reader installed.
    // Clone of FSmartCardReaderInstalled in ppp\eaptls\util.c
    //
{
    LONG            lErr;
    DWORD           dwLen   = 0;
    SCARDCONTEXT    hCtx    = 0;
    BOOL            fReturn = FALSE;

    lErr = SCardListReadersA(0, NULL, NULL, &dwLen);

    fReturn = (   (NO_ERROR == lErr)
               && (2 * sizeof(CHAR) < dwLen));

    if (!fReturn)
    {
        goto LDone;
    }

    fReturn = FALSE;

    lErr = SCardEstablishContext(SCARD_SCOPE_USER, 0, 0, &hCtx);

    if (SCARD_S_SUCCESS != lErr)
    {
        goto LDone;
    }

    lErr = SCardListReadersA(hCtx, NULL, NULL, &dwLen);

    fReturn = (   (NO_ERROR == lErr)
               && (2 * sizeof(CHAR) < dwLen));

LDone:

    if (0 != hCtx)
    {
        SCardReleaseContext(hCtx);
    }
    
    return(fReturn);
}


INT_PTR CALLBACK
StDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the start page of the wizard.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            AEINFO* pInfo = (AEINFO* )(((PROPSHEETPAGE* )lparam)->lParam);
            SetWindowLongPtr( hwnd, DWLP_USER, (ULONG_PTR )pInfo );

            // Position the dialog per caller's instructions if we're not
            // owned by the shell.
            //
            if (!(pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned))
            {
                PositionDlg( GetParent( hwnd ),
                    pInfo->pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
                    pInfo->pArgs->pApiArgs->xDlg,
                    pInfo->pArgs->pApiArgs->yDlg );
            }

            return StInit( hwnd, pInfo );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("StSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = StSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("StKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = StKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
StInit(
    IN     HWND    hwndPage,
    IN OUT AEINFO* pInfo )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.  'pInfo' is the arguments from the PropertySheet caller.
    //
    // Return false if focus was set, true otherwise.
    //
{
    pInfo->hwndDlg = GetParent( hwndPage );

    // Initialize the common controls library for the controls we use.
    //
    {
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;
        InitCommonControlsEx (&icc);
    }

    return TRUE;
}

BOOL
StKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    return FALSE;
}

BOOL
StSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    return FALSE;
}


//----------------------------------------------------------------------------
// Users property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
UsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Users page of the wizard.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return UsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("UsSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = UsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("UsKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = UsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
UsInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("UsInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Don't execute on personal (DT page in this case)
    //
    if (IsConsumerPlatform())
    {
    //For consumer platform, personal or non-domain professional
    //all connections are all-user
        pInfo->fCreateForAllUsers = TRUE;
        return TRUE;
    }
    
    // Initialize page-specific context information.
    //
    pInfo->hwndUs = hwndPage;
    pInfo->hwndUsRbForAll = GetDlgItem( hwndPage, CID_US_RB_All ); 
    pInfo->hwndUsRbForMe  = GetDlgItem( hwndPage, CID_US_RB_Myself ); 
    
    // If the user is an administrator or power user, we want the default
    // to be to create the phone book entry for all users.  This
    // must correspond to how ReadPhonebookFile opens the default phonebook.
    //
    //For whistler bug 382795
    //We let the VPN connection default to "My use only"
    //
    if ( RASEDFLAG_NewTunnelEntry & pInfo->pArgs->pApiArgs->dwFlags )
    {
        pInfo->fCreateForAllUsers = FALSE;
    }
    else
    {    
        pInfo->fCreateForAllUsers = pInfo->pArgs->fIsUserAdminOrPowerUser;
    }

    return TRUE;
}

BOOL
UsKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    BOOL fCreateForAllUsers;

    // Don't execute on personal (DT page in this case)
    //
    if (IsConsumerPlatform())
    {
        return FALSE;
    }

    fCreateForAllUsers = Button_GetCheck( pInfo->hwndUsRbForAll );

    // We need to (re)open the phonebook file corresponding to the selection.
    // Only do this if the selection has changed, or we don't have the file
    // open yet.  We definitely need to have it open when this page is left
    // because subsequent pages depend on it.
    //
    if ((fCreateForAllUsers != pInfo->fCreateForAllUsers) ||
        !pInfo->pArgs->pFile ||
        (fCreateForAllUsers != IsPublicPhonebook(pInfo->pArgs->pFile->pszPath)))
    {

        pInfo->fCreateForAllUsers = fCreateForAllUsers;

        // Close and re-open the phonebook file since the All Users flag has
        // changed
        ReOpenPhonebookFile(pInfo->fCreateForAllUsers,
                            pInfo->pArgs->pFile);

    }

    return FALSE;
}

BOOL
UsSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    // Don't execute on personal (DT page in this case)
    //
    if (IsConsumerPlatform())
    {
        return FALSE;
    }
    
    if (pInfo->fDccHost)
    {
        return FALSE;
    }

    // We don't give the option to create all-user connections to non-admins.
    //
    if (!pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        EnableWindow( pInfo->hwndUsRbForAll, FALSE );

        //Change for whistler bug 283902    gangz
        //
        Button_SetCheck( pInfo->hwndUsRbForMe, TRUE);

    }

    // Set the radio buttons.
    //
    /*
    //For whistler bug 382795
    //We let the VPN connection default to "My use only"
    //
    if ( RASEDFLAG_NewTunnelEntry & pInfo->pArgs->pApiArgs->dwFlags )
    {
        Button_SetCheck( pInfo->hwndUsRbForAll, FALSE);
        Button_SetCheck( pInfo->hwndUsRbForMe, TRUE );
    }
    else
    */
    {
        Button_SetCheck( pInfo->hwndUsRbForAll, pInfo->fCreateForAllUsers );
        Button_SetCheck( pInfo->hwndUsRbForMe, !pInfo->fCreateForAllUsers );
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


//----------------------------------------------------------------------------
// Shared-access property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
SwDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared-access page of the wizard.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return SwInit( hwnd );

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return SwCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SwSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = SwSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SwKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = SwKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
SwCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "SwCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_SW_PB_Shared:
        {
            BOOL fShared =
                Button_GetCheck( GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared) );
            EnableWindow(
                GetDlgItem( pInfo->hwndSw, CID_SW_ST_DemandDial), fShared );
            EnableWindow(
                GetDlgItem( pInfo->hwndSw, CID_SW_PB_DemandDial), fShared );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
SwInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;

    TRACE("SwInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndSw = hwndPage;
    Button_SetCheck(
        GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared),
        pInfo->pArgs->fShared );
    Button_SetCheck(
        GetDlgItem(pInfo->hwndSw, CID_SW_PB_DemandDial),
        pInfo->pArgs->fDemandDial );
    SwCommand(
        pInfo, BN_CLICKED, CID_SW_PB_Shared,
        GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared) );

    return TRUE;
}


BOOL
SwKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    if (!pInfo->fCreateForAllUsers)
    {
        pInfo->pArgs->fNewShared = pInfo->pArgs->fShared;
        pInfo->pArgs->fNewDemandDial = pInfo->pArgs->fDemandDial;
    }
    else
    {
        pInfo->pArgs->fNewShared =
            Button_GetCheck( GetDlgItem(pInfo->hwndSw, CID_SW_PB_Shared) );
        pInfo->pArgs->fNewDemandDial =
            Button_GetCheck( GetDlgItem(pInfo->hwndSw, CID_SW_PB_DemandDial) );
        if (pInfo->pArgs->fNewShared)
        {
            UINT    unId;
            MSGARGS msgargs;
            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_YESNO | MB_ICONINFORMATION;
            unId = MsgDlg( pInfo->hwndDlg, SID_EnableSharedAccess, &msgargs );
            if (unId == IDNO)
            {
                pInfo->pArgs->fNewShared = pInfo->pArgs->fShared;
                pInfo->pArgs->fNewDemandDial = pInfo->pArgs->fDemandDial;
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL
SwSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    NT_PRODUCT_TYPE ProductType;
    ASSERT(pInfo);
    // skip the page if
    // (a) this is a workstation installation
    // (b) the user does not have administrative privileges
    // (c) the connection is not for all users
    // (d) TCP/IP is not configured
    // (e) there is already a shared connection
    // (f) there are no lan connections
    //
    RtlGetNtProductType(&ProductType);
    if (ProductType == NtProductWinNt ||
        !pInfo->pArgs->fIsUserAdminOrPowerUser ||
        !pInfo->fCreateForAllUsers ||
        !pInfo->fIpConfigured ||
        // pInfo->pArgs->fAnyShared ||
        !pInfo->pArgs->dwLanCount )
    {
        return FALSE;
    }
    else
    {
        EnableWindow(
            GetDlgItem( pInfo->hwndSw, CID_SW_ST_DemandDial ),
            pInfo->pArgs->fNewShared );
        EnableWindow(
            GetDlgItem( pInfo->hwndSw, CID_SW_PB_DemandDial ),
            pInfo->pArgs->fNewShared );
        return TRUE;
    }
}


//----------------------------------------------------------------------------
// Shared private-lan property page
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
SpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Shared private-lan page of the wizard.
    // Parameters / and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return SpInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SpSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = SpSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SpKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = SpKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
SpInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    DWORD i;
    INT item;
    AEINFO* pInfo;
    NETCON_PROPERTIES* pLanTable;

    TRACE("SpInit");

    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    // Initialize page-specific context information.
    //
    pInfo->hwndSp = hwndPage;
    pInfo->hwndSpLbPrivateLan = GetDlgItem( hwndPage, CID_SP_LB_PrivateLan );
    ASSERT( pInfo->hwndSpLbPrivateLan );

    // Fill the drop-list with lan connections
    //
  /*  pLanTable = (NETCON_PROPERTIES*)pInfo->pArgs->pLanTable;
    for (i = 0; i < pInfo->pArgs->dwLanCount; i++)
    {
        item =
            ComboBox_AddString(
                pInfo->hwndSpLbPrivateLan, pLanTable[i].pszwName );
        if (item != CB_ERR)
        {
            ComboBox_SetItemData(
                pInfo->hwndSpLbPrivateLan, item, &pLanTable[i].guidId );
        }
    }*/

    ComboBox_SetCurSel( pInfo->hwndSpLbPrivateLan, 0 );

    return TRUE;
}


BOOL
SpKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{
    if (!pInfo->pArgs->fNewShared || (pInfo->pArgs->dwLanCount <= 1))
    {
        pInfo->pArgs->pPrivateLanConnection = NULL;
    }
    else
    {
        INT item = ComboBox_GetCurSel( pInfo->hwndSpLbPrivateLan );
        if (item != CB_ERR)
        {
            pInfo->pArgs->pPrivateLanConnection =
                (IHNetConnection*)ComboBox_GetItemData(
                    pInfo->hwndSpLbPrivateLan, item );
        }
    }
    return FALSE;
}


BOOL
SpSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    ASSERT(pInfo);
    // skip the page if
    // (a) sharing has not been enabled
    // (b) there is less than or equal to one lan interface.
    //
    if (!pInfo->pArgs->fNewShared || (pInfo->pArgs->dwLanCount <= 1))
    {
        return FALSE;
    }
    return TRUE;
}


BOOL
GhCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3("GhCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_GH_RB_Host:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    pInfo->fDccHost = TRUE;
                    break;
                }
            }
            break;
        }

        case CID_GH_RB_Guest:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    pInfo->fDccHost = FALSE;
                    break;
                }
            }
            break;
        }
    }

    return FALSE;
}


INT_PTR CALLBACK
GhDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Guest Host page of the Direct Connect wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return GhInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("GhSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = GhSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = GhKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return GhCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}



BOOL
GhInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    HWND hwndHost = GetDlgItem( hwndPage, CID_GH_RB_Host );
    HWND hwndGuest = GetDlgItem( hwndPage, CID_GH_RB_Guest );

    TRACE("GhInit");

    // Initialize page-specific context information.
    //
    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    pInfo->hwndGh = hwndPage;

    // If the user is an admin or power user, then enable the
    // host control and set focus to it
    //
    if (pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        pInfo->fDccHost = TRUE;
        SetFocus(hwndHost);
    }

    // Otherwise, this page will be skipped
    //
    else
    {
        pInfo->fDccHost = FALSE;
        EnableWindow(hwndHost, FALSE);
        SetFocus(hwndGuest);
    }

    SendMessage (
        hwndHost,
        BM_SETCHECK,
        (pInfo->fDccHost) ? BST_CHECKED : BST_UNCHECKED,
        0);

    SendMessage (
        hwndGuest,
        BM_SETCHECK,
        (!pInfo->fDccHost) ? BST_CHECKED : BST_UNCHECKED,
        0);

    return FALSE;
}


BOOL
GhKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false if it can be dismissed.
    //
{
    // Show the ras-server specific pages according to whether
    // host was selected.  Show the ras client pages accordingly.
    RassrvShowWizPages (pInfo->pvDccHostContext, pInfo->fDccHost);

    return FALSE;
}

BOOL
GhSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    LPARAM dwWizButtons = PSWIZB_NEXT;

    // If we're not an admin, only the guest path
    // is available. 
    //
    if (! pInfo->pArgs->fIsUserAdminOrPowerUser)
    {
        pInfo->fDccHost = FALSE;
    }

    if (pInfo->pArgs->pApiArgs->dwFlags & RASEDFLAG_ShellOwned)
    {
        dwWizButtons |= PSWIZB_BACK;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
    
    return TRUE;
}

DWORD
DnUpdateSelectedDevice(
    IN AEINFO* pInfo,
    IN HWND hwndLv)

    // Called to a handle the fact that a device has changed
    // in the direct connect wizard.
{

    DTLLIST* pList = NULL;
    DTLNODE* pNode = NULL, *pNode2 = NULL;
    PBLINK * pLink = NULL;

    // pmay: 372661
    // 
    // Validate the connection type so that the right logic is
    // applied.
    //
    if (pInfo->pArgs->pEntry->dwType != RASET_Direct)
    {
        return NO_ERROR;
    }

    pList = pInfo->pArgs->pEntry->pdtllistLinks;

    // Get node from current selection
    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        hwndLv,
        ComboBox_GetCurSel( hwndLv ) );

    if(NULL == pNode)
    {   
        return NO_ERROR;
    }

    // Remove selected item from list of links
    // and disable all other links
    DtlRemoveNode ( pList, pNode );

    for (pNode2 = DtlGetFirstNode (pList);
         pNode2;
         pNode2 = DtlGetNextNode (pNode2))
    {
        pLink = (PBLINK* )DtlGetData( pNode2 );
        pLink->fEnabled = FALSE;
    }

    // Enable selected device and Re-add
    // in list of links at front
    pLink = (PBLINK* )DtlGetData( pNode );
    pLink->fEnabled = TRUE;
    DtlAddNodeFirst( pList, pNode );

    return NO_ERROR;
}

BOOL
DnCommand(
    IN AEINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3("DnCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wNotification)
    {
        case CBN_SELCHANGE:
            if (wId == CID_DN_CB_DeviceSelect)
                DnUpdateSelectedDevice(pInfo, hwndCtrl);
            break;
    }

    return FALSE;
}



INT_PTR CALLBACK
DnDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the direct connect device page of the Direct Connect wizard.
    // Parameters and return value are as described for standard windows
    // 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            AeSetContext( hwnd, lparam );
            return DnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("GhSETACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = DnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AEINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("PaKILLACTIVE");
                    pInfo = AeContext( hwnd );
                    ASSERT(pInfo);
                    fInvalid = DnKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AEINFO* pInfo = AeContext( hwnd );
            ASSERT(pInfo);

            return DnCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}

BOOL
DnInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AEINFO* pInfo;
    HWND hwndCb = GetDlgItem( hwndPage, CID_DN_CB_DeviceSelect );

    TRACE("DnInit");

    // Initialize page-specific context information.
    //
    pInfo = AeContext( hwndPage );
    if (!pInfo)
        return TRUE;

    pInfo->hwndDn = hwndPage;

    // Fill the dropdown list of devices and select the first item.
    //
    {
        TCHAR*   psz;
        DTLNODE* pNode;
        INT      iItem;

        iItem = 1;
        for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink;
            DWORD dwImage;

            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            psz = DisplayPszFromPpbport( &pLink->pbport, &dwImage );
            if (psz)
            {
                PBLINK* pLink;

                pLink = (PBLINK* )DtlGetData( pNode );
                ComboBox_AddItem( hwndCb, psz, pNode );
                Free( psz );
            }
        }
        ComboBox_SetCurSelNotify(hwndCb, 0);
    }


    SetFocus( hwndCb );

    return FALSE;
}

BOOL
DnKillActive(
    IN AEINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false if it can be dismissed.
    //
{
    return FALSE;
}


BOOL
DnSetActive(
    IN AEINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    LPARAM dwWizButtons = PSWIZB_NEXT;
    DWORD  dwFlags = pInfo->pArgs->pApiArgs->dwFlags;

    PBENTRY* pEntry = pInfo->pArgs->pEntry;

    // If the "guest" option of the dcc client wasn't selected,
    // don't allow this page to show.
    if ((pInfo->fDccHost) || (RASET_Direct != pEntry->dwType))
    {
        return FALSE;
    }

    // Show the back button if we're shell owned or, we have the
    // La page before us.
    //
    if ((dwFlags & RASEDFLAG_ShellOwned) ||
        !(dwFlags & RASEDFLAG_NewDirectEntry) || !pInfo->fSkipMa)
    {
        dwWizButtons |= PSWIZB_BACK;
    }


    PropSheet_SetWizButtons( pInfo->hwndDlg, dwWizButtons );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\entry.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entry.c
// Remote Access Common Dialog APIs
// {Ras,Router}PhonebookEntryDlg APIs and general entry utilities
//
// 06/20/95 Steve Cobb
//
// Eu, Cu, and Su utilities sets:
//
// This file contains 3 sets of high-level phone book entry UI utilities
// shared by the phonebook entry property sheet and the add entry wizard.  The
// highest level set of "Eu" utilities is based on the EINFO block and is
// specific to the entry property sheet and add entry wizards.  The other two
// utilities may be used by other dialogs without an EINFO context.  The "Cu"
// utility set based on the CUINFO block encapsulates all complex phone number
// logic.  The "Su" utility set, based on the SUINFO block, encapsulates
// scripting logic.


#include "rasdlgp.h"
#include <serial.h>   // for SERIAL_TXT
#include <mprapi.h>   // for MprAdmin API declarations
#include <lmaccess.h> // for NetUserAdd declarations
#include <lmerr.h>    // for NERR_* declarations.  pmay bug 232983
#include <rasapip.h>
#include <mprerror.h>


// Target machine for RouterEntryDlg{A,W} in "\\server" form.  See
// "limitation" comment in RouterEntryDlgW.
//
static WCHAR g_wszServer[ MAX_COMPUTERNAME_LENGTH + 3] = L"";

//-----------------------------------------------------------------------------
// Local structures
//-----------------------------------------------------------------------------
typedef struct _FREE_COM_PORTS_DATA {
    DTLLIST* pListPortsInUse;       // Ports currently in use
    DTLLIST* pListFreePorts;        // Ports currently free
    DWORD dwCount;                  // Count of com ports
} FREE_COM_PORTS_DATA;

typedef struct _COM_PORT_INFO {
    PWCHAR pszFriendlyName;
    PWCHAR pszPort;
} COM_PORT_INFO;

//-----------------------------------------------------------------------------
// Local prototypes
//-----------------------------------------------------------------------------

// 
// Prototype of the RouterEntryDlg func
//
typedef
BOOL 
(APIENTRY * ROUTER_ENTRY_DLG_FUNC) (
    IN     LPWSTR         lpszServer,
    IN     LPWSTR         lpszPhonebook,
    IN     LPWSTR         lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo );

VOID
AppendDisabledPorts(
    IN EINFO* pInfo,
    IN DWORD dwType );

BOOL
BuildFreeComPortList(
    IN PWCHAR pszPort,
    IN HANDLE hData);

//-----------------------------------------------------------------------------
// External entry points
//-----------------------------------------------------------------------------

DWORD
GetRasDialOutProtocols()

    // This is called by WinLogon to determine if RAS is installed.
    //
    // !!! RaoS is working on cleaning this up, i.e. making it a "real" RAS
    //     API or removing the need for it.
    //
{
#if 1
    return g_pGetInstalledProtocolsEx( NULL, FALSE, TRUE, FALSE );
#else
    return NP_Ip;
#endif
}


BOOL APIENTRY
RasEntryDlgA(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN OUT LPRASENTRYDLGA lpInfo )

    // Win32 ANSI entrypoint that displays the modal Phonebook Entry property
    // sheet.  'LpszPhonebook' is the full path to the phonebook file or NULL
    // to use the default phonebook.  'LpszEntry' is the entry to edit or the
    // default name of the new entry.  'LpInfo' is caller's additional
    // input/output parameters.
    //
    // Returns true if user presses OK and succeeds, false on error or Cancel.
    //
{
    WCHAR* pszPhonebookW;
    WCHAR* pszEntryW;
    RASENTRYDLGW infoW;
    BOOL fStatus;

    TRACE( "RasEntryDlgA" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASENTRYDLGA))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Thunk "A" arguments to "W" arguments.
    //
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromA( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
        pszPhonebookW = NULL;

    if (lpszEntry)
    {
        pszEntryW = StrDupTFromA( lpszEntry );
        if (!pszEntryW)
        {
            Free0( pszPhonebookW );
            {
                lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
                return FALSE;
            }
        }
    }
    else
        pszEntryW = NULL;

    ZeroMemory( &infoW, sizeof(infoW) );
    infoW.dwSize = sizeof(infoW);
    infoW.hwndOwner = lpInfo->hwndOwner;
    infoW.dwFlags = lpInfo->dwFlags;
    infoW.xDlg = lpInfo->xDlg;
    infoW.yDlg = lpInfo->yDlg;
    infoW.reserved = lpInfo->reserved;
    infoW.reserved2 = lpInfo->reserved2;

    // Thunk to the equivalent "W" API.
    //
    fStatus = RasEntryDlgW( pszPhonebookW, pszEntryW, &infoW );

    Free0( pszPhonebookW );
    Free0( pszEntryW );

    // Thunk "W" results to "A" results.
    //
    StrCpyAFromW(lpInfo->szEntry, infoW.szEntry, sizeof(lpInfo->szEntry));
    lpInfo->dwError = infoW.dwError;

    return fStatus;
}


BOOL APIENTRY
RasEntryDlgW(
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )

    // Win32 Unicode entrypoint that displays the modal Phonebook Entry
    // property sheet.  'LpszPhonebook' is the full path to the phonebook file
    // or NULL to use the default phonebook.  'LpszEntry' is the entry to edit
    // or the default name of the new entry.  'LpInfo' is caller's additional
    // input/output parameters.
    //
    // Returns true if user presses OK and succeeds, false on error or Cancel.
    //
{
    DWORD dwErr;
    EINFO* pEinfo;
    BOOL fStatus;
    HWND hwndOwner;
    DWORD dwOp;
    BOOL fRouter;
    BOOL fShellOwned;

    TRACE( "RasEntryDlgW" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASENTRYDLGW))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // The "ShellOwned" mode is required for Connections.  In this mode, the
    // API returns before the sheet is dismissed, does not fill in outputs,
    // and the wizard and property sheets are responsible for calling EuCommit
    // (if necessary) and then EuFree.  Otherwise, EuCommit/EuFree are called
    // below.
    //
    fShellOwned = lpInfo->dwFlags & RASEDFLAG_ShellOwned;

    if (fShellOwned)
    {
        RASEDSHELLOWNEDR2* pShellOwnedInfo;

        pShellOwnedInfo = (RASEDSHELLOWNEDR2*)lpInfo->reserved2;
        if (!pShellOwnedInfo ||
            IsBadWritePtr (&pShellOwnedInfo->pvWizardCtx,
                           sizeof(pShellOwnedInfo->pvWizardCtx)))
        {
            lpInfo->dwError = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
    }

    // Eliminate some invalid flag combinations up front.
    //
    if (lpInfo->dwFlags & RASEDFLAG_CloneEntry)
    {
        lpInfo->dwFlags &= ~(RASEDFLAG_AnyNewEntry | RASEDFLAG_NoRename);
    }

    // fRouter = RasRpcDllLoaded();
    if(lpInfo->reserved)
    {
        fRouter = IsRasRemoteConnection(((INTERNALARGS *)lpInfo->reserved)->hConnection);
    }
    else
    {
        fRouter = FALSE;
    }

    if (!fRouter)
    {
        // DwCustomEntryDlg returns ERROR_SUCCESS if it handled
        // the CustomEntryDlg. returns E_NOINTERFACE otherwise
        // which implies that there is no custom dlg interface
        // supported for this entry and the default Entrydlg
        // should be displayed
        //
        dwErr = DwCustomEntryDlg(
                        lpszPhonebook,
                        lpszEntry,
                        lpInfo,
                        &fStatus);

        if(ERROR_SUCCESS == dwErr)
        {
            return fStatus;
        }

        // Load RAS DLL entrypoints which starts RASMAN, if necessary.  The
        // entrypoints are already loaded in the router case.  The limitations
        // this creates are discussed in RasEntryDlgW.
        //
        dwErr = LoadRas( g_hinstDll, lpInfo->hwndOwner );
        if (dwErr != 0)
        {
            if (!fShellOwned)
            {
                ErrorDlg( lpInfo->hwndOwner, SID_OP_LoadRas, dwErr, NULL );
            }
            lpInfo->dwError = dwErr;
            return FALSE;
        }

        {
            // Commented it out For whistler bug 445424      gangz
            // We move the Tapi first area Dialog to dialing rules check
            // box
            /*
            HLINEAPP hlineapp;

            // Popup TAPI's "first location" dialog if they are uninitialized.
            // An error here is treated as a "cancel" per bug 288385.  This
            // ridiculous exercise is necessary due to TAPI's inability to (a)
            // provide a default location or (b) create a location
            // programatically.
            //
            hlineapp = (HLINEAPP )0;
            if (TapiNoLocationDlg(
                    g_hinstDll, &hlineapp, lpInfo->hwndOwner ) == 0)
            {
                TapiShutdown( hlineapp );
            }
            else
            {
                lpInfo->dwError = 0;
                return FALSE;
            }
	    */
#if 0
            RAS_DEVICE_INFO *pDeviceInfo = NULL;
            DWORD dwVersion = RAS_VERSION, 
                   dwEntries = 0, 
                   dwcb = 0,  i;

            dwErr = RasGetDeviceConfigInfo(NULL, &dwVersion,
                                        &dwEntries, &dwcb,
                                        NULL);

            if(dwErr == ERROR_BUFFER_TOO_SMALL)
            {
                pDeviceInfo = LocalAlloc(LPTR,
                                      dwcb);
                if(NULL == pDeviceInfo)
                {
                    lpInfo->dwError = GetLastError();
                    return FALSE;
                }
                dwErr = RasGetDeviceConfigInfo(NULL,
                                            &dwVersion,
                                            &dwEntries,
                                            &dwcb,
                                            (PBYTE) pDeviceInfo);

                //
                // Check to see if there is a modem device
                //
                for(i = 0; i < dwEntries; i++)
                {
                    if(RAS_DEVICE_TYPE(pDeviceInfo[i].eDeviceType)
                        == RDT_Modem)
                    {
                        break;
                    }
                }
                
                LocalFree(pDeviceInfo);

                if(i < dwEntries)
                {
                    // Popup TAPI's "first location" dialog if they are uninitialized.
                    // An error here is treated as a "cancel" per bug 288385.  This
                    // ridiculous exercise is necessary due to TAPI's inability to (a)
                    // provide a default location or (b) create a location
                    // programatically.
                    //
                    hlineapp = (HLINEAPP )0;
                    if (TapiNoLocationDlg(
                            g_hinstDll, &hlineapp, lpInfo->hwndOwner ) == 0)
                    {
                        TapiShutdown( hlineapp );
                    }
                    else
                    {
                        lpInfo->dwError = 0;
                        return FALSE;
                    }
                }
            }
#endif        
        }
    }

    // Initialize the entry common context block.
    //
    dwErr = EuInit( lpszPhonebook, lpszEntry, lpInfo, fRouter, &pEinfo, &dwOp );
    if (dwErr == 0)
    {
        BOOL fShowWizard = FALSE;

        if (lpInfo->dwFlags & RASEDFLAG_AnyNewEntry)
        {
            fShowWizard = (pEinfo->pUser->fNewEntryWizard || fShellOwned);
        }
        else if (lpInfo->dwFlags & RASEDFLAG_CloneEntry)
        {
            // Need the wizard to gather the cloned entry's name.
            fShowWizard = TRUE;
        }

        if (fShowWizard)
        {
            if (pEinfo->fRouter)
            {
#if 1
                AiWizard( pEinfo );
#else
                pEinfo->fChainPropertySheet = TRUE;
#endif
            }
            else
            {
                AeWizard( pEinfo );
            }

            if (pEinfo->fChainPropertySheet && lpInfo->dwError == 0)
            {
                PePropertySheet( pEinfo );
            }
        }
        else
        {
            PePropertySheet( pEinfo );
        }
    }
    else
    {
        ErrorDlg( lpInfo->hwndOwner, dwOp, dwErr, NULL );
        lpInfo->dwError = dwErr;
    }

    // Clean up here, but only in non-Shell-owned mode.
    //
    if (fShellOwned)
    {
        fStatus = TRUE;
    }
    else 
    {
        if( NULL != pEinfo)
        {
            fStatus = (pEinfo->fCommit && EuCommit( pEinfo ));
            EuFree( pEinfo );
        }
        else
        {
            fStatus = FALSE;
         }
    }

    return fStatus;
}

//
// Raises the NT4 ui.
//
BOOL  
RouterEntryDlgNt4W(
    IN LPWSTR lpszServer,
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )
{
    HMODULE hLib = NULL;
    ROUTER_ENTRY_DLG_FUNC pFunc = NULL;
    BOOL bOk = FALSE;

    do
    {
        // Load the library
        hLib = LoadLibraryA("rasdlg4.dll");
        if (hLib == NULL)
        {
            lpInfo->dwError = GetLastError();
            break;
        }

        // Get the func pointer
        pFunc = (ROUTER_ENTRY_DLG_FUNC) 
            GetProcAddress(hLib, "RouterEntryDlgW");
        if (pFunc == NULL)
        {
            lpInfo->dwError = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Call the function
        //
        bOk = pFunc(lpszServer, lpszPhonebook, lpszEntry, lpInfo);

    } while (FALSE);        
    
    if (hLib)
    {
        FreeLibrary(hLib);
    }

    return bOk;
}

BOOL APIENTRY
RouterEntryDlgA(
    IN LPSTR lpszServer,
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN OUT LPRASENTRYDLGA lpInfo )

    // Router-specific version of RasEntryDlgA.  'LpszServer' is the name of
    // the target server in "\\server" form or NULL for the local machine.
    // Other arguments are as for RasEntryDlgA.  See "limitation" comment in
    // RouterEntryDlgW.
    //
{
    BOOL fSuccess;
    DWORD dwErr;
    HANDLE hConnection = NULL;
    BOOL fAllocatedIArgs = FALSE;
    WCHAR wszServer[ MAX_COMPUTERNAME_LENGTH + 3];

    TRACE( "RouterEntryDlgA" );

    // Load RAS entrypoints or set up RPC to them, if remote server.
    //
    if (lpszServer)
    {
        StrCpyWFromAUsingAnsiEncoding(
            wszServer, 
            lpszServer, 
            MAX_COMPUTERNAME_LENGTH+3);
    }
    else
    {
        wszServer[ 0 ] = L'\0';
    }

    // Load RAS entrypoints or set up RPC to them, if remote server.
    //
    dwErr = InitializeConnection(wszServer, &hConnection);
    if(dwErr)
    {
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // Use the reserved parameter to pass the handle to the api - allocate
    // this parameter if not already present - very sleazy - (RaoS)
    //
    if (NULL == (INTERNALARGS *)lpInfo->reserved)
    {
        INTERNALARGS *pIArgs = Malloc(sizeof(INTERNALARGS));

        if(NULL == pIArgs)
        {
            lpInfo->dwError = GetLastError();
            return FALSE;
        }

        ZeroMemory(pIArgs, sizeof(INTERNALARGS));

        pIArgs->fInvalid = TRUE;
        lpInfo->reserved = (ULONG_PTR )pIArgs;
        fAllocatedIArgs = TRUE;
    }

    ((INTERNALARGS *)lpInfo->reserved)->hConnection = hConnection;

    // Load MPR entrypoints.
    //
    dwErr = LoadMpradminDll();
    if (dwErr)
    {
        dwErr = UnloadRasRpcDll();
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // Call the normal dial-out UI.
    //
    fSuccess = RasEntryDlgA( lpszPhonebook, lpszEntry, lpInfo );

    // Unload DLLs.
    //
    UnloadMpradminDll();
    UninitializeConnection(hConnection);
    ((INTERNALARGS *)lpInfo->reserved)->hConnection = NULL;

    if(fAllocatedIArgs)
    {
        Free((PVOID)lpInfo->reserved);
        (PVOID)lpInfo->reserved = NULL;
    }

    return fSuccess;
}


BOOL APIENTRY
RouterEntryDlgW(
    IN LPWSTR lpszServer,
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASENTRYDLGW lpInfo )

    // Router-specific version of RasEntryDlgA.  'LpszServer' is the name of
    // the target server in "\\server" form or NULL for the local machine.
    // Other arguments are as for RasEntryDlgW.
    //
    // LIMITATION: As implemented with the 'g_wszServer' global and global RPC
    //     entrypoints, the following single process limitations apply to this
    //     (currently undocumented) API.  First, it cannot be called
    //     simultaneously for two different servers.  Second, it cannot be
    //     called simultaneously with RasEntryDlg.
{
    BOOL fSuccess;
    DWORD dwErr, dwVersion;
    HANDLE hConnection = NULL;
    BOOL fAllocatedIArgs = FALSE;
    WCHAR wszServer[ MAX_COMPUTERNAME_LENGTH + 3];

    TRACE( "RouterEntryDlgW" );
    TRACEW1( "  s=%s", (lpszServer) ? lpszServer : TEXT("") );
    TRACEW1( "  p=%s", (lpszPhonebook) ? lpszPhonebook : TEXT("") );
    TRACEW1( "  e=%s", (lpszEntry) ? lpszEntry : TEXT("") );

    if (lpszServer)
    {
        lstrcpynW( wszServer, lpszServer, sizeof(wszServer) / sizeof(WCHAR) );
    }
    else
    {
        wszServer[0] = L'\0';
    }

    // Load RAS entrypoints or set up RPC to them, if remote server.
    //
    dwErr = InitializeConnection(lpszServer, &hConnection);
    if(dwErr)
    {
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // If this is a downlevel machine, use the downlevel
    // UI
    //
    if (IsRasRemoteConnection(hConnection))
    {
        dwVersion = RemoteGetServerVersion(hConnection);
        if (dwVersion == VERSION_40)
        {
            UninitializeConnection(hConnection);                                            
            
            dwErr = RouterEntryDlgNt4W(
                        lpszServer,
                        lpszPhonebook,
                        lpszEntry,
                        lpInfo );
                        
            return dwErr;
        }
    }

    //
    // Use the reserved parameter to pass the handle to the
    // api - allocate this parameter if not already present
    //  - very sleazy -
    //
    if(NULL == (INTERNALARGS *) lpInfo->reserved)
    {
        INTERNALARGS *pIArgs = Malloc(sizeof(INTERNALARGS));

        if(NULL == pIArgs)
        {
            lpInfo->dwError = GetLastError();
            return FALSE;
        }

        ZeroMemory(pIArgs, sizeof(INTERNALARGS));
        pIArgs->fInvalid = TRUE;
        lpInfo->reserved = (ULONG_PTR ) pIArgs;
        fAllocatedIArgs = TRUE;
    }

    ((INTERNALARGS *)lpInfo->reserved)->hConnection = hConnection;


    // Load MPR entrypoints.
    //
    dwErr = LoadMpradminDll();
    if (dwErr)
    {
        dwErr = UnloadRasRpcDll();
        lpInfo->dwError = dwErr;
        return FALSE;
    }

    // Call the normal dial-out UI.
    //
    fSuccess = RasEntryDlgW( lpszPhonebook, lpszEntry, lpInfo );

    // Unload DLLs.
    //
    UnloadMpradminDll();
    UninitializeConnection(hConnection);
    ((INTERNALARGS *)lpInfo->reserved)->hConnection = NULL;

    if(fAllocatedIArgs)
    {
        Free((PVOID) lpInfo->reserved);
        (PVOID)lpInfo->reserved = 0;
    }

    return fSuccess;
}


//----------------------------------------------------------------------------
// Phonebook Entry common routines (Eu utilities)
// Listed alphabetically
//----------------------------------------------------------------------------

VOID
AppendDisabledPorts(
    IN EINFO* pInfo,
    IN DWORD dwType )

    // Utility to append links containing all remaining configured ports of
    // RASET_* type 'dwType' to the list of links with the new links marked
    // "unenabled".  If 'dwType' is -1 all configured ports are appended.
    //
{
    DTLNODE* pNodeP;
    DTLNODE* pNodeL;

    for (pNodeP = DtlGetFirstNode( pInfo->pListPorts );
         pNodeP;
         pNodeP = DtlGetNextNode( pNodeP ))
    {
        PBPORT* pPort;
        BOOL fSkipPort;
        DTLNODE* pNode;

        pPort = (PBPORT* )DtlGetData( pNodeP );
        fSkipPort = FALSE;

        if (dwType != RASET_P_AllTypes)
        {
            // pmay: 233287
            //
            // The port should not be included if:
            //   1. The mode is non-tunnel and the port is vpn type
            //   2. The mode is normal and the port type mismatches
            //
            if (dwType == RASET_P_NonVpnTypes)
            {
                if (pPort->dwType == RASET_Vpn)
                {
                    continue;
                }
            }
            else
            {
                if (pPort->dwType != dwType)
                {
                    continue;
                }
            }
        }

        for (pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
             pNodeL;
             pNodeL = DtlGetNextNode( pNodeL ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );

            ASSERT( pPort->pszPort );
            ASSERT( pLink->pbport.pszPort );

            if (lstrcmp( pLink->pbport.pszPort, pPort->pszPort ) == 0
                && lstrcmp( pLink->pbport.pszDevice, pPort->pszDevice ) == 0)
            {
                // The port already appears in a link in the list.
                //
                fSkipPort = TRUE;
                break;
            }
        }

        if (fSkipPort)
        {
            continue;
        }

        pNode = CreateLinkNode();
        if (pNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

            if (CopyToPbport( &pLink->pbport, pPort ) != 0)
            {
                DestroyLinkNode( pNode );
            }
            else
            {
                if ((pPort->pbdevicetype == PBDT_Modem) ||
                    (pPort->dwFlags & PBP_F_NullModem)
                   )
                {
                    SetDefaultModemSettings( pLink );
                }

                pLink->fEnabled = FALSE;
                DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNode );
            }
        }
    }

    // Set "multiple devices" flag if there is more than one device of this
    // type for convenient reference elsewhere.
    //
    pInfo->fMultipleDevices =
        (DtlGetNodes( pInfo->pEntry->pdtllistLinks ) > 1);
}

BOOL
BuildFreeComPortList(
    IN PWCHAR pszPort,
    IN HANDLE hData)

    // Com port enumeration function that generates a list of
    // free com ports.  Returns TRUE to stop enumeration (see
    // MdmEnumComPorts)
{
    FREE_COM_PORTS_DATA* pfcpData = (FREE_COM_PORTS_DATA*)hData;
    DTLLIST* pListUsed = pfcpData->pListPortsInUse;
    DTLLIST* pListFree = pfcpData->pListFreePorts;
    DTLNODE* pNodeP, *pNodeL, *pNode;

    // If the given port is in the used list, then return
    // so that it is not added to the list of free ports and
    // so that enumeration continues.
    for (pNodeL = DtlGetFirstNode( pListUsed );
         pNodeL;
         pNodeL = DtlGetNextNode( pNodeL ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );
        ASSERT( pLink->pbport.pszPort );

        // The port already appears in a link in the list.
        if (lstrcmp( pLink->pbport.pszPort, pszPort ) == 0)
            return FALSE;
    }

    // The port is not in use.  Add it to the free list.
    pNode = DtlCreateSizedNode( sizeof(COM_PORT_INFO), 0L );
    if (pNode)
    {
        COM_PORT_INFO* pComInfo;
        TCHAR* pszFriendlyName;

        pszFriendlyName = PszFromId(g_hinstDll, SID_FriendlyComPort);
        pComInfo = (COM_PORT_INFO* )DtlGetData( pNode );
        pComInfo->pszFriendlyName = pszFriendlyName;
        pComInfo->pszPort = StrDup(pszPort);
        DtlAddNodeLast( pListFree, pNode );
        pfcpData->dwCount += 1;
    }

    return FALSE;
}

DWORD
EuMergeAvailableComPorts(
    IN  EINFO* pInfo,
    OUT DTLNODE** ppNodeP,
    IN OUT LPDWORD lpdwCount)

    // Adds all the available com ports in the system
    // as modem devices.
{
    FREE_COM_PORTS_DATA fcpData;
    DTLLIST* pListFreeComPorts = NULL;
    DTLNODE* pNodeL;

    // Initialize the list of com ports
    pListFreeComPorts = DtlCreateList(0L);

    if(NULL == pListFreeComPorts)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    fcpData.pListPortsInUse = pInfo->pListPorts;
    fcpData.pListFreePorts = pListFreeComPorts;
    fcpData.dwCount = 0;

    // Enumerate the com ports
    MdmEnumComPorts (
        BuildFreeComPortList,
        (HANDLE)(&fcpData));

    // Go throught the list of free com ports and create
    // a bogus device for each one.
    for (pNodeL = DtlGetFirstNode( pListFreeComPorts );
         pNodeL;
         pNodeL = DtlGetNextNode( pNodeL ))
    {
        COM_PORT_INFO* pComInfo;
        DTLNODE* pNode;

        // Get the info about the com port
        pComInfo = (COM_PORT_INFO* )DtlGetData( pNodeL );

        // Create a new device for it
        pNode = CreateLinkNode();
        if (pNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            pLink->pbport.pszPort = pComInfo->pszPort;
            pLink->pbport.pszDevice = pComInfo->pszFriendlyName;
            pLink->pbport.pszMedia = StrDup( TEXT(SERIAL_TXT) );
            pLink->pbport.pbdevicetype = PBDT_ComPort;
            pLink->pbport.dwType = RASET_Direct;
            pLink->fEnabled = TRUE;

            // If the first node hasn't been identified yet,
            // assign it to this one.
            //
            // ppNode is assumed to have been added to the 
            // list pInfo->pEntry->pdtllistLinks (#348920)
            //
            if (! (*ppNodeP))
            {
                *ppNodeP = pNode;
            }
            else
            {
                DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNode );
            }                
        }
    }

    // Free up the resources held by the list of
    // free com ports
    DtlDestroyList(pListFreeComPorts, NULL);

    // Update the count
    *lpdwCount += fcpData.dwCount;

    return NO_ERROR;
}

DWORD
EuChangeEntryType(
    IN EINFO* pInfo,
    IN DWORD dwType )

    // Changes the work entry node to the default settings for the RASET_*
    // entry type 'dwType', or if -1 to phone defaults with a full list of
    // available links.  'PInfo' is the common entry information block.  As
    // this routine is intended for use only on new entries, information
    // stored in the entries existing list of links, if any, is discarded.
    //
    // Returns 0 if successful or an error code.
    //
{
    DTLNODE* pNode;
    DTLNODE* pNodeP;
    DTLNODE* pNodeL;
    PBLINK* pLink;
    DWORD cDevices, cPorts;

    // Change the default settings of the phonebook entry, i.e. those not
    // specific to the way the UI manipulates the PBLINK list.
    //
    // pmay: 233287. Special types can be considered phone entries.
    //
    if ((dwType == RASET_P_AllTypes) || (dwType == RASET_P_NonVpnTypes))
    {
        ChangeEntryType( pInfo->pEntry, RASET_Phone );
    }
    else
    {
        ChangeEntryType( pInfo->pEntry, dwType );
    }

    // Update the list of PBLINKs to include only links of the appropriate
    // type.  First, delete the old links, if any, and add one default link.
    // This resets the links to the what they are just after CreateEntryNode.
    //
    while (pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks ))
    {
        DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNodeL );
        DestroyLinkNode( pNodeL );
    }

    pNodeL = CreateLinkNode();
    if (!pNodeL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeLast( pInfo->pEntry->pdtllistLinks, pNodeL );
    pLink = (PBLINK* )DtlGetData( pNodeL );
    ASSERT( pLink );

    // Count the configured links of the indicated type, noting the first node
    // of the correct type.
    //
    cDevices = 0;
    pNodeP = NULL;
    for (pNode = DtlGetFirstNode( pInfo->pListPorts );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBPORT* pPort;

        pPort = (PBPORT* )DtlGetData( pNode );
        if ((dwType == RASET_P_AllTypes)                                     ||
            ((dwType == RASET_P_NonVpnTypes) && (pPort->dwType != RASET_Vpn))||
            (pPort->dwType == dwType)
           )
        {
            ++cDevices;

            if (!pNodeP)
            {
                pNodeP = pNode;
            }
        }
    }

    // If this is a direct connect device, merge in the
    // com ports since they will be available to have
    // null modems installed over them
    if (pInfo->pEntry->dwType == RASET_Direct)
    {
        // pmay: 249346
        //
        // Only merge the com ports if the user is an admin since
        // admin privilege is required to install a null modem.
        //
        if (pInfo->fIsUserAdminOrPowerUser)
        {
            EuMergeAvailableComPorts(pInfo, &pNodeP, &cDevices);
        }            
    }

    if (pNodeP)
    {
        pInfo->fNoPortsConfigured = FALSE;
    }
    else
    {
        TRACE( "No ports configured" );
        pInfo->fNoPortsConfigured = TRUE;
        pNodeP = CreatePortNode();
    }

    if (pNodeP)
    {
        PBPORT* pPort;

        pPort = (PBPORT* )DtlGetData( pNodeP );

        if (cDevices <= 0)
        {
            if (pInfo->pEntry->dwType == RASET_Phone)
            {
                // Make up a bogus COM port with unknown Unimodem
                // attached.  Hereafter, this will behave like an entry
                // whose modem has been de-installed.
                //
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultPort );
                pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
                pPort->pbdevicetype = PBDT_Modem;

                // pmay: 233287
                // We need to track bogus devices so that the dd interface
                // wizard can prevent interfaces with these from being
                // created.
                pPort->dwFlags |= PBP_F_BogusDevice;
            }
            else if (pInfo->pEntry->dwType == RASET_Vpn)
            {
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultVpnPort );
                pPort->pszMedia = StrDup( TEXT("rastapi") );
                pPort->pbdevicetype = PBDT_Vpn;
            }
            else if (pInfo->pEntry->dwType == RASET_Broadband)
            {
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultBbPort );
                pPort->pszMedia = StrDup( TEXT("rastapi") );
                pPort->pbdevicetype = PBDT_PPPoE;
                pPort->dwFlags |= PBP_F_BogusDevice;
            }
            else
            {
                ASSERT( pInfo->pEntry->dwType == RASET_Direct );

                // Make up a bogus COM port with unknown Unimodem
                // attached.  Hereafter, this will behave like an entry
                // whose modem has been de-installed.
                //
                pPort->pszPort = PszFromId( g_hinstDll, SID_DefaultPort );
                pPort->pszMedia = StrDup( TEXT(SERIAL_TXT) );
                pPort->pbdevicetype = PBDT_Null;

                // pmay: 233287
                // We need to track bogus devices so that the dd interface
                // wizard can prevent interfaces with these from being
                // created.
                pPort->dwFlags |= PBP_F_BogusDevice;
            }

            pPort->fConfigured = FALSE;
        }

        // If a bogus port was created, copy it into the
        // new node
        CopyToPbport( &pLink->pbport, pPort );
        if ((pLink->pbport.pbdevicetype == PBDT_Modem) ||
            (pLink->pbport.dwFlags & PBP_F_NullModem)
           )
        {
            SetDefaultModemSettings( pLink );
        }
    }

    if (pInfo->fNoPortsConfigured)
    {
        if(NULL != pNodeP)
        {
            DestroyPortNode( pNodeP );
        }
    }

    if (!pNodeP || !pLink->pbport.pszPort || !pLink->pbport.pszMedia)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Append all non-configured ports of the entries type to the list of
    // links.  This is for the convenience of the UI.  The non-configured
    // ports are removed after editing prior to saving.
    //
    AppendDisabledPorts( pInfo, dwType );

    return NO_ERROR;
}

BOOL 
EuRouterInterfaceIsNew(
     IN EINFO * pInfo )
{
    if ((pInfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
        && pInfo->fRouter
        && pInfo->pUser->fNewEntryWizard
        && !pInfo->fChainPropertySheet)
    {
        return TRUE;
    }

    return FALSE;
} //EuRouterInterfaceIsNew()

BOOL
EuCommit(
    IN EINFO* pInfo )

    // Commits the new or changed entry node to the phonebook file and list.
    // Also adds the area code to the per-user list, if indicated.  'PInfo' is
    // the common entry information block.
    //
    // Returns true if successful, false otherwise.
    //
{
    DWORD dwErr;
    BOOL fEditMode;
    BOOL fChangedNameInEditMode;

    // If shared phone number, copy the phone number information from the
    // shared link to each enabled link.
    //
    if (pInfo->pEntry->fSharedPhoneNumbers)
    {
        DTLNODE* pNode;

        ASSERT( pInfo->pEntry->dwType == RASET_Phone );

        for (pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            if (pLink->fEnabled)
            {
                CopyLinkPhoneNumberInfo( pNode, pInfo->pSharedNode );
            }
        }
    }

    // Delete all disabled link nodes.
    //
    if (pInfo->fMultipleDevices)
    {
        DTLNODE* pNode;

        pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
        while (pNode)
        {
            PBLINK*  pLink = (PBLINK* )DtlGetData( pNode );
            DTLNODE* pNextNode = DtlGetNextNode( pNode );

            if (!pLink->fEnabled)
            {
                DtlRemoveNode( pInfo->pEntry->pdtllistLinks, pNode );
                DestroyLinkNode( pNode );
            }

            pNode = pNextNode;
        }
    }

    // pmay: 277801
    //
    // Update the preferred device if the one selected is different
    // from the device this page was initialized with.
    //
    if ((pInfo->fMultipleDevices) &&
        (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1))
    {
        DTLNODE* pNodeL;
        PBLINK* pLink;
        BOOL bUpdatePref = FALSE;

        pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );

        //For whistler bug 428308
        //
        if(pNodeL)
        {
            pLink = (PBLINK*) DtlGetData( pNodeL );
        
            TRACE( "Mult devs, only one selected -- check preferred dev." );

            if ((pInfo->pszCurDevice == NULL) || (pInfo->pszCurPort == NULL))
            {
                TRACE( "No preferred device.  Resetting preferred to current." );
                bUpdatePref = TRUE;
            }
            else if (
                (lstrcmpi(pInfo->pszCurDevice, pLink->pbport.pszDevice)) ||
                (lstrcmpi(pInfo->pszCurPort, pLink->pbport.pszPort)) ||
                ( pInfo->pEntry->dwPreferredBps != pLink->dwBps ) ||
                ( pInfo->pEntry->fPreferredHwFlow  != pLink->fHwFlow  ) ||//XPSP1 664578, .Net 639551
                ( pInfo->pEntry->fPreferredEc != pLink->fEc )   ||
                ( pInfo->pEntry->fPreferredEcc != pLink->fEcc ) ||
                ( pInfo->pEntry->fPreferredSpeaker != pLink->fSpeaker ) ||
                ( pInfo->pEntry->dwPreferredModemProtocol !=    //whistler 402522
                    pLink->dwModemProtocol) )

            {
                TRACE( "New device selected as preferred device" );
                bUpdatePref = TRUE;
            }
            if (bUpdatePref)
            {
                // Assign new values to the preferred parameters
                //
                Free0(pInfo->pEntry->pszPreferredDevice);
                Free0(pInfo->pEntry->pszPreferredPort);

                pInfo->pEntry->pszPreferredDevice = 
                    StrDup(pLink->pbport.pszDevice);
                pInfo->pEntry->pszPreferredPort = 
                    StrDup(pLink->pbport.pszPort);

                // For XPSP1 664578, .Net bug 639551      gangz
                //
                pInfo->pEntry->dwPreferredBps   = pLink->dwBps;
                pInfo->pEntry->fPreferredHwFlow = pLink->fHwFlow;
                pInfo->pEntry->fPreferredEc     = pLink->fEc;
                pInfo->pEntry->fPreferredEcc    = pLink->fEcc;
                pInfo->pEntry->fPreferredSpeaker = pLink->fSpeaker;
                
                // For whistler bug 402522
                //
                pInfo->pEntry->dwPreferredModemProtocol =
                    pLink->dwModemProtocol;
                
            }
        }
    }
    
    // Save preferences if they've changed.
    //
    if (pInfo->pUser->fDirty)
    {
        INTERNALARGS *pIArgs = (INTERNALARGS *)pInfo->pApiArgs->reserved;

        if (g_pSetUserPreferences(
                (pIArgs) ? pIArgs->hConnection : NULL,
                pInfo->pUser,
                (pInfo->fRouter) ? UPM_Router : UPM_Normal ) != 0)
        {
            return FALSE;
        }
    }

    // Save the changed phonebook entry.
    //
    pInfo->pEntry->fDirty = TRUE;

    // The final name of the entry is output to caller via API structure.
    //
    lstrcpyn( 
        pInfo->pApiArgs->szEntry, 
        pInfo->pEntry->pszEntryName,
        RAS_MaxEntryName + 1);

    // Delete the old node if in edit mode, then add the new node.
    //
    EuGetEditFlags( pInfo, &fEditMode, &fChangedNameInEditMode );

    if (fEditMode)
    {
        DtlDeleteNode( pInfo->pFile->pdtllistEntries, pInfo->pOldNode );
    }

    DtlAddNodeLast( pInfo->pFile->pdtllistEntries, pInfo->pNode );
    pInfo->pNode = NULL;

    // Write the change to the phone book file.
    //
    dwErr = WritePhonebookFile( pInfo->pFile,
                (fChangedNameInEditMode) ? pInfo->szOldEntryName : NULL );

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_WritePhonebook, dwErr,
            NULL );
        // shaunco - fix RAID 171651 by assigning dwErr to callers structure.
        pInfo->pApiArgs->dwError = dwErr;
        return FALSE;
    }

    // Notify through rasman that the entry has changed
    //
    if(pInfo->pApiArgs->dwFlags & (RASEDFLAG_AnyNewEntry | RASEDFLAG_CloneEntry))
    {
        dwErr = DwSendRasNotification(
                        ENTRY_ADDED,
                        pInfo->pEntry,
                        pInfo->pFile->pszPath,
                        NULL);
    }
    else
    {
        dwErr = DwSendRasNotification(
                        ENTRY_MODIFIED,
                        pInfo->pEntry,
                        pInfo->pFile->pszPath,
                        NULL);

    }

    // Ignore the error returned from DwSendRasNotification - we don't want
    // to fail the operation in this case. The worst case scenario is that
    // the connections folder won't refresh automatically.
    //
    dwErr = ERROR_SUCCESS;

    // If EuCommit is being called as a result of completing the "new demand 
    // dial interface" wizard, then we need to create the new demand dial 
    // interface now.
    //
    if ( EuRouterInterfaceIsNew( pInfo ) )
    {
        //Create Router MPR interface and save user credentials
        //like UserName, Domain and Password
        //IPSec credentials are save in EuCredentialsCommitRouterIPSec
        //

        dwErr = EuRouterInterfaceCreate( pInfo );

        // If we weren't successful at commiting the interface's
        // credentials, then delete the new phonebook entry.
        //
        if ( dwErr != NO_ERROR )
        {
            WritePhonebookFile( pInfo->pFile, pInfo->pApiArgs->szEntry );
            pInfo->pApiArgs->dwError = dwErr;
            return FALSE;
        }

    }

    // Now save any per-connection credentials
    //
    dwErr = EuCredentialsCommit( pInfo );

   // If we weren't successful at commiting the interface's
  // credentials, then delete the new phonebook entry.
   //
   if ( dwErr != NO_ERROR )
    {
        ErrorDlg( pInfo->pApiArgs->hwndOwner, 
                  SID_OP_CredCommit, 
                  dwErr,
                  NULL );

        pInfo->pApiArgs->dwError = dwErr;

       return FALSE;
    }

    // Save the default Internet connection settings as appropriate.  Igonre
    // the error returned as failure to set the connection as default need
    // not prevent the connection/interface creation.
    //
    dwErr = EuInternetSettingsCommitDefault( pInfo );
    dwErr = NO_ERROR;

    // If the user edited/created a router-phonebook entry, store the bitmask
    // of selected network-protocols in 'reserved2'.
    //
    if (pInfo->fRouter)
    {
        pInfo->pApiArgs->reserved2 =
            ((NP_Ip | NP_Ipx) & ~pInfo->pEntry->dwfExcludedProtocols);
    }

    // Commit the user's changes to home networking settings.
    // Ignore the return value.
    //
    dwErr = EuHomenetCommitSettings(pInfo);
    dwErr = NO_ERROR;

    pInfo->pApiArgs->dwError = 0;
    return TRUE;
}

DWORD
EuCredentialsCommit(
    IN EINFO * pInfo )
{

    // If the user is creating a new router-phonebook entry, and the user is
    // using the router wizard to create it, and the user did not edit
    // properties directly, save the dial-out credentials, and optionally, the
    // dial-in credentials.
    //
    DWORD dwErr = NO_ERROR;

    //Save the IPSec Credentials Info
    //
    if ( pInfo->fRouter )
    {
        // Save the router ipsec settings
        //
        dwErr = EuCredentialsCommitRouterIPSec( pInfo );

        // If this is a new router connection, save the 
        // credentials.  Currently, we only persist the 
        // standard credentials when it's a new router 
        // interface because there is no UI in the properties
        // of a router interface that sets the standard
        // credentials.
        //
        if ( (NO_ERROR == dwErr) && EuRouterInterfaceIsNew ( pInfo ) )
        {
            dwErr = EuCredentialsCommitRouterStandard( pInfo );
        }
    }
    else
    {
        dwErr = EuCredentialsCommitRasIPSec( pInfo );

        if (dwErr == NO_ERROR)
        {
            dwErr = EuCredentialsCommitRasGlobal( pInfo );
        }
    }
    
    return dwErr;   
} //end of EuCredentialsCommit()

DWORD
EuCredentialsCommitRouterStandard( 
    IN EINFO* pInfo )
{
    DWORD dwErr = NO_ERROR;
    HANDLE hServer = NULL;
    WCHAR* pwszInterface = NULL;
    HANDLE hInterface = NULL;

    TRACE( "EuCredentialsCommitRouterStandard" );
    // Generate the interface name based on the 
    // phonebook entry name
    dwErr = g_pMprAdminServerConnect(pInfo->pszRouter, &hServer);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do{
        //Get the interface handle
        //
        pwszInterface = StrDupWFromT( pInfo->pEntry->pszEntryName );
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        dwErr = g_pMprAdminInterfaceGetHandle(
                    hServer,
                    pwszInterface,
                    &hInterface,
                    FALSE);

        if (dwErr)
        {
            TRACE1( 
                "EuCredComRouterStandard: MprAdminInterfaceGetHandle error %d",
                 dwErr);
            break;
        }

        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pInfo->pszRouterPassword );
        dwErr = g_pMprAdminInterfaceSetCredentials(
                    pInfo->pszRouter,
                    pwszInterface,
                    pInfo->pszRouterUserName,
                    pInfo->pszRouterDomain,
                    pInfo->pszRouterPassword );
        EncodePassword( pInfo->pszRouterPassword );

        if(dwErr)
        {
            TRACE1(
             "EuCredComRouterStndrd: MprAdminInterfaceSetCredentials error %d",
             dwErr);
            break;
        }
    }
    while(FALSE);

    if (pwszInterface)
    {
        Free0(pwszInterface);
    }

    if (hServer)
    {
        g_pMprAdminServerDisconnect( hServer );
    }

    return dwErr;
} //EuCredentialsCommitRouterStandard()

//
//Save IPSec keys
//
DWORD
EuCredentialsCommitRouterIPSec(
    IN EINFO* pInfo )
{
    DWORD dwErr = NO_ERROR;
    HANDLE hServer = NULL;
    HANDLE hInterface = NULL;
    WCHAR* pwszInterface = NULL;
    WCHAR pszComputer[512];
    BOOL bComputer, bUserAdded = FALSE;
    MPR_INTERFACE_0 mi0;
    MPR_CREDENTIALSEX_1 mc1;

    TRACE( "EuCredComRouterIPSec" );

    //
    //Save PSK only when User changed it in the Property UI
    //
    if ( !pInfo->fPSKCached )
    {
        return NO_ERROR;
    }
    
    // Connect to the router service.
    //
    dwErr = g_pMprAdminServerConnect(pInfo->pszRouter, &hServer);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        // Initialize the interface-information structure.
        //
        ZeroMemory( &mi0, sizeof(mi0) );

        mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
        mi0.fEnabled = TRUE;
        pwszInterface = StrDupWFromT( pInfo->pEntry->pszEntryName );
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lstrcpynW( 
            mi0.wszInterfaceName, 
            pwszInterface, 
            MAX_INTERFACE_NAME_LEN+1 );

        //
        //Get the interface handle
        //
         dwErr = g_pMprAdminInterfaceGetHandle(
                    hServer,
                    pwszInterface,
                    &hInterface,
                    FALSE);

        if (dwErr)
        {
            TRACE1( "EuCredComRouterIPSec: MprAdminInterfaceGetHandle error %d", dwErr);
            break;
        }

        // Set the dial-out credentials for the interface.  Stop after this if
        // an error occurs, or if we don't need to add a user-account.
        //

        //Save the IPSec Policy keys(PSK for Whislter)
        //
            ASSERT( g_pMprAdminInterfaceSetCredentialsEx );
            ZeroMemory( &mc1, sizeof(mc1) );
            mc1.dwSize = sizeof( pInfo->szPSK );
            mc1.lpbCredentialsInfo = (LPBYTE)(pInfo->szPSK);

            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pInfo->szPSK );
            dwErr = g_pMprAdminInterfaceSetCredentialsEx(
                        hServer,
                        hInterface,
                        1,
                        (LPBYTE)&mc1);
            EncodePassword( pInfo->szPSK );
            if(dwErr)
            {
                TRACE1(
                    "EuCredComRouterIPSec: MprAdminInterfaceSetCredentialsEx error %d",
                    dwErr);
                break;
            }

    }
    while (FALSE);

    // Cleanup
    {
        // Close all handles, free all strings.
        if (pwszInterface)
        {
            Free0( pwszInterface );
        }

        if (hServer)
        {
            g_pMprAdminServerDisconnect( hServer );
        }
    }

    return dwErr;
}//end of EuCredentialsCommitRouterIPSec()

DWORD
EuCredentialsCommitRasIPSec(
    IN EINFO* pInfo )
{
     //Save IPSec Keys through RAS functions
     //
     DWORD dwErr = NO_ERROR;
     RASCREDENTIALS rc;

    TRACE( "EuCredentialsCommitRasIPSec" );
    if ( pInfo->fPSKCached )
    {
        ZeroMemory( &rc, sizeof(rc) );
        rc.dwSize = sizeof(rc);
        rc.dwMask = RASCM_PreSharedKey; //RASCM_Password; //RASCM_UserName;

        // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
        //
        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded previously
        //
        DecodePassword( pInfo->szPSK );
        lstrcpyn(
            rc.szPassword,
            pInfo->szPSK,
            sizeof(rc.szPassword) / sizeof(TCHAR) );
        EncodePassword( pInfo->szPSK );

        ASSERT( g_pRasSetCredentials );
        TRACE( "RasSetCredentials(p,TRUE)" );
        dwErr = g_pRasSetCredentials(
                    pInfo->pFile->pszPath,
                    pInfo->pEntry->pszEntryName,
                    &rc,
                    FALSE );

        ZeroMemory( rc.szPassword, sizeof(rc.szPassword) );

        TRACE1( "EuCredentialsCommitRasIPSec: RasSetCredentials=%d", dwErr );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->pApiArgs->hwndOwner, SID_OP_CachePw, dwErr, NULL );
        }
    }

    return dwErr;
} //end of EuCredentialsCommitRasIPSec()

// Commits the global ras credentials
//
DWORD
EuCredentialsCommitRasGlobal(
    IN EINFO* pInfo )
{
    DWORD dwErr = NO_ERROR;
    RASCREDENTIALS rc;

    TRACE( "EuCredentialsCommitRasGlobal" );
    if ( pInfo->pszDefUserName )
    {
         ZeroMemory( &rc, sizeof(rc) );
         rc.dwSize = sizeof(rc);
         rc.dwMask = RASCM_UserName | RASCM_Password; 

        //Add this for whistler bug 328673
        //
         if ( pInfo->fGlobalCred )
         {
            rc.dwMask |= RASCM_DefaultCreds;
         }

         // Whistler bug 254385 encode password when not being used
         //
         DecodePassword( pInfo->pszDefPassword );
         lstrcpyn( 
            rc.szPassword, 
            pInfo->pszDefPassword,
            sizeof(rc.szPassword) / sizeof(TCHAR));
         EncodePassword( pInfo->pszDefPassword );

         lstrcpyn( 
            rc.szUserName, 
            pInfo->pszDefUserName,
            sizeof(rc.szUserName) / sizeof(TCHAR));
            
         ASSERT( g_pRasSetCredentials );
         TRACE( "RasSetCredentials(p,TRUE)" );
         dwErr = g_pRasSetCredentials(
                    pInfo->pFile->pszPath,
                    pInfo->pEntry->pszEntryName, 
                    &rc, 
                    FALSE );

         // Whistler bug 254385 encode password when not being used
         //
         ZeroMemory( rc.szPassword, sizeof(rc.szPassword) );

         TRACE1( "EuCredsCommitRasGlobal: RasSetCredentials=%d", dwErr );
         if (dwErr != 0)
         {
              ErrorDlg( 
                pInfo->pApiArgs->hwndOwner, 
                SID_OP_CachePw, 
                dwErr, 
                NULL );
         }
    }

    return dwErr;
}

DWORD
EuInternetSettingsCommitDefault( 
    IN EINFO* pInfo )
{
    RASAUTODIALENTRY adEntry;
    DWORD dwErr = NO_ERROR;

    ZeroMemory(&adEntry, sizeof(adEntry));
    adEntry.dwSize = sizeof(adEntry);

    if ( pInfo->fDefInternet )
    {
        lstrcpyn(
            adEntry.szEntry, 
            pInfo->pApiArgs->szEntry, 
            RAS_MaxEntryName + 1);

        dwErr = RasSetAutodialAddress(
                    NULL,
                    0,
                    &adEntry,
                    sizeof(adEntry),
                    1);
    }

    return dwErr;
}

DWORD
EuHomenetCommitSettings(
    IN EINFO* pInfo)
{
    DWORD dwErr = NO_ERROR;

    return dwErr;
}

DWORD
EuRouterInterfaceCreate(
    IN EINFO* pInfo )

    // Commits the credentials and user-account for a router interface.
    //
{
    DWORD dwErr;
    DWORD dwPos, dwSize;
    HANDLE hServer = NULL, hUserServer = NULL, hUser = NULL;
    HANDLE hInterface = NULL;
    WCHAR* pwszInterface = NULL;
    WCHAR pszComputer[512];
    BOOL bComputer, bUserAdded = FALSE;
    RAS_USER_0 ru0;
    USER_INFO_1 ui1;
    MPR_INTERFACE_0 mi0;
    //MPR_CREDENTIALSEX_1 mc1;

    TRACE( "EuRouterInterfaceCreate" );

    // Connect to the router service.
    //
    dwErr = g_pMprAdminServerConnect(pInfo->pszRouter, &hServer);

    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        // Initialize the interface-information structure.
        //
        ZeroMemory( &mi0, sizeof(mi0) );

        mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
        mi0.fEnabled = TRUE;
        pwszInterface = StrDupWFromT( pInfo->pEntry->pszEntryName );
        if (!pwszInterface)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        lstrcpynW( 
            mi0.wszInterfaceName, 
            pwszInterface, 
            MAX_INTERFACE_NAME_LEN+1 );

        // Create the interface.
        //
        dwErr = g_pMprAdminInterfaceCreate(
                    hServer,
                    0,
                    (BYTE*)&mi0,
                    &hInterface );
        if ( dwErr )
        {
            TRACE1( "EuRouterInterfaceCreate: MprAdminInterfaceCreate error %d", dwErr);
            break;
        }

         dwErr = g_pMprAdminInterfaceGetHandle(
                    hServer,
                    pwszInterface,
                    &hInterface,
                    FALSE);

        if (dwErr)
        {
            TRACE1( "EuRouterInterfaceCreate: MprAdminInterfaceGetHandle error %d", dwErr);
            break;
        }

        // Add a user if we were instructed to.
        if (pInfo->fAddUser)
        {
            // Initialize user-information structure.
            //
            ZeroMemory( &ui1, sizeof(ui1) );

            ui1.usri1_name = pwszInterface;

            // Whistler bug 254385 encode password when not being used
            // Assumed password was encoded previously
            //
            DecodePassword( pInfo->pszRouterDialInPassword );
            ui1.usri1_password =
                StrDupWFromT( pInfo->pszRouterDialInPassword );
            EncodePassword( pInfo->pszRouterDialInPassword );

            ui1.usri1_priv = USER_PRIV_USER;
            ui1.usri1_comment =
                PszFromId( g_hinstDll, SID_RouterDialInAccount );
            ui1.usri1_flags = UF_SCRIPT         |
                              UF_NORMAL_ACCOUNT |
                              UF_DONT_EXPIRE_PASSWD;

            // Format the server name so that it is
            // in the form '\\<server>' as this is
            // required by the NetUser api's.
            bComputer = FALSE;
            if (pInfo->pszRouter)
            {
                if (*(pInfo->pszRouter) != L'\\')
                {
                    dwSize = sizeof(pszComputer) - (2 * sizeof(WCHAR));

                    // Whistler bug 224074 use only lstrcpyn's to prevent
                    // maliciousness
                    //
                    lstrcpynW(
                        pszComputer,
                        L"\\\\",
                        sizeof(pszComputer) / sizeof(TCHAR) );
                    if (*(pInfo->pszRouter) != 0)
                    {
                        lstrcatW(pszComputer, pInfo->pszRouter);
                    }
                    else
                    {
                        GetComputerName(pszComputer + 2, &dwSize);
                    }
                    bComputer = TRUE;
                }
            }

            // Add the user-account.
            //
            dwErr = NetUserAdd(
                        (bComputer) ? pszComputer : pInfo->pszRouter,
                        1,
                        (BYTE*)&ui1,
                        &dwPos );

            ZeroMemory(
                ui1.usri1_password,
                lstrlen( ui1.usri1_password ) * sizeof(TCHAR) );
            Free0(ui1.usri1_password);
            Free0(ui1.usri1_comment);

            // pmay: bug 232983.  If the user already exists, give the
            // admin the option of continuing with the config or
            // canceling this operation.
            if (dwErr == NERR_UserExists)
            {
                MSGARGS args;
                INT iRet;

                // Initialize the arguments that specify the
                // type of popup we want.
                ZeroMemory(&args, sizeof(args));
                args.dwFlags = MB_YESNO | MB_ICONINFORMATION;
                args.apszArgs[0] = ui1.usri1_name;

                // Popup the confirmation
                iRet = MsgDlg(
                        GetActiveWindow(),
                        SID_RouterUserExists,
                        &args );
                if (iRet == IDNO)
                {
                    break;
                }
            }

            // If some other error occurred besides the user already
            // existing, bail out.
            else if (dwErr)
            {
                TRACE1( "EuRouterInterfaceCreate: NetUserAdd error %d", dwErr );
                break;
            }

            // Otherwise, record the fact that a user was added
            // so that we can clean up as appropriate.
            else
            {
                bUserAdded = TRUE;
            }

            // Initialize the RAS user-settings structure.
            //
            ZeroMemory( &ru0, sizeof(ru0) );
            ru0.bfPrivilege = RASPRIV_NoCallback | RASPRIV_DialinPrivilege;

            // Nt4 routers enable local users by setting user parms
            //
            if ( pInfo->fNt4Router )
            {
                dwErr = g_pRasAdminUserSetInfo(
                            pInfo->pszRouter,
                            pwszInterface,
                            0,
                            (BYTE*)&ru0 );
                if(dwErr)
                {
                    TRACE1( "EuRouterInterfaceCreate: MprAdminUserSetInfo %d", dwErr );
                    break;
                }
            }

            // Nt5 routers enable users for dialin by setting
            // information with sdo's.
            else
            {
                dwErr = g_pMprAdminUserServerConnect(
                                (bComputer) ? pszComputer : pInfo->pszRouter,
                                TRUE,
                                &hUserServer);
                if (dwErr != NO_ERROR)
                {
                    TRACE1( "EuRouterInterfaceCreate: UserSvrConnect error %d", dwErr );
                    break;
                }

                dwErr = g_pMprAdminUserOpen(
                            hUserServer,
                            pwszInterface,
                            &hUser);
                if (dwErr != NO_ERROR)
                {
                    TRACE1( "EuRouterInterfaceCreate: UserOpen error %d", dwErr );
                    break;
                }

                dwErr = g_pMprAdminUserWrite(
                            hUser,
                            0,
                            (LPBYTE)&ru0);

                if (dwErr != NO_ERROR)
                {
                    TRACE1( "EuRouterInterfaceCreate: UserWrite error %d", dwErr );
                    break;
                }
            }
        }
    }
    while (FALSE);

    // Cleanup
    {
        // If some operation failed, restore the router to the
        // state it was previously in.
        if ( dwErr != NO_ERROR )
        {
            // Cleanup the interface we created...
            if ( hInterface )
            {
                MprAdminInterfaceDelete(hServer, hInterface);
            }
            if ( bUserAdded )
            {
                NetUserDel (
                    (bComputer) ? pszComputer : pInfo->pszRouter,
                    pwszInterface );
            }
        }

        // Close all handles, free all strings.
        if ( hUser )
            g_pMprAdminUserClose( hUser );
        if ( hUserServer )
            g_pMprAdminUserServerDisconnect( hUserServer );
        if (pwszInterface)
            Free0( pwszInterface );
        if (hServer)
            g_pMprAdminServerDisconnect( hServer );
    }

    return dwErr;
}


VOID
EuFree(
    IN EINFO* pInfo )

    // Releases 'pInfo' and associated resources.
    //
{
    TCHAR* psz;
    INTERNALARGS* piargs;

    piargs = (INTERNALARGS* )pInfo->pApiArgs->reserved;

    // Don't clean up the phonebook and user preferences if they arrived via
    // the secret hack.
    //
    if (!piargs)
    {
        if (pInfo->pFile)
        {
            ClosePhonebookFile( pInfo->pFile );
        }

        if (pInfo->pUser)
        {
            DestroyUserPreferences( pInfo->pUser );
        }
    }

    if (pInfo->pListPorts)
    {
        DtlDestroyList( pInfo->pListPorts, DestroyPortNode );
    }
    Free0(pInfo->pszCurDevice);
    Free0(pInfo->pszCurPort);

    if (pInfo->pNode)
    {
        DestroyEntryNode( pInfo->pNode );
    }

    // Free router-information
    //
    Free0( pInfo->pszRouter );
    Free0( pInfo->pszRouterUserName );
    Free0( pInfo->pszRouterDomain );

    if (pInfo->pSharedNode)
    {
        DestroyLinkNode( pInfo->pSharedNode );
    }

    psz = pInfo->pszRouterPassword;
    if (psz)
    {
        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
        Free( psz );
    }

    psz = pInfo->pszRouterDialInPassword;
    if (psz)
    {
        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
        Free( psz );
    }

    // Free credentials stuff
    //
    Free0(pInfo->pszDefUserName);

    // Whistler bug 254385 encode password when not being used
    //
    psz = pInfo->pszDefPassword;
    if (psz)
    {
        ZeroMemory( psz, lstrlen( psz ) * sizeof(TCHAR) );
        Free( psz );
    }

    if (pInfo->fComInitialized)
    {
        CoUninitialize();
    }

    Free( pInfo );
}


VOID
EuGetEditFlags(
    IN EINFO* pEinfo,
    OUT BOOL* pfEditMode,
    OUT BOOL* pfChangedNameInEditMode )

    // Sets '*pfEditMode' true if in edit mode, false otherwise.  Set
    // '*pfChangedNameInEditMode' true if the entry name was changed while in
    // edit mode, false otherwise.  'PEinfo' is the common entry context.
    //
{
    if ((pEinfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
        || (pEinfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry))
    {
        *pfEditMode = *pfChangedNameInEditMode = FALSE;
    }
    else
    {
        *pfEditMode = TRUE;
        *pfChangedNameInEditMode =
            (lstrcmpi( pEinfo->szOldEntryName,
                pEinfo->pEntry->pszEntryName ) != 0);
    }
}


DWORD
EuInit(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry,
    IN RASENTRYDLG* pArgs,
    IN BOOL fRouter,
    OUT EINFO** ppInfo,
    OUT DWORD* pdwOp )

    // Allocates '*ppInfo' data for use by the property sheet or wizard.
    // 'PszPhonebook', 'pszEntry', and 'pArgs', are the arguments passed by
    // user to the API.  'FRouter' is set if running in "router mode", clear
    // for the normal "dial-out" mode.  '*pdwOp' is set to the operation code
    // associated with any error.
    //
    // Returns 0 if successful, or an error code.  If non-null '*ppInfo' is
    // returned caller must eventually call EuFree to release the returned
    // block.
    //
{
    DWORD dwErr;
    EINFO* pInfo;
    INTERNALARGS* piargs;

    *ppInfo = NULL;
    *pdwOp = 0;

    pInfo = Malloc( sizeof(EINFO) );
    if (!pInfo)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppInfo = pInfo;

    ZeroMemory( pInfo, sizeof(*pInfo ) );
    pInfo->pszPhonebook = pszPhonebook;
    pInfo->pszEntry = pszEntry;
    pInfo->pApiArgs = pArgs;
    pInfo->fRouter = fRouter;

    piargs = (INTERNALARGS *)pArgs->reserved;

    if (pInfo->fRouter)
    {
        LPTSTR pszRouter;
        DWORD dwVersion;

        ASSERT(piargs);

        pszRouter = RemoteGetServerName(piargs->hConnection);

        // pmay: 348623
        //
        // Note that RemoteGetServerName is guarenteed to return
        // NULL for local box, non-NULL for remote
        //
        pInfo->fRemote = !!pszRouter;

        if(NULL == pszRouter)
        {
            pszRouter = TEXT("");
        }

        pInfo->pszRouter = StrDupTFromW(pszRouter);

        // Find out if we're focused on an nt4 router
        // pInfo->fNt4Router = FALSE;
        // IsNt40Machine( pszRouter, &(pInfo->fNt4Router) );

        dwVersion = ((RAS_RPC *)(piargs->hConnection))->dwVersion;

        pInfo->fNt4Router = !!(VERSION_40 == dwVersion );
        //Find out if the remote server is a win2k machine
        //
        pInfo->fW2kRouter = !!(VERSION_50 == dwVersion );
    }

    // Load the user preferences, or figure out that caller has already loaded
    // them.
    //
    if (piargs && !piargs->fInvalid)
    {
        // We've received user preferences and the "no user" status via the
        // secret hack.
        //
        pInfo->pUser = piargs->pUser;
        pInfo->fNoUser = piargs->fNoUser;
        pInfo->pFile = piargs->pFile;
        pInfo->fDisableFirstConnect = piargs->fDisableFirstConnect;
    }
    else
    {
        DWORD dwReadPbkFlags = 0;

        // Read user preferences from registry.
        //
        dwErr = g_pGetUserPreferences(
            (piargs) ? piargs->hConnection : NULL,
            &pInfo->user,
            (pInfo->fRouter) ? UPM_Router : UPM_Normal );
        if (dwErr != 0)
        {
            *pdwOp = SID_OP_LoadPrefs;
            return dwErr;
        }

        pInfo->pUser = &pInfo->user;

        if(pInfo->fRouter)
        {
            pInfo->file.hConnection = piargs->hConnection;
            dwReadPbkFlags |= RPBF_Router;
        }

        if(pInfo->fNoUser)
        {
            dwReadPbkFlags |= RPBF_NoUser;
        }
        else
        {
            if (IsConsumerPlatform())
            {
                dwReadPbkFlags |= RPBF_AllUserPbk;
            }
        }

        // Load and parse the phonebook file.
        //
        dwErr = ReadPhonebookFile(
            pInfo->pszPhonebook, &pInfo->user, NULL,
            dwReadPbkFlags,
            &pInfo->file );
        if (dwErr != 0)
        {
            *pdwOp = SID_OP_LoadPhonebook;
            return dwErr;
        }

        pInfo->pFile = &pInfo->file;
    }

    // Determine if strong encryption is supported.  Export laws prevent it in
    // some versions of the system.
    //
    {
        ULONG ulCaps;
        RAS_NDISWAN_DRIVER_INFO info;

        ZeroMemory( &info, sizeof(info) );
        ASSERT( g_pRasGetNdiswanDriverCaps );
        dwErr = g_pRasGetNdiswanDriverCaps(
            (piargs) ? piargs->hConnection : NULL, &info );
        if (dwErr == 0)
        {
            pInfo->fStrongEncryption =
                !!(info.DriverCaps & RAS_NDISWAN_128BIT_ENABLED);
        }
        else
        {
            pInfo->fStrongEncryption = FALSE;
        }
    }

    // Load the list of ports.
    //
    dwErr = LoadPortsList2(
        (piargs) ? piargs->hConnection : NULL,
        &pInfo->pListPorts,
        pInfo->fRouter );
    if (dwErr != 0)
    {
        TRACE1( "LoadPortsList=%d", dwErr );
        *pdwOp = SID_OP_RetrievingData;
        return dwErr;
    }

    // Set up work entry node.
    //
    if (pInfo->pApiArgs->dwFlags & RASEDFLAG_AnyNewEntry)
    {
        DTLNODE* pNodeL;
        DTLNODE* pNodeP;
        PBLINK* pLink;
        PBPORT* pPort;

        // New entry mode, so 'pNode' set to default settings.
        //
        pInfo->pNode = CreateEntryNode( TRUE );
        if (!pInfo->pNode)
        {
            TRACE( "CreateEntryNode failed" );
            *pdwOp = SID_OP_RetrievingData;
            return dwErr;
        }

        // Store entry within work node stored in context for convenience
        // elsewhere.
        //
        pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );
        ASSERT( pInfo->pEntry );

        if (pInfo->fRouter)
        {
            // Set router specific defaults.
            //
            pInfo->pEntry->dwIpNameSource = ASRC_None;
            pInfo->pEntry->dwRedialAttempts = 0;

            // Since this is a new entry, setup a proposed entry name.
            // This covers the case when the wizard is not used to
            // create the entry and the property sheet has no way to enter
            // the name.
            ASSERT( !pInfo->pEntry->pszEntryName );
            GetDefaultEntryName( pInfo->pFile,
                                 RASET_Phone,
                                 pInfo->fRouter,
                                 &pInfo->pEntry->pszEntryName );

            // Disable MS client and File and Print services by default
            //
            EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_msclient"),
                FALSE);
            EnableOrDisableNetComponent( pInfo->pEntry, TEXT("ms_server"),
                FALSE);
        }

        // Use caller's default name, if any.
        //
        if (pInfo->pszEntry)
        {
            pInfo->pEntry->pszEntryName = StrDup( pInfo->pszEntry );
        }

        // Set the default entry type to "phone", i.e. modems, ISDN, X.26 etc.
        // This may be changed to "VPN" or  "direct"  by the new entry  wizard
        // after the initial wizard page.
        //
        EuChangeEntryType( pInfo, RASET_Phone );
    }
    else
    {
        DTLNODE* pNode;

        // Edit or clone entry mode, so 'pNode' set to entry's current
        // settings.
        //
        pInfo->pOldNode = EntryNodeFromName(
            pInfo->pFile->pdtllistEntries, pInfo->pszEntry );

        if (    !pInfo->pOldNode
            &&  !pInfo->fRouter)
        {

            if(NULL == pInfo->pszPhonebook)
            {
                //
                // Close the phonebook file we opened above.
                // we will try to find the entry name in the
                // per user phonebook file.
                //
                ClosePhonebookFile(&pInfo->file);

                pInfo->pFile = NULL;

                //
                // Attempt to find the file in users profile
                //
                dwErr = GetPbkAndEntryName(
                                    NULL,
                                    pInfo->pszEntry,
                                    0,
                                    &pInfo->file,
                                    &pInfo->pOldNode);

                if(ERROR_SUCCESS != dwErr)
                {
                    *pdwOp = SID_OP_RetrievingData;
                    return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                }

                pInfo->pFile = &pInfo->file;
            }
            else
            {
                *pdwOp = SID_OP_RetrievingData;
                return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
            }
        }

        if(NULL != pInfo->pOldNode)
        {
            PBENTRY *pEntry = (PBENTRY *) DtlGetData(pInfo->pOldNode);
            
            // Before cloning or editing make sure that for dial up
            // connections, share File And Print is disabled.
            //
            if(     ((RASET_Phone == pEntry->dwType)
                ||  (RASET_Broadband == pEntry->dwType))
                &&  (!pEntry->fShareMsFilePrint))
            {
                EnableOrDisableNetComponent( pEntry, TEXT("ms_server"),
                    FALSE);
            }
        }

        if(NULL != pInfo->pOldNode)
        {
            if (pInfo->pApiArgs->dwFlags & RASEDFLAG_CloneEntry)
            {
                pInfo->pNode = CloneEntryNode( pInfo->pOldNode );
            }
            else
            {
                pInfo->pNode = DuplicateEntryNode( pInfo->pOldNode );
            }
        }

        if (!pInfo->pNode)
        {
            TRACE( "DuplicateEntryNode failed" );
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        // Store entry within work node stored in context for convenience
        // elsewhere.
        //
        pInfo->pEntry = (PBENTRY* )DtlGetData( pInfo->pNode );

        // Save original entry name for comparison later.
        //
        lstrcpyn( 
            pInfo->szOldEntryName, 
            pInfo->pEntry->pszEntryName,
            RAS_MaxEntryName + 1);

        // For router, want unconfigured ports to show up as "unavailable" so
        // they stand out to user who has been directed to change them.
        //
        if (pInfo->fRouter)
        {
            DTLNODE* pNodeL;
            PBLINK* pLink;

            pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNodeL );

            if (!pLink->pbport.fConfigured)
            {
                Free0( pLink->pbport.pszDevice );
                pLink->pbport.pszDevice = NULL;
            }
        }

        // pmay: 277801
        //
        // Remember the "current" device if this entry was last saved
        // as single link.  
        //
        if (DtlGetNodes(pInfo->pEntry->pdtllistLinks) == 1)
        {
            DTLNODE* pNodeL;
            PBLINK* pLink;
            
            pNodeL = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
            pLink = (PBLINK* )DtlGetData( pNodeL );

            if (pLink->pbport.pszDevice && pLink->pbport.pszPort)
            {
                pInfo->pszCurDevice = 
                    StrDup(pLink->pbport.pszDevice);
                pInfo->pszCurPort = 
                    StrDup(pLink->pbport.pszPort);
            }                
        }

        // Append all non-configured ports of the entries type to the list of
        // links.  This is for the convenience of the UI.  The non-configured
        // ports are removed after editing prior to saving.
        //
        AppendDisabledPorts( pInfo, pInfo->pEntry->dwType );
    }

    // Set up the phone number storage for shared phone number mode.
    // Initialize it to a copy of the information from the first link which at
    // startup will always be enabled.  Note the Dial case with non-0
    // dwSubEntry is an exception, but in that case the pSharedNode anyway.
    //
    {
        DTLNODE* pNode;

        pInfo->pSharedNode = CreateLinkNode();
        if (!pInfo->pSharedNode)
        {
            *pdwOp = SID_OP_RetrievingData;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ASSERT( pInfo->pSharedNode );
        pNode = DtlGetFirstNode( pInfo->pEntry->pdtllistLinks );
        ASSERT( pNode );
        CopyLinkPhoneNumberInfo( pInfo->pSharedNode, pNode );
    }

    if (pInfo->fRouter)
    {
        pInfo->pEntry->dwfExcludedProtocols |= NP_Nbf;
    }

    // AboladeG - capture the security level of the current user.
    //
    pInfo->fIsUserAdminOrPowerUser = FIsUserAdminOrPowerUser();

    return 0;
}


BOOL
EuValidateName(
    IN HWND hwndOwner,
    IN EINFO* pEinfo )

    // Validates the working entry name and pops up a message if invalid.
    // 'HwndOwner' is the window to own the error popup.  'PEinfo' is the
    // common dialog context containing the name to validate.
    //
    // Returns true if the name is valid, false if not.
    //
{
    PBENTRY* pEntry;
    BOOL fEditMode;
    BOOL fChangedNameInEditMode;

    pEntry = pEinfo->pEntry;

    // Validate the sheet data.
    //
    if (!ValidateEntryName( pEinfo->pEntry->pszEntryName ))
    {
        // Invalid entry name.
        //
        MsgDlg( hwndOwner, SID_BadEntry, NULL );
        return FALSE;
    }

    EuGetEditFlags( pEinfo, &fEditMode, &fChangedNameInEditMode );

    if ((fChangedNameInEditMode || !fEditMode)
        && EntryNodeFromName(
               pEinfo->pFile->pdtllistEntries, pEntry->pszEntryName ))
    {
        // Duplicate entry name.
        //
        MSGARGS msgargs;
        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pEntry->pszEntryName;
        MsgDlg( hwndOwner, SID_DuplicateEntry, &msgargs );
        return FALSE;
    }

    return TRUE;
}


//----------------------------------------------------------------------------
// Area-code and Country-code utility routiness (Cu utilities)
// Listed alphabetically
//----------------------------------------------------------------------------

VOID
CuClearCountryCodeLb(
    IN CUINFO* pCuInfo )

    // Clear the country code dropdown.  'PCuInfo' is the complex phone number
    // context.
    //
{
    TRACE( "CuClearCountryCodeLb" );

    ComboBox_ResetContent( pCuInfo->hwndLbCountryCodes );

    if (pCuInfo->pCountries)
    {
        FreeCountryInfo( pCuInfo->pCountries, pCuInfo->cCountries );
        pCuInfo->pCountries = NULL;
    }

    pCuInfo->cCountries = 0;
    pCuInfo->fComplete = FALSE;
}


BOOL
CuCountryCodeLbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification )

    // Handles WM_COMMAND notification to the Country Code dropdown.
    // 'PCuInfo' is the complex phone number context.  'WNotification' is the
    // wParam of the WM_COMMAND.
    //
    // Returns true if processed message, false otherwise.
    //
{
    switch (wNotification)
    {
        case CBN_DROPDOWN:
        {
            CuUpdateCountryCodeLb( pCuInfo, TRUE );
            return TRUE;
        }

        case CBN_SELCHANGE:
        {
            CuCountryCodeLbSelChange( pCuInfo );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
CuCountryCodeLbSelChange(
    IN CUINFO* pCuInfo )

    // Called when the country list selection has changed.  'PCuInfo' is the
    // complex phone number context.
    //
{
    LONG lSign;
    LONG i;

    TRACE( "CuCountryCodeLbSelChange" );

    // When a partial list (default after setting a new phone number set) is
    // loaded there are dummy entries placed before and after the single
    // country code with contexts of -1 and 1.  This allows transparent
    // behavior when user presses left/right arrows to change selection, in
    // which case the full list of countries is loaded behind the scenes, and
    // the selection adjusted to the country before/after the country in the
    // original partial display.
    //
    lSign =
        (LONG )ComboBox_GetItemData( pCuInfo->hwndLbCountryCodes,
                   ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes ) );

    if (lSign == -1 || lSign == 1)
    {
        CuUpdateCountryCodeLb( pCuInfo, TRUE );

        i = (LONG )ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
        if (ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, i + lSign ) < 0)
        {
            ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, i );
        }
    }
    else
    {
        ASSERT( pCuInfo->fComplete );
    }
}


BOOL
CuDialingRulesCbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "use dialing rules" checkbox
    // control.  Updates the the Area Code and Country Code controls to
    // reflect the current state of dialing rules.  'PCuInfo' is the complex
    // phone number context.  'WNotification' is the wparam of the WM_COMMAND
    // notification (though it currently assumes it's a button click).
    //
    // Returns true if processed message, false otherwise.
{
    BOOL fRules;
    BOOL fEnable;

    TRACE( "CuDialingRulesCbChange" );

    fRules = Button_GetCheck( pCuInfo->hwndCbUseDialingRules );

    // For whistler bug 445424      gangz
    //
    if ( fRules )
    {
        DWORD dwErr = NO_ERROR;
        HLINEAPP hlineapp = (HLINEAPP )0;
        
        dwErr = TapiNoLocationDlg( 
                            g_hinstDll, 
                            &hlineapp, 
                            pCuInfo->hwndCbUseDialingRules
                                );
        if (dwErr != 0)
        {
            // Error here is treated as a "cancel" per bug 288385.
            //
            Button_SetCheck( pCuInfo->hwndCbUseDialingRules, FALSE);
            fRules = FALSE;
            Button_SetCheck( pCuInfo->hwndCbUseDialingRules, FALSE);
        }
    }


    if (fRules)
    {
        CuUpdateCountryCodeLb( pCuInfo, FALSE );
        CuUpdateAreaCodeClb( pCuInfo );
    }
    else
    {
        COUNTRY* pCountry;
        INT iSel;

        iSel = ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
        if (iSel >= 0)
        {
            pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
                pCuInfo->hwndLbCountryCodes, iSel );
            ASSERT( pCountry );

            if(NULL != pCountry)
            {
                pCuInfo->dwCountryId = pCountry->dwId;
                pCuInfo->dwCountryCode = pCountry->dwCode;
            }
        }

        Free0( pCuInfo->pszAreaCode );
        pCuInfo->pszAreaCode = GetText( pCuInfo->hwndClbAreaCodes );

        ComboBox_ResetContent( pCuInfo->hwndClbAreaCodes );
        CuClearCountryCodeLb( pCuInfo );
    }

    EnableWindow( pCuInfo->hwndStAreaCodes, fRules );
    EnableWindow( pCuInfo->hwndClbAreaCodes, fRules );
    EnableWindow( pCuInfo->hwndStCountryCodes, fRules );
    EnableWindow( pCuInfo->hwndLbCountryCodes, fRules );
    EnableWindow( pCuInfo->hwndPbDialingRules, fRules );

    return TRUE;
}


VOID
CuFree(
    IN CUINFO* pCuInfo )

    // Free resources attached to the 'pCuInfo' context.
    //
{
    TRACE( "CuFree" );

    if (pCuInfo->pCountries)
    {
        FreeCountryInfo( pCuInfo->pCountries, pCuInfo->cCountries );
        pCuInfo->pCountries = NULL;
    }

    pCuInfo->cCountries = 0;
    pCuInfo->fComplete = FALSE;

    Free0( pCuInfo->pszAreaCode );
    pCuInfo->pszAreaCode = NULL;
}


VOID
CuGetInfo(
    IN CUINFO* pCuInfo,
    OUT DTLNODE* pPhoneNode )

    // Load the phone number set information from the controls into PBPHONE
    // node 'pPhone'.  'PCuInfo' is the complex phone number context.
    //
{
    PBPHONE* pPhone;

    pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
    ASSERT( pPhone );

    Free0( pPhone->pszPhoneNumber );
    pPhone->pszPhoneNumber = GetText( pCuInfo->hwndEbPhoneNumber );

    if (pCuInfo->hwndEbComment)
    {
        Free0( pPhone->pszComment );
        pPhone->pszComment = GetText( pCuInfo->hwndEbComment );
    }

    pPhone->fUseDialingRules =
        Button_GetCheck( pCuInfo->hwndCbUseDialingRules );

    Free0( pPhone->pszAreaCode );

    if (pPhone->fUseDialingRules)
    {
        COUNTRY* pCountry;
        INT iSel;

        // Get the area and country code selections from the lists.
        //
        pPhone->pszAreaCode = GetText( pCuInfo->hwndClbAreaCodes );

        iSel = ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
        if (iSel >= 0)
        {
            pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
                pCuInfo->hwndLbCountryCodes, iSel );
            ASSERT( pCountry );

            if(NULL != pCountry)
            {
                pPhone->dwCountryID = pCountry->dwId;
                pPhone->dwCountryCode = pCountry->dwCode;
            }
        }
    }
    else
    {
        // Get the "blanked" values instead.
        //
        pPhone->pszAreaCode = StrDup( pCuInfo->pszAreaCode );
        pPhone->dwCountryID = pCuInfo->dwCountryId;
        pPhone->dwCountryCode = pCuInfo->dwCountryCode;
    }

    if (pPhone->pszAreaCode)
    {
        TCHAR* pIn;
        TCHAR* pOut;

        // Sanitize the area code.  See bug 298570.
        //
        for (pIn = pOut = pPhone->pszAreaCode; *pIn; ++pIn)
        {
            if (*pIn != TEXT(' ') && *pIn != TEXT('(') && *pIn != TEXT(')'))
            {
                *pOut++ = *pIn;
            }
        }
        *pOut = TEXT('\0');
    }

    // Add the area code entered to the global list for this user.
    //
    CuSaveToAreaCodeList( pCuInfo, pPhone->pszAreaCode );
}


VOID
CuInit(
    OUT CUINFO* pCuInfo,
    IN HWND hwndStAreaCodes,
    IN HWND hwndClbAreaCodes,
    IN HWND hwndStPhoneNumber,
    IN HWND hwndEbPhoneNumber,
    IN HWND hwndStCountryCodes,
    IN HWND hwndLbCountryCodes,
    IN HWND hwndCbUseDialingRules,
    IN HWND hwndPbDialingRules,
    IN HWND hwndPbAlternates,
    IN HWND hwndStComment,
    IN HWND hwndEbComment,
    IN DTLLIST* pListAreaCodes )

    // Initialize the context '*pCuInfo' in preparation for using other CuXxx
    // calls.  The 'hwndStPhoneNumber', 'hwndStComment', 'hwndEbComment',
    // 'hwndPbAlternates', and 'pListAreaCodes' arguments may be NULL.  Others
    // are required.
    //
{
    ZeroMemory( pCuInfo, sizeof(*pCuInfo) );

    pCuInfo->hwndStAreaCodes = hwndStAreaCodes;
    pCuInfo->hwndClbAreaCodes = hwndClbAreaCodes;
    pCuInfo->hwndStPhoneNumber = hwndStPhoneNumber;
    pCuInfo->hwndEbPhoneNumber = hwndEbPhoneNumber;
    pCuInfo->hwndStCountryCodes = hwndStCountryCodes;
    pCuInfo->hwndLbCountryCodes = hwndLbCountryCodes;
    pCuInfo->hwndCbUseDialingRules = hwndCbUseDialingRules;
    pCuInfo->hwndPbDialingRules = hwndPbDialingRules;
    pCuInfo->hwndPbAlternates = hwndPbAlternates;
    pCuInfo->hwndStComment = hwndStComment;
    pCuInfo->hwndEbComment = hwndEbComment;
    pCuInfo->pListAreaCodes = pListAreaCodes;

    // Disaster defaults only.  Not used in normal operation.
    //
    pCuInfo->dwCountryId = 1;
    pCuInfo->dwCountryCode = 1;

    Edit_LimitText( pCuInfo->hwndEbPhoneNumber, RAS_MaxPhoneNumber );

    if (pCuInfo->hwndEbComment)
    {
        Edit_LimitText( pCuInfo->hwndEbComment, RAS_MaxDescription );
    }
}


VOID
CuSaveToAreaCodeList(
    IN CUINFO* pCuInfo,
    IN TCHAR* pszAreaCode )

    // Adds 'pszAreaCode' to the top of the list of area codes eliminating any
    // duplicate farther down in the list.
    //
{
    DTLNODE* pNodeNew;
    DTLNODE* pNode;

    TRACE( "CuSaveToAreaCodeList" );

    if (!pszAreaCode || IsAllWhite( pszAreaCode ) || !pCuInfo->pListAreaCodes)
    {
        return;
    }

    // Create a new node for the current area code and add it to the list
    // head.
    //
    pNodeNew = CreatePszNode( pszAreaCode );
    if (!pNodeNew)
    {
        return;
    }

    DtlAddNodeFirst( pCuInfo->pListAreaCodes, pNodeNew );

    // Delete any other occurrence of the same area code later in the
    // list.
    //
    pNode = DtlGetNextNode( pNodeNew );

    while (pNode)
    {
        TCHAR* psz;
        DTLNODE* pNodeNext;

        pNodeNext = DtlGetNextNode( pNode );

        psz = (TCHAR* )DtlGetData( pNode );
        if (lstrcmp( psz, pszAreaCode ) == 0)
        {
            DtlRemoveNode( pCuInfo->pListAreaCodes, pNode );
            DestroyPszNode( pNode );
        }

        pNode = pNodeNext;
    }
}


VOID
CuSetInfo(
    IN CUINFO* pCuInfo,
    IN DTLNODE* pPhoneNode,
    IN BOOL fDisableAll )

    // Set the controls for context 'pCuInfo' to the PBPHONE node 'pPhoneNode'
    // values.  'FDisableAll' indicates the controls are disabled, meaning a
    // group disable, not a no dialing rules disable.
    //
{
    PBPHONE* pPhone;
    BOOL fEnableAny;
    BOOL fEnableComplex;

    TRACE( "CuSetInfo" );

    pPhone = (PBPHONE* )DtlGetData( pPhoneNode );
    ASSERT( pPhone );

    // Update "blanked" values.
    //
    Free0( pCuInfo->pszAreaCode );
    pCuInfo->pszAreaCode = StrDup( pPhone->pszAreaCode );
    pCuInfo->dwCountryId = pPhone->dwCountryID;
    pCuInfo->dwCountryCode = pPhone->dwCountryCode;

    SetWindowText(
        pCuInfo->hwndEbPhoneNumber, UnNull( pPhone->pszPhoneNumber ) );
    Button_SetCheck(
        pCuInfo->hwndCbUseDialingRules, pPhone->fUseDialingRules );

    if (pPhone->fUseDialingRules)
    {
        CuUpdateCountryCodeLb( pCuInfo, FALSE );
        CuUpdateAreaCodeClb( pCuInfo );
    }
    else
    {
        ComboBox_ResetContent( pCuInfo->hwndClbAreaCodes );
        CuClearCountryCodeLb( pCuInfo );
    }

    // Enable/disable controls.
    //
    fEnableAny = !fDisableAll;
    fEnableComplex = (pPhone->fUseDialingRules && fEnableAny);

    EnableWindow( pCuInfo->hwndStAreaCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndClbAreaCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndEbPhoneNumber, fEnableAny );
    EnableWindow( pCuInfo->hwndStCountryCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndLbCountryCodes, fEnableComplex );
    EnableWindow( pCuInfo->hwndPbDialingRules, fEnableComplex );

    if (pCuInfo->hwndStPhoneNumber)
    {
        EnableWindow( pCuInfo->hwndStPhoneNumber, fEnableAny );
    }

    if (pCuInfo->hwndPbAlternates)
    {
        EnableWindow( pCuInfo->hwndPbAlternates, fEnableAny );
    }

    if (pCuInfo->hwndEbComment)
    {
        SetWindowText( pCuInfo->hwndEbComment, UnNull( pPhone->pszComment ) );
        EnableWindow( pCuInfo->hwndStComment, fEnableAny );
        EnableWindow( pCuInfo->hwndEbComment, fEnableAny );
    }
}


VOID
CuUpdateAreaCodeClb(
    IN CUINFO* pCuInfo )

    // Fill the area code combo-box-list, if necessary, and set the selection
    // to the one in the context.  'PCuInfo' is the complex phone number
    // context.
    //
{
    DTLNODE* pNode;
    INT iSel;

    TRACE( "CuUpdateAreaCodeClb" );

    if (!pCuInfo->pListAreaCodes)
    {
        return;
    }

    ComboBox_ResetContent( pCuInfo->hwndClbAreaCodes );
    ComboBox_LimitText( pCuInfo->hwndClbAreaCodes, RAS_MaxAreaCode );

    // Add caller's list of area codes.
    //
    for (pNode = DtlGetFirstNode( pCuInfo->pListAreaCodes );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* pszAreaCode = (TCHAR* )DtlGetData( pNode );

        ComboBox_AddString( pCuInfo->hwndClbAreaCodes, pszAreaCode );
    }

    // Select the last area code set via CuSetInfo, inserting at the top if
    // it's not already in the list.
    //
    if (pCuInfo->pszAreaCode && *(pCuInfo->pszAreaCode))
    {
        iSel = ComboBox_FindStringExact(
            pCuInfo->hwndClbAreaCodes, -1, pCuInfo->pszAreaCode );
        if (iSel < 0)
        {
            ComboBox_InsertString(
                pCuInfo->hwndClbAreaCodes, 0, pCuInfo->pszAreaCode );
            iSel = 0;
        }

        ComboBox_SetCurSel( pCuInfo->hwndClbAreaCodes, iSel );
    }

    ComboBox_AutoSizeDroppedWidth( pCuInfo->hwndClbAreaCodes );
}


VOID
CuUpdateCountryCodeLb(
    IN CUINFO* pCuInfo,
    IN BOOL fComplete )

    // Fill the country code dropdown and set the selection.  'FComplete'
    // indicates the entire list should be loaded, otherwise only the selected
    // item is loaded.  'PCuInfo' is the complex phone number context.
    //
{
    DWORD dwErr;
    BOOL fSelectionOk;
    COUNTRY* pCountries;
    COUNTRY* pCountry;
    DWORD cCountries;
    DWORD i;
    INT iSel;

    TRACE1( "CuUpdateCountryCodeLb(f=%d)", fComplete );

    // See if the current selection is the one to select.  If so, and it's not
    // a partial list when a complete list was requested, there's no need
    // to do anything further.
    //
    iSel = ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes );
    if (iSel >= 0)
    {
        pCountry = (COUNTRY* )ComboBox_GetItemDataPtr(
            pCuInfo->hwndLbCountryCodes, iSel );

        if (pCountry
            && pCountry != (VOID* )-1
            && pCountry != (VOID* )1
            && (pCountry->dwId == pCuInfo->dwCountryId)
            && (!fComplete || pCuInfo->fComplete))
        {
            return;
        }
    }

    // ...otherwise, clear the list in preparation for reload.
    //
    CuClearCountryCodeLb( pCuInfo );
    pCountries = NULL;
    cCountries = 0;

    dwErr = GetCountryInfo( &pCountries, &cCountries,
                (fComplete) ? 0 : pCuInfo->dwCountryId );
    if (dwErr == 0)
    {
        if (!fComplete)
        {
            // Add dummy item first in partial list so left arrow selection
            // change can be handled correctly.  See CBN_SELCHANGE handling.
            //
            ComboBox_AddItem(
                pCuInfo->hwndLbCountryCodes, TEXT("AAAAA"), (VOID* )-1 );
        }

        for (i = 0, pCountry = pCountries;
             i < cCountries;
             ++i, ++pCountry)
        {
            INT iItem;
            TCHAR szBuf[ 512 ];

            wsprintf( szBuf, TEXT("%s (%d)"),
                pCountry->pszName, pCountry->dwCode );
            iItem = ComboBox_AddItem(
                pCuInfo->hwndLbCountryCodes, szBuf, pCountry );

            // If it's the one in the entry, select it.
            //
            if (pCountry->dwId == pCuInfo->dwCountryId)
            {
                ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, iItem );
            }
        }

        if (!fComplete)
        {
            // Add dummy item last in partial list so right arrow selection
            // change can be handled correctly.  See CBN_SELCHANGE handling.
            //
            ComboBox_AddItem(
                pCuInfo->hwndLbCountryCodes, TEXT("ZZZZZ"), (VOID* )1 );
        }

        ComboBox_AutoSizeDroppedWidth( pCuInfo->hwndLbCountryCodes );

        if (dwErr == 0 && cCountries == 0)
        {
            dwErr = ERROR_TAPI_CONFIGURATION;
        }
    }

    if (dwErr != 0)
    {
        ErrorDlg( GetParent( pCuInfo->hwndLbCountryCodes ),
            SID_OP_LoadTapiInfo, dwErr, NULL );
        return;
    }

    if (ComboBox_GetCurSel( pCuInfo->hwndLbCountryCodes ) < 0)
    {
        // The entry's country code was not added to the list, so as an
        // alternate select the first country in the list, loading the whole
        // list if necessary...should be extremely rare, a diddled phonebook
        // or TAPI country list strangeness.
        //
        if (ComboBox_GetCount( pCuInfo->hwndLbCountryCodes ) > 0)
        {
            ComboBox_SetCurSel( pCuInfo->hwndLbCountryCodes, 0 );
        }
        else
        {
            FreeCountryInfo( pCountries, cCountries );
            CuUpdateCountryCodeLb( pCuInfo, TRUE );
            return;
        }
    }

    // Will be freed by CuFree.
    //
    pCuInfo->pCountries = pCountries;
    pCuInfo->cCountries = cCountries;
    pCuInfo->fComplete = fComplete;
}


//----------------------------------------------------------------------------
// Scripting utility routines (Su utilities)
// Listed alphabetically
//----------------------------------------------------------------------------

BOOL
SuBrowsePbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "browse" button control.
    // 'PSuInfo' is the script utility context.  'WNotification' is the wparam
    // of the WM_COMMAND notification.
    //
    // 'PSuInfo' is the script utility context.
    //
{
    OPENFILENAME ofn;
    TCHAR* pszFilterDesc;
    TCHAR* pszFilter;
    TCHAR* pszDefExt;
    TCHAR* pszTitle;
    TCHAR szBuf[ MAX_PATH + 1 ];
    TCHAR szDir[ MAX_PATH + 1 ];
    TCHAR szFilter[ 64 ];

    if (wNotification != BN_CLICKED)
    {
        return FALSE;
    }

    // Fill in FileOpen dialog parameter buffer.
    //
    pszFilterDesc = PszFromId( g_hinstDll, SID_ScpFilterDesc );
    pszFilter = PszFromId( g_hinstDll, SID_ScpFilter );
    if (pszFilterDesc && pszFilter)
    {
        DWORD dwLen = 0, dwSize = sizeof(szFilter) / sizeof(TCHAR);
        
        ZeroMemory( szFilter, sizeof(szFilter) );
        lstrcpyn( szFilter, pszFilterDesc, dwSize);
        dwLen = lstrlen( szFilter ) + 1;
        lstrcpyn( szFilter + dwLen, pszFilter, dwSize - dwLen );
    }
    Free0( pszFilterDesc );
    Free0( pszFilter );

    pszTitle = PszFromId( g_hinstDll, SID_ScpTitle );
    pszDefExt = PszFromId( g_hinstDll, SID_ScpDefExt );
    szBuf[ 0 ] = TEXT('\0');
    szDir[ 0 ] = TEXT('\0');

    // Saying "Alternate" rather than "System" here gives us the old NT
    // phonebook location rather than the new NT5 location, which for
    // scripts, is what we want.
    //
    GetPhonebookDirectory( PBM_Alternate, szDir );

    ZeroMemory( &ofn, sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = GetParent( pSuInfo->hwndLbScripts );
    ofn.hInstance = g_hinstDll;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szBuf;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrTitle = pszTitle;
    ofn.lpstrDefExt = pszDefExt;
    ofn.Flags = OFN_HIDEREADONLY;

    if (GetOpenFileName (&ofn))
    {
        SetWindowText( pSuInfo->hwndLbScripts, ofn.lpstrFile );
    }

    Free0( pszTitle );
    Free0( pszDefExt );

    return TRUE;
}


BOOL
SuEditPbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "edit" button control.
    // 'PSuInfo' is the script utility context.  'WNotification' is the wparam
    // of the WM_COMMAND notification.
    //
    // 'PSuInfo' is the script utility context.
    //
{
    TCHAR* psz;

    if (wNotification != BN_CLICKED)
    {
        return FALSE;
    }

    psz = GetText( pSuInfo->hwndLbScripts );
    if (psz)
    {
        HWND hwndDlg = GetParent( pSuInfo->hwndPbEdit );

        if (FFileExists( psz ))
        {
            SuEditScpScript( hwndDlg, psz );
        }
        else
        {
            SuEditSwitchInf( hwndDlg );
        }

        Free( psz );
    }

    return TRUE;
}


VOID
SuEditScpScript(
    IN HWND   hwndOwner,
    IN TCHAR* pszScript )

    // Starts notepad.exe on the 'pszScript' script path.  'HwndOwner' is the
    // window to center any error popup on.
    //
{
    TCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL f;

    wsprintf( szCmd, TEXT("notepad.exe %s"), pszScript );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    TRACEW1( "SuEditScp-cmd=%s", szCmd );

    f = CreateProcess(
            NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );
    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadSwitchEditor, GetLastError(), NULL );
    }
}


VOID
SuEditSwitchInf(
    IN HWND hwndOwner )

    // Starts notepad.exe on the system script file, switch.inf.  'HwndOwner'
    // is the window to center any error popup on.
    //
{
    TCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    TCHAR szSysDir[ MAX_PATH + 1 ];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL f;

    szSysDir[ 0 ] = TEXT('\0');
    g_pGetSystemDirectory( NULL, szSysDir, MAX_PATH );

    wsprintf( szCmd, TEXT("notepad.exe %s\\ras\\switch.inf"), szSysDir );

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    TRACEW1( "SuEditInf-cmd=%s", szCmd );

    f = CreateProcess(
            NULL, szCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );

    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadSwitchEditor, GetLastError(), NULL );
    }
}


VOID
SuFillDoubleScriptsList(
    IN SUINFO* pSuInfo )

    // Fill scripts list in context 'pSuInfo' with switch.inf entries and .SCP
    // file entries.  The old list, if any, is freed.  Select the script
    // selection in the context or "(none)" if none.  If the name is non-NULL
    // but not found in the list it is appended.  Caller must eventually call
    // DtlDestroyList on the returned list.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    INT nIndex;
    DTLLIST* pList;
    DTLLIST* pListScp;

    TRACE( "SuFillDoubleScriptsList" );

    ComboBox_ResetContent( pSuInfo->hwndLbScripts );
    ComboBox_AddItemFromId(
        g_hinstDll, pSuInfo->hwndLbScripts, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( pSuInfo->hwndLbScripts, 0 );

    pList = NULL;
    dwErr = LoadScriptsList( pSuInfo->hConnection, &pList );
    if (dwErr != 0)
    {
        ErrorDlg( GetParent( pSuInfo->hwndLbScripts ),
            SID_OP_LoadScriptInfo, dwErr, NULL );
        return;
    }

    pListScp = NULL;
    dwErr = SuLoadScpScriptsList( &pListScp );
    if (dwErr == 0)
    {
        while (pNode = DtlGetFirstNode( pListScp ))
        {
            DtlRemoveNode( pListScp, pNode );
            DtlAddNodeLast( pList, pNode );
        }

        DtlDestroyList( pListScp, NULL );
    }

    DtlDestroyList( pSuInfo->pList, DestroyPszNode );
    pSuInfo->pList = pList;

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        nIndex = ComboBox_AddString( pSuInfo->hwndLbScripts, psz );

        if (pSuInfo->pszSelection
            && lstrcmp( psz, pSuInfo->pszSelection ) == 0)
        {
            ComboBox_SetCurSel( pSuInfo->hwndLbScripts, nIndex );
        }
    }

    if (pSuInfo->pszSelection
        && ComboBox_GetCurSel( pSuInfo->hwndLbScripts ) <= 0
        && lstrcmp( pSuInfo->pszSelection,
               PszLoadString( g_hinstDll, SID_NoneSelected ) ) != 0)
    {
        nIndex = ComboBox_AddString(
            pSuInfo->hwndLbScripts, pSuInfo->pszSelection );
        if (nIndex >= 0)
        {
            ComboBox_SetCurSel( pSuInfo->hwndLbScripts, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( pSuInfo->hwndLbScripts );
}


#if 0
VOID
SuFillScriptsList(
    IN EINFO* pEinfo,
    IN HWND hwndLbScripts,
    IN TCHAR* pszSelection )

    // Fill scripts list in working entry of common entry context 'pEinfo'.
    // The old list, if any, is freed.  Select the script from user's entry.
    // 'HwndLbScripts' is the script dropdown.  'PszSelection' is the selected
    // name from the phonebook or NULL for "(none)".  If the name is non-NULL
    // but not found in the list it is appended.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    INT nIndex;
    DTLLIST* pList;

    TRACE( "SuFillScriptsList" );

    ComboBox_ResetContent( hwndLbScripts );
    ComboBox_AddItemFromId(
        g_hinstDll, hwndLbScripts, SID_NoneSelected, NULL );
    ComboBox_SetCurSel( hwndLbScripts, 0 );

    pList = NULL;
    dwErr = LoadScriptsList( &pList );
    if (dwErr != 0)
    {
        ErrorDlg( GetParent( hwndLbScripts ),
            SID_OP_LoadScriptInfo, dwErr, NULL );
        return;
    }

    DtlDestroyList( pEinfo->pListScripts, DestroyPszNode );
    pEinfo->pListScripts = pList;

    for (pNode = DtlGetFirstNode( pEinfo->pListScripts );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz;

        psz = (TCHAR* )DtlGetData( pNode );
        nIndex = ComboBox_AddString( hwndLbScripts, psz );

        if (pszSelection && lstrcmp( psz, pszSelection ) == 0)
        {
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
        }
    }

    if (pszSelection && ComboBox_GetCurSel( hwndLbScripts ) <= 0)
    {
        nIndex = ComboBox_AddString( hwndLbScripts, pszSelection );
        if (nIndex >= 0)
        {
            ComboBox_SetCurSel( hwndLbScripts, nIndex );
        }
    }

    ComboBox_AutoSizeDroppedWidth( hwndLbScripts );
}
#endif


VOID
SuFree(
    IN SUINFO* pSuInfo )

    // Free resources attached to the 'pSuInfo' context.
    //
{
    if (pSuInfo->pList)
    {
        DtlDestroyList( pSuInfo->pList, DestroyPszNode );
        pSuInfo->pList = NULL;
    }

    Free0( pSuInfo->pszSelection );
}


VOID
SuGetInfo(
    IN SUINFO* pSuInfo,
    OUT BOOL* pfScript,
    OUT BOOL* pfTerminal,
    OUT TCHAR** ppszScript )

    // Load the scripting information from the controls into caller's output
    // arguments.  'PSuInfo' is the complex phone number context.
    //
{
    // Whistler 308135 Dialup Scripting: Pre-Dial scripts can be selected but
    // are not executed
    //
    if (pSuInfo->hwndCbTerminal && !(pSuInfo->dwFlags & SU_F_DisableTerminal))
    {
        if (pfTerminal)
        {
            *pfTerminal = Button_GetCheck( pSuInfo->hwndCbTerminal );
        }
    }
    else
    {
        if (pfTerminal)
        {
            *pfTerminal = FALSE;
        }
    }

    if (pSuInfo->dwFlags & SU_F_DisableScripting)
    {
        if (pfScript)
        {
            *pfScript = FALSE;
        }

        if (ppszScript)
        {
            *ppszScript = NULL;
        }
    }
    else
    {
        if (pfScript)
        {
            *pfScript = Button_GetCheck( pSuInfo->hwndCbRunScript );
        }

        if (ppszScript)
        {
            *ppszScript = GetText( pSuInfo->hwndLbScripts );
        }
    }

    // Silently fix up "no script selected" error.
    //
    if (pfScript && *pfScript)
    {
        TCHAR* pszNone;

        pszNone = PszFromId( g_hinstDll, SID_NoneSelected );

        if (!ppszScript || !*ppszScript
            || !pszNone || lstrcmp( pszNone, *ppszScript ) == 0)
        {
            *pfScript = FALSE;
        }

        Free0( pszNone );
    }
}


VOID
SuInit(
    IN SUINFO* pSuInfo,
    IN HWND hwndCbRunScript,
    IN HWND hwndCbTerminal,
    IN HWND hwndLbScripts,
    IN HWND hwndPbEdit,
    IN HWND hwndPbBrowse,
    IN DWORD dwFlags)

    // Initialize the scripting context 'pSuInfo'.  The window handles are the
    // controls to be managed.  'PSuInfo' is the script utility context.
    //
{
    pSuInfo->hwndCbRunScript = hwndCbRunScript;
    pSuInfo->hwndCbTerminal = hwndCbTerminal;
    pSuInfo->hwndLbScripts = hwndLbScripts;
    pSuInfo->hwndPbEdit = hwndPbEdit;
    pSuInfo->hwndPbBrowse = hwndPbBrowse;
    pSuInfo->dwFlags = dwFlags;

    if (pSuInfo->dwFlags & SU_F_DisableTerminal)
    {
        Button_SetCheck(pSuInfo->hwndCbTerminal, FALSE);
        EnableWindow(pSuInfo->hwndCbTerminal, FALSE);
    }
    if (pSuInfo->dwFlags & SU_F_DisableScripting)
    {
        Button_SetCheck(pSuInfo->hwndCbRunScript, FALSE);
        EnableWindow(pSuInfo->hwndCbRunScript, FALSE);
        
        EnableWindow(pSuInfo->hwndLbScripts, FALSE);
        EnableWindow(pSuInfo->hwndPbEdit, FALSE);
        EnableWindow(pSuInfo->hwndPbBrowse, FALSE);
    }

    pSuInfo->pList = NULL;
    pSuInfo->pszSelection = NULL;
}


DWORD
SuLoadScpScriptsList(
    OUT DTLLIST** ppList )

    // Loads '*ppList' with a list of Psz nodes containing the pathnames of
    // the .SCP files in the RAS directory.  It is caller's responsibility to
    // call DtlDestroyList on the returned list.
    //
    // Returns 0 if successful or an error code.
    //
{
    UINT cch;
    TCHAR szPath[ MAX_PATH ];
    TCHAR* pszFile;
    WIN32_FIND_DATA data;
    HANDLE h;
    DTLLIST* pList;

    cch = g_pGetSystemDirectory( NULL, szPath, MAX_PATH );
    if (cch == 0)
    {
        return GetLastError();
    }

    pList = DtlCreateList( 0L );
    if (!pList)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcat( szPath, TEXT("\\ras\\*.scp") );

    h = FindFirstFile( szPath, &data );
    if (h != INVALID_HANDLE_VALUE)
    {
        // Find the address of the file name part of the path since the 'data'
        // provides only the filename and not the rest of the path.
        //
        pszFile = szPath + lstrlen( szPath ) - 5;

        do
        {
            DTLNODE* pNode;

            // Ignore any directories that happen to match.
            //
            if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            // Create a Psz node with the path to the found file and append it
            // to the end of the list.
            //
            // Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
            //
            lstrcpyn(
                pszFile,
                data.cFileName,
                MAX_PATH - lstrlen( szPath ) - 5 );
            pNode = CreatePszNode( szPath );
            if (!pNode)
            {
                continue;
            }

            DtlAddNodeLast( pList, pNode );
        }
        while (FindNextFile( h, &data ));

        FindClose( h );
    }

    *ppList = pList;
    return 0;
}


BOOL
SuScriptsCbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification )

    // Handle the WM_COMMAND notification to the "run scripts" checkbox
    // control.  'PSuInfo' is the script utility context.  'WNotification' is
    // the wparam of the WM_COMMAND notification.
    //
{
    if (wNotification != BN_CLICKED)
    {
        return FALSE;
    }

    SuUpdateScriptControls( pSuInfo );

    return TRUE;
}


VOID
SuSetInfo(
    IN SUINFO* pSuInfo,
    IN BOOL fScript,
    IN BOOL fTerminal,
    IN TCHAR* pszScript )

    // Set the controls for context 'pSuInfo' to the argument values.
    //
{
    Free0( pSuInfo->pszSelection );
    pSuInfo->pszSelection = StrDup( pszScript );

    if (pSuInfo->hwndCbTerminal && !(pSuInfo->dwFlags & SU_F_DisableTerminal))
    {
        Button_SetCheck( pSuInfo->hwndCbTerminal, fTerminal );
    }      
    if (!(pSuInfo->dwFlags & SU_F_DisableScripting))
    {
        Button_SetCheck( pSuInfo->hwndCbRunScript, fScript );
    }

    SuFillDoubleScriptsList( pSuInfo );

    SuUpdateScriptControls( pSuInfo );
}


VOID
SuUpdateScriptControls(
    IN SUINFO* pSuInfo )

    // Update the enable/disable state of the script controls based on the
    // "run script" check box setting.  'PSuInfo' is the script utility
    // context.
    //
{
    BOOL fCheck;

    fCheck = Button_GetCheck( pSuInfo->hwndCbRunScript );

    if (fCheck)
    {
        if (!pSuInfo->pList)
        {
            // Fill the script list with both SWITCH.INF and .SCP scripts.
            //
            SuFillDoubleScriptsList( pSuInfo );
        }
    }
    else
    {
        // Clear the list contents in addition to disabling, per spec.  The
        // current selection is saved off so if user re-checks the box his
        // last selection will show.
        //
        Free0( pSuInfo->pszSelection );
        pSuInfo->pszSelection = GetText( pSuInfo->hwndLbScripts );

        ComboBox_ResetContent( pSuInfo->hwndLbScripts );
        DtlDestroyList( pSuInfo->pList, DestroyPszNode );
        pSuInfo->pList = NULL;
    }

    EnableWindow( pSuInfo->hwndLbScripts, fCheck );
    EnableWindow( pSuInfo->hwndPbEdit, fCheck );
    EnableWindow( pSuInfo->hwndPbBrowse, fCheck );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\entry.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// entry.h
// Remote Access Common Dialog APIs
// Phonebook entry property sheet and wizard header
//
// 06/18/95 Steve Cobb


#ifndef _ENTRY_H_
#define _ENTRY_H_


#define RASEDFLAG_AnyNewEntry       (RASEDFLAG_NewEntry       | \
                                     RASEDFLAG_NewPhoneEntry  | \
                                     RASEDFLAG_NewTunnelEntry | \
                                     RASEDFLAG_NewDirectEntry | \
                                     RASEDFLAG_NewBroadbandEntry)
//
// pmay: 233287
//
// We need to be able to filter ports lists such that
// all port types are included in the list and such that
// all non-vpn port types are included in the list.  This
// is a requirement for the demand dial interface wizard.
//
// Define private RASET_* types to be used with the
// EuChangeEntryType function.
//
#define RASET_P_AllTypes        ((DWORD)-1)
#define RASET_P_NonVpnTypes     ((DWORD)-2)

//
// pmay: 378432
//
// Add more flexibility to Su* api's
// See SUINFO.dwFlags
//
#define SU_F_DisableTerminal       0x1
#define SU_F_DisableScripting      0x2

//-----------------------------------------------------------------------------
// Datatypes
//-----------------------------------------------------------------------------

// Phonebook Entry common block.
//
typedef struct
_EINFO
{
    // RAS API arguments.
    //
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
    RASENTRYDLG* pApiArgs;

    // Set true by property sheet or wizard when changes should be committed
    // before returning from the API.  Does not apply in ShellOwned-mode where
    // the API returns before the property sheet is dismissed.
    //
    BOOL fCommit;

    // Set if we have been called via RouterEntryDlg.
    //
    BOOL fRouter;

    // Set if fRouter is TRUE and pszRouter refers to a remote machine.
    //
    BOOL fRemote;

    // Set if pszRouter is an NT4 steelhead machine.  Valid only 
    // if fRouter is true.
    //
    BOOL fNt4Router;

    //Set if pszRouter is an Windows 2000 machine, Valid only if
    // fRouter is true
    BOOL fW2kRouter;

    // The name of the server in "\\server" form or NULL if none (or if
    // 'fRouter' is not set).
    //
    TCHAR* pszRouter;

    // Set by the add entry or add interface wizards if user chooses to end
    // the wizard and go edit the properties directly.  When this flag is set
    // the wizard should *not* call EuFree before returning.
    //
    BOOL fChainPropertySheet;

    // Phonebook settings read from the phonebook file.  All access should be
    // thru 'pFile' as 'file' will only be used in cases where the open
    // phonebook is not passed thru the reserved word hack.
    //
    PBFILE* pFile;
    PBFILE file;

    // Global preferences read via phonebook library.  All access should be
    // thru 'pUser' as 'user' will only be used in cases where the preferences
    // are not passed thru the reserved word hack.
    //
    PBUSER* pUser;
    PBUSER user;

    // Set if "no user before logon" mode.
    //
    BOOL fNoUser;

    // Set by the add-entry wizard if the selected port is an X.25 PAD.
    //
    BOOL fPadSelected;

    // Set if there are multiple devices configured, i.e. if the UI is running
    // in the multiple device mode.  This is implicitly false in VPN and
    // Direct modes.
    //
    BOOL fMultipleDevices;

    // Link storing the List of PBPHONEs and alternate options for shared
    // phone number mode.  This allows user to change the port/device to
    // another link without losing the phone number he typed.
    //
    DTLNODE* pSharedNode;

    // The node being edited (still in the list), and the original entry name
    // for use in comparison later.  These are valid in "edit" case only.
    //
    DTLNODE* pOldNode;
    TCHAR szOldEntryName[ RAS_MaxEntryName + 1 ];

    // The work entry node containing and a shortcut pointer to the entry
    // inside.
    //
    DTLNODE* pNode;
    PBENTRY* pEntry;

    // The master list of configured ports used by EuChangeEntryType to
    // construct an appropriate sub-list of PBLINKs in the work entry node.
    //
    DTLLIST* pListPorts;

    // The "current" device.  This value is NULL for multilink entries.  It
    // is the device that the entry will use if no change is made.  We compare
    // the current device to the device selected from the general tab to know
    // when it is appropriate to update the phonebook's "preferred" device.
    //
    TCHAR* pszCurDevice;
    TCHAR* pszCurPort;

    // Set true if there are no ports of the current entry type configured,
    // not including any bogus "uninstalled" ports added to the link list so
    // the rest of the code can assume there is at least one link.
    //
    BOOL fNoPortsConfigured;

    // Dial-out user info for router; used by AiWizard.  Used to set interface
    // credentials via MprAdminInterfaceSetCredentials.
    //
    TCHAR* pszRouterUserName;
    TCHAR* pszRouterDomain;
    TCHAR* pszRouterPassword;

    // Dial-in user info for router (optional); used by AiWizard.  Used to
    // create dial-in user account via NetUserAdd; the user name for the
    // account is the interface (phonebook entry) name.
    //
    BOOL fAddUser;
    TCHAR* pszRouterDialInPassword;

    // Home networking settings for the entry.
    //
    BOOL fComInitialized;
    HRESULT hShowHNetPagesResult;
    BOOL fShared;
    BOOL fDemandDial;
    BOOL fNewShared;
    BOOL fNewDemandDial;
    DWORD dwLanCount;
    IHNetConnection *pPrivateLanConnection;

    // AboladeG - security level of the current user.
    // Set true if the user is an administrator/power user.
    // This is required by several pages, both in the wizard
    // and in the property sheet.
    //
    BOOL fIsUserAdminOrPowerUser;

    // Set if strong encryption is supported by NDISWAN, as determined in
    // EuInit.
    //
    BOOL fStrongEncryption;

    // Set whent the VPN "first connect" controls should be read-only, e.g. in
    // the dialer's Properties button is pressed in the middle of a double
    // dial.
    //
    BOOL fDisableFirstConnect;

    //Used in the IPSec Policy in the Security tab for a VPN connection
    //
    BOOL fPSKCached;
    TCHAR szPSK[PWLEN + 1];


    // Flags to track whether to save the default Internet connection
    //
    BOOL fDefInternet;

    // Default credentials
    //
    BOOL   fGlobalCred;     //add for whistler bug 328673
    TCHAR* pszDefUserName;
    TCHAR* pszDefPassword;
}
EINFO;


// Complex phone number utilities context block.
//
typedef struct
_CUINFO
{
    // Array of country information.
    //
    COUNTRY* pCountries;

    // Number of countries in the 'pCountries' array.
    //
    DWORD cCountries;

    // The complete country list, rather than a partial, is loaded.
    //
    BOOL fComplete;

    // Handles of the controls involved.
    //
    HWND hwndStAreaCodes;
    HWND hwndClbAreaCodes;
    HWND hwndStPhoneNumber;     // May be NULL
    HWND hwndEbPhoneNumber;
    HWND hwndStCountryCodes;
    HWND hwndLbCountryCodes;
    HWND hwndCbUseDialingRules;
    HWND hwndPbDialingRules;    // May be NULL  
    HWND hwndPbAlternates;      // May be NULL
    HWND hwndStComment;         // May be NULL
    HWND hwndEbComment;         // May be NULL

    // List of area codes modified to include all strings retrieved with
    // CuGetInfo.  The list is owned by the caller, i.e. it is not cleaned up
    // on CuFree.
    //
    DTLLIST* pListAreaCodes;    // May be NULL

    // The area code and country code fields are blanked when "use dialing
    // rules" is not checked to avoid confusing the typical user who doesn't
    // understand them.  The setting to which each field would be restored
    // were "use dialing rules" to be enabled is stored here.  These fields
    // always reflect the value at the last rules toggle or set swap.
    //
    // This country ID also serves as the "country ID to select" passed to
    // CuUpdateCountryCodeLb, which allows an optimization where the full
    // Country Code list is only loaded when user requests to view it.
    //
    TCHAR* pszAreaCode;
    DWORD dwCountryId;
    DWORD dwCountryCode;

    // Used by tapi for the dialing rules
    HLINEAPP hlineapp;
}
CUINFO;


// Scripting utilities context block.
//
typedef struct
_SUINFO
{
    // The managed controls.
    //
    HWND hwndCbRunScript;
    HWND hwndCbTerminal;
    HWND hwndLbScripts;
    HWND hwndPbEdit;
    HWND hwndPbBrowse;

    // List of scripts loaded.
    //
    DTLLIST* pList;

    // The current list selection or if disabled the hidden selection.
    //
    TCHAR* pszSelection;

    // hConnection to the server in case this is a remote
    // machine.
    //
    HANDLE hConnection;

    // The flags
    //
    DWORD dwFlags;
}
SUINFO;


// "Dial another first" list item context block.
//
typedef struct
PREREQITEM
{
    TCHAR* pszEntry;
    TCHAR* pszPbk;
}
PREREQITEM;


//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
AeWizard(
    IN OUT EINFO* pEinfo );

VOID
AiWizard(
    IN OUT EINFO* pEinfo );

VOID
PePropertySheet(
    IN OUT EINFO* pEinfo );

DWORD
EuChangeEntryType(
    IN EINFO* pInfo,
    IN DWORD dwType );

BOOL
EuCommit(
    IN EINFO* pInfo );

DWORD
EuRouterInterfaceCreate(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommit(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommitRouterStandard(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommitRouterIPSec(
    IN EINFO* pInfo );

DWORD
EuCredentialsCommitRasGlobal(
    IN EINFO* pInfo );
    
DWORD
EuCredentialsCommitRasIPSec(
    IN EINFO* pInfo );

BOOL 
EuRouterInterfaceIsNew(
     IN EINFO * pInfo );

DWORD
EuInternetSettingsCommitDefault( 
    IN EINFO* pInfo );

DWORD
EuHomenetCommitSettings(
    IN EINFO* pInfo);
    
VOID
EuFree(
    IN EINFO* pInfo );

VOID
EuGetEditFlags(
    IN EINFO* pEinfo,
    OUT BOOL* pfEditMode,
    OUT BOOL* pfChangedNameInEditMode );

DWORD
EuInit(
    IN TCHAR* pszPhonebook,
    IN TCHAR* pszEntry,
    IN RASENTRYDLG* pArgs,
    IN BOOL fRouter,
    OUT EINFO** ppInfo,
    OUT DWORD* pdwOp );

BOOL
EuValidateName(
    IN HWND hwndOwner,
    IN EINFO* pEinfo );

VOID
CuClearCountryCodeLb(
    IN CUINFO* pCuInfo );

BOOL
CuCountryCodeLbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification );

VOID
CuCountryCodeLbSelChange(
    IN CUINFO* pCuInfo );

BOOL
CuDialingRulesCbHandler(
    IN CUINFO* pCuInfo,
    IN WORD wNotification );

VOID
CuFree(
    IN CUINFO* pCuInfo );

VOID
CuGetInfo(
    IN CUINFO* pCuInfo,
    OUT DTLNODE* pPhoneNode );

VOID
CuInit(
    OUT CUINFO* pCuInfo,
    IN HWND hwndStAreaCodes,
    IN HWND hwndClbAreaCodes,
    IN HWND hwndStPhoneNumber,
    IN HWND hwndEbPhoneNumber,
    IN HWND hwndStCountryCodes,
    IN HWND hwndLbCountryCodes,
    IN HWND hwndCbUseDialingRules,
    IN HWND hwndPbDialingRules,
    IN HWND hwndPbAlternates,
    IN HWND hwndStComment,
    IN HWND hwndEbComment,
    IN DTLLIST* pListAreaCodes );

VOID
CuSaveToAreaCodeList(
    IN CUINFO* pCuInfo,
    IN TCHAR* pszAreaCode );

VOID
CuSetInfo(
    IN CUINFO* pCuInfo,
    IN DTLNODE* pPhoneNode,
    IN BOOL fDisableAll );

VOID
CuUpdateAreaCodeClb(
    IN CUINFO* pCuInfo );

VOID
CuUpdateCountryCodeLb(
    IN CUINFO* pCuInfo,
    IN BOOL fComplete );

BOOL
SuBrowsePbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification );

BOOL
SuEditPbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification );

VOID
SuEditScpScript(
    IN HWND   hwndOwner,
    IN TCHAR* pszScript );

VOID
SuEditSwitchInf(
    IN HWND hwndOwner );

VOID
SuFillDoubleScriptsList(
    IN SUINFO* pSuInfo );

VOID
SuFillScriptsList(
    IN EINFO* pEinfo,
    IN HWND hwndLbScripts,
    IN TCHAR* pszSelection );

VOID
SuFree(
    IN SUINFO* pSuInfo );

VOID
SuGetInfo(
    IN SUINFO* pSuInfo,
    OUT BOOL* pfScript,
    OUT BOOL* pfTerminal,
    OUT TCHAR** ppszScript );

VOID
SuInit(
    IN SUINFO* pSuInfo,
    IN HWND hwndCbRunScript,
    IN HWND hwndCbTerminal,
    IN HWND hwndLbScripts,
    IN HWND hwndPbEdit,
    IN HWND hwndPbBrowse,
    IN DWORD dwFlags);

DWORD
SuLoadScpScriptsList(
    OUT DTLLIST** ppList );

BOOL
SuScriptsCbHandler(
    IN SUINFO* pSuInfo,
    IN WORD wNotification );

VOID
SuSetInfo(
    IN SUINFO* pSuInfo,
    IN BOOL fScript,
    IN BOOL fTerminal,
    IN TCHAR* pszScript );

VOID
SuUpdateScriptControls(
    IN SUINFO* pSuInfo );


#endif // _ENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\ifw.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** ifw.c
** Remote Access Common Dialog APIs
** Add Interface wizard
**
** 02/11/97 Abolade Gbadegesin (based on entryw.c, by Steve Cobb).
*/

#include "rasdlgp.h"
#include "entry.h"

//
// Definitions for flags tracked by the interface wizard.
// See the dwFlags member of AIINFO.
//
#define AI_F_HasPhysDevs    0x1    // router has phys ports available
#define AI_F_HasTunlDevs    0x2    // router has tunnel ports available
#define AI_F_HasPptpDevs    0x4    // router has Pptp ports available
#define AI_F_HasL2tpDevs    0x8    // router has L2tp ports available
#define AI_F_HasPPPoEDevs   0x10   // router has PPPoE ports available //for whistler bug 345068 349087

/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* Add Interface wizard context block.  All property pages refer to the single
** context block associated with the sheet.
*/
#define AIINFO struct tagAIINFO
AIINFO
{
    /* Common input arguments.
    */
    EINFO* pArgs;

    /* Wizard and page handles.  'hwndFirstPage' is the handle of the first
    ** property page initialized.  This is the page that allocates and frees
    ** the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndRb;    //Add for DOD wizard 345068 349087
    HWND hwndRw;
    HWND hwndIn;
    HWND hwndSs;
    HWND hwndRn;
    HWND hwndRp;
    HWND hwndRc;
    HWND hwndRa;
    HWND hwndNs;
    HWND hwndDo;
    HWND hwndDi;
    HWND hwndRf;
    HWND hwndVd;

    /* Interface Name page.
    */
    HWND hwndEbInterfaceName;

    /* Modem/Adapter page.
    */
    HWND hwndLv;

    /* Connection type page
    */
    HWND hwndRbTypePhys;
    HWND hwndRbTypeTunl;
    HWND hwndRbBroadband;   //Add for DOD wizard

    /* Phone number page.
    */
    HWND hwndStNumber;
    HWND hwndEbNumber;  //Share by VpnDestination, PhoneNumber, PPPoE
    HWND hwndPbAlternates;

    /* Login script page.
    */
    HWND hwndCbRunScript;
    HWND hwndLbScripts;
    HWND hwndCbTerminal;
    HWND hwndPbEdit;
    HWND hwndPbBrowse;

    /* IP address page.
    */
    HWND hwndCcIp;

    /* Name server page.
    */
    HWND hwndCcDns;
    HWND hwndCcWins;

    /* Vpn type page
    */
    HWND hwndVtRbAutomatic;
    HWND hwndVtRbPptp;
    HWND hwndVtRbL2tp;

    /* Dial-out credentials page.
    */
    HWND hwndDoEbUserName;
    HWND hwndDoEbDomain;
    HWND hwndDoEbPassword;
    HWND hwndDoEbConfirm;

    /* Dial-in credentials page.
    */
    HWND hwndDiEbUserName;
    HWND hwndDiEbDomain;
    HWND hwndDiEbPassword;
    HWND hwndDiEbConfirm;

    /* Router welcome page
    */
    HWND hwndRwStWelcome;

    /* Router finish page
    */
    HWND hwndRfStFinish;

    /* The phone number stash.  This allows user to change the port to another
    ** link without losing the phone number he typed.  Initialized to empty in
    ** AiInit and saved to entry in AiFinish.
    */
    DTLLIST* pListPhoneNumbers;
    BOOL     fPromoteHuntNumbers;

    /* Checkbox options chosen by user.
    */
    BOOL fIp;
    BOOL fIpx;
    BOOL fClearPwOk;
    BOOL fNotNt;

    /*For connection type page, For whistler bug 349807
    */
    DWORD dwCtDeviceNum;
    
    /* Set true when there is only one meaningful choice of device.
    */
    BOOL fSkipMa;

    /* Set true if the selected device is a modem or null modem.
    */
    BOOL fModem;

    /* The NP_* mask of protocols configured for RAS.
    */
    DWORD dwfConfiguredProtocols;

    /* Set true if IP is configured for RAS.
    */
    BOOL fIpConfigured;

    //IPX is not supported on IA64
    //
    BOOL fIpxConfigured;    

    /* Set to true of Add Interface wizard is skipped.
    */
    BOOL fSkipWizard;

    // After dial scripting helper context block, and a flag indicating if the
    // block has been initialized.
    //
    SUINFO suinfo;
    BOOL fSuInfoInitialized;

    // Handle to a bold font for use with start and finish wizard pages
    HFONT hBoldFont;

    // Flags that track the configuration of the machine that the
    // wizard is currently focused on.  See AI_F_*
    DWORD dwFlags;

    // Set to the vpn type when one is configured.
    DWORD dwVpnStrategy;

    // Index of the selected device on the RN page
    //
    DWORD dwSelectedDeviceIndex;
};


/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

int CALLBACK
AiCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam );

VOID
AiCancel(
    IN HWND hwndPage );

AIINFO*
AiContext(
    IN HWND hwndPage );

VOID
AiExit(
    IN AIINFO* pInfo,
    IN DWORD   dwError );

VOID
AiExitInit(
    IN HWND hwndDlg );

BOOL
AiFinish(
    IN HWND hwndPage );

AIINFO*
AiInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs );

VOID
AiTerm(
    IN HWND hwndPage );

INT_PTR CALLBACK
RbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RbInit(
    IN HWND hwndPage );

BOOL
RbKillActive(
    IN AIINFO* pInfo );

BOOL
RbSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
CtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CtInit(
    IN HWND   hwndPage );

BOOL
CtKillActive(
    IN AIINFO* pInfo );

BOOL
CtSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
DiDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DiInit(
    IN HWND   hwndPage );

BOOL
DiKillActive(
    IN AIINFO* pInfo );

BOOL
DiNext(
    IN AIINFO* pInfo );

BOOL
DiSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
DoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DoInit(
    IN HWND   hwndPage );

BOOL
DoKillActive(
    IN AIINFO* pInfo );

BOOL
DoNext(
    IN AIINFO* pInfo );
    
BOOL
DoSetActive(
    IN AIINFO* pInfo );

BOOL
InCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
InDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
InInit(
    IN     HWND   hwndPage);

BOOL
InKillActive(
    IN AIINFO* pInfo );

BOOL
InSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
NsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NsInit(
    IN HWND   hwndPage );

BOOL
NsKillActive(
    IN AIINFO* pInfo );

BOOL
NsSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RaInit(
    IN HWND hwndPage );

BOOL
RaKillActive(
    IN AIINFO* pInfo );

BOOL
RaSetActive(
    IN AIINFO* pInfo );

BOOL
RcCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RcInit(
    IN HWND hwndPage );

BOOL
RcKillActive(
    IN AIINFO* pInfo );

BOOL
RcSetActive(
    IN AIINFO* pInfo );

BOOL
RfCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RfDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RfInit(
    IN HWND hwndPage );

BOOL
RfKillActive(
    IN AIINFO* pInfo );
    
BOOL
RfSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RnInit(
    IN HWND hwndPage );

LVXDRAWINFO*
RnLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
RnLvItemChanged(
    IN AIINFO* pInfo );

BOOL
RnLvRefresh(
    IN AIINFO* pInfo);
    
BOOL
RnSetActive(
    IN AIINFO* pInfo );

VOID
RpAlternates(
    IN AIINFO* pInfo );

BOOL
RpCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
RpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RpInit(
    IN HWND hwndPage );

BOOL
RpKillActive(
    IN AIINFO* pInfo );

VOID
RpPhoneNumberToStash(
    IN AIINFO* pInfo );

BOOL
RpSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
RwDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
RwInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs );

BOOL
RwKillActive(
    IN AIINFO* pInfo );

BOOL
RwSetActive(
    IN AIINFO* pInfo );

BOOL
SsCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
SsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
SsInit(
    IN HWND hwndPage );

BOOL
SsKillActive(
    IN AIINFO* pInfo );

BOOL
SsSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
VdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
VdInit(
    IN HWND   hwndPage );

BOOL
VdKillActive(
    IN AIINFO* pInfo );

BOOL
VdSetActive(
    IN AIINFO* pInfo );

INT_PTR CALLBACK
VtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
VtInit(
    IN HWND   hwndPage );

BOOL
VtKillActive(
    IN AIINFO* pInfo );

BOOL
VtSetActive(
    IN AIINFO* pInfo );


/* Demand dial wizard page definitions.
*/
struct DD_WIZ_PAGE_INFO
{
    DLGPROC     pfnDlgProc;
    INT         nPageId;
    INT         nSidTitle;
    INT         nSidSubtitle;
    DWORD       dwFlags;
};


static const struct DD_WIZ_PAGE_INFO c_aDdWizInfo [] =
{
    { RwDlgProc, PID_RW_RouterWelcome,        0,            0,                PSP_HIDEHEADER},
    { InDlgProc, PID_IN_InterfaceName,        SID_IN_Title, SID_IN_Subtitle,  0},
    { CtDlgProc, PID_CT_RouterConnectionType, SID_CT_Title, SID_CT_Subtitle,  0},
    { VtDlgProc, PID_VT_RouterVpnType,        SID_VT_Title, SID_VT_Subtitle,  0},
    { RnDlgProc, PID_RN_RouterModemAdapter,   SID_RN_Title, SID_RN_Subtitle,  0},
    { RbDlgProc, PID_BS_BroadbandService,     SID_BS_Title, SID_BS_Subtitle,  0},
    { RpDlgProc, PID_RP_RouterPhoneNumber,    SID_RP_Title, SID_RP_Subtitle,  0},
    { VdDlgProc, PID_VD_RouterVpnDestination, SID_VD_Title, SID_VD_Subtitle,  0},
    { SsDlgProc, PID_SS_ServerSettings,       SID_SS_Title, SID_SS_Subtitle,  0},
    { RaDlgProc, PID_RA_RouterIpAddress,      SID_RA_Title, SID_RA_Subtitle,  0},
    { NsDlgProc, PID_NS_RouterNameServers,    SID_NS_Title, SID_NS_Subtitle,  0},
    { RcDlgProc, PID_RC_RouterScripting,      SID_RC_Title, SID_RC_Subtitle,  0},
    { DiDlgProc, PID_DI_RouterDialIn,         SID_DI_Title, SID_DI_Subtitle,  0},
    { DoDlgProc, PID_DO_RouterDialOut,        SID_DO_Title, SID_DO_Subtitle,  0},
    { RfDlgProc, PID_RF_RouterFinish,         0,            0,                PSP_HIDEHEADER},
};

#define c_cDdWizPages    (sizeof (c_aDdWizInfo) / sizeof(c_aDdWizInfo[0]))


/*----------------------------------------------------------------------------
** Add Interface wizard entry point
**----------------------------------------------------------------------------
*/

VOID
AiWizard(
    IN OUT EINFO* pEinfo )

    /* Runs the Phonebook entry property sheet.  'PEinfo' is an input block
    ** with only caller's API arguments filled in.
    */
{
    DWORD           dwErr, i;
    PROPSHEETHEADER header;
    PROPSHEETPAGE   apage[ c_cDdWizPages ];
    PROPSHEETPAGE*  ppage;
    

    TRACE("AiWizard");

    ZeroMemory( &header, sizeof(header) );

    // Prepare the header
    //
    header.dwSize       = sizeof(PROPSHEETHEADER);
    header.hwndParent   = pEinfo->pApiArgs->hwndOwner;
    header.hInstance    = g_hinstDll;
    header.nPages       = c_cDdWizPages;
    header.pszbmHeader  = MAKEINTRESOURCE( BID_WizardHeader );
    header.ppsp         = apage;
    header.pfnCallback  = AiCallbackFunc;
    header.dwFlags      = 
        (
            PSH_WIZARD           | PSH_WIZARD97    |
            PSH_WATERMARK        | PSH_HEADER      | 
            PSH_STRETCHWATERMARK | PSH_USECALLBACK |
            PSH_PROPSHEETPAGE 
        );

    // Prepare the array of pages
    //
    ZeroMemory( apage, sizeof(apage) );
    for (i = 0; i < c_cDdWizPages; i++)
    {
        // Initialize page data
        //
        ppage = &apage[i];
        ppage->dwSize       = sizeof(PROPSHEETPAGE);
        ppage->hInstance    = g_hinstDll;
        ppage->pszTemplate  = MAKEINTRESOURCE(c_aDdWizInfo[i].nPageId);
        ppage->pfnDlgProc   = c_aDdWizInfo[i].pfnDlgProc;
        ppage->lParam       = (LPARAM )pEinfo;
        ppage->dwFlags      = c_aDdWizInfo[i].dwFlags;

        // Initialize title and subtitle information.
        //
        if (c_aDdWizInfo[i].nSidTitle)
        {
            ppage->dwFlags |= PSP_USEHEADERTITLE;
            ppage->pszHeaderTitle = PszLoadString( g_hinstDll,
                    c_aDdWizInfo[i].nSidTitle );
        }

        if (c_aDdWizInfo[i].nSidSubtitle)
        {
            ppage->dwFlags |= PSP_USEHEADERSUBTITLE;
            ppage->pszHeaderSubTitle = PszLoadString( g_hinstDll,
                    c_aDdWizInfo[i].nSidSubtitle );
        }
        
    }

    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg( pEinfo->pApiArgs->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN,
            NULL );
    }
}


/*----------------------------------------------------------------------------
** Add Interface wizard
** Listed alphabetically
**----------------------------------------------------------------------------
*/

int CALLBACK
AiCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    /* A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    **
    ** Returns 0 always.
    */
{
    TRACE2("AiCallbackFunc(m=%d,l=%08x)",unMsg,lparam);

    if (unMsg == PSCB_PRECREATE)
    {
        DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
        pDlg->style &= ~(DS_CONTEXTHELP);
    }

    return 0;
}


VOID
AiCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a wizard page.
    */
{
    TRACE("AiCancel");
}


AIINFO*
AiContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a wizard page handle.
    */
{
    return (AIINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


VOID
AiExit(
    IN AIINFO* pInfo,
    IN DWORD   dwError )

    /* Forces an exit from the dialog, reporting 'dwError' to the caller.
    ** 'PInfo' is the dialog context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See AiExitInit.
    */
{
    TRACE("AiExit");

    pInfo->pArgs->pApiArgs->dwError = dwError;
    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
AiExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within AiInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}


BOOL
AiFinish(
    IN HWND hwndPage )

    /* Saves the contents of the wizard.  'HwndPage is the handle of a
    ** property page.  Pops up any errors that occur.  'FPropertySheet'
    ** indicates the user chose to edit the property sheet directly.
    **
    ** Returns true is page can be dismissed, false otherwise.
    */
{
    const TCHAR* pszIp0 = TEXT("0.0.0.0");

    AIINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("AiFinish");

    pInfo = AiContext( hwndPage );
    ASSERT(pInfo);
    if (pInfo == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    pEntry = pInfo->pArgs->pEntry;
    ASSERT(pEntry);

    // Update the entry type to match the selected port(s), which are assumed
    // to have been moved to the head of the list.  This does not happen
    // automatically because "all types" is used initially.
    //
    {
        DTLNODE* pNode;
        PBLINK* pLink;

        pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        ChangeEntryType( pEntry, pLink->pbport.dwType );
    }

    // Replace phone number settings of all enabled links (or the shared link,
    // if applicable) from the stashed phone number list.
    //
    {
        DTLLIST* pList;
        DTLNODE* pNodeL;
        PBLINK* pLink;

        ASSERT( pInfo->pListPhoneNumbers );

        if (pEntry->fSharedPhoneNumbers)
        {
            pLink = (PBLINK* )DtlGetData( pInfo->pArgs->pSharedNode );
            ASSERT( pLink );
            CopyPszListToPhoneList( pLink, pInfo->pListPhoneNumbers );
        }
        else
        {
            for (pNodeL = DtlGetFirstNode( pEntry->pdtllistLinks );
                 pNodeL;
                 pNodeL = DtlGetNextNode( pNodeL ))
            {
                pLink = (PBLINK* )DtlGetData( pNodeL );
                ASSERT( pLink );

                if (pLink->fEnabled)
                {
                    CopyPszListToPhoneList( pLink, pInfo->pListPhoneNumbers );
                }
            }
        }
    }

    /* Update some settings based on user selections.
    */
    if (pInfo->fClearPwOk)
    {
        pEntry->dwTypicalAuth = TA_Unsecure;
    }
    else
    {
        pEntry->dwTypicalAuth = TA_Secure;
    }
    pEntry->dwAuthRestrictions =    
        AuthRestrictionsFromTypicalAuth(pEntry->dwTypicalAuth);
    
    if (    !pInfo->fSkipWizard
        &&  !pInfo->fIp)
        pEntry->dwfExcludedProtocols |= NP_Ip;

    if (    !pInfo->fSkipWizard
        &&  !pInfo->fIpx)
        pEntry->dwfExcludedProtocols |= NP_Ipx;

    if (pEntry->pszIpAddress
        && lstrcmp( pEntry->pszIpAddress, pszIp0 ) != 0)
    {
        pEntry->dwIpAddressSource = ASRC_RequireSpecific;
    }

    if ((pEntry->pszIpDnsAddress
             && lstrcmp( pEntry->pszIpDnsAddress, pszIp0 ) != 0)
        || (pEntry->pszIpWinsAddress
             && lstrcmp( pEntry->pszIpWinsAddress, pszIp0 ) != 0))
    {
        pEntry->dwIpNameSource = ASRC_RequireSpecific;
    }

    if ( pEntry->dwType == RASET_Vpn ) 
    {
        pEntry->dwVpnStrategy = pInfo->dwVpnStrategy;
    }

    // pmay: 234964
    // Default the idle disconnect to five minutes
    //
    pEntry->lIdleDisconnectSeconds = 5 * 60;

    // pmay: 389632
    //
    // Default DD connections to not register their names (CreateEntryNode 
    // defaults this value to primary+inform)
    //
    pEntry->dwIpDnsFlags = 0;

    // Whistler bug: 
    // 
    // By default, DD connections should share file+print, nor be msclient,
    // nor permit NBT over tcp.
    //
    pEntry->fShareMsFilePrint = FALSE;
    pEntry->fBindMsNetClient = FALSE;
    EnableOrDisableNetComponent( pEntry, TEXT("ms_server"), FALSE);
    EnableOrDisableNetComponent( pEntry, TEXT("ms_msclient"), FALSE);
    pEntry->dwIpNbtFlags = 0;

    /* It's a valid new entry and caller has not chosen to edit properties
    ** directly, so mark the entry for commitment.
    */
    if (!pInfo->pArgs->fChainPropertySheet)
        pInfo->pArgs->fCommit = TRUE;

    return TRUE;
}


AIINFO*
AiInit(
    IN HWND   hwndFirstPage,
    IN EINFO* pArgs )

    /* Wizard level initialization.  'HwndPage' is the handle of the first
    ** page.  'PArgs' is the common entry input argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** wizard has been cancelled.
    */
{
    DWORD   dwErr;
    DWORD   dwOp;
    AIINFO* pInfo;
    HWND    hwndDlg;
    BOOL    bNt4;

    TRACE("AiInit");

    hwndDlg = GetParent( hwndFirstPage );

    /* Allocate the context information block.  Initialize it enough so that
    ** it can be destroyed properly, and associate the context with the
    ** window.
    */
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            TRACE("Context NOT allocated");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            AiExitInit( hwndDlg );
            return NULL;
        }

        ZeroMemory( pInfo, sizeof(AIINFO) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;
        pInfo->hwndFirstPage = hwndFirstPage;

        if (!SetProp( hwndDlg, g_contextId, pInfo ))
        {
            TRACE("Context NOT set");
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
            pArgs->pApiArgs->dwError = ERROR_UNKNOWN;
            Free( pInfo );
            AiExitInit( hwndDlg );
            return NULL;
        }

        TRACE("Context set");
    }

    /* Position the dialog per caller's instructions.
    */
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASDDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    // Do here instead of LibMain because otherwise it leaks resources into
    // WinLogon according to ShaunCo.
    //
    {
        InitCommonControls();
        IpAddrInit( g_hinstDll, SID_PopupTitle, SID_BadIpAddrRange );
    }

    /* Initialize these meta-flags that are not actually stored.
    */
    pInfo->fNotNt = FALSE;
    pInfo->fSkipMa = FALSE;
    pInfo->fModem = FALSE;
    pInfo->pArgs->fPadSelected = FALSE;

    {
        INTERNALARGS *pIArgs = (INTERNALARGS *) pArgs->pApiArgs->reserved;

        pInfo->dwfConfiguredProtocols =
            g_pGetInstalledProtocolsEx(
                (pIArgs) ? pIArgs->hConnection : NULL,
                TRUE, FALSE, TRUE);
    }

    pInfo->fIpConfigured = (pInfo->dwfConfiguredProtocols & NP_Ip);

//for whistler bug 213901
//
#ifndef _WIN64
    pInfo->fIpxConfigured = (pInfo->dwfConfiguredProtocols & NP_Ipx);
#else
    pInfo->fIpxConfigured = FALSE;
#endif


    // Set up common phone number list storage.
    //
    {
        pInfo->pListPhoneNumbers = DtlCreateList( 0 );
        if (!pInfo->pListPhoneNumbers)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            AiExitInit( hwndDlg );
            return NULL;
        }
    }

    // Load links for all port types.
    //
    EuChangeEntryType( pArgs, (DWORD )-1 );

    // Convert the PBPHONE phone list for the first link to a TAPI-disabled
    // PSZ stash list of phone numbers.  The stash list is edited rather than
    // the list in the entry so user can change active links without losing
    // the phone number he entered.
    //
    {
        DTLNODE* pNode;
        PBLINK* pLink;

        ASSERT( pInfo->pListPhoneNumbers );

        pNode = DtlGetFirstNode( pArgs->pEntry->pdtllistLinks );
        ASSERT( pNode );
        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT( pLink );

        for (pNode = DtlGetFirstNode( pLink->pdtllistPhones );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBPHONE* pPhone;
            DTLNODE* pNodeP;

            pPhone = (PBPHONE* )DtlGetData( pNode );
            ASSERT( pPhone );

            pNodeP = CreatePszNode( pPhone->pszPhoneNumber );
            if (pNodeP)
            {
                DtlAddNodeLast( pInfo->pListPhoneNumbers, pNodeP );
            }
        }
    }

    // Get the bold font for the start and finish pages
    //
    GetBoldWindowFont(hwndFirstPage, TRUE, &(pInfo->hBoldFont));

    // Initlialize the flags for this wizard based on the 
    // ports loaded in.
    //
    {
        DTLNODE* pNode;
        PBLINK* pLink;

        for (pNode = DtlGetFirstNode( pArgs->pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT( pLink );

            if ( pLink->pbport.dwType == RASET_Vpn ) 
            {
                pInfo->dwFlags |= AI_F_HasTunlDevs;
            }

            // pmay: 233287
            // Do not count bogus devices as physical devices.
            //
            else if (! (pLink->pbport.dwFlags & PBP_F_BogusDevice))
            {
                pInfo->dwFlags |= AI_F_HasPhysDevs;
            }

            if ( pLink->pbport.dwFlags & PBP_F_PptpDevice )
            {
                pInfo->dwFlags |= AI_F_HasPptpDevs;
            }
            else if ( pLink->pbport.dwFlags & PBP_F_L2tpDevice )
            {
                pInfo->dwFlags |= AI_F_HasL2tpDevs;
            }

            //For whistler bug 345068 349087
            //
            if ( pLink->pbport.dwFlags & PBP_F_PPPoEDevice )
            {
                pInfo->dwFlags |= AI_F_HasPPPoEDevs;
            }
        }

    }    

    return pInfo;
}


VOID
AiTerm(
    IN HWND hwndPage )

    /* Wizard level termination.  Releases the context block.  'HwndPage' is
    ** the handle of a property page.
    */
{
    AIINFO* pInfo;

    TRACE("AiTerm");

    pInfo = AiContext( hwndPage );
    if (pInfo)
    {
        if (pInfo->hBoldFont)
        {
            DeleteObject(pInfo->hBoldFont);
        }
        if (pInfo->pListPhoneNumbers)
        {
            DtlDestroyList( pInfo->pListPhoneNumbers, DestroyPszNode );
        }

        if (pInfo->fSuInfoInitialized)
        {
            SuFree( &pInfo->suinfo );
        }

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}



// Add Broadband service name page for router wizard 
// For whistler 345068 349087     gangz
// This broadband serice page is shared by AiWizard(ifw.c) and AeWizard(in entryw.c)
//
/*----------------------------------------------------------------------------
** Broadband service dialog procedure
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the broadband service page of the wizard.  
    // Parameters and return value are as described for 
    // standard windows 'DialogProc's.
    //
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RbInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RbSetActive");
                    pInfo = AiContext( hwnd );
                    
                    ASSERT(pInfo);
                    if ( NULL == pInfo )
                    {
                        break;
                    }
                    
                    fDisplay = RbSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RbKillActive");
                    pInfo = AiContext( hwnd );
                    
                    ASSERT(pInfo);
                    if ( NULL == pInfo )
                    {
                        break;
                    }
                    
                    fInvalid = RbKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RbInit(
    IN HWND hwndPage )

    // Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    // page.
    //
    // Return false if focus was set, true otherwise.
    //
{
    AIINFO* pInfo;

    TRACE("RbInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
    {
        return TRUE;
    }

    // Initialize page-specific context information.
    //
    pInfo->hwndRb = hwndPage;
    pInfo->hwndEbNumber = 
        GetDlgItem( hwndPage, CID_BS_EB_ServiceName );
    ASSERT(pInfo->hwndEbNumber);

    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
                   FirstPszFromList( pInfo->pListPhoneNumbers ) );
    

    return FALSE;
}

//For whistler bug 349807
//The RbXXX, VdXXX, RpXXX three sets of functions share the same pInfo->hwndEbNumber
//to store phone number/Vpn destionation/PPPPoE service name
//
BOOL
RbKillActive(
    IN AIINFO* pInfo )

    // Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true if the page is invalid, false is it can be dismissed.
    //
{

    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no PPPoE devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasPPPoEDevs) )
    {
        return FALSE;
    }

    // If the connection type is not broadband, skip this page since the
    // destination will be gotten from the phone number/VPN page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Broadband )
    {
        return FALSE;
    }    

    RpPhoneNumberToStash(pInfo);

    return FALSE;
}


BOOL
RbSetActive(
    IN AIINFO* pInfo )

    // Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    //
    // Returns true to display the page, false to skip it.
    //
{
    BOOL     fDisplayPage;
    PBENTRY* pEntry;

    TRACE("RbSetActive");
    
    ASSERT(pInfo);
    pEntry = pInfo->pArgs->pEntry;

    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }
    // If we have no PPPoE devices, then this page is invalid
    //
    if ( ! (pInfo->dwFlags & AI_F_HasPPPoEDevs) )
    {
        return FALSE;
    }
    
    if (RASET_Broadband != pEntry->dwType)
    {
        return FALSE;
    }
    else
    {
        PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
        fDisplayPage = TRUE;
    }

    pInfo->hwndEbNumber = 
        GetDlgItem( pInfo->hwndRb, CID_BS_EB_ServiceName );
    ASSERT(pInfo->hwndEbNumber);

    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
                   FirstPszFromList( pInfo->pListPhoneNumbers ) );

    return fDisplayPage;
}


/*----------------------------------------------------------------------------
** Connection type property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
CtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the vpn type page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CtInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("CtSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = CtSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("CtKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = CtKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
CtInit(
    IN HWND   hwndPage )
    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO * pInfo;

    // Get the context
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );
    if (pInfo == NULL)
    {
        return FALSE;
    }
    
    // Initialize the checks
    pInfo->hwndRbTypePhys = GetDlgItem( hwndPage, CID_CT_RB_Physical );
    ASSERT(pInfo->hwndRbTypePhys);
    pInfo->hwndRbTypeTunl = GetDlgItem( hwndPage, CID_CT_RB_Virtual );
    ASSERT(pInfo->hwndRbTypeTunl);
    //for whistler 345068 349087        gangz
    //
    pInfo->hwndRbBroadband  = GetDlgItem( hwndPage, CID_CT_RB_Broadband );       
    ASSERT(pInfo->hwndRbBroadband);

    // pmay: 233287     
    //for whistler 345068 349087    gangz
    // Likewise, if there are only one devices available among
    // phys devices, tunel devices and broadband devices , then force the 
    // user to configure  dd interface with that device.
    // 

    //If no valid device availabe, stop the wizard
    //
    pInfo->dwCtDeviceNum = 0;

    if (pInfo->dwFlags & AI_F_HasTunlDevs) 
    {
        pInfo->dwCtDeviceNum++;
     }
     
    if (pInfo->dwFlags & AI_F_HasPhysDevs)
    {
        pInfo->dwCtDeviceNum++;
     }

    if (pInfo->dwFlags & AI_F_HasPPPoEDevs)
    {
        pInfo->dwCtDeviceNum++;
     }
    
    if ( 0 == pInfo->dwCtDeviceNum )
    {
        ErrorDlg( pInfo->hwndDlg, SID_NoDevices, ERROR_UNKNOWN, NULL);
        AiExit ( pInfo, ERROR_DEVICE_NOT_AVAILABLE );
        
        return TRUE;
    }

    if ( 1 == pInfo->dwCtDeviceNum )
    {
        if (pInfo->dwFlags & AI_F_HasPhysDevs) 
        {
            EuChangeEntryType(
                pInfo->pArgs, 
                RASET_P_NonVpnTypes);
        }
        else if (pInfo->dwFlags & AI_F_HasTunlDevs) 
        {
            EuChangeEntryType(
                pInfo->pArgs, 
                RASET_Vpn);
        }
        else if (pInfo->dwFlags & AI_F_HasPPPoEDevs) 
        {
            EuChangeEntryType(
                pInfo->pArgs, 
                RASET_Broadband);
        }
        else
        {
            ErrorDlg( pInfo->hwndDlg, SID_NoDevices, ERROR_UNKNOWN, NULL);
            AiExit ( pInfo, ERROR_DEVICE_NOT_AVAILABLE );

            return TRUE;
        }
    }

    //Set radio buttons
    //
    Button_SetCheck(pInfo->hwndRbTypePhys, FALSE);
    Button_SetCheck(pInfo->hwndRbTypeTunl, FALSE);
    Button_SetCheck(pInfo->hwndRbBroadband, FALSE);
    
    if (pInfo->dwFlags & AI_F_HasPhysDevs)
    {
        Button_SetCheck(pInfo->hwndRbTypePhys, TRUE);
    }
    else if(pInfo->dwFlags & AI_F_HasTunlDevs)
    {
        Button_SetCheck(pInfo->hwndRbTypeTunl, TRUE);
    }
    else
    {
        Button_SetCheck(pInfo->hwndRbBroadband, TRUE);
    }

    //Enable/Disable buttons
    //
    if ( !(pInfo->dwFlags & AI_F_HasPhysDevs) )
    {
        EnableWindow(pInfo->hwndRbTypePhys, FALSE);
    }

    if ( !(pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        EnableWindow(pInfo->hwndRbTypeTunl, FALSE);
    }
    
    if ( !(pInfo->dwFlags & AI_F_HasPPPoEDevs) )
    {
        EnableWindow(pInfo->hwndRbBroadband, FALSE);
    }
    
    return FALSE;
}

BOOL
CtKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    BOOL bPhys, bTunnel;
    
    // Change the entry type based on the type 
    // selected from this page
    //For whistler 345068 349087    gangz
    // 

    bPhys = Button_GetCheck( pInfo->hwndRbTypePhys );
    bTunnel = Button_GetCheck( pInfo->hwndRbTypeTunl );

    if(bPhys)
    {
        EuChangeEntryType(
                          pInfo->pArgs, 
                          RASET_P_NonVpnTypes);
     }
     else if(bTunnel)
     {
        EuChangeEntryType(
                          pInfo->pArgs, 
                          RASET_Vpn);
     }
     else
     {
        EuChangeEntryType(
                          pInfo->pArgs, 
                          RASET_Broadband);
     }
    
    return FALSE;
}

BOOL
CtSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    // If we're focused on an nt4 box, then this page is 
    // invalid (type of connection is inferred from the 
    // device that gets selected.)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // Only allow this page to display if there are at least two of 
    // physical, tunnel and broadband devices configured.  Otherwise,
    // it makes no sense to allow the user to choose which
    // type he/she wants.

    if ( 2 <= pInfo->dwCtDeviceNum )
    {
        PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
        return TRUE;
    }

    return FALSE;
}



/*----------------------------------------------------------------------------
** Dial-In Credentials property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DiDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Dial-in Credentials page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                DiInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DiSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = DiSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DiKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DiKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoNEXT");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DiNext( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fInvalid) ? -1 : 0 );
                    return TRUE;
                }

            }
            break;
        }
    }

    return FALSE;
}



BOOL
DiInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("DiInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndDi = hwndPage;
    pInfo->hwndDiEbUserName = GetDlgItem( hwndPage, CID_DI_EB_UserName );
    Edit_LimitText( pInfo->hwndDiEbUserName, UNLEN );
    pInfo->hwndDiEbPassword = GetDlgItem( hwndPage, CID_DI_EB_Password );
    Edit_LimitText( pInfo->hwndDiEbPassword, PWLEN );
    pInfo->hwndDiEbConfirm = GetDlgItem( hwndPage, CID_DI_EB_Confirm );
    Edit_LimitText( pInfo->hwndDiEbConfirm, PWLEN );

    // pmay: 222622: Since we only configure local users, we removed 
    // the domain field from the dial in credentials page.

    return FALSE;
}

BOOL
DiKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    return FALSE;
}

BOOL
DiNext(
    IN AIINFO* pInfo )

    /* Called when PSN_WIZNEXT is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    /* Whistler bug 254385 encode password when not being used
    */
    psz = GetText(pInfo->hwndDiEbPassword);
    EncodePassword(psz);
    if (psz)
    {
        TCHAR* psz2;

        psz2 = GetText(pInfo->hwndDiEbConfirm);

        if(NULL != psz2)
        {
            /* Whistler bug 254385 encode password when not being used
            */
            DecodePassword(psz);
            if (lstrcmp(psz, psz2))
            {
                ZeroMemory(psz, (lstrlen(psz) + 1) * sizeof(TCHAR));
                ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
                Free(psz);
                Free(psz2);
                MsgDlg(pInfo->hwndDlg, SID_PasswordMismatch, NULL);
                SetFocus(pInfo->hwndDiEbPassword);
                return TRUE;
            }

            EncodePassword(psz);
            ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
            Free(psz2);
        }
        /* Whistler bug 254385 encode password when not being used
        ** Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
        */
        if (pInfo->pArgs->pszRouterDialInPassword)
        {
            ZeroMemory(
                pInfo->pArgs->pszRouterDialInPassword,
                (lstrlen(pInfo->pArgs->pszRouterDialInPassword) + 1) *
                    sizeof(TCHAR));
        }

        Free0(pInfo->pArgs->pszRouterDialInPassword);
        pInfo->pArgs->pszRouterDialInPassword = psz;
    }

    return FALSE;
}

BOOL
DiSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    /* The dialog is only displayed if the user is adding a dial-in account.
    */
    if (!pInfo->pArgs->fAddUser)
        return FALSE;

    /* Display the interface name in the disabled edit-box
    */
    SetWindowText(
        pInfo->hwndDiEbUserName, pInfo->pArgs->pEntry->pszEntryName );

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}




/*----------------------------------------------------------------------------
** Dial-Out Credentials property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
DoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Dial-Out Credentials page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                DoInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("DoSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = DoSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DoKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("DoNEXT");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = DoNext( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fInvalid) ? -1 : 0 );
                    return TRUE;
                }
                
            }
            break;
        }
    }

    return FALSE;
}



BOOL
DoInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("DoInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndDo = hwndPage;
    pInfo->hwndDoEbUserName = GetDlgItem( hwndPage, CID_DO_EB_UserName );
    Edit_LimitText( pInfo->hwndDoEbUserName, UNLEN );
    pInfo->hwndDoEbDomain = GetDlgItem( hwndPage, CID_DO_EB_Domain );
    Edit_LimitText( pInfo->hwndDoEbDomain, DNLEN );
    pInfo->hwndDoEbPassword = GetDlgItem( hwndPage, CID_DO_EB_Password );
    Edit_LimitText( pInfo->hwndDoEbPassword, PWLEN );
    pInfo->hwndDoEbConfirm = GetDlgItem( hwndPage, CID_DO_EB_Confirm );
    Edit_LimitText( pInfo->hwndDoEbConfirm, PWLEN );

    /* Use the target router name as the default "User name",
    */
    if (pInfo->pArgs->pszRouter)
    {
        if (pInfo->pArgs->pszRouter[0] == TEXT('\\') &&
            pInfo->pArgs->pszRouter[1] == TEXT('\\'))
            SetWindowText(pInfo->hwndDoEbUserName, pInfo->pArgs->pszRouter+2);
        else
            SetWindowText(pInfo->hwndDoEbUserName, pInfo->pArgs->pszRouter);
    }

    return FALSE;
}




BOOL
DoKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    return FALSE;
}

BOOL
DoNext(
    IN AIINFO* pInfo )

    /* Called when PSN_WIZNEXT is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText(pInfo->hwndDoEbUserName);
    if (psz)
    {
        if (!lstrlen(psz))
        {
            Free(psz);
            MsgDlg(pInfo->hwndDlg, SID_DialOutUserName, NULL);
            SetFocus(pInfo->hwndDoEbUserName);
            return TRUE;
        }

        Free0(pInfo->pArgs->pszRouterUserName);
        pInfo->pArgs->pszRouterUserName = psz;
    }

    psz = GetText(pInfo->hwndDoEbDomain);
    if (psz)
    {
        Free0(pInfo->pArgs->pszRouterDomain);
        pInfo->pArgs->pszRouterDomain = psz;
    }

    /* Whistler bug 254385 encode password when not being used
    */
    psz = GetText(pInfo->hwndDoEbPassword);
    EncodePassword(psz);
    if (psz)
    {
        TCHAR* psz2;

        psz2 = GetText(pInfo->hwndDoEbConfirm);

        if(NULL != psz2)
        {
            /* Whistler bug 254385 encode password when not being used
            */
            DecodePassword(psz);
            if (lstrcmp(psz, psz2))
            {
                ZeroMemory(psz, (lstrlen(psz) + 1) * sizeof(TCHAR));
                ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
                Free(psz);
                Free(psz2);
                MsgDlg(pInfo->hwndDlg, SID_PasswordMismatch, NULL);
                SetFocus(pInfo->hwndDoEbPassword);
                return TRUE;
            }

            EncodePassword(psz);
            ZeroMemory(psz2, (lstrlen(psz2) + 1) * sizeof(TCHAR));
            Free(psz2);
        }
        /* Whistler bug 254385 encode password when not being used
        ** Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
        */
        if (pInfo->pArgs->pszRouterPassword)
        {
            ZeroMemory(
                pInfo->pArgs->pszRouterPassword,
                (lstrlen(pInfo->pArgs->pszRouterPassword) + 1) * sizeof(TCHAR));
        }

        Free0(pInfo->pArgs->pszRouterPassword);
        pInfo->pArgs->pszRouterPassword = psz;
    }

    return FALSE;
}


BOOL
DoSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
#if 0
    TCHAR* psz;

    /* Fill in the interface name in the explanatory text.
    */
    psz = PszFromId( g_hinstDll, SID_RouterDialOut );
    if (psz)
    {
        MSGARGS msgargs;

        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = pInfo->pArgs->pEntry->pszEntryName;
        msgargs.fStringOutput = TRUE;
        msgargs.pszString = psz;

        MsgDlgUtil( NULL, 0, &msgargs, g_hinstDll, 0 );

        if (msgargs.pszOutput)
        {
            SetDlgItemText( pInfo->hwndDo, CID_DO_ST_Explain,
                msgargs.pszOutput );
            Free( msgargs.pszOutput );
        }

        Free( psz );
    }
#endif    

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Interface Name property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
InDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Interface Name page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                InInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("InRESET");
                    AiCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("InSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = InSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("InKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = InKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    AIINFO* pInfo;

                    TRACE("InWIZFINISH");

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }

                    /* You'd think pressing Finish would trigger a KILLACTIVE
                    ** event, but it doesn't, so we do it ourselves.
                    */
                    InKillActive( pInfo );

                    /* Set "no wizard" user preference, per user's check.
                    */
                    pInfo->pArgs->pUser->fNewEntryWizard = FALSE;
                    pInfo->pArgs->pUser->fDirty = TRUE;
                    g_pSetUserPreferences(
                        NULL,
                        pInfo->pArgs->pUser,
                        pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                    pInfo->pArgs->fPadSelected = FALSE;
                    pInfo->pArgs->fChainPropertySheet = TRUE;
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return InCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            AiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
InCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    //TRACE3("InCommand(n=%d,i=%d,c=$%x)",
    //    (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    return FALSE;
}


BOOL
InInit(
    IN     HWND   hwndPage)

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo;
    PBENTRY* pEntry;

    TRACE("InInit");

    // Get the context of this page
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );
    if (pInfo == NULL)
    {
        return FALSE;
    }

    // Set up the interface name stuff
    //
    pInfo->hwndEbInterfaceName =
        GetDlgItem( hwndPage, CID_IN_EB_InterfaceName );
    ASSERT(pInfo->hwndEbInterfaceName);
    
    pEntry = pInfo->pArgs->pEntry;
    if (!pEntry->pszEntryName)
    {
        /* No entry name, so think up a default.
        */
        dwErr = GetDefaultEntryName(
            pInfo->pArgs->pFile,
            pEntry->dwType,
            pInfo->pArgs->fRouter,
            &pEntry->pszEntryName );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPage, dwErr, NULL );
            AiExit( pInfo, dwErr );
            return TRUE;
        }
    }

    Edit_LimitText( pInfo->hwndEbInterfaceName, RAS_MaxEntryName );
    SetWindowText( pInfo->hwndEbInterfaceName, pEntry->pszEntryName );

    /* Initialize page-specific context information.
    */
    pInfo->hwndIn = hwndPage;

    return TRUE;
}


BOOL
InKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndEbInterfaceName );
    if (psz)
    {
        /* Update the entry name from the editbox.
        */
        Free0( pInfo->pArgs->pEntry->pszEntryName );
        pInfo->pArgs->pEntry->pszEntryName = psz;

        /* Validate the entry name.
        */
        if (!EuValidateName( pInfo->hwndDlg, pInfo->pArgs ))
        {
            SetFocus( pInfo->hwndEbInterfaceName );
            Edit_SetSel( pInfo->hwndEbInterfaceName, 0, -1 );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
InSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    TCHAR* psz;

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    
    return TRUE;
}



/*----------------------------------------------------------------------------
** Name Servers property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
NsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Name Servers page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                NsInit( hwnd );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("NsSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = NsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("NsKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = NsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}



BOOL
NsInit(
    IN     HWND   hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("NsInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndNs = hwndPage;
    pInfo->hwndCcDns = GetDlgItem( hwndPage, CID_NS_CC_Dns );
    ASSERT(pInfo->hwndCcDns);
    pInfo->hwndCcWins = GetDlgItem( hwndPage, CID_NS_CC_Wins );
    ASSERT(pInfo->hwndCcWins);

    /* Set the IP address fields.
    */
    SetWindowText( pInfo->hwndCcDns, pInfo->pArgs->pEntry->pszIpDnsAddress );
    SetWindowText( pInfo->hwndCcWins, pInfo->pArgs->pEntry->pszIpWinsAddress );

    return FALSE;
}




BOOL
NsKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR*      psz;
    PBENTRY*    pEntry = pInfo->pArgs->pEntry;

    psz = GetText( pInfo->hwndCcDns );
    if (psz)
    {
        Free0( pEntry->pszIpDnsAddress );
        pEntry->pszIpDnsAddress = psz;
    }

    psz = GetText( pInfo->hwndCcWins );
    if (psz)
    {
        Free0( pEntry->pszIpWinsAddress );
        pEntry->pszIpWinsAddress = psz;
    }

    return FALSE;
}


BOOL
NsSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    // In NT5, we always skip this page
    return FALSE;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}




/*----------------------------------------------------------------------------
** IP Address property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RaDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the IP Address page of the wizard.  Parameters
    ** and return value are as described for standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("RaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RaInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RaSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RaSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RaKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RaKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RaInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RaInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRa = hwndPage;
    pInfo->hwndCcIp = GetDlgItem( hwndPage, CID_RA_CC_Ip );
    ASSERT(pInfo->hwndCcIp);

    /* Set the IP address field to '0.0.0.0'.
    */
    SetWindowText( pInfo->hwndCcIp, pInfo->pArgs->pEntry->pszIpAddress );

    return FALSE;
}


BOOL
RaKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    TCHAR* psz;

    psz = GetText( pInfo->hwndCcIp );
    if (psz)
    {
        PBENTRY* pEntry = pInfo->pArgs->pEntry;

        Free0( pEntry->pszIpAddress );
        pEntry->pszIpAddress = psz;
    }

    return FALSE;
}


BOOL
RaSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    // In NT5, we always skip this page
    return FALSE;

    if (!pInfo->fNotNt || !pInfo->fIpConfigured)
    {
        return FALSE;
    }

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Logon Script property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RcDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Logon Script page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RcDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RcInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RcSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RcSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RcKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RcKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return RcCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RcCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("RcCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_RC_CB_RunScript:
        {
            if (SuScriptsCbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_RC_PB_Edit:
        {
            if (SuEditPbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }

        case CID_RC_PB_Browse:
        {
            if (SuBrowsePbHandler( &pInfo->suinfo, wNotification ))
            {
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}


BOOL
RcInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;
    PBENTRY* pEntry;

    TRACE("RcInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRc = hwndPage;
    pInfo->hwndCbTerminal = GetDlgItem( hwndPage, CID_RC_CB_Terminal );
    ASSERT( pInfo->hwndCbTerminal );
    pInfo->hwndCbRunScript = GetDlgItem( hwndPage, CID_RC_CB_RunScript );
    ASSERT( pInfo->hwndCbRunScript );
    pInfo->hwndLbScripts = GetDlgItem( hwndPage, CID_RC_LB_Scripts );
    ASSERT( pInfo->hwndLbScripts );
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_RC_PB_Edit );
    ASSERT( pInfo->hwndPbEdit );
    pInfo->hwndPbBrowse = GetDlgItem( hwndPage, CID_RC_PB_Browse );
    ASSERT( pInfo->hwndPbBrowse );

    pEntry = pInfo->pArgs->pEntry;

    pInfo->suinfo.hConnection = 
        ((INTERNALARGS *) pInfo->pArgs->pApiArgs->reserved)->hConnection;

    // We don't allow the script window for dd interfaces
    //
    ShowWindow(pInfo->hwndCbTerminal, SW_HIDE);

    // Set up the after-dial scripting controls.
    //
    SuInit( &pInfo->suinfo,
        pInfo->hwndCbRunScript,
        pInfo->hwndCbTerminal,
        pInfo->hwndLbScripts,
        pInfo->hwndPbEdit,
        pInfo->hwndPbBrowse,
        SU_F_DisableTerminal);
    pInfo->fSuInfoInitialized = TRUE;

    SuSetInfo( &pInfo->suinfo,
        pEntry->fScriptAfter,
        pEntry->fScriptAfterTerminal,
        pEntry->pszScriptAfter );

    return FALSE;
}


BOOL
RcKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    PBENTRY* pEntry;

    pEntry = pInfo->pArgs->pEntry;

    Free0( pEntry->pszScriptAfter );
    SuGetInfo( &pInfo->suinfo,
        &pEntry->fScriptAfter,
        &pEntry->fScriptAfterTerminal,
        &pEntry->pszScriptAfter );

    return FALSE;
}


BOOL
RcSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndRb;

    if (!pInfo->fNotNt || !pInfo->fModem)
        return FALSE;

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Finish property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RfDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Finish page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RfDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RfInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RfSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RfSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RfKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RfKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    TRACE("RfWIZFINISH");
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return RfCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
RfCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("RfCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

#if 0
    switch (wId)
    {
        case CID_RF_PB_Properties:
        {
            pInfo->pArgs->fChainPropertySheet = TRUE;
            PropSheet_PressButton( pInfo->hwndDlg, PSBTN_FINISH );
            return TRUE;
        }
    }
#endif

    return FALSE;
}


BOOL
RfInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;
    PBENTRY* pEntry;
    DWORD dwErr;

    TRACE("RfInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRf = hwndPage;

    // Set up a bold font if we can.
    //
    pInfo->hwndRfStFinish = GetDlgItem( hwndPage, CID_RF_ST_Explain );
    if (pInfo->hBoldFont && pInfo->hwndRfStFinish)
    {
        SendMessage( 
            pInfo->hwndRfStFinish,
            WM_SETFONT,
            (WPARAM)pInfo->hBoldFont,
            MAKELPARAM(TRUE, 0));
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return FALSE;
}


BOOL
RfSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_FINISH );
    return TRUE;
}

BOOL
RfKillActive(
    IN AIINFO* pInfo )
{
    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */

    return FALSE;
}


/*----------------------------------------------------------------------------
** Modem/Adapter property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RnDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Modem/Adapter page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RnDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, RnLvCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RnInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RnSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    fDisplay = RnSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    AIINFO* pInfo;

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    RnLvItemChanged( pInfo );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
RnInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD   dwErr;
    AIINFO* pInfo;

    TRACE("RnInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRn = hwndPage;
    pInfo->hwndLv = GetDlgItem( hwndPage, CID_RN_LV_Devices );
    ASSERT(pInfo->hwndLv);

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( pInfo->hwndLv, g_hinstDll );

    /* Add a single column exactly wide enough to fully display the
    ** widest member of the list.
    */
    {
        LV_COLUMN col;

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT;
        col.fmt = LVCFMT_LEFT;
        ListView_InsertColumn( pInfo->hwndLv, 0, &col );
        ListView_SetColumnWidth(
            pInfo->hwndLv, 0, LVSCW_AUTOSIZE_USEHEADER );
    }
    
    /* Don't bother with this page if there's only one device, not counting
    ** the bogus "uninstalled" standard modem that's added by EuInit so
    ** entries can be edited when there are no ports.
    */
    if (!pInfo->pArgs->fNoPortsConfigured
        && ListView_GetItemCount( pInfo->hwndLv ) == 1)
    {
        pInfo->fSkipMa = TRUE;
    }

    return FALSE;
}

LVXDRAWINFO*
RnLvCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 1, 0, LVXDI_DxFill, { 0, 0 } };

    return &info;
}

VOID
RnLvItemChanged(
    IN AIINFO* pInfo )

    /* Called when the combobox selection changes.  'PInfo' is the wizard
    ** context.
    */
{
    INT      iSel;
    DTLNODE* pNode;
    DTLLIST* pList;

    TRACE("RnLvItemChanged");

    pList = pInfo->pArgs->pEntry->pdtllistLinks;
    ASSERT(pList);
    pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
    pInfo->dwSelectedDeviceIndex = 
        (DWORD) ListView_GetNextItem( pInfo->hwndLv, -1, LVNI_SELECTED );

    if (pNode)
    {
        PBLINK* pLink;

        /* Single device selected.  Enable it, move it to the head of the list
        ** of links, and disable all the other links.
        */
        pLink = (PBLINK* )DtlGetData( pNode );
        pLink->fEnabled = TRUE;

        pInfo->fModem =
            (pLink->pbport.pbdevicetype == PBDT_Modem
             || pLink->pbport.pbdevicetype == PBDT_Null);

        /* If the device selected is an X25 PAD, we will drop the user into
        ** the phonebook entry-dialog after this wizard, so that the X25
        ** address can be entered there.
        */
        pInfo->pArgs->fPadSelected = (pLink->pbport.pbdevicetype == PBDT_Pad);

        DtlRemoveNode( pList, pNode );
        DtlAddNodeFirst( pList, pNode );

        for (pNode = DtlGetNextNode( pNode );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);
            pLink->fEnabled = FALSE;
        }
    }
    else
    {
        DTLNODE* pNextNode;
        DTLNODE* pAfterNode;

        pInfo->fModem = FALSE;

        /* ISDN multi-link selected.  Enable the ISDN multi-link nodes, move
        ** them to the head of the list, and disable all the other links.
        */
        pAfterNode = NULL;
        for (pNode = DtlGetFirstNode( pList );
             pNode;
             pNode = pNextNode)
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );
            ASSERT(pLink);

            pNextNode = DtlGetNextNode( pNode );

            if (pLink->pbport.pbdevicetype == PBDT_Isdn
                && !pLink->fProprietaryIsdn)
            {
                pLink->fEnabled = TRUE;

                DtlRemoveNode( pList, pNode );
                if (pAfterNode)
                    DtlAddNodeAfter( pList, pAfterNode, pNode );
                else
                    DtlAddNodeFirst( pList, pNode );
                pAfterNode = pNode;
            }
            else
            {
                pLink->fEnabled = FALSE;
            }
        }
    }
}

BOOL
RnLvRefresh(
    IN AIINFO* pInfo)
{
    DWORD dwErr = NO_ERROR;
    TCHAR*   psz;
    DTLNODE* pNode;
    DWORD    cMultilinkableIsdn;
    INT      iItem;

    ListView_DeleteAllItems( pInfo->hwndLv );

    iItem = 1;
    cMultilinkableIsdn = 0;
    for (pNode = DtlGetFirstNode( pInfo->pArgs->pEntry->pdtllistLinks );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        PBLINK* pLink;

        pLink = (PBLINK* )DtlGetData( pNode );
        ASSERT(pLink);

        if (pLink->pbport.pbdevicetype == PBDT_Isdn
            && !pLink->fProprietaryIsdn)
        {
            ++cMultilinkableIsdn;
        }

        psz = DisplayPszFromDeviceAndPort(
            pLink->pbport.pszDevice, pLink->pbport.pszPort );
        if (psz)
        {
            PBLINK* pLink;
            LV_ITEM item;

            pLink = (PBLINK* )DtlGetData( pNode );

            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            item.iItem = iItem++;
            item.pszText = psz;

            // I noticed that the device bitmaps were
            // inconsistent with connections, so I'm 
            // matching them up here.
            //
            if (pLink->pbport.dwType == RASET_Direct)
            {
                item.iImage = DI_Direct;
            }
            else if (pLink->pbport.pbdevicetype == PBDT_Modem)
            {
                item.iImage = DI_Modem;    
            }
            else 
            {
                item.iImage = DI_Adapter;    
            }

            item.lParam = (LPARAM )pNode;

            ListView_InsertItem( pInfo->hwndLv, &item );
            Free( psz );
        }
    }

    if (cMultilinkableIsdn > 1)
    {
        psz = PszFromId( g_hinstDll, SID_IsdnAdapter );
        if (psz)
        {
            LONG    lStyle;
            LV_ITEM item;

            /* Turn off sorting so the special ISDN-multilink item appears
            ** at the top of the list.
            */
            lStyle = GetWindowLong( pInfo->hwndLv, GWL_STYLE );
            SetWindowLong( pInfo->hwndLv, GWL_STYLE,
                (lStyle & ~(LVS_SORTASCENDING)) );

            ZeroMemory( &item, sizeof(item) );
            item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
            item.iItem = 0;
            item.pszText = psz;
            item.iImage = DI_Adapter;
            item.lParam = (LPARAM )NULL;

            ListView_InsertItem( pInfo->hwndLv, &item );
            Free( psz );
        }
    }

    return NO_ERROR;    
}

BOOL
RnSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    INT cDevices;

    // pmay: 233295.
    // This page does not apply to VPN connections
    //
    if (
        ((pInfo->pArgs->pEntry->dwType == RASET_Vpn        
            &&  !pInfo->pArgs->fNt4Router) 
         || (pInfo->fSkipMa) 
         || (pInfo->pArgs->pEntry->dwType == RASET_Broadband)) //For whistler 349807
       )
    {
        return FALSE;
    }

    // If we have no physical devices, then this page is invalid
    // unless we're focused on an nt4 machine in which case the 
    // tunneling adapters are selected from here.
    if ( ! (pInfo->dwFlags & AI_F_HasPhysDevs) )
    {
        if ( ! pInfo->pArgs->fNt4Router )
            return FALSE;
    }

    // Refresh the list view and make the correct selection
    //
    RnLvRefresh(pInfo);
    ListView_SetItemState( 
        pInfo->hwndLv, 
        pInfo->dwSelectedDeviceIndex,
        LVIS_SELECTED, LVIS_SELECTED );

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}


/*----------------------------------------------------------------------------
** Phone Number property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Phone Number page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("RpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return RpInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RpSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RpSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("RpKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RpKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return RpCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


VOID
RpAlternates(
    IN AIINFO* pInfo )

    /* Popup the Alternate Phone Numbers dialog.  'PInfo' is the property
    ** sheet context.
    */
{
    RpPhoneNumberToStash( pInfo );

    if (PhoneNumberDlg(
            pInfo->hwndRp,
            pInfo->pArgs->fRouter,
            pInfo->pListPhoneNumbers,
            &pInfo->fPromoteHuntNumbers ))
    {
        TCHAR* pszPhoneNumber;

        pszPhoneNumber = FirstPszFromList( pInfo->pListPhoneNumbers );
        SetWindowText( pInfo->hwndEbNumber, pszPhoneNumber );
    }
}


BOOL
RpCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("RpCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_RP_PB_Alternates:
            RpAlternates( pInfo );
            return TRUE;
    }

    return FALSE;
}


BOOL
RpInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("RpInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRp = hwndPage;
    pInfo->hwndStNumber = GetDlgItem( hwndPage, CID_RP_ST_Number );
    ASSERT(pInfo->hwndStNumber);
    pInfo->hwndEbNumber = GetDlgItem( hwndPage, CID_RP_EB_Number );
    ASSERT(pInfo->hwndEbNumber);
    pInfo->hwndPbAlternates = GetDlgItem( hwndPage, CID_RP_PB_Alternates );
    ASSERT(pInfo->hwndPbAlternates);

    /* Fill the phone number field from the stash created earlier.
    */
    Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
    SetWindowText( pInfo->hwndEbNumber,
        FirstPszFromList( pInfo->pListPhoneNumbers ) );

    return FALSE;
}


BOOL
RpKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    // pmay: 226610.  Call RpPhoneNumberToStash if we were successfully
    // activated.
    
    /* Update the stashed phone number from the editbox.
    */
    if ( (! pInfo->pArgs->fNt4Router)                && 
         ( (pInfo->pArgs->pEntry->dwType == RASET_Vpn) ||
           (pInfo->pArgs->pEntry->dwType == RASET_Broadband) ) //For whistler 349807
       )
    {
        return FALSE;
    }
   
    RpPhoneNumberToStash( pInfo );

    return FALSE;
}


VOID
RpPhoneNumberToStash(
    IN AIINFO* pInfo )

    /* Replace the first phone number in the stashed list with the contents of
    ** the phone number field.  'pInfo' is the property sheet context.
    */
{
    DWORD  dwErr;
    TCHAR* pszPhoneNumber;

    TRACE("RpPhoneNumberToStash");

    pszPhoneNumber = GetText( pInfo->hwndEbNumber );
    if (pszPhoneNumber)
    {
        dwErr = FirstPszToList( pInfo->pListPhoneNumbers, pszPhoneNumber );
        Free( pszPhoneNumber );
    }
    else
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RetrievingData, dwErr, NULL );
        AiExit( pInfo, dwErr );
    }
}


BOOL
RpSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    INT      iSel;
    DTLNODE* pNode;
    DTLLIST* pList;
    PBLINK*  pLink;
        
    if (! pInfo->pArgs->fNt4Router)             
    {
        // If we're focused on an nt5 machine, then skip this page
        // if the connection type is virtual because the phone number will
        // be gotten from the vpn destination page.
        if (pInfo->pArgs->pEntry->dwType == RASET_Vpn ||
            pInfo->pArgs->pEntry->dwType == RASET_Broadband)    //Add this for whistler 349087
        {
            return FALSE;
        }
        
        // pmay: 233287
        //
        // No phone number is requred if the device is dcc.  Skip 
        // this page if that is the case.
        //
        pList = pInfo->pArgs->pEntry->pdtllistLinks;
        ASSERT(pList);
        pNode = (DTLNODE* )ListView_GetSelectedParamPtr( pInfo->hwndLv );
        if (pNode)
        {
            // Single device selected.  See if its dcc
            pLink = (PBLINK* )DtlGetData( pNode );
            if (pLink->pbport.dwType == RASET_Direct)
            {
                return FALSE;
            }
        }
    }        

    // Instruct the wizard to use the destination editbox for the 
    // phone number of this connection
    pInfo->hwndEbNumber = GetDlgItem(pInfo->hwndRp, CID_RP_EB_Number);
    
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}


/*----------------------------------------------------------------------------
** Router welcome property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
RwDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Router Welcome page of the wizard.
    ** Parameters and return values are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return
                RwInit( hwnd, (EINFO* )(((PROPSHEETPAGE* )lparam)->lParam) );
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    TRACE("RwRESET");
                    AiCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("RwSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = RwSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("InKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = RwKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    AIINFO* pInfo;

                    TRACE("InWIZFINISH");

                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }

                    /* You'd think pressing Finish would trigger a KILLACTIVE
                    ** event, but it doesn't, so we do it ourselves.
                    */
                    RwKillActive( pInfo );

                    /* Set "no wizard" user preference, per user's check.
                    */
                    pInfo->pArgs->pUser->fNewEntryWizard = FALSE;
                    pInfo->pArgs->pUser->fDirty = TRUE;
                    g_pSetUserPreferences(
                        NULL,
                        pInfo->pArgs->pUser,
                        pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );

                    pInfo->pArgs->fPadSelected = FALSE;
                    pInfo->pArgs->fChainPropertySheet = TRUE;
                    AiFinish( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, 0 );
                    return TRUE;
                }
            }
            break;
        }

        case WM_DESTROY:
        {
            AiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}

BOOL
RwInit(
    IN     HWND   hwndPage,
    IN OUT EINFO* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo;

    TRACE("RwInit");

    /* We're first page, so initialize the wizard.
    */
    pInfo = AiInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndRw = hwndPage;
    pInfo->hwndRwStWelcome = GetDlgItem( hwndPage, CID_RW_ST_Welcome);

    // Set up a bold font if we can.
    //
    if (pInfo->hBoldFont)
    {
        SendMessage( 
            pInfo->hwndRwStWelcome,
            WM_SETFONT,
            (WPARAM)pInfo->hBoldFont,
            MAKELPARAM(TRUE, 0));
    }

    /* Create and display the wizard bitmap.
    */
    CreateWizardBitmap( hwndPage, TRUE );

    return TRUE;
}


BOOL
RwKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    return FALSE;
}


BOOL
RwSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_NEXT );
    return TRUE;
}



/*----------------------------------------------------------------------------
** Server settings property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
SsDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the 5 checkboxes page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
#if 0
    TRACE4("SsDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return SsInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("SsSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = SsSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("SsKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = SsKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            AIINFO* pInfo = AiContext( hwnd );
            ASSERT(pInfo);
            if (pInfo == NULL)
            {
                break;
            }

            return SsCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}



BOOL
SsCommand(
    IN AIINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("SsCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_SS_CB_AddUser:
            return TRUE;
    }

    return FALSE;
}


BOOL
SsInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO* pInfo;

    TRACE("SsInit");

    pInfo = AiContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndSs = hwndPage;

    if (pInfo->fIpConfigured)
        CheckDlgButton( hwndPage, CID_SS_CB_RouteIp, BST_CHECKED );

//for whistler bug 213901
//Hide the IPX checkbox
//move other check boxes to cover the hole made by hiding
//
#ifdef _WIN64
    {
        HWND hwndCBox[4];
        RECT rcPos[4];
        POINT   ptTemp;
        int i;

        hwndCBox[0] = GetDlgItem( hwndPage, CID_SS_CB_RouteIpx );
        hwndCBox[1] = GetDlgItem( hwndPage, CID_SS_CB_AddUser );
        hwndCBox[2] = GetDlgItem( hwndPage, CID_SS_CB_PlainPw );
        hwndCBox[3] = GetDlgItem( hwndPage, CID_SS_CB_NotNt );

        for ( i = 0; i < 4; i++ )
        {
            
            GetWindowRect( hwndCBox[i], &rcPos[i] );
            ptTemp.x = rcPos[i].left;
            ptTemp.y = rcPos[i].top;

            ScreenToClient( hwndPage, &ptTemp );
            rcPos[i].left = ptTemp.x;
            rcPos[i].top  = ptTemp.y;

            //Add this for whistler bug# 256658    gangz
            //
            ptTemp.x = rcPos[i].right;
            ptTemp.y = rcPos[i].bottom;

            ScreenToClient( hwndPage, &ptTemp );
            rcPos[i].right    = ptTemp.x;
            rcPos[i].bottom   = ptTemp.y;
        }

        ShowWindow ( hwndCBox[0], SW_HIDE );
        EnableWindow( hwndCBox[0], FALSE );

        for ( i = 1; i< 4; i++ )
        {
            MoveWindow ( hwndCBox[i],
                         rcPos[i-1].left,
                         rcPos[i-1].top,
                         rcPos[i].right - rcPos[i].left + 1,
                         rcPos[i].bottom - rcPos[i].top +1,
                         TRUE );
        }
    }
#else
    if (pInfo->fIpxConfigured)
    {
        CheckDlgButton( hwndPage, CID_SS_CB_RouteIpx, BST_CHECKED );
    }
#endif

    return FALSE;
}


BOOL
SsKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    pInfo->fIp =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_RouteIp );

//for whistler bug 213901
//
#ifndef _WIN64
    pInfo->fIpx =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_RouteIpx );
#else
    pInfo->fIpx = FALSE;
#endif

    pInfo->pArgs->fAddUser =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_AddUser );
    pInfo->pArgs->pEntry->fAuthenticateServer = FALSE;
    pInfo->fClearPwOk =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_PlainPw );
    pInfo->fNotNt =
        IsDlgButtonChecked( pInfo->hwndSs, CID_SS_CB_NotNt );

    if (pInfo->fIp && !pInfo->fIpConfigured)
    {
        MsgDlg( pInfo->hwndDlg, SID_ConfigureIp, NULL );
        SetFocus( GetDlgItem( pInfo->hwndSs, CID_SS_CB_RouteIp) );
        return TRUE;
    }

#ifndef _WIN64
    if (pInfo->fIpx && !pInfo->fIpxConfigured)
    {
        MsgDlg( pInfo->hwndDlg, SID_ConfigureIpx, NULL );
        SetFocus( GetDlgItem( pInfo->hwndSs, CID_SS_CB_RouteIpx) );
        return TRUE;
    }
#endif

    return FALSE;
}


BOOL
SsSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    HWND hwndScript = GetDlgItem( pInfo->hwndSs, CID_SS_CB_NotNt );
    HWND hwndPw = GetDlgItem( pInfo->hwndSs, CID_SS_CB_PlainPw );
    
    //
    // We only allow interactive scripting on modem devices
    //
    // (pmay: 378432.  Same for PAP/SPAP)
    //
    if ( pInfo->pArgs->pEntry->dwType == RASET_Vpn )
    {
        Button_SetCheck( hwndScript, FALSE );
        Button_SetCheck( hwndPw, FALSE );
        EnableWindow( hwndScript, FALSE );
        EnableWindow( hwndPw, FALSE );
    }
    else
    {
        EnableWindow( hwndScript, TRUE );
        EnableWindow( hwndPw, TRUE );
    }

    //For PPPoE dont add a dial-in user account whistler 345068 349087 gangz
    //
    if ( RASET_Broadband == pInfo->pArgs->pEntry->dwType )
    {
        HWND hwndTmp = GetDlgItem( pInfo->hwndSs, CID_SS_CB_AddUser );

        if (hwndTmp)
        {
            Button_SetCheck( hwndTmp, FALSE );
            EnableWindow( hwndTmp, FALSE);
         }
    }
    
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    return TRUE;
}


/*----------------------------------------------------------------------------
** Vpn destination property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
VdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the vpn destination page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return VdInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("VdSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = VdSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("VdKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = VdKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


BOOL
VdInit(
    IN HWND   hwndPage )
    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD    dwErr;
    AIINFO*  pInfo = NULL;
    PBENTRY* pEntry;

    TRACE("InInit");

    // Get the context of this page
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );

    // Set up the interface name stuff
    //
    //For prefix bug 226336 to validate the pInfo   gangz
    //
    if(pInfo)
    {
        pInfo->hwndEbNumber =
            GetDlgItem( hwndPage, CID_VD_EB_NameOrAddress );
     //    ASSERT(pInfo->hwndEbInterfaceName);
        ASSERT(pInfo->hwndEbNumber);
     
    
        Edit_LimitText( pInfo->hwndEbNumber, RAS_MaxPhoneNumber );
        SetWindowText( pInfo->hwndEbNumber,
            FirstPszFromList( pInfo->pListPhoneNumbers ) );

        /* Initialize page-specific context information.
        */
        pInfo->hwndVd = hwndPage;
       return TRUE;
   }
   else
   {
       return FALSE;
   }

}

BOOL
VdKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    // pmay: 226610.  Call RpPhoneNumberToStash if we were successfully
    // activated.

    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no tunnel devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        return FALSE;
    }

    // If the connection type is not virtual, skip this page since the
    // destination will be gotten from the phone number/PPPoE page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Vpn )
    {
        return FALSE;
    }    

    RpPhoneNumberToStash(pInfo);
    
    return FALSE;
}

BOOL
VdSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no tunnel devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        return FALSE;
    }

    // If the connection type is not virtual, skip this page since the
    // destination will be gotten from the phone number page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Vpn )
    {
        return FALSE;
    }            

    // Instruct the wizard to use the destination editbox for the 
    // phone number of this connection
    pInfo->hwndEbNumber = GetDlgItem(pInfo->hwndVd, CID_VD_EB_NameOrAddress);
    
    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}

/*----------------------------------------------------------------------------
** Vpn type property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
VtDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the vpn type page of the wizard.
    ** Parameters and return value are as described for standard windows
    ** 'DialogProc's.
    */
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return VtInit( hwnd );

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_SETACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fDisplay;

                    TRACE("VtSETACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fDisplay = VtSetActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, (fDisplay) ? 0 : -1 );
                    return TRUE;
                }

                case PSN_KILLACTIVE:
                {
                    AIINFO* pInfo;
                    BOOL    fInvalid;

                    TRACE("VtKILLACTIVE");
                    pInfo = AiContext( hwnd );
                    ASSERT(pInfo);
                    if (pInfo == NULL)
                    {
                        break;
                    }
                    fInvalid = VtKillActive( pInfo );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, fInvalid );
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}

BOOL
VtInit(
    IN HWND   hwndPage )
    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    AIINFO * pInfo;

    // Get the context
    pInfo = AiContext( hwndPage );
    ASSERT ( pInfo );
    if (pInfo == NULL)
    {
        return FALSE;
    }
    
    // Initialize the checks
    pInfo->hwndVtRbAutomatic = GetDlgItem( hwndPage, CID_VT_RB_Automatic );
    pInfo->hwndVtRbPptp = GetDlgItem( hwndPage, CID_VT_RB_Pptp );
    pInfo->hwndVtRbL2tp = GetDlgItem( hwndPage, CID_VT_RB_L2tp );
    ASSERT( pInfo->hwndVtRbAutomatic );
    ASSERT( pInfo->hwndVtRbPptp );
    ASSERT( pInfo->hwndVtRbL2tp );

    // Default to automatic
    Button_SetCheck( pInfo->hwndVtRbAutomatic, TRUE );     
    
    return FALSE;
}

BOOL
VtKillActive(
    IN AIINFO* pInfo )

    /* Called when PSN_KILLACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true if the page is invalid, false is it can be dismissed.
    */
{
    if ( Button_GetCheck( pInfo->hwndVtRbAutomatic ) )
    {
        pInfo->dwVpnStrategy = VS_Default;
    }

    else if ( Button_GetCheck( pInfo->hwndVtRbPptp ) )
    {
        pInfo->dwVpnStrategy = VS_PptpOnly;
    }
    
    else if ( Button_GetCheck( pInfo->hwndVtRbL2tp ) )
    {
        pInfo->dwVpnStrategy = VS_L2tpOnly;
    }
    
    return FALSE;
}

BOOL
VtSetActive(
    IN AIINFO* pInfo )

    /* Called when PSN_SETACTIVE is received.  'PInfo' is the wizard context.
    **
    ** Returns true to display the page, false to skip it.
    */
{
    // If we're focused on an nt4 box, then this page is 
    // invalid (pptp was the only type)
    if ( pInfo->pArgs->fNt4Router )
    {
        return FALSE;
    }

    // If we have no tunnel devices, then this page is invalid
    else if ( ! (pInfo->dwFlags & AI_F_HasTunlDevs) )
    {
        return FALSE;
    }

    // If the connection type is not virtual, skip this page since the
    // destination will be gotten from the phone number page.
    if ( pInfo->pArgs->pEntry->dwType != RASET_Vpn )
    {
        return FALSE;
    }            

    PropSheet_SetWizButtons( pInfo->hwndDlg, PSWIZB_BACK | PSWIZB_NEXT );
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\ipsecpolicy.c ===
// Copyright (c) 2000, Microsoft Corporation, all rights reserved
//
// IPSecPolicy.c
// Remote Access Common Dialog APIs
// IPSecPolicy dialogs
//
// 10/04/2000 Gang Zhao
//


#include "rasdlgp.h"
#include <rasauth.h>
#include <rrascfg.h>
#include <ras.h>
#include <mprapi.h>
#include <mprerror.h>

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwCiHelp[] =
{
    CID_CI_CB_PresharedKey,         HID_CI_CB_PresharedKey,
    CID_CI_ST_Key,                  HID_CI_EB_PSK,
    CID_CI_EB_PSK,                  HID_CI_EB_PSK,
    0, 0
};

//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------
typedef struct
_CIARGS
{
    EINFO * pEinfo;

}
CIARGS;

typedef struct
_CIINFO
{
    //Caller's arguments to the dialog
    //
    CIARGS * pArgs;

    //Handles of this dialog and some of its controls
    //for PSK
    HWND hwndDlg;
    HWND hwndCbPresharedKey;
    HWND hwndStKey;
    HWND hwndEbPSK;

    //for User certs
    //
    HWND hwndCbUserCerts;

    //for specific certs
    //
    HWND hwndCbSpecificCerts;
    HWND hwndPbSelect;
    HWND hwndLbCertsList;
    
}
CIINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------
BOOL
CiCommand(
    IN CIINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CiDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CiInit(
    IN HWND hwndDlg,
    IN CIARGS* pArgs );

VOID
CiTerm(
    IN HWND hwndDlg );

BOOL
CiSave(
    IN CIINFO* pInfo );

//
// Add new features for whistler bug 193987
// Pop Up a Dialog box for IPSec Policy
// currently just Pre-shared key/L2TP, and will have Certificates/L2TP in the future
//

BOOL
IPSecPolicyDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs )
{
    INT_PTR nStatus;
    CIARGS args;

    TRACE( "IPSecPolicyDlg" );

    args.pEinfo = pArgs;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CI_CustomIPSec ),
            hwndOwner,
            CiDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}//end of IPSecPolicyDlg()


INT_PTR CALLBACK
CiDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Custom IPSecPolicy dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CiDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CiInit( hwnd, (CIARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCiHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            CIINFO* pInfo = (CIINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return CiCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CiTerm( hwnd );
            break;
        }
    }

    return FALSE;
}//end of CiDlgProc()


BOOL
CiInit(
    IN HWND hwndDlg,
    IN CIARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DWORD dwAr;
    CIINFO* pInfo;

    TRACE( "CiInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndCbPresharedKey = GetDlgItem( hwndDlg, CID_CI_CB_PresharedKey );
    ASSERT(pInfo->hwndCbPresharedKey);
    pInfo->hwndStKey = GetDlgItem( hwndDlg, CID_CI_ST_Key );
    ASSERT(pInfo->hwndStKey);
    pInfo->hwndEbPSK = GetDlgItem( hwndDlg, CID_CI_EB_PSK );
    ASSERT(pInfo->hwndEbPSK);
    pInfo->hwndCbUserCerts = GetDlgItem( hwndDlg, CID_CI_CB_UserCerts );
    ASSERT(pInfo->hwndCbUserCerts);
    pInfo->hwndCbSpecificCerts = GetDlgItem( hwndDlg, CID_CI_CB_SpecificCerts );
    ASSERT(pInfo->hwndCbSpecificCerts);
    pInfo->hwndPbSelect = GetDlgItem( hwndDlg, CID_CI_PB_Select );
    ASSERT(pInfo->hwndPbSelect);
    pInfo->hwndLbCertsList = GetDlgItem( hwndDlg, CID_CI_LB_CertsList );
    ASSERT(pInfo->hwndLbCertsList);

    //Hide the User certs and Specific certs until the whistler server
    ShowWindow( pInfo->hwndCbUserCerts, SW_HIDE );
    ShowWindow( pInfo->hwndCbSpecificCerts, SW_HIDE );
    ShowWindow( pInfo->hwndPbSelect, SW_HIDE );
    ShowWindow( pInfo->hwndLbCertsList, SW_HIDE );

   // Fill the EAP packages listbox and select the previously identified
   // selection.  The Properties button is disabled by default, but may
   // be enabled when the EAP list selection is set.
   //
    {
        BOOL fEnabled;

        fEnabled = !!((pArgs->pEinfo->pEntry->dwIpSecFlags)& AR_F_IpSecPSK) ;

        Button_SetCheck( pInfo->hwndCbPresharedKey, fEnabled );

        EnableWindow( pInfo->hwndStKey, fEnabled );
        EnableWindow( pInfo->hwndEbPSK, fEnabled );
        Edit_LimitText( pInfo->hwndEbPSK, PWLEN );  //Limit the length of PSK
    }

    //
    //Fill the Preshared Key in "*"s or just leave it bland if none 
    //is saved previously
    //
    //for Demand Dial, use MprAdmin.... router functions
    //
    if (pArgs->pEinfo->fRouter) 
    {
        if( !(pArgs->pEinfo->fPSKCached) )
        {
            // Initialize the interface-information structure.
            //
           DWORD dwErr;
           HANDLE hServer = NULL;
           HANDLE hInterface = NULL;
           WCHAR* pwszInterface = NULL;
           WCHAR pszComputer[512];
           MPR_INTERFACE_0 mi0;
           MPR_CREDENTIALSEX_1 * pMc1 = NULL;

           dwErr = NO_ERROR;
           do {
                dwErr = g_pMprAdminServerConnect(pArgs->pEinfo->pszRouter, &hServer);

                if (dwErr != NO_ERROR)
                {
                    TRACE("CiInit: MprAdminServerConnect failed!");
                    break;
                }

                ZeroMemory( &mi0, sizeof(mi0) );

                mi0.dwIfType = ROUTER_IF_TYPE_FULL_ROUTER;
                mi0.fEnabled = TRUE;

                pwszInterface = StrDupWFromT( pArgs->pEinfo->pEntry->pszEntryName );
                if (!pwszInterface)
                {
                    TRACE("CiInit:pwszInterface conversion failed!");
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                lstrcpynW( 
                    mi0.wszInterfaceName, 
                    pwszInterface, 
                    MAX_INTERFACE_NAME_LEN+1 );

                // Get the interface handle
                //
                ASSERT( g_pMprAdminInterfaceGetHandle );
                dwErr = g_pMprAdminInterfaceGetHandle(
                            hServer,
                            pwszInterface,
                            &hInterface,
                            FALSE);

                if (dwErr)
                {
                    TRACE1( "CiInit: MprAdminInterfaceGetHandle error %d", dwErr);
                    break;
                }

                //Get the IPSec Policy keys(PSK for Whislter)
                //
                ASSERT( g_pMprAdminInterfaceGetCredentialsEx );
                dwErr = g_pMprAdminInterfaceGetCredentialsEx(
                            hServer,
                            hInterface,
                            1,
                            (LPBYTE *)&pMc1 );
                 if(dwErr)
                {
                    TRACE1(
                     "CiInit: MprAdminInterfaceGetCredentialsEx error %d", dwErr);
                    break;
                }

                if ( !pMc1 )
                {
                    TRACE(
                     "CiInit: MprAdminInterfaceGetCredentialsEx returns invalid credential pointer!");

                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
                else
                {
                    if ( lstrlenA( pMc1->lpbCredentialsInfo ) >0 )
                    {
                        SetWindowText( pInfo->hwndEbPSK,TEXT("****************") );

                        // Whistler bug 254385 encode password when not being used
                        // Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
                        //
                        ZeroMemory(
                            pMc1->lpbCredentialsInfo,
                            lstrlenA(pMc1->lpbCredentialsInfo) + 1 );
                    }
                    else
                    {
                        SetWindowText( pInfo->hwndEbPSK,TEXT("") );
                    }

                    ASSERT( g_pMprAdminBufferFree );
                    g_pMprAdminBufferFree( pMc1 );
                }

               }
               while (FALSE) ;

            // Cleanup
            {
                // If some operation failed, restore the router to the
                // state it was previously in.
                if ( dwErr != NO_ERROR )
                {
                    SetWindowText( pInfo->hwndEbPSK, TEXT("") );
                }

                // Close all handles, free all strings.
                if ( pwszInterface )
                {
                    Free0( pwszInterface );
                }

                if (hServer)
                {
                    g_pMprAdminServerDisconnect( hServer );
                }
            }
        }
        else
        {
            SetWindowText( pInfo->hwndEbPSK,TEXT("****************") );// pArgs->pEinfo->szPSK ); //
        }

    }
    else    //retrieve the credentials with Ras functions
    {
        // Look up cached PSK, from RASMAN or EINFO
        //
        if( !(pArgs->pEinfo->fPSKCached) )
        {
            DWORD dwErrRc;
            RASCREDENTIALS rc;

            ZeroMemory( &rc, sizeof(rc) );
            rc.dwSize = sizeof(rc);
            rc.dwMask = RASCM_PreSharedKey; 
            ASSERT( g_pRasGetCredentials );
            TRACE( "RasGetCredentials" );
            dwErrRc = g_pRasGetCredentials(
                pInfo->pArgs->pEinfo->pFile->pszPath, 
                pInfo->pArgs->pEinfo->pEntry->pszEntryName, 
                &rc );

            TRACE2( "RasGetCredentials=%d,m=%d", dwErrRc, rc.dwMask );

            if (dwErrRc == 0 && (rc.dwMask & RASCM_PreSharedKey) && ( lstrlen(rc.szPassword) > 0 ) )
            {
                SetWindowText( pInfo->hwndEbPSK, TEXT("****************") );
            }
            else
            {
                SetWindowText( pInfo->hwndEbPSK,TEXT("") );
            }

            // Whistler bug 254385 encode password when not being used
            //
            ZeroMemory( rc.szPassword, sizeof(rc.szPassword) );
        }
        else
        {
            SetWindowText( pInfo->hwndEbPSK,TEXT("****************") );// pArgs->pEinfo->szPSK ); //
        }

    }
    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    SetFocus( pInfo->hwndEbPSK );

    return TRUE;
} //end of CiInit()


BOOL
CiCommand(
    IN CIINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CiCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_CI_EB_PSK:
        {
            return TRUE;
        }

        case CID_CI_CB_PresharedKey:
        {
            BOOL fEnabled;
            
            fEnabled = Button_GetCheck( pInfo->hwndCbPresharedKey );
            EnableWindow( pInfo->hwndStKey, fEnabled );
            EnableWindow( pInfo->hwndEbPSK, fEnabled );
        }
        break;

        case IDOK:
        {
            if (CiSave( pInfo ))
            {
                EndDialog( pInfo->hwndDlg, TRUE );
            }
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}//end of CiCommand()

BOOL
CiSave(
    IN CIINFO* pInfo )

    // Saves control contents to caller's PBENTRY argument.  'PInfo' is the
    // dialog context.
    //
    // Returns TRUE if successful or false if invalid combination of
    // selections was detected and reported.
    //
{
        TCHAR szPSK[PWLEN + 1];
        BOOL  fPskChecked = FALSE;

        fPskChecked = Button_GetCheck( pInfo->hwndCbPresharedKey );
        
        if ( fPskChecked )
        {
            GetWindowText( pInfo->hwndEbPSK, szPSK, PWLEN+1 );
        
            if ( lstrlen( szPSK ) == 0  )
            {
                MsgDlgUtil( pInfo->hwndDlg, SID_HavetoEnterPSK, NULL, g_hinstDll, SID_PopupTitle );
                return FALSE;
            }
            else if (!lstrcmp( szPSK, TEXT("****************")) )  //16 "*" means no change
            {
                ; 
            }
            else    //save PSK to EINFO and mark the fPSKCached
            {
                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                // Whistler bug 254385 encode password when not being used
                // Assumed password was not encoded by GetWindowText()
                //
                lstrcpyn(
                    pInfo->pArgs->pEinfo->szPSK,
                    szPSK,
                    sizeof(pInfo->pArgs->pEinfo->szPSK) / sizeof(TCHAR) );
                EncodePassword( pInfo->pArgs->pEinfo->szPSK );
                pInfo->pArgs->pEinfo->fPSKCached = TRUE;
            }
        }
        else
        {
                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                lstrcpyn(
                    pInfo->pArgs->pEinfo->szPSK,
                    TEXT(""),
                    sizeof(pInfo->pArgs->pEinfo->szPSK) / sizeof(TCHAR) );
                pInfo->pArgs->pEinfo->fPSKCached = FALSE;
        }

        // Whistler bug 254385 encode password when not being used
        //
        ZeroMemory( szPSK, sizeof(szPSK) );

        //Change the value of dwIpSecFlags only along with a valid operation
        //
        pInfo->pArgs->pEinfo->pEntry->dwIpSecFlags = fPskChecked?AR_F_IpSecPSK : 0;

    return TRUE;
}//end of CiSave()


VOID
CiTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    CIINFO* pInfo;

    TRACE( "CiTerm" );

    pInfo = (CIINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}//end of CiTerm()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\main.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// main.c
// Remote Access Common Dialog APIs
// Main routines
//
// 06/20/95 Steve Cobb


#include "rasdlgp.h"
#include "treelist.h" // for TL_Init: RasMonitorDlg only
#define INCL_ENCRYPT
#include <rassrvp.h>  // [pmay] private header merges this project with ras server ui

//-----------------------------------------------------------------------------
// Rasdlg globals
//-----------------------------------------------------------------------------

// IMPORTANT: No globals may be defined that do not work properly when the DLL
//            is called by multiple threads within a single process.
//

// Handle of the DLL instance set from the corresponding LibMain parameter.
//
HINSTANCE g_hinstDll = NULL;

// The atom identifying our context property suitable for use by the Windows
// XxxProp APIs.  A Prop is used to associate context information with a
// property sheet.  The atom is registered in LibMain.
//
LPCTSTR g_contextId = NULL;

// The handle of the RAS wizard bitmap.  This is needed only because
// DLGEDIT.EXE is currently unable to produce the RC syntax necessary to
// create a self-contained SS_BITMAP control, so the image must be set at
// run-time.  See also SetWizardBitmap().
//
HBITMAP g_hbmWizard = NULL;

// The name of the on-line help file.  Initialized in LibMain.
//
TCHAR* g_pszHelpFile = NULL;

// The name of the on-line ROUTER help file.  Initialized in LibMain.
//
TCHAR* g_pszRouterHelpFile = NULL;

// Count of RasDial callbacks active and the flag telling the dialer to
// terminate them ASAP, plus the mutex that protects these fields.
//
HANDLE g_hmutexCallbacks = NULL;
LONG g_ulCallbacksActive = 0L;   //Change this for whistler bug 341662   gangz
BOOL g_fTerminateAsap = FALSE;

// ----------------------------------------------------------------------------
// Rasdlg DLL entrypoint
// ----------------------------------------------------------------------------

BOOL
LibMain(
    HANDLE hinstDll,
    DWORD fdwReason,
    LPVOID lpReserved )

    // This routine is called by the system on various events such as the
    // process attachment and detachment.  See Win32 DllEntryPoint
    // documentation.
    //
    // Returns true if successful, false otherwise.
    //
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // Initialize trace and assert support.
        //
        DEBUGINIT( "RASDLG" );

        // Initialize fusion
        // For whistler bug 349866
        //
         SHFusionInitializeFromModuleID(hinstDll, 128);


        // Stash the DLL instance handle for use in the dialog/window calls
        // later.
        //
        g_hinstDll = hinstDll;

        // Register the context ID atom for use in the Windows XxxProp calls
        // which are used to associate a context with a dialog window handle.
        //
        g_contextId = (LPCTSTR )GlobalAddAtom( TEXT("RASDLG") );
        if (!g_contextId)
            return FALSE;

        // Initialize the TreeList custom control
        //
        TL_Init( hinstDll );

        // Load the name of our on-line help file.
        //
        g_pszHelpFile = PszFromId( hinstDll, SID_HelpFile );

        // Load the name of our on-line help file.
        //
        g_pszRouterHelpFile = PszFromId( hinstDll, SID_RouterHelpFile );

        // Initialize the Phonebook library.
        //
        if (InitializePbk() != 0)
        {
            return FALSE;
        }

        // Mutex protecting count of active RasDial callbacks.
        //
        if (!(g_hmutexCallbacks = CreateMutex( NULL, FALSE, NULL )))
        {
            return FALSE;
        }

        // [pmay] Allow the ras server ui to initialize
        RassrvHandleProcessAttach(hinstDll, lpReserved);
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        // [pmay] Allow the ras server ui to cleanup
        RassrvHandleProcessDetach(hinstDll, lpReserved);

        // Remove the context ID atom we registered at initialization.
        //
        GlobalDeleteAtom( LOWORD( g_contextId ) );

        // Unload the wizard bitmap.
        //
        if (g_hbmWizard)
            DeleteObject( (HGDIOBJ )g_hbmWizard );

        // Free the on-line help file string.
        //
        Free0( g_pszHelpFile );
        Free0( g_pszRouterHelpFile );

        /* Uninitialize the Phonebook library.
        */
        TerminatePbk();

        if (g_hmutexCallbacks)
        {
            CloseHandle( g_hmutexCallbacks );
        }

        /* Unload dynamically loaded DLLs, if any.
        */
        UnloadRas();

        //For whistler bug 349866
        //
        SHFusionUninitialize();


        /* Terminate trace and assert support.
        */
        DEBUGTERM();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\nwc.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// nwc.c
// Remote Access Common Dialog APIs
// NetWare Compatible warning dialog
//
// 12/06/95 Steve Cobb


#include "rasdlgp.h"


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// NetWare Compatible warning dialog argument block.
//
typedef struct
_NWARGS
{
    // Caller's  arguments to the stub API.
    //
    BOOL fPosition;
    LONG xDlg;
    LONG yDlg;
    PBFILE* pFile;
    PBENTRY* pEntry;
}
NWARGS;


// NetWare Compatible warning dialog context block.
//
typedef struct
_NWINFO
{
    // Stub API arguments.
    //
    NWARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndCb;
}
NWINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
NwConnectionDlg(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry );

INT_PTR CALLBACK
NwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
NwCommand(
    IN NWINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

BOOL
NwInit(
    IN HWND hwndDlg,
    IN NWARGS* pArgs );

VOID
NwTerm(
    IN HWND hwndDlg );

TCHAR*
GetNwProviderName(
    void );

BOOL
IsActiveNwLanConnection(
    void );


//----------------------------------------------------------------------------
// Entry point
//----------------------------------------------------------------------------

BOOL
NwConnectionCheck(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry )

    // Warns about active NetWare LAN connections being blown away, if
    // indicated.  'HwndOwner' is the owning window if a dialog is necessary.
    // 'FPosition', 'xDlg', and 'yDlg' are the dialog positioning parameters
    // as specified to the calling API.  'PFile' and 'pEntry' are the open
    // phonebook file and entry to check.
    //
    // Note: This call will write the phonebook file if user checks the "not
    //       in the future" checkbox.
    //
    // Returns true if warning is not necessary or user pressed OK, false if
    // user presses cancel.
    //
{
    TRACE("NwConnectionCheck");

    // Warn about active NetWare LAN connections being blown away, if
    // indicated.
    //
    if (!pEntry->fSkipNwcWarning
        && pEntry->dwBaseProtocol == BP_Ppp
        && (g_pGetInstalledProtocolsEx(NULL, FALSE, TRUE, FALSE) & NP_Ipx)
        && !(pEntry->dwfExcludedProtocols & NP_Ipx)
        && IsActiveNwLanConnection())
    {
        if (!NwConnectionDlg(
                hwndOwner, fPosition, xDlg, yDlg, pFile, pEntry ))
        {
            return FALSE;
        }
    }

    return TRUE;
}


//----------------------------------------------------------------------------
// Netware dialog routines (alphabetically following stub and DlgProc)
//----------------------------------------------------------------------------

BOOL
NwConnectionDlg(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry )

    // Pops up a warning about active NWC LAN connections being blown away.
    // 'HwndOwner' is the owning window if a dialog is necessary.
    // 'FPosition', 'xDlg', and 'yDlg' are the dialog positioning parameters
    // as specified to the calling API.  'PFile' and 'pEntry' are the open
    // phonebook file and entry to check.
    //
    // Note: This call will write the phonebook file if user checks the "not
    //       in the future" checkbox.
    //
    // Returns true if user pressed OK, false if user presses cancel.
    //
{
    INT_PTR nStatus;
    NWARGS args;

    TRACE( "NwConnectionDlg" );

    // Initialize dialog argument block.
    //
    args.fPosition = fPosition;
    args.xDlg = xDlg;
    args.yDlg = yDlg;
    args.pFile = pFile;
    args.pEntry = pEntry;

    // Run the dialog.
    //
    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_NW_NwcConnections ),
            hwndOwner,
            NwDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
NwDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Netware warning dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "NwDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return NwInit( hwnd, (NWARGS* )lparam );
        }

        case WM_COMMAND:
        {
            NWINFO* pInfo = (NWINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return NwCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            NwTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
NwCommand(
    IN NWINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "NwCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            TRACE( "OK pressed" );

            if (Button_GetCheck( pInfo->hwndCb ))
            {
                DWORD dwErr;

                // Save user's preference to skip this warning popup in the
                // phonebook.
                //
                pInfo->pArgs->pEntry->fSkipNwcWarning = TRUE;
                pInfo->pArgs->pEntry->fDirty = TRUE;
                dwErr = WritePhonebookFile( pInfo->pArgs->pFile, NULL );
                if (dwErr != 0)
                {
                    ErrorDlg( pInfo->hwndDlg, SID_OP_WritePhonebook,
                        dwErr, NULL );
                }
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
NwInit(
    IN HWND hwndDlg,
    IN NWARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PArgs' is caller's arguments as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    TCHAR* psz;
    NWINFO* pInfo;

    TRACE( "NwInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndCb = GetDlgItem( hwndDlg, CID_NW_CB_SkipPopup );
    ASSERT( pInfo->hwndCb );

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg, pArgs->fPosition, pArgs->xDlg, pArgs->yDlg );
    SetForegroundWindow( hwndDlg );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
NwTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    NWINFO* pInfo = (NWINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "NwTerm" );

    if (pInfo)
    {
        Free( pInfo );
    }
}


//----------------------------------------------------------------------------
// Utility routines
//----------------------------------------------------------------------------

TCHAR*
GetNwProviderName(
    void )

    // Returns the NWC provider name from the registry or NULL if none.  It's
    // caller's responsibility to Free the returned string.
    //
{
#define REGKEY_Nwc  TEXT("SYSTEM\\CurrentControlSet\\Services\\NWCWorkstation\\networkprovider")
#define REGVAL_Name TEXT("Name")

    HKEY hkey;
    DWORD dwErr;
    DWORD cb = 0;	//Add this for prefix whislter bug 295921
    TCHAR* psz = NULL;
    DWORD dwType = REG_SZ;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_Nwc, &hkey );

    if (dwErr == 0)
    {
        dwErr = RegQueryValueEx(
            hkey, REGVAL_Name, NULL, &dwType, NULL, &cb );
        if (dwErr == 0)
        {
            psz = (TCHAR* )Malloc( cb );
            if (psz)
            {
                dwErr = RegQueryValueEx(
                    hkey, REGVAL_Name, NULL, &dwType, (LPBYTE )psz, &cb );
            }
        }

        RegCloseKey( hkey );
    }

    if (!psz || dwErr != 0 || dwType != REG_SZ)
    {
        if (psz)
        {
            Free( psz );
        }
        return NULL;
    }

    return psz;
}


BOOL
IsActiveNwLanConnection(
    void )

    // Returns true if NWC is installed and there are redirected drive or UNC
    // connections using NWC provider, false otherwise.
    //
{
    DWORD dwErr;
    DWORD cEntries;
    DWORD cb;
    TCHAR* pszProvider;
    BYTE ab[ 1024 ];
    HANDLE hEnum = INVALID_HANDLE_VALUE;
    BOOL fStatus = FALSE;

    do
    {
        pszProvider = GetNwProviderName();
        if (!pszProvider)
        {
            break;
        }

        dwErr = WNetOpenEnum(
            RESOURCE_CONNECTED, RESOURCETYPE_ANY, 0, NULL, &hEnum );
        if (dwErr != NO_ERROR)
        {
            break;
        }

        for (;;)
        {
            NETRESOURCE* pnr;

            cEntries = 0xFFFFFFFF;
            cb = sizeof(ab);
            dwErr = WNetEnumResource( hEnum, &cEntries, ab, &cb );
            if (!cEntries || dwErr != NO_ERROR)
            {
                break;
            }

            for (pnr = (NETRESOURCE* )ab; cEntries--; ++pnr)
            {
                if (pnr->lpProvider
                    && lstrcmp( pnr->lpProvider, pszProvider ) == 0)
                {
                    fStatus = TRUE;
                    break;
                }
            }
        }
    }
    while (FALSE);

    if (hEnum != INVALID_HANDLE_VALUE)
    {
        WNetCloseEnum( hEnum );
    }

    if (pszProvider)
    {
        Free( pszProvider );
    }

    return fStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\pbook.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// pbook.c
// Remote Access Common Dialog APIs
// RasPhonebookDlg APIs
//
// 06/20/95 Steve Cobb


#include "rasdlgp.h" // Our private header
#include <commdlg.h> // FileOpen dialog
#include <dlgs.h>    // Common dialog resource constants
#include <rnk.h>     // Shortcut file library

#define WM_RASEVENT      (WM_USER+987)
#define WM_NOUSERTIMEOUT (WM_USER+988)

#define RAS_SC_IS_BAD_PIN(_err) \
    (((_err) == SCARD_W_WRONG_CHV) || ((_err) == SCARD_E_INVALID_CHV))

// In no-user mode this is updated on every mouse or keyboard event by our
// window hook.  The monitor thread notices and resets it's inactivity
// timeout.
//
DWORD g_cInput = 0;


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwDuHelp[] =
{
    CID_DU_ST_Entries,     HID_DU_LB_Entries,
    CID_DU_LB_Entries,     HID_DU_LB_Entries,
    CID_DU_PB_New,         HID_DU_PB_New,
    CID_DU_PB_More,        HID_DU_PB_More,
    CID_DU_PB_Dial,        HID_DU_PB_Dial,
    CID_DU_PB_Close,       HID_DU_PB_Close,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Phonebook dialog argument block.
//
typedef struct
_DUARGS
{
    // Caller's  arguments to the RAS API.  Outputs in 'pApiArgs' are visible
    // to the API which has the address of same.  'PszPhonebook' is updated if
    // user changes the phonebook on the Preferences->PhoneList page, though
    // API is unaware of this.
    //
    LPTSTR pszPhonebook;
    LPTSTR pszEntry;
    RASPBDLG* pApiArgs;

    // RAS API return value.  Set true if a connection is established within
    // the dialog.
    //
    BOOL fApiResult;
}
DUARGS;

typedef struct
_DUCONTEXT
{
    LPTSTR  pszPhonebookPath;
    PBENTRY *pEntry;
}
DUCONTEXT;


// Dial-Up Networking dialog context block.
//
typedef struct
_DUINFO
{
    // Caller's arguments to the RAS API.
    //
    DUARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndPbNew;
    HWND hwndPbProperties;
    HWND hwndLbEntries;
    HWND hwndPbDial;

    // Global user preference settings read from the Registry.
    //
    PBUSER user;

    // Phonebook settings read from the phonebook file.
    //
    PBFILE file;

    // No logged on user information retrieved via callback.
    //
    RASNOUSER* pNoUser;

    // Set if in "no user before logon" mode.  Always the same as the
    // RASPBDFLAG but here for convenience.
    //
    BOOL fNoUser;

    // Window hooks used to detect user input in the thread.  Used only when
    // 'fNoUser' is set.
    //
    HHOOK hhookKeyboard;
    HHOOK hhookMouse;

    // TAPI session handle.
    //
    HLINEAPP hlineapp;

    // Handle of the RAS connection associated with the current entry or NULL
    // if none.
    //
    HRASCONN hrasconn;

    // Connect monitor objects.
    //
    HANDLE hThread;
    HANDLE hEvent;
    BOOL fAbortMonitor;
}
DUINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
DuCommand(
    IN DUINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

VOID
DuCreateShortcut(
    IN DUINFO* pInfo );

LRESULT CALLBACK
DuCreateShortcutCallWndRetProc(
    int code,
    WPARAM wparam,
    LPARAM lparam );

INT_PTR CALLBACK
DuDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DuDeleteSelectedEntry(
    IN DUINFO* pInfo );

VOID
DuDialSelectedEntry(
    IN DUINFO* pInfo );

VOID
DuEditSelectedEntry(
    IN DUINFO* pInfo );

VOID
DuEditSelectedLocation(
    IN DUINFO* pInfo );

DWORD
DuFillLocationList(
    IN DUINFO* pInfo );

VOID
DuFillPreview(
    IN DUINFO* pInfo );

DWORD
DuGetEntry(
    DUINFO* pInfo,
    DUCONTEXT* pContext );

TCHAR*
DuGetPreview(
    IN DUINFO* pInfo );

DWORD
DuHandleConnectFailure(
    IN DUINFO* pInfo,
    IN RASDIALDLG* pDialInfo);
    
VOID
DuHangUpSelectedEntry(
    IN DUINFO* pInfo );

BOOL
DuInit(
    IN HWND    hwndDlg,
    IN DUARGS* pArgs );

LRESULT CALLBACK
DuInputHook(
    IN int nCode,
    IN WPARAM wparam,
    IN LPARAM lparam );

LRESULT APIENTRY
DuLbEntriesProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DuLocationChange(
    IN DUINFO* pInfo );

DWORD
DuMonitorThread(
    LPVOID pThreadArg );

VOID
DuNewEntry(
    IN DUINFO* pInfo,
    IN BOOL fClone );

VOID
DuOperatorDial(
    IN DUINFO* pInfo );

LRESULT APIENTRY
DuPbMoreProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
DuPopupMoreMenu(
    IN DUINFO* pInfo );

VOID
DuPreferences(
    IN DUINFO* pInfo,
    IN BOOL fLogon );

VOID
DuSetup(
    IN DUINFO* pInfo );

VOID
DuStatus(
    IN DUINFO* pInfo );

VOID
DuTerm(
    IN HWND hwndDlg );

VOID
DuUpdateConnectStatus(
    IN DUINFO* pInfo );

VOID
DuUpdateLbEntries(
    IN DUINFO* pInfo,
    IN TCHAR* pszEntry );

VOID
DuUpdatePreviewAndLocationState(
    IN DUINFO* pInfo );

VOID
DuUpdateTitle(
    IN DUINFO* pInfo );

VOID
DuWriteShortcutFile(
    IN HWND hwnd,
    IN TCHAR* pszRnkPath,
    IN TCHAR* pszPbkPath,
    IN TCHAR* pszEntry );

DWORD
DwGetEapLogonInfo(
    VOID *pv,
    EAPLOGONINFO **ppEapLogonInfo );

VOID WINAPI
RasPbDlgCallbackThunk(
    ULONG_PTR ulpId,
    DWORD dwEvent,
    LPWSTR pszEntry,
    LPVOID pArgs );


//----------------------------------------------------------------------------
// External entry points
//----------------------------------------------------------------------------

BOOL APIENTRY
RasPhonebookDlgA(
    IN LPSTR lpszPhonebook,
    IN LPSTR lpszEntry,
    IN OUT LPRASPBDLGA lpInfo )

    // Win32 ANSI entrypoint that displays the Dial-Up Networking dialog, i.e.
    // the RAS phonebook.  'LpszPhonebook' is the full path the phonebook or
    // NULL indicating the default phonebook.  'LpszEntry' is the entry to
    // highlight on entry or NULL to highlight the first entry in the list.
    // 'LpInfo' is caller's additional input/output parameters.
    //
    // Returns true if user establishes a connection, false otherwise.
    //
{
    WCHAR* pszPhonebookW;
    WCHAR* pszEntryW;
    RASPBDLGW infoW;
    BOOL fStatus;

    TRACE( "RasPhonebookDlgA" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASPBDLGA))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Thunk "A" arguments to "W" arguments.
    //
    if (lpszPhonebook)
    {
        pszPhonebookW = StrDupTFromAUsingAnsiEncoding( lpszPhonebook );
        if (!pszPhonebookW)
        {
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
        pszPhonebookW = NULL;
    }

    if (lpszEntry)
    {
        pszEntryW = StrDupTFromAUsingAnsiEncoding( lpszEntry );
        if (!pszEntryW)
        {
            Free0( pszPhonebookW );
            lpInfo->dwError = ERROR_NOT_ENOUGH_MEMORY;
            return FALSE;
        }
    }
    else
    {
        pszEntryW = NULL;
    }

    // Take advantage of the structures currently having the same size and
    // layout.  Only the callback is different.
    //
    ASSERT( sizeof(RASPBDLGA) == sizeof(RASPBDLGW) );
    CopyMemory( &infoW, lpInfo, sizeof(infoW) );

    if (lpInfo->pCallback)
    {
        infoW.dwCallbackId = (ULONG_PTR)lpInfo;
        infoW.pCallback = RasPbDlgCallbackThunk;
    }

    infoW.reserved2 = lpInfo->reserved2;

    // Thunk to the equivalent "W" API.
    //
    fStatus = RasPhonebookDlgW( pszPhonebookW, pszEntryW, &infoW );

    Free0( pszPhonebookW );
    Free0( pszEntryW );

    return fStatus;
}


VOID WINAPI
RasPbDlgCallbackThunk(
    ULONG_PTR ulpId,
    DWORD dwEvent,
    LPWSTR pszEntry,
    LPVOID pArgs )

    // This thunks "W" callbacks to API caller's "A" callback.
    //
{
    CHAR* pszEntryA;
    VOID* pArgsA;
    RASPBDLGA* pInfo;
    RASNOUSERA nuA;

    if (dwEvent == RASPBDEVENT_NoUser || dwEvent == RASPBDEVENT_NoUserEdit)
    {
        RASNOUSERW* pnuW = (RASNOUSERW* )pArgs;
        ASSERT( pnuW );

        ZeroMemory( &nuA, sizeof(nuA) );
        nuA.dwSize = sizeof(nuA);
        nuA.dwFlags = pnuW->dwFlags;
        nuA.dwTimeoutMs = pnuW->dwTimeoutMs;

        StrCpyAFromW(nuA.szUserName, pnuW->szUserName, UNLEN + 1);
        StrCpyAFromW(nuA.szPassword, pnuW->szPassword, UNLEN + 1);
        StrCpyAFromW(nuA.szDomain, pnuW->szDomain, UNLEN + 1);
        
        pArgsA = &nuA;
    }
    else
    {
        pArgsA = NULL;
    }

    pszEntryA = StrDupAFromT( pszEntry );
    pInfo = (RASPBDLGA* )ulpId;
    pInfo->pCallback( pInfo->dwCallbackId, dwEvent, pszEntryA, pArgsA );
    Free0( pszEntryA );

    if (dwEvent == RASPBDEVENT_NoUser || dwEvent == RASPBDEVENT_NoUserEdit)
    {
        RASNOUSERW* pnuW = (RASNOUSERW* )pArgs;

        pnuW->dwFlags = nuA.dwFlags;
        pnuW->dwTimeoutMs = nuA.dwTimeoutMs;

        StrCpyWFromA(pnuW->szUserName, nuA.szUserName, UNLEN + 1);
        StrCpyWFromA(pnuW->szPassword, nuA.szPassword, UNLEN + 1);
        StrCpyWFromA(pnuW->szDomain, nuA.szDomain, UNLEN + 1);
        
        ZeroMemory( nuA.szPassword, PWLEN );
    }
}


BOOL APIENTRY
RasPhonebookDlgW(
    IN LPWSTR lpszPhonebook,
    IN LPWSTR lpszEntry,
    IN OUT LPRASPBDLGW lpInfo )

    // Win32 Unicode entrypoint that displays the Dial-Up Networking dialog,
    // i.e. the RAS phonebook.  'LpszPhonebook' is the full path the phonebook
    // or NULL indicating the default phonebook.  'LpszEntry' is the entry to
    // highlight on entry or NULL to highlight the first entry in the list.
    // 'LpInfo' is caller's additional input/output parameters.
    //
    // Returns true if user establishes a connection, false otherwise.
    //
{
    INT_PTR nStatus;
    DUARGS args;

    TRACE( "RasPhonebookDlgW" );

    if (!lpInfo)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (lpInfo->dwSize != sizeof(RASPBDLGW))
    {
        lpInfo->dwError = ERROR_INVALID_SIZE;
        return FALSE;
    }

    // Initialize OUT parameters.
    //
    lpInfo->dwError = 0;

    // Initialize dialog argument block.
    //
    args.pszPhonebook = lpszPhonebook;
    args.pszEntry = lpszEntry;
    args.pApiArgs = lpInfo;
    args.fApiResult = FALSE;


    // Run the dialog.
    //
    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DU_DialUpNetworking ),
            lpInfo->hwndOwner,
            DuDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( lpInfo->hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        lpInfo->dwError = ERROR_UNKNOWN;
        args.fApiResult = FALSE;
    }

    return args.fApiResult;
}


//----------------------------------------------------------------------------
// Dial-Up Networking dialog
// Listed alphabetically following dialog proc
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DuDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Dial-Up Networking dialog, i.e. the
    // phonebook dialog.  Parameters and return value are as described for
    // standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DuDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DuInit( hwnd, (DUARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDuHelp, hwnd, unMsg, wparam, lparam );
            return TRUE;
        }

        case WM_COMMAND:
        {
            DUINFO* pInfo = (DUINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return DuCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_RASEVENT:
        {
            DUINFO* pInfo = (DUINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            DuUpdateConnectStatus( pInfo );
            break;
        }

        case WM_NOUSERTIMEOUT:
        {
            DUINFO* pInfo;
            ULONG ulCallbacksActive;

            TRACE( "CancelOwnedWindows" );
            CancelOwnedWindows( hwnd );
            TRACE( "CancelOwnedWindows done" );

            ulCallbacksActive = CallbacksActive( 1, NULL );
            if (ulCallbacksActive > 0)
            {
                TRACE1( "NoUser timeout stall, n=%d", ulCallbacksActive );
                PostMessage( hwnd, WM_NOUSERTIMEOUT, wparam, lparam );
                return TRUE;
            }

            pInfo = (DUINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            if (pInfo)
            {
                pInfo->pArgs->pApiArgs->dwError = STATUS_TIMEOUT;
            }

            EndDialog( hwnd, TRUE );
            CallbacksActive( 0, NULL );
            break;
        }

        case WM_DESTROY:
        {
            DuTerm( hwnd );

            /*
            //We have to wait for Deonb to return us the IID_Dun1 icon
            //For whistler bug 372078 381099
            //Icon returned by GetCurrentIconEntryType() has to be destroyed
            {
                HICON hIcon=NULL;

                //hIcon = (HICON) GetWindowLongPtr(hwnd, GWLP_USERDATA);
                hIcon = GetProp( hwnd, TEXT("TweakTitleBar_Icon"));
                ASSERT(hIcon);
                if( hIcon )
                {
                    DestroyIcon(hIcon);
                }
                else
                {
                    TRACE("DuDlgProc:Destroy Icon failed");
                }
            }
            */
            break;
        }
    }

    return FALSE;
}


BOOL
DuCommand(
    IN DUINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "DuCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_DU_PB_Dial:
        {
            if (pInfo->hrasconn)
            {
                DuHangUpSelectedEntry( pInfo );
            }
            else
            {
                DuDialSelectedEntry( pInfo );
            }
            return TRUE;
        }

        case CID_DU_PB_New:
        {
            DuNewEntry( pInfo, FALSE );
            return TRUE;
        }

        case CID_DU_PB_More:
        {
            DuEditSelectedEntry( pInfo );
            return TRUE;
        }

        case CID_DU_LB_Entries:
        {
            if (wNotification == CBN_SELCHANGE)
            {
                PBENTRY *pEntry;
                DWORD  dwErr = SUCCESS;
                DUCONTEXT *pContext;

                pContext = (DUCONTEXT *)
                           ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries,
                                ComboBox_GetCurSel(pInfo->hwndLbEntries));

                ASSERT(NULL != pContext);

                if(NULL == pContext)
                {
                    return TRUE;
                }

                //
                // Update the phonebook information
                //
                dwErr = DuGetEntry(pInfo, pContext);

                if(ERROR_SUCCESS == dwErr)
                {
                    ComboBox_SetItemData(
                            pInfo->hwndLbEntries,
                            ComboBox_GetCurSel(pInfo->hwndLbEntries),
                            pContext);
                }
                else
                {
                    ComboBox_DeleteString(
                            pInfo->hwndLbEntries,
                            ComboBox_GetCurSel(pInfo->hwndLbEntries) );
                }

                DuUpdateConnectStatus( pInfo );
                return TRUE;
            }
            break;
        }

        case IDCANCEL:
        case CID_DU_PB_Close:
        {
            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }
    }

    return FALSE;
}
    
VOID
DuDialSelectedEntry(
    IN DUINFO* pInfo )

    // Called when user presses the "Dial" button.
    //
{
    DWORD dwErr;
    BOOL fConnected;
    BOOL fAutoLogon;
    TCHAR* pszEbNumber;
    TCHAR* pszEbPreview;
    TCHAR* pszOrgPreview;
    TCHAR* pszOverride;
    TCHAR* pszEntryName;
    RASDIALDLG info;
    INTERNALARGS iargs;
    PBENTRY* pEntry;
    DTLNODE *pdtlnode;
    PBFILE file;
    DUCONTEXT *pContext;

    TRACE( "DuDialSelectedEntry" );

    // Look up the selected entry.
    //
    pContext = (DUCONTEXT *) ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries,
                                ComboBox_GetCurSel(pInfo->hwndLbEntries));

    if (!pContext)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }

    pEntry = pContext->pEntry;

    if (!pEntry)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }


    pszOverride = NULL;
    pszOrgPreview = NULL;
    pszEbPreview = NULL;
    pszEbNumber = NULL;

    // Set up API argument block.
    //
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    // The secret hack to share information already loaded with the entry API.
    //
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = &pInfo->file;
    iargs.pUser = &pInfo->user;
    iargs.pNoUser = pInfo->pNoUser;
    iargs.fNoUser = pInfo->fNoUser;
    iargs.fForceCloseOnDial =
        (pInfo->pArgs->pApiArgs->dwFlags & RASPBDFLAG_ForceCloseOnDial);

    iargs.pvEapInfo = NULL;

    if(0 != pInfo->pArgs->pApiArgs->reserved2)
    {
        DWORD retcode;
        EAPLOGONINFO *pEapInfo = NULL;

        retcode = DwGetEapLogonInfo(
                    (VOID *) pInfo->pArgs->pApiArgs->reserved2,
                    &pEapInfo);

        if(SUCCESS == retcode)
        {
            iargs.pvEapInfo = (VOID *) pEapInfo;
        }
    }

    iargs.fMoveOwnerOffDesktop =
        (iargs.fForceCloseOnDial || pInfo->user.fCloseOnDial);
    info.reserved = (ULONG_PTR ) &iargs;

    // Call the Win32 API to run the connect status dialog.  Make a copy of
    // the entry name and auto-logon flag first, because RasDialDlg may
    // re-read the entry node to pick up RASAPI changes.
    //
    pszEntryName = StrDup( pEntry->pszEntryName );
    fAutoLogon = pEntry->fAutoLogon;

    TRACEW1( "RasDialDlg,o=\"%s\"", (pszOverride) ? pszOverride : TEXT("") );
    fConnected = RasDialDlg(
        pContext->pszPhonebookPath, pEntry->pszEntryName, pszOverride, &info );
    TRACE1( "RasDialDlg=%d", fConnected );

    Free0( pszEbPreview );
    Free0( pszOrgPreview );

    if(NULL != iargs.pvEapInfo)
    {
        Free0(iargs.pvEapInfo);
        iargs.pvEapInfo = NULL;
    }

    if (fConnected)
    {
        pInfo->pArgs->fApiResult = TRUE;

        if (pInfo->pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

            if (pInfo->pNoUser && iargs.fNoUserChanged && fAutoLogon)
            {
                // Whistler bug 254385 encode password when not being used
                // Need to Decode password before callback function
                // Assumed password was encoded previously by DuInit()
                //
                DecodePassword( pInfo->pNoUser->szPassword );
                TRACE( "Callback(NoUserEdit)" );
                pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                    RASPBDEVENT_NoUserEdit, NULL, pInfo->pNoUser );
                TRACE( "Callback(NoUserEdit) done" );
                EncodePassword( pInfo->pNoUser->szPassword );
            }

            TRACE( "Callback(DialEntry)" );
            pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                RASPBDEVENT_DialEntry, pszEntryName, NULL );
            TRACE( "Callback(DialEntry) done" );
        }

        if (pInfo->user.fCloseOnDial
            || (pInfo->pArgs->pApiArgs->dwFlags & RASPBDFLAG_ForceCloseOnDial))
        {
            EndDialog( pInfo->hwndDlg, TRUE );
        }
    }

    else
    {
        DuHandleConnectFailure(pInfo, &info);
    }

    if (pInfo->pNoUser && !pInfo->hThread)
    {
        TRACE( "Taking shortcut to exit" );
        return;
    }

    // Reload the list even if the Dial was cancelled as user may have changed
    // the current PBENTRY with the Properties button on the dialer which
    // commits changes even if user cancels the dial itself.  See bug 363710.
    //
    DuUpdateLbEntries( pInfo, pszEntryName );
    SetFocus( pInfo->hwndLbEntries );

    Free0( pszEntryName );
}


VOID
DuEditSelectedEntry(
    IN DUINFO* pInfo )

    // Called when user selects "Edit entry" from the menu.  'PInfo' is the
    // dialog context.  'PszEntry' is the name of the entry to edit.
    //
{
    BOOL fOk;
    RASENTRYDLG info;
    INTERNALARGS iargs;
    PBENTRY* pEntry;
    LPTSTR pszEntryName;
    DTLNODE *pdtlnode;
    PBFILE file;
    DWORD dwErr;
    DUCONTEXT *pContext;
    INT iSel;

    TRACE( "DuEditSelectedEntry" );

    // Look up the selected entry.
    //
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
    if (iSel < 0)
    {
        return;
    }

    pContext = (DUCONTEXT * )ComboBox_GetItemDataPtr(
        pInfo->hwndLbEntries, iSel );

    ASSERT(NULL != pContext);

    if(NULL == pContext)
    {
        return;
    }
    
    ASSERT(NULL != pContext->pszPhonebookPath);

    pEntry = pContext->pEntry;

    if (!pEntry)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }

    // Set up API argument block.
    //
    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    {
        RECT rect;

        info.dwFlags = RASEDFLAG_PositionDlg;
        GetWindowRect( pInfo->hwndDlg, &rect );
        info.xDlg = rect.left + DXSHEET;
        info.yDlg = rect.top + DYSHEET;
    }

    // The secret hack to share information already loaded with the entry API.
    //
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = &pInfo->file;
    iargs.pUser = &pInfo->user;
    iargs.pNoUser = pInfo->pNoUser;
    iargs.fNoUser = pInfo->fNoUser;
    info.reserved = (ULONG_PTR ) &iargs;

    // Call the Win32 API to run the entry property sheet.
    //
    TRACE( "RasEntryDlg" );
    fOk = RasEntryDlg(
              pContext->pszPhonebookPath, pEntry->pszEntryName, &info );
    TRACE1( "RasEntryDlg=%d", fOk );

    if (pInfo->pNoUser && !pInfo->hThread)
    {
        TRACE( "Taking shortcut to exit" );
        return;
    }

    if (fOk)
    {
        TRACEW1( "OK pressed,e=\"%s\"", info.szEntry );

        if (pInfo->pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

            TRACE( "Callback(EditEntry)" );
            pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                RASPBDEVENT_AddEntry, info.szEntry, NULL );
            TRACE( "Callback(EditEntry) done" );
        }

        DuUpdateLbEntries( pInfo, info.szEntry );
        SetFocus( pInfo->hwndLbEntries );
    }
    else
    {
        TRACE( "Cancel pressed or error" );
    }
}

// 
// Helper function called by DuDialSelectedEntry to handle errors
// returned from RasDialDlgW
//
DWORD
DuHandleConnectFailure(
    IN DUINFO* pInfo,
    IN RASDIALDLG* pDialInfo)
{
    TRACE3( 
        "DuHandleConnectFailure: nu=%x, r2=%x, de=%x",
        (pInfo->pNoUser),
        (pInfo->pArgs->pApiArgs->reserved2),
        (pDialInfo->dwError));
        
    // XP: 384968
    //
    // Handle the bad-PIN error from winlogon
    //
    // Normally, the smart card PIN is gotten by calling EAP-TLS's identity
    // api.  This API raises UI and validates the PIN entered.
    //
    // During winlogon, however, the smart card PIN is passed to us from GINA.
    // In this case it is not validated until we call EAP API's.  (actually, 
    // it's until we call the eap identity api with RAS_EAP_FLAG_LOGON.
    // This flag tells EAP not to raise any UI but instead to use the info 
    // passed from GINA)
    //
    // GINA is not able to validate the PIN itself because it does not call any
    // CAPI's directly.  Oh well.
    //
    // If RasDialDlg returns a bad pin error, then we should gracefully fail 
    // back to winlogon.
    //

    if ((pInfo->pNoUser)                        &&  // called by winlogon
        (pInfo->pArgs->pApiArgs->reserved2)     &&  // for smart card
        (RAS_SC_IS_BAD_PIN(pDialInfo->dwError)))    // but pin is bad
    {
        pInfo->pArgs->pApiArgs->dwError = pDialInfo->dwError;
        EndDialog( pInfo->hwndDlg, TRUE );
    }

    return NO_ERROR;
}

VOID
DuHangUpSelectedEntry(
    IN DUINFO* pInfo )

    // Hang up the selected entry after confirming with user.  'Pinfo' is the
    // dialog context block.
    //
{
    DWORD dwErr;
    PBENTRY* pEntry;
    INT iSel;
    INT nResponse;
    MSGARGS msgargs;
    LPTSTR pszEntryName;
    DTLNODE *pdtlnode;
    DUCONTEXT *pContext;

    TRACE( "DuHangUpSelectedEntry" );

    // Look up the selected entry.
    //
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
    ASSERT( iSel >= 0 );
    pContext = (DUCONTEXT * )ComboBox_GetItemDataPtr( pInfo->hwndLbEntries, iSel );

    ASSERT(NULL != pContext);
    
    if (!pContext)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }
    
    pEntry = pContext->pEntry;
    ASSERT( pEntry );

    if (!pEntry)
    {
        MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
        SetFocus( pInfo->hwndPbNew );
        return;
    }

    ZeroMemory( &msgargs, sizeof(msgargs) );
    msgargs.apszArgs[ 0 ] = pEntry->pszEntryName;
    msgargs.dwFlags = MB_YESNO | MB_ICONEXCLAMATION;
    nResponse = MsgDlg( pInfo->hwndDlg, SID_ConfirmHangUp, &msgargs );

    if (nResponse == IDYES)
    {
        ASSERT( g_pRasHangUp );
        TRACE( "RasHangUp" );
        dwErr = g_pRasHangUp( pInfo->hrasconn );
        TRACE1( "RasHangUp=%d", dwErr );
        if ( dwErr == ERROR_HANGUP_FAILED )
        {
            MsgDlg( pInfo->hwndDlg, SID_CantHangUpRouter, NULL );
        }
    }
}


BOOL
DuInit(
    IN HWND    hwndDlg,
    IN DUARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    // dialog window.  'pArgs' points at caller's arguments as passed to the
    // API (or thunk).
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DWORD dwThreadId;
    DWORD dwReadPbkFlags = 0;
    DUINFO* pInfo;

    TRACE( "DuInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            pArgs->pApiArgs->dwError = ERROR_NOT_ENOUGH_MEMORY;
            EndDialog( hwndDlg, TRUE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->file.hrasfile = -1;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->pArgs = pArgs;
    pInfo->hwndDlg = hwndDlg;

    // Position the dialog per caller's instructions.
    //
    PositionDlg( hwndDlg,
        pArgs->pApiArgs->dwFlags & RASPBDFLAG_PositionDlg,
        pArgs->pApiArgs->xDlg, pArgs->pApiArgs->yDlg );

    // Load RAS DLL entrypoints which starts RASMAN, if necessary.  There must
    // be no API calls that require RASAPI32 or RASMAN prior to this point.
    //
    dwErr = LoadRas( g_hinstDll, hwndDlg );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadRas, dwErr, NULL );
        pArgs->pApiArgs->dwError = dwErr;
        EndDialog( hwndDlg, TRUE );
        return TRUE;
    }


    if(0 != (pArgs->pApiArgs->dwFlags & RASPBDFLAG_NoUser))
    {
        // Popup TAPI's "first location" dialog if they are uninitialized.
        //
        dwErr = TapiNoLocationDlg( g_hinstDll, &pInfo->hlineapp, hwndDlg );
        if (dwErr != 0)
        {
            // Error here is treated as a "cancel" per bug 288385.
            //
            pArgs->pApiArgs->dwError = 0;
            EndDialog( hwndDlg, TRUE );
            return TRUE;
        }
    }

    pInfo->hwndLbEntries = GetDlgItem( hwndDlg, CID_DU_LB_Entries );
    ASSERT( pInfo->hwndLbEntries );
    pInfo->hwndPbDial = GetDlgItem( hwndDlg, CID_DU_PB_Dial );
    ASSERT( pInfo->hwndPbDial );
    pInfo->hwndPbNew = GetDlgItem( hwndDlg, CID_DU_PB_New );
    ASSERT( pInfo->hwndPbNew );
    pInfo->hwndPbProperties = GetDlgItem( hwndDlg, CID_DU_PB_More );
    ASSERT( pInfo->hwndPbProperties );

    pInfo->fNoUser = (pArgs->pApiArgs->dwFlags & RASPBDFLAG_NoUser );

    // Setting this global flag indicates that WinHelp will not work in the
    // current mode.  See common\uiutil\ui.c.  We assume here that only the
    // WinLogon process makes use of this.
    //
    {
        extern BOOL g_fNoWinHelp;
        g_fNoWinHelp = pInfo->fNoUser;
    }

    // Read user preferences from registry.
    //
    dwErr = g_pGetUserPreferences(
        NULL, &pInfo->user, pInfo->fNoUser ? UPM_Logon : UPM_Normal);
    if (dwErr != 0)
    {
        //
        // The following free causes a crash in DuTerm. This context will be
        // freed in DuTerm - raos.
        //
        // Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPrefs, dwErr, NULL );
        EndDialog( hwndDlg, TRUE );
        return TRUE;
    }

    // Load and parse phonebook file.
    //
    if (pInfo->fNoUser)
    {
        dwReadPbkFlags |= RPBF_NoUser;
    }
    dwErr = ReadPhonebookFile(
                pArgs->pszPhonebook,
                &pInfo->user,
                NULL,
                dwReadPbkFlags,
                &pInfo->file );
    if (dwErr != 0)
    {
        // The following free causes a crash in DuTerm. This context will be
        // freed in DuTerm - raos.
        //
        // Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPhonebook, dwErr, NULL );
        EndDialog( hwndDlg, TRUE );
        return TRUE;
    }

    if (pArgs->pApiArgs->pCallback && !pArgs->pszPhonebook)
    {
        RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

        // Tell user the path to the default phonebook file.
        //
        TRACE( "Callback(EditGlobals)" );
        pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
            RASPBDEVENT_EditGlobals, pInfo->file.pszPath, NULL );
        TRACE( "Callback(EditGlobals) done" );
    }

    if (pInfo->fNoUser)
    {
        // Retrieve logon information from caller via callback.
        //
        if (pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pArgs->pApiArgs->pCallback;

            pInfo->pNoUser = Malloc( sizeof(RASNOUSERW) );
            if (pInfo->pNoUser)
            {
                ZeroMemory( pInfo->pNoUser, sizeof(*pInfo->pNoUser) );
                pInfo->pNoUser->dwSize = sizeof(*pInfo->pNoUser);

                TRACE( "Callback(NoUser)" );
                pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                    RASPBDEVENT_NoUser, NULL, pInfo->pNoUser );
                TRACE1( "Callback(NoUser) done,to=%d",
                    pInfo->pNoUser->dwTimeoutMs );
                TRACEW1( "U=%s",pInfo->pNoUser->szUserName );
                TRACEW1( "D=%s",pInfo->pNoUser->szDomain );

                // Whistler bug 254385 encode password when not being used
                // Assumed password was not encoded during callback
                //
                EncodePassword( pInfo->pNoUser->szPassword );

                // Install input detection hooks.
                //
                if (pInfo->pNoUser->dwTimeoutMs > 0)
                {
                    pInfo->hhookMouse = SetWindowsHookEx(
                        WH_MOUSE, DuInputHook, g_hinstDll,
                        GetCurrentThreadId() );

                    pInfo->hhookKeyboard = SetWindowsHookEx(
                        WH_KEYBOARD, DuInputHook, g_hinstDll,
                        GetCurrentThreadId() );
                }
            }
        }

        if (!pInfo->user.fAllowLogonPhonebookEdits)
        {
            // Disable new button.  See also similar logic for the Properties
            // button occurs in DuUpdateLbEntries.
            //
            EnableWindow( pInfo->hwndPbNew, FALSE );
        }
    }

    // Load the list of phonebook entries and set selection.
    //
    DuUpdateLbEntries( pInfo, pInfo->pArgs->pszEntry );

    if (!pInfo->pArgs->pszEntry)
    {
        if (ComboBox_GetCount( pInfo->hwndLbEntries ) > 0)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbEntries, 0 );
        }
    }

    // Update the title to reflect the phonebook mode.
    //
    DuUpdateTitle( pInfo );

    // Adjust the title bar widgets and create the wizard bitmap.
    //
    TweakTitleBar( hwndDlg );
    AddContextHelpButton( hwndDlg );

    // Start the connect monitor.
    //
    if ((pInfo->hEvent = CreateEvent( NULL, FALSE, FALSE, NULL ))
        && (pInfo->hThread = CreateThread(
                NULL, 0, DuMonitorThread, (LPVOID )pInfo, 0,
                (LPDWORD )&dwThreadId )))
    {
        ASSERT( g_pRasConnectionNotification );
        TRACE( "RasConnectionNotification" );
        dwErr = g_pRasConnectionNotification(
            INVALID_HANDLE_VALUE, pInfo->hEvent,
            RASCN_Connection | RASCN_Disconnection );
        TRACE1( "RasConnectionNotification=%d", dwErr );
    }
    else
        TRACE( "Monitor DOA" );

    if (ComboBox_GetCount( pInfo->hwndLbEntries ) == 0)
    {
        // The phonebook is empty.
        //
        if (pInfo->fNoUser
            && !pInfo->user.fAllowLogonPhonebookEdits
            )
        {
            // Tell the user you can't create an entry or locations during
            // startup.
            //
            MsgDlg( hwndDlg, SID_EmptyLogonPb, NULL );
            EndDialog( hwndDlg, TRUE );
            return TRUE;
        }
        else
        {
            if(pInfo->fNoUser)
            {
                dwErr = TapiNoLocationDlg( g_hinstDll, 
                                           &pInfo->hlineapp, hwndDlg );
                if (dwErr != 0)
                {
                    // Error here is treated as a "cancel" per bug 288385.
                    //
                    pArgs->pApiArgs->dwError = 0;
                    EndDialog( hwndDlg, TRUE );
                    return TRUE;
                }
            }
        
            // Tell the user, then automatically start him into adding a new
            // entry.  Set initial focus to "New" button first, in case user
            // cancels out.
            //
            SetFocus( pInfo->hwndPbNew );
            MsgDlg( hwndDlg, SID_EmptyPhonebook, NULL );
            DuNewEntry( pInfo, FALSE );
        }
    }
    else
    {
        // Set initial focus to the non-empty entry listbox.
        //
        SetFocus( pInfo->hwndLbEntries );
    }

    return FALSE;
}


LRESULT CALLBACK
DuInputHook(
    IN int    nCode,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // Standard Win32 'MouseProc' or 'KeyboardProc' callback.  For our simple
    // processing we can take advantage of them having identical arguments and
    // 'nCode' definitions.
    //
{
    if (nCode == HC_ACTION)
    {
        ++g_cInput;
    }
    return 0;
}

VOID
DuNewEntry(
    IN DUINFO* pInfo,
    IN BOOL fClone )

    // Called when user presses the "New" button or "Clone" menu item.
    // 'PInfo' is the dialog context.  'FClone' is set to clone the selected
    // entry, otherwise an empty entry is created.
    //
{
    BOOL fOk;
    TCHAR* pszEntry;
    RASENTRYDLG info;
    INTERNALARGS iargs;
    PBENTRY* pEntry;

    TRACE1( "DuNewEntry(f=%d)", fClone );

    ZeroMemory( &info, sizeof(info) );
    info.dwSize = sizeof(info);
    info.hwndOwner = pInfo->hwndDlg;

    if (fClone)
    {
        DUCONTEXT *pContext;

        // Look up the selected entry.
        //
        pContext = (DUCONTEXT* )ComboBox_GetItemDataPtr(
            pInfo->hwndLbEntries, ComboBox_GetCurSel( pInfo->hwndLbEntries ) );

        if (!pContext)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
            SetFocus( pInfo->hwndPbNew );
            return;
        }

        pEntry = pContext->pEntry;

        if (!pEntry)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoEntrySelected, NULL );
            SetFocus( pInfo->hwndPbNew );
            return;
        }

        pszEntry = pEntry->pszEntryName;
        info.dwFlags = RASEDFLAG_CloneEntry;
    }
    else
    {
        pszEntry = NULL;
        info.dwFlags = RASEDFLAG_NewEntry;
    }

    {
        RECT rect;

        GetWindowRect( pInfo->hwndDlg, &rect );
        info.dwFlags += RASEDFLAG_PositionDlg;
        info.xDlg = rect.left + DXSHEET;
        info.yDlg = rect.top + DYSHEET;
    }

    // The secret hack to share information already loaded with the entry API.
    //
    ZeroMemory( &iargs, sizeof(iargs) );
    iargs.pFile = &pInfo->file;
    iargs.pUser = &pInfo->user;
    iargs.pNoUser = pInfo->pNoUser;
    iargs.fNoUser = pInfo->fNoUser;
    info.reserved = (ULONG_PTR ) &iargs;

    // Call the Win32 API to run the add entry wizard.
    //
    TRACE( "RasEntryDlg" );
    fOk = RasEntryDlg( pInfo->pArgs->pszPhonebook, pszEntry, &info );
    TRACE1( "RasEntryDlg=%d", fOk );

    if (pInfo->pNoUser && !pInfo->hThread)
    {
        TRACE( "Taking shortcut to exit" );
        return;
    }

    if (fOk)
    {
        TRACEW1( "OK pressed, e=\"%s\"", info.szEntry );

        if (pInfo->pArgs->pApiArgs->pCallback)
        {
            RASPBDLGFUNCW pfunc = pInfo->pArgs->pApiArgs->pCallback;

            TRACE( "Callback(AddEntry)" );
            pfunc( pInfo->pArgs->pApiArgs->dwCallbackId,
                RASPBDEVENT_AddEntry, info.szEntry, NULL );
            TRACE( "Callback(AddEntry) done" );
        }

        DuUpdateLbEntries( pInfo, info.szEntry );
        Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbDial );
        SetFocus( pInfo->hwndLbEntries );
    }
    else
    {
        TRACE( "Cancel pressed or error" );
    }
}

VOID
DuUpdateConnectStatus(
    IN DUINFO* pInfo )

    // Called to update connect status of the selected entry and the text of
    // the Dial/HangUp button.  'PInfo' is the dialog context block.
    //
{
    TCHAR* pszPhonebook;
    TCHAR* pszEntry;
    INT iSel;
    TCHAR* psz;
    DUCONTEXT *pContext;

    TRACE( "DuUpdateConnectStatus" );

    // pszPhonebook = pInfo->file.pszPath;
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
    if (iSel < 0)
    {
        return;
    }

    pContext = (DUCONTEXT *) ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries,
                                iSel);

    ASSERT(NULL != pContext);

    pszEntry = ComboBox_GetPsz( pInfo->hwndLbEntries, iSel );
    pInfo->hrasconn = HrasconnFromEntry(
                                    pContext->pszPhonebookPath,
                                    pszEntry );

    psz = PszFromId( g_hinstDll,
              (pInfo->hrasconn) ? SID_DU_HangUp : SID_DU_Dial );
    if (psz)
    {
        SetWindowText( pInfo->hwndPbDial, psz );
        Free( psz );
    }
}


VOID
DuUpdateLbEntries(
    IN DUINFO* pInfo,
    IN TCHAR* pszEntry )

    // Update the contents of the entry listbox and set the selection to
    // 'pszEntry'.  If there are entries the Properties button is enabled,
    // otherwise it is disabled.  'PInfo' is the dialog context.
    //
{
    DTLNODE* pNode;
    RASENTRYNAME *pRasEntryNames = NULL;
    DWORD cEntries = 0;
    DWORD cb;
    DWORD dwErr;
    DWORD i;
    RASENTRYNAME ren;
    DUCONTEXT *pContext;
    INT iSel;

    TRACE( "DuUpdateLbEntries" );

    iSel = -1;
    ComboBox_ResetContent( pInfo->hwndLbEntries );

    cb = ren.dwSize = sizeof(RASENTRYNAME);

    //
    // Enumerate entries across all phonebooks. Fix for bug 206467
    //
    dwErr = g_pRasEnumEntries(NULL,
                              pInfo->pArgs->pszPhonebook,
                              &ren,
                              &cb,
                              &cEntries);

    if(     (   (ERROR_BUFFER_TOO_SMALL == dwErr)
            ||  (SUCCESS == dwErr))
        &&  (cb >= sizeof(RASENTRYNAME)))
    {
        pRasEntryNames = (RASENTRYNAME *) Malloc(cb);

        if(NULL == pRasEntryNames)
        {
            // Nothing else can be done in this case
            //
            goto done;
        }

        pRasEntryNames->dwSize = sizeof(RASENTRYNAME);

        dwErr = g_pRasEnumEntries(NULL,
                                  pInfo->pArgs->pszPhonebook,
                                  pRasEntryNames,
                                  &cb,
                                  &cEntries);

        if(dwErr)
        {
            goto done;
        }
    }
    else
    {
        goto done;
    }


    for(i = 0; i < cEntries; i++)
    {
        pContext = (DUCONTEXT *) Malloc(sizeof(DUCONTEXT));

        if(NULL == pContext)
        {
            dwErr = GetLastError();
            goto done;
        }

        ZeroMemory(pContext, sizeof(DUCONTEXT));

        pContext->pszPhonebookPath = 
                            StrDup(
                                pRasEntryNames[i].szPhonebookPath
                                );
                                
        ComboBox_AddItem(pInfo->hwndLbEntries,
                         pRasEntryNames[i].szEntryName,
                         pContext);


    }

    if (ComboBox_GetCount( pInfo->hwndLbEntries ) >= 0)
    {
        if (pszEntry)
        {
            // Select entry specified by API caller.
            //
            iSel = ComboBox_FindStringExact(
                pInfo->hwndLbEntries, -1, pszEntry );
        }

        if (iSel < 0)
        {
            // Entry not found so default to first item selected.
            //
            iSel = 0;
        }

        if(ComboBox_GetCount(pInfo->hwndLbEntries) > 0)
        {
            ComboBox_SetCurSelNotify( pInfo->hwndLbEntries, iSel );
        }
    }

done:

    // Enable/disable Properties button based on existence of an entry.  See
    // bug 313037.
    //
    if (ComboBox_GetCurSel( pInfo->hwndLbEntries ) >= 0
        && (!pInfo->fNoUser || pInfo->user.fAllowLogonPhonebookEdits))
    {
        EnableWindow( pInfo->hwndPbProperties, TRUE );
    }
    else
    {
        if (GetFocus() == pInfo->hwndPbProperties)
        {
            SetFocus( pInfo->hwndPbDial );
        }

        EnableWindow( pInfo->hwndPbProperties, FALSE );
    }

    ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbEntries );
    Free0(pRasEntryNames);
}

VOID
DuUpdateTitle(
    IN DUINFO* pInfo )

    // Called to update the dialog title to reflect the current phonebook.
    // 'PInfo' is the dialog context.
    //
{
    TCHAR szBuf[ 256 ];
    TCHAR* psz;

    psz = PszFromId( g_hinstDll, SID_PopupTitle );
    if (psz)
    {
        lstrcpyn( szBuf, psz, sizeof(szBuf) / sizeof(TCHAR) );
        Free( psz );
    }
    else
    {
        *szBuf = TEXT('0');
    }

    if (pInfo->pArgs->pszPhonebook
        || pInfo->user.dwPhonebookMode != PBM_System)
    {
        INT iSel;

        iSel = ComboBox_GetCurSel(pInfo->hwndLbEntries);
        if (iSel >= 0)
        {
            DUCONTEXT *pContext;

            pContext = (DUCONTEXT *) ComboBox_GetItemDataPtr(
                pInfo->hwndLbEntries, iSel);

            ASSERT( pContext );

            if(NULL != pContext)
            {
                lstrcat( szBuf, TEXT(" - ") );
                lstrcat( szBuf, StripPath( pContext->pszPhonebookPath ) );
            }
        }
    }

    SetWindowText( pInfo->hwndDlg, szBuf );
}


VOID
DuTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    DUINFO* pInfo;

    DWORD i;
    DWORD cEntries;

    TRACE( "DuTerm" );

    pInfo = (DUINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        // Close ReceiveMonitorThread resources.
        //
        if (pInfo->hThread)
        {
            TRACE( "Set abort event" );

            // Tell thread to wake up and quit...
            //
            pInfo->fAbortMonitor = TRUE;
            CloseHandle( pInfo->hThread );

            // Don't SetEvent before closing the thread handle.  On
            // multi-proc systems, the thread will exit so fast (and
            // set hThread to NULL) that CloseHandle will then close
            // an invalid handle.
            //
            SetEvent( pInfo->hEvent );

            // ...and wait for that to happen.  A message API (such as
            // PeekMessage) must be called to prevent the thread-to-thread
            // SendMessage in the thread from blocking.
            //
            {
                MSG msg;

                TRACE( "Termination spin..." );
                for (;;)
                {
                    PeekMessage( &msg, hwndDlg, 0, 0, PM_NOREMOVE );
                    if (!pInfo->hThread)
                    {
                        break;
                    }
                    Sleep( 500L );
                }
                TRACE( "Termination spin ends" );
            }
        }

        if (pInfo->hEvent)
        {
            CloseHandle( pInfo->hEvent );
        }

        if (pInfo->pNoUser)
        {
            // Don't leave caller's password floating around in memory.
            //
            ZeroMemory( pInfo->pNoUser->szPassword, PWLEN * sizeof(TCHAR) );
            Free( pInfo->pNoUser );

            // Uninstall input event hooks.
            //
            if (pInfo->hhookMouse)
            {
                UnhookWindowsHookEx( pInfo->hhookMouse );
            }
            if (pInfo->hhookKeyboard)
            {
                UnhookWindowsHookEx( pInfo->hhookKeyboard );
            }
        }
        else if ((pInfo->pArgs->pApiArgs->dwFlags & RASPBDFLAG_UpdateDefaults)
                 && pInfo->hwndLbEntries && pInfo->user.fInitialized)
        {
            INT iSel;
            RECT rect;

            // Caller said to update default settings so save the name of the
            // selected entry and the current window position.
            //
            iSel = ComboBox_GetCurSel( pInfo->hwndLbEntries );
            if (iSel >= 0)
            {
                DUCONTEXT *pContext;
                PBENTRY* pEntry;

                pContext = (DUCONTEXT* )ComboBox_GetItemDataPtr(
                    pInfo->hwndLbEntries, iSel );

                if(     (NULL != pContext)
                    &&  (NULL != (pEntry = pContext->pEntry)))
                {
                    Free0( pInfo->user.pszDefaultEntry );
                    pInfo->user.pszDefaultEntry =
                        StrDup( pEntry->pszEntryName );
                }
            }

            if (!SetOffDesktop( pInfo->hwndDlg, SOD_GetOrgRect, &rect ))
            {
                GetWindowRect( pInfo->hwndDlg, &rect );
            }
            pInfo->user.dwXPhonebook = rect.left;
            pInfo->user.dwYPhonebook = rect.top;

            pInfo->user.fDirty = TRUE;
            g_pSetUserPreferences(
                NULL, &pInfo->user, pInfo->fNoUser ? UPM_Logon : UPM_Normal );
        }

        if(NULL != pInfo->hwndLbEntries)
        {
            DUCONTEXT *pContext;

            cEntries = ComboBox_GetCount(pInfo->hwndLbEntries);

            //
            // Free the context stored in the list box
            //
            for(i = 0; i < cEntries; i++)
            {
                pContext = ComboBox_GetItemDataPtr(
                                pInfo->hwndLbEntries, i);

                if(NULL != pContext)
                {
                    Free0(pContext->pszPhonebookPath);
                }

                Free0(pContext);
            }
        }

        TapiShutdown( pInfo->hlineapp );
        ClosePhonebookFile( &pInfo->file );
        DestroyUserPreferences( &pInfo->user );
        Free( pInfo );
    }
}

DWORD
DuMonitorThread(
    LPVOID pThreadArg )

    // The "main" of the "connect monitor" thread.  This thread simply
    // converts Win32 RasConnectionNotification events int WM_RASEVENT style
    // notfications.
    //
{
    DUINFO* pInfo;
    DWORD dwErr;
    DWORD dwTimeoutMs;
    DWORD dwQuitTick;
    DWORD cInput = 0;

    TRACE( "DuMonitor starting" );

    pInfo = (DUINFO* )pThreadArg;

    if (pInfo->pNoUser && pInfo->pNoUser->dwTimeoutMs != 0)
    {
        TRACE( "DuMonitor quit timer set" );
        dwTimeoutMs = 5000L;
        dwQuitTick = GetTickCount() + pInfo->pNoUser->dwTimeoutMs;
        cInput = g_cInput;
    }
    else
    {
        dwTimeoutMs = INFINITE;
        dwQuitTick = 0;
    }

    // Trigger the event so the other thread has the correct state as of the
    // monitor starting.
    //
    SetEvent( pInfo->hEvent );

    for (;;)
    {
        dwErr = WaitForSingleObject( pInfo->hEvent, dwTimeoutMs );

        if (pInfo->fAbortMonitor)
        {
            break;
        }

        if (dwErr == WAIT_TIMEOUT)
        {
            if (g_cInput > cInput)
            {
                TRACE( "Input restarts timer" );
                cInput = g_cInput;
                dwQuitTick = GetTickCount() + pInfo->pNoUser->dwTimeoutMs;
            }
            else if (GetTickCount() >= dwQuitTick)
            {
                TRACE( "/DuMonitor SendMessage(WM_NOUSERTIMEOUT)" );
                SendMessage( pInfo->hwndDlg, WM_NOUSERTIMEOUT, 0, 0 );
                TRACE( "\\DuMonitor SendMessage(WM_NOUSERTIMEOUT) done" );
                break;
            }
        }
        else
        {
            TRACE( "/DuMonitor SendMessage(WM_RASEVENT)" );
            SendMessage( pInfo->hwndDlg, WM_RASEVENT, 0, 0 );
            TRACE( "\\DuMonitor SendMessage(WM_RASEVENT) done" );
        }
    }

    // This clues the other thread that all interesting work has been done.
    //
    pInfo->hThread = NULL;

    TRACE( "DuMonitor terminating" );
    return 0;
}


DWORD
DuGetEntry(
    DUINFO* pInfo,
    DUCONTEXT* pContext )
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwReadPbkFlags = 0;
    LPTSTR pszEntryName;
    DTLNODE *pdtlnode;
    PBFILE file;

    ASSERT(NULL != pContext);

    pContext->pEntry = NULL;

    pszEntryName = ComboBox_GetPsz(pInfo->hwndLbEntries,
                                   ComboBox_GetCurSel(pInfo->hwndLbEntries));

    if (pInfo->fNoUser)
    {
        dwReadPbkFlags |= RPBF_NoUser;
    }

    if(     (NULL != pInfo->file.pszPath)
        &&  (0 == lstrcmpi(pContext->pszPhonebookPath,
                     pInfo->file.pszPath)))
    {
        //
        // We already have the phonebook file open
        //
        pdtlnode = EntryNodeFromName(
                        pInfo->file.pdtllistEntries,
                        pszEntryName);

        ASSERT(NULL != pdtlnode);
    }
    else
    {
        //
        // phonebook file changed. So close the existing phone
        // book file and open the one in  which the entry
        // belongs
        //
        if(NULL != pInfo->file.pszPath)
        {
            ClosePhonebookFile(&pInfo->file);
        }

        dwErr = GetPbkAndEntryName(pContext->pszPhonebookPath,
                                   pszEntryName,
                                   dwReadPbkFlags,
                                   &file,
                                   &pdtlnode);

        if(dwErr)
        {
            goto done;
        }

        ASSERT(NULL != pdtlnode);

        CopyMemory(&pInfo->file, &file, sizeof(PBFILE));
    }

    if (pdtlnode)
    {
        pContext->pEntry = (PBENTRY *) DtlGetData(pdtlnode);
    }
    else
    {
        dwErr = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
    }

done:
    return dwErr;
}


DWORD
DwGetEapLogonInfo(
    VOID *pv,
    EAPLOGONINFO **ppEapLogonInfo )
{
    EAPLOGONINFO *pEapLogonInfo = NULL;

    DWORD retcode = SUCCESS;

    struct EAPINFO
    {
        DWORD dwSizeofEapInfo;
        PBYTE pbEapInfo;
        DWORD dwSizeofPINInfo;
        PBYTE pbPINInfo;
    };

    struct EAPINFO *pEapInfo = (struct EAPINFO *) pv;

    DWORD dwSize;

    if(NULL == pv)
    {
        retcode = E_INVALIDARG;
        goto done;
    }

    dwSize = sizeof(EAPLOGONINFO)
           + pEapInfo->dwSizeofEapInfo
           + pEapInfo->dwSizeofPINInfo;

    pEapLogonInfo = (EAPLOGONINFO *) Malloc(dwSize);

    if(NULL == pEapLogonInfo)
    {

        retcode = GetLastError();

        TRACE1("Failed to Allocate EapLogonInfo. rc=0x%x",
                 retcode);
        goto done;
    }

    ZeroMemory(pEapLogonInfo, dwSize);

    //
    // Set up the fields in pEapLogonInfo by
    // flattening out the information passed
    // in.
    //
    pEapLogonInfo->dwSize = dwSize;

    pEapLogonInfo->dwLogonInfoSize =
        pEapInfo->dwSizeofEapInfo;

    pEapLogonInfo->dwOffsetLogonInfo =
        FIELD_OFFSET(EAPLOGONINFO, abdata);

    memcpy( pEapLogonInfo->abdata,
            pEapInfo->pbEapInfo,
            pEapInfo->dwSizeofEapInfo);

    pEapLogonInfo->dwPINInfoSize =
        pEapInfo->dwSizeofPINInfo;

    pEapLogonInfo->dwOffsetPINInfo =
        FIELD_OFFSET(EAPLOGONINFO, abdata)
        + pEapInfo->dwSizeofEapInfo;

    memcpy(    (PBYTE)
               ((PBYTE) pEapLogonInfo
             + pEapLogonInfo->dwOffsetPINInfo),

            pEapInfo->pbPINInfo,

            pEapInfo->dwSizeofPINInfo);

done:
    *ppEapLogonInfo = pEapLogonInfo;

    return retcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\mlink.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// mlink.c
// Remote Access Common Dialog APIs
// Multi-link configuration dialogs
//
// 01/23/96 Steve Cobb


#include "rasdlgp.h"


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwDmHelp[] =
{
    CID_DM_ST_Explain,       HID_DM_ST_Explain,
    CID_DM_ST_Dial,          HID_DM_LB_DialPercent,
    CID_DM_LB_DialPercent,   HID_DM_LB_DialPercent,
    CID_DM_ST_DialOrMore,    HID_DM_LB_DialTime,
    CID_DM_LB_DialTime,      HID_DM_LB_DialTime,
    CID_DM_ST_HangUp,        HID_DM_LB_HangUpPercent,
    CID_DM_LB_HangUpPercent, HID_DM_LB_HangUpPercent,
    CID_DM_ST_HangUpOrLess,  HID_DM_LB_HangUpTime,
    CID_DM_LB_HangUpTime,    HID_DM_LB_HangUpTime,
    0, 0
};


//-----------------------------------------------------------------------------
// Local datatypes
//-----------------------------------------------------------------------------

// Multi-link dialing dialog context block.
//
typedef struct
_DMINFO
{
    // Stub API argument.
    //
    PBENTRY* pEntry;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbDialPercents;
    HWND hwndLbDialTimes;
    HWND hwndLbHangUpPercents;
    HWND hwndLbHangUpTimes;
}
DMINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

BOOL
DmCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
DmDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
DmInit(
    IN HWND hwndDlg,
    IN PBENTRY* pEntry );

VOID
DmSave(
    IN DMINFO* pInfo );

VOID
DmTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Multi-link dialing dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
MultiLinkDialingDlg(
    IN HWND hwndOwner,
    OUT PBENTRY* pEntry )

    // Popup the Multi-link dialing dialog.  'HwndOwner' is the owner of the
    // dialog.  'PEntry' is a phonebook entry to edit.
    //
    // Returns true if user pressed OK and succeeded, false if user pressed
    // Cancel or encountered an error.
{
    INT_PTR nStatus;

    TRACE( "MultiLinkConfigureDlg" );

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_DM_DialingMultipleLines ),
            hwndOwner,
            DmDlgProc,
            (LPARAM )pEntry );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
DmDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Multi-Link dialing dialog.  Parameters and
    // return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "DmDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
            (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return DmInit( hwnd, (PBENTRY* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwDmHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            return DmCommand(
                hwnd, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            DmTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
DmCommand(
    IN HWND hwnd,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'Hwnd' is the dialog window.  'WNotification' is
    // the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    DWORD dwErr;

    TRACE3( "DmCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case IDOK:
        {
            DMINFO* pInfo;

            pInfo = (DMINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );
            DmSave( pInfo );
            EndDialog( hwnd, TRUE );
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( hwnd, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
DmInit(
    IN HWND hwndDlg,
    IN PBENTRY* pEntry )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the owning window.
    // 'PEntry' is the caller's stub API argument.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DMINFO* pInfo;

    TRACE( "DmInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pEntry = pEntry;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndLbDialPercents = GetDlgItem( hwndDlg, CID_DM_LB_DialPercent );
    ASSERT( pInfo->hwndLbDialPercents );
    pInfo->hwndLbDialTimes = GetDlgItem( hwndDlg, CID_DM_LB_DialTime );
    ASSERT( pInfo->hwndLbDialTimes );
    pInfo->hwndLbHangUpPercents = GetDlgItem( hwndDlg, CID_DM_LB_HangUpPercent );
    ASSERT( pInfo->hwndLbHangUpPercents );
    pInfo->hwndLbHangUpTimes = GetDlgItem( hwndDlg, CID_DM_LB_HangUpTime );
    ASSERT( pInfo->hwndLbHangUpTimes );

    // Initialize the drop lists contents and selections.
    //
    {
        INT i;
        INT iSel;
        DWORD* pdwPercent;
        LBTABLEITEM* pItem;

        static LBTABLEITEM aTimes[] =
        {
            SID_Time3s,  3,
            SID_Time5s,  5,
            SID_Time10s, 10,
            SID_Time30s, 30,
            SID_Time1m,  60,
            SID_Time2m,  120,
            SID_Time5m,  300,
            SID_Time10m, 600,
            SID_Time30m, 1800,
            SID_Time1h,  3600,
            0, 0
        };

        static DWORD aDialPercents[] =
        {
            1, 5, 10, 25, 50, 75, 90, 95, 100, 0xFFFFFFFF
        };

        static DWORD aHangUpPercents[] =
        {
            0, 5, 10, 25, 50, 75, 90, 95, 99, 0xFFFFFFFF
        };

        // Initialize the Dial Percents list and set the selection.
        //
        iSel = -1;
        for (pdwPercent = aDialPercents, i = 0;
             *pdwPercent != 0xFFFFFFFF;
             ++pdwPercent, ++i)
        {
            TCHAR achPercent[ 12 ];

            wsprintf( achPercent, TEXT("%d%%"), *pdwPercent );
            ComboBox_AddItem( pInfo->hwndLbDialPercents, achPercent,
                (VOID* )UlongToPtr(*pdwPercent));

            if (iSel < 0 && pEntry->dwDialPercent <= *pdwPercent)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbDialPercents, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbDialPercents, i - 1 );
        }

        // Initialize the Hang Up Percents list and set the selection.
        //
        iSel = -1;
        for (pdwPercent = aHangUpPercents, i = 0;
             *pdwPercent != 0xFFFFFFFF;
             ++pdwPercent, ++i)
        {
            TCHAR achPercent[ 12 ];

            wsprintf( achPercent, TEXT("%d%%"), *pdwPercent );
            ComboBox_AddItem( pInfo->hwndLbHangUpPercents, achPercent,
                (VOID* )UlongToPtr(*pdwPercent));

            if (iSel < 0 && pEntry->dwHangUpPercent <= *pdwPercent)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbHangUpPercents, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbHangUpPercents, i - 1 );
        }

        // Initialize the Dial times list.
        //
        iSel = -1;
        for (pItem = aTimes, i = 0;
             pItem->sidItem;
             ++pItem, ++i )
        {
            ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbDialTimes,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (iSel < 0 && pEntry->dwDialSeconds <= pItem->dwData)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbDialTimes, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbDialTimes, i - 1 );
        }

        // Initialize the Hang Up times list.
        //
        iSel = -1;
        for (pItem = aTimes, i = 0;
             pItem->sidItem;
             ++pItem, ++i )
        {
            ComboBox_AddItemFromId( g_hinstDll, pInfo->hwndLbHangUpTimes,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (iSel < 0 && pEntry->dwHangUpSeconds <= pItem->dwData)
            {
                iSel = i;
                ComboBox_SetCurSel( pInfo->hwndLbHangUpTimes, iSel );
            }
        }

        if (iSel < 0)
        {
            ComboBox_SetCurSel( pInfo->hwndLbDialTimes, i - 1 );
        }
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.  Dlgedit.exe doesn't currently
    // support this at resource edit time.  When that's fixed set
    // DS_CONTEXTHELP there and remove this call.
    //
    AddContextHelpButton( hwndDlg );

    return TRUE;
}


VOID
DmSave(
    IN DMINFO* pInfo )

    // Save the current dialog state in the stub API entry buffer.  'PInfo' is
    // the dialog context.
    //
{
    INT iSel;

    TRACE( "DmSave" );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialPercents );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwDialPercent =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbDialPercents, iSel ) );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbDialTimes );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwDialSeconds =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbDialTimes, iSel ) );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbHangUpPercents );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwHangUpPercent =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbHangUpPercents, iSel ) );

    iSel = ComboBox_GetCurSel( pInfo->hwndLbHangUpTimes );
    ASSERT( iSel >= 0 );
    pInfo->pEntry->dwHangUpSeconds =
        PtrToUlong( ComboBox_GetItemDataPtr( pInfo->hwndLbHangUpTimes, iSel ) );

    pInfo->pEntry->fDirty = TRUE;
}


VOID
DmTerm(
    IN HWND hwndDlg )

    /* Dialog termination.  Releases the context block.  'HwndDlg' is the
    ** handle of a dialog.
    */
{
    DMINFO* pInfo;

    TRACE( "DmTerm" );

    pInfo = (DMINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\pref.c ===
/* Copyright (c) 1995, Microsoft Corporation, all rights reserved
**
** pref.c
** Remote Access Common Dialog APIs
** User Preferences property sheet
**
** 08/22/95 Steve Cobb
*/

#include "rasdlgp.h"
#include <commdlg.h>  // FileOpen dialog


/* Page definitions.
*/
//#define UP_AdPage    0
//#define UP_CbPage    1
//#define UP_GpPage    2
//#define UP_PlPage    3
#define UP_PageCount 2

// 
// Defines flags the modify the behavior of the user preferences
// dialog
//
#define UP_F_AutodialMode  0x1      // Come up with focus on autodial page

/*----------------------------------------------------------------------------
** Help maps
**----------------------------------------------------------------------------
*/

static DWORD g_adwAdHelp[] =
{
    CID_AD_ST_Enable,              HID_AD_LV_Enable,
    CID_AD_LV_Enable,              HID_AD_LV_Enable,
    CID_AD_ST_Attempts,            HID_AD_EB_Attempts,
    CID_AD_EB_Attempts,            HID_AD_EB_Attempts,
    CID_AD_ST_Seconds,             HID_AD_EB_Seconds,
    CID_AD_EB_Seconds,             HID_AD_EB_Seconds,
    CID_AD_ST_Idle,                HID_AD_EB_Idle,
    CID_AD_EB_Idle,                HID_AD_EB_Idle,
    CID_AD_CB_AskBeforeAutodial,   HID_AD_CB_AskBeforeAutodial,
    CID_AD_CB_AskBeforeAutodial,   HID_AD_CB_AskBeforeAutodial,
    CID_AD_CB_DisableThisSession,  HID_AD_CB_DisableThisSession,
    0, 0
};

static DWORD g_adwCbHelp[] =
{
    CID_CB_RB_No,      HID_CB_RB_No,
    CID_CB_RB_Maybe,   HID_CB_RB_Maybe,
    CID_CB_RB_Yes,     HID_CB_RB_Yes,
    CID_CB_LV_Numbers, HID_CB_LV_Numbers,
    CID_CB_PB_Edit,    HID_CB_PB_Edit,
    CID_CB_PB_Delete,  HID_CB_PB_Delete,
    0, 0
};

static DWORD g_adwGpHelp[] =
{
    CID_GP_CB_Preview,        HID_GP_CB_Preview,
    CID_GP_CB_Location,       HID_GP_CB_Location,
    CID_GP_CB_Lights,         HID_GP_CB_Lights,
    CID_GP_CB_Progress,       HID_GP_CB_Progress,
    CID_GP_CB_CloseOnDial,    HID_GP_CB_CloseOnDial,
    CID_GP_CB_UseWizard,      HID_GP_CB_UseWizard,
    CID_GP_CB_AutodialPrompt, HID_GP_CB_AutodialPrompt,
    CID_GP_CB_PhonebookEdits, HID_GP_CB_PhonebookEdits,
    CID_GP_CB_LocationEdits,  HID_GP_CB_LocationEdits,
    0, 0
};

static DWORD g_adwCoHelp[] =
{
    CID_CO_GB_LogonPrivileges,             HID_CO_GB_LogonPrivileges,
    CID_CO_ST_AllowConnectionModification, HID_CO_CB_AllowConnectionModification,
    CID_CO_CB_AllowConnectionModification, HID_CO_CB_AllowConnectionModification,
    0, 0
};

static DWORD g_adwPlHelp[] =
{
    CID_PL_ST_Open,          HID_PL_ST_Open,
    CID_PL_RB_SystemList,    HID_PL_RB_SystemList,
    CID_PL_RB_PersonalList,  HID_PL_RB_PersonalList,
    CID_PL_RB_AlternateList, HID_PL_RB_AlternateList,
    CID_PL_CL_Lists,         HID_PL_CL_Lists,
    CID_PL_PB_Browse,        HID_PL_PB_Browse,
    0, 0
};


/*----------------------------------------------------------------------------
** Local datatypes (alphabetically)
**----------------------------------------------------------------------------
*/

/* User Preferences property sheet argument block.
*/
#define UPARGS struct tagUPARGS
UPARGS
{
    /* Caller's arguments to the stub API.
    */
    HLINEAPP hlineapp;
    BOOL     fNoUser;
    BOOL     fIsUserAdmin;
    PBUSER*  pUser;
    PBFILE** ppFile;

    /* Stub API return value.
    */
    BOOL fResult;

    /* Flags that provide more info see UP_F_* values
    */
    DWORD dwFlags;
};


/* User Preferences property sheet context block.  All property pages refer to
** the single context block associated with the sheet.
*/
#define UPINFO struct tagUPINFO
UPINFO
{
    /* Stub API arguments from UpPropertySheet.
    */
    UPARGS* pArgs;

    /* TAPI session handle.  Should always be addressed thru the pointer since
    ** the handle passed down from caller, if any, will be used instead of
    ** 'hlineapp'.
    */
    HLINEAPP  hlineapp;
    HLINEAPP* pHlineapp;

    /* Property sheet dialog and property page handles.  'hwndFirstPage' is
    ** the handle of the first property page initialized.  This is the page
    ** that allocates and frees the context block.
    */
    HWND hwndDlg;
    HWND hwndFirstPage;
    HWND hwndCo;
    HWND hwndGp;
    HWND hwndAd;
    HWND hwndCb;
    HWND hwndPl;

    /* Auto-dial page.
    */
    HWND hwndLvEnable;
    HWND hwndEbAttempts;
    HWND hwndEbSeconds;
    HWND hwndEbIdle;

    BOOL fChecksInstalled;

    /* Callback page.
    */
    HWND hwndRbNo;
    HWND hwndRbMaybe;
    HWND hwndRbYes;
    HWND hwndLvNumbers;
    HWND hwndPbEdit;
    HWND hwndPbDelete;

    /* Phone list page.
    */
    HWND hwndRbSystem;
    HWND hwndRbPersonal;
    HWND hwndRbAlternate;
    HWND hwndClbAlternates;
    HWND hwndPbBrowse;

    /* Working data read from and written to registry with phonebook library.
    */
    PBUSER user;        // Current user
    PBUSER userLogon;   // Logon preferences
};

/*----------------------------------------------------------------------------
** Local prototypes (alphabetically)
**----------------------------------------------------------------------------
*/

VOID
AdApply(
    IN UPINFO* pInfo );

INT_PTR CALLBACK
AdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
AdFillLvEnable(
    IN UPINFO* pInfo );

BOOL
AdInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs );

LVXDRAWINFO*
AdLvEnableCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
CbApply(
    IN UPINFO* pInfo );

BOOL
CbCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
CbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CbInit(
    IN HWND hwndPage );

VOID
CbUpdateLvAndPbState(
    IN UPINFO* pInfo );

BOOL
CoApply(
    IN UPINFO* pInfo );

INT_PTR CALLBACK
CoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CoInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs );

VOID
GpApply(
    IN UPINFO* pInfo );

BOOL
GpCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
GpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
GpInit(
    IN HWND hwndPage );

VOID
GpUpdateCbStates(
    IN UPINFO* pInfo );

BOOL
PlApply(
    IN UPINFO* pInfo );

VOID
PlBrowse(
    IN UPINFO* pInfo );

BOOL
PlCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

INT_PTR CALLBACK
PlDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
PlInit(
    IN HWND hwndPage );

BOOL
UpApply(
    IN HWND hwndPage );

VOID
UpCancel(
    IN HWND hwndPage );

UPINFO*
UpContext(
    IN HWND hwndPage );

VOID
UpExit(
    IN UPINFO* pInfo );

VOID
UpExitInit(
    IN HWND hwndDlg );

UPINFO*
UpInit(
    IN HWND    hwndFirstPage,
    IN UPARGS* pArgs );

VOID
UpTerm(
    IN HWND hwndPage );


/*----------------------------------------------------------------------------
** User Preferences property sheet entry point
**----------------------------------------------------------------------------
*/

BOOL
UserPreferencesDlg(
    IN  HLINEAPP hlineapp,
    IN  HWND     hwndOwner,
    IN  BOOL     fNoUser,
    IN  DWORD    dwFlags,
    OUT PBUSER*  pUser,
    OUT PBFILE** ppFile )

    /* Pops up the User Preferences property sheet, reading and storing the
    ** result in the USER registry.  'HwndOwner' is the handle of the owning
    ** window.  'FNoUser' indicates logon preferences, rather than user
    ** preferences should be edited.  'Hlineapp' is an open TAPI session
    ** handle or NULL if none.  'Puser' is caller's buffer to receive the
    ** result.  'PpFile' is address of caller's file block which is filled in,
    ** if user chooses to open a new phonebook file, with the information
    ** about the newly open file.  It is caller's responsibility to
    ** ClosePhonebookFile and Free the returned block.
    **
    ** Returns true if user pressed OK and settings were saved successfully,
    ** or false if user pressed Cancel or an error occurred.  The routine
    ** handles the display of an appropriate error popup.
    */
{
    PROPSHEETHEADER header;
    PROPSHEETPAGE*  apage;
    PROPSHEETPAGE*  ppage;
    TCHAR*          pszTitle;
    UPARGS          args;
    BOOL            bIsAdmin;
    DWORD           dwPageCount, i;

    TRACE("UpPropertySheet");

    // If the user doesn't have administrative priveleges, then
    // we don't allow the Connections tab to show.
    ZeroMemory(&args, sizeof(args));
    args.fIsUserAdmin = FIsUserAdminOrPowerUser();
    dwPageCount = UP_PageCount;

    // Initialize the array of pages
    apage = Malloc (dwPageCount * sizeof (PROPSHEETPAGE));
    if (!apage)
        return FALSE;

    /* Initialize OUT parameter and property sheet argument block.
    */
    ZeroMemory( pUser, sizeof(*pUser) );
    args.pUser = pUser;
    args.fNoUser = fNoUser;
    args.ppFile = ppFile;
    args.hlineapp = hlineapp;
    args.fResult = FALSE;
    args.dwFlags = dwFlags;

    if (ppFile)
        *ppFile = NULL;

    pszTitle = PszFromId(
        g_hinstDll, (fNoUser) ? SID_UpLogonTitle : SID_UpTitle );

    ZeroMemory( &header, sizeof(header) );

    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_PROPSHEETPAGE + PSH_NOAPPLYNOW;
    header.hwndParent = hwndOwner;
    header.hInstance = g_hinstDll;
    header.pszCaption = (pszTitle) ? pszTitle : TEXT("");
    header.nPages = dwPageCount;
    header.ppsp = apage;

    ZeroMemory( apage, dwPageCount * sizeof (PROPSHEETPAGE) );
    i = 0;

    // Add the autodial page
    ppage = &apage[ i ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (fNoUser)
            ? MAKEINTRESOURCE( PID_AD_AutoDialLogon )
            : MAKEINTRESOURCE( PID_AD_AutoDial ),
    ppage->pfnDlgProc = AdDlgProc;
    ppage->lParam = (LPARAM )&args;
    i++;

    ppage = &apage[ i ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate = MAKEINTRESOURCE( PID_CB_CallbackSettings );
    ppage->pfnDlgProc = CbDlgProc;
    i++;

#if 0
    ppage = &apage[ UP_GpPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (fNoUser)
            ? MAKEINTRESOURCE( PID_GP_GeneralPrefLogon )
            : MAKEINTRESOURCE( PID_GP_GeneralPreferences ),
    ppage->pfnDlgProc = GpDlgProc;

    ppage = &apage[ UP_PlPage ];
    ppage->dwSize = sizeof(PROPSHEETPAGE);
    ppage->hInstance = g_hinstDll;
    ppage->pszTemplate =
        (fNoUser)
            ? MAKEINTRESOURCE( PID_PL_PhoneListLogon )
            : MAKEINTRESOURCE( PID_PL_PhoneList ),
    ppage->pfnDlgProc = PlDlgProc;
#endif

    if (PropertySheet( &header ) == -1)
    {
        TRACE("PropertySheet failed");
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
    }

    Free0( pszTitle );

    return args.fResult;
}

// Allows the editing of ras user preferences
DWORD
APIENTRY
RasUserPrefsDlgInternal (
    HWND hwndParent,
    DWORD dwFlags)
{
    BOOL bCommit = FALSE;
    PBFILE * pPbFile = NULL;
    PBUSER pbuser;
    DWORD dwErr;

    // Load ras if neccessary
    dwErr = LoadRas( g_hinstDll, hwndParent );
    if (dwErr != 0)
    {
        ErrorDlg( hwndParent, SID_OP_LoadRas, dwErr, NULL );
        return dwErr;
    }

    // Launch the user preferences dialog
    bCommit = UserPreferencesDlg( 
                    0,
                    hwndParent,
                    FALSE,
                    dwFlags,
                    &pbuser,
                    &pPbFile );

    // Commit any neccessary changes
    if (bCommit)
    {

    }

    return NO_ERROR;
}

DWORD
APIENTRY
RasUserPrefsDlgAutodial (
    HWND hwndParent)
{
    return RasUserPrefsDlgInternal(hwndParent, UP_F_AutodialMode);
}

DWORD
APIENTRY
RasUserPrefsDlg (
    HWND hwndParent)
{
    return RasUserPrefsDlgInternal(hwndParent, 0);
}

DWORD
APIENTRY
RasUserEnableManualDial (
    IN HWND  hwndParent,
    IN BOOL  bLogon,
    IN BOOL  bEnable )

    /* Called when the "operator dial" menu item is checked.
    */
{
    return SetUserManualDialEnabling (
                bEnable,
                (bLogon) ? UPM_Logon : UPM_Normal);
}

DWORD
APIENTRY
RasUserGetManualDial (
    IN HWND  hwndParent,    // parent for error dialogs
    IN BOOL  bLogon,        // whether a user is logged in
    IN PBOOL pbEnabled )    // whether to enable or not

    /* Called when the "operator dial" menu item is checked.
    */
{
    return GetUserManualDialEnabling (
                pbEnabled,
                (bLogon) ? UPM_Logon : UPM_Normal );
}

/*----------------------------------------------------------------------------
** User Preferences property sheet
** Listed alphabetically
**----------------------------------------------------------------------------
*/

BOOL
UpApply(
    IN HWND hwndPage )

    /* Saves the contents of the property sheet.  'hwndPage' is the property
    ** sheet page.  Pops up any errors that occur.
    **
    ** Returns false if invalid, true otherwise.
    */
{
    DWORD   dwErr;
    UPINFO* pInfo;

    TRACE("UpApply");

    pInfo = UpContext( hwndPage );
    if (!pInfo)
        return TRUE;

    if ( pInfo->hwndAd )
        AdApply( pInfo );

    if (pInfo->hwndCb)
        CbApply( pInfo );

#if 0
    if (pInfo->hwndGp)
        GpApply( pInfo );
#endif

    if (pInfo->hwndCo)
        CoApply ( pInfo );

#if 0
    if (pInfo->hwndPl)
    {
        if (!PlApply( pInfo ))
            return FALSE;
    }
#endif

    pInfo->user.fDirty = TRUE;

    // Save off the user preferences
    //
    dwErr = g_pSetUserPreferences( 
                NULL, 
                &pInfo->user, 
                pInfo->pArgs->fNoUser ? UPM_Logon : UPM_Normal );
    if (dwErr != 0)
    {
        if (*pInfo->pArgs->ppFile)
        {
            ClosePhonebookFile( *pInfo->pArgs->ppFile );
            *pInfo->pArgs->ppFile = NULL;
        }

        ErrorDlg( pInfo->hwndDlg, SID_OP_WritePrefs, dwErr, NULL );
        UpExit( pInfo );
        return TRUE;
    }

    // Save off the logon preferences if we loaded them.
    //
    if (! pInfo->pArgs->fNoUser )
    {
        dwErr = g_pSetUserPreferences( 
                    NULL, 
                    &pInfo->userLogon, 
                    UPM_Logon );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_WritePrefs, dwErr, NULL );
            UpExit( pInfo );
            return TRUE;
        }
    }        

    CopyMemory( pInfo->pArgs->pUser, &pInfo->user, sizeof(PBUSER) );

    pInfo->pArgs->fResult = TRUE;
    return TRUE;
}


VOID
UpCancel(
    IN HWND hwndPage )

    /* Cancel was pressed.  'HwndPage' is the handle of a property page.
    */
{
    TRACE("UpCancel");
}


UPINFO*
UpContext(
    IN HWND hwndPage )

    /* Retrieve the property sheet context from a property page handle.
    */
{
    return (UPINFO* )GetProp( GetParent( hwndPage ), g_contextId );
}


VOID
UpExit(
    IN UPINFO* pInfo )

    /* Forces an exit from the dialog.  'PInfo' is the property sheet context.
    **
    ** Note: This cannot be called during initialization of the first page.
    **       See UpExitInit.
    */
{
    TRACE("UpExit");

    PropSheet_PressButton( pInfo->hwndDlg, PSBTN_CANCEL );
}


VOID
UpExitInit(
    IN HWND hwndDlg )

    /* Utility to report errors within UpInit and other first page
    ** initialization.  'HwndDlg' is the dialog window.
    */
{
    SetOffDesktop( hwndDlg, SOD_MoveOff, NULL );
    SetOffDesktop( hwndDlg, SOD_Free, NULL );
    PostMessage( hwndDlg, WM_COMMAND,
        MAKEWPARAM( IDCANCEL , BN_CLICKED ),
        (LPARAM )GetDlgItem( hwndDlg, IDCANCEL ) );
}

UPINFO*
UpInit(
    IN HWND    hwndFirstPage,
    IN UPARGS* pArgs )

    /* Property sheet level initialization.  'HwndPage' is the handle of the
    ** first page.  'PArgs' is the API argument block.
    **
    ** Returns address of the context block if successful, NULL otherwise.  If
    ** NULL is returned, an appropriate message has been displayed, and the
    ** property sheet has been cancelled.
    */
{
    UPINFO* pInfo;
    DWORD   dwErr;
    HWND    hwndDlg;

    TRACE("UpInit");

    hwndDlg = GetParent( hwndFirstPage );
    ASSERT(hwndDlg);

    /* Allocate the context information block.
    */
    pInfo = Malloc( sizeof(*pInfo) );
    if (!pInfo)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* Initialize the context block.
    */
    ZeroMemory( pInfo, sizeof(*pInfo) );
    pInfo->hwndDlg = hwndDlg;
    pInfo->pArgs = pArgs;
    pInfo->hwndFirstPage = hwndFirstPage;

    /* Read in the user preferences
    */
    dwErr = g_pGetUserPreferences( 
                NULL, 
                &pInfo->user, 
                pArgs->fNoUser ? UPM_Logon : UPM_Normal);
    if (dwErr != 0)
    {
        Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadPrefs, dwErr, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* If the fNoUser option was not selected, then load in the 
       logon preferences separately, since we allow them to be
       modificed in this UI
    */
    if (! pArgs->fNoUser )
    {
        dwErr = g_pGetUserPreferences( 
                    NULL, 
                    &pInfo->userLogon, 
                    UPM_Logon);
        if (dwErr != 0)
        {
            Free( pInfo );
            ErrorDlg( hwndDlg, SID_OP_LoadPrefs, dwErr, NULL );
            UpExitInit( hwndDlg );
            return NULL;
        }
    }        

    /* Associate the context with the property sheet window.
    */
    if (!SetProp( hwndDlg, g_contextId, pInfo ))
    {
        Free( pInfo );
        ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        UpExitInit( hwndDlg );
        return NULL;
    }

    /* Use caller's TAPI session handle, if any.
    */
    if (pArgs->hlineapp)
       pInfo->pHlineapp = &pArgs->hlineapp;
    else
       pInfo->pHlineapp = &pInfo->hlineapp;

    TRACE("Context set");

    /* Set even fixed tab widths, per spec.
    */
    // SetEvenTabWidths( hwndDlg, UP_PageCount );

    /* Position property sheet at standard offset from parent.
    {
        RECT rect;

        GetWindowRect( GetParent( hwndDlg ), &rect );
        SetWindowPos( hwndDlg, NULL,
            rect.left + DXSHEET, rect.top + DYSHEET, 0, 0,
            SWP_NOZORDER + SWP_NOSIZE );
        UnclipWindow( hwndDlg );
    }
    */

    CenterWindow ( hwndDlg, GetParent ( hwndDlg ) );

    //
    // pmay: 292069
    //
    // If the autodialer dialog has called into us, set focus to the
    // autodial tab.
    //
    if (pArgs->dwFlags & UP_F_AutodialMode)
    {
        PostMessage(
            hwndDlg,
            PSM_SETCURSELID,
            0,
            (LPARAM)(INT)PID_AD_AutoDial);
    }
    
    return pInfo;
}


VOID
UpTerm(
    IN HWND hwndPage )

    /* Property sheet level termination.  Releases the context block.
    ** 'HwndPage' is the handle of a property page.
    */
{
    UPINFO* pInfo;

    TRACE("UpTerm");

    pInfo = UpContext( hwndPage );

    // Only terminate for once by making sure that we 
    // only terminate if this is the first page.
    if ( (pInfo) && (pInfo->hwndFirstPage == hwndPage) )
    {
        // Cleanup the list view
        if ( pInfo->hwndLvNumbers )
        {
            CbutilLvNumbersCleanup( pInfo->hwndLvNumbers );
        }

        if (pInfo->fChecksInstalled)
        {
            ListView_UninstallChecks( pInfo->hwndLvEnable );
        }

        if (pInfo->pHlineapp && *pInfo->pHlineapp != pInfo->pArgs->hlineapp)
        {
            TapiShutdown( *pInfo->pHlineapp );
        }

        Free( pInfo );
        TRACE("Context freed");
    }

    RemoveProp( GetParent( hwndPage ), g_contextId );
}


/*----------------------------------------------------------------------------
** Auto Dial property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
AdDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Auto Dial page of the User Preferences
    ** property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("AdDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, AdLvEnableCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return
                AdInit( hwnd, (UPARGS* )(((PROPSHEETPAGE* )lparam)->lParam) );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwAdHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;
                    UPINFO* pInfo = UpContext ( hwnd );

                    TRACE("AdAPPLY");

                    // We have to apply if we are the first page...
                    if (pInfo->hwndFirstPage == hwnd)
                    {
                        /* Call UpApply only on first page.
                        */
                        fValid = UpApply( hwnd );
                        SetWindowLong(
                            hwnd, DWLP_MSGRESULT,
                            (fValid)
                                ? PSNRET_NOERROR
                                : PSNRET_INVALID_NOCHANGEPAGE );
                        return TRUE;
                    }
                }

                case PSN_RESET:
                {
                    /* Call UpCancel only on first page.
                    */
                    TRACE("AdRESET");
                    UpCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    break;
                }
            }
        }
        break;

        case WM_DESTROY:
        {
            /* UpTerm will handle making sure it only does its 
            ** thing once
            */
            UpTerm( hwnd );
            break;
        }

    }

    return FALSE;
}


VOID
AdApply(
    IN UPINFO* pInfo )

    /* Saves the contents of the property page.  'PInfo' is the property sheet
    ** context.
    */
{
    DWORD   dwErr, dwFlag;
    UINT    unValue;
    LV_ITEM item;
    INT     i, iCount;
    BOOL    f;

    TRACE("AdApply");

    if (!pInfo->pArgs->fNoUser)
    {
        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_PARAM + LVIF_STATE;

        iCount = ListView_GetItemCount( pInfo->hwndLvEnable );
        for (i = 0; i < iCount; ++i)
        {
            BOOL fCheck;

            item.iItem = i;
            if (!ListView_GetItem( pInfo->hwndLvEnable, &item ))
                break;

            fCheck = ListView_GetCheck( pInfo->hwndLvEnable, i );
            ASSERT(g_pRasSetAutodialEnable);
            dwErr = g_pRasSetAutodialEnable( (DWORD )item.lParam, fCheck );
            if (dwErr != 0)
                ErrorDlg( pInfo->hwndDlg, SID_OP_SetADialInfo, dwErr, NULL );
        }

        /* Set the autodial prompt information.
         * Flip it because the API wants true to mean "disable".
        */
        dwFlag = (DWORD )!IsDlgButtonChecked(
            pInfo->hwndAd, CID_AD_CB_AskBeforeAutodial );

        TRACE1("RasSetAutodialParam(%d)",dwFlag);
        dwErr = g_pRasSetAutodialParam( RASADP_DisableConnectionQuery,
            &dwFlag, sizeof(dwFlag) );
        TRACE1("RasSetAutodialParam=%d",dwErr);

        // 
        // pmay: 209762
        //
        // Save the "disable current session" checkbox
        //
        dwFlag = (DWORD )
            IsDlgButtonChecked(pInfo->hwndAd, CID_AD_CB_DisableThisSession );

        dwErr = g_pRasSetAutodialParam( 
                    RASADP_LoginSessionDisable,
                    &dwFlag, 
                    sizeof(dwFlag) );
    }
}


BOOL
AdFillLvEnable(
    IN UPINFO* pInfo )

    /* Initialize the listview of checkboxes.  'PInfo' is the property sheet
    ** context.
    **
    ** Note: This routine must only be called once.
    **
    ** Returns true if focus is set, false otherwise.
    */
{
    DWORD     dwErr;
    LOCATION* pLocations;
    DWORD     cLocations;
    DWORD     dwCurLocation;
    BOOL      fFocusSet;

    fFocusSet = FALSE;
    ListView_DeleteAllItems( pInfo->hwndLvEnable );

    /* Install "listview of check boxes" handling.
    */
    pInfo->fChecksInstalled =
        ListView_InstallChecks( pInfo->hwndLvEnable, g_hinstDll );
    if (!pInfo->fChecksInstalled)
        return FALSE;

    /* Insert an item for each location.
    */
    pLocations = NULL;
    cLocations = 0;
    dwCurLocation = 0xFFFFFFFF;
    dwErr = GetLocationInfo( g_hinstDll, pInfo->pHlineapp,
                &pLocations, &cLocations, &dwCurLocation );
    if (dwErr != 0)
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadTapiInfo, dwErr, NULL );
    else
    {
        LV_ITEM   item;
        LOCATION* pLocation;
        TCHAR*    pszCurLoc;
        DWORD     i;

        pszCurLoc = PszFromId( g_hinstDll, SID_IsCurLoc );

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT + LVIF_PARAM;

        for (i = 0, pLocation = pLocations;
             i < cLocations;
            ++i, ++pLocation)
        {
            TCHAR* psz;
            TCHAR* pszText;
            DWORD  cb;

            pszText = NULL;
            psz = StrDup( pLocation->pszName );
            if (psz)
            {
                if (dwCurLocation == pLocation->dwId && pszCurLoc)
                {
                    /* This is the current globally selected location.  Append
                    ** the " (the current location)" text.
                    */
                    cb = lstrlen( psz ) + lstrlen(pszCurLoc) + 1;
                    pszText = Malloc( cb * sizeof(TCHAR) );
                    if (pszText)
                    {
                        // Whistler bug 224074 use only lstrcpyn's to prevent
                        // maliciousness
                        //
                        lstrcpyn(
                            pszText,
                            psz,
                            cb );
                        lstrcat( pszText, pszCurLoc );
                    }
                    Free( psz );
                }
                else
                    pszText = psz;
            }

            if (pszText)
            {
                BOOL fCheck;

                /* Get the initial check value for this location.
                */
                ASSERT(g_pRasGetAutodialEnable);
                dwErr = g_pRasGetAutodialEnable( pLocation->dwId, &fCheck );
                if (dwErr != 0)
                {
                    ErrorDlg( pInfo->hwndDlg, SID_OP_GetADialInfo,
                        dwErr, NULL );
                    fCheck = FALSE;
                }

                item.iItem = i;
                item.lParam = pLocation->dwId;
                item.pszText = pszText;
                ListView_InsertItem( pInfo->hwndLvEnable, &item );
                ListView_SetCheck( pInfo->hwndLvEnable, i, fCheck );

                if (dwCurLocation == pLocation->dwId)
                {
                    /* Initial selection is the current location.
                    */
                    ListView_SetItemState( pInfo->hwndLvEnable, i,
                        LVIS_SELECTED + LVIS_FOCUSED,
                        LVIS_SELECTED + LVIS_FOCUSED );
                    fFocusSet = TRUE;
                }

                Free( pszText );
            }
        }

        Free0( pszCurLoc );
        FreeLocationInfo( pLocations, cLocations );

        /* Add a single column exactly wide enough to fully display the widest
        ** member of the list.
        */
        {
            LV_COLUMN col;

            ZeroMemory( &col, sizeof(col) );
            col.mask = LVCF_FMT;
            col.fmt = LVCFMT_LEFT;
            ListView_InsertColumn( pInfo->hwndLvEnable, 0, &col );
            ListView_SetColumnWidth(
                pInfo->hwndLvEnable, 0, LVSCW_AUTOSIZE_USEHEADER );
        }
    }

    return fFocusSet;
}


BOOL
AdInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO* pInfo;
    BOOL    fFocusSet;
    HWND    hwndUdAttempts;
    HWND    hwndUdSeconds;
    HWND    hwndUdIdle;
    DWORD   dwErr;

    TRACE("AdInit");

    /* We're first page, if the user isn't
     * an admin.
    */
    pInfo = UpInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    // Make sure that a default location is created if there isn't one.  bug
    // 168631
    //
    dwErr = TapiNoLocationDlg( g_hinstDll, &(pInfo->pArgs->hlineapp), hwndPage );
    if (dwErr != 0)
    {
        // Error here is treated as a "cancel" per bug 288385.
        //
        return TRUE;
    }

    /* Initialize page-specific context information.
    */
    pInfo->hwndAd = hwndPage;
    if (!pArgs->fNoUser)
    {
        pInfo->hwndLvEnable = GetDlgItem( hwndPage, CID_AD_LV_Enable );
        ASSERT(pInfo->hwndLvEnable);
    }

    if (!pArgs->fNoUser)
    {
        DWORD dwFlag, dwErr;
        DWORD cb;

        /* Initialize the listview.
        */
        fFocusSet = AdFillLvEnable( pInfo );

        /* Initialize autodial parameters.
        */
        dwFlag = FALSE;
        cb = sizeof(dwFlag);
        TRACE("RasGetAutodialParam(DCQ)");
        dwErr = g_pRasGetAutodialParam(
            RASADP_DisableConnectionQuery, &dwFlag, &cb );
        TRACE1("RasGetAutodialParam=%d",dwErr);

        /* Flip it because the API wants true to mean "disable".
        */
        CheckDlgButton( hwndPage, CID_AD_CB_AskBeforeAutodial, (BOOL )!dwFlag );

        // 
        // pmay: 209762
        //
        // Initialize the "disable current session" checkbox
        //
        dwFlag = FALSE;
        cb = sizeof(dwFlag);
        dwErr = g_pRasGetAutodialParam(
            RASADP_LoginSessionDisable, &dwFlag, &cb );
            
        CheckDlgButton( 
            hwndPage, 
            CID_AD_CB_DisableThisSession, 
            (BOOL )dwFlag );
    }

    return !fFocusSet;
}


LVXDRAWINFO*
AdLvEnableCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the draw information.
    */
{
    /* The enhanced list view is used only to get the "wide selection bar"
    ** feature so our option list is not very interesting.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info = { 1, 0, 0, { 0 } };

    return &info;
}


/*----------------------------------------------------------------------------
** Callback property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
CbDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Callback page of the User Preferences
    ** property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("CbDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    if (ListView_OwnerHandler(
            hwnd, unMsg, wparam, lparam, CbutilLvNumbersCallback ))
    {
        return TRUE;
    }

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CbInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwCbHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case NM_DBLCLK:
                {
                    UPINFO* pInfo = UpContext( hwnd );
                    ASSERT(pInfo);
                    SendMessage( pInfo->hwndPbEdit, BM_CLICK, 0, 0 );
                    return TRUE;
                }

                case LVN_ITEMCHANGED:
                {
                    UPINFO* pInfo = UpContext( hwnd );
                    ASSERT(pInfo);
                    CbUpdateLvAndPbState( pInfo );
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            UPINFO* pInfo = UpContext( hwnd );
            ASSERT(pInfo);

            return CbCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }
    }

    return FALSE;
}


VOID
CbApply(
    IN UPINFO* pInfo )

    /* Saves the contents of the property page.  'PInfo' is the property sheet
    ** context.
    */
{
    TRACE("CbApply");

    if (IsDlgButtonChecked( pInfo->hwndCb, CID_CB_RB_No ))
        pInfo->user.dwCallbackMode = CBM_No;
    else if (IsDlgButtonChecked( pInfo->hwndCb, CID_CB_RB_Maybe ))
        pInfo->user.dwCallbackMode = CBM_Maybe;
    else
        pInfo->user.dwCallbackMode = CBM_Yes;

    CbutilSaveLv( pInfo->hwndLvNumbers, pInfo->user.pdtllistCallback );
}


BOOL
CbCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("CbCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_CB_RB_No:
        case CID_CB_RB_Maybe:
        case CID_CB_RB_Yes:
        {
            if (wNotification == BN_CLICKED)
            {
                CbUpdateLvAndPbState( pInfo );

                if (wId == CID_CB_RB_Yes
                    && ListView_GetSelectedCount( pInfo->hwndLvNumbers ) == 0)
                {
                    /* Nothing's selected, so select the first item, if any.
                    */
                    ListView_SetItemState( pInfo->hwndLvNumbers, 0,
                        LVIS_SELECTED, LVIS_SELECTED );
                }
            }
            break;
        }

        case CID_CB_PB_Edit:
        {
            if (wNotification == BN_CLICKED)
                CbutilEdit( pInfo->hwndCb, pInfo->hwndLvNumbers );
            break;
        }

        case CID_CB_PB_Delete:
        {
            if (wNotification == BN_CLICKED)
                CbutilDelete( pInfo->hwndCb, pInfo->hwndLvNumbers );
            break;
        }
    }

    return FALSE;
}


BOOL
CbInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO* pInfo;

    TRACE("CbInit");

    pInfo = UpContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndCb = hwndPage;
    pInfo->hwndRbNo = GetDlgItem( hwndPage, CID_CB_RB_No );
    ASSERT(pInfo->hwndRbNo);
    pInfo->hwndRbMaybe = GetDlgItem( hwndPage, CID_CB_RB_Maybe );
    ASSERT(pInfo->hwndRbMaybe);
    pInfo->hwndRbYes = GetDlgItem( hwndPage, CID_CB_RB_Yes );
    ASSERT(pInfo->hwndRbYes);
    pInfo->hwndLvNumbers = GetDlgItem( hwndPage, CID_CB_LV_Numbers );
    ASSERT(pInfo->hwndLvNumbers);
    pInfo->hwndPbEdit = GetDlgItem( hwndPage, CID_CB_PB_Edit );
    ASSERT(pInfo->hwndPbEdit);
    pInfo->hwndPbDelete = GetDlgItem( hwndPage, CID_CB_PB_Delete );
    ASSERT(pInfo->hwndPbDelete);

    /* Initialize the listview.
    */
    CbutilFillLvNumbers(
        pInfo->hwndCb, pInfo->hwndLvNumbers,
        pInfo->user.pdtllistCallback, FALSE );

    /* Set the radio button selection, which triggers appropriate
    ** enabling/disabling.
    */
    {
        HWND  hwndRb;

        if (pInfo->user.dwCallbackMode == CBM_No)
            hwndRb = pInfo->hwndRbNo;
        else if (pInfo->user.dwCallbackMode == CBM_Maybe)
            hwndRb = pInfo->hwndRbMaybe;
        else
        {
            ASSERT(pInfo->user.dwCallbackMode==CBM_Yes);
            hwndRb = pInfo->hwndRbYes;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    // pmay: If there are no devices available for callback,
    // add some explanatory text and disable appropriate
    // controls.  Bug 168830
    if (ListView_GetItemCount(pInfo->hwndLvNumbers) == 0)
    {
        // Uncheck if needed
        if (Button_GetCheck(pInfo->hwndRbYes))
        {
            Button_SetCheck(pInfo->hwndRbMaybe, TRUE);
        }

        // Disable the windows.
        EnableWindow(pInfo->hwndRbYes, FALSE);
        EnableWindow(pInfo->hwndLvNumbers, FALSE);
    }
    
    return TRUE;
}


VOID
CbUpdateLvAndPbState(
    IN UPINFO* pInfo )

    /* Enables/disables the list view and associated buttons.  ListView is
    ** gray unless auto-callback is selected.  Buttons gray unless
    ** auto-callback selected and there is an item selected.
    */
{
    BOOL fEnableList;
    BOOL fEnableEditButton, fEnableDeleteButton;
    INT  iSel;
    HWND hwndLv;

    // By default, we don't enable any buttons
    fEnableDeleteButton = FALSE;
    fEnableEditButton = FALSE;
    
    // Only enable the list view if Yes is selected
    //
    fEnableList = Button_GetCheck( pInfo->hwndRbYes );
    if (fEnableList)
    {
        hwndLv = pInfo->hwndLvNumbers;

        if ( ListView_GetSelectedCount( hwndLv ) )
        {
            // The edit button should only be enabled if the 
            // listview is enabled and if one or more
            // items is selected.
            fEnableEditButton = TRUE;

            //
            // pmay: 213060
            //
            // The delete button is only enabled if all of the selected
            // devices are not configured on the system. (since only 
            // non-installed devices can be removed from the list).
            //
            fEnableDeleteButton = TRUE;
            for (iSel = ListView_GetNextItem( hwndLv, -1, LVNI_SELECTED );
                 iSel >= 0;
                 iSel = ListView_GetNextItem( hwndLv, iSel, LVNI_SELECTED )
                )
            {
                LV_ITEM item;
                ZeroMemory(&item, sizeof(item));

                item.iItem = iSel;
                item.mask = LVIF_PARAM;
                
                if ( ListView_GetItem(hwndLv, &item) )
                {
                    if (((CBCONTEXT*)item.lParam)->fConfigured)
                    {
                        fEnableDeleteButton = FALSE;
                    }
                }
            }  
        }            
    }

    EnableWindow( pInfo->hwndLvNumbers, fEnableList );
    EnableWindow( pInfo->hwndPbEdit, fEnableEditButton );
    EnableWindow( pInfo->hwndPbDelete, fEnableDeleteButton );
}

/*-----------------------------------------------------
** Utilities shared with router version of the listview
**-----------------------------------------------------
*/

VOID
CbutilDelete(
    IN HWND  hwndDlg,
    IN HWND  hwndLvNumbers )

    /* Called when the Delete button is pressed.  'PInfo' is the dialog
    ** context.
    */
{
    MSGARGS msgargs;
    INT     nResponse;

    TRACE("CbDelete");

    ZeroMemory( &msgargs, sizeof(msgargs) );
    msgargs.dwFlags = MB_YESNO + MB_ICONEXCLAMATION;
    nResponse = MsgDlg( hwndDlg, SID_ConfirmDelDevice, &msgargs );
    if (nResponse == IDYES)
    {
        INT iSel;

        /* User has confirmed deletion of selected devices, so do it.
        */
        while ((iSel = ListView_GetNextItem(
                           hwndLvNumbers, -1, LVNI_SELECTED )) >= 0)
        {
            ListView_DeleteItem( hwndLvNumbers, iSel );
        }
    }
}


VOID
CbutilEdit(
    IN HWND hwndDlg,
    IN HWND hwndLvNumbers )

    /* Called when the Edit button is pressed.  'HwndDlg' is the page/dialog
    ** window.  'HwndLvNumbers' is the callback number listview window.
    */
{
    INT    iSel;
    TCHAR  szBuf[ RAS_MaxCallbackNumber + 1 ];
    TCHAR* pszNumber;

    TRACE("CbutilEdit");

    /* Load 'szBuf' with the current phone number of the first selected item.
    */
    iSel = ListView_GetNextItem( hwndLvNumbers, -1, LVNI_SELECTED );
    if (iSel < 0)
        return;
    szBuf[ 0 ] = TEXT('\0');
    ListView_GetItemText( hwndLvNumbers, iSel, 1,
        szBuf, RAS_MaxCallbackNumber + 1 );

    /* Popup dialog to edit the number.
    */
    pszNumber = NULL;
    if (StringEditorDlg( hwndDlg, szBuf,
            SID_EcbnTitle, SID_EcbnLabel, RAS_MaxCallbackNumber,
            HID_ZE_ST_CallbackNumber, &pszNumber ))
    {
        /* OK pressed, so change the number on all selected items.
        */
        ASSERT(pszNumber);

        do
        {
            ListView_SetItemText( hwndLvNumbers, iSel, 1, pszNumber );
        }
        while ((iSel = ListView_GetNextItem(
                           hwndLvNumbers, iSel, LVNI_SELECTED )) >= 0);
    }
}


VOID
CbutilFillLvNumbers(
    IN HWND     hwndDlg,
    IN HWND     hwndLvNumbers,
    IN DTLLIST* pListCallback,
    IN BOOL     fRouter )

    /* Fill the listview with devices and phone numbers.  'HwndDlg' is the
    ** page/dialog window.  'HwndLvNumbers' is the callback listview.
    ** 'PListCallback' is the list of CALLBACKINFO.  'FRouter' is true if the
    ** router ports should be enumerated, or false for regular dial-out ports.
    **
    ** Note: This routine should be called only once.
    */
{
    DWORD    dwErr;
    DTLLIST* pListPorts;
    DTLNODE* pNodeCbi;
    DTLNODE* pNodePort;
    INT      iItem;
    TCHAR*   psz;

    TRACE("CbutilFillLvNumbers");

    ListView_DeleteAllItems( hwndLvNumbers );

    /* Add columns.
    */
    {
        LV_COLUMN col;
        TCHAR*    pszHeader0;
        TCHAR*    pszHeader1;

        pszHeader0 = PszFromId( g_hinstDll, SID_DeviceColHead );
        pszHeader1 = PszFromId( g_hinstDll, SID_PhoneNumberColHead );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader0) ? pszHeader0 : TEXT("");
        ListView_InsertColumn( hwndLvNumbers, 0, &col );

        ZeroMemory( &col, sizeof(col) );
        col.mask = LVCF_FMT + LVCF_SUBITEM + LVCF_TEXT;
        col.fmt = LVCFMT_LEFT;
        col.pszText = (pszHeader1) ? pszHeader1 : TEXT("");
        col.iSubItem = 1;
        ListView_InsertColumn( hwndLvNumbers, 1, &col );

        Free0( pszHeader0 );
        Free0( pszHeader1 );
    }

    /* Add the modem and adapter images.
    */
    ListView_SetDeviceImageList( hwndLvNumbers, g_hinstDll );

    /* Load listview with callback device/number pairs saved as user
    ** preferences.
    */
    iItem = 0;
    ASSERT(pListCallback);
    for (pNodeCbi = DtlGetFirstNode( pListCallback );
         pNodeCbi;
         pNodeCbi = DtlGetNextNode( pNodeCbi ), ++iItem)
    {
        CALLBACKINFO* pCbi;
        LV_ITEM       item;

        pCbi = (CALLBACKINFO* )DtlGetData( pNodeCbi );
        ASSERT(pCbi);
        ASSERT(pCbi->pszPortName);
        ASSERT(pCbi->pszDeviceName);
        ASSERT(pCbi->pszNumber);

        if (pCbi->dwDeviceType != RASET_Vpn) {
            psz = PszFromDeviceAndPort( pCbi->pszDeviceName, pCbi->pszPortName );
            if (psz)
            {
                // pmay: 213060
                //
                // Allocate and initialize the context.
                //
                CBCONTEXT * pCbCtx;

                pCbCtx = (CBCONTEXT*) Malloc (sizeof(CBCONTEXT));
                if (pCbCtx == NULL)
                {
                    continue;
                }
                pCbCtx->pszPortName = pCbi->pszPortName;
                pCbCtx->pszDeviceName = pCbi->pszDeviceName;
                pCbCtx->dwDeviceType = pCbi->dwDeviceType;
                pCbCtx->fConfigured = FALSE;
            
                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                item.iItem = iItem;
                item.pszText = psz;
                item.iImage =
                    ((PBDEVICETYPE )pCbi->dwDeviceType == PBDT_Modem)
                        ? DI_Modem : DI_Adapter;
                item.lParam = (LPARAM )pCbCtx;
                ListView_InsertItem( hwndLvNumbers, &item );
                ListView_SetItemText( hwndLvNumbers, iItem, 1, pCbi->pszNumber );
                Free( psz );
            }
        }
    }

    /* Add any devices installed but not already in the list.
    */
    dwErr = LoadPortsList2( NULL, &pListPorts, fRouter );
    if (dwErr != 0)
    {
        ErrorDlg( hwndDlg, SID_OP_LoadPortInfo, dwErr, NULL );
    }
    else
    {
        for (pNodePort = DtlGetFirstNode( pListPorts );
             pNodePort;
             pNodePort = DtlGetNextNode( pNodePort ))
        {
            PBPORT* pPort = (PBPORT* )DtlGetData( pNodePort );
            INT i = -1;
            BOOL bPortAlreadyInLv = FALSE;
            ASSERT(pPort);

            // pmay: 213060
            //
            // Search for the configured item in the list view
            //
            while ((i = ListView_GetNextItem( 
                            hwndLvNumbers, 
                            i, 
                            LVNI_ALL )) >= 0)
            {
                LV_ITEM item;
                CBCONTEXT * pCbCtx;
                
                ZeroMemory( &item, sizeof(item) );
                item.mask = LVIF_PARAM;
                item.iItem = i;
                if (!ListView_GetItem( hwndLvNumbers, &item ))
                {
                    continue;
                }

                // Get the context
                //
                pCbCtx = (CBCONTEXT*)item.lParam;
                if (! pCbCtx)
                {
                    continue;
                }

                // If the current item in the list view matches the 
                // current port, then we know that the current item
                // is configured on the system.
                if ((lstrcmpi( pPort->pszPort, pCbCtx->pszPortName ) == 0) &&
                    (lstrcmpi( pPort->pszDevice, pCbCtx->pszDeviceName ) == 0)
                   )
                {
                    bPortAlreadyInLv = TRUE;
                    pCbCtx->fConfigured = TRUE;
                    break;
                }
            }
            
            if (! bPortAlreadyInLv)
            {
                LV_ITEM      item;
                PBDEVICETYPE pbdt;

                /* The device/port was not in the callback list.  Append it 
                ** to the listview with empty phone number.
                */
                if ((pPort->dwType != RASET_Vpn) && 
                    (pPort->dwType != RASET_Direct) &&
                    (pPort->dwType != RASET_Broadband)
                   ) 
                {
                    psz = PszFromDeviceAndPort( 
                                pPort->pszDevice, 
                                pPort->pszPort );
                    if (psz)
                    {
                        // pmay: 213060
                        //
                        // Allocate and initialize the context.
                        //
                        CBCONTEXT * pCbCtx;

                        pCbCtx = (CBCONTEXT*) Malloc (sizeof(CBCONTEXT));
                        if (pCbCtx == NULL)
                        {
                            continue;
                        }
                        pCbCtx->pszPortName = pPort->pszPort;
                        pCbCtx->pszDeviceName = pPort->pszDevice;
                        pCbCtx->dwDeviceType = (DWORD) pPort->pbdevicetype;
                        pCbCtx->fConfigured = TRUE;

                        ZeroMemory( &item, sizeof(item) );
                        item.mask = LVIF_TEXT + LVIF_IMAGE + LVIF_PARAM;
                        item.iItem = iItem;
                        item.pszText = psz;
                        item.iImage =
                            (pPort->pbdevicetype == PBDT_Modem)
                                ? DI_Modem : DI_Adapter;
                        item.lParam = (LPARAM ) pCbCtx;
                        ListView_InsertItem( hwndLvNumbers, &item );
                        ListView_SetItemText( 
                            hwndLvNumbers, 
                            iItem, 
                            1, 
                            TEXT(""));
                        ++iItem;
                        Free( psz );
                    }
                }
            }
        }

        DtlDestroyList( pListPorts, DestroyPortNode );
    }

    /* Auto-size columns to look good with the text they contain.
    */
    ListView_SetColumnWidth( hwndLvNumbers, 0, LVSCW_AUTOSIZE_USEHEADER );
    ListView_SetColumnWidth( hwndLvNumbers, 1, LVSCW_AUTOSIZE_USEHEADER );
}

VOID
CbutilLvNumbersCleanup(
    IN  HWND    hwndLvNumbers )

    /* Cleans up after CbutilFillLvNumbers.
    */
{
    INT      i;
    
    i = -1;
    while ((i = ListView_GetNextItem( hwndLvNumbers, i, LVNI_ALL )) >= 0)
    {
        LV_ITEM item;

        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_PARAM;
        item.iItem = i;
        if (!ListView_GetItem( hwndLvNumbers, &item ))
            continue;

        // Free the context
        Free0( (PVOID) item.lParam );
    }
}


LVXDRAWINFO*
CbutilLvNumbersCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )

    /* Enhanced list view callback to report drawing information.  'HwndLv' is
    ** the handle of the list view control.  'DwItem' is the index of the item
    ** being drawn.
    **
    ** Returns the address of the column information.
    */
{
    /* Use "wide selection bar" feature and the other recommended options.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info =
        { 2, 0, LVXDI_Blend50Dis + LVXDI_DxFill, { 0, 0 } };

    return &info;
}


VOID
CbutilSaveLv(
    IN  HWND     hwndLvNumbers,
    OUT DTLLIST* pListCallback )

    /* Replace list 'pListCallback' contents with that of the listview
    ** 'hwndLvNumbers'.
    */
{
    DTLNODE* pNode;
    INT      i;

    TRACE("CbutilSaveLv");

    /* Empty the list of callback info, then re-populate from the listview.
    */
    while (pNode = DtlGetFirstNode( pListCallback ))
    {
        DtlRemoveNode( pListCallback, pNode );
        DestroyCallbackNode( pNode );
    }

    i = -1;
    while ((i = ListView_GetNextItem( hwndLvNumbers, i, LVNI_ALL )) >= 0)
    {
        LV_ITEM item;
        TCHAR*  pszDevice;
        TCHAR*  pszPort;

        TCHAR szDP[ RAS_MaxDeviceName + 2 + MAX_PORT_NAME + 1 + 1 ];
        TCHAR szNumber[ RAS_MaxCallbackNumber + 1 ];

        szDP[ 0 ] = TEXT('\0');
        ZeroMemory( &item, sizeof(item) );
        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = i;
        item.pszText = szDP;
        item.cchTextMax = sizeof(szDP) / sizeof(TCHAR);
        if (!ListView_GetItem( hwndLvNumbers, &item ))
            continue;

        szNumber[ 0 ] = TEXT('\0');
        ListView_GetItemText( hwndLvNumbers, i, 1,
            szNumber, RAS_MaxCallbackNumber + 1 );

        if (!DeviceAndPortFromPsz( szDP, &pszDevice, &pszPort ))
            continue;

        pNode = CreateCallbackNode(
                    pszPort, 
                    pszDevice, 
                    szNumber, 
                    ((CBCONTEXT*)item.lParam)->dwDeviceType );
        if (pNode)
            DtlAddNodeLast( pListCallback, pNode );

        Free( pszDevice );
        Free( pszPort );
    }
}

/*----------------------------------------------------------------------------
** Connections Preferences property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/
INT_PTR CALLBACK
CoDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )
{
    switch (unMsg)
    {
        case WM_INITDIALOG:
            return CoInit( hwnd, (UPARGS* )(((PROPSHEETPAGE* )lparam)->lParam) );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwCoHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_APPLY:
                {
                    BOOL fValid;
                    UPINFO *pUpInfo;

                    TRACE("CoAPPLY");

                    pUpInfo = UpContext(hwnd);

                    if(NULL != pUpInfo)
                    {
                        CoApply( pUpInfo );
                    }

                    /* Call UpApply only on first page.
                    */
                    fValid = UpApply( hwnd );
                    SetWindowLong(
                        hwnd, DWLP_MSGRESULT,
                        (fValid)
                            ? PSNRET_NOERROR
                            : PSNRET_INVALID_NOCHANGEPAGE );
                    return TRUE;
                }
            }
            break;
        }

    }

    return FALSE;
}

BOOL
CoApply(
    IN UPINFO* pInfo )

    // Return true to allow application of property sheet, false
    // to refuse.
{
    // If we're not the logon user, go ahead and commit 
    // the global phonebook editing flag.
    if (! pInfo->pArgs->fNoUser )
    {
        BOOL bAllow;

        bAllow = IsDlgButtonChecked( 
                    pInfo->hwndCo, 
                    CID_CO_CB_AllowConnectionModification );

        if ( (!!bAllow) != (!!pInfo->userLogon.fAllowLogonPhonebookEdits) )
        {
            pInfo->userLogon.fAllowLogonPhonebookEdits = !!bAllow;
            pInfo->userLogon.fDirty = TRUE;
        }
    }

    return TRUE;
}

BOOL
CoInit(
    IN     HWND    hwndPage,
    IN OUT UPARGS* pArgs )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.  'PArgs' is the arguments from the PropertySheet caller.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO * pInfo = NULL;

    /* We're first page, so initialize the property sheet.
    */
    pInfo = UpInit( hwndPage, pArgs );
    if (!pInfo)
        return TRUE;

    pInfo->hwndCo = hwndPage;

    // Set the flag for allowing phonebook edits
    if (! pInfo->pArgs->fNoUser )
    {
        Button_SetCheck (
            GetDlgItem (pInfo->hwndCo, CID_CO_CB_AllowConnectionModification),
            pInfo->userLogon.fAllowLogonPhonebookEdits);
    }                         

    return TRUE;
}

#if 0
/*----------------------------------------------------------------------------
** General Preferences property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
GpDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the General page of the User Preferences
    ** property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("GpDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return GpInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwGpHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_NOTIFY:
        {
            switch (((NMHDR* )lparam)->code)
            {
                case PSN_RESET:
                {
                    /* Call UpCancel only on first page.
                    */
                    TRACE("GpRESET");
                    UpCancel( hwnd );
                    SetWindowLong( hwnd, DWLP_MSGRESULT, FALSE );
                    break;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            UPINFO* pInfo = UpContext( hwnd );
            ASSERT(pInfo);

            return GpCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ),(HWND )lparam );
        }

        case WM_DESTROY:
        {
            /* UpTerm will handle making sure it only does its 
            ** thing once
            */
            UpTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


VOID
GpApply(
    IN UPINFO* pInfo )

    /* Saves the contents of the property page.  'PInfo' is the property sheet
    ** context.
    */
{
    DWORD dwErr;

    TRACE("GpApply");

    pInfo->user.fUseLocation =
        IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_Location );

    pInfo->user.fPreviewPhoneNumber =
        IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_Preview );

    pInfo->user.fShowConnectStatus =
        IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_Progress );

    pInfo->user.fCloseOnDial =
        IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_CloseOnDial );

    pInfo->user.fNewEntryWizard =
        IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_UseWizard );

    if (pInfo->pArgs->fNoUser)
    {
        pInfo->user.fAllowLogonPhonebookEdits =
            IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_PhonebookEdits );

        pInfo->user.fAllowLogonLocationEdits =
            IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_LocationEdits );
    }
    else
    {
        DWORD dwFlag;

        pInfo->user.fShowLights =
            IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_Lights );

        /* Flip it because the API wants true to mean "disable".
        */
        dwFlag = (DWORD )!IsDlgButtonChecked(
            pInfo->hwndGp, CID_GP_CB_AutodialPrompt );

        TRACE1("RasSetAutodialParam(%d)",dwFlag);
        dwErr = g_pRasSetAutodialParam( RASADP_DisableConnectionQuery,
            &dwFlag, sizeof(dwFlag) );
        TRACE1("RasSetAutodialParam=%d",dwErr);
    }
}


BOOL
GpCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("GpCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    if (pInfo->pArgs->fNoUser)
    {
        switch (wId)
        {
            case CID_GP_CB_Location:
            case CID_GP_CB_PhonebookEdits:
            {
                if (wNotification == BN_CLICKED)
                    GpUpdateCbStates( pInfo );
            }
            break;
        }
    }

    return FALSE;
}


BOOL
GpInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    DWORD   dwErr;
    UPINFO* pInfo;

    TRACE("GpInit");

    pInfo = UpContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndGp = hwndPage;

    /* Initialize page.
    */
    CheckDlgButton( hwndPage, CID_GP_CB_Preview,
        pInfo->user.fPreviewPhoneNumber );

    CheckDlgButton( hwndPage, CID_GP_CB_Location,
        pInfo->user.fUseLocation );

    CheckDlgButton( hwndPage, CID_GP_CB_Progress,
        pInfo->user.fShowConnectStatus );

    CheckDlgButton( hwndPage, CID_GP_CB_CloseOnDial,
        pInfo->user.fCloseOnDial );

    CheckDlgButton( hwndPage, CID_GP_CB_UseWizard,
        pInfo->user.fNewEntryWizard );

    if (pInfo->pArgs->fNoUser)
    {
        /* Edit restriction check boxes for logon mode only.
        */
        CheckDlgButton( hwndPage, CID_GP_CB_PhonebookEdits,
            pInfo->user.fAllowLogonPhonebookEdits );

        CheckDlgButton( hwndPage, CID_GP_CB_LocationEdits,
            pInfo->user.fAllowLogonLocationEdits );

        GpUpdateCbStates( pInfo );
    }
    else
    {
        DWORD dwFlag;
        DWORD cb;

        /* Start rasmon check box for non-logon mode only.
        */
        CheckDlgButton( hwndPage, CID_GP_CB_Lights,
            pInfo->user.fShowLights );

        /* Autodial prompt check box for non-logon mode only.
        */
        dwFlag = FALSE;
        cb = sizeof(dwFlag);
        TRACE("RasGetAutodialParam(DCQ)");
        dwErr = g_pRasGetAutodialParam(
            RASADP_DisableConnectionQuery, &dwFlag, &cb );
        TRACE1("RasGetAutodialParam=%d",dwErr);

        /* Flip it because the API wants true to mean "disable".
        */
        CheckDlgButton( hwndPage, CID_GP_CB_AutodialPrompt, (BOOL )!dwFlag );
    }

    return TRUE;
}


VOID
GpUpdateCbStates(
    IN UPINFO* pInfo )

    /* Updates the enable/disable state of dependent checkboxes.
    */
{
    BOOL fLocation;
    BOOL fPbEdits;

    ASSERT(pInfo->pArgs->fNoUser);

    fLocation = IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_Location );
    if (!fLocation)
        CheckDlgButton( pInfo->hwndGp, CID_GP_CB_LocationEdits, FALSE );
    EnableWindow( GetDlgItem( pInfo->hwndGp, CID_GP_CB_LocationEdits ),
        fLocation );

    fPbEdits = IsDlgButtonChecked( pInfo->hwndGp, CID_GP_CB_PhonebookEdits );
    if (!fPbEdits)
        CheckDlgButton( pInfo->hwndGp, CID_GP_CB_UseWizard, FALSE );
    EnableWindow( GetDlgItem( pInfo->hwndGp, CID_GP_CB_UseWizard ),
        fPbEdits );
}


/*----------------------------------------------------------------------------
** Phone List property page
** Listed alphabetically following dialog proc
**----------------------------------------------------------------------------
*/

INT_PTR CALLBACK
PlDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    /* DialogProc callback for the Phone List page of the User Preferences
    ** Property sheet.  Parameters and return value are as described for
    ** standard windows 'DialogProc's.
    */
{
#if 0
    TRACE4("PlDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD)hwnd,(DWORD)unMsg,(DWORD)wparam,(DWORD)lparam);
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
            return PlInit( hwnd );

        case WM_HELP:
        case WM_CONTEXTMENU:
            ContextHelp( g_adwPlHelp, hwnd, unMsg, wparam, lparam );
            break;

        case WM_COMMAND:
        {
            UPINFO* pInfo = UpContext( hwnd );
            ASSERT(pInfo);

            return PlCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }
    }

    return FALSE;
}


BOOL
PlApply(
    IN UPINFO* pInfo )

    /* Saves the contents of the property page.  'PInfo' is the property sheet
    ** context.
    **
    ** Returns false if invalid and can't dismiss, otherwise true.
    */
{
    DWORD   dwErr;
    DWORD   dwOldMode;
    DWORD   dwNewMode;
    TCHAR*  pszOldPersonal;
    TCHAR*  pszNewPersonal;
    TCHAR*  pszOldAlternate;
    TCHAR*  pszNewAlternate;
    PBFILE* pFile;

    TRACE("PlApply");

    dwOldMode = pInfo->user.dwPhonebookMode;
    if (Button_GetCheck( pInfo->hwndRbSystem ))
        dwNewMode = PBM_System;
    else if (Button_GetCheck( pInfo->hwndRbPersonal ))
        dwNewMode = PBM_Personal;
    else
        dwNewMode = PBM_Alternate;

    if (!pInfo->user.pszAlternatePath)
        pInfo->user.pszAlternatePath = StrDup( TEXT("") );

    if (!pInfo->user.pszPersonalFile)
        pInfo->user.pszPersonalFile = StrDup( TEXT("") );

    pszOldAlternate = pInfo->user.pszAlternatePath;
    pszOldPersonal = pInfo->user.pszPersonalFile;

    pszNewAlternate = GetText( pInfo->hwndClbAlternates );
    if (!pszOldAlternate || !pszOldPersonal || !pszNewAlternate)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPhonebook,
            ERROR_NOT_ENOUGH_MEMORY, NULL );
        return TRUE;
    }

    if (dwNewMode == PBM_Alternate && IsAllWhite( pszNewAlternate ))
    {
        /* Alternate phonebook mode, but no path.  Tell user to fix it.
        */
        MsgDlg( pInfo->hwndDlg, SID_NoAltPath, NULL );
        //PropSheet_SetCurSel( pInfo->hwndDlg, NULL, UP_PlPage );
        SetFocus( pInfo->hwndClbAlternates );
        ComboBox_SetEditSel( pInfo->hwndClbAlternates, 0, -1 );
        return FALSE;
    }

    if (dwNewMode == dwOldMode
        && (dwNewMode != PBM_Alternate
            || lstrcmpi( pszNewAlternate, pszOldAlternate ) == 0))
    {
        /* User made no changes.
        */
        TRACE("No phonebook change.");
        Free0( pszNewAlternate );
        return TRUE;
    }

    /* User changed phonebook settings.
    */
    if (dwNewMode == PBM_Personal && IsAllWhite( pszOldPersonal ))
    {
        /* Create the personal phonebook and tell user what happened.
        */
        dwErr = InitPersonalPhonebook( &pszNewPersonal );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_MakePhonebook, dwErr, NULL );
            Free( pszNewAlternate );
            return TRUE;
        }

        ASSERT(pszNewPersonal);
        MsgDlg( pInfo->hwndDlg, SID_NewPhonebook, NULL );
    }
    else
        pszNewPersonal = NULL;

    pInfo->user.dwPhonebookMode = dwNewMode;
    pInfo->user.pszAlternatePath = pszNewAlternate;
    if (pszNewPersonal)
        pInfo->user.pszPersonalFile = pszNewPersonal;

    if (pInfo->pArgs->ppFile)
    {
        /* Open the new phonebook returning the associated file context block
        ** to the stub API caller.
        */
        pFile = Malloc( sizeof(*pFile) );
        if (!pFile)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPhonebook,
                ERROR_NOT_ENOUGH_MEMORY, NULL );
            Free0( pszNewPersonal );
            Free0( pszNewAlternate );
            return TRUE;
        }

        dwErr = ReadPhonebookFile( NULL, &pInfo->user, NULL, 0, pFile );
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_LoadPhonebook,
                ERROR_NOT_ENOUGH_MEMORY, NULL );
            pInfo->user.dwPhonebookMode = dwOldMode;
            pInfo->user.pszAlternatePath = pszOldAlternate;
            if (pszNewPersonal)
                pInfo->user.pszPersonalFile = pszOldPersonal;
            Free0( pszNewPersonal );
            Free0( pszNewAlternate );
            Free( pFile );
            return TRUE;
        }

        /* Return opened file to stub API caller.
        */
        *pInfo->pArgs->ppFile = pFile;
    }

    Free0( pszOldAlternate );
    if (pszNewPersonal)
        Free0( pszOldPersonal );

    /* Add the edit field path to the list, if it's not already.
    */
    if (!IsAllWhite( pszNewAlternate ))
    {
        DTLNODE* pNode;

        for (pNode = DtlGetFirstNode( pInfo->user.pdtllistPhonebooks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            TCHAR* psz;

            psz = (TCHAR* )DtlGetData( pNode );
            ASSERT(psz);

            if (lstrcmpi( psz, pszNewAlternate ) == 0)
                break;
        }

        if (!pNode)
        {
            pNode = CreatePszNode( pszNewAlternate );
            if (pNode)
                DtlAddNodeFirst( pInfo->user.pdtllistPhonebooks, pNode );
            else
                Free( pszNewAlternate );
        }
    }

    return TRUE;
}


BOOL
PlCommand(
    IN UPINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl )

    /* Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    ** is the notification code of the command.  'wId' is the control/menu
    ** identifier of the command.  'HwndCtrl' is the control window handle of
    ** the command.
    **
    ** Returns true if processed message, false otherwise.
    */
{
    TRACE3("PlCommand(n=%d,i=%d,c=$%x)",
        (DWORD)wNotification,(DWORD)wId,(ULONG_PTR )hwndCtrl);

    switch (wId)
    {
        case CID_PL_RB_SystemList:
        case CID_PL_RB_PersonalList:
        {
            if (wNotification == BN_CLICKED)
            {
                EnableWindow( pInfo->hwndClbAlternates, FALSE );
                EnableWindow( pInfo->hwndPbBrowse, FALSE );
            }
            return TRUE;
        }

        case CID_PL_RB_AlternateList:
        {
            if (wNotification == BN_CLICKED)
            {
                EnableWindow( pInfo->hwndClbAlternates, TRUE );
                EnableWindow( pInfo->hwndPbBrowse, TRUE );
            }
            break;
        }

        case CID_PL_PB_Browse:
        {
            PlBrowse( pInfo );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
PlBrowse(
    IN UPINFO* pInfo )

    /* Called when the Browse button is pressed.  'PInfo' is the property
    ** sheet context.
    */
{
    OPENFILENAME ofn;
    TCHAR        szBuf[ MAX_PATH + 1 ];
    TCHAR        szFilter[ 64 ];
    TCHAR*       pszFilterDesc;
    TCHAR*       pszFilter;
    TCHAR*       pszTitle;
    TCHAR*       pszDefExt;

    TRACE("PlBrowse");

    szBuf[ 0 ] = TEXT('\0');

    /* Fill in FileOpen dialog parameter buffer.
    */
    pszFilterDesc = PszFromId( g_hinstDll, SID_PbkDescription );
    pszFilter = PszFromId( g_hinstDll, SID_PbkFilter );
    if (pszFilterDesc && pszFilter)
    {
        DWORD dwSize = sizeof(szFilter) / sizeof(TCHAR), dwLen;
        
        ZeroMemory( szFilter, sizeof(szFilter) );
        lstrcpyn( szFilter, pszFilterDesc, dwSize );
        dwLen = lstrlen( szFilter ) + 1;
        lstrcpyn( szFilter + dwLen, pszFilter, dwSize - dwLen );
    }
    Free0( pszFilterDesc );
    Free0( pszFilter );

    pszTitle = PszFromId( g_hinstDll, SID_PbkTitle );
    pszDefExt = PszFromId( g_hinstDll, SID_PbkDefExt );

    ZeroMemory( &ofn, sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = pInfo->hwndDlg;
    ofn.hInstance = g_hinstDll;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szBuf;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = pszTitle;
    ofn.lpstrDefExt = pszDefExt;
    ofn.Flags = OFN_HIDEREADONLY;

    {
        HHOOK hhook;
        BOOL  f;

        /* Install hook that will get the message box centered on the
        ** owner window.
        */
        hhook = SetWindowsHookEx( WH_CALLWNDPROC,
            CenterDlgOnOwnerCallWndProc, g_hinstDll, GetCurrentThreadId() );

        TRACE("GetOpenFileName");
        f = GetOpenFileName( &ofn );
        TRACE1("GetOpenFileName=%d",f);

        if (hhook)
            UnhookWindowsHookEx( hhook );

        if (f)
            SetWindowText( pInfo->hwndClbAlternates, ofn.lpstrFile );
    }

    Free0( pszTitle );
    Free0( pszDefExt );
}


BOOL
PlInit(
    IN HWND hwndPage )

    /* Called on WM_INITDIALOG.  'hwndPage' is the handle of the property
    ** page.
    **
    ** Return false if focus was set, true otherwise.
    */
{
    UPINFO* pInfo;

    TRACE("PlInit");

    pInfo = UpContext( hwndPage );
    if (!pInfo)
        return TRUE;

    /* Initialize page-specific context information.
    */
    pInfo->hwndPl = hwndPage;
    pInfo->hwndRbSystem = GetDlgItem( hwndPage, CID_PL_RB_SystemList );
    ASSERT(pInfo->hwndRbSystem);
    if (!pInfo->pArgs->fNoUser)
    {
        pInfo->hwndRbPersonal = GetDlgItem( hwndPage, CID_PL_RB_PersonalList );
        ASSERT(pInfo->hwndRbPersonal);

        if (pInfo->user.dwPhonebookMode == PBM_Personal)
            pInfo->user.dwPhonebookMode = PBM_System;
    }
    pInfo->hwndRbAlternate = GetDlgItem( hwndPage, CID_PL_RB_AlternateList );
    ASSERT(pInfo->hwndRbAlternate);
    pInfo->hwndClbAlternates = GetDlgItem( hwndPage, CID_PL_CL_Lists );
    ASSERT(pInfo->hwndClbAlternates);
    pInfo->hwndPbBrowse = GetDlgItem( hwndPage, CID_PL_PB_Browse );
    ASSERT(pInfo->hwndPbBrowse);

    /* Load alternate phonebooks list.
    */
    {
        INT      iSel;
        DTLNODE* pNode;
        TCHAR*   pszSel;

        pszSel = pInfo->user.pszAlternatePath;

        iSel = -1;
        for (pNode = DtlGetFirstNode( pInfo->user.pdtllistPhonebooks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            TCHAR* psz;
            INT    i;

            psz = (TCHAR* )DtlGetData( pNode );
            if (psz)
            {
                i = ComboBox_AddString( pInfo->hwndClbAlternates, psz );

                if (iSel < 0 && pszSel && lstrcmpi( psz, pszSel ) == 0)
                    iSel = i;
            }
        }

        if (iSel < 0 && pszSel)
            iSel = ComboBox_AddString( pInfo->hwndClbAlternates, pszSel );

        ComboBox_SetCurSel( pInfo->hwndClbAlternates, iSel );
        ComboBox_AutoSizeDroppedWidth( pInfo->hwndClbAlternates );
    }

    /* Select the phonebook mode with a pseudo-click which will trigger
    ** enabling/disabling of combo and button state.
    */
    {
        HWND hwndRb;

        if (pInfo->user.dwPhonebookMode == PBM_System)
            hwndRb = pInfo->hwndRbSystem;
        else if (pInfo->user.dwPhonebookMode == PBM_Personal)
            hwndRb = pInfo->hwndRbPersonal;
        else
        {
            ASSERT(pInfo->user.dwPhonebookMode==PBM_Alternate);
            hwndRb = pInfo->hwndRbAlternate;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\rasdlghc.h ===
// Copyright (c) 1996, Microsoft Corporation, all rights reserved.
//
// rasdlghc.h
// Remote Access Common Dialogs
// Help constants
//
// 02/06/96 Steve Cobb
//
// The IDs used here should be kept in the range 1000 to 9999.  Each dialog is
// assigned a 2-letter code that appears in all associated constants.  Each
// control has an additional 2-letter code indicating the control class, where
// PB=PushButton, EB=EditBox, LB=ListBox, CB=CheckBox, RB=RadioButton,
// ST=StaticText, GB=GroupBox, CC=CustomControl and CL=ComboListBox.
//

#ifndef _RASDLG_HCH_
#define _RASDLG_HCH_


// Entry property sheet, General page
//
#define HID_GE_GB_ConnectUsing          1000
#define HID_GE_LV_Devices               1001
#define HID_GE_PB_MoveUp                1002
#define HID_GE_PB_MoveDown              1003
#define HID_GE_CB_SharedPhoneNumber     1004
#define HID_GE_PB_Configure             1005
#define HID_GE_CLB_AreaCodes            1007
#define HID_GE_EB_PhoneNumber           1009
#define HID_GE_LB_CountryCodes          1011
#define HID_GE_CB_UseDialingRules       1012
#define HID_GE_PB_Alternates            1013
#define HID_GE_CB_ShowIcon              1014
#define HID_GE_LV_Device                1015
#define HID_GE_EB_ServiceName           1016
#define HID_GE_GB_FirstConnect          1017
#define HID_GE_CB_DialAnotherFirst      1018
#define HID_GE_LB_DialAnotherFirst      1019
#define HID_GE_LB_Devices               1020
#define HID_GE_PB_DialingRules          1021
#define HID_GE_EB_HostName              1022

// Entry property sheet, Shared Access page
//
#define HID_SA_PB_Shared                1150
#define HID_SA_PB_DemandDial            1151
#define HID_SA_PB_Settings              1152
#define HID_SA_LB_PrivateLan            1153

// Entry property sheet, Options page
//
#define HID_OE_GB_Progress              1100
#define HID_OE_CB_DisplayProgress       1101
#define HID_OE_CB_PreviewUserPw         1102
#define HID_OE_CB_PreviewDomain         1103
#define HID_OE_CB_PreviewNumber         1104
#define HID_OE_GB_Redial                1105
#define HID_OE_EB_RedialAttempts        1106
#define HID_OE_LB_RedialTimes           1107
#define HID_OE_LB_IdleTimes             1108
#define HID_OE_CB_RedialOnDrop          1109
#define HID_OE_GB_MultipleDevices       1110
#define HID_OE_LB_MultipleDevices       1111
#define HID_OE_PB_Configure             1112
#define HID_OE_PB_X25                   1113
#define HID_OE_PB_Tunnel                1114
#define HID_OE_RB_DemandDial            1115
#define HID_OE_RB_Persistent            1116
#define HID_OE_LB_IdleTimesRouter       1117
#define HID_OE_PB_Callback              1118


// Entry property sheet, Security page
//
#define HID_LO_RB_TypicalSecurity       1200
#define HID_LO_LB_Auths                 1201
#define HID_LO_CB_UseWindowsPw          1202
#define HID_LO_CB_Encryption            1203
#define HID_LO_RB_AdvancedSecurity      1204
#define HID_LO_PB_Advanced              1205
#define HID_LO_GB_Scripting             1206
#define HID_LO_CB_RunScript             1207
#define HID_LO_CB_Terminal              1208
#define HID_LO_LB_Scripts               1209
#define HID_LO_PB_Edit                  1210
#define HID_LO_PB_Browse                1211
#define HID_LO_GB_SecurityOptions       1212
#define HID_LO_PB_IPSec                 1213
#define HID_LO_PB_IPSecServer			1214

// Entry property sheet, Networking page
//
#define HID_NE_LB_ServerType            1300
#define HID_NE_PB_Settings              1301
#define HID_NE_LV_Components            1302
#define HID_NE_PB_Add                   1303
#define HID_NE_PB_Remove                1304
#define HID_NE_PB_Properties            1305
#define HID_NE_LB_ComponentDesc         1306

// Entry property sheet, Networking page, PPP dialog box
//
#define HID_NE_EnableLcp                1350
#define HID_NE_EnableCompression        1351
#define HID_NE_NegotiateMultilinkAlways 1352

// Alternate numbers dialog
//
#define HID_AN_ST_Explain               1400
#define HID_AN_LV_Numbers               1402
#define HID_AN_PB_Up                    1403
#define HID_AN_PB_Down                  1404
#define HID_AN_PB_Add                   1405
#define HID_AN_PB_Edit                  1406
#define HID_AN_PB_Delete                1407
#define HID_AN_CB_MoveToTop             1408
#define HID_AN_CB_TryNextOnFail         1409

// Phone number editor dialog
//
#define HID_CE_GB_PhoneNumber           1500
#define HID_CE_CLB_AreaCodes            1502
#define HID_CE_EB_PhoneNumber           1504
#define HID_CE_LB_CountryCodes          1506
#define HID_CE_GB_Comment               1507
#define HID_CE_EB_Comment               1508
#define HID_CE_CB_UseDialingRules       1509

// X.25 Logon Settings dialog
//
#define HID_XS_ST_Explain               1600
#define HID_XS_LB_Networks              1602
#define HID_XS_EB_Address               1604
#define HID_XS_GB_Optional              1605
#define HID_XS_EB_UserData              1607
#define HID_XS_EB_Facilities            1609

// Automatic Dialing and Hanging Up dialog
//
#define HID_DM_ST_Explain               1700
#define HID_DM_LB_DialPercent           1702
#define HID_DM_LB_DialTime              1704
#define HID_DM_LB_HangUpPercent         1706
#define HID_DM_LB_HangUpTime            1708

// Custom Authentication dialog
//
#define HID_CA_LB_Encryption            1800
#define HID_CA_GB_LogonSecurity         1801
#define HID_CA_RB_Eap                   1802
#define HID_CA_LB_EapPackages           1803
#define HID_CA_PB_Properties            1804
#define HID_CA_RB_AllowedProtocols      1805
#define HID_CA_CB_Pap                   1806
#define HID_CA_CB_Spap                  1807
#define HID_CA_CB_Chap                  1808
#define HID_CA_CB_MsChap                1809
#define HID_CA_CB_W95MsChap             1810
#define HID_CA_CB_MsChap2               1811
#define HID_CA_CB_UseWindowsPw          1812

// Data Encryption dialog
//
#define HID_ES_LB_Encryptions           1900

// ISDN configure dialog.
//
#define HID_IC_LB_LineType              2000
#define HID_IC_CB_Fallback              2001
#define HID_IC_CB_DownLevel             2002
#define HID_IC_CB_Compression           2003
#define HID_IC_EB_Channels              2004

// Modem configure dialog.
//
#define HID_MC_I_Modem                  2100
#define HID_MC_EB_ModemValue            2101
#define HID_MC_LB_MaxBps                2103
#define HID_MC_GB_Features              2104
#define HID_MC_CB_FlowControl           2105
#define HID_MC_CB_ErrorControl          2106
#define HID_MC_CB_Compression           2107
#define HID_MC_GB_BeforeDial            2108
#define HID_MC_CB_RunScript             2109
#define HID_MC_LB_Scripts               2110
#define HID_MC_CB_Terminal              2111
#define HID_MC_PB_Edit                  2112
#define HID_MC_PB_Browse                2113
#define HID_MC_CB_EnableSpeaker         2114
#define HID_MC_LB_ModemProtocol         2115

// Change password dialog
//
#define HID_CP_ST_Explain               2200
#define HID_CP_EB_OldPassword           2201
#define HID_CP_EB_Password              2202
#define HID_CP_EB_ConfirmPassword       2203

// Dial callback dialog
//
#define HID_DC_ST_Explain               2300
#define HID_DC_EB_Number                2301

// Dial error dialog
//
#define HID_DE_PB_More                  2401
#define HID_DE_PB_Redial                2402

// Projection result dialog
//
#define HID_PR_ST_Text                  2500
#define HID_PR_PB_Accept                2501
#define HID_PR_PB_HangUp                2502
#define HID_PR_CB_DisableProtocols      2503

// Retry Authentication dialog
//
#define HID_UA_ST_UserName              2600
#define HID_UA_EB_UserName              2601
#define HID_UA_ST_Password              2602
#define HID_UA_EB_Password              2603
#define HID_UA_ST_Domain                2604
#define HID_UA_EB_Domain                2605
#define HID_UA_CB_SavePassword          2606

// Terminal dialogs
//
#define HID_IT_EB_Screen                2900
#define HID_IT_CC_IpAddress             2901
#define HID_IT_PB_Done                  2902

// Dialer dialogs
//
#define HID_DR_BM_Useless               3000
#define HID_DR_EB_User                  3002
#define HID_DR_EB_Password              3004
#define HID_DR_EB_Domain                3006
#define HID_DR_CB_SavePassword          3007
#define HID_DR_CLB_Numbers              3009
#define HID_DR_LB_Locations             3011
#define HID_DR_PB_Rules                 3012
#define HID_DR_PB_Properties            3013
#define HID_DR_PB_DialConnect           3014
#define HID_DR_PB_Cancel                3016
#define HID_DR_PB_Help                  3017
#define HID_DR_RB_SaveForMe             3018
#define HID_DR_RB_SaveForEveryone       3019

// Main phonebook dialog (temporary).
//
#define HID_DU_BM_Wizard                3400
#define HID_DU_LB_Entries               3401
#define HID_DU_PB_New                   3402
#define HID_DU_PB_More                  3403
#define HID_DU_LB_DialPreview           3404
#define HID_DU_LB_DialFrom              3405
#define HID_DU_PB_Location              3406
#define HID_DU_PB_Dial                  3407
#define HID_DU_PB_Close                 3408

// Phone Number list dialog.
//
#define HID_PN_EB_NewNumber             3500
#define HID_PN_PB_Add                   3501
#define HID_PN_PB_Replace               3502
#define HID_PN_LB_List                  3503
#define HID_PN_PB_Up                    3504
#define HID_PN_PB_Down                  3505
#define HID_PN_PB_Delete                3506
#define HID_PN_CB_Promote               3507


//#if 0

// (Router) Dialing page.
//
#define HID_RD_RB_Persistent            3600
#define HID_RD_RB_DemandDial            3601
#define HID_RD_EB_Attempts              3602
#define HID_RD_EB_Seconds               3603
#define HID_RD_EB_Idle                  3604
#define HID_RD_PB_Callback              3605
#define HID_RD_PB_MultipleLines         3606

// (Router) Callback dialog
//
#define HID_CR_RB_No                    3700
#define HID_CR_RB_Yes                   3701
#define HID_CR_LV_Numbers               3702
#define HID_CR_PB_Edit                  3703
#define HID_CR_PB_Delete                3704

// User preferences property sheet, Appearance page.
//
#define HID_GP_CB_Preview               3801
#define HID_GP_CB_Location              3802
#define HID_GP_CB_Lights                3803
#define HID_GP_CB_Progress              3804
#define HID_GP_CB_CloseOnDial           3805
#define HID_GP_CB_PhonebookEdits        3807
#define HID_GP_CB_LocationEdits         3808
#define HID_GP_CB_UseWizard             3809
#define HID_GP_CB_AutodialPrompt        3810

// User preferences property sheet, Dialing page.
//
#define HID_AD_LV_Enable                3900
#define HID_AD_EB_Attempts              3901
#define HID_AD_EB_Seconds               3902
#define HID_AD_EB_Idle                  3903
#define HID_AD_CB_AskBeforeAutodial     3904
#define HID_AD_CB_DisableThisSession    3905

// User preferences property sheet, Callback page.
//
#define HID_CB_RB_No                    4001
#define HID_CB_RB_Maybe                 4002
#define HID_CB_RB_Yes                   4003
#define HID_CB_LV_Numbers               4004
#define HID_CB_PB_Edit                  4005
#define HID_CB_PB_Delete                4006

// User preferences property sheet, Phonebook page.
//
#define HID_PL_ST_Open                  4100
#define HID_PL_RB_SystemList            4101
#define HID_PL_RB_PersonalList          4102
#define HID_PL_RB_AlternateList         4103
#define HID_PL_CL_Lists                 4104
#define HID_PL_PB_Browse                4105

// Shared access settings property sheet, Applications page.
//
#define HID_SA_LV_Applications          4200
#define HID_SA_PB_Add                   4201
#define HID_SA_PB_Edit                  4202
#define HID_SA_PB_Delete                4203

// Shared access settings property sheet, Services page.
//
#define HID_SS_LV_Services              4250
#define HID_SS_PB_Add                   4251
#define HID_SS_PB_Edit                  4252
#define HID_SS_PB_Delete                4253

// Shared access settings property sheet, New Application dialog.
//
#define HID_SA_EB_Application           4300
#define HID_SA_EB_Port                  4301
#define HID_SA_PB_Tcp                   4302
#define HID_SA_PB_Udp                   4303
#define HID_SA_EB_TcpResponse           4304
#define HID_SA_EB_UdpResponse           4305

// Shared access settings property sheet, New Service dialog.
//
#define HID_SS_EB_Service               4350
#define HID_SS_EB_Port                  4351
#define HID_SS_PB_Tcp                   4352
#define HID_SS_PB_Udp                   4353
#define HID_SS_EB_Address               4354

// User preferences property sheet, Connections page.
//
#define HID_CO_GB_LogonPrivileges             4400
#define HID_CO_CB_AllowConnectionModification 4401

// User preferences property sheet, Callback page.
//
#define HID_ZE_ST_CallbackNumber        4450

// IP Security Policy Dialog box
//
#define HID_CI_CB_PresharedKey          4500
#define HID_CI_EB_PSK                   4501


//#endif


// Start of RAS error contexts and the single context for non-RAS errors.  So,
// 9700 is error 600, 9701 is error 601, etc.
//
#define HID_RASERRORBASE                9700
#define HID_RECONNECTING                9998
#define HID_NONRASERROR                 9999


#endif // _RASDLG_HCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\rasdlgp.h ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// rasdlgp.h
// Remote Access Common Dialog APIs
// Private pre-compiled header
//
// 06/18/95 Steve Cobb


#ifndef _RASDLGP_H_
#define _RASDLGP_H_

#define COBJMACROS

#include <nt.h>       // NT declarations
#include <ntrtl.h>    // NT general runtime-library
#include <nturtl.h>   // NT user-mode runtime-library
#include <windows.h>  // Win32 root
#include <windowsx.h> // Win32 macro extensions
#include <commctrl.h> // Win32 common controls
#include <commdlg.h>  // Win32 common dialogs
#include <prsht.h>    // Win32 property sheets
#include <setupapi.h> // Class image lists for network components
#include <shlobj.h>   // To get profile directory for user
#include <tapi.h>     // Telephony API
#include <rasdlg.h>   // Win32 RAS common dialogs (our public header)
#include <rasuip.h>   // RAS UI APIs (our private header)
#include <raserror.h> // Win32 RAS error codes
#include <netcfgx.h>  // INetCfg interfaces
#include <hnetcfg.h>  // IHNetCfg interfaces
#include <pbk.h>      // RAS phonebook library
#include <tapiutil.h> // TAPI helper library
#include <nouiutil.h> // No-HWND helper library
#include <phonenum.h> // Phone number helper library
#include <debug.h>    // Trace/assert library
#include <uiutil.h>   // HWND helper library
#include <wait.rch>   // LoadRas resource constants
#include <mdm.h>      // installs null modems for the dcc wizards.
#include <pwutil.h>   // password encoding, etc.
#include "rasdlgrc.h" // Our resource constants
#include "rasdlghc.h" // Our help context constants
#include "entry.h"    // High-level common phonebook entry helpers
#include "rassrv.h"

// Fusion support
// For whistler bug 349866
#include "shfusion.h"

// Whistler bug 224074 use only lstrcpyn's to prevent maliciousness
//
// Created this for the use of dial.c/terminal.c, max length of the IP address
// for the terminal dialog
//
#define TERM_IpAddress 17

// Positional offset of property sheets and wizards from the main dialog.
//
#define DXSHEET 12
#define DYSHEET 25

// List editor dialog option flags
//
#define LEDFLAG_NoDeleteLastItem 0x00000001
#define LEDFLAG_Sorted           0x00000002
#define LEDFLAG_Unique           0x00000004

//-----------------------------------------------------------------------------
// Datatypes
//-----------------------------------------------------------------------------

// Defines arguments passed internally via reserved words in the public
// interface.  This is done so an API doesn't have to re-load the phonebook
// and user preferences when serving another API.
//
typedef struct
_INTERNALARGS
{
    PBFILE* pFile;
    PBUSER* pUser;
    RASNOUSER* pNoUser;
    BOOL fNoUser;
    BOOL fNoUserChanged;
    BOOL fMoveOwnerOffDesktop;
    BOOL fForceCloseOnDial;
    HANDLE hConnection;
    BOOL fInvalid;
    PVOID pvEapInfo;
    BOOL fDisableFirstConnect;
}
INTERNALARGS;

// Static list table item.
//
typedef struct
_LBTABLEITEM
{
    DWORD sidItem;
    DWORD dwData;
}
LBTABLEITEM;


//-----------------------------------------------------------------------------
// Global declarations (defined in main.c)
//-----------------------------------------------------------------------------

extern HINSTANCE g_hinstDll;
extern LPCWSTR g_contextId;
extern HBITMAP g_hbmWizard;
extern TCHAR* g_pszHelpFile;
extern TCHAR* g_pszRouterHelpFile;
extern BOOL g_fEncryptionPermitted;
extern HANDLE g_hmutexCallbacks;
extern LONG g_ulCallbacksActive;
extern BOOL g_fTerminateAsap;


//-----------------------------------------------------------------------------
// Macros
//-----------------------------------------------------------------------------

#define ErrorDlg(h,o,e,a) \
            ErrorDlgUtil(h,o,e,a,g_hinstDll,SID_PopupTitle,SID_FMT_ErrorMsg)

#define MsgDlg(h,m,a) \
            MsgDlgUtil(h,m,a,g_hinstDll,SID_PopupTitle)

// Extended tracing macros.  Specifying a flag by name in the first parameter
// allows the caller to categorize messages printed e.g.
//
//     TRACEX(RASDLG_TIMER,"entering LsRefresh")
//
#define RASDLG_TIMER  ((DWORD)0x80000000|0x00000002)


//-----------------------------------------------------------------------------
// Cross-file prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL
AdvancedSecurityDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs );

BOOL
AllLinksAreModems(
    IN PBENTRY* pEntry );

BOOL
AllowDccWizard(
    IN HANDLE hConnection);

BOOL
AlternatePhoneNumbersDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pLinkNode,
    IN OUT DTLLIST* pListAreaCodes );

DWORD
AuthRestrictionsFromTypicalAuth(
    IN DWORD dwTypicalAuth );

ULONG
CallbacksActive(
    INT nSetTerminateAsap,
    BOOL* pfTerminateAsap );

VOID
ContextHelp(
    IN const DWORD* padwMap,
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

VOID
ContextHelpX(
    IN const DWORD* padwMap,
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam,
    IN BOOL fRouter);

VOID
CopyLinkPhoneNumberInfo(
    OUT DTLNODE* pDstLinkNode,
    IN DTLNODE* pSrcLinkNode );

VOID
CopyPszListToPhoneList(
    IN OUT PBLINK* pLink,
    IN DTLLIST* pListPhoneNumbers );

HWND
CreateWizardBitmap(
    IN HWND hwndDlg,
    IN BOOL fPage );

BOOL
CustomAuthenticationDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN DTLLIST* pList,
    IN DTLNODE* pNodeToSelect,
    OUT DTLNODE** ppNodeSelected );

BOOL
DataEncryptionDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN DWORD dwfCaps );

VOID
DereferenceRunningCallbacks(
    VOID );

BOOL
DeviceConfigureDlg(
    IN HWND hwndOwner,
    IN PBLINK* pLink,
    IN PBENTRY* pEntry,
    IN BOOL fSingleLink,
    IN BOOL fRouter);

TCHAR*
DisplayPszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort );

TCHAR*
DisplayPszFromPpbport(
    IN PBPORT* pPort,
    OUT DWORD* pdwDeviceIcon );

DWORD
DwCustomTerminalDlg(TCHAR *pszPhonebook,
                    HRASCONN hrasconn,
                    PBENTRY *pEntry,
                    HWND hwndDlg,
                    RASDIALPARAMS *prasdialparams,
                    PVOID pvReserved);
BOOL
EditPhoneNumberDlg(
    IN HWND hwndOwner,
    IN OUT DTLNODE* pPhoneNode,
    IN OUT DTLLIST* pListAreaCodes,
    IN DWORD sidTitle );

VOID
EnableCbWithRestore(
    IN HWND hwndCb,
    IN BOOL fEnable,
    IN BOOL fDisabledCheck,
    IN OUT BOOL* pfRestore );

VOID
EnableLbWithRestore(
    IN HWND hwndLb,
    IN BOOL fEnable,
    IN OUT INT* piRestore );

DTLNODE*
FirstPhoneNodeFromPhoneList(
    IN DTLLIST* pListPhones );

VOID
FirstPhoneNodeToPhoneList(
    IN DTLLIST* pListPhones,
    IN DTLNODE* pNewNode );

TCHAR*
FirstPhoneNumberFromEntry(
    IN PBENTRY* pEntry );

TCHAR*
FirstPszFromList(
    IN DTLLIST* pPszList );

DWORD
FirstPhoneNumberToEntry(
    IN PBENTRY* pEntry,
    IN TCHAR* pszPhoneNumber );

DWORD
FirstPszToList(
    IN DTLLIST* pPszList,
    IN TCHAR* psz );

VOID 
GetBoldWindowFont(
    IN  HWND hwnd, 
    IN  BOOL fLargeFont, 
    OUT HFONT * pBoldFont);


DWORD
GetDefaultEntryName(
    IN  PBFILE* pFile,
    IN  DWORD dwType,
    IN  BOOL fRouter,
    OUT TCHAR** ppszName );

BOOL
IPSecPolicyDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs );
    
BOOL
IsLocalPad(
    IN PBENTRY* pEntry );

/*
DWORD
IsNt40Machine (
    IN      PWCHAR      pszServer,
    OUT     PBOOL       pbIsNt40
    );
*/    

BOOL
ListEditorDlg(
    IN HWND hwndOwner,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck,
    IN DWORD dwMaxItemLen,
    IN TCHAR* pszTitle,
    IN TCHAR* pszItemLabel,
    IN TCHAR* pszListLabel,
    IN TCHAR* pszCheckLabel,
    IN TCHAR* pszDefaultItem,
    IN INT iSelInitial,
    IN DWORD* pdwHelp,
    IN DWORD dwfFlags,
    IN PDESTROYNODE pDestroyId );

BOOL
MultiLinkConfigureDlg(
    IN HWND hwndOwner,
    IN PBENTRY* pEntry,
    IN BOOL fRouter );

BOOL
MultiLinkDialingDlg(
    IN HWND hwndOwner,
    OUT PBENTRY* pEntry );

BOOL
NwConnectionCheck(
    IN HWND hwndOwner,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg,
    IN PBFILE* pFile,
    IN PBENTRY* pEntry );

BOOL
PhoneNodeIsBlank(
    IN DTLNODE* pNode );

BOOL
PhoneNumberDlg(
    IN HWND hwndOwner,
    IN BOOL fRouter,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck );

VOID
PositionDlg(
    IN HWND hwndDlg,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg );

LRESULT CALLBACK
PositionDlgStdCallWndProc(
    int code,
    WPARAM wparam,
    LPARAM lparam );

BOOL
PppTcpipDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry,
    IN BOOL fRouter );

BOOL
PrefixSuffixLocationDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszLocation,
    IN DWORD dwLocationId,
    IN OUT PBUSER* pUser,
    IN OUT HLINEAPP* pHlineapp );

TCHAR*
PszFromPhoneNumberList(
    IN DTLLIST* pList );

LRESULT CALLBACK
SelectDesktopCallWndRetProc(
    int code,
    WPARAM wparam,
    LPARAM lparam );

HICON
GetCurrentIconEntryType(
    IN DWORD dwType,
    BOOL fSmall);
   
VOID
SetIconFromEntryType(
    IN HWND hwndIcon,
    IN DWORD dwType,
    BOOL fSmall);

BOOL
SlipTcpipDlg(
    IN HWND hwndOwner,
    IN OUT PBENTRY* pEntry );

BOOL
StringEditorDlg(
    IN HWND hwndOwner,
    IN TCHAR* pszIn,
    IN DWORD dwSidTitle,
    IN DWORD dwSidLabel,
    IN DWORD cbMax,
    IN DWORD dwHelpId,
    IN OUT TCHAR** ppszOut );

BOOL
TerminalDlg(
    IN PBENTRY* pEntry,
    IN RASDIALPARAMS* pRdp,
    IN HWND hwndOwner,
    IN HRASCONN hrasconn,
    IN DWORD sidTitle,
    IN OUT TCHAR* pszIpAddress );

VOID
TweakTitleBar(
    IN HWND hwndDlg );

int CALLBACK
UnHelpCallbackFunc(
    IN HWND hwndDlg,
    IN UINT unMsg,
    IN LPARAM lparam );

BOOL
UserPreferencesDlg(
    IN HLINEAPP hlineapp,
    IN HWND hwndOwner,
    IN BOOL fLogon,
    IN DWORD dwFlags,
    OUT PBUSER*  pUser,
    OUT PBFILE** ppFile );

BOOL
WaitForRasDialCallbacksToTerminate(
    VOID );

BOOL
X25LogonSettingsDlg(
    IN HWND hwndOwner,
    IN BOOL fLocalPad,
    IN OUT PBENTRY* pEntry );

//-----------------------------------------------------------------------------
//
// pmay: 213060
// Prototypes moved from pref.c and entryps.c, cleanup added
//
// Callback number utilities
//
//-----------------------------------------------------------------------------

// 
//  Per-callback number context.
//
//  CbutilFillLvNumbers will allocate one of these contexts for each
//  item it puts in the list (accessed as LV_ITEM.lParam).  
//  CbutilLvNumbersCleanup will cleanup these contexts.
//
typedef struct _CBCONTEXT
{
    TCHAR* pszPortName;  // Pointer to port name (not owned by struct)
    TCHAR* pszDeviceName;// Pointer to device name (not owned by struct)
    DWORD dwDeviceType;  // pointer to the type of the device
    BOOL fConfigured;    // Whether device referenced is installed on sys.
} CBCONTEXT;

VOID
CbutilFillLvNumbers(
    IN HWND     hwndDlg,
    IN HWND     hwndLvNumbers,
    IN DTLLIST* pListCallback,
    IN BOOL     fRouter );

VOID
CbutilLvNumbersCleanup(
    IN  HWND    hwndLvNumbers );

LVXDRAWINFO*
CbutilLvNumbersCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

VOID
CbutilEdit(
    IN HWND hwndDlg,
    IN HWND hwndLvNumbers );

VOID
CbutilDelete(
    IN HWND  hwndDlg,
    IN HWND  hwndLvNumbers );

VOID
CbutilSaveLv(
    IN  HWND     hwndLvNumbers,
    OUT DTLLIST* pListCallback );

#endif // _RASDLGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\penettab.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// penettab.c
// Remote Access Common Dialog APIs
// Phonebook Entry property sheet (Networking tab)
//
// 12/10/97 Shaun Cox
//


#include "rasdlgp.h"
#include "entryps.h"
#include "inetcfgp.h"
#include "initguid.h"
#include "netcfgp.h"
#include "netconp.h"
#include "devguid.h"
#include "uiinfo.h"


typedef struct
_MAP_SZ_DWORD
{
    LPCTSTR pszValue;
    DWORD   dwValue;
}
MAP_SZ_DWORD;

//For whistler bug#194394
//For 64bit, IPX wont show up
//For 32/64 bit, NETBEUI wont show up
//
#ifdef _WIN64
    static const MAP_SZ_DWORD c_mapProtocols [] =
    {
        { NETCFG_TRANS_CID_MS_TCPIP,        NP_Ip  },
        { NETCFG_TRANS_CID_MS_NETMON,       NP_Netmon },
    };
#else
    static const MAP_SZ_DWORD c_mapProtocols [] =
    {
        { NETCFG_TRANS_CID_MS_TCPIP,        NP_Ip  },
        { NETCFG_TRANS_CID_MS_NWIPX,        NP_Ipx },
        { NETCFG_TRANS_CID_MS_NETMON,       NP_Netmon },
    };
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DwProtocolFromComponentId
//
//  Purpose:    Return the DWORD value of the protocol corresponding to
//              the string value in c_mapProtocols.
//
//  Arguments:
//      pszComponentId [in] Component id to find.
//
//  Returns:    NP_xxx value
//
//  Author:     shaunco   13 Dec 1997
//
//  Notes:      The input argument must exist in c_mapProtocols.
//
DWORD
DwProtocolFromComponentId (
    LPCTSTR pszComponentId)
{
    int i;
    for (i = 0; i < sizeof(c_mapProtocols) / sizeof(c_mapProtocols[0]); i++)
    {
        if (0 == lstrcmpi (pszComponentId, c_mapProtocols[i].pszValue))
        {
            return c_mapProtocols[i].dwValue;
        }
    }
    // Should never get here as we should never pass a protocol that is not
    // in c_mapProtocols.
    //
    ASSERT (FALSE);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetComponentImageIndex
//
//  Purpose:    Returns the index into pcild corresponding to the class of
//              pComponent.
//
//  Arguments:
//      pComponent [in] Component who's class should be used.
//      pcild      [in] Returned from SetupDiGetClassImageList
//
//  Returns:    A valid index or zero (which may also be valid).
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
int
GetComponentImageIndex (
    INetCfgComponent*       pComponent,
    SP_CLASSIMAGELIST_DATA* pcild)
{
    int iImage = 0;

    GUID guidClass;
    HRESULT hr = INetCfgComponent_GetClassGuid (pComponent, &guidClass);
    if (SUCCEEDED(hr))
    {
        SetupDiGetClassImageIndex (pcild, &guidClass, &iImage);
    }

    return iImage;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrEnumComponentsForListView
//
//  Purpose:    Return an array of INetCfgComponents that are candidates
//              for adding to our list view.  This is composed of all
//              clients and servcies, and a few select protocols.  (No
//              net adapters.)  Hidden components could be returned and
//              should be checked before adding to the list view.
//
//  Arguments:
//      pNetCfg      [in]
//      celt         [in]
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
HRESULT
HrEnumComponentsForListView (
    INetCfg*            pNetCfg,
    ULONG               celt,
    INetCfgComponent**  rgelt,
    ULONG*              pceltFetched)
{
    static const GUID* c_apguidClasses [] =
    {
        &GUID_DEVCLASS_NETCLIENT,
        &GUID_DEVCLASS_NETSERVICE,
    };

    HRESULT hr;
    int i;
    ULONG celtFetched = 0;

    // Initialize the output parameters.
    //
    ZeroMemory (rgelt, celt * sizeof (*rgelt));
    *pceltFetched = 0;

    // Enumerate the clients and services.
    //
    hr = HrEnumComponentsInClasses (pNetCfg,
            sizeof(c_apguidClasses) / sizeof(c_apguidClasses[0]),
            (GUID**)c_apguidClasses,
            celt, rgelt, &celtFetched);

    // Find the protocols if they are installed.
    //
    for (i = 0; i < sizeof(c_mapProtocols) / sizeof(c_mapProtocols[0]); i++)
    {
        INetCfgComponent* pComponent;
        hr = INetCfg_FindComponent (pNetCfg, c_mapProtocols[i].pszValue,
                        &pComponent);
        if (S_OK == hr)
        {
            rgelt [celtFetched++] = pComponent;
        }
    }

    *pceltFetched = celtFetched;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrNeRefreshListView
//
//  Purpose:    Clear and re-add all of the items that belong in the list
//              view.
//
//  Arguments:
//      pInfo   [in]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Dec 1997
//
//  Notes:
//
HRESULT
HrNeRefreshListView (
    PEINFO* pInfo)
{
    HRESULT             hr = S_OK;
    INetCfgComponent*   aComponents [256];
    ULONG               cComponents;
    HIMAGELIST          himlSmall;
    PBENTRY*            pEntry = pInfo->pArgs->pEntry;
    PBFILE*             pFile  = pInfo->pArgs->pFile;

    // Delete all existing items.  The LVN_DELETEITEM handler is expected to
    // release the objects we have attached prior.
    //
    ListView_DeleteAllItems (pInfo->hwndLvComponents);

    hr = HrEnumComponentsForListView (pInfo->pNetCfg,
            sizeof(aComponents)/sizeof(aComponents[0]),
            aComponents, &cComponents);
    if (SUCCEEDED(hr))
    {
        BOOL    fHasPermission = TRUE;
        ULONG   i;

        // check if user has any permission to change the bindings
        INetConnectionUiUtilities * pncuu = NULL;

        hr = HrCreateNetConnectionUtilities(&pncuu);
        if (SUCCEEDED(hr))
        {
            fHasPermission =
                INetConnectionUiUtilities_UserHasPermission(
                    pncuu, NCPERM_ChangeBindState);

            INetConnectionUiUtilities_Release(pncuu);
        }

        for (i = 0; i < cComponents; i++)
        {
            INetCfgComponent*   pComponent = aComponents [i];
            DWORD               dwCharacter;
            LPWSTR              pszwName = NULL;
            LPWSTR              pszwId = NULL;
            int                 iItem;
            LV_ITEM             item = {0};
            BOOL                fCheck, fForceCheck = FALSE;
            GUID                guid;
            BOOL                fDisableCheckbox = FALSE;

            // We'll release it if inserting it failed or we decided to
            // skip it.  By not releasing it, we pass ownership to the
            // list view.
            //
            BOOL fReleaseComponent = TRUE;

            // Don't add hidden components.  Silently skip components
            // that we fail to get the class GUID or display name for.
            // (After all, what could we have the user do to fix the error?
            //  Might as well show them what we can.)
            //
            if (   FAILED(INetCfgComponent_GetCharacteristics (pComponent, &dwCharacter))
                || (dwCharacter & NCF_HIDDEN)
                || FAILED(INetCfgComponent_GetDisplayName (pComponent, &pszwName)))
            {
                goto skip_component;
            }

            //for whistler bug 29356 filter out Network Load Balancing
            //
            if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
            {
                WCHAR * pszwTmpId = NULL;

                pszwTmpId  = StrDupWFromT(NETCFG_SERVICE_CID_MS_WLBS);

                if(pszwTmpId)
                {
                    if ( 0 == lstrcmpW(pszwId, pszwTmpId))
                    {
                        Free0(pszwTmpId);
                        CoTaskMemFree (pszwId);
                        goto skip_component;
                    }
                    
                    Free0(pszwTmpId);
               }

                CoTaskMemFree (pszwId);
            }
  

            // Disable the checkbox on components whose bindings are not user adjustable
            // or user has no permission to adjust binding
            if (NCF_FIXED_BINDING & dwCharacter)
            {
                fDisableCheckbox = TRUE;
            }

            // Bug #157213: Don't add any protocols other than IP if SLIP
            // is enabled
            //
            // Bug #294401: Also filter out CSNW when server type is SLIP
            if (pInfo->pArgs->pEntry->dwBaseProtocol == BP_Slip)
            {
                if (SUCCEEDED(INetCfgComponent_GetClassGuid(pComponent, &guid)))
                {
                    BOOL    fSkip = FALSE;

                    if (IsEqualGUID(&guid, &GUID_DEVCLASS_NETTRANS))
                    {
                        if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                        {
                            if (DwProtocolFromComponentId(pszwId) == NP_Ip)
                            {
                                // This item is IP. We should disable the check
                                // box so the user can't disable TCP/IP in SLIP
                                // mode. This is done after the item is inserted.
                                //
                                fDisableCheckbox = TRUE;

                                // 122024
                                //
                                // We should also force the ui to show ip as enabled
                                // since IP is always used with SLIP.
                                //
                                fForceCheck = TRUE;
                                
                            }
                            else
                            {
                                fSkip = TRUE;
                            }

                            CoTaskMemFree (pszwId);
                        }
                    }
                    else if (IsEqualGUID(&guid, &GUID_DEVCLASS_NETCLIENT))
                    {
                        if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                        {
                            if (0 == lstrcmpi (pszwId, TEXT("MS_NWCLIENT")))
                            {
                                fSkip = TRUE;
                            }
                            CoTaskMemFree (pszwId);
                        }
                    }

                    if (fSkip)
                    {
                        goto skip_component;
                    }
                }
            }

            // pmay: 348623 
            //
            // If we are remote admining a router, only allow tcpip and
            // ipx to be displayed.
            //
            if (pInfo->pArgs->fRouter && pInfo->pArgs->fRemote)
            {
                if (SUCCEEDED(INetCfgComponent_GetClassGuid(pComponent, &guid)))
                {
                    BOOL    fSkip = TRUE;
                    DWORD   dwId;

                    if (IsEqualGUID(&guid, &GUID_DEVCLASS_NETTRANS))
                    {
                        if (SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                        {
                            dwId = DwProtocolFromComponentId(pszwId);
                            if ((dwId == NP_Ip) || (dwId == NP_Ipx))
                            {
                                fSkip = FALSE;
                            }
                            CoTaskMemFree (pszwId);
                        }
                    }
                    
                    if (fSkip)
                    {
                        goto skip_component;
                    }
                }
            }

            item.mask    = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            item.pszText = pszwName;
            item.iImage  = GetComponentImageIndex (pComponent, &pInfo->cild);
            item.lParam  = (LPARAM)pComponent;

            // Add the item.
            //
            iItem = ListView_InsertItem (pInfo->hwndLvComponents, &item);
            if (-1 != iItem)
            {
                // List view now has it.  We can't release it.
                //
                fReleaseComponent = FALSE;

                // Set its check state.
                //
                if (! fForceCheck)
                {
                    fCheck = NeIsComponentEnabled (pInfo, pComponent);
                }
                else
                {
                    fCheck = TRUE;
                }
                ListView_SetCheck (pInfo->hwndLvComponents, iItem, fCheck);

                // Disable the checkbox if this is psched. We don't allow
                // users to change check state of psched from ras connections.
                // bug 255749 [raos].
                //
                if(SUCCEEDED(INetCfgComponent_GetId(pComponent, &pszwId)))
                {
                    // Check to see if this is psched.
                    //
                    if(     (0 == _wcsicmp(pszwId, L"ms_psched"))
                        ||  (0 == _wcsicmp(pszwId, L"ms_NetMon")))
                    {
                        fDisableCheckbox = TRUE;
                    }
                }

                if (fDisableCheckbox)
                {
                    ListView_DisableCheck(pInfo->hwndLvComponents, iItem);
                }
            }

        skip_component:

            if (fReleaseComponent)
            {
                ReleaseObj (pComponent);
            }

            CoTaskMemFree (pszwName);
        }

        // Select first item
        ListView_SetItemState(pInfo->hwndLvComponents, 0,
                              LVIS_SELECTED | LVIS_FOCUSED,
                              LVIS_SELECTED | LVIS_FOCUSED);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PComponentFromItemIndex
//
//  Purpose:    Return the INetCfgComponent associated with the specified
//              list view item.
//
//  Arguments:
//      hwndLv [in]
//      iItem  [in]
//
//  Returns:    A (non-AddRef'd) copy of the INetCfgComponent pointer
//              associated with the item.
//
//  Author:     shaunco   14 Dec 1997
//
//  Notes:      The returned value is NOT AddRef'd.
//
INetCfgComponent*
PComponentFromItemIndex (
    HWND hwndLv,
    int  iItem)
{
    INetCfgComponent* pComponent = NULL;
    LV_ITEM           item = {0};

    item.mask = LVIF_PARAM;
    item.iItem = iItem;
    if (ListView_GetItem (hwndLv, &item))
    {
        pComponent = (INetCfgComponent*)item.lParam;
        ASSERT (pComponent);
    }
    return pComponent;
}

//+---------------------------------------------------------------------------
//
//  Function:   PComponentFromCurSel
//
//  Purpose:
//
//  Arguments:
//      hwndLv [in]  Window handle of list view
//      piItem [out] Optional address of integer to receive selected item.
//
//  Returns:
//
//  Author:     shaunco   30 Dec 1997
//
//  Notes:
//
INetCfgComponent*
PComponentFromCurSel (
    HWND hwndLv,
    int* piItem)
{
    INetCfgComponent* pComponent = NULL;

    // Get the current selection if it exists.
    //
    int iItem = ListView_GetNextItem (hwndLv, -1, LVNI_SELECTED);
    if (-1 != iItem)
    {
        // Get the component associated with the current selection.  It must
        // exist.
        //
        pComponent = PComponentFromItemIndex (hwndLv, iItem);
        ASSERT (pComponent);
    }

    // Return the index of the item if requested.
    //
    if (piItem)
    {
        *piItem = iItem;
    }

    return pComponent;
}

//+---------------------------------------------------------------------------
//
//  Function:   PeQueryOrChangeComponentEnabled
//
//  Purpose:
//
//  Arguments:
//      pInfo      []
//      pComponent []
//      fChange    []
//      fNewValue  []
//
//  Returns:
//
//  Author:     shaunco   14 Dec 1997
//
//  Notes:
//
BOOL
NeQueryOrChangeComponentEnabled (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent,
    BOOL                fChange,
    BOOL                fValue)
{
    BOOL    fOldValue;
    GUID    guidClass;
    HRESULT hr;

    hr = INetCfgComponent_GetClassGuid (pComponent, &guidClass);
    if (SUCCEEDED(hr))
    {
        LPWSTR pszwId;
        hr = INetCfgComponent_GetId (pComponent, &pszwId);
        if (SUCCEEDED(hr))
        {
            // We handle protocols in a hard-coded (er, well known) fashion.
            //
            if (IsEqualGUID (&guidClass, &GUID_DEVCLASS_NETTRANS))
            {
                DWORD* pdwValue = &pInfo->pArgs->pEntry->dwfExcludedProtocols;

                // Check if the protocol is exluded.
                //
                DWORD dwProtocol = DwProtocolFromComponentId (pszwId);

                if (fChange)
                {
                    if (fValue)
                    {
                        // Include the protocol.  (By not explicitly excluding
                        // it.
                        //
                        *pdwValue &= ~dwProtocol;
                    }
                    else
                    {
                        // Exclude the protocol.  (Remember, its a list of
                        // excluded protocols.
                        //
                        *pdwValue |= dwProtocol;
                    }
                }
                else
                {
                    fValue = !(dwProtocol & *pdwValue);
                }
            }
            else
            {
                if (fChange)
                {
                    EnableOrDisableNetComponent (pInfo->pArgs->pEntry,
                        pszwId, fValue);
                }
                else
                {
                    // Default to enabled for the case whenthe value isn't
                    // found in the entry.  This will be the case for pre-NT5
                    // entries and entries that have not yet been to the
                    // Networking tab for edits.
                    //
                    BOOL fEnabled;
                    fValue = TRUE;
                    if (FIsNetComponentListed(pInfo->pArgs->pEntry,
                            pszwId, &fEnabled, NULL))
                    {
                        fValue = fEnabled;
                    }
                }
            }

            CoTaskMemFree (pszwId);
        }
    }
    return fValue;
}

VOID
NeEnableComponent (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent,
    BOOL                fEnable)
{
    NeQueryOrChangeComponentEnabled (pInfo, pComponent, TRUE, fEnable);
}

BOOL
NeIsComponentEnabled (
    PEINFO*             pInfo,
    INetCfgComponent*   pComponent)
{
    return NeQueryOrChangeComponentEnabled (pInfo, pComponent, FALSE, FALSE);
}

VOID
NeShowComponentProperties (
    IN PEINFO* pInfo)
{
    HRESULT hr;

    // Get the component for the current selection.
    //
    INetCfgComponent* pComponent;
    pComponent = PComponentFromCurSel (pInfo->hwndLvComponents, NULL);
    ASSERT (pComponent);

    if(NULL == pComponent)
    {   
        return;
    }

    // Create the UI info callback object if we haven't done so yet.
    // If this fails, we can still show properties.  TCP/IP just might
    // not know which UI-variant to show.
    //
    if (!pInfo->punkUiInfoCallback)
    {
        HrCreateUiInfoCallbackObject (pInfo, &pInfo->punkUiInfoCallback);
    }

    // Show the component's property UI.  If S_OK is returned, it means
    // something changed.
    //
    hr = INetCfgComponent_RaisePropertyUi (pComponent,
            pInfo->hwndDlg,
            NCRP_SHOW_PROPERTY_UI,
            pInfo->punkUiInfoCallback);

    if (S_OK == hr)
    {
        // Get the INetCfgComponentPrivate interface so we can query the
        // notify object directly.
        //
        INetCfgComponentPrivate* pPrivate;
        hr = INetCfgComponent_QueryInterface (pComponent,
                    &IID_INetCfgComponentPrivate,
                    (VOID**)&pPrivate);
        if (SUCCEEDED(hr))
        {
            // Get the INetRasConnectionIpUiInfo interface from the notify
            // object.
            //
            INetRasConnectionIpUiInfo* pIpUiInfo;
            hr = INetCfgComponentPrivate_QueryNotifyObject (pPrivate,
                    &IID_INetRasConnectionIpUiInfo,
                    (VOID**)&pIpUiInfo);
            if (SUCCEEDED(hr))
            {
                // Get the UI info from TCP/IP.
                //
                RASCON_IPUI info;
                hr = INetRasConnectionIpUiInfo_GetUiInfo (pIpUiInfo, &info);
                if (SUCCEEDED(hr))
                {
                    PBENTRY* pEntry = pInfo->pArgs->pEntry;

                    // Get rid of our current data before we copy the new
                    // data.
                    //
                    pEntry->dwIpAddressSource = ASRC_ServerAssigned;
                    pEntry->dwIpNameSource = ASRC_ServerAssigned;

                    Free0 (pEntry->pszIpAddress);
                    pEntry->pszIpAddress = NULL;

                    Free0 (pEntry->pszIpDnsAddress);
                    pEntry->pszIpDnsAddress = NULL;

                    Free0 (pEntry->pszIpDns2Address);
                    pEntry->pszIpDns2Address = NULL;

                    Free0 (pEntry->pszIpWinsAddress);
                    pEntry->pszIpWinsAddress = NULL;

                    Free0 (pEntry->pszIpWins2Address);
                    pEntry->pszIpWins2Address = NULL;

                    Free0 (pEntry->pszIpDnsSuffix);
                    pEntry->pszIpDnsSuffix = StrDup (info.pszwDnsSuffix);

                    if ((info.dwFlags & RCUIF_USE_IP_ADDR) &&
                        *info.pszwIpAddr)
                    {
                        pEntry->dwIpAddressSource = ASRC_RequireSpecific;
                        pEntry->pszIpAddress = StrDup (info.pszwIpAddr);
                    }
                    else
                    {
                        pEntry->dwIpAddressSource = ASRC_ServerAssigned;
                        Free0 (pEntry->pszIpAddress);
                        pEntry->pszIpAddress = NULL;
                    }

                    if (info.dwFlags & RCUIF_USE_NAME_SERVERS)
                    {
                        if (*info.pszwDnsAddr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpDnsAddress = StrDup (info.pszwDnsAddr);
                        }
                        if (*info.pszwDns2Addr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpDns2Address = StrDup (info.pszwDns2Addr);
                        }
                        if (*info.pszwWinsAddr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpWinsAddress = StrDup (info.pszwWinsAddr);
                        }
                        if (*info.pszwWins2Addr)
                        {
                            pEntry->dwIpNameSource = ASRC_RequireSpecific;
                            pEntry->pszIpWins2Address = StrDup (info.pszwWins2Addr);
                        }
                    }

                    // pmay: 389632  
                    // 
                    // Use this convoluted logic to store something reasonable
                    // about the registration process.
                    //
                    if (info.dwFlags & RCUIF_USE_DISABLE_REGISTER_DNS)
                    {
                        pEntry->dwIpDnsFlags = 0;
                    }
                    else 
                    {
                        BOOL bSuffix = 
                            ((pEntry->pszIpDnsSuffix) && (*(pEntry->pszIpDnsSuffix)));
                            
                        pEntry->dwIpDnsFlags = DNS_RegPrimary;
                        
                        if (info.dwFlags & RCUIF_USE_PRIVATE_DNS_SUFFIX)
                        {
                            if (bSuffix)
                            {
                                pEntry->dwIpDnsFlags |= DNS_RegPerConnection;
                            }
                            else
                            {
                                pEntry->dwIpDnsFlags |= DNS_RegDhcpInform;
                            }
                        }
                    }

                    // 277478
                    // Enable the NBT over IP controls
                    //
                    if (info.dwFlags & RCUIF_ENABLE_NBT)
                    {
                        pEntry->dwIpNbtFlags = PBK_ENTRY_IP_NBT_Enable;
                    }
                    else
                    {
                        pEntry->dwIpNbtFlags = 0;
                    }
                                        
                    if (pInfo->pArgs->fRouter)
                    {
                        pEntry->fIpPrioritizeRemote = FALSE;
                    }
                    else
                    {
                        pEntry->fIpPrioritizeRemote  = info.dwFlags & RCUIF_USE_REMOTE_GATEWAY;
                    }                        
                    pEntry->fIpHeaderCompression = info.dwFlags & RCUIF_USE_HEADER_COMPRESSION;
                    pEntry->dwFrameSize = info.dwFrameSize;
                }
                ReleaseObj (pIpUiInfo);
            }

            ReleaseObj (pPrivate);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\rasdlgrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rasdlg.rc
//
#define BID_Dialer                      100
#define BID_Wizard                      101
#define BID_WizardHeader                102
#define DID_AN_AlternateNumbers         102
#define DID_AQ_AutoDialQuery            103
#define DID_BE_BundlingErrors           104
#define DID_CA_CustomAuth               105
#define DID_CC_ConnectComplete          106
#define DID_CE_ComplexPhoneEditor       107
#define DID_CP_ChangePassword           108
#define DID_CP_ChangePassword2          109
#define DID_DC_DialCallback             110
#define DID_DE_DialError                111
#define DID_DM_DialingMultipleLines     112
#define DID_DP_DialProgress             113
#define DID_DQ_DisableAutoDialQuery     114
#define DID_DR_DialerNL                 115
#define DID_DR_DialerU                  116
#define DID_DR_DialerUD                 117
#define DID_DR_DialerUDN                118
#define DID_DR_DialerUN                 119
#define DID_ES_EncryptionSettings       120
#define DID_IC_IsdnConfigure            121
#define DID_IC_IsdnConfigureMlink       122
#define DID_IT_SlipTerminal             123
#define DID_IT_Terminal                 124
#define DID_MC_ModemConfigure           125
#define DID_NE_AddComponent             126
#define DID_NW_NwcConnections           127
#define DID_OD_OperatorDial             128
#define DID_PR_ProjectionResult         129
#define DID_XS_X25Settings              133
#define IID_DnArr                       134
#define IID_DnArrDis                    135
#define IID_UpArr                       144
#define IID_UpArrDis                    145
#define PID_AD_AutoDial                 146
#define PID_AD_AutoDialLogon            147
#define PID_CB_CallbackSettings         148
#define PID_DI_RouterDialIn             149
#define PID_DO_RouterDialOut            150
#define PID_EN_EntryName                153
#define PID_GE_GeneralMultiple          155
#define PID_GE_GeneralSingle            156
#define PID_GP_GeneralPrefLogon         157
#define PID_GP_GeneralPreferences       158
#define PID_IN_InterfaceName            160
#define PID_LO_Security                 162
#define PID_MA_ModemAdapter             163
#define PID_NE_Network                  165
#define PID_NS_RouterNameServers        166
#define PID_OE_Options                  167
#define PID_PA_PhoneNumber              168
#define PID_PL_PhoneList                169
#define PID_PL_PhoneListLogon           170
#define PID_RA_RouterIpAddress          171
#define PID_RC_RouterScripting          172
#define PID_RD_Dialing                  173
#define PID_RD_Router                   174
#define PID_RF_RouterFinish             175
#define PID_RN_RouterModemAdapter       179
#define PID_RP_RouterPhoneNumber        180
#define PID_SE_RouterSecuritySettings   181
#define PID_SE_SecuritySettings         182
#define PID_SS_ServerSettings           183
#define PID_ST_Start                    184
#define PID_US_Users                    186
#define SID_AQ_DoNotDialLabel           187
#define SID_AQ_Text                     188
#define SID_AddAlternateTitle           189
#define SID_AuthAny                     190
#define SID_DialOnlyFirst               190
#define SID_AuthCustom                  191
#define SID_DialAll                     191
#define SID_AuthEncrypted               192
#define SID_DialNeeded                  192
#define SID_AuthExplain                 193
#define SID_AuthMsEncrypted             194
#define SID_SharingConflict             194
#define SID_BadAreaCode                 195
#define SID_BadEntry                    196
#define SID_BadIpAddrRange              197
#define SID_CannotLoadConfigDll         198
#define SID_CantHangUpRouter            199
#define SID_CommentColHead              200
#define CID_CA_CB_W95MsChap             200
#define SID_ConfigDllApiFailed          201
#define SID_ConfigureIp                 202
#define SID_ConfigureIpx                203
#define SID_ConfirmDelDevice            204
#define SID_ConfirmDelEntry             205
#define SID_ConfirmHangUp               206
#define SID_ConfirmShortcut             207
#define SID_ConfirmViewScriptLog        208
#define SID_ConnectComplete             209
#define SID_ConnectComplete1            210
#define SID_AuthPassword                211
#define SID_Connected                   212
#define SID_CustomAuthConfigRequired    213
#define SID_CutDefExt                   214
#define SID_CutDescription              215
#define SID_CutFilter                   216
#define SID_CutTitle                    217
#define SID_DE_LinkFailed               218
#define SID_DS_CantGetFraming           219
#define SID_DS_CantGetPortInfo          220
#define SID_DS_CantGetProjection        221
#define SID_DS_CantGetRasconnList       222
#define SID_DS_Client                   223
#define SID_DS_Details                  224
#define SID_DS_Device                   225
#define SID_DS_Network                  226
#define SID_DS_NotConnected             227
#define SID_DU_Dial                     228
#define SID_DU_HangUp                   229
#define SID_DefaultEntryName            230
#define SID_DefaultModemSettings        231
#define SID_DefaultPort                 232
#define SID_DefaultRouterEntryName      233
#define SID_DeviceColHead               234
#define SID_DialOutUserName             235
#define SID_DuplicateEntry              236
#define SID_EC_Subtitle                 237
#define SID_EC_Title                    238
#define SID_EN_Subtitle                 239
#define SID_EN_Title                    240
#define SID_EcbnLabel                   241
#define SID_EcbnTitle                   242
#define SID_EditAlternateTitle          243
#define SID_EditConnected               244
#define SID_EmptyLogonPb                245
#define SID_EmptyPhonebook              246
#define SID_EncryptionBanned            247
#define SID_EnterX25Address             248
#define SID_FMT_Error                   249
#define SID_FMT_ErrorMsg                250
#define SID_FMT_ErrorMsgDiag            251
#define SID_FMT_ErrorMsgExt             252
#define SID_FMT_ErrorMsgF1              253
#define SID_FMT_ErrorMsgName            254
#define SID_FMT_ErrorMsgProject         255
#define SID_FMT_ErrorMsgResp            256
#define SID_FMT_FailCode                257
#define SID_FMT_Name                    258
#define SID_FMT_ProjectError            259
#define SID_FMT_ProjectOk               260
#define SID_FP_Subtitle                 261
#define SID_FP_Title                    262
#define SID_FinishWizard                263
#define SID_HelpFile                    264
#define SID_HuntCheckLabel              265
#define SID_HuntItemLabel               266
#define SID_HuntListLabel               267
#define SID_HuntTitle                   268
#define SID_IA_Subtitle                 269
#define SID_IA_Title                    270
#define SID_InternetWithoutIp           271
#define SID_Ip                          272
#define SID_IpsecDefault                273
#define SID_Ipx                         274
#define SID_IsCurLoc                    275
#define SID_Isdn                        276
#define SID_IsdnAdapter                 277
#define SID_IsdnLineType0               278
#define SID_IsdnLineType1               279
#define SID_IsdnLineType2               280
#define SID_LG_Subtitle                 281
#define SID_LG_Title                    282
#define SID_LS_PercentFmt               283
#define SID_LinkPhoneNumber             284
#define SID_LocationItemLabel           285
#define SID_LocationListLabel           286
#define SID_LocationTitle               287
#define SID_MA_Subtitle                 288
#define SID_MA_Title                    289
#define SID_MlinkNeedsPpp               290
#define SID_Modem                       291
#define SID_ModemNotInstalled           292
#define SID_Mppe128bit                  293
#define SID_Mppe40bit                   294
#define SID_MultiLink                   295
#define SID_MultiLinkNumber             296
#define SID_NA_Subtitle                 297
#define SID_NA_Title                    298
#define SID_NR_FT_Amb                   299
#define SID_NR_FT_Ppp                   300
#define SID_NR_FT_PppLcp                301
#define SID_NR_FT_Slip                  302
#define SID_Nbf                         303
#define SID_NewPhonebook                304
#define SID_NoAltPath                   305
#define SID_NoConfigure                 306
#define SID_NoDeleteConnected           307
#define SID_NoEntrySelected             308
#define SID_NoIpAddress                 309
#define SID_NoX25Address                310
#define SID_NoneSelected                311
#define SID_NotUnique                   312
#define SID_AuthPasswordAndData         313
#define SID_NpNotInstalled              314
#define SID_OP_CachePw                  315
#define SID_OP_DisplayData              316
#define SID_OP_GetADialInfo             317
#define SID_OP_LoadDlg                  318
#define SID_OP_UnshareConnection        319
#define SID_OP_LoadPage                 320
#define SID_OP_LoadPhonebook            321
#define SID_OP_LoadPortInfo             322
#define SID_OP_LoadPrefs                323
#define SID_OP_LoadScriptInfo           324
#define SID_OP_LoadScriptLog            325
#define SID_OP_LoadSwitchEditor         326
#define SID_OP_LoadTapiInfo             327
#define SID_OP_LoadX25Info              328
#define SID_OP_MakePhonebook            329
#define SID_OP_ShareConnection          330
#define SID_OP_RasDial                  331
#define SID_OP_RasGetBuffer             332
#define SID_OP_RasGetInfo               333
#define SID_OP_RasGetProtocolInfo       334
#define SID_OP_RasPortReceive           335
#define SID_OP_RasPortSend              336
#define SID_OP_RetrievingData           337
#define SID_OP_SaveTapiInfo             338
#define SID_OP_SavingData               339
#define SID_OP_ScriptHalted             340
#define SID_OP_ScriptHaltedOnError      341
#define SID_OP_SetADialInfo             342
#define SID_OP_UncachePw                343
#define SID_OP_WritePhonebook           344
#define SID_OP_WritePrefs               345
#define SID_OP_WriteShortcutFile        346
#define SID_OkLabel                     347
#define SID_PA_Subtitle                 348
#define SID_PA_Title                    349
#define SID_PasswordMismatch            350
#define SID_PasswordsDontMatch          351
#define SID_PbkDefExt                   352
#define SID_PbkDescription              353
#define SID_PbkFilter                   354
#define SID_PbkTitle                    355
#define SID_PeTitleClone                356
#define SID_PeTitleEdit                 357
#define SID_PeTitleNew                  358
#define SID_PhoneNumberColHead          359
#define SID_PhoneNumbersColHead         360
#define SID_PopupTitle                  361
#define SID_PppNeedsProtocol            362
#define SID_PppWithoutProtocol          363
#define SID_PrefixItemLabel             364
#define SID_PrefixListLabel             365
#define SID_PrefixTitle                 366
#define SID_ProjectionResult1           367
#define SID_ProjectionResult2           368
#define SID_ProtocolsInfo               369
#define SID_SavePasswordFrndly          370
#define SID_RasNeedsNbf                 405
#define SID_RasWithoutNbf               406
#define SID_RedialLabel                 407
#define SID_RemoveCP                    408
#define SID_SW_Title                    409
#define SID_RouterDialInAccount         410
#define SID_RouterDialOut               411
#define SID_RouterHelpFile              412
#define SID_RouterHuntCheckLabel        413
#define SID_RouterHuntItemLabel         414
#define SID_RouterHuntListLabel         415
#define SID_RouterHuntTitle             416
#define SID_ST_Ppp                      417
#define SID_DataEncNone                 418
#define SID_ST_Slip                     419
#define SID_S_AllDevicesConnected       420
#define SID_S_AuthAck                   421
#define SID_S_AuthCallback              422
#define SID_S_AuthChangePassword        423
#define SID_S_AuthLinkSpeed             424
#define SID_S_AuthNotify                425
#define SID_S_AuthProject               426
#define SID_S_AuthRetry                 427
#define SID_S_Authenticate              428
#define SID_S_Authenticated             429
#define SID_S_ConnectDevice             430
#define SID_S_ConnectModemNoNum         431
#define SID_S_ConnectModemOperator      432
#define SID_S_ConnectNull               433
#define SID_S_ConnectNumber             434
#define SID_S_ConnectPad                435
#define SID_S_ConnectPostSwitch         436
#define SID_S_ConnectPreSwitch          437
#define SID_S_Connected                 438
#define SID_S_DeviceConnected           439
#define SID_S_Disconnected              440
#define SID_S_ModemConnected            441
#define SID_S_NullConnected             442
#define SID_S_OpenPort                  443
#define SID_S_PadConnected              444
#define SID_S_PortOpened                445
#define SID_S_PostSwitchConnected       446
#define SID_S_PreSwitchConnected        447
#define SID_S_PrepareForCallback        448
#define SID_S_Projected                 449
#define SID_S_ReAuthenticate            450
#define SID_S_SubConnected              451
#define SID_S_Unknown                   452
#define SID_S_WaitForCallback           453
#define SID_S_WaitForModemReset         454
#define SID_SavePreview                 455
#define SID_ScpDefExt                   456
#define SID_ScpFilter                   457
#define SID_ScpFilterDesc               458
#define SID_ScpTitle                    459
#define SID_SelectOneLink               460
#define SID_SharedPhoneNumber           461
#define SID_SlipNeedsIp                 462
#define SID_SlipWithoutIp               463
#define SID_StatusColHead               464
#define SID_SuffixItemLabel             465
#define SID_SuffixListLabel             466
#define SID_SuffixTitle                 467
#define SID_TC_Subtitle                 468
#define SID_TC_Title                    469
#define SID_T_ManualDialTerminal        470
#define SID_T_PostconnectTerminal       471
#define SID_T_PreconnectTerminal        472
#define SID_T_SlipTerminal              473
#define SID_Time10m                     474
#define SID_Time10s                     475
#define SID_Time1h                      476
#define SID_Time1m                      477
#define SID_Time24h                     478
#define SID_Time2h                      479
#define SID_Time2m                      480
#define SID_Time30m                     481
#define SID_Time30s                     482
#define SID_Time3s                      483
#define SID_Time4h                      484
#define SID_Time4m                      485
#define SID_Time5m                      486
#define SID_Time5s                      487
#define SID_Time8h                      488
#define SID_TimeNever                   489
#define SID_US_Subtitle                 490
#define SID_US_Title                    491
#define SID_UnMultiLink                 492
#define SID_UnknownDevice               493
#define SID_UpLogonTitle                494
#define SID_UpTitle                     495
#define SID_X25                         496
#define SID_X25Pad                      497
#define DID_UA_RetryAuthenticationU     498
#define SID_SW_Subtitle                 498
#define SID_DA_Title                    499
#define DID_UA_RetryAuthenticationUD    500
#define SID_OP_EnableDemandDial         500
#define SID_DA_Subtitle                 501
#define DID_NE_PppSettings              502
#define SID_OP_DisableDemandDial        502
#define SID_PN_Title                    503
#define SID_PN_Subtitle                 504
#define SID_DefaultVpnPort              505
#define CID_BM_Wizard                   506
#define SID_SP_Title                    506
#define SID_SP_Subtitle                 507
#define SID_GH_Title                    508
#define PID_GH_GuestHost                509
#define SID_ChangeSharedConnection      509
#define SID_GH_Subtitle                 510
#define PID_DN_DccDevice                511
#define SID_EnableSharedAccess          511
#define SID_DN_Title                    512
#define SID_DN_Subtitle                 513
#define SID_ConnectButton               514
#define SID_DataEncServerDetermine      515
#define SID_DataEncAlways               516
#define SID_DataEncMppe40               517
#define SID_DataEncMppe128              518
#define SID_MschapOrEapRequired         519
#define SID_CustAuthMsgTitle            520
#define SID_AuthVpnNormal               521
#define SID_S_ConnectVpn                521
#define SID_AuthVpnSecure               522
#define SID_CN_Title                    522
#define SID_ST_VpnAuto                  523
#define SID_ST_VpnPptp                  524
#define SID_ST_VpnL2tp                  525
#define SID_LA_Subtitle                 526
#define SID_LA_Title                    527
#define PID_CO_Connections              528
#define SID_DialerHelpCmdLine           528
#define SID_DefaultVpnEntryName         529
#define SID_LO_DescPhysAny              530
#define SID_LO_DescPhysPassword         531
#define DID_CR_CallbackRouter           532
#define SID_TypeEntryName               532
#define SID_LO_DescPhysPassData         533
#define PID_OE_OptionsRouter            534
#define SID_TypePortNumber              534
#define SID_LO_DescPhysCustom           535
#define SID_LO_DescVpnNormal            536
#define SID_LO_DescVpnSecure            537
#define SID_LO_DescVpnCustom            538
#define DID_DR_DialerI                  539
#define SID_DuplicatePortNumber         539
#define DID_DR_DialerIN                 540
#define SID_TypeResponseList            540
#define DID_DR_DialerINL                541
#define SID_NoDeleteSelection           541
#define SID_Time1s                      542
#define SID_NoModifySelection           543
#define PID_SW_SharedAccess             544
#define PID_SP_SharedLan                545
#define PID_SC_SmartCard                546
#define PID_RW_RouterWelcome            547
#define PID_CT_RouterConnectionType     548
#define SID_CN_SubtitleDccGuest         549
#define PID_VD_RouterVpnDestination     550
#define DID_DR_DialerID                 551
#define DID_DR_DialerIDN                552
#define DID_DR_DialerIDNL               553
#define PID_GE_RouterGeneralMultiple    554
#define PID_GE_RouterGeneralSingle      555
#define DID_SA_Application              556
#define DID_SS_Service                  557
#define PID_SA_SharedAccessApplications 558
#define PID_SS_SharedAccessServices     559
#define DID_VI_VpnInitial               560
#define IID_Dun1			562
#define IID_Broadband                   563
#define PID_BS_BroadbandService         567
#define PID_GE_GeneralBroadband         568
#define PID_LO_SecurityVpn              569
#define DID_CI_CustomIPSec              570
#define PID_FW_FirewallLogging          571
#define PID_FW_ICMP                     572
#define PID_SA_HomenetUnavailable       574
#define CID_SA_ST_ErrorText             575
#define SID_Time20m                     576
#define PID_CN_ConnectionName           577
#define SID_CN_SubtitleWork             579
#define PID_VT_RouterVpnType            580
#define SID_NetworkApplicationSettings  581
#define SID_CN_HMsgWork                 582
#define SID_CN_HMsgDccGuest             583
#define SID_CN_HMsgInternet             584
#define SID_CN_SubtitleInternet         585
#define SID_SS_TypeAddress              586
#define SID_SharedAccessSettings        587
#define SID_BadEntryWithDot             588
#define SID_PropertiesHeader            589
#define CID_AD_EB_Attempts              1001
#define CID_AD_EB_Idle                  1002
#define CID_AD_EB_Seconds               1003
#define CID_AD_LV_Enable                1004
#define CID_AD_ST_Attempts              1005
#define CID_AD_ST_Enable                1006
#define CID_AD_ST_Explain               1007
#define CID_AD_ST_Idle                  1008
#define CID_AD_ST_Seconds               1009
#define CID_AN_CB_MoveToTop             1010
#define CID_AN_CB_TryNextOnFail         1011
#define CID_AN_LV_Numbers               1012
#define CID_AN_PB_Add                   1013
#define CID_AN_PB_Delete                1014
#define CID_AN_PB_Down                  1015
#define CID_AN_PB_Edit                  1016
#define CID_AN_PB_Up                    1017
#define CID_AN_ST_Explain               1018
#define CID_AN_ST_Numbers               1019
#define CID_AQ_CB_AlwaysPrompt          1020
#define CID_AQ_CB_DisableAutoDialForSession 1021
#define CID_AQ_I_DialUp                 1022
#define CID_AQ_CB_DisableAutoDial       1022
#define CID_AQ_CB_DisableThisSession    1022
#define CID_AQ_LB_DialFrom              1023
#define CID_AQ_PB_Dial                  1024
#define CID_AQ_PB_DoNotDial             1025
#define CID_AQ_PB_Expand                1026
#define CID_AQ_PB_Settings              1026
#define CID_AQ_ST_DialFrom              1027
#define CID_AQ_ST_Separator             1028
#define CID_AQ_ST_Text                  1029
#define CID_BE_CB_DisableLink           1030
#define CID_BE_I_Information            1031
#define CID_BE_LV_Errors                1032
#define CID_BE_ST_Text                  1033
#define CID_CA_LB_Packages              1034
#define CID_CA_LB_EapPackages           1034
#define CID_CA_PB_Properties            1035
#define CID_CA_ST_Packages              1036
#define CID_CB_LV_Numbers               1037
#define CID_CB_PB_Delete                1038
#define CID_CB_PB_Edit                  1039
#define CID_CB_RB_Maybe                 1040
#define CID_CB_RB_No                    1041
#define CID_CB_RB_Yes                   1042
#define CID_CB_ST_Explain               1043
#define CID_CC_CB_SkipMessage           1045
#define CID_CC_I_Rasmon                 1046
#define CID_CC_ST_Text                  1047
#define CID_CE_CB_UseDialingRules       1048
#define CID_CE_CLB_AreaCodes            1049
#define CID_CE_EB_Comment               1050
#define CID_CE_EB_PhoneNumber           1051
#define CID_CE_GB_Comment               1052
#define CID_CE_GB_PhoneNumber           1053
#define CID_CE_LB_CountryCodes          1054
#define CID_CE_ST_AreaCodes             1055
#define CID_CE_ST_CountryCodes          1056
#define CID_CE_ST_PhoneNumber           1057
#define CID_CP_EB_ConfirmPassword       1058
#define CID_CP_EB_OldPassword           1059
#define CID_CP_EB_Password              1060
#define CID_CP_ST_ConfirmPassword       1061
#define CID_CP_ST_Explain               1062
#define CID_CP_ST_OldPassword           1063
#define CID_CP_ST_Password              1064
#define CID_DC_EB_Number                1065
#define CID_DC_ST_Explain               1066
#define CID_DC_ST_Number                1067
#define CID_DE_I_Exclamation            1068
#define CID_DE_PB_More                  1069
#define CID_DE_ST_Text                  1070
#define CID_DI_EB_Confirm               1071
#define CID_DI_EB_Domain                1072
#define CID_DI_EB_Password              1073
#define CID_DI_EB_UserName              1074
#define CID_DI_ST_Confirm               1075
#define CID_DI_ST_Domain                1076
#define CID_DI_ST_Password              1077
#define CID_DI_ST_UserName              1078
#define CID_DM_LB_DialPercent           1079
#define CID_DM_LB_DialTime              1080
#define CID_DM_LB_HangUpPercent         1081
#define CID_DM_LB_HangUpTime            1082
#define CID_DM_ST_Dial                  1083
#define CID_DM_ST_DialOrMore            1084
#define CID_DM_ST_Explain               1085
#define CID_DM_ST_HangUp                1086
#define CID_DM_ST_HangUpOrLess          1087
#define CID_DO_EB_Confirm               1088
#define CID_DO_EB_Domain                1089
#define CID_DO_EB_Password              1090
#define CID_DO_EB_UserName              1091
#define CID_DO_ST_Confirm               1092
#define CID_DO_ST_Domain                1093
#define CID_DO_ST_Explain               1094
#define CID_DO_ST_Password              1095
#define CID_DO_ST_UserName              1096
#define CID_DP_ST_State                 1097
#define CID_DQ_I_DialUp                 1098
#define CID_DQ_ST_Text                  1099
#define CID_DR_BM_Useless               1100
#define CID_DR_CB_SavePassword          1101
#define CID_DR_EB_Domain                1102
#define CID_DR_EB_Password              1103
#define CID_DR_EB_User                  1104
#define CID_DR_PB_Properties            1107
#define CID_DR_PB_Rules                 1108
#define CID_DR_ST_Domain                1110
#define CID_DR_ST_Password              1112
#define CID_EN_EB_EntryName             1114
#define CID_ES_LB_Encryptions           1115
#define CID_ES_ST_Encryptions           1116
#define CID_GE_CB_SharedPhoneNumber     1119
#define CID_GE_CB_ShowIcon              1120
#define CID_GE_CB_UseDialingRules       1121
#define CID_GE_CLB_AreaCodes            1122
#define CID_GE_EB_PhoneNumber           1123
#define CID_GE_GB_ConnectUsing          1124
#define CID_GE_GB_PhoneNumber           1125
#define CID_GE_LB_CountryCodes          1126
#define CID_GE_LV_Device                1127
#define CID_GE_LV_Devices               1128
#define CID_GE_PB_Alternates            1129
#define CID_GE_PB_Configure             1130
#define CID_GE_PB_MoveDown              1131
#define CID_GE_PB_MoveUp                1132
#define CID_GE_ST_AreaCodes             1133
#define CID_GE_ST_CountryCodes          1134
#define CID_GE_ST_PhoneNumber           1135
#define CID_GP_CB_AutodialPrompt        1136
#define CID_GE_PB_DialingRules          1136
#define CID_GP_CB_CloseOnDial           1137
#define CID_GP_CB_Lights                1138
#define CID_GP_CB_Location              1139
#define CID_GP_CB_LocationEdits         1140
#define CID_GP_CB_PhonebookEdits        1141
#define CID_GP_CB_Preview               1142
#define CID_GP_CB_Progress              1143
#define CID_GP_CB_UseWizard             1144
#define CID_IC_CB_Compression           1148
#define CID_IC_CB_DownLevel             1149
#define CID_IC_CB_Fallback              1150
#define CID_IC_EB_Channels              1151
#define CID_IC_GB_DownLevel             1152
#define CID_IC_LB_LineType              1153
#define CID_IC_ST_Channels              1154
#define CID_IC_ST_LineType              1155
#define CID_IN_CB_SkipWizard            1156
#define CID_IN_EB_InterfaceName         1157
#define CID_IN_ST_Explain               1158
#define CID_IN_ST_InterfaceName         1159
#define CID_IT_CC_IpAddress             1160
#define CID_IT_EB_Screen                1161
#define CID_IT_PB_BogusButton           1162
#define CID_IT_ST_IpAddress             1163
#define CID_LO_CB_Encryption            1169
#define CID_LO_CB_PreviewDomain         1170
#define CID_LO_CB_PreviewUserPw         1171
#define CID_LO_CB_RunScript             1172
#define CID_LO_CB_Terminal              1173
#define CID_LO_CB_UseWindowsPw          1174
#define CID_LO_CB_WindowsLogon          1174
#define CID_LO_GB_Encryption            1175
#define CID_LO_GB_Password              1176
#define CID_LO_GB_Scripting             1177
#define CID_LO_LB_Auths                 1178
#define CID_LO_LB_Authentication        1178
#define CID_LO_LB_Scripts               1179
#define CID_LO_PB_AuthSettings          1180
#define CID_LO_PB_Advanced              1180
#define CID_LO_PB_Browse                1181
#define CID_LO_PB_Edit                  1182
#define CID_LO_PB_EncryptionSettings    1183
#define CID_LS_EB_Condition             1184
#define CID_LS_EB_Response              1185
#define CID_LS_GB_ConnStats             1186
#define CID_LS_GB_DevStats              1187
#define CID_LS_GB_Errors                1188
#define CID_LS_LB_Devices               1189
#define CID_LS_PB_Details               1190
#define CID_LS_PB_HangUp                1191
#define CID_LS_PB_Reset                 1192
#define CID_LS_SL_Condition             1193
#define CID_LS_SL_ConnInBytes           1194
#define CID_LS_SL_ConnOutBytes          1195
#define CID_LS_SL_ConnectTime           1196
#define CID_LS_SL_DevInBytes            1197
#define CID_LS_SL_DevOutBytes           1198
#define CID_LS_SL_Devices               1199
#define CID_LS_SL_ErrAlignment          1200
#define CID_LS_SL_ErrBufOverruns        1201
#define CID_LS_SL_ErrCRC                1202
#define CID_LS_SL_ErrFraming            1203
#define CID_LS_SL_ErrHwOverruns         1204
#define CID_LS_SL_ErrTimeout            1205
#define CID_LS_SL_InCompRatio           1206
#define CID_LS_SL_InFrames              1207
#define CID_LS_SL_LineSpeed             1208
#define CID_LS_SL_OutCompRatio          1209
#define CID_LS_SL_OutFrames             1210
#define CID_LS_ST_ConnInBytes           1211
#define CID_LS_ST_ConnOutBytes          1212
#define CID_LS_ST_ConnectTime           1213
#define CID_LS_ST_DevInBytes            1214
#define CID_LS_ST_DevOutBytes           1215
#define CID_LS_ST_ErrAlignment          1216
#define CID_LS_ST_ErrBufOverruns        1217
#define CID_LS_ST_ErrCRC                1218
#define CID_LS_ST_ErrFraming            1219
#define CID_LS_ST_ErrHwOverruns         1220
#define CID_LS_ST_ErrTimeout            1221
#define CID_LS_ST_InCompRatio           1222
#define CID_LS_ST_InFrames              1223
#define CID_LS_ST_LineSpeed             1224
#define CID_LS_ST_OutCompRatio          1225
#define CID_LS_ST_OutFrames             1226
#define CID_LS_ST_Response              1227
#define CID_MA_LV_Devices               1228
#define CID_MC_CB_Compression           1229
#define CID_MC_CB_EnableSpeaker         1230
#define CID_MC_CB_ErrorControl          1231
#define CID_MC_CB_FlowControl           1232
#define CID_MC_CB_RunScript             1233
#define CID_MC_CB_Terminal              1234
#define CID_MC_EB_ModemValue            1235
#define CID_MC_GB_BeforeDial            1236
#define CID_MC_GB_Features              1237
#define CID_MC_I_Modem                  1238
#define CID_MC_LB_MaxBps                1239
#define CID_MC_LB_Scripts               1240
#define CID_MC_PB_Browse                1241
#define CID_MC_PB_Edit                  1242
#define CID_MC_ST_MaxBps                1243
#define CID_MC_ST_ModemProtocol         1244
#define CID_MC_LB_ModemProtocol         1245
#define CID_NE_LB_ComponentDesc         1250
#define CID_NE_LV_Components            1251
#define CID_NE_PB_Add                   1252
#define CID_NE_PB_Properties            1253
#define CID_NE_PB_Remove                1254
#define CID_NR_SL_Framing               1255
#define CID_NR_SL_IpAddress             1256
#define CID_NR_SL_IpServer              1257
#define CID_NR_SL_Ipx                   1258
#define CID_NR_SL_IpxNetNumber          1259
#define CID_NR_SL_IpxNodeID             1260
#define CID_NR_SL_NbfName               1261
#define CID_NR_SL_NetBeui               1262
#define CID_NR_SL_Tcpip                 1263
#define CID_NR_ST_Framing               1264
#define CID_NR_ST_IpAddress             1265
#define CID_NR_ST_IpServer              1266
#define CID_NR_ST_IpxNetNumber          1267
#define CID_NR_ST_IpxNodeID             1268
#define CID_NR_ST_NameString            1269
#define CID_NR_ST_NameTitle             1270
#define CID_NR_ST_NbfName               1271
#define CID_NS_CC_Dns                   1272
#define CID_NS_CC_Wins                  1273
#define CID_NS_ST_Dns                   1274
#define CID_NS_ST_Explain               1275
#define CID_NS_ST_Wins                  1276
#define CID_NW_CB_SkipPopup             1277
#define CID_NW_I_Exclamation            1278
#define CID_NW_ST_Explain1              1279
#define CID_NW_ST_Explain2              1280
#define CID_OD_ST_Explain               1281
#define CID_OD_ST_PhoneNumber           1282
#define CID_OD_ST_PhoneNumberValue      1283
#define CID_OE_CB_DisplayProgress       1284
#define CID_OE_CB_PreviewNumber         1285
#define CID_OE_CB_RedialOnDrop          1286
#define CID_OE_EB_RedialAttempts        1287
#define CID_OE_GB_MultipleDevices       1288
#define CID_OE_GB_Progress              1289
#define CID_OE_GB_Redial                1290
#define CID_OE_LB_IdleTimes             1291
#define CID_OE_LB_RedialTimes           1292
#define CID_OE_PB_Configure             1293
#define CID_OE_PB_Tunnel                1294
#define CID_OE_PB_X25                   1295
#define CID_OE_RB_DialAll               1296
#define CID_OE_CB_PromptBeforeDialing   1296
#define CID_OE_RB_DialNeeded            1297
#define CID_OE_CB_IncludeDomain         1297
#define CID_OE_RB_DialOnlyFirst         1298
#define CID_OE_ST_IdleTimes             1299
#define CID_OE_ST_RedialAttempts        1300
#define CID_OE_ST_RedialTimes           1301
#define CID_PA_CB_UseAreaCountry        1302
#define CID_OE_PB_Callback              1302
#define CID_PA_CLB_Area                 1303
#define CID_PA_EB_Number                1304
#define CID_PA_LB_Country               1305
#define CID_PA_ST_Area                  1306
#define CID_PA_ST_Country               1307
#define CID_PA_ST_Number                1308
#define CID_PF_GB_PlaySound             1309
#define CID_PF_GB_ShowLights            1310
#define CID_PF_PB_Lights                1311
#define CID_PF_PB_OnConnect             1312
#define CID_PF_PB_OnDisconnect          1313
#define CID_PF_PB_OnLineError           1314
#define CID_PF_PB_OnTransmission        1315
#define CID_PF_PB_Tasklist              1316
#define CID_PF_PB_Titlebar              1317
#define CID_PF_PB_Topmost               1318
#define CID_PF_RB_Desktop               1319
#define CID_PF_RB_Taskbar               1320
#define CID_PL_CL_Lists                 1321
#define CID_PL_PB_Browse                1322
#define CID_PL_RB_AlternateList         1323
#define CID_PL_RB_PersonalList          1324
#define CID_PL_RB_SystemList            1325
#define CID_PL_ST_Open                  1326
#define CID_PR_CB_DisableProtocols      1327
#define CID_PR_I_Information            1328
#define CID_PR_ST_Text                  1329
#define CID_RA_CC_Ip                    1330
#define CID_RA_ST_Explain               1331
#define CID_RA_ST_Ip                    1332
#define CID_RA_ST_Note                  1333
#define CID_RC_LB_Scripts               1334
#define CID_RC_PB_Edit                  1335
#define CID_RC_PB_Refresh               1336
#define CID_RC_RB_None                  1337
#define CID_RC_RB_Script                1338
#define CID_RC_ST_Explain               1339
#define CID_RD_EB_Attempts              1340
#define CID_RD_EB_Idle                  1341
#define CID_RD_EB_Seconds               1342
#define CID_RD_GB_DemandDial            1343
#define CID_RD_GB_DialingPolicy         1344
#define CID_RD_PB_Callback              1345
#define CID_RD_PB_MultipleLines         1346
#define CID_RD_RB_DemandDial            1347
#define CID_RD_RB_Persistent            1348
#define CID_RD_ST_Attempts              1349
#define CID_RD_ST_Idle                  1350
#define CID_RD_ST_Seconds               1351
#define CID_RF_ST_Explain               1352
#define CID_RF_ST_Interface             1353
#define CID_RF_ST_Note                  1354
#define CID_RN_LV_Devices               1355
#define CID_RF_ST_Note2                 1355
#define CID_RN_ST_Device                1356
#define CID_RN_ST_Explain               1357
#define CID_RP_EB_Number                1358
#define CID_RP_PB_Alternates            1359
#define CID_RP_ST_Explain               1360
#define CID_RP_ST_Number                1361
#define CID_SE_CB_AuthenticateServer    1362
#define CID_SE_CB_RequireDataEncryption 1363
#define CID_SE_CB_RequireStrongDataEncryption 1364
#define CID_SE_CB_SecureLocalFiles      1365
#define CID_SE_CB_UseLogonCredentials   1366
#define CID_SE_GB_AuthEncryption        1367
#define CID_SE_PB_Advanced              1368
#define CID_SE_PB_UnsavePw              1369
#define CID_SE_RB_AnyAuth               1370
#define CID_SE_RB_EncryptedAuth         1373
#define CID_SE_RB_MsEncryptedAuth       1374
#define CID_SL_LV_Devices               1375
#define CID_SL_PB_Header                1376
#define CID_SL_SL_Devices               1377
#define CID_SM_PB_Details               1378
#define CID_SM_PB_HangUp                1379
#define CID_SM_ST_Summary               1380
#define CID_SM_TL_Networks              1381
#define CID_SS_CB_AddUser               1382
#define CID_SS_CB_AuthRemote            1383
#define CID_SS_CB_NotNt                 1384
#define CID_SS_CB_PlainPw               1385
#define CID_SS_CB_RouteIp               1386
#define CID_SS_CB_RouteIpx              1387
#define CID_SS_ST_CheckAll              1388
#define CID_UA_CB_SavePassword          1391
#define CID_UA_EB_Domain                1392
#define CID_UA_EB_Password              1393
#define CID_UA_EB_UserName              1394
#define CID_UA_ST_Domain                1395
#define CID_UA_ST_Explain               1396
#define CID_UA_ST_Password              1397
#define CID_UA_ST_Separator             1398
#define CID_UA_ST_UserName              1399
#define CID_US_RB_All                   1400
#define CID_US_RB_Myself                1401
#define CID_XS_EB_Address               1402
#define CID_XS_EB_Facilities            1403
#define CID_XS_EB_UserData              1404
#define CID_XS_GB_Optional              1405
#define CID_XS_LB_Networks              1406
#define CID_XS_ST_Address               1407
#define CID_XS_ST_Explain               1408
#define CID_XS_ST_Facilities            1409
#define CID_XS_ST_Networks              1410
#define CID_XS_ST_UserData              1411
#define CID_DR_ST_Numbers               1412
#define CID_DR_ST_User                  1413
#define CID_DR_LB_Locations             1414
#define CID_DR_ST_Locations             1415
#define CID_DR_CLB_Numbers              1416
#define CID_DP_Icon                     1417
#define CID_NE_LB_ServerType            1418
#define CID_NE_PB_Settings              1419
#define DID_DR_DialerN                  1420
#define DID_DR_DialerUNL                1421
#define DID_DR_DialerUDNL               1422
#define CID_NE_EnableLcp                1423
#define CID_NE_EnableCompression        1424
#define PID_GE_GeneralVpn               1425
#define PID_OE_OptionsVD                1426
#define CID_GE_EB_HostName              1427
#define PID_DA_VpnDestination           1427
#define CID_GE_CB_DialAnotherFirst      1428
#define PID_PN_PublicNetwork            1428
#define CID_GE_LB_DialAnotherFirst      1429
#define CID_GE_ST_HostName              1430
#define CID_GE_GB_FirstConnect          1431
#define CID_GE_ST_Explain               1432
#define CID_DA_EB_HostName              1433
#define CID_PN_LB_DialAnotherFirst      1435
#define PID_GE_GeneralDirect            1436
#define CID_GE_LB_Devices               1437
#define DID_DU_DialUpNetworking         1448
#define CID_DU_PB_Dial                  1449
#define CID_DU_PB_Location              1450
#define CID_DU_ST_DialPreview           1451
#define CID_DU_ST_DialFrom              1452
#define CID_DU_EB_DialPreview           1453
#define CID_DU_PB_Close                 1455
#define CID_DU_ST_Entries               1456
#define CID_DU_LB_Entries               1457
#define CID_DU_ST_Separator             1458
#define CID_DU_PB_New                   1459
#define CID_DU_PB_More                  1460
#define CID_RC_CB_Terminal              1462
#define CID_RC_CB_RunScript             1463
#define CID_RC_CLB_Scripts              1464
#define CID_RC_PB_Browse                1465
#define DID_LE_ListEditor               1466
#define DID_LE_ListEditor2              1467
#define DID_LE_ListEditor3              1468
#define CID_LE_ST_Item                  1469
#define PID_LA_NameAndType              1469
#define CID_LE_EB_Item                  1470
#define CID_LE_PB_Add                   1471
#define CID_LE_PB_Replace               1472
#define CID_LE_ST_List                  1473
#define CID_LE_LB_List                  1474
#define CID_LE_PB_Up                    1475
#define CID_LE_PB_Down                  1476
#define CID_LE_PB_Delete                1477
#define CID_LE_CB_Promote               1478
#define CID_LE_ST_Separator             1479
#define DID_ZE_StringEditor             1480
#define CID_ZE_ST_String                1481
#define PID_DT_DefaultInternet          1481
#define CID_ZE_EB_String                1482
#define CID_GH_RB_Host                  1483
#define CID_GH_RB_Guest                 1484
#define CID_DN_CB_DeviceSelect          1485
#define CID_LA_RB_Phone                 1488
#define CID_LA_RB_Tunnel                1489
#define CID_LA_RB_Direct                1490
#define CID_CA_CB_Pap                   1491
#define CID_LA_RB_Broadband             1491
#define CID_CA_CB_Eap                   1492
#define CID_CA_CB_MsChap2               1492
#define CID_CA_CB_MsChap                1493
#define CID_CA_CB_Chap                  1494
#define CID_CA_LB_Encryption            1495
#define CID_AD_CB_AskBeforeAutodial     1496
#define CID_CA_CB_Spap                  1496
#define CID_CO_CB_AllowConnectionModification 1497
#define CID_CO_CB_UseWizard             1498
#define CID_CR_RB_No                    1501
#define CID_CR_RB_Yes                   1502
#define CID_CR_LV_Numbers               1503
#define CID_CR_PB_Edit                  1504
#define CID_CR_PB_Delete                1505
#define CID_OE_RB_DemandDial            1506
#define CID_OE_RB_Persistent            1507
#define CID_LO_ST_AuthDescription       1508
#define CID_PN_RB_DoNotDialFirst        1509
#define CID_PN_RB_DialFirst             1510
#define CID_SW_PB_Shared                1512
#define SID_FriendlyComPort             1512
#define CID_SW_PB_DemandDial            1513
#define CID_SW_ST_DemandDial            1514
#define CID_SA_ST_PrivateLan            1515
#define CID_SA_LB_PrivateLan            1516
#define CID_SA_GB_Shared                1517
#define CID_SA_GB_PrivateLan            1518
#define CID_SA_SF_PrivateLan            1519
#define CID_SA_EB_PrivateLan            1521
#define CID_SP_LB_PrivateLan            1522
#define SID_Channel                     1523
#define CID_SC_RB_YesSmartCard          1524
#define CID_SC_RB_NoSmartCard           1525
#define SID_SC_Title                    1526
#define SID_SC_Subtitle                 1527
#define SID_DefaultDccEntryName         1528
#define CID_RF_EB_InterfaceName         1528
#define SID_SelectDevice                1529
#define CID_RF_ST_InterfaceName         1529
#define CID_RW_ST_Welcome               1530
#define SID_LargeFontName               1530
#define CID_RW_ST_Explain               1531
#define SID_LargeFontSize               1531
#define CID_CT_RB_Physical              1531
#define CID_RW_ST_Explain2              1532
#define SID_CT_Title                    1532
#define CID_CT_RB_Virtual               1532
#define CID_VT_RB_Pptp                  1532
#define SID_CT_Subtitle                 1533
#define CID_VT_RB_L2tp                  1533
#define SID_RN_Title                    1534
#define CID_VT_RB_Automatic             1534
#define SID_RN_Subtitle                 1535
#define CID_VD_ST_Explain               1535
#define SID_RP_Title                    1536
#define CID_VD_EB_NameOrAddress         1536
#define SID_RP_Subtitle                 1537
#define CID_VD_ST_HostBoxLabel          1537
#define CID_LO_ST_Authentication        1537
#define CID_LO_ST_Auths                 1537
#define SID_VT_Title                    1538
#define CID_SA_PB_Add                   1538
#define SID_VT_Subtitle                 1539
#define CID_LO_ST_AdvancedText          1539
#define SID_VD_Title                    1540
#define CID_LO_RB_TypicalSecurity       1540
#define SID_VD_Subtitle                 1541
#define CID_LO_RB_AdvancedSecurity      1541
#define SID_LO_GB_TypicalSecurity       1542
#define CID_LO_GB_TypicalSecurity       1542
#define SID_LO_GB_AdvancedSecurity      1543
#define CID_LO_GB_AdvancedSecurity      1543
#define SID_RA_Title                    1544
#define CID_CA_RB_Eap                   1544
#define SID_RA_Subtitle                 1545
#define CID_CA_RB_AllowedProtocols      1545
#define SID_NS_Title                    1546
#define CID_CA_ST_Encryption            1546
#define SID_NS_Subtitle                 1547
#define CID_CA_GB_LogonSecurity         1547
#define SID_RC_Title                    1548
#define CID_SA_PB_Tcp                   1548
#define SID_RC_Subtitle                 1549
#define CID_CA_CB_UseWindowsPw          1549
#define SID_DI_Title                    1550
#define CID_AD_CB_DisableThisSession    1550
#define SID_DI_Subtitle                 1551
#define CID_SA_EB_UdpResponse           1551
#define CID_OE_LB_MultipleDevices       1551
#define SID_DO_Title                    1552
#define CID_SS_EB_Service               1552
#define SID_DO_Subtitle                 1553
#define CID_SS_EB_Port                  1553
#define SID_IN_Title                    1554
#define CID_SS_PB_Tcp                   1554
#define CID_OE_CB_PreviewUserPw         1554
#define SID_IN_Subtitle                 1555
#define CID_SS_PB_Udp                   1555
#define CID_OE_CB_PreviewDomain         1555
#define SID_NoDevices                   1556
#define CID_SS_EB_Address               1556
#define CID_NE_NegotiateMultilinkAlways 1557
#define SID_RouterUserExists            1557
#define CID_SA_LV_Applications          1558
#define SID_NoAuthForSlip               1558
#define CID_SA_PB_Edit                  1559
#define SID_AuthUnsecured               1559
#define CID_SS_LV_Services              1560
#define SID_AuthSecured                 1560
#define CID_SS_PB_Add                   1561
#define SID_AuthCardOrCert              1561
#define CID_SS_PB_Delete                1562
#define SID_NoAuthChecked               1562
#define CID_SS_PB_Edit                  1563
#define SID_DE_None                     1563
#define CID_SA_PB_Settings              1564
#define SID_DE_IfPossible               1564
#define CID_SA_EB_Application           1565
#define SID_DE_Require                  1565
#define CID_SA_EB_Port                  1566
#define SID_DE_RequireMax               1566
#define CID_SA_PB_Udp                   1567
#define SID_EncEnabled                  1567
#define CID_SA_PB_Delete                1568
#define SID_NoEncryption                1568
#define SID_DT_Title                    1568
#define CID_SA_EB_TcpResponse           1569
#define IDS_STRING1569                  1569
#define SID_DT_Subtitle                 1569
#define SID_NeedEapKeys                 1570
#define SID_MsChapRequired              1571
#define SID_SS_Title                    1572
#define SID_SS_Subtitle                 1573
#define SID_OptionalAuthQuery           1574
#define CID_VI_I_Information            1575
#define SID_VI_ST_Explain               1575
#define CID_VI_ST_Explain               1576
#define SID_VI_CB_SkipMessage           1576
#define SID_S_ConnectParallel           1576
#define SID_S_ConnectIrda               1577
#define SID_S_ParallelConnected         1578
#define CID_VI_CB_SkipMessage           1579
#define SID_S_IrdaConnected             1579
#define CID_LO_GB_SecurityOptions       1580
#define SID_NoStrongEncryption          1580
#define CID_CO_ST_AllowConnectionModification 1581
#define SID_NE_VpnServerLabel           1581
#define CID_CO_GB_LogonPrivileges       1582
#define SID_MissingUserName             1582
#define CID_NE_ST_ServerType            1583
#define SID_DR_GlobalPassword           1583
#define CID_CN_HMsgWork2                1584
#define SID_CN_HMsgWork2                1584
#define CID_NE_GB_Description           1585
#define SID_DT_TitleWork                1585
#define SID_NE_Reboot                   1586
#define SID_NE_ReadOnly                 1587
#define SID_NE_AccessDenied             1588
#define CID_SA_I_SharedAccess           1588
#define SID_ReplyMessageFmt             1589
#define CID_DR_PB_DialConnect           1590
#define SID_DR_ReconnectTitle           1590
#define CID_DR_PB_Cancel                1591
#define SID_PS_Title                    1591
#define SID_BS_Title                    1591
#define CID_DR_PB_Help                  1592
#define SID_PS_Subtitle                 1592
#define SID_BS_Subtitle                 1592
#define CID_BS_EB_ServiceName           1593
#define IDS_STRING1593                  1593
#define SID_DT_SubtitleWork             1593
#define SID_DefaultBbPort               1594
#define CID_GE_EB_ServiceName           1594
#define SID_ST_BbPppoe                  1595
#define CID_DT_CB_Default               1595
#define SID_NE_BbServerLabel            1596
#define CID_DT_CB_UseSharedCredentials  1596
#define CID_GE_ST_Devices               1597
#define SID_OP_EmptyPSK                 1597
#define CID_LO_PB_IPSec                 1598
#define CID_LO_RB_IPSecPolicy           1599
#define CID_LO_ST_IPSecText             1600
#define CID_CI_ST_Key                   1602
#define CID_LO_CB_IPSecPolicy           1603
#define CID_CI_CB_PresharedKey          1604
#define CID_CI_EB_PSK                   1605
#define CID_CI_CB_UserCerts             1606
#define CID_CI_CB_SpecificCerts         1607
#define CID_CI_PB_Select                1608
#define CID_CI_LB_CertsList             1610
#define SID_DefaultBbEntryName          1611
#define SID_HavetoEnterPSK              1612
#define SID_OP_CredCommit               1613
#define CID_DT_EB_UserName              1614
#define CID_DT_EB_UserName2             1615
#define CID_DT_EB_Password              1615
#define CID_DT_EB_UserName3             1616
#define CID_DT_EB_Password2             1616
#define CID_US_EB_UserName              1617
#define CID_US_EB_UserName2             1618
#define CID_US_EB_UserName3             1619
#define CID_US_CB_UseSharedCredentials  1620
#define CID_US_CB_Default               1621
#define CID_DR_RB_SaveForMe             1622
#define CID_DR_RB_SaveForEveryone       1623
#define SID_SA_NoWMIError               1634
#define SID_SA_StoreError               1635
#define CID_DT_ST_UserName              1636
#define CID_DT_ST_Password              1637
#define CID_DT_ST_Password2             1638
#define CID_FL_PB_Browse                1639
#define CID_FL_EB_Filesize              1640
#define CID_FL_CB_LogOutboundConnections 1641
#define CID_FL_CB_LogDroppedInbound     1642
#define CID_FL_PB_RestoreDefaults       1643
#define CID_IC_LV_Settings              1644
#define CID_IC_ST_Description           1645
#define SID_ICMP_IECHO                  1646
#define SID_ICMP_ITIME                  1647
#define SID_ICMP_IMASK                  1648
#define SID_ICMP_IROUT                  1649
#define SID_ICMP_ODEST                  1650
#define SID_ICMP_OQNCH                  1651
#define SID_ICMP_OPRAM                  1652
#define SID_ICMP_OTIME                  1653
#define SID_ICMP_XRDRT                  1654
#define SID_FwbDefExt                   1655
#define SID_FwbFilter                   1656
#define SID_FwbFilterDesc               1657
#define SID_FwbTitle                    1658
#define CID_SA_ST_HNWLink               1659
#define DID_SA_DisableFirewallWarning   1660
#define CID_SA_ST_ICSText               1661
#define CID_SA_PB_DisableFirewallWarning 1662
#define SID_SA_SelectAdapter            1663
#define SID_SA_SelectAdapterError       1664
#define SID_ICMP_IECHO_DESC             1665
#define SID_ICMP_ITIME_DESC             1666
#define SID_ICMP_IMASK_DESC             1667
#define SID_ICMP_IROUT_DESC             1668
#define SID_ICMP_ODEST_DESC             1669
#define SID_ICMP_OQNCH_DESC             1670
#define SID_ICMP_OPRAM_DESC             1671
#define SID_ICMP_OTIME_DESC             1672
#define SID_ICMP_XRDRT_DESC             1673
#define CID_FL_EB_Filename              1674
#define SID_FwbInvalidSize              1675
#define CID_AQ_LK_UsingAutodial         1676
#define CID_AQ_LV_Connections           1677
#define BID_DialerHi                    1678
#define CID_CN_EB_ConnectionName        1680
#define CID_CN_ST_HMsg                  1681
#define CID_DT_CB_Firewall              1682
#define CID_CN_ST_HMsg2                 1683
#define CID_NE_ST_Components            1684
#define SID_OP_DeletePw                 1684
#define SID_OP_LoadRasAccessDenied      1685
#define CID_GE_ST_ServiceName           1686
#define SID_DT_HMsgWork                 1686
#define SID_CN_NameDccGuest             1687
#define CID_CT_RB_Broadband             1688
#define SID_CN_NameInternet             1688
#define CID_DT_HeadMessage              1689
#define SID_CN_NameWork                 1689
#define CID_CN_Name                     1690
#define SID_PA_SubtitleWork             1690
#define CID_SA_PB_Shared                15022
#define CID_SA_PB_DemandDial            15023
#define CID_SA_ST_DemandDial            15025
#define CID_FW_PB_Firewalled            15026
#define IID_RM_Modem                    15102
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        589
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1691
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\security.c ===
// Copyright (c) 1997, Microsoft Corporation, all rights reserved
//
// security.c
// Remote Access Common Dialog APIs
// Security dialogs
//
// 11/06/97 Steve Cobb
//


#include "rasdlgp.h"
#include <rasauth.h>
#include <rrascfg.h>

const IID IID_IEAPProviderConfig =  {0x66A2DB19,
                                    0xD706,
                                    0x11D0,
                                    {0xA3,0x7B,0x00,0xC0,0x4F,0xC9,0xDA,0x04}};

//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwCaHelp[] =
{
    CID_CA_ST_Encryption,       HID_CA_LB_Encryption,
    CID_CA_LB_Encryption,       HID_CA_LB_Encryption,
    CID_CA_GB_LogonSecurity,    HID_CA_GB_LogonSecurity,
    CID_CA_RB_Eap,              HID_CA_RB_Eap,
    CID_CA_LB_EapPackages,      HID_CA_LB_EapPackages,
    CID_CA_PB_Properties,       HID_CA_PB_Properties,
    CID_CA_RB_AllowedProtocols, HID_CA_RB_AllowedProtocols,
    CID_CA_CB_Pap,              HID_CA_CB_Pap,
    CID_CA_CB_Spap,             HID_CA_CB_Spap,
    CID_CA_CB_Chap,             HID_CA_CB_Chap,
    CID_CA_CB_MsChap,           HID_CA_CB_MsChap,
    CID_CA_CB_W95MsChap,        HID_CA_CB_W95MsChap,
    CID_CA_CB_MsChap2,          HID_CA_CB_MsChap2,
    CID_CA_CB_UseWindowsPw,     HID_CA_CB_UseWindowsPw,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes
//----------------------------------------------------------------------------

// Custom authentication dialog argument block.
//
typedef struct
_CAARGS
{
    PBENTRY* pEntry;
    BOOL fStrongEncryption;

    // Set if we have been called via RouterEntryDlg.
    //
    BOOL fRouter;

    // Set if pszRouter is an NT4 steelhead machine.  Valid only 
    // if fRouter is true.
    //
    BOOL fNt4Router;

    // The name of the server in "\\server" form or NULL if none (or if
    // 'fRouter' is not set).
    //
    TCHAR* pszRouter;
}
CAARGS;

// Custom authentication dialog context block.
//
typedef struct
_CAINFO
{
    // Caller's arguments to the dialog.
    //
    CAARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndLbEncryption;
    HWND hwndRbEap;
    HWND hwndLbEapPackages;
    HWND hwndPbProperties;
    HWND hwndRbAllowedProtocols;
    HWND hwndCbPap;
    HWND hwndCbSpap;
    HWND hwndCbChap;
    HWND hwndCbMsChap;
    HWND hwndCbW95MsChap;
    HWND hwndCbMsChap2;
    HWND hwndCbUseWindowsPw;

    // List of EAPCFGs read from the registry, with the originally selected
    // node for use in consistency tests later.
    //
    DTLLIST* pListEapcfgs;
    DTLNODE* pOriginalEapcfgNode;

    // "Restore" states for controls that may be disabled with
    // EnableCbWithRestore or EnableLbWithRestore routines.
    //
    DWORD iLbEapPackages;
    BOOL fPap;
    BOOL fSpap;
    BOOL fChap;
    BOOL fMsChap;
    BOOL fW95MsChap;
    BOOL fMsChap2;
    BOOL fUseWindowsPw;
}
CAINFO;


//-----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//-----------------------------------------------------------------------------

VOID
CaCbToggle(
    IN CAINFO* pInfo,
    IN HWND hwndCb );

BOOL
CaCommand(
    IN CAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl );

INT_PTR CALLBACK
CaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
CaInit(
    IN HWND hwndDlg,
    IN CAARGS* pArgs );

VOID
CaLbEapPackagesSelChange(
    IN CAINFO* pInfo );

VOID
CaPropertiesLocal(
    IN CAINFO* pInfo );

VOID
CaPropertiesRemote(
    IN CAINFO* pInfo );

VOID
CaRbToggle(
    IN CAINFO* pInfo,
    IN BOOL fEapSelected );

BOOL
CaSave(
    IN CAINFO* pInfo );

VOID
CaTerm(
    IN HWND hwndDlg );


//----------------------------------------------------------------------------
// Advanced Security dialog routines
// Listed alphabetically following entrypoint and dialog proc
//----------------------------------------------------------------------------

BOOL
AdvancedSecurityDlg(
    IN HWND hwndOwner,
    IN OUT EINFO* pArgs )

    // Popup a dialog to select advanced security options for phonebook entry
    // represented by 'pArgs'.  'HwndOwner' is the owning window.
    //
    // Returns true if user pressed OK and succeeded or false on Cancel or
    // error.  If successful, the new configuration is written to the
    // appropriate 'pArgs->pEntry' fields.  The routine assumes that these same
    // 'pEntry' fields contain the desired defaults on entry.
    //
{
    INT_PTR nStatus;
    CAARGS args;

    TRACE( "AdvSecurityDlg" );

    args.pEntry = pArgs->pEntry;
    args.fStrongEncryption = pArgs->fStrongEncryption;
    args.fRouter = pArgs->fRouter;
    args.fNt4Router = pArgs->fNt4Router;
    args.pszRouter = pArgs->pszRouter;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( DID_CA_CustomAuth ),
            hwndOwner,
            CaDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
CaDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Custom Authentication dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "CaDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
        (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return CaInit( hwnd, (CAARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwCaHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            CAINFO* pInfo = (CAINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT( pInfo );

            return CaCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_DESTROY:
        {
            CaTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
CaCommand(
    IN CAINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "CaCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_CA_RB_Eap:
        case CID_CA_RB_AllowedProtocols:
        {
            switch (wNotification)
            {
                case BN_CLICKED:
                {
                    CaRbToggle( pInfo, (wId == CID_CA_RB_Eap) );
                    return TRUE;
                }
            }
            break;
        }

        case CID_CA_LB_EapPackages:
        {
            CaLbEapPackagesSelChange( pInfo );
            return TRUE;
        }

        case CID_CA_PB_Properties:
        {
            if (   ( pInfo->pArgs->fRouter )
                && ( !pInfo->pArgs->fNt4Router )
                && ( pInfo->pArgs->pszRouter ) 
                && ( pInfo->pArgs->pszRouter[0] ) )
            {
                CaPropertiesRemote( pInfo );
            }
            else
            {
                CaPropertiesLocal( pInfo );
            }

            return TRUE;
        }

        case CID_CA_CB_Pap:
        case CID_CA_CB_Spap:
        case CID_CA_CB_Chap:
        case CID_CA_CB_MsChap:
        case CID_CA_CB_W95MsChap:
        case CID_CA_CB_MsChap2:
        {
            CaCbToggle( pInfo, hwndCtrl );
            return TRUE;
        }

        case IDOK:
        {
            if (CaSave( pInfo ))
            {
                EndDialog( pInfo->hwndDlg, TRUE );
            }
            return TRUE;
        }

        case IDCANCEL:
        {
            TRACE( "Cancel pressed" );
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
        }
    }

    return FALSE;
}


VOID
CaCbToggle(
    IN CAINFO* pInfo,
    IN HWND hwndCb )

    // Called when one of the 6 authentication protocol check boxes is toggled
    // and/or the toggle processing should be performed.  'HwndCb' is the
    // window handle of the toggled checkbox or NULL if none.  'PInfo' is the
    // dialog context.
    //
{
    BOOL fMsChap;
    BOOL fW95MsChap;
    BOOL fMsChap2;

    fMsChap = Button_GetCheck( pInfo->hwndCbMsChap );

    EnableCbWithRestore(
        pInfo->hwndCbW95MsChap,
        fMsChap,
        FALSE,
        &pInfo->fW95MsChap );

    if (IsWindowEnabled( pInfo->hwndCbW95MsChap ))
    {
        fW95MsChap = Button_GetCheck( pInfo->hwndCbW95MsChap );
    }
    else
    {
        fW95MsChap = FALSE;
    }

    fMsChap2 = Button_GetCheck( pInfo->hwndCbMsChap2 );

    EnableCbWithRestore(
        pInfo->hwndCbUseWindowsPw,
        fMsChap || fW95MsChap || fMsChap2,
        FALSE,
        &pInfo->fUseWindowsPw );
}


BOOL
CaInit(
    IN HWND hwndDlg,
    IN CAARGS* pArgs )

    // Called on WM_INITDIALOG.  'HwndDlg' is the handle of the phonebook
    // dialog window.  'PArgs' is caller's arguments as passed to the stub
    // API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    DWORD dwAr;
    CAINFO* pInfo;
    PBENTRY* pEntry;

    TRACE( "CaInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pEntry = pArgs->pEntry;

    pInfo->hwndLbEncryption = GetDlgItem( hwndDlg, CID_CA_LB_Encryption );
    ASSERT( pInfo->hwndLbEncryption );
    pInfo->hwndRbEap = GetDlgItem( hwndDlg, CID_CA_RB_Eap );
    ASSERT( pInfo->hwndRbEap );
    pInfo->hwndLbEapPackages = GetDlgItem( hwndDlg, CID_CA_LB_EapPackages );
    ASSERT( pInfo->hwndLbEapPackages );
    pInfo->hwndPbProperties = GetDlgItem( hwndDlg, CID_CA_PB_Properties );
    ASSERT( pInfo->hwndPbProperties );
    pInfo->hwndRbAllowedProtocols =
        GetDlgItem( hwndDlg, CID_CA_RB_AllowedProtocols );
    ASSERT( pInfo->hwndRbAllowedProtocols );
    pInfo->hwndCbPap = GetDlgItem( hwndDlg, CID_CA_CB_Pap );
    ASSERT( pInfo->hwndCbPap );
    pInfo->hwndCbSpap = GetDlgItem( hwndDlg, CID_CA_CB_Spap );
    ASSERT( pInfo->hwndCbSpap );
    pInfo->hwndCbChap = GetDlgItem( hwndDlg, CID_CA_CB_Chap );
    ASSERT( pInfo->hwndCbChap );
    pInfo->hwndCbMsChap = GetDlgItem( hwndDlg, CID_CA_CB_MsChap );
    ASSERT( pInfo->hwndCbMsChap );
    pInfo->hwndCbW95MsChap = GetDlgItem( hwndDlg, CID_CA_CB_W95MsChap );
    ASSERT( pInfo->hwndCbW95MsChap );
    pInfo->hwndCbMsChap2 = GetDlgItem( hwndDlg, CID_CA_CB_MsChap2 );
    ASSERT( pInfo->hwndCbMsChap2 );
    pInfo->hwndCbUseWindowsPw = GetDlgItem( hwndDlg, CID_CA_CB_UseWindowsPw );
    ASSERT( pInfo->hwndCbUseWindowsPw );

    // Initialize the encryption list.
    //
    {
        LBTABLEITEM* pItem;
        INT i;

        static LBTABLEITEM aItems[] =
        {
            SID_DE_None, DE_None,
            SID_DE_IfPossible, DE_IfPossible,
            SID_DE_Require, DE_Require,
            SID_DE_RequireMax, DE_RequireMax,
            0, 0
        };

        static LBTABLEITEM aItemsExport[] =
        {
            SID_DE_None, DE_None,
            SID_DE_IfPossible, DE_IfPossible,
            SID_DE_Require, DE_Require,
            0, 0
        };

        // Warn user if entry is configured for strong encryption and none is
        // available on the machine.  (See bug 289692)
        //
        if (pEntry->dwDataEncryption == DE_RequireMax
            && !pArgs->fStrongEncryption)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoStrongEncryption, NULL );
            pEntry->dwDataEncryption = DE_Require;
        }

        for (pItem = (pArgs->fStrongEncryption) ? aItems : aItemsExport, i = 0;
             pItem->sidItem;
             ++pItem, ++i)
        {
            ComboBox_AddItemFromId(
                g_hinstDll, pInfo->hwndLbEncryption,
                pItem->sidItem, (VOID* )UlongToPtr(pItem->dwData));

            if (pEntry->dwDataEncryption == pItem->dwData)
            {
                ComboBox_SetCurSel( pInfo->hwndLbEncryption, i );
            }
        }
    }

    // Initialize EAP package list.
    //
    {
        DTLNODE* pNode;
        TCHAR* pszEncEnabled;

        // Read the EAPCFG information from the registry and find the node
        // selected in the entry, or the default, if none.
        //
        if (   ( pInfo->pArgs->fRouter )
            && ( !pInfo->pArgs->fNt4Router )
            && ( pInfo->pArgs->pszRouter )
            && ( pInfo->pArgs->pszRouter[0] ) )
        {
            pInfo->pListEapcfgs = ReadEapcfgList( pInfo->pArgs->pszRouter );
        }
        else
        {
            pInfo->pListEapcfgs = ReadEapcfgList( NULL );
        }

        if (pInfo->pListEapcfgs)
        {
            DTLNODE* pNodeEap;
            DWORD cbData = 0;
            PBYTE pbData = NULL;
            DWORD dwkey = pEntry->dwCustomAuthKey;
            

            for (pNodeEap = DtlGetFirstNode(pInfo->pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap))
            {
                EAPCFG* pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
                ASSERT( pEapcfg );

                pEntry->dwCustomAuthKey = pEapcfg->dwKey;

                if(NO_ERROR == DwGetCustomAuthData(
                                    pEntry,
                                    &cbData,
                                    &pbData)
                    &&  (cbData > 0)
                    &&  (pbData))
                {
                    VOID *pData = Malloc(cbData);

                    if(pData)
                    {
                        CopyMemory(pData,
                                   pbData,
                                   cbData);

                        Free0(pEapcfg->pData);
                        pEapcfg->pData = pData;
                        pEapcfg->cbData = cbData;
                    }
                }
            }

            pEntry->dwCustomAuthKey = dwkey;

            if (pEntry->dwCustomAuthKey == (DWORD )-1)
            {
                pNode = DtlGetFirstNode( pInfo->pListEapcfgs );
            }
            else
            {

                pNode = EapcfgNodeFromKey(
                    pInfo->pListEapcfgs, pEntry->dwCustomAuthKey );
            }

            pInfo->pOriginalEapcfgNode = pNode;
        }

        // Fill the EAP packages listbox and select the previously identified
        // selection.  The Properties button is disabled by default, but may
        // be enabled when the EAP list selection is set.
        //
        EnableWindow( pInfo->hwndPbProperties, FALSE );

        pszEncEnabled = PszFromId( g_hinstDll, SID_EncEnabled );
        if (pszEncEnabled)
        {
            for (pNode = DtlGetFirstNode( pInfo->pListEapcfgs );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                DWORD cb;
                EAPCFG* pEapcfg;
                INT i;
                TCHAR* pszBuf;

                pEapcfg = (EAPCFG* )DtlGetData( pNode );
                ASSERT( pEapcfg );
                ASSERT( pEapcfg->pszFriendlyName );

                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                cb = lstrlen( pEapcfg->pszFriendlyName ) +
                     lstrlen( pszEncEnabled ) + 1;

                pszBuf = Malloc( cb * sizeof(TCHAR) );
                if (!pszBuf)
                {
                    continue;
                }

                // Whistler bug 224074 use only lstrcpyn's to prevent
                // maliciousness
                //
                lstrcpyn( pszBuf, pEapcfg->pszFriendlyName, cb );
                if (pEapcfg->fProvidesMppeKeys)
                {
                    lstrcat( pszBuf, pszEncEnabled );
                }

                i = ComboBox_AddItem(
                    pInfo->hwndLbEapPackages, pszBuf, pNode );

                if (pNode == pInfo->pOriginalEapcfgNode)
                {
                    ComboBox_SetCurSelNotify( pInfo->hwndLbEapPackages, i );
                }

                Free( pszBuf );
            }

            Free0( pszEncEnabled );
            ComboBox_AutoSizeDroppedWidth( pInfo->hwndLbEapPackages );
        }

    }

    // Set initial check box settings.  The values may be changed when the
    // radio button handling does it's enabling/disabling.
    //
    dwAr = pEntry->dwAuthRestrictions;
    Button_SetCheck( pInfo->hwndCbPap, !!(dwAr & AR_F_AuthPAP) );
    Button_SetCheck( pInfo->hwndCbSpap, !!(dwAr & AR_F_AuthSPAP) );
    Button_SetCheck( pInfo->hwndCbChap, !!(dwAr & AR_F_AuthMD5CHAP) );
    Button_SetCheck( pInfo->hwndCbMsChap, !!(dwAr & AR_F_AuthMSCHAP) );
    Button_SetCheck( pInfo->hwndCbW95MsChap, !!(dwAr & AR_F_AuthW95MSCHAP) );
    Button_SetCheck( pInfo->hwndCbMsChap2, !!(dwAr & AR_F_AuthMSCHAP2) );

    if (!pInfo->pArgs->fRouter)
    {
        pInfo->fUseWindowsPw = pEntry->fAutoLogon;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, pInfo->fUseWindowsPw );
    }
    else
    {
        pInfo->fUseWindowsPw = FALSE;
        Button_SetCheck( pInfo->hwndCbUseWindowsPw, FALSE );
        EnableWindow( pInfo->hwndCbUseWindowsPw, FALSE );
        ShowWindow( pInfo->hwndCbUseWindowsPw, FALSE );
    }

    // Set the appropriate radio button which triggers appropriate
    // enabling/disabling.
    //
    {
        HWND hwndRb;

        if (dwAr & AR_F_AuthEAP)
        {
            hwndRb = pInfo->hwndRbEap;
        }
        else
        {
            hwndRb = pInfo->hwndRbAllowedProtocols;
        }

        SendMessage( hwndRb, BM_CLICK, 0, 0 );
    }

    // Center dialog on the owner window.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    SetFocus( pInfo->hwndLbEncryption );

    return TRUE;
}


VOID
CaLbEapPackagesSelChange(
    IN CAINFO* pInfo )

    // Called when the EAP list selection changes.  'PInfo' is the dialog
    // context.
    //
{
    EAPCFG* pEapcfg;
    INT iSel;

    // Get the EAPCFG information for the selected EAP package.
    //
    pEapcfg = NULL;
    iSel = ComboBox_GetCurSel( pInfo->hwndLbEapPackages );
    if (iSel >= 0)
    {
        DTLNODE* pNode;

        pNode =
            (DTLNODE* )ComboBox_GetItemDataPtr(
                pInfo->hwndLbEapPackages, iSel );
        if (pNode)
        {
            pEapcfg = (EAPCFG* )DtlGetData( pNode );
        }
    }

    // Enable the Properties button if the selected package has a
    // configuration entrypoint.
    //
    EnableWindow(
        pInfo->hwndPbProperties, (pEapcfg && !!(pEapcfg->pszConfigDll)) );
}


VOID
CaPropertiesLocal(
    IN CAINFO* pInfo )

    // Called when the EAP properties button is pressed.  Call the
    // configuration DLL to popup the properties of the package.  'PInfo' is
    // the dialog context.
    //
{
    DWORD dwErr;
    DTLNODE* pNode;
    EAPCFG* pEapcfg;
    RASEAPINVOKECONFIGUI pInvokeConfigUi;
    RASEAPFREE pFreeConfigUIData;
    HINSTANCE h;
    BYTE* pConnectionData;
    DWORD cbConnectionData;

    // Look up the selected package configuration and load the associated
    // configuration DLL.
    //
    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        pInfo->hwndLbEapPackages,
        ComboBox_GetCurSel( pInfo->hwndLbEapPackages ) );
    ASSERT( pNode );

    if(NULL == pNode)
    {
        return;
    }
    
    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    h = NULL;
    if (!(h = LoadLibrary( pEapcfg->pszConfigDll ))
        || !(pInvokeConfigUi =
                (RASEAPINVOKECONFIGUI )GetProcAddress(
                    h, "RasEapInvokeConfigUI" ))
        || !(pFreeConfigUIData =
                (RASEAPFREE) GetProcAddress(
                    h, "RasEapFreeMemory" )))
    {
        MsgDlg( pInfo->hwndDlg, SID_CannotLoadConfigDll, NULL );
        if (h)
        {
            FreeLibrary( h );
        }
        return;
    }

    // Call the configuration DLL to popup it's custom configuration UI.
    //
    pConnectionData = NULL;
    cbConnectionData = 0;

    dwErr = pInvokeConfigUi(
        pEapcfg->dwKey, pInfo->hwndDlg, 
        pInfo->pArgs->fRouter ? RAS_EAP_FLAG_ROUTER : 0,
        pEapcfg->pData,
        pEapcfg->cbData,
        &pConnectionData, &cbConnectionData
        );
    if (dwErr != 0)
    {
        if (dwErr != ERROR_CANCELLED)
            MsgDlg( pInfo->hwndDlg, SID_ConfigDllApiFailed, NULL );
        FreeLibrary( h );
        return;
    }

    // Store the configuration information returned in the package descriptor.
    //

    Free( pEapcfg->pData );
    pEapcfg->pData = NULL;
    pEapcfg->cbData = 0;

    if (pConnectionData)
    {
        if (cbConnectionData > 0)
        {
            // Copy it into the eap node
            pEapcfg->pData = Malloc( cbConnectionData );
            if (pEapcfg->pData)
            {
                CopyMemory( pEapcfg->pData, pConnectionData, cbConnectionData );
                pEapcfg->cbData = cbConnectionData;
            }
        }
    }

    pFreeConfigUIData( pConnectionData );

    // Note any "force user to configure" requirement on the package has been
    // satisfied.
    //
    pEapcfg->fConfigDllCalled = TRUE;

    FreeLibrary( h );
}


VOID
CaPropertiesRemote(
    IN CAINFO* pInfo )

    // Called when the EAP properties button is pressed.  Call the
    // configuration DLL to popup the properties of the package.  'PInfo' is
    // the dialog context.
    //
{
    DWORD               dwErr;
    HRESULT             hr;
    DTLNODE*            pNode;
    EAPCFG*             pEapcfg;
    BOOL                fComInitialized     = FALSE;
    BYTE*               pConnectionData     = NULL;
    DWORD               cbConnectionData    = 0;
    IEAPProviderConfig* pEapProv            = NULL;
    ULONG_PTR           uConnectionParam;
    BOOL                fInitialized        = FALSE;

    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        pInfo->hwndLbEapPackages,
        ComboBox_GetCurSel( pInfo->hwndLbEapPackages ) );
    ASSERT( pNode );

    if(NULL == pNode)
    {
        goto LDone;
    }
    
    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if ( RPC_E_CHANGED_MODE == hr )
    {
        hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    }

    if (   ( S_OK != hr )
        && ( S_FALSE != hr ) )
    {
        goto LDone;
    }

    fComInitialized = TRUE;

    hr = CoCreateInstance(
            &(pEapcfg->guidConfigCLSID),
            NULL,
            CLSCTX_SERVER,
            &IID_IEAPProviderConfig,
            (PVOID*)&pEapProv
            );

    if ( FAILED( hr ) )
    {
        pEapProv = NULL;
        goto LDone;
    }

    // Call the configuration DLL to popup it's custom configuration UI.
    //
    hr = IEAPProviderConfig_Initialize(
            pEapProv,
            pInfo->pArgs->pszRouter,
            pEapcfg->dwKey,
            &uConnectionParam );

    if ( FAILED( hr ) )
    {
        goto LDone;
    }

    fInitialized = TRUE;

    hr = IEAPProviderConfig_RouterInvokeConfigUI(
            pEapProv,
            pEapcfg->dwKey,
            uConnectionParam,
            pInfo->hwndDlg,
            RAS_EAP_FLAG_ROUTER,
            pEapcfg->pData,
            pEapcfg->cbData,
            &pConnectionData,
            &cbConnectionData );

    if ( FAILED( hr ) )
    {
        // if (dwErr != ERROR_CANCELLED)
            // MsgDlg( pInfo->hwndDlg, SID_ConfigDllApiFailed, NULL );
        goto LDone;
    }

    // Store the configuration information returned in the package descriptor.
    //

    Free( pEapcfg->pData );
    pEapcfg->pData = NULL;
    pEapcfg->cbData = 0;

    if (pConnectionData)
    {
        if (cbConnectionData > 0)
        {
            // Copy it into the eap node
            pEapcfg->pData = Malloc( cbConnectionData );
            if (pEapcfg->pData)
            {
                CopyMemory( pEapcfg->pData, pConnectionData, cbConnectionData );
                pEapcfg->cbData = cbConnectionData;
            }
        }
    }

    // Note any "force user to configure" requirement on the package has been
    // satisfied.
    //
    pEapcfg->fConfigDllCalled = TRUE;

LDone:

    if ( NULL != pConnectionData )
    {
        CoTaskMemFree( pConnectionData );
    }

    if ( fInitialized )
    {
        IEAPProviderConfig_Uninitialize(
            pEapProv,
            pEapcfg->dwKey,
            uConnectionParam );
    }

    if ( NULL != pEapProv )
    {
        IEAPProviderConfig_Release(pEapProv);
    }

    if ( fComInitialized )
    {
        CoUninitialize();
    }
}


VOID
CaRbToggle(
    IN CAINFO* pInfo,
    IN BOOL fEapSelected )

    // Called when the radio button setting is toggled.  'FEapSelected' is set
    // if the EAP option was selected, clear if the "Allowed protocols" option
    // was selected.  'PInfo' is the dialog context.
    //
{
    EnableLbWithRestore(
        pInfo->hwndLbEapPackages, fEapSelected, &pInfo->iLbEapPackages );

    EnableCbWithRestore(
        pInfo->hwndCbPap, !fEapSelected, FALSE, &pInfo->fPap );
    EnableCbWithRestore(
        pInfo->hwndCbSpap, !fEapSelected, FALSE, &pInfo->fSpap );
    EnableCbWithRestore(
        pInfo->hwndCbChap, !fEapSelected, FALSE, &pInfo->fChap );
    EnableCbWithRestore(
        pInfo->hwndCbMsChap, !fEapSelected, FALSE, &pInfo->fMsChap );
    EnableCbWithRestore(
        pInfo->hwndCbW95MsChap, !fEapSelected, FALSE, &pInfo->fW95MsChap );
    EnableCbWithRestore(
        pInfo->hwndCbMsChap2, !fEapSelected, FALSE, &pInfo->fMsChap2 );

    if (fEapSelected)
    {
        EnableCbWithRestore(
            pInfo->hwndCbUseWindowsPw, FALSE, FALSE, &pInfo->fUseWindowsPw );
    }
    else
    {
        CaCbToggle( pInfo, NULL );
    }
}


BOOL
CaSave(
    IN CAINFO* pInfo )

    // Saves control contents to caller's PBENTRY argument.  'PInfo' is the
    // dialog context.
    //
    // Returns TRUE if successful or false if invalid combination of
    // selections was detected and reported.
    //
{
    DWORD dwDe;
    PBENTRY* pEntry;
    DTLNODE* pNodeEap;
    DWORD    dwEapKey;

    pEntry = pInfo->pArgs->pEntry;

    dwDe =
        (DWORD )ComboBox_GetItemData(
            pInfo->hwndLbEncryption,
            ComboBox_GetCurSel( pInfo->hwndLbEncryption ) );

    if (Button_GetCheck( pInfo->hwndRbEap ))
    {
        DTLNODE* pNode;
        EAPCFG* pEapcfg;

        pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
            pInfo->hwndLbEapPackages,
            ComboBox_GetCurSel( pInfo->hwndLbEapPackages ) );
        ASSERT( pNode );

        if(NULL == pNode)
        {
            return FALSE;
        }
        pEapcfg = (EAPCFG* )DtlGetData( pNode );
        ASSERT( pEapcfg );

        // Tell user about required EAP configuration, if applicable.
        //
        if (pNode != pInfo->pOriginalEapcfgNode
            && pEapcfg->fForceConfig
            && !pEapcfg->fConfigDllCalled)
        {
            MsgDlg(
                pInfo->hwndDlg, SID_CustomAuthConfigRequired, NULL );
            ASSERT( IsWindowEnabled( pInfo->hwndPbProperties ) );
            SetFocus( pInfo->hwndPbProperties );
            return FALSE;
        }

        // Tell user EAP doesn't support encryption, if it doesn't and he
        // chose encryption.  This check doesn't apply to L2TP which does not
        // use MPPE.
        //
        if (!(pEntry->dwType == RASET_Vpn
              && pEntry->dwVpnStrategy == VS_L2tpOnly)
            && (dwDe != DE_None && !pEapcfg->fProvidesMppeKeys))
        {
            MsgDlg( pInfo->hwndDlg, SID_NeedEapKeys, NULL );
            return FALSE;
        }

        // Save settings.
        //
        pEntry->dwDataEncryption = dwDe;
        pEntry->dwAuthRestrictions = AR_F_AuthCustom | AR_F_AuthEAP;
        pEntry->fAutoLogon = FALSE;

        dwEapKey = pEapcfg->dwKey;
    }
    else
    {
        DWORD dwAr;

        if (dwDe != DE_None
            && dwDe != DE_IfPossible
            && !(pEntry->dwType == RASET_Vpn
                 && pEntry->dwVpnStrategy == VS_L2tpOnly)
            && !(Button_GetCheck( pInfo->hwndCbMsChap )
                 || Button_GetCheck( pInfo->hwndCbW95MsChap )
                 || Button_GetCheck( pInfo->hwndCbMsChap2 )))
        {
            MsgDlg( pInfo->hwndDlg, SID_MsChapRequired, NULL );
            return FALSE;
        }

        dwAr = AR_F_AuthCustom;
        if (Button_GetCheck( pInfo->hwndCbPap ))
        {
            dwAr |= AR_F_AuthPAP;
        }

        if (Button_GetCheck( pInfo->hwndCbSpap ))
        {
            dwAr |= AR_F_AuthSPAP;
        }

        if (Button_GetCheck( pInfo->hwndCbChap ))
        {
            dwAr |= AR_F_AuthMD5CHAP;
        }

        if (Button_GetCheck( pInfo->hwndCbMsChap ))
        {
            dwAr |= AR_F_AuthMSCHAP;
        }

        if (IsWindowEnabled( pInfo->hwndCbW95MsChap )
            && Button_GetCheck( pInfo->hwndCbW95MsChap ))
        {
            dwAr |= AR_F_AuthW95MSCHAP;
        }

        if (Button_GetCheck( pInfo->hwndCbMsChap2 ))
        {
            dwAr |= AR_F_AuthMSCHAP2;
        }

        if (dwDe != DE_None
            && !(pEntry->dwType == RASET_Vpn
                 && pEntry->dwVpnStrategy == VS_L2tpOnly)
            && (dwAr & (AR_F_AuthPAP | AR_F_AuthSPAP | AR_F_AuthMD5CHAP)))
        {
            MSGARGS msgargs;

            ZeroMemory( &msgargs, sizeof(msgargs) );
            msgargs.dwFlags = MB_YESNO | MB_DEFBUTTON2 | MB_ICONINFORMATION;

            if (MsgDlg(
                    pInfo->hwndDlg, SID_OptionalAuthQuery, &msgargs) == IDNO)
            {
                Button_SetCheck( pInfo->hwndCbPap, FALSE );
                Button_SetCheck( pInfo->hwndCbSpap, FALSE );
                Button_SetCheck( pInfo->hwndCbChap, FALSE );
                return FALSE;
            }
        }

        if (dwAr == AR_F_AuthCustom)
        {
            MsgDlg( pInfo->hwndDlg, SID_NoAuthChecked, NULL );
            return FALSE;
        }

        // Save settings.
        //
        pEntry->dwAuthRestrictions = dwAr;
        pEntry->dwDataEncryption = dwDe;

        if (IsWindowEnabled( pInfo->hwndCbUseWindowsPw ))
        {
            pEntry->fAutoLogon = Button_GetCheck( pInfo->hwndCbUseWindowsPw );
        }
        else
        {
            pEntry->fAutoLogon = FALSE;
        }
        
        dwEapKey = pEntry->dwCustomAuthKey;
    }

        
    for (pNodeEap = DtlGetFirstNode(pInfo->pListEapcfgs);
         pNodeEap;
         pNodeEap = DtlGetNextNode(pNodeEap))
    {
        EAPCFG* pcfg = (EAPCFG* )DtlGetData(pNodeEap);
        ASSERT( pcfg );

        pEntry->dwCustomAuthKey = pcfg->dwKey;

        (VOID) DwSetCustomAuthData(
                        pEntry,
                        pcfg->cbData,
                        pcfg->pData);

        Free0(pcfg->pData);
        pcfg->pData = NULL;                           
    }

    pEntry->dwCustomAuthKey = dwEapKey;

    return TRUE;
}


VOID
CaTerm(
    IN HWND hwndDlg )

    // Dialog termination.  Releases the context block.  'HwndDlg' is the
    // handle of a dialog.
    //
{
    CAINFO* pInfo;

    TRACE( "CaTerm" );

    pInfo = (CAINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );
    if (pInfo)
    {
        if (pInfo->pListEapcfgs)
        {
            DtlDestroyList( pInfo->pListEapcfgs, DestroyEapcfgNode );
        }

        Free( pInfo );
        TRACE( "Context freed" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\uiinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U I I N F O . C P P
//
//  Contents:   Implements a call-back COM object used to raise properties
//              on INetCfg components.  This object implements the
//              INetRasConnectionIpUiInfo interface.
//
//  Notes:
//
//  Author:     shaunco   1 Jan 1998
//
//----------------------------------------------------------------------------

#include "rasdlgp.h"
#include "netconp.h"
#include "uiinfo.h"


class CRasConnectionUiIpInfo :
    public INetRasConnectionIpUiInfo
{
private:
    ULONG   m_cRef;
    PEINFO* m_pInfo;

friend
    void
    RevokePeinfoFromUiInfoCallbackObject (
        IUnknown*   punk);

public:
    CRasConnectionUiIpInfo (PEINFO* pInfo);

    // IUnknown
    //
    STDMETHOD (QueryInterface) (REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)  (void);
    STDMETHOD_(ULONG, Release) (void);

    // INetRasConnectionIpUiInfo
    //
    STDMETHOD (GetUiInfo) (RASCON_IPUI*  pIpui);
};


// Constructor.  Set our reference count to 1 and initialize our members.
//
CRasConnectionUiIpInfo::CRasConnectionUiIpInfo (
    PEINFO* pInfo)
{
    m_cRef = 1;
    m_pInfo = pInfo;
}

// IUnknown
//
STDMETHODIMP
CRasConnectionUiIpInfo::QueryInterface (
    REFIID riid,
    void** ppv)
{
    static const IID IID_INetRasConnectionIpUiInfo =
        {0xFAEDCF58,0x31FE,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    if (!ppv)
    {
        return E_POINTER;
    }
    if ((IID_IUnknown == riid) ||
        (IID_INetRasConnectionIpUiInfo == riid))
    {
        *ppv = static_cast<void*>(static_cast<IUnknown*>(this));
        AddRef ();
        return S_OK;
    }
    *ppv = NULL;
    return E_NOINTERFACE;
}

// Standard AddRef and Release implementations.
//
STDMETHODIMP_(ULONG)
CRasConnectionUiIpInfo::AddRef (void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CRasConnectionUiIpInfo::Release (void)
{
    ULONG cRef = --m_cRef;
    if (0 == cRef)
    {
        delete this;
    }
    return cRef;
}

// INetRasConnectionIpUiInfo
//
STDMETHODIMP
CRasConnectionUiIpInfo::GetUiInfo (
    RASCON_IPUI*    pIpui)
{
    // Validate parameters.
    //
    if (!pIpui)
    {
        return E_POINTER;
    }

    ZeroMemory (pIpui, sizeof(*pIpui));

    // We need to have a PEINFO with which to answer the call.
    // If it was revoked, it means we're being called after everything
    // has gone away.  (The caller probably has not released us when he
    // he should have.)
    //
    if (!m_pInfo)
    {
        return E_UNEXPECTED;
    }

    PBENTRY* pEntry = m_pInfo->pArgs->pEntry;

    // Phonebook upgrade code needs to assure that pGuid is always present.
    //
    pIpui->guidConnection = *pEntry->pGuid;

    // Set whether its SLIP or PPP.
    //
    if (BP_Slip == pEntry->dwBaseProtocol)
    {
        pIpui->dwFlags = RCUIF_SLIP;
    }
    else
    {
        pIpui->dwFlags = RCUIF_PPP;
    }

    // Set whether this is demand dial or not
    //
    if (m_pInfo->pArgs->fRouter)
    {
        pIpui->dwFlags |= RCUIF_DEMAND_DIAL;
    }

    // Set whether we're in non-admin mode (406630)
    //
    if (m_pInfo->fNonAdmin)
    {
        pIpui->dwFlags |= RCUIF_NOT_ADMIN;
    }

// !!! This is temporary and can be removed when this flag has been added to
//     the checked in necomp IDL file.
//
#ifndef RCUIF_VPN
#define RCUIF_VPN 0x40
#endif

    // Note if it's a VPN connection.
    //
    if (pEntry->dwType == RASET_Vpn)
    {
        pIpui->dwFlags |= RCUIF_VPN;
    }

    // Set whether to use a specific IP address.
    //
    // Whistler bug 304064 NT4SLIP connection gets wrong IP settings on upgrade
    //
    if (pEntry->pszIpAddress &&
        ((BP_Slip == pEntry->dwBaseProtocol) ||
         (ASRC_RequireSpecific == pEntry->dwIpAddressSource)))
    {
        pIpui->dwFlags |= RCUIF_USE_IP_ADDR;

        if (pEntry->pszIpAddress &&
            lstrcmp(pEntry->pszIpAddress, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwIpAddr,
                pEntry->pszIpAddress,
                sizeof(pIpui->pszwIpAddr) / sizeof(WCHAR));
        }
    }

    // Set whether to use specific name server addresses.
    //
    // Whistler bug 304064 NT4SLIP connection gets wrong IP settings on upgrade
    //
    if (((BP_Slip == pEntry->dwBaseProtocol) ||
         (ASRC_RequireSpecific == pEntry->dwIpNameSource)) &&
        (pEntry->pszIpDnsAddress  || pEntry->pszIpDns2Address ||
         pEntry->pszIpWinsAddress || pEntry->pszIpWins2Address))
    {
        pIpui->dwFlags |= RCUIF_USE_NAME_SERVERS;

        // Since the phonebook stores zeros even for unused IP address
        // strings, we need to ignore them explicitly.
        //
        if (pEntry->pszIpDnsAddress &&
            lstrcmp(pEntry->pszIpDnsAddress, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwDnsAddr,
                pEntry->pszIpDnsAddress,
                sizeof(pIpui->pszwDnsAddr) / sizeof(WCHAR));
        }

        if (pEntry->pszIpDns2Address &&
            lstrcmp(pEntry->pszIpDns2Address, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwDns2Addr,
                pEntry->pszIpDns2Address,
                sizeof(pIpui->pszwDns2Addr) / sizeof(WCHAR));
        }

        if (pEntry->pszIpWinsAddress &&
            lstrcmp(pEntry->pszIpWinsAddress, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwWinsAddr,
                pEntry->pszIpWinsAddress,
                sizeof(pIpui->pszwWinsAddr) / sizeof(WCHAR));
        }

        if (pEntry->pszIpWins2Address &&
            lstrcmp(pEntry->pszIpWins2Address, TEXT("0.0.0.0")))
        {
            lstrcpynW (
                pIpui->pszwWins2Addr,
                pEntry->pszIpWins2Address,
                sizeof(pIpui->pszwWins2Addr) / sizeof(WCHAR));
        }
    }

    if (!m_pInfo->pArgs->fRouter && pEntry->fIpPrioritizeRemote)
    {
        pIpui->dwFlags |= RCUIF_USE_REMOTE_GATEWAY;
    }

    if (pEntry->fIpHeaderCompression)
    {
        pIpui->dwFlags |= RCUIF_USE_HEADER_COMPRESSION;
    }

    if (BP_Slip == pEntry->dwBaseProtocol)
    {
        pIpui->dwFrameSize = pEntry->dwFrameSize;
    }

    // pmay: 389632  
    // 
    // Initialize the dns controls
    //
    if (pEntry->dwIpDnsFlags & DNS_RegPrimary)
    {
        if ((pEntry->dwIpDnsFlags & DNS_RegPerConnection) ||
            (pEntry->dwIpDnsFlags & DNS_RegDhcpInform))
        {
            pIpui->dwFlags |= RCUIF_USE_PRIVATE_DNS_SUFFIX;
        }
    }
    else
    {
        pIpui->dwFlags |= RCUIF_USE_DISABLE_REGISTER_DNS;
    }

    if (pEntry->pszIpDnsSuffix)
    {
        lstrcpyn(
            pIpui->pszwDnsSuffix,
            pEntry->pszIpDnsSuffix,
            255);
    }

    if (pEntry->dwIpNbtFlags & PBK_ENTRY_IP_NBT_Enable)
    {
        pIpui->dwFlags |= RCUIF_ENABLE_NBT;
    }

    return S_OK;
}


EXTERN_C
HRESULT
HrCreateUiInfoCallbackObject (
    PEINFO*     pInfo,
    IUnknown**  ppunk)
{
    // Validate parameters.
    //
    if (!pInfo || !ppunk)
    {
        return E_POINTER;
    }

    // Create the object and return its IUnknown interface.
    // This assumes the object is created with a ref-count of 1.
    // (Check the constructor above to make sure.)
    //
    HRESULT hr = S_OK;
    CRasConnectionUiIpInfo* pObj = new CRasConnectionUiIpInfo (pInfo);
    if (pObj)
    {
        *ppunk = static_cast<IUnknown*>(pObj);
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

// Set the m_pInfo member to NULL.  Since we don't have direct control over
// the lifetime of this object (clients can hold references as long as they
// want) revoking m_pInfo is a saftey net to keep us from trying to access
// memory that may have gone away.
//
EXTERN_C
void
RevokePeinfoFromUiInfoCallbackObject (
    IUnknown*   punk)
{
    CRasConnectionUiIpInfo* pObj = static_cast<CRasConnectionUiIpInfo*>(punk);
    pObj->m_pInfo = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\status.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    status.c
//
// History:
//  Abolade Gbadegesin  Nov-02-1995     Created.
//
// Code for the RAS Monitor property sheet.
//============================================================================

#include "rasdlgp.h"

#define RASMONITORDLG struct tagRASMONITORDLG
RASMONITORDLG
{
    IN  DWORD dwSize;
    IN  HWND  hwndOwner;
    IN  DWORD dwFlags;
    IN  DWORD dwStartPage;
    IN  LONG  xDlg;
    IN  LONG  yDlg;
    OUT DWORD dwError;
    IN  ULONG_PTR reserved;
    IN  ULONG_PTR reserved2;
};

//----------------------------------------------------------------------------
// Function:    RasMonitorDlgW
//
//
// Entry point for RAS status dialog.
//----------------------------------------------------------------------------

BOOL
APIENTRY
RasMonitorDlgW(
    IN LPWSTR lpszDeviceName,
    IN OUT RASMONITORDLG *lpApiArgs
    ) {
    //
    // 352118 Remove broken/legacy public RAS API - RasMonitorDlg
    //
    DbgPrint( "Unsupported Interface - RasMonitorDlg" );

    do
    {
        if (lpApiArgs == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            break;
        }

        if (lpApiArgs->dwSize != sizeof(RASMONITORDLG)) {
            lpApiArgs->dwError = ERROR_INVALID_SIZE;
            break;
        }

        lpApiArgs->dwError = ERROR_CALL_NOT_IMPLEMENTED;

    } while (FALSE);

    return FALSE;
}

//----------------------------------------------------------------------------
// Function:    RasMonitorDlgA
//
//
// ANSI entry-point for RAS Monitor Dialog.
// This version invokes the Unicode entry-point
//----------------------------------------------------------------------------

BOOL
APIENTRY
RasMonitorDlgA(
    IN LPSTR lpszDeviceName,
    IN OUT RASMONITORDLG *lpApiArgs
    ) {
    //
    // 352118 Remove broken/legacy public RAS API - RasMonitorDlg
    //

    return RasMonitorDlgW(NULL, lpApiArgs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\uiinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U I I N F O . H
//
//  Contents:   Declares a call-back COM object used to raise properties
//              on INetCfg components.  This object implements the
//              INetRasConnectionUiInfo interface.
//
//  Notes:
//
//  Author:     shaunco   1 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#include "entryps.h"

EXTERN_C
HRESULT
HrCreateUiInfoCallbackObject (
    PEINFO*     pInfo,
    IUnknown**  ppunk);

EXTERN_C
void
RevokePeinfoFromUiInfoCallbackObject (
    IUnknown*   punk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasphone\netcfg.cpp ===
// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <ncnetcfg.h>
#include <initguid.h>
#include <devguid.h>
#include <netcfg_i.c>
#include "rasphone.rch"


EXTERN_C
VOID
Install(
    IN HINSTANCE hinst,
    IN HWND hwndOwner,
    INetCfg* pNetCfg )

    /* Runs the RAS install program.  'HwndOwner' is the owning window or NULL
    ** if none.  'PNetCfg' is the initialized net configuration object.
    */
{
    HRESULT hr;

    /* Install RAS.
    */
    hr = HrInstallComponentOboUser(
        pNetCfg, GUID_DEVCLASS_NETSERVICE,
        NETCFG_SERVICE_CID_MS_RASCLI,
        NULL );

    if (SUCCEEDED(hr))
    {
        hr = HrValidateAndApplyOrCancelINetCfg (pNetCfg, hwndOwner);

        if (NETCFG_S_REBOOT == hr)
        {
            LPCTSTR pszCaption = SzLoadString(hinst, SID_PopupTitle);
            LPCTSTR pszText    = SzLoadString(hinst, SID_RestartText1);
            MessageBox (hwndOwner, pszText, pszCaption, MB_OK);
        }
    }
}

EXTERN_C
HRESULT HrCreateAndInitINetCfg (BOOL fInitCom, INetCfg** ppnc)
{
    return HrCreateAndInitializeINetCfg (fInitCom, ppnc);
}

EXTERN_C
HRESULT HrUninitAndReleaseINetCfg (BOOL fUninitCom, INetCfg* pnc)
{
    return HrUninitializeAndReleaseINetCfg (fUninitCom, pnc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\terminal.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// terminal.c
// Remote Access Common Dialog APIs
// Terminal dialogs
//
// 08/28/95 Steve Cobb


#include "rasdlgp.h"
#include "rasscrpt.h"


#define WM_EOLFROMDEVICE    (WM_USER+999)
#define SECS_ReceiveTimeout 1
#define SIZE_ReceiveBuf     1024
#define SIZE_SendBuf        1


//----------------------------------------------------------------------------
// Help maps
//----------------------------------------------------------------------------

static DWORD g_adwItHelp[] =
{
    CID_IT_EB_Screen,    HID_IT_EB_Screen,
    CID_IT_ST_IpAddress, HID_IT_CC_IpAddress,
    CID_IT_CC_IpAddress, HID_IT_CC_IpAddress,
    IDOK,                HID_IT_PB_Done,
    0, 0
};


//----------------------------------------------------------------------------
// Local datatypes (alphabetically)
//----------------------------------------------------------------------------

// Interactive terminal dialog argument block.
//
typedef struct
_ITARGS
{
    DWORD sidTitle;
    TCHAR* pszIpAddress;
    HRASCONN hrasconn;
    PBENTRY* pEntry;
    RASDIALPARAMS* pRdp;
}
ITARGS;


// Interactive terminal dialog context block.
//
typedef struct
_ITINFO
{
    // Caller's arguments to the dialog.
    //
    ITARGS* pArgs;

    // Handle of this dialog and some of it's controls.
    //
    HWND hwndDlg;
    HWND hwndEbScreen;
    HWND hwndCcIpAddress;
    HWND hwndPbBogus;

    // Set when waiting for the thread to terminate.
    //
    BOOL fAbortReceiveLoop;

    // Original dialog and screen edit box window proc.
    //
    WNDPROC pOldWndProc;
    WNDPROC pOldEbScreenWndProc;

    // buffers for RasScriptSend/RasScriptReceive.
    //
    BYTE pbyteReceiveBuf[SIZE_ReceiveBuf];
    BYTE pbyteSendBuf[SIZE_SendBuf];

    // handle to active script on this connection
    //
    HANDLE hscript;

    // Screen edit box font and brush.
    //
    HFONT hfontEbScreen;
    HBRUSH hbrEbScreen;
}
ITINFO;


//----------------------------------------------------------------------------
// Local prototypes (alphabetically)
//----------------------------------------------------------------------------

INT_PTR CALLBACK
ItDlgProc(
    IN HWND   hwnd,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam );

BOOL
ItCommand(
    IN ITINFO* pInfo,
    IN WORD    wNotification,
    IN WORD    wId,
    IN HWND    hwndCtrl );

LRESULT APIENTRY
ItEbScreenWndProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );

BOOL
ItInit(
    IN HWND    hwndDlg,
    IN ITARGS* pArgs );

BOOL
ItRasApiComplete(
    IN ITINFO* pInfo );

DWORD
ItReceiveMonitorThread(
    LPVOID pThreadArg );

VOID
ItTerm(
    IN HWND hwndDlg );

VOID
ItViewScriptLog(
    IN HWND   hwndOwner );

LRESULT APIENTRY
ItWndProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam );


//----------------------------------------------------------------------------
// Terminal dialog
// Listed alphabetically following stub API and dialog proc
//----------------------------------------------------------------------------

BOOL
TerminalDlg(
    IN PBENTRY* pEntry,
    IN RASDIALPARAMS* pRdp,
    IN HWND hwndOwner,
    IN HRASCONN hrasconn,
    IN DWORD sidTitle,
    IN OUT TCHAR* pszIpAddress )

    // Pops-up the Terminal dialog.  'HwndOwner' is the window owning the
    // dialog.  'Hrasconn' is the RAS connection handle to talk on.
    // 'SidTitle' is ID of the string displayed as the window caption.
    // 'PszIpAddress' is caller's buffer of at least 16 characters containing
    // the initial IP address on entry and the edited IP address on exit.  If
    // 'pszIpAddress' is empty, no IP address field is displayed.
    //
    // Returns true if user pressed OK and succeeded, false if he pressed
    // Cancel or encountered an error.
    //
{
    INT_PTR nStatus;
    INT nDlg;
    ITARGS args;

    TRACE( "TerminalDlg" );

    if (pszIpAddress && pszIpAddress[ 0 ])
    {

        InitCommonControls();
        IpAddrInit( g_hinstDll, SID_PopupTitle, SID_BadIpAddrRange );

        nDlg = DID_IT_SlipTerminal;
    }
    else
    {
        nDlg = DID_IT_Terminal;
    }

    args.pszIpAddress = pszIpAddress;
    args.sidTitle = sidTitle;
    args.hrasconn = hrasconn;
    args.pEntry = pEntry;
    args.pRdp = pRdp;

    nStatus =
        DialogBoxParam(
            g_hinstDll,
            MAKEINTRESOURCE( nDlg ),
            hwndOwner,
            ItDlgProc,
            (LPARAM )&args );

    if (nStatus == -1)
    {
        TRACE1("TerminalDlg: GLE=%d", GetLastError());
        ErrorDlg( hwndOwner, SID_OP_LoadDlg, ERROR_UNKNOWN, NULL );
        nStatus = FALSE;
    }

    return (nStatus) ? TRUE : FALSE;
}


INT_PTR CALLBACK
ItDlgProc(
    IN HWND hwnd,
    IN UINT unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam )

    // DialogProc callback for the Interactive Terminal dialog.  Parameters
    // and return value are as described for standard windows 'DialogProc's.
    //
{
#if 0
    TRACE4( "ItDlgProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_INITDIALOG:
        {
            return ItInit( hwnd, (ITARGS* )lparam );
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            ContextHelp( g_adwItHelp, hwnd, unMsg, wparam, lparam );
            break;
        }

        case WM_COMMAND:
        {
            ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            return ItCommand(
                pInfo, HIWORD( wparam ), LOWORD( wparam ), (HWND )lparam );
        }

        case WM_RASAPICOMPLETE:
        {
            ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
            ASSERT(pInfo);

            // The notification code from the scripting-thread is in 'lparam'
            //
            switch (lparam)
            {
                case SCRIPTCODE_Done:
                {
                    EndDialog(hwnd, TRUE);
                    return TRUE;
                }

                case SCRIPTCODE_Halted:
                {
                    MSGARGS msg;

                    // The script has halted programmatically, for instance
                    // because of an explicit "halt" command.  Show a popup
                    // indicating things have stopped, but don't dismiss the
                    // dialog.
                    //
                    ZeroMemory(&msg, sizeof(msg));
                    msg.dwFlags = MB_OK | MB_ICONINFORMATION;
                    MsgDlg( hwnd, SID_OP_ScriptHalted, &msg );
                    return TRUE;
                }

                case SCRIPTCODE_HaltedOnError:
                {
                    MSGARGS msg;
                    INT nResponse;

                    // There was an execution-error in the script; show a
                    // popup asking if the user wants to view the errors, and
                    // if the user clicks 'Yes' invoke Notepad on the file
                    // %windir%\system32\ras\script.log.  Since this is an
                    // error condition, dismiss the dialog.
                    //
                    ZeroMemory(&msg, sizeof(msg));
                    msg.dwFlags = MB_YESNO | MB_ICONQUESTION;
                    nResponse = MsgDlg(
                        hwnd, SID_OP_ScriptHaltedOnError, &msg );

                    if (nResponse == IDYES)
                    {
                        ItViewScriptLog( hwnd );
                    }

                    EndDialog(hwnd, FALSE);
                    return TRUE;
                }

                case SCRIPTCODE_KeyboardEnable:
                {
                    // Allow keyboard input in the edit-box.
                    //
                    EnableWindow(pInfo->hwndEbScreen, TRUE);
                    return TRUE;
                }

                case SCRIPTCODE_KeyboardDisable:
                {
                    // Disallow keyboard input in the edit-box; if the
                    // edit-box currently has the focus, we first set the
                    // focus to the 'Done' button.
                    //
                    if (GetFocus() == pInfo->hwndEbScreen)
                    {
                        SetFocus( GetDlgItem (hwnd, IDOK ) );
                    }

                    EnableWindow( pInfo->hwndEbScreen, FALSE );
                    return TRUE;
                }

                case SCRIPTCODE_IpAddressSet:
                {
                    DWORD dwErr;
                    CHAR szAddress[ RAS_MaxIpAddress + 1 ];

                    // The script is notifying us that the IP address has been
                    // changed programmatically.
                    //
                    // Get the new IP address.
                    //
                    dwErr = RasScriptGetIpAddress( pInfo->hscript, szAddress );

                    if (dwErr == NO_ERROR)
                    {
                        TCHAR* psz;

                        // Save the new IP address.
                        //
                        psz = StrDupTFromA(szAddress);

                        if (NULL != psz)
                        {
                            // Whistler bug 224074 use only lstrcpyn's to
                            // prevent maliciousness
                            //
                            lstrcpyn(
                                pInfo->pArgs->pszIpAddress,
                                psz,
                                TERM_IpAddress);
                            Free0(psz);
                        }

                        // Display it in the IP-address edit-box
                        //
                        if (pInfo->hwndCcIpAddress)
                        {
                            SetWindowText( pInfo->hwndCcIpAddress,
                                pInfo->pArgs->pszIpAddress );
                        }
                    }

                    return TRUE;
                }

                case SCRIPTCODE_InputNotify:
                {
                    // Handle input-notification.
                    //
                    return ItRasApiComplete( pInfo );
                }

                return TRUE;
            }
        }

        case WM_DESTROY:
        {
            ItTerm( hwnd );
            break;
        }
    }

    return FALSE;
}


BOOL
ItCommand(
    IN ITINFO* pInfo,
    IN WORD wNotification,
    IN WORD wId,
    IN HWND hwndCtrl )

    // Called on WM_COMMAND.  'PInfo' is the dialog context.  'WNotification'
    // is the notification code of the command.  'wId' is the control/menu
    // identifier of the command.  'HwndCtrl' is the control window handle of
    // the command.
    //
    // Returns true if processed message, false otherwise.
    //
{
    TRACE3( "ItCommand(n=%d,i=%d,c=$%x)",
        (DWORD )wNotification, (DWORD )wId, (ULONG_PTR )hwndCtrl );

    switch (wId)
    {
        case CID_IT_EB_Screen:
        {

            // Turn off the default button whenever the terminal window
            // has the focus.  Pressing [Return] in the terminal acts like
            // a normal terminal.
            //
            Button_MakeDefault( pInfo->hwndDlg, pInfo->hwndPbBogus );

            // Don't select the entire string on entry.
            //
            Edit_SetSel( pInfo->hwndEbScreen, (UINT )-1, 0 );

            break;
        }

        case IDOK:
        {
            TRACE("OK pressed");

            if (pInfo->pArgs->pszIpAddress)
            {
                GetWindowText(
                    pInfo->hwndCcIpAddress, pInfo->pArgs->pszIpAddress, 16 );
            }

            EndDialog( pInfo->hwndDlg, TRUE );
            return TRUE;
        }

        case IDCANCEL:
            TRACE("Cancel pressed");
            EndDialog( pInfo->hwndDlg, FALSE );
            return TRUE;
    }

    return FALSE;
}


LRESULT APIENTRY
ItEbScreenWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed terminal edit box window procedure.
    //
    // Return value depends on message type.
    //
{
    ITINFO* pInfo;
    BOOL fSend;
    BOOL fSendTab;

    fSend = fSendTab = FALSE;

    if (unMsg == WM_EOLFROMDEVICE)
    {
        // An end-of-line in the device input was received.  Send a linefeed
        // character to the window.
        //
        wParam = '\n';
        unMsg = WM_CHAR;
    }
    else
    {
        BOOL fCtrlKeyDown = (GetKeyState( VK_CONTROL ) < 0);
        BOOL fShiftKeyDown = (GetKeyState( VK_SHIFT ) < 0);

        if (unMsg == WM_KEYDOWN)
        {
            // The key was pressed by the user.
            //
            if (wParam == VK_RETURN && !fCtrlKeyDown && !fShiftKeyDown)
            {
                // Enter key pressed without Shift or Ctrl is discarded.  This
                // prevents Enter from being interpreted as "press default
                // button" when pressed in the edit box.
                //
                return 0;
            }

            if (fCtrlKeyDown && wParam == VK_TAB)
            {
                fSend = TRUE;
                fSendTab = TRUE;
            }
        }
        else if (unMsg == WM_CHAR)
        {
            // The character was typed by the user.
            //
            if (wParam == VK_TAB)
            {
                // Ignore tabs...Windows sends this message when Tab (leave
                // field) is pressed but not when Ctrl+Tab (insert a TAB
                // character) is pressed...weird.
                //
                return 0;
            }

            fSend = TRUE;
        }
    }

    pInfo = (ITINFO* )GetWindowLongPtr( GetParent( hwnd ), DWLP_USER );
    ASSERT(pInfo);

    if (fSend)
    {
        DWORD dwErr;

        pInfo->pbyteSendBuf[ 0 ] = (BYTE )wParam;
        dwErr = RasScriptSend(
            pInfo->hscript, pInfo->pbyteSendBuf, SIZE_SendBuf);
        if (dwErr != 0)
        {
            ErrorDlg( pInfo->hwndDlg, SID_OP_RasPortSend, dwErr, NULL );
        }

        if (!fSendTab)
        {
            return 0;
        }
    }

    // Call the previous window procedure for everything else.
    //
    return
        CallWindowProc(
            pInfo->pOldEbScreenWndProc, hwnd, unMsg, wParam, lParam );
}


BOOL
ItInit(
    IN HWND hwndDlg,
    IN ITARGS* pArgs )

    // Called on WM_INITDIALOG.  'hwndDlg' is the handle of the phonebook
    // dialog window.  'pEntry' is caller's entry as passed to the stub API.
    //
    // Return false if focus was set, true otherwise, i.e. as defined for
    // WM_INITDIALOG.
    //
{
    DWORD dwErr;
    ITINFO* pInfo;
    WORD wReceiveSize;
    WORD wSendSize;
    WORD wSize;
    DWORD dwThreadId;

    TRACE( "ItInit" );

    // Allocate the dialog context block.  Initialize minimally for proper
    // cleanup, then attach to the dialog window.
    //
    {
        pInfo = Malloc( sizeof(*pInfo) );
        if (!pInfo)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, ERROR_NOT_ENOUGH_MEMORY, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        ZeroMemory( pInfo, sizeof(*pInfo) );
        pInfo->pArgs = pArgs;
        pInfo->hwndDlg = hwndDlg;

        SetWindowLongPtr( hwndDlg, DWLP_USER, (ULONG_PTR )pInfo );
        TRACE( "Context set" );
    }

    pInfo->hwndEbScreen = GetDlgItem( hwndDlg, CID_IT_EB_Screen );
    ASSERT( pInfo->hwndEbScreen );
    pInfo->hwndPbBogus = GetDlgItem( hwndDlg, CID_IT_PB_BogusButton );
    ASSERT( pInfo->hwndPbBogus );
    if (pArgs->pszIpAddress && pArgs->pszIpAddress[0])
    {
        pInfo->hwndCcIpAddress = GetDlgItem( hwndDlg, CID_IT_CC_IpAddress );
        ASSERT( pInfo->hwndCcIpAddress );

        if (*pArgs->pszIpAddress)
        {
            SetWindowText( pInfo->hwndCcIpAddress, pArgs->pszIpAddress );
        }
        else
        {
            SetWindowText( pInfo->hwndCcIpAddress, TEXT("0.0.0.0") );
        }
    }

    // Set the dialog title.
    //
    {
        TCHAR* psz = PszFromId( g_hinstDll, pArgs->sidTitle );
        if (psz)
        {
            SetWindowText( hwndDlg, psz );
            Free( psz );
        }
    }

    // Subclass the dialog and screen edit box.
    //
    pInfo->pOldWndProc =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndDlg, GWLP_WNDPROC, (ULONG_PTR )ItWndProc );
    pInfo->pOldEbScreenWndProc =
        (WNDPROC )SetWindowLongPtr(
            pInfo->hwndEbScreen, GWLP_WNDPROC, (ULONG_PTR )ItEbScreenWndProc );

    // Prepare for special TTY-ish painting.
    //
    pInfo->hfontEbScreen =
        SetFont( pInfo->hwndEbScreen, TEXT("Courier New"),
            FIXED_PITCH | FF_MODERN, 9, FALSE, FALSE, FALSE, FALSE );

    pInfo->hbrEbScreen = (HBRUSH )GetStockObject( BLACK_BRUSH );

    // Initialize script-processing/data-receipt
    //
    {
        CHAR* pszUserName;
        CHAR* pszPassword;

        pszUserName = StrDupAFromT( pInfo->pArgs->pRdp->szUserName );

        // Whistler bug 254385 encode password when not being used
        // Assumed password was encoded by DpInteractive() -or- DwTerminalDlg()
        //
        DecodePassword( pInfo->pArgs->pRdp->szPassword );
        pszPassword = StrDupAFromT( pInfo->pArgs->pRdp->szPassword );
        EncodePassword( pInfo->pArgs->pRdp->szPassword );

        // Initialize the script.  The script DLL is 'delayload' hence the
        // exception handling.
        //
        __try
        {
            dwErr = RasScriptInit(
                pInfo->pArgs->hrasconn, pInfo->pArgs->pEntry,
                pszUserName, pszPassword, RASSCRIPT_NotifyOnInput |
                RASSCRIPT_HwndNotify, (HANDLE)hwndDlg, &pInfo->hscript );
            TRACE1( "RasScriptInit(e=%d)", dwErr );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            ErrorDlg(
                hwndDlg, SID_OP_LoadDlg, STATUS_PROCEDURE_NOT_FOUND, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }

        Free0( pszUserName );

        // Whistler bug 254385 encode password when not being used
        // Whistler bug 275526 NetVBL BVT Break: Routing BVT broken
        //
        if (pszPassword)
        {
            ZeroMemory( pszPassword, strlen(pszPassword) + 1 );
            Free( pszPassword );
        }

        // See whether anything went wrong in the script-initialization
        //
        if (dwErr == ERROR_SCRIPT_SYNTAX)
        {
            MSGARGS msg;
            INT nResponse;

            // There was a syntax error in the script; show a popup asking if
            // the user wants to view the errors, and if so bring up Notepad
            // on %windir%\system32\ras\script.log.
            //
            // Center the dialog on our parent rather than on the dialog,
            // since the dialog is not yet visible.
            //
            ZeroMemory(&msg, sizeof(msg));
            msg.dwFlags = MB_YESNO | MB_ICONQUESTION;
            nResponse = MsgDlg( GetParent( hwndDlg ),
                SID_ConfirmViewScriptLog, &msg );

            if (nResponse == IDYES)
            {
                ItViewScriptLog( hwndDlg );
            }

            // Terminate the dialog.  This hangs up the connection.
            //
            EndDialog( hwndDlg, FALSE );

            return TRUE;
        }
        else if (dwErr != 0)
        {
            ErrorDlg( hwndDlg, SID_OP_LoadDlg, dwErr, NULL );
            EndDialog( hwndDlg, FALSE );
            return TRUE;
        }
    }

    // Center dialog on the owner window, and hide the owner window which is
    // currently assumed to be the dial progress dialog.
    //
    CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    SetOffDesktop( GetParent( hwndDlg ), SOD_MoveOff, NULL );

    // Add context help button to title bar.
    //
    AddContextHelpButton( hwndDlg );

    // Set initial focus to the screen.
    //
    SetFocus( pInfo->hwndEbScreen );
    return FALSE;
}


BOOL
ItRasApiComplete(
    IN ITINFO* pInfo )

    // Called on WM_RASAPICOMPLETE, i.e. an asynchronous RasPortReceive
    // completed.  'PInfo' is the dialog context block.
    //
    // Returns true if processed the message, false otherwise.
    //
{
    DWORD dwErr;
    DWORD dwSize = SIZE_ReceiveBuf;
    RASMAN_INFO info;

    TRACE( "RasScriptReceive" );
    dwErr = RasScriptReceive(
        pInfo->hscript, pInfo->pbyteReceiveBuf, &dwSize);
    TRACE1( "RasScriptReceive=%d",dwErr );
    if (dwErr != 0)
    {
        ErrorDlg( pInfo->hwndDlg, SID_OP_RasGetInfo, dwErr, NULL );
        EndDialog( pInfo->hwndDlg, FALSE );
        return TRUE;
    }

    info.RI_BytesReceived = (WORD )dwSize;

    // Send the device talk to the terminal edit box.
    //
    if (info.RI_BytesReceived > 0)
    {
        CHAR szBuf[ SIZE_ReceiveBuf + 1 ];
        CHAR* pch = szBuf;
        WORD i;

        TRACE1( "Read %d", info.RI_BytesReceived );

        for (i = 0; i < info.RI_BytesReceived; ++i)
        {
            CHAR ch = pInfo->pbyteReceiveBuf[ i ];

            // Formatting: Converts CRs to LFs (there seems to be no VK_ for
            // LF) and throws away LFs.  This prevents the user from exiting
            // the dialog when they press Enter (CR) in the terminal screen.
            // LF looks like CRLF in the edit box.  Also, throw away TABs
            // because otherwise they change focus to the next control.
            //
            if (ch == VK_RETURN)
            {
                // Must send whenever end-of-line is encountered because
                // EM_REPLACESEL doesn't handle VK_RETURN characters well
                // (prints garbage).
                //
                *pch = '\0';

                // Turn off current selection, if any, and replace the null
                // selection with the current buffer.  This has the effect of
                // adding the buffer at the caret.  Finally, send the EOL to
                // the window which (unlike EM_REPLACESEL) handles it
                // correctly.
                //
                Edit_SetSel( pInfo->hwndEbScreen, (UINT )-1, 0 );
                SendMessageA( pInfo->hwndEbScreen,
                    EM_REPLACESEL, (WPARAM )0, (LPARAM )szBuf );
                SendMessage( pInfo->hwndEbScreen, WM_EOLFROMDEVICE, 0, 0 );

                // Start afresh on the output buffer.
                //
                pch = szBuf;
                continue;
            }
            else if (ch == '\n' || ch == VK_TAB)
            {
                continue;
            }

            *pch++ = ch;
        }

        *pch = '\0';

        if (pch != szBuf)
        {
            // Send the last remnant of the line.
            //
            Edit_SetSel( pInfo->hwndEbScreen, (UINT )-1, 0 );
            SendMessageA( pInfo->hwndEbScreen,
                EM_REPLACESEL, (WPARAM )0, (LPARAM )szBuf );
        }
    }

    return TRUE;
}


VOID
ItTerm(
    IN HWND hwndDlg )

    // Called on WM_DESTROY.  'HwndDlg' is that handle of the dialog window.
    //
{
    ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwndDlg, DWLP_USER );

    TRACE( "ItTerm" );

    if (pInfo)
    {
        // Close RAS script resources
        //
        if (pInfo->hscript)
        {
            TRACE( "Stop script processing" );

            // Shutdown script processing
            //
            TRACE( "RasScriptTerm" );
            RasScriptTerm( pInfo->hscript );
            TRACE( "RasScriptTerm done" );
        }

        // De-activate WndProc hooks.
        //
        if (pInfo->pOldEbScreenWndProc)
        {
            SetWindowLongPtr( pInfo->hwndEbScreen,
                GWLP_WNDPROC, (ULONG_PTR )pInfo->pOldEbScreenWndProc );
        }
        if (pInfo->pOldWndProc)
        {
            SetWindowLongPtr( pInfo->hwndDlg,
                GWLP_WNDPROC, (ULONG_PTR )pInfo->pOldWndProc );
        }

        if (pInfo->hfontEbScreen)
        {
            DeleteObject( (HGDIOBJ )pInfo->hfontEbScreen );
        }

        SetOffDesktop( GetParent( hwndDlg ), SOD_MoveBackFree, NULL );

        Free( pInfo );
    }
}


VOID
ItViewScriptLog(
    IN HWND hwndOwner )

    // Starts notepad.exe on the script log file, script.log.  'HwndOwner' is
    // the window to center any error popup on.
    //
{
    DWORD dwSize;
    TCHAR szCmd[ (MAX_PATH * 2) + 50 + 1 ];
    TCHAR* pszCmd;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL f;

    // Format the command-line string invoking Notepad on the script-log; note
    // the double-quotes around the script-log's path, which are needed since
    // RASSCRIPT_LOG is %windir%\system32\ras\script.log and so the expanded
    // result may contain spaces.
    //
    wsprintf( szCmd, TEXT("notepad.exe \"%s\""), TEXT(RASSCRIPT_LOG) );

    // Get the size of the expanded command-line
    //
    dwSize = ExpandEnvironmentStrings(szCmd, NULL, 0);

    // Allocate enough space for the expanded command-line
    //
    pszCmd = Malloc( (dwSize + 1) * sizeof(TCHAR) );
    if (!pszCmd)
    {
        ErrorDlg( hwndOwner, SID_OP_LoadScriptLog, GetLastError(), NULL );
        return;
    }

    // Expand the command-line into the allocated space
    //
    ExpandEnvironmentStrings(szCmd, pszCmd, dwSize);

    // Initialize the startup-info structure
    //
    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);

    // Launch Notepad on the script-log.
    //
    f = CreateProcess(
            NULL, pszCmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi );
    Free(pszCmd);

    if (f)
    {
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
    }
    else
    {
        ErrorDlg( hwndOwner, SID_OP_LoadScriptLog, GetLastError(), NULL );
    }
}


LRESULT APIENTRY
ItWndProc(
    HWND hwnd,
    UINT unMsg,
    WPARAM wParam,
    LPARAM lParam )

    // Subclassed dialog window procedure.
    //
    // Return value depends on message type.
    //
{
    ITINFO* pInfo = (ITINFO* )GetWindowLongPtr( hwnd, DWLP_USER );
    ASSERT(pInfo);

#if 0
    TRACE4( "ItWndProc(h=$%x,m=$%x,w=$%x,l=$%x)",
           (DWORD )hwnd, (DWORD )unMsg, (DWORD )wparam, (DWORD )lparam );
#endif

    switch (unMsg)
    {
        case WM_CTLCOLOREDIT:
        {
            // Set terminal screen colors to TTY-ish green on black.
            //
            if (pInfo->hbrEbScreen)
            {
                SetBkColor( (HDC )wParam, RGB( 0, 0, 0 ) );
                SetTextColor( (HDC )wParam, RGB( 2, 208, 44 ) );
                return (LRESULT )pInfo->hbrEbScreen;
            }
            break;
        }
    }

    // Call the previous window procedure for everything else.
    //
    return
        CallWindowProc(
            pInfo->pOldWndProc, hwnd, unMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasdlg\util.c ===
// Copyright (c) 1995, Microsoft Corporation, all rights reserved
//
// util.c
// Remote Access Common Dialog APIs
// Utility routines
// Listed alphabetically
//
// Steve Cobb 06/20/95


#include "rasdlgp.h"   // Our private header
#include <dlgs.h>      // Common dialog resource constants
#include <lmwksta.h>   // NetWkstaGetInfo
#include <lmapibuf.h>  // NetApiBufferFree
#include <dsrole.h>    // machine is a member of a workgroup or domain, etc.
#include <tchar.h>

typedef struct _COUNT_FREE_COM_PORTS_DATA
{
    DTLLIST* pListPortsInUse;
    DWORD dwCount;
} COUNT_FREE_COM_PORTS_DATA;

const WCHAR c_szCurrentBuildNumber[]      = L"CurrentBuildNumber";
const WCHAR c_szWinVersionPath[]          =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR c_szNt40BuildNumber[]         = L"1381";

//-----------------------------------------------------------------------------
// Help maps
//-----------------------------------------------------------------------------

static DWORD g_adwPnHelp[] =
{
    CID_LE_ST_Item,    HID_PN_EB_NewNumber,
    CID_LE_EB_Item,    HID_PN_EB_NewNumber,
    CID_LE_PB_Add,     HID_PN_PB_Add,
    CID_LE_PB_Replace, HID_PN_PB_Replace,
    CID_LE_ST_List,    HID_PN_LB_List,
    CID_LE_LB_List,    HID_PN_LB_List,
    CID_LE_PB_Up,      HID_PN_PB_Up,
    CID_LE_PB_Down,    HID_PN_PB_Down,
    CID_LE_PB_Delete,  HID_PN_PB_Delete,
    CID_LE_CB_Promote, HID_PN_CB_Promote,
    0, 0
};


//-----------------------------------------------------------------------------
// Local helper prototypes (alphabetically)
//-----------------------------------------------------------------------------

BOOL 
CountFreeComPorts(
    IN PWCHAR pszPort,
    IN HANDLE hData);
    
//-----------------------------------------------------------------------------
// Utility routines (alphabetically)
//-----------------------------------------------------------------------