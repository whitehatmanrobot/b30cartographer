uerySet.

--*/
{
    return  ComputeQuerySetSize(
                (PWSAQUERYSETA) pQuerySet,
                TRUE        // unicode query set
                );

#if 0
    //
    //  here's the code prior to my change for reference (jamesg)
    //

    INT size;

    size = sizeof(WSAQUERYSETW);

    // DWORD           dwSize;
    // no further action required

    // PWSTR             lpszServiceInstanceName;

    if (pQuerySet->lpszServiceInstanceName != NULL)
    {
        size += (wcslen(pQuerySet->lpszServiceInstanceName)
                    + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // LPGUID          lpServiceClassId;
    if (pQuerySet->lpServiceClassId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // LPWSAVERSION      lpVersion;
    if (pQuerySet->lpVersion != NULL) {
        size += sizeof(WSAVERSION) + (sizeof(DWORD_PTR) -1);
    }

    // PWSTR              lpszComment;
    if (pQuerySet->lpszComment != NULL) {
        size += (wcslen(pQuerySet->lpszComment)
            + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // DWORD           dwNameSpace;
    // no further action required

    // LPGUID          lpNSProviderId;
    if (pQuerySet->lpNSProviderId != NULL) {
        size += sizeof(GUID) + (sizeof(DWORD_PTR) -1);
    }

    // PWSTR              lpszContext;
    if (pQuerySet->lpszContext != NULL) {
        size += (wcslen(pQuerySet->lpszContext)
            + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // PWSTR              lpszQueryString;
    if (pQuerySet->lpszQueryString != NULL) {
        size += (wcslen(pQuerySet->lpszQueryString)
            + 1) * sizeof(WCHAR);
        size += (sizeof(DWORD_PTR) -1);
    }

    // DWORD           dwNumberOfProtocols;
    // no further action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if (pQuerySet->lpafpProtocols != NULL) {
        size += sizeof(AFPROTOCOLS) *
            pQuerySet->dwNumberOfProtocols + 2;
    }

    // DWORD           dwNumberOfCsAddrs;
    // no further action required

    // PCSADDR_INFO    lpcsaBuffer;
    if (pQuerySet->lpcsaBuffer != NULL) {
        size += ComputeAddrInfoArraySize(
            pQuerySet->dwNumberOfCsAddrs,   // dwNumAddrs
            pQuerySet->lpcsaBuffer) + 2;        // lpAddrBuf
    }

    // LPBLOB          lpBlob;
    if (pQuerySet->lpBlob != NULL) {
        size += ComputeBlobSize(
            pQuerySet->lpBlob) + 2;
    }

    return(size);
#endif

} // WSAComputeQuerySetSizeW




//
//  Buffer space management class
//
//  Manages the free space at the tail end of a packed WSAQUERYSET
//  buffer as it is being built.
//

class SPACE_MGR
{
public:
    SPACE_MGR(
        IN INT    MaxBytes,
        IN LPVOID Buf
        );

    ~SPACE_MGR(
        );

    LPVOID
    TakeSpaceBYTE(
        IN INT  NumBytes
        );

    LPVOID
    TakeSpaceWORD(
        IN INT  NumBytes
        );

    LPVOID
    TakeSpaceDWORD(
        IN INT  NumBytes
        );

    LPVOID
    TakeSpaceDWORD_PTR(
        IN INT  NumBytes
        );

private:

    LPVOID
    TakeSpace(
        IN INT  NumBytes,
        IN INT  alignment
        );

    INT    m_MaxBytes;
        // The  maximum  number  of bytes that can be used in the entire buffer
        // (i.e., the size of the buffer).

    LPVOID m_Buf;
        // Pointer to the beginning of the buffer.

    INT    m_BytesUsed;
        // The  number  of  bytes that have been allocated out of the buffer so
        // far.

}; // class SPACE_MGR

typedef SPACE_MGR * LPSPACE_MGR;


SPACE_MGR::SPACE_MGR(
    IN      INT             MaxBytes,
    IN      LPVOID          pBuf
    )
/*++

Routine Description:

    Constructor for a SPACE_MGR object.  It initializes
    the object to indicate that zero bytes have so far been consumed.

Arguments:

    MaxBytes - Supplies  the  starting  number of bytes available in the entire
               buffer.

    pBuf     - Supplies the pointer to the beginning of the buffer.

Return Value:

    Implictly Returns the pointer to the newly allocated SPACE_MGR object.

--*/
{
    m_MaxBytes  = MaxBytes;
    m_Buf       = pBuf;
    m_BytesUsed = 0;
}  // SPACE_MGR::SPACE_MGR




SPACE_MGR::~SPACE_MGR(
    VOID
    )
/*++

Routine Description:

    Destructor for the SPACE_MGR object.

    Note that it is the caller's responsibility to deallocate the
    actual buffer as appropriate.

Arguments:

    None

Return Value:

    None

--*/
{
    m_Buf = NULL;
}  // SPACE_MGR::~SPACE_MGR

inline
LPVOID
SPACE_MGR::TakeSpaceBYTE(
    IN INT  NumBytes
    )
{
    return(TakeSpace(NumBytes, 1));
}

inline
LPVOID
SPACE_MGR::TakeSpaceWORD(
    IN INT  NumBytes
    )
{
    return(TakeSpace(NumBytes, 2));
}

inline
LPVOID
SPACE_MGR::TakeSpaceDWORD(
    IN INT  NumBytes
    )
{
    return(TakeSpace(NumBytes, 4));
}

inline
LPVOID
SPACE_MGR::TakeSpaceDWORD_PTR(
    IN INT NumBytes
    )
{
    return(TakeSpace(NumBytes, sizeof(ULONG_PTR)));
}



LPVOID
SPACE_MGR::TakeSpace(
    IN      INT             NumBytes,
    IN      INT             Align
    )
/*++
Routine Description:

    This  procedure  allocates  the  indicated number of bytes from the buffer,
    returning a pointer to the beginning of the allocated space.  The procedure
    assumes  that  the  caller  does not attempt to allocate more space than is
    available, although it does an internal consistency check.

    Pre-alignment of the buffer is made based on the value of align.

Arguments:

    NumBytes - Supplies the number of bytes to be allocated from the buffer.

    Align - number of bytes to align to

Return Value:

    Pointer to next aligned-by-Align byte in buffer free space.

--*/
{
    LPVOID  return_value;
    PCHAR   charbuf;

    //
    //  align
    //      - bring bytes used up to next multiple of alignment value
    //      - note alignment must be an integral power of 2
    //

    m_BytesUsed = (m_BytesUsed + Align - 1) & ~(Align - 1);

    ASSERT( (NumBytes + m_BytesUsed) <= m_MaxBytes );

    charbuf = (PCHAR) m_Buf;
    return_value = (LPVOID) & charbuf[m_BytesUsed];
    m_BytesUsed += NumBytes;

    return(return_value);

}  // SPACE_MGR::TakeSpace




//
//  WSAQUERYSET copy routines
//

static
PWSAQUERYSETA
CopyQuerySetDirectA(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      PWSAQUERYSETA   Source
    )
/*++
Routine Description:

    This  procedure copies the "direct" portion of the indicated PWSAQUERYSETA
    structure  into  the  managed buffer.  Pointer values in the direct portion
    are  copied,  however  no  "deep" copy is done of the objects referenced by
    those pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyQuerySetIndirectA.
--*/
{
    PWSAQUERYSETA  Target;

    Target = (PWSAQUERYSETA) SpaceMgr->TakeSpaceDWORD_PTR(
                                            sizeof(WSAQUERYSETA));
    *Target = *Source;

    return(Target);

} // CopyQuerySetDirectA



LPBLOB
CopyBlobDirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      LPBLOB          Source
    )
/*++
Routine Description:

    This  procedure  copies  the  "direct"  portion  of  the  indicated  LPBLOB
    structure  into  the  managed buffer.  Pointer values in the direct portion
    are  copied,  however  no  "deep" copy is done of the objects referenced by
    those pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyBlobIndirect.
--*/
{
    LPBLOB Target;

    Target = (LPBLOB) SpaceMgr->TakeSpaceDWORD_PTR( sizeof(BLOB) );
    *Target = *Source;

    return(Target);

} // CopyBlobDirect




VOID
CopyBlobIndirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  LPBLOB          Target,
    IN      LPBLOB          Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated LPBLOB structure into the managed buffer.  Space for the indirect
    portions  is  allocated  from  the  managed  buffer.  Pointer values in the
    "direct"  portion  of the target LPBLOB structure are updated to point into
    the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{
    if ((Source->pBlobData != NULL) &&
        (Source->cbSize != 0))
    {
        Target->pBlobData = (BYTE *) SpaceMgr->TakeSpaceDWORD_PTR(
                                                        Source->cbSize);
        CopyMemory(
            (PVOID) Target->pBlobData,
            (PVOID) Source->pBlobData,
            Source->cbSize );
    }
    else
    {
        //  force the buffer to be well-formed
        Target->pBlobData = NULL;
        Target->cbSize = 0;
    }

} // CopyBlobIndirect



static
PCSADDR_INFO 
CopyAddrInfoArrayDirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      DWORD           NumAddrs,
    IN      PCSADDR_INFO    Source
    )
/*++
Routine Description:

    This  procedure  copies the "direct" portion of the indicated PCSADDR_INFO 
    array  into  the  managed buffer.  Pointer values in the direct portion are
    copied,  however  no "deep" copy is done of the objects referenced by those
    pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    NumAddrs - Supplies the number of CSADDR_INFO structures in the array to be
               copied.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyAddrInfoArrayIndirect.
--*/
{
    PCSADDR_INFO   Target;

    Target = (PCSADDR_INFO ) SpaceMgr->TakeSpaceDWORD_PTR(
                                    NumAddrs * sizeof(CSADDR_INFO));
    CopyMemory(
        (PVOID) Target,
        (PVOID) Source,
        NumAddrs * sizeof(CSADDR_INFO));

    return(Target);

} // CopyAddrInfoArrayDirect



static
VOID
CopyAddrInfoArrayIndirect(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  PCSADDR_INFO    Target,
    IN      DWORD           NumAddrs,
    IN      PCSADDR_INFO    Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated  PCSADDR_INFO   array  into  the  managed  buffer.  Space for the
    indirect  portions is allocated from the managed buffer.  Pointer values in
    the "direct" portion of the target PCSADDR_INFO  array are updated to point
    into the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    NumAddrs - Supplies the number of CSADDR_INFO structures in the array to be
               copied.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{
    DWORD i;

    for (i = 0; i < NumAddrs; i++) {
        // SOCKET_ADDRESS LocalAddr ;
        if ((Source[i].LocalAddr.lpSockaddr != NULL) &&
            (Source[i].LocalAddr.iSockaddrLength != 0)) {
            Target[i].LocalAddr.lpSockaddr =
                (LPSOCKADDR) SpaceMgr->TakeSpaceDWORD_PTR(
                    Source[i].LocalAddr.iSockaddrLength);
            CopyMemory(
                (PVOID) Target[i].LocalAddr.lpSockaddr,
                (PVOID) Source[i].LocalAddr.lpSockaddr,
                Source[i].LocalAddr.iSockaddrLength);
        }
        else {
            Target[i].LocalAddr.lpSockaddr = NULL;
            // And force the buffer to be well-formed
            Target[i].LocalAddr.iSockaddrLength = 0;
        }

        // SOCKET_ADDRESS RemoteAddr ;
        if ((Source[i].RemoteAddr.lpSockaddr != NULL) &&
            (Source[i].RemoteAddr.iSockaddrLength != 0)) {
            Target[i].RemoteAddr.lpSockaddr =
                (LPSOCKADDR) SpaceMgr->TakeSpaceDWORD_PTR(
                     Source[i].RemoteAddr.iSockaddrLength);
            CopyMemory(
                (PVOID) Target[i].RemoteAddr.lpSockaddr,
                (PVOID) Source[i].RemoteAddr.lpSockaddr,
                Source[i].RemoteAddr.iSockaddrLength);
        }
        else {
            Target[i].RemoteAddr.lpSockaddr = NULL;
            // And force the buffer to be well-formed
            Target[i].RemoteAddr.iSockaddrLength = 0;
        }

        // INT iSocketType ;
        // no action required

        // INT iProtocol ;
        // no action required

    } // for i

} // CopyAddrInfoArrayIndirect



static
VOID
CopyQuerySetIndirectA(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  PWSAQUERYSETA  Target,
    IN      PWSAQUERYSETA  Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated  PWSAQUERYSETA structure into the managed buffer.  Space for the
    indirect  portions is allocated from the managed buffer.  Pointer values in
    the  "direct" portion of the target PWSAQUERYSETA structure are updated to
    point into the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{

    // DWORD           dwSize;
    // no action required

    // LPSTR            lpszServiceInstanceName;
    if (Source->lpszServiceInstanceName != NULL) {
        Target->lpszServiceInstanceName = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszServiceInstanceName) + 1);
        lstrcpy(
            Target->lpszServiceInstanceName,
            Source->lpszServiceInstanceName);
    }
    else {
        Target->lpszServiceInstanceName = NULL;
    }

    // LPGUID          lpServiceClassId;
    if (Source->lpServiceClassId != NULL) {
        Target->lpServiceClassId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpServiceClassId) = *(Source->lpServiceClassId);
    }
    else {
        Target->lpServiceClassId = NULL;
    }

    // LPWSAVERSION      lpVersion;
    if (Source->lpVersion != NULL) {
        Target->lpVersion = (LPWSAVERSION) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(WSAVERSION));
        *(Target->lpVersion) = *(Source->lpVersion);
    }
    else {
        Target->lpVersion = NULL;
    }

    // LPSTR             lpszComment;
    if (Source->lpszComment != NULL) {
        Target->lpszComment = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszComment) + 1);
        lstrcpy(
            Target->lpszComment,
            Source->lpszComment);
    }
    else {
        Target->lpszComment = NULL;
    }

    // DWORD           dwNameSpace;
    // no action required

    // LPGUID          lpNSProviderId;
    if (Source->lpNSProviderId != NULL) {
        Target->lpNSProviderId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpNSProviderId) = *(Source->lpNSProviderId);
    }
    else {
        Target->lpNSProviderId = NULL;
    }

    // LPSTR             lpszContext;
    if (Source->lpszContext != NULL) {
        Target->lpszContext = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszContext) + 1);
        lstrcpy(
            Target->lpszContext,
            Source->lpszContext);
    }
    else {
        Target->lpszContext = NULL;
    }

    // LPSTR             lpszQueryString;
    if (Source->lpszQueryString != NULL) {
        Target->lpszQueryString = (LPSTR) SpaceMgr->TakeSpaceBYTE(
            lstrlen(Source->lpszQueryString) + 1);
        lstrcpy(
            Target->lpszQueryString,
            Source->lpszQueryString);
    }
    else {
        Target->lpszQueryString = NULL;
    }

    // DWORD           dwNumberOfProtocols;
    // no action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if ((Source->lpafpProtocols != NULL) &&
        (Source->dwNumberOfProtocols != 0)) {
        Target->lpafpProtocols = (LPAFPROTOCOLS) SpaceMgr->TakeSpaceDWORD_PTR(
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
        CopyMemory (
            (PVOID) Target->lpafpProtocols,
            (PVOID) Source->lpafpProtocols,
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
    }
    else {
        Target->lpafpProtocols = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfProtocols = 0;
    }

    // DWORD           dwNumberOfCsAddrs;
    // no action required

    // PCSADDR_INFO    lpcsaBuffer;
    if ((Source->lpcsaBuffer != NULL) &&
        (Source->dwNumberOfCsAddrs != 0)) {
        Target->lpcsaBuffer = CopyAddrInfoArrayDirect(
            SpaceMgr,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
        CopyAddrInfoArrayIndirect(
            SpaceMgr,
            Target->lpcsaBuffer,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
    }
    else {
        Target->lpcsaBuffer = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfCsAddrs = 0;
    }

    // LPBLOB          lpBlob;
    if (Source->lpBlob != NULL) {
        Target->lpBlob = CopyBlobDirect(
            SpaceMgr,
            Source->lpBlob);
        CopyBlobIndirect(
            SpaceMgr,
            Target->lpBlob,
            Source->lpBlob);
    }
    else {
        Target->lpBlob = NULL;
    }

} // CopyQuerySetIndirectA




INT
WSAAPI
WSABuildQuerySetBufferA(
    IN      PWSAQUERYSETA  pQuerySet,
    IN      DWORD           dwPackedQuerySetSize,
    OUT     PWSAQUERYSETA  lpPackedQuerySet
    )
/*++
Routine Description:

    This  procedure  copies  a  source  WSAQUERYSET  into  a target WSAQUERYSET
    buffer.  The target WSAQUERYSET buffer is assembled in "packed" form.  That
    is,  all  pointers  in  the  WSAQUERYSET  are  to locations within the same
    supplied buffer.

Arguments:

    pQuerySet     - Supplies  the  source  query set to be copied to the
                           target  buffer.   The  supplied  query  set  may  be
                           organized  as  separately-allocated  pieces  or as a
                           single packed buffer.

    dwPackedQuerySetSize - Supplies the size, in bytes, of the target query set
                           buffer.

    lpPackedQuerySet     - Returns the packed copied query set.

Return Value:

    ERROR_SUCCESS - The function succeeded.

    SOCKET_ERROR  - The function failed.  A specific error code can be obtained
                    from WSAGetLastError().

Implementation Notes:

    If (target buffer is big enough) then
        space_mgr = new buffer_space_manager(...);
        start_direct = CopyQuerySetDirectA(
            space_mgr,
            (LPVOID) pQuerySet);
        CopyQuerySetIndirectA(
            space_mgr,
            start_direct,
            pQuerySet);
        delete space_mgr;
        result = ERROR_SUCCESS;
    else
        result = SOCKET_ERROR;
    endif

--*/
{
    INT          return_value;
    INT          space_required;
    BOOL         ok_to_continue;

    ok_to_continue = TRUE;

    space_required = WSAComputeQuerySetSizeA( pQuerySet );

    if ((DWORD) space_required > dwPackedQuerySetSize) {
        SetLastError(WSAEFAULT);
        ok_to_continue = FALSE;
    }

    SPACE_MGR    space_mgr(
        dwPackedQuerySetSize,
        lpPackedQuerySet);

    if (ok_to_continue) {
        PWSAQUERYSETA  Target;
        Target = CopyQuerySetDirectA(
            & space_mgr,        // SpaceMgr
            pQuerySet);  // Source
        CopyQuerySetIndirectA(
            & space_mgr,        // SpaceMgr
            Target,             // Target
            pQuerySet);  // Source
    }

    if (ok_to_continue) {
        return_value = ERROR_SUCCESS;
    }
    else {
        return_value = SOCKET_ERROR;
    }
    return(return_value);

} // WSABuildQuerySetBufferA




static
PWSAQUERYSETW
CopyQuerySetDirectW(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN      PWSAQUERYSETW  Source
    )
/*++
Routine Description:

    This  procedure copies the "direct" portion of the indicated PWSAQUERYSETW
    structure  into  the  managed buffer.  Pointer values in the direct portion
    are  copied,  however  no  "deep" copy is done of the objects referenced by
    those pointers.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Source   - Supplies the source data to be copied.

Return Value:

    The  function returns a pointer to the beginning of the newly copied target
    values.   This  value  is  typically  used  as the "Target" in a subsequent
    CopyQuerySetIndirectW.
--*/
{
    PWSAQUERYSETW  Target;

    Target = (PWSAQUERYSETW) SpaceMgr->TakeSpaceDWORD_PTR(
        sizeof(WSAQUERYSETW));
    *Target = *Source;

    return(Target);

} // CopyQuerySetDirectW




VOID
CopyQuerySetIndirectW(
    IN OUT  LPSPACE_MGR     SpaceMgr,
    IN OUT  PWSAQUERYSETW  Target,
    IN      PWSAQUERYSETW  Source
    )
/*++
Routine Description:

    This  procedure  does  a  full-depth copy of the "indirect" portions of the
    indicated  PWSAQUERYSETW structure into the managed buffer.  Space for the
    indirect  portions is allocated from the managed buffer.  Pointer values in
    the  "direct" portion of the target PWSAQUERYSETW structure are updated to
    point into the managed buffer at the correct location.

Arguments:

    SpaceMgr - Supplies  the  starting  buffer  allocation  state.  Returns the
               resulting buffer allocation state.

    Target   - Supplies  the  starting values of the "direct" portion.  Returns
               the "direct" portion values with all pointers updated.

    Source   - Supplies the source data to be copied.

Return Value:

    none
--*/
{

    // DWORD           dwSize;
    // no action required

    // PWSTR             lpszServiceInstanceName;
    if (Source->lpszServiceInstanceName != NULL) {
        Target->lpszServiceInstanceName = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszServiceInstanceName) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszServiceInstanceName,
            Source->lpszServiceInstanceName);
    }
    else {
        Target->lpszServiceInstanceName = NULL;
    }

    // LPGUID          lpServiceClassId;
    if (Source->lpServiceClassId != NULL) {
        Target->lpServiceClassId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpServiceClassId) = *(Source->lpServiceClassId);
    }
    else {
        Target->lpServiceClassId = NULL;
    }

    // LPWSAVERSION      lpVersion;
    if (Source->lpVersion != NULL) {
        Target->lpVersion = (LPWSAVERSION) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(WSAVERSION));
        *(Target->lpVersion) = *(Source->lpVersion);
    }
    else {
        Target->lpVersion = NULL;
    }

    // PWSTR              lpszComment;
    if (Source->lpszComment != NULL) {
        Target->lpszComment = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszComment) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszComment,
            Source->lpszComment);
    }
    else {
        Target->lpszComment = NULL;
    }

    // DWORD           dwNameSpace;
    // no action required

    // LPGUID          lpNSProviderId;
    if (Source->lpNSProviderId != NULL) {
        Target->lpNSProviderId = (LPGUID) SpaceMgr->TakeSpaceDWORD_PTR(
            sizeof(GUID));
        *(Target->lpNSProviderId) = *(Source->lpNSProviderId);
    }
    else {
        Target->lpNSProviderId = NULL;
    }

    // PWSTR              lpszContext;
    if (Source->lpszContext != NULL) {
        Target->lpszContext = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszContext) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszContext,
            Source->lpszContext);
    }
    else {
        Target->lpszContext = NULL;
    }

    // PWSTR              lpszQueryString;
    if (Source->lpszQueryString != NULL) {
        Target->lpszQueryString = (PWSTR ) SpaceMgr->TakeSpaceWORD(
            (wcslen(Source->lpszQueryString) + 1) * sizeof(WCHAR));
        wcscpy(
            Target->lpszQueryString,
            Source->lpszQueryString);
    }
    else {
        Target->lpszQueryString = NULL;
    }

    // DWORD           dwNumberOfProtocols;
    // no action required

    // LPAFPROTOCOLS   lpafpProtocols;
    if ((Source->lpafpProtocols != NULL) &&
        (Source->dwNumberOfProtocols != 0)) {
        Target->lpafpProtocols = (LPAFPROTOCOLS) SpaceMgr->TakeSpaceDWORD_PTR(
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
        CopyMemory (
            (PVOID) Target->lpafpProtocols,
            (PVOID) Source->lpafpProtocols,
            Source->dwNumberOfProtocols * sizeof(AFPROTOCOLS));
    }
    else {
        Target->lpafpProtocols = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfProtocols = 0;
    }

    // DWORD           dwNumberOfCsAddrs;
    // no action required

    // PCSADDR_INFO    lpcsaBuffer;
    if ((Source->lpcsaBuffer != NULL) &&
        (Source->dwNumberOfCsAddrs != 0)) {
        Target->lpcsaBuffer = CopyAddrInfoArrayDirect(
            SpaceMgr,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
        CopyAddrInfoArrayIndirect(
            SpaceMgr,
            Target->lpcsaBuffer,
            Source->dwNumberOfCsAddrs,
            Source->lpcsaBuffer);
    }
    else {
        Target->lpcsaBuffer = NULL;
        // And force the target buffer to be well-formed
        Target->dwNumberOfCsAddrs = 0;
    }

    // LPBLOB          lpBlob;
    if (Source->lpBlob != NULL) {
        Target->lpBlob = CopyBlobDirect(
            SpaceMgr,
            Source->lpBlob);
        CopyBlobIndirect(
            SpaceMgr,
            Target->lpBlob,
            Source->lpBlob);
    }
    else {
        Target->lpBlob = NULL;
    }

} // CopyQuerySetIndirectW




INT
WSAAPI
WSABuildQuerySetBufferW(
    IN      PWSAQUERYSETW  pQuerySet,
    IN      DWORD           dwPackedQuerySetSize,
    OUT     PWSAQUERYSETW  lpPackedQuerySet
    )
/*++
Routine Description:

    This  procedure  copies  a  source  WSAQUERYSET  into  a target WSAQUERYSET
    buffer.  The target WSAQUERYSET buffer is assembled in "packed" form.  That
    is,  all  pointers  in  the  WSAQUERYSET  are  to locations within the same
    supplied buffer.

Arguments:

    pQuerySet     - Supplies  the  source  query set to be copied to the
                           target  buffer.   The  supplied  query  set  may  be
                           organized  as  separately-allocated  pieces  or as a
                           single packed buffer.

    dwPackedQuerySetSize - Supplies the size, in bytes, of the target query set
                           buffer.

    lpPackedQuerySet     - Returns the packed copied query set.

Return Value:

    ERROR_SUCCESS - The function succeeded.

    SOCKET_ERROR  - The function failed.  A specific error code can be obtained
                    from WSAGetLastError().
--*/
{
    INT     return_value = ERROR_SUCCESS;
    INT     space_required;
    BOOL    ok_to_continue = TRUE;

    space_required = WSAComputeQuerySetSizeW( pQuerySet );

    if ( (DWORD)space_required > dwPackedQuerySetSize )
    {
        SetLastError( WSAEFAULT );
        ok_to_continue = FALSE;
    }

    SPACE_MGR  space_mgr(
        dwPackedQuerySetSize,
        lpPackedQuerySet );

    if ( ok_to_continue )
    {
        PWSAQUERYSETW  Target;
        Target = CopyQuerySetDirectW(
                    & space_mgr,        // SpaceMgr
                    pQuerySet);  // Source

        CopyQuerySetIndirectW(
            & space_mgr,        // SpaceMgr
            Target,             // Target
            pQuerySet);         // Source
    }

    if (ok_to_continue)
    {
        return_value = ERROR_SUCCESS;
    }
    else
    {
        return_value = SOCKET_ERROR;
    }
    return(return_value);

} // WSABuildQuerySetBufferW




PWSTR 
wcs_dup_from_ansi(
    IN LPSTR  Source
    )
/*++
Routine Description:

    This  procedure  is intended for internal use only within this module since
    it  requires the caller to use the same memory management strategy that the
    procedure uses internally.

    The procedure allocates a Unicode string and initializes it with the string
    converted  from  the  supplied  Ansi  source  string.   It  is the caller's
    responsibility  to  eventually deallocate the returned Unicode string using
    the C++ "delete" operator.

Arguments:

    Source - Supplies the Ansi string to be duplicated into Unicode form.

Return Value:

    The  procedure  returns  the newly allocated and initialized Unicode string
    pointer.   It  caller  must eventually deallocate this string using the C++
    "delete" opertor.  The procedure returns NULL if memory allocation fails.
--*/
{
    INT     len_guess;
    BOOL    still_trying;
    PWSTR   return_string;

    ASSERT( Source != NULL );

    // An  initial guess length of zero is required, since that is the only way
    // we  can coax the conversion fuction to ignore the buffer and tell us the
    // length  required.   Note  that  "length"  is in terms of the destination
    // characters   whatever  byte-width  they  have.   Presumably  the  length
    // returned from a conversion function includes the terminator.

    len_guess = 0;
    still_trying = TRUE;
    return_string = NULL;

    while (still_trying) {
        int  chars_required;

        chars_required = MultiByteToWideChar(
                            CP_ACP,         // CodePage (Ansi)
                            0,              // dwFlags
                            Source,         // lpMultiByteStr
                            -1,             // cchMultiByte
                            return_string,  // lpWideCharStr
                            len_guess );    // cchWideChar

        if (chars_required > len_guess) {
            // retry with new size
            len_guess = chars_required;
            delete return_string;
            return_string = new WCHAR[len_guess];
            if (return_string == NULL) {
                still_trying = FALSE;
            }
        }
        else if (chars_required > 0) {
            // success
            still_trying = FALSE;
        }
        else {
            // utter failure
            delete return_string;
            return_string = NULL;
            still_trying = FALSE;
        }
    }

    return(return_string);

} // wcs_dup_from_ansi




LPSTR
ansi_dup_from_wcs(
    IN PWSTR   Source
    )
/*++
Routine Description:

    This  procedure  is intended for internal use only within this module since
    it  requires the caller to use the same memory management strategy that the
    procedure uses internally.

    The  procedure  allocates an Ansi string and initializes it with the string
    converted  from  the  supplied  Unicode  source string.  It is the caller's
    responsibility  to eventually deallocate the returned Ansi string using the
    C++ "delete" operator.

Arguments:

    Source - Supplies the Unicode string to be duplicated into Ansi form.

Return Value:

    The  procedure  returns  the  newly  allocated  and initialized Ansi string
    pointer.   It  caller  must eventually deallocate this string using the C++
    "delete" opertor.  The procedure returns NULL if memory allocation fails.
--*/
{
    INT     len_guess;
    BOOL    still_trying;
    LPSTR   return_string;

    ASSERT( Source != NULL );

    // An  initial guess length of zero is required, since that is the only way
    // we  can coax the conversion fuction to ignore the buffer and tell us the
    // length  required.   Note  that  "length"  is in terms of the destination
    // characters   whatever  byte-width  they  have.   Presumably  the  length
    // returned from a conversion function includes the terminator.

    len_guess = 0;
    still_trying = TRUE;
    return_string = NULL;

    while (still_trying) {
        int  chars_required;

        chars_required = WideCharToMultiByte(
                            CP_ACP,        // CodePage (Ansi)
                            0,             // dwFlags
                            Source,        // lpWideCharStr
                            -1,            // cchWideChar
                            return_string, // lpMultiByteStr
                            len_guess,     // cchMultiByte
                            NULL,          // lpDefaultChar
                            NULL );        // lpUsedDefaultChar
        if (chars_required > len_guess) {
            // retry with new size
            len_guess = chars_required;
            delete return_string;
            return_string = new CHAR[len_guess];
            if (return_string == NULL) {
                still_trying = FALSE;
            }
        }
        else if (chars_required > 0) {
            // success
            still_trying = FALSE;
        }
        else {
            // utter failure
            delete return_string;
            return_string = NULL;
            still_trying = FALSE;
        }
    } // while still_trying

    return(return_string);

} // ansi_dup_from_wcs




INT
MapAnsiQuerySetToUnicode(
    IN      PWSAQUERYSETA  Source,
    IN OUT  LPDWORD         lpTargetSize,
    OUT     PWSAQUERYSETW  Target
    )
/*++
Routine Description:

    This  procedure  takes  an  Ansi  PWSAQUERYSETA  and  builds an equivalent
    Unicode PWSAQUERYSETW packed structure.

Arguments:

    Source       - Supplies  the  source query set structure to be copied.  The
                   source  structure  may  be in packed or separately-allocated
                   form.

    lpTargetSize - Supplies  the  size, in bytes, of the Target buffer.  If the
                   function  fails  due to insufficient Target buffer space, it
                   returns  the  required  size of the Target buffer.  In other
                   situations, lpTargetSize is not updated.

    Target       - Returns   the   equivalent   Unicode  PWSAQUERYSETW  packed
                   structure.   This  value  is  ignored if lpTargetSize is not
                   enough  to  hold the resulting structure.  It may be NULL if
                   lpTargetSize is 0.

Return Value:

    ERROR_SUCCESS - The function was successful

    WSAEFAULT     - The  function  failed  due to insufficient buffer space and
                    lpTargetSize was updated with the required size.

    other         - If  the  function  fails  in  any  other way, it returns an
                    appropriate WinSock 2 error code.

Implementation:

    compute size required for copy of source;
    allocate a source copy buffer;
    build source copy;
    cast source copy to Unicode version;
    for each source string requiring conversion loop
        allocate and init with converted string;
        over-write string pointer with allocated;
    end loop
    compute size required for unicode version;
    if (we have enough size) then
        flatten unicode version into target
        return_value = ERROR_SUCCESS
    else
        *lpTargetSize = required unicode size
    endif
    for each allocated converted string loop
        delete converted string
    end loop
    delete source copy buffer
--*/
{
    INT             return_value = ERROR_SUCCESS;
    PWSAQUERYSETA   src_copy_A = NULL;
    PWSAQUERYSETW   src_copy_W;
    DWORD           src_size_A;
    DWORD           needed_size_W;
    INT             build_result_A;
    INT             build_result_W;
    PWSTR           W_string1 = NULL;
    PWSTR           W_string2 = NULL;
    PWSTR           W_string3 = NULL;
    PWSTR           W_string4 = NULL;
    BOOL            ok_to_continue = TRUE;

    //
    //  copy original string
    //
    //  note:  there's a possible optimization here if we know
    //      the input query set is ours (as in the return case)
    //      we can avoid the copy
    //          - save the original string field pointers
    //          - convert the string fields sticking pointers
    //              in the original query set
    //          - copy to target buffer
    //          - revert the string fields to original pointers
    //          - cleanup copies
    //

    src_size_A = WSAComputeQuerySetSizeA(Source);

    src_copy_A = (PWSAQUERYSETA) new char[src_size_A];

    if (src_copy_A == NULL) {
        return_value = WSA_NOT_ENOUGH_MEMORY;
        ok_to_continue = FALSE;
    }
    if (ok_to_continue) {
        build_result_A = WSABuildQuerySetBufferA(
            Source,      // pQuerySet
            src_size_A,  // dwPackedQuerySetSize
            src_copy_A); // lpPackedQuerySet
        if (build_result_A != ERROR_SUCCESS) {
            return_value = GetLastError();
            ok_to_continue = FALSE;
        }
    } // if (ok_to_continue)

    if (ok_to_continue) {
        // In  the following cast, we are taking advantage of the fact that the
        // layout of fields in the WSAQUERYSETA and WSAQUERYSETW are identical.
        // If  this  were not the case, we would have to assemble an equivalent
        // query  set  of the other type field by field.  Since the layouts are
        // the  same,  we  can  simply  alter  our  local  copy  in-place  with
        // converted, separately allocated strings.
        src_copy_W = (PWSAQUERYSETW) src_copy_A;

        if( src_copy_A->lpszServiceInstanceName != NULL ) {
            W_string1 = wcs_dup_from_ansi(
                src_copy_A->lpszServiceInstanceName);
            if (W_string1 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszServiceInstanceName = W_string1;
    } // if (ok_to_continue)

    if (ok_to_continue) {
        if( src_copy_A->lpszComment != NULL ) {
            W_string2 = wcs_dup_from_ansi(
                src_copy_A->lpszComment);
            if (W_string2 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszComment = W_string2;
    } // if (ok_to_continue)

    if (ok_to_continue) {
        if( src_copy_A->lpszContext != NULL ) {
            W_string3 = wcs_dup_from_ansi(
                src_copy_A->lpszContext);
            if (W_string3 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszContext = W_string3;
    } // if (ok_to_continue)

    if (ok_to_continue) {
        if( src_copy_A->lpszQueryString != NULL ) {
            W_string4 = wcs_dup_from_ansi(
                src_copy_A->lpszQueryString);
            if (W_string4 == NULL) {
                return_value = WSA_NOT_ENOUGH_MEMORY;
                ok_to_continue = FALSE;
            }
        }
        src_copy_W->lpszQueryString = W_string4;
    } // if (ok_to_continue)

    // Now  we  have  a  converted  query set, but it is composed of separately
    // allocated pieces attached to our locally-allocated buffer.

    if (ok_to_continue) {
        needed_size_W = WSAComputeQuerySetSizeW(src_copy_W);
        if (needed_size_W > (* lpTargetSize)) {
            * lpTargetSize = needed_size_W;
            return_value = WSAEFAULT;
            ok_to_continue = FALSE;
        }
    }

    if (ok_to_continue) {
        build_result_W = WSABuildQuerySetBufferW(
            src_copy_W,      // pQuerySet
            * lpTargetSize,  // dwPackedQuerySetSize
            Target);         // lpPackedQuerySet
        if (build_result_W != ERROR_SUCCESS) {
            return_value = GetLastError();
            ok_to_continue = FALSE;
        }
    }

    // clean up the temporarily-allocated memory
    delete W_string4;
    delete W_string3;
    delete W_string2;
    delete W_string1;
    delete src_copy_A;

    return(return_value);

} // MapAnsiQuerySetToUnicode



INT
MapUnicodeQuerySetToAnsi(
    IN      PWSAQUERYSETW  pSource,
    IN OUT  PDWORD          pTargetSize,
    OUT     PWSAQUERYSETA  pTarget
    )
/*++

Routine Description:

    Copy unicode query set to ANSI query set in packed buffer.

Arguments:

    pSource - existing unicode query set (may be packed or separately allocated)

    pTargetSize - addr of DWORD containing size of target buffer;
        if this size is insufficient, the address is updated with the required
            size for the ANSI query set;
        otherwise (including success) the size is not updated

    pTarget - ptr to buffer to receive ANSI version of query set in packed form
        - this buffer will not be written to if pTargetSize is less than
          required size of query set in ANSI packed buffer
        - may be NULL if pTargetSize contains zero (only size information desired)

Return Value:

    ERROR_SUCCESS - if wrote ANSI query set to buffer
    WSAEFAULT     - if failed due to insufficient buffer space and
                    pTargetSize was updated with the required size.
    WinsockError  - if functions fails for other reason (ex memory allocation)

--*/
{
    INT             retval = ERROR_SUCCESS;
    PWSAQUERYSETW   ptempW = NULL;
    PWSAQUERYSETA   ptempA;
    DWORD           size;
    LPSTR           ptempName = NULL;
    LPSTR           ptempComment = NULL;
    LPSTR           ptempContext = NULL;
    LPSTR           ptempQueryString = NULL;


    //
    //  copy original string
    //
    //  note:  there's a possible optimization here if we know
    //      the input query set is ours (as in the return case)
    //      we can avoid the copy
    //          - save the original string field pointers
    //          - convert the string fields sticking pointers
    //              in the original query set
    //          - copy to target buffer
    //          - revert the string fields to original pointers
    //          - cleanup copies
    //

    //
    //  size source query set and alloc space for copy
    //

    size = WSAComputeQuerySetSizeW( pSource );

    ptempW = (PWSAQUERYSETW) new char[size];
    if ( ptempW == NULL )
    {
        retval = WSA_NOT_ENOUGH_MEMORY;
        goto Done;
    }

    //
    //  make unicode copy of query set
    //

    retval = WSABuildQuerySetBufferW(
                        pSource,        // pQuerySet
                        size,           // dwPackedQuerySetSize
                        ptempW  // lpPackedQuerySet
                        );
    if ( retval != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        retval = GetLastError();
        goto Done;
    }

    //
    //  convert unicode copy to ANSI in place
    //
    //      - cast unicode structure to ANSI
    //      - all non-string fields left alone
    //      - replace string field pointers with pointers to
    //          individually allocated copies
    //
    //  note, that this approach depends on the fields in WSAQUERYSETA and
    //  WSAQUERYSETW being the same.
    //

    ptempA = (PWSAQUERYSETA) ptempW;

    if ( ptempW->lpszServiceInstanceName )
    {
        ptempName = ansi_dup_from_wcs( ptempW->lpszServiceInstanceName );
        if ( !ptempName )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszServiceInstanceName = ptempName;
    }

    if ( ptempW->lpszComment )
    {
        ptempComment = ansi_dup_from_wcs( ptempW->lpszComment );
        if ( !ptempComment )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszComment = ptempComment;
    }

    if ( ptempW->lpszContext )
    {
        ptempContext = ansi_dup_from_wcs( ptempW->lpszContext );
        if ( !ptempContext )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszContext = ptempContext;
    }

    if( ptempW->lpszQueryString )
    {
        ptempQueryString = ansi_dup_from_wcs( ptempW->lpszQueryString );
        if ( !ptempQueryString )
        {
            retval = WSA_NOT_ENOUGH_MEMORY;
            goto Done;
        }
        ptempA->lpszQueryString = ptempQueryString;
    }

    //
    //  successfully converted temp query set to ANSI
    //      but it is separately allocated pieces, need to write as
    //      flat buffer to target buffer

    //
    //  verify adequate buffer length
    //      - get ANSI query set size
    //      - compare to buffer size
    //

    size = WSAComputeQuerySetSizeA( ptempA );

    if ( size > (*pTargetSize) )
    {
        *pTargetSize = size;
        retval = WSAEFAULT;
        goto Done;
    }

    //
    //  write query set to ANSI
    //

    retval = WSABuildQuerySetBufferA(
                    ptempA,             // pQuerySet
                    * pTargetSize,      // dwPackedQuerySetSize
                    pTarget );          // lpPackedQuerySet

    if ( retval != ERROR_SUCCESS )
    {
        ASSERT( FALSE );
        retval = GetLastError();
        goto Done;
    }
    
Done:

    //  clean up the temporary allocations

    delete ptempName;
    delete ptempComment;
    delete ptempContext;
    delete ptempQueryString;
    delete ptempW;

    return( retval );

} // MapUnicodeQuerySetToAnsi



INT
CopyQuerySetA(
    IN      PWSAQUERYSETA      Source,
    OUT     PWSAQUERYSETA *    Target
    )
{
    DWORD dwSize = WSAComputeQuerySetSizeA(Source);

    *Target = (PWSAQUERYSETA)new BYTE[dwSize];
    if (*Target == NULL)
        return WSA_NOT_ENOUGH_MEMORY;

    return WSABuildQuerySetBufferA(Source, dwSize, *Target);
} // CopyQuerySetA




INT
CopyQuerySetW(
    IN      PWSAQUERYSETW      Source,
    OUT     PWSAQUERYSETW *    Target
    )
{
    DWORD dwSize = WSAComputeQuerySetSizeW(Source);

    *Target = (PWSAQUERYSETW)new BYTE[dwSize];
    if (*Target == NULL)
        return WSA_NOT_ENOUGH_MEMORY;
    return WSABuildQuerySetBufferW(Source, dwSize, *Target);
} // CopyQuerySetW


//
//  End qshelpr.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\nsquery.cpp ===
/*++

    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.

Module Name:

    nsquery.cpp

Abstract:

    This module gives the class implementation for the NSQUERY object type.
    The NSQUERY object holds all the state information regarding a
    WSALookup{Begin/Next/End} series of operations. It supplies member
    functions that implement the API-level operations in terms of the SPI-level
    operations.

Author:

    Dirk Brandewie (dirk@mink.intel.com) 04-December-1995

Notes:

    $Revision:   1.14  $

    $Modtime:   08 Mar 1996 16:14:30  $


Revision History:

    most-recent-revision-date email-name
        description

    04-Dec-1995 dirk@mink.intel.com
        Initail revision

--*/

#include "precomp.h"

BOOL
MatchProtocols(DWORD dwNameSpace, LONG lfamily, LPWSAQUERYSETW lpqs)
/*++
Checks if the namespace provider identified by dwNamespace can
handle the protocol items in the list. It knows about NS_DNS and
NS_SAP only and therefore all other providers simply "pass". These
two providers are known to support one address family each and therefore
the protocol restrictions must include this family.
N.B. The right way to do this is to pass in the supported address family,
which in a more perfect world, would be store in the registry along with
the other NSP information. When that day dawns, this code can be
changed to use that value.
--*/
{
    DWORD dwProts = lpqs->dwNumberOfProtocols;
    LPAFPROTOCOLS lap = lpqs->lpafpProtocols;
    INT Match;

    //
    // this switch is the replacment for having the supported protocol
    // stored  in registry.
    //
    if(lfamily != -1)
    {
        if(lfamily == AF_UNSPEC)
        {
            return(TRUE);       // does them all
        }
        Match = lfamily;
    }
    else
    {
        switch(dwNameSpace)
        {
            case NS_SAP:
                Match = AF_IPX;
                break;

#if 0
      // The DNS name space provider now supports IPV6, IP SEC, ATM, etc.
      // Not just INET.

            case NS_DNS:
                Match = AF_INET;
                break;
#endif
            default:
                return(TRUE);      // use it
        }
    }
    //
    // If we get the address family-in-the registry=support, then
    // we should check for a value of AF_UNSPEC stored there
    // and accept this provider in that case. Note that if
    // AF_UNSPEC is given in the restriction list, we must
    // load each provider since we don't know the specific protocols
    // a provider supports.
    //
    for(; dwProts; dwProts--, lap++)
    {
        if((lap->iAddressFamily == AF_UNSPEC)
                      ||
           (lap->iAddressFamily == Match))
        {
            return(TRUE);
        }
    }
    return(FALSE);
}


NSQUERY::NSQUERY()
/*++

Routine Description:

    Constructor for the NSQUERY object.  The first member function called after
    this must be Initialize.

Arguments:

    None

Return Value:

    Returns a pointer to a NSQUERY object.
--*/
{
    m_signature = ~QUERYSIGNATURE;
    m_reference_count  = 0;
    m_shutting_down = FALSE;
    InitializeListHead(&m_provider_list);
    m_current_provider = NULL;
    m_change_ioctl_succeeded = FALSE;
#ifdef RASAUTODIAL
    m_query_set = NULL;
    m_control_flags = 0;
    m_catalog = NULL;
    m_restartable = TRUE;
#endif
}



INT
NSQUERY::Initialize(
    )
/*++

Routine Description:

    This  procedure  performs  all initialization for the NSQUERY object.  This
    function  must  be  invoked  after the constructor, before any other member
    function is invoked.

Arguments:


Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock 2 error code.
--*/
{
    INT     err;
    // Init mem variables that need some amount of processing
    __try {
        InitializeCriticalSection(&m_members_guard);
        m_signature = QUERYSIGNATURE;
        m_reference_count = 1; // Initial reference.
        err = ERROR_SUCCESS;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = WSA_NOT_ENOUGH_MEMORY;
    }

    return(err);
}



BOOL
NSQUERY::ValidateAndReference()
/*++

Routine Description:

   Checks the signature of this->m_signature to ensure that this is a valid
   query object and references it.

Arguments:

    NONE

Return Value:

    True if this points to valid query object and we were able to reference it.

--*/
{
    LONG    newCount;
    __try
    {

        while (1) {
            //
            // Check the signature first
            //
            if (m_signature != QUERYSIGNATURE) {
                break;
            }

            //
            // Don't try to increment is object is being destroyed.
            //
            newCount = m_reference_count;
            if (newCount==0) {
                break;
            }

            //
            // Increment the count
            //
            if (InterlockedCompareExchange ((PLONG)&m_reference_count,
                                                    newCount+1,
                                                    newCount)==newCount) {
                return TRUE;
            }
            //
            // Try again, someone is executing in paraller with us.
            //
        }

    }
    __except (WS2_EXCEPTION_FILTER())
    {
    }
    return FALSE;
}




NSQUERY::~NSQUERY()
/*++

Routine Description:

    Destructor of the NSQUERY object.  The object should be destroyed only when
    either  (1)  the  reference count goes to 0, or (2) if the
    Initialize() member function fails.

Arguments:

    None

Return Value:

    None
--*/
{
    PLIST_ENTRY ListEntry;
    PNSPROVIDERSTATE Provider;

    //
    // Check if we were fully initialized.
    //
    if (m_signature != QUERYSIGNATURE) {
        return;
    }
    EnterCriticalSection(&m_members_guard);

    //
    // invalidate the signature since simply freeing the memory
    // may not do so. Any value will do, so the one used is arbitrary.
    //
    m_signature = ~QUERYSIGNATURE;

    while (!IsListEmpty(&m_provider_list))
    {
        ListEntry = RemoveHeadList(&m_provider_list);
        Provider = CONTAINING_RECORD( ListEntry,
                                      NSPROVIDERSTATE,
                                      m_query_linkage);
        delete(Provider);
    }
#ifdef RASAUTODIAL
    delete(m_query_set);
#endif // RASAUTODIAL
    DeleteCriticalSection(&m_members_guard);
}


//Structure used to carry context to CatalogEnumerationProc()
typedef struct _NSPENUMERATIONCONTEXT {
    LPWSAQUERYSETW lpqs;
    DWORD ErrorCode;
    PNSQUERY aNsQuery;
    PNSCATALOG  Catalog;
} NSPENUMERATIONCONTEXT, * PNSPENUMERATIONCONTEXT;

BOOL
LookupBeginEnumerationProc(
    IN PVOID Passback,
    IN PNSCATALOGENTRY  CatalogEntry
    )
/*++

Routine Description:

    The enumeration procedure for LookupBegin. Inspects each catalog item to
    see if it matches the selection criteria the query, if so adds the provider
    associated with the item to the list of providers involved in the query.

Arguments:

    PassBack - A context value passed to EunerateCatalogItems. It is really a
               pointer to a NSPENUMERATIONCONTEXT struct.

    CatalogItem - A pointer to a catalog item to be inspected.


Return Value:

    True
--*/
{
    PNSPENUMERATIONCONTEXT Context;
    DWORD NamespaceId;
    PNSPROVIDER Provider;
    PNSQUERY aNsQuery;
    BOOL Continue=TRUE;

    Context = (PNSPENUMERATIONCONTEXT)Passback;
    NamespaceId = CatalogEntry->GetNamespaceId();
    aNsQuery = Context->aNsQuery;

    __try { // we are holding catalog lock, make sure we won't av
            // because of bogus parameters and leave it locked.
        if ((((Context->lpqs->dwNameSpace == NamespaceId)
                        ||
            (Context->lpqs->dwNameSpace == NS_ALL))
                        &&
            (!Context->lpqs->dwNumberOfProtocols
                        ||
             MatchProtocols(NamespaceId,
                            CatalogEntry->GetAddressFamily(),
                            Context->lpqs)))
                        &&
            CatalogEntry->GetEnabledState())
        {
            Provider = CatalogEntry->GetProvider();
            if (Provider==NULL) {
                // Try to load provider
                INT ErrorCode;
                ErrorCode = Context->Catalog->LoadProvider (CatalogEntry);
                if (ErrorCode!=ERROR_SUCCESS) {
                    // no error if the provider won't load.
                    return TRUE;
                }
                Provider = CatalogEntry->GetProvider();
                assert (Provider!=NULL);
            }

            if (!aNsQuery->AddProvider(Provider)){
                Context->ErrorCode = WSASYSCALLFAILURE;
                Continue = FALSE;
            } //if
        } //if
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        Continue = FALSE;
        Context->ErrorCode = WSAEFAULT;
    }
    return(Continue);
}


INT
WINAPI
NSQUERY::LookupServiceBegin(
    IN  LPWSAQUERYSETW      lpqsRestrictions,
    IN  DWORD              dwControlFlags,
    IN PNSCATALOG          NsCatalog
    )
/*++

Routine Description:

   Complete the initialization of a NSQUERY object and call
   NSPLookupServiceBegin() for all service providers refereneced by the query.

Arguments:

    NsCatalog - Supplies  a  reference  to  the  name-space catalog object from
                which providers may be selected.

Return Value:

--*/
{
    INT ReturnCode = NO_ERROR;
    INT ErrorCode;
    PNSCATALOGENTRY  ProviderEntry;
    PNSPROVIDERSTATE Provider;
    PLIST_ENTRY      ListEntry;
    WSASERVICECLASSINFOW ClassInfo;
    LPWSASERVICECLASSINFOW ClassInfoBuf=NULL;
    DWORD                  ClassInfoSize=0;
    DWORD                  dwTempOutputFlags =
                               lpqsRestrictions->dwOutputFlags;
    LPWSTR                 lpszTempComment =
                               lpqsRestrictions->lpszComment;
    DWORD                  dwTempNumberCsAddrs =
                               lpqsRestrictions->dwNumberOfCsAddrs;
    PCSADDR_INFO           lpTempCsaBuffer =
                               lpqsRestrictions->lpcsaBuffer;

    // Select the service provider(s) that will be used for this query. A
    // service provider is selected using the provider GUID or the namespace ID
    // the namespace ID may be a specific namespace i.e. NS_DNS or NS_ALL for
    // all installed namespaces.

    //
    // Make sure that the ignored fields are cleared so that the
    // CopyQuerySetW function call below doesn't AV.
    //
    // This was a fix for bug #91655
    //
    lpqsRestrictions->dwOutputFlags = 0;
    lpqsRestrictions->lpszComment = NULL;
    lpqsRestrictions->dwNumberOfCsAddrs = 0;
    lpqsRestrictions->lpcsaBuffer = NULL;

#ifdef RASAUTODIAL
    //
    // Save the original parameters of the query, in
    // case we have to restart it due to an autodial
    // attempt.
    //
    if (m_restartable) {
        ErrorCode = CopyQuerySetW(lpqsRestrictions, &m_query_set);
        if (ErrorCode != ERROR_SUCCESS) {
            ReturnCode = SOCKET_ERROR;
            m_restartable = FALSE;
        }
        m_control_flags = dwControlFlags;
        m_catalog = NsCatalog;
    }
#endif // RASAUTODIAL

    if (ReturnCode==NO_ERROR) 
    {
        if (lpqsRestrictions->lpNSProviderId)
        {
            // Use a single namespace provider
            ReturnCode = NsCatalog->GetCountedCatalogItemFromProviderId(
                lpqsRestrictions->lpNSProviderId,
                &ProviderEntry);
            if (ReturnCode==NO_ERROR){
                if (!AddProvider(ProviderEntry->GetProvider())) {
                    ErrorCode = WSA_NOT_ENOUGH_MEMORY;
                    ReturnCode = SOCKET_ERROR;
                }
            }
            else {
                ErrorCode = WSAEINVAL;
                ReturnCode = SOCKET_ERROR;
            } //if
        } //if
        else{
            NSPENUMERATIONCONTEXT Context;
    
            Context.lpqs = lpqsRestrictions;
            Context.ErrorCode = NO_ERROR;
            Context.aNsQuery = this;
            Context.Catalog = NsCatalog;
    
            NsCatalog->EnumerateCatalogItems(
                LookupBeginEnumerationProc,
                &Context);
            if (Context.ErrorCode!=NO_ERROR){
                ErrorCode = Context.ErrorCode;
                ReturnCode = SOCKET_ERROR;
            } //if
        } //else
    } //if


    if (ReturnCode==NO_ERROR){
         //Get the class information for this query. Call once with a zero
         //buffer to size the buffer we need to allocate then call to get the
         //real answer
        ClassInfo.lpServiceClassId = lpqsRestrictions->lpServiceClassId;

        ReturnCode = NsCatalog->GetServiceClassInfo(
            &ClassInfoSize,
            &ClassInfo);

        if (ReturnCode!=NO_ERROR) {
            ErrorCode = GetLastError ();
            if (ErrorCode==WSAEFAULT){

                ClassInfoBuf = (LPWSASERVICECLASSINFOW)new BYTE[ClassInfoSize];

                if (ClassInfoBuf){
                    ReturnCode = NsCatalog->GetServiceClassInfo(
                        &ClassInfoSize,
                        ClassInfoBuf);
                    if (ReturnCode!=NO_ERROR) {
                        ErrorCode = GetLastError ();
                    }
                } //if
                else{
                    ErrorCode = WSA_NOT_ENOUGH_MEMORY;
                    ReturnCode = SOCKET_ERROR;
                } //else
            }//if
            else {
                // Ignore other error codes.
                ReturnCode = NO_ERROR;
            }
        } //if
    } //if

    if( ReturnCode==NO_ERROR && IsListEmpty( &m_provider_list ) ) {
        ErrorCode = WSASERVICE_NOT_FOUND;
        ReturnCode = SOCKET_ERROR;
    }

    if (ReturnCode==NO_ERROR){
        INT ReturnCode1;

        ReturnCode = SOCKET_ERROR;  // Assume all providers fail.
        //Call Begin on all the selected providers
        ListEntry = m_provider_list.Flink;
        Provider = CONTAINING_RECORD( ListEntry,
                                      NSPROVIDERSTATE,
                                      m_query_linkage);
        do {
            ReturnCode1 = Provider->LookupServiceBegin(lpqsRestrictions,
                                         ClassInfoBuf,
                                         dwControlFlags);
            if(ReturnCode1 == SOCKET_ERROR)
            {
                //
                // this provider didn't like it. So remove it
                // from the list
                //

                PNSPROVIDERSTATE Provider1;
                ErrorCode = GetLastError ();

                Provider1 = Provider;
                Provider = NextProvider(Provider);
                RemoveEntryList(&Provider1->m_query_linkage);
                delete(Provider1);
            }
            else
            {
                ReturnCode = ERROR_SUCCESS;// Record that at least one
                                           // provider succeeded.
                Provider = NextProvider(Provider);
            }
        } while (Provider);
    } //if

    if (ReturnCode == NO_ERROR){
        ListEntry = m_provider_list.Flink;
        m_current_provider = CONTAINING_RECORD( ListEntry,
                                      NSPROVIDERSTATE,
                                      m_query_linkage);
    } //if
    else{
        // We failed somewhere along the way so clean up the provider on the
        // provider list.
        while (!IsListEmpty(&m_provider_list)){
            ListEntry = RemoveHeadList(&m_provider_list);
            Provider = CONTAINING_RECORD( ListEntry,
                                          NSPROVIDERSTATE,
                                          m_query_linkage);
            delete(Provider);
        } //while
        if (ClassInfoBuf){
            delete ClassInfoBuf;
        } //if
        // Set error after all is done so it is not overwritten
        // accidentally.
        SetLastError (ErrorCode);
    } //else

    //
    // Restore ignored field values to what callee had set.
    //
    lpqsRestrictions->dwOutputFlags = dwTempOutputFlags;
    lpqsRestrictions->lpszComment = lpszTempComment;
    lpqsRestrictions->dwNumberOfCsAddrs = dwTempNumberCsAddrs;
    lpqsRestrictions->lpcsaBuffer = lpTempCsaBuffer;

    return(ReturnCode);
}

// *** Fill in description from the spec when it stabilizes.



INT
WINAPI
NSQUERY::LookupServiceNext(
    IN     DWORD           dwControlFlags,
    IN OUT LPDWORD         lpdwBufferLength,
    IN OUT LPWSAQUERYSETW  lpqsResults
    )
/*++

Routine Description:

    //***TODO Fill in description from the spec when it stabilizes.

Arguments:


Return Value:

--*/
{
    INT ReturnCode = SOCKET_ERROR;
    PNSPROVIDERSTATE NewProvider = NULL;
    PNSPROVIDERSTATE ThisProvider;

    if (!m_shutting_down) {

        EnterCriticalSection(&m_members_guard);

        NewProvider = m_current_provider;

        if (!NewProvider) {

            if (m_change_ioctl_succeeded) {

                //
                // Push the ioctl provider to the end of the list and reset
                // the current provider pointer to it to make it possible to
                // continue calling LookupServiceNext after a change notification.
                //
                PNSPROVIDERSTATE tmp =
                    CONTAINING_RECORD(m_provider_list.Blink,
                                      NSPROVIDERSTATE,
                                      m_query_linkage);

                while ((tmp != NULL) && !tmp->SupportsIoctl())
                    tmp = PreviousProvider(tmp);

                if (tmp == NULL) {
                    LeaveCriticalSection(&m_members_guard);
                    SetLastError(WSA_E_NO_MORE);
                    return (SOCKET_ERROR);
                }

                RemoveEntryList(&tmp->m_query_linkage);
                InsertTailList(&m_provider_list, &tmp->m_query_linkage);

                NewProvider = m_current_provider = tmp;

            } else {
                LeaveCriticalSection(&m_members_guard);
                SetLastError(WSA_E_NO_MORE);
                return (SOCKET_ERROR);
            }
        }

        LeaveCriticalSection(&m_members_guard);

        while (NewProvider) {
            ReturnCode = NewProvider->LookupServiceNext(
                dwControlFlags,
                lpdwBufferLength,
                lpqsResults);
            if ((ERROR_SUCCESS == ReturnCode)
                        ||
                (WSAEFAULT == GetLastError()) )
            {
                break;
            } //if

            if (m_shutting_down)
                break;

            EnterCriticalSection(&m_members_guard);
            if (m_current_provider!=NULL) {
                ThisProvider = NewProvider;
                NewProvider = NextProvider (m_current_provider);
                if (ThisProvider==m_current_provider) {
                    m_current_provider = NewProvider;
                }
            }
            else {
                NewProvider = NULL;
            }

#ifdef RASAUTODIAL
            if (NewProvider == NULL &&
                m_restartable &&
                ReturnCode == SOCKET_ERROR &&
                !m_shutting_down)
            {
                PLIST_ENTRY ListEntry;
                DWORD errval;

                //
                // Save the error in case the Autodial
                // attempt fails.
                //
                errval = GetLastError();
                //
                // We only invoke Autodial once per query.
                //
                m_restartable = FALSE;
                if (WSAttemptAutodialName(m_query_set)) {
                    //
                    // Because the providers have cached state
                    // about this query, we need to call
                    // LookupServiceEnd/LookupServiceBegin
                    // to reset them.
                    //

                    while (!IsListEmpty(&m_provider_list)){
                        ListEntry = RemoveHeadList(&m_provider_list);
        
                        ThisProvider = CONTAINING_RECORD( ListEntry,
                                                      NSPROVIDERSTATE,
                                                      m_query_linkage);
                        ThisProvider->LookupServiceEnd();
                        delete(ThisProvider);

                    } //while
                    m_current_provider = NULL;

                    //
                    // Restart the query.
                    //
                    if (LookupServiceBegin(
                          m_query_set,
                          m_control_flags|LUP_FLUSHCACHE,
                          m_catalog) == ERROR_SUCCESS)
                    {
                        NewProvider = m_current_provider;
                        assert (NewProvider!=NULL);
                        m_current_provider = NextProvider (NewProvider);
                    }
                }
                else {
                    SetLastError(errval);
                }
            }
            LeaveCriticalSection (&m_members_guard);
#endif // RASAUTODIAL
        } //while
    }
    else {
        SetLastError(WSAECANCELLED);
    }

    return(ReturnCode);
}


INT
WINAPI
NSQUERY::Ioctl(
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion,
    IN  LPWSATHREADID    lpThreadId
    )
/*++

Routine Description:

Arguments:

Return Value:
--*/
{
    INT ReturnCode = SOCKET_ERROR;

    if (!m_shutting_down){

        //
        // Make sure there is at least one and only one namespace
        // in the query that supports this operation.
        //

        PNSPROVIDERSTATE provider = NULL;
        unsigned int numProviders = 0;
        PLIST_ENTRY ListEntry;

        EnterCriticalSection (&m_members_guard);
        ListEntry = m_provider_list.Flink;
        while (ListEntry != &m_provider_list) {
            PNSPROVIDERSTATE CurrentProvider =
                CONTAINING_RECORD(ListEntry, NSPROVIDERSTATE, m_query_linkage);
            if (CurrentProvider->SupportsIoctl()) {
                if (++numProviders > 1)
                    break;
                provider = CurrentProvider;
            }
            ListEntry = ListEntry->Flink;
        }
        LeaveCriticalSection (&m_members_guard);

        if (numProviders > 1) {
            SetLastError(WSAEINVAL);
            return (SOCKET_ERROR);
        }

        if (provider == NULL) {
            SetLastError(WSAEOPNOTSUPP);
            return (SOCKET_ERROR);
        }

        ReturnCode = provider->Ioctl(dwControlCode, lpvInBuffer, cbInBuffer,
                                     lpvOutBuffer, cbOutBuffer, lpcbBytesReturned,
                                     lpCompletion, lpThreadId);

        //
        // If the ioctl succeeds or is pending, when the change occurs we
        // want to reset the provider list to permit further calls to
        // LookupServiceNext.
        //
        if ((dwControlCode == SIO_NSP_NOTIFY_CHANGE) &&
            ((ReturnCode == NO_ERROR) ||
             ((ReturnCode == SOCKET_ERROR) && (GetLastError() == WSA_IO_PENDING)))) {
                int error = GetLastError();
                EnterCriticalSection(&m_members_guard);
                m_change_ioctl_succeeded = TRUE;
                LeaveCriticalSection(&m_members_guard);
                SetLastError(error);
        }

    } else {
        SetLastError(WSAECANCELLED);
    }

    return (ReturnCode);
}


INT
WINAPI
NSQUERY::LookupServiceEnd()
/*++

Routine Description:

    This routine ends a query by calling NSPlookupServiceEnd on all the
    providers associated with this query.

Arguments:

    NONE

Return Value:

    ERROR_SUCCESS
--*/
{
    PLIST_ENTRY ListEntry;
    PNSPROVIDERSTATE CurrentProvider;

    EnterCriticalSection (&m_members_guard);
    
    m_shutting_down = TRUE;

    ListEntry = m_provider_list.Flink;

    while (ListEntry != &m_provider_list){
        CurrentProvider = CONTAINING_RECORD( ListEntry,
                                              NSPROVIDERSTATE,
                                              m_query_linkage);
        CurrentProvider->LookupServiceEnd();

        ListEntry = ListEntry->Flink;
    } //while
    LeaveCriticalSection (&m_members_guard);

    return(ERROR_SUCCESS);
}



VOID
WINAPI
NSQUERY::Dereference()
/*++

Routine Description:

    This  function  determines  whether the NSQUERY object should be destroyed.
    This  function should be invoked after every call to LookupServiceNext() or
    LookupEnd().   If it returns TRUE, any concurrent operations have completed
    and the NSQUERY object should be destroyed.

Arguments:

    None

Return Value:

    TRUE  - The NSQUERY object should be destroyed.
    FALSE - The NSQUERY object should not be destroyed.
--*/
{
    if (InterlockedDecrement ((PLONG)&m_reference_count)==0) {
        delete this;
    }
}


PNSPROVIDERSTATE
NSQUERY::NextProvider(
    PNSPROVIDERSTATE Provider
    )
/*++

Routine Description:

    Retrieve the next provider object from the list of providers associated
    with this query.

Arguments:

    Provider - A pointer to a provider state object.

Return Value:

    A pointer to the next provider state object on the list of providers or
    NULL if no entries are present after Provider.

--*/
{
    PNSPROVIDERSTATE NewProvider=NULL;
    PLIST_ENTRY ListEntry;

    ListEntry = Provider->m_query_linkage.Flink;

    if (ListEntry != &m_provider_list){
        NewProvider = CONTAINING_RECORD( ListEntry,
                                         NSPROVIDERSTATE,
                                         m_query_linkage);
    } //if
    return(NewProvider);
}


PNSPROVIDERSTATE
NSQUERY::PreviousProvider(
    PNSPROVIDERSTATE Provider
    )
/*++

Routine Description:

    Retrieve the previous provider object from the list of providers associated
    with this query.

Arguments:

    Provider - A pointer to a provider state object.

Return Value:

    A pointer to the previous provider state object on the list of providers or
    NULL if no entries are present before Provider.

--*/
{
    PNSPROVIDERSTATE NewProvider=NULL;
    PLIST_ENTRY ListEntry;

    ListEntry = Provider->m_query_linkage.Blink;

    if (ListEntry != &m_provider_list){
        NewProvider = CONTAINING_RECORD( ListEntry,
                                         NSPROVIDERSTATE,
                                         m_query_linkage);
    } //if
    return(NewProvider);
}


BOOL
NSQUERY::AddProvider(
    PNSPROVIDER  pNamespaceProvider
    )
/*++

Routine Description:

    Adds a namespace provider to the list of provider(s) involed with this
    query. A NSPROVIDERSTATE object is created for the provider the provider
    object is attached to the state object and the state object is added to the
    provider list.

Arguments:

    pNamespaceProvider - A pointer to a namespace provider object to be added
                         to the list of providers.

Return Value:
    TRUE if the operation is successful else FALSE.

--*/
{
    BOOL ReturnCode = TRUE;
    PNSPROVIDERSTATE ProviderHolder;

    ProviderHolder = new NSPROVIDERSTATE;
    if (ProviderHolder){
        ProviderHolder->Initialize(pNamespaceProvider);
        InsertTailList(&m_provider_list,
                           &(ProviderHolder->m_query_linkage));
    } //if
    else{
        SetLastError(WSASYSCALLFAILURE);
        ReturnCode = FALSE;
    } //else
    return(ReturnCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\recv.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    recv.cpp

Abstract:

    This module contains the data recption API functions for winsock2 DLL

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h. Reworked whole
        file. recv and recvform are now just calls to the WSA versions of the
        calls.

    dirk@mink.intel.com 21-Jul-1995
       Added warnoff.h to includes. Moved assignment statements
       outside of confditionals

    Mark Hamilton mark_hamilton@ccm.jf.intel.com 18-06-1995
       Implemented all of the functions.
--*/


#include "precomp.h"


int WSAAPI
recv(
     IN SOCKET s,
     OUT char FAR * buf,
     IN int len,
     IN int flags
     )
/*++
Routine Description:

    Receive data from a socket.

Arguments:

    s     - A descriptor identifying a connected socket.

    buf   - A buffer for the incoming data.

    len   - The length of buf.

    flags - Specifies the way in which the call is made.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT             ErrorCode;
    PDSOCKET        Socket;
    PDTHREAD        Thread;


	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;
            DWORD           BytesReceived;
            WSABUF          Buffers;

            Buffers.len = len;
            Buffers.buf = buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecv(s,
                              &Buffers,
                              1,
                              &BytesReceived,
                              (LPDWORD)&flags,
                              NULL,                 // lpOverlapped
                              NULL,                 // lpCompletionRoutine
                              Thread->GetWahThreadID(),
                              &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS) {
                if ((flags & MSG_PARTIAL)==0) {
                    return (INT)BytesReceived;
                }
                ErrorCode = WSAEMSGSIZE;
            }

            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
recvfrom(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR *from,
    IN OUT int FAR * fromlen
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s       - A descriptor identifying a bound socket.

    buf     - A buffer for the incoming data.

    len     - The length of buf.

    flags   - Specifies the way in which the call is made.

    from    - An  optional  pointer  to  a  buffer  which  will hold the source
              address upon return.

    fromlen - An optional pointer to the size of the from buffer.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT                ErrorCode;
    PDSOCKET           Socket;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;
            DWORD           BytesReceived;
            WSABUF          Buffers;

            Buffers.len = len;
            Buffers.buf = buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecvFrom(s,
                                  &Buffers,
                                  1,
                                  &BytesReceived,
                                  (LPDWORD)&flags,
                                  from,
                                  fromlen,
                                  NULL,                 // lpOverlapped
                                  NULL,                 // lpCompletionRoutine
                                  Thread->GetWahThreadID(),
                                  &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS) {
                if ((flags & MSG_PARTIAL)==0) {
                    return (INT)BytesReceived;
                }
                ErrorCode = WSAEMSGSIZE;
            }

            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSARecv(
    IN SOCKET s,
    OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Receive data from a socket.

Arguments:

    s                    - A descriptor identifying a connected socket.

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call if the receive operation completes immediately.

    lpFlags              - A pointer to flags.

    lpOverlapped         - A  pointer to a WSAOVERLAPPED structure (ignored for
                           non-overlapped sockets).

    lpCompletionRoutine  - A  pointer to the completion routine called when the
                           receive  operation  has  been completed (ignored for
                           non-overlapped sockets).

Returns:

    If  no  error  occurs  and the receive operation has completed immediately,
    WSARecv() returns the number of bytes received.  If the connection has been
    closed,  it returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and
    the  specific  error  code  is  stored with SetErrorCode().  The error code
    WSA_IO_PENDING   indicates   that   the   overlapped   operation  has  been
    successfully  initiated  and  that  completion will be indicated at a later
    time.  Any other error code indicates that the overlapped operation was not
    successfully initiated and no completion indication will occur.

    If  the  MSG_INTERRUPT  flag  is  set,  the  meaning of the return value is
    changed.  A value of zero indicates success and is interpreted as described
    above.   Otherwise,  the return value will directly contain the appropriate
    error  code  as  shown  below.   Note that this is applicable only to Win16
    environments  and only for protocols that have the XP1_INTERRUPT bit set in
    the WSAPROTOCOL_INFO struct.

--*/
{
    INT                 ErrorCode;
    PDSOCKET            Socket;
    PDTHREAD            Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                 ReturnValue;
            PDPROVIDER          Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecv(s,
                              lpBuffers,
                              dwBufferCount,
                              lpNumberOfBytesRecvd,
                              lpFlags,
                              lpOverlapped,
                              lpCompletionRoutine,
                              Thread->GetWahThreadID(),
                              &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;

        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
WSARecvDisconnect(
    IN SOCKET s,
    OUT LPWSABUF lpInboundDisconnectData
    )
/*++
Routine Description:

    Terminate  reception  on  a socket, and retrieve the disconnect data if the
    socket is connection-oriented.

Arguments:

    s                       - A descriptor identifying a socket.

    lpInboundDisconnectData - A pointer to the incoming disconnect data.

Returns:

    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().

--*/

{
    INT                 ErrorCode;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                 ReturnValue;
            PDPROVIDER          Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecvDisconnect(
                s,
                lpInboundDisconnectData,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ERROR_SUCCESS;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}



int WSAAPI
WSARecvFrom(
    IN SOCKET s,
    OUT LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesRecvd,
    IN OUT LPDWORD lpFlags,
    OUT struct sockaddr FAR *  lpFrom,
    IN OUT LPINT lpFromlen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s                    - A descriptor identifying a socket

    lpBuffers            - A  pointer  to  an array of WSABUF structures.  Each
                           WSABUF  structure contains a pointer to a buffer and
                           the length of the buffer.

    dwBufferCount        - The  number  of  WSABUF  structures in the lpBuffers
                           array.

    lpNumberOfBytesRecvd - A  pointer  to  the number of bytes received by this
                           call if the receive operation completes immediately.

    lpFlags              - A pointer to flags.

    lpFrom               - An  optional pointer to a buffer which will hold the
                           source address upon the completion of the overlapped
                           operation.

    lpFromlen            - A  pointer  to the size of the from buffer, required
                           only if lpFrom is specified.

    lpOverlapped         - A  pointer to a WSAOVERLAPPED structure (ignored for
                           non- overlapped sockets).

    lpCompletionRoutine  - A  pointer to the completion routine called when the
                           receive  operation  has  been completed (ignored for
                           non-overlapped sockets).

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetErrorCode().

--*/

{
    INT                ErrorCode;
    PDSOCKET           Socket;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPRecvFrom(s,
                                  lpBuffers,
                                  dwBufferCount,
                                  lpNumberOfBytesRecvd,
                                  lpFlags,
                                  lpFrom,
                                  lpFromlen,
                                  lpOverlapped,
                                  lpCompletionRoutine,
                                  Thread->GetWahThreadID(),
                                  &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\perthrd.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    perthrd.c

Abstract:

    This module contains the winsock API functions that query and set
    per thread information contained in winsock DLL. The following
    functions are contained in this module.

    WSAGetLastError()
    WSASetLastError()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

[Environment:]

[Notes:]

Revision History:


--*/

#include "precomp.h"


int WSAAPI
WSAGetLastError(
    IN void
    )
/*++
Routine Description:

    Get the error status for the last operation which failed.

Arguments:

    NONE

Returns:
    The return value indicates the error code for the last failed WinSock
    routine performed by this thread.

--*/
{
    return(GetLastError());
}




void WSAAPI
WSASetLastError(
    IN int iError
    )
/*++
Routine Description:

    Set the error code which can be retrieved by WSAGetLastError().

Arguments:

    iError - Specifies the error code to be returned by a subsequent
             WSAGetLastError() call.

Returns:
    NONE

--*/
{
    SetLastError(iError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\precomp.h ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    precomp.h

Abstract:

    This file includes all the headers required to build winsock2.dll
    to ease the process of building a precompiled header.

Author:

Dirk Brandewie dirk@mink.intel.com  11-JUL-1995

Revision History:


--*/

#ifndef _PRECOMP_
#define _PRECOMP_


//
// Turn off "declspec" decoration of entrypoints defined in WINSOCK2.H.
//

#define WINSOCK_API_LINKAGE


#include "osdef.h"
#include "warnoff.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2spi.h>
#include <mswsock.h>
#include <sporder.h>
#include <windows.h>
#include <wtypes.h>
#include <stdio.h>
#include <tchar.h>
#include "trace.h"
#include "wsassert.h"
#include "scihlpr.h"
#include "nsprovid.h"
#include "nspstate.h"
#include "nscatent.h"
#include "nscatalo.h"
#include "nsquery.h"
#include "ws2help.h"
#include "dprovide.h"
#include "dsocket.h"
#include "dprocess.h"
#include "dthread.h"
#include "wsautil.h"
#include "dcatalog.h"
#include "dcatitem.h"
#include "startup.h"
#include "dt_dll.h"
#include "dthook.h"
#include "trycatch.h"
#include "getxbyy.h"
#include "qshelpr.h"
#ifdef RASAUTODIAL
#include "autodial.h"
#endif // RASAUTODIAL
#include "async.h"

#endif  // _PRECOMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\rnr.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    rnr.cpp

Abstract:

    This module contains the implementation of the Registration and
    Name Resolution API for the WinSock2 API

    This module contains the following functions. For functions whose function
    signature contains sting arguments both and ASCII and Wide charater version
    of the function are supplied

    WSAEnumNameSpaceProviders
    WSCEnumNameSpaceProviders
    WSALookupServiceBegin
    WSALookupServiceNext
    WSANSPIoctl
    WSALookupServiceEnd
    WSASetService
    WSAInstallServiceClass
    WSARemoveServiceClass
    WSAGetServiceClassNameByClassId

Author:

    Dirk Brandewie dirk@mink.intel.com  12-1-1995

[Environment:]

[Notes:]

Revision History:

    12-Dec-1995 dirk@mink.intel.com
        Initial Revision

--*/

#include "precomp.h"

typedef struct
{
    BOOL    AllProviders;
    LPDWORD RequiredBufferSize;
    DWORD   BufferSize;
    PBYTE   Buffer;
    PBYTE   BufferFreePtr;
    BOOL    Ansi;
    INT     NumItemsEnumerated;
    INT     ErrorCode;
} NSCATALOG_ENUMERATION_CONTEXT, * PNSCATALOG_ENUMERATION_CONTEXT;

//
// BONUSSIZE is a hack that is used  to bias the computed size
// when WSALookupServiceNextA gets a WSAEFAULT from the
// WSALookupServiceNextW call. It is the "maximum" padding
// that we might need. Note this assumes all values returned
// and a limit of 3 addresses. There is no way to know exactly
// what the makeup of the returned data will be, so this is
// a "best guess". The right fix is to redo the code to
// pack the result optimally, so no padding is needed.
//

#define BONUSSIZE (3 + 3 + 3 + (3 * 3))


BOOL
CalculateBufferSize(
    PVOID           PassBack,
    PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    This fuction calculates the size of buffer required to return the
    NAMESPACE_INFO structs for a call to WSAEnumNameSpaces(). This function is
    a callback function used as an argument to the name space catalog
    enumeration funtion

Arguments:

    PassBack - A context value passed thru the catalog enumeration
               function. This passback value is really a pointer to a
               NSCATALOG_ENUMERATION_CONTEXT.

    CatalogEntry - A pointer to the current name space catalog entry to be
                   inspected.
Return Value:

   TRUE, Signalling the catalog enumeration function should continue the
   enumeration.

--*/
{
    PNSCATALOG_ENUMERATION_CONTEXT Context;
    LPWSTR                         EntryDisplayString;

    Context = (PNSCATALOG_ENUMERATION_CONTEXT)PassBack;

    // Add the fixed length of the WSANAMESPACE_INFO struct
    *(Context->RequiredBufferSize) += sizeof(WSANAMESPACE_INFO);

    // Add room for the GUID
    *(Context->RequiredBufferSize) += sizeof(GUID);

    // Add room for the display string
    EntryDisplayString = CatalogEntry->GetProviderDisplayString();
    *(Context->RequiredBufferSize) += ((wcslen(EntryDisplayString)+1) *
                                           sizeof(WCHAR));
    return(TRUE); // Continue the enumeration
}


BOOL
CopyFixedPortionNameSpaceInfo(
    PVOID           PassBack,
    PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    This Funtion copies the fixed size elements of a NSCATALOGENTRY object into
    a user buffer for return from a call to WSAEnumNameSpaces(). It also
    increments the number of fixed size elements copied so far.

Arguments:

    PassBack - A context value passed thru the catalog enumeration
               function. This passback value is really a pointer to a
               NSCATALOG_ENUMERATION_CONTEXT.

    CatalogEntry - A pointer to the current name space catalog entry to be
                   inspected.

Return Value:

  TRUE, Signalling the catalog enumeration function should continue the
   enumeration.

--*/
{
    PNSCATALOG_ENUMERATION_CONTEXT Context;
    LPWSANAMESPACE_INFOW CurrentNSInfo;

    Context =  (PNSCATALOG_ENUMERATION_CONTEXT)PassBack;

    CurrentNSInfo = (LPWSANAMESPACE_INFOW)Context->BufferFreePtr;
    __try {
        CurrentNSInfo->dwNameSpace  = CatalogEntry->GetNamespaceId();
        CurrentNSInfo->fActive      = CatalogEntry->GetEnabledState();
        CurrentNSInfo->dwVersion    = CatalogEntry->GetVersion();
        CurrentNSInfo->NSProviderId = *(CatalogEntry->GetProviderId());
        Context->BufferFreePtr += sizeof(WSANAMESPACE_INFO);
        Context->NumItemsEnumerated++;
        return(TRUE); // Continue the enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return(FALSE);
   }
}


BOOL
CopyVariablePortionNameSpaceInfo(
    PVOID           PassBack,
    PNSCATALOGENTRY CatalogEntry
    )
/*++

Routine Description:

    This Funtion copies the variable size elements of a NSCATALOGENTRY object
    into a user buffer for return from a call to WSAEnumNameSpaces().

Arguments:

    PassBack - A context value passed thru the catalog enumeration
               function. This passback value is really a pointer to a
               NSCATALOG_ENUMERATION_CONTEXT.

    CatalogEntry - A pointer to the current name space catalog entry to be
                   inspected.

Return Value:

    TRUE, Signalling the catalog enumeration function should continue the
    enumeration.

--*/
{
    PNSCATALOG_ENUMERATION_CONTEXT Context;
    LPWSANAMESPACE_INFOW CurrentNSInfo;
    LPWSTR DisplayString;
    INT    StringLength;

    Context =  (PNSCATALOG_ENUMERATION_CONTEXT)PassBack;

    CurrentNSInfo = (LPWSANAMESPACE_INFOW)Context->Buffer;

    // Copy over the display string
    DisplayString = CatalogEntry->GetProviderDisplayString();
    StringLength = ((wcslen(DisplayString)+1) * sizeof(WCHAR));

    CurrentNSInfo->lpszIdentifier = (LPWSTR)Context->BufferFreePtr;
    __try {
        if (Context->Ansi){
            WideCharToMultiByte(
                     CP_ACP,                                   // CodePage (ANSI)
                     0,                                        // dwFlags
                     DisplayString,                            // lpWideCharStr
                     -1,                                       // cchWideChar
                     (char*)CurrentNSInfo->lpszIdentifier,     // lpMultiByteStr
                     StringLength,                             // cchMultiByte
                     NULL,                                     // lpDefaultChar
                     NULL                                      // lpUsedDefaultChar
                     );
            Context->BufferFreePtr += lstrlen(
                (LPSTR)CurrentNSInfo->lpszIdentifier)+1;
        } //if
        else{
            memcpy(CurrentNSInfo->lpszIdentifier,
                   DisplayString,
                   StringLength);
            Context->BufferFreePtr += StringLength;

        } //else

        // point to the next struct
        Context->Buffer += sizeof(WSANAMESPACE_INFO);
        return(TRUE); // Continue the enumeration
    }
    __except (WS2_EXCEPTION_FILTER()) {
        Context->ErrorCode = WSAEFAULT;
        return FALSE;
    }
}


INT
WSAAPI
EnumNameSpaceProviders(
    IN      PNSCATALOG              Catalog,
    IN      BOOL                    Ansi,
    IN OUT  PDWORD                  BufferLength,
    IN OUT  LPWSANAMESPACE_INFOW    Buffer,
    OUT     PDWORD                  ErrorCode
    )
/*++

Routine Description:

    This Function is used by WSAEnumNameSpaceProvidersA and
    WSAEnumNameSpaceProvidersW to fill in the user buffer with the information
    about each name spcae provider install on the system.

Arguments:

    Catalog - A pointer to a NSCATALOG object containing the requested
              information.

    Ansi - A boolean value marking whether the user requested the ansi or
           unicode version of the WSANAMESPACE_INFO struct should be returned.

    BufferLength - The size of the user buffer in bytes.

    Buffer - A pointer to the user buffer.

    ErrorCode - A pointer to a DWORD to contain the error return from this
                function.

Return Value:

    If the function is successful it returns the number of name space providers
    enumerated.   Otherwise it returns SOCKET_ERROR.  If the user buffer is too
    small  to  contain  all  the  the WSANAMESPACE_INFO structs SOCKET_ERROR is
    returned,  the  error code is set to WSAEFAULT, and BufferLength is updated
    to  reflect  the  size  of  buffer  required  to  hold  all  the  requested
    information.
--*/
{
    INT        ReturnCode;
    DWORD      RequiredBufferSize;

    // Setup for early return
    ReturnCode = SOCKET_ERROR;
    *ErrorCode = WSAEFAULT;

    // Find out if the user handed in a big enough buffer
    RequiredBufferSize = 0;
    NSCATALOG_ENUMERATION_CONTEXT Context;

    Context.RequiredBufferSize = &RequiredBufferSize;
    Catalog->EnumerateCatalogItems(
                    CalculateBufferSize,
                    & Context );

    __try
    {
        if ( Buffer!=NULL && RequiredBufferSize <= *BufferLength )
        {
            Context.BufferSize = *BufferLength;
        }
        else
        {
            // Error code is set above
            *BufferLength = RequiredBufferSize;
            return (ReturnCode);
        }
    }
    __except( WS2_EXCEPTION_FILTER() )
    {
        // Everything is set
        return (ReturnCode);
    }

    Context.Buffer = (PBYTE)Buffer;
    Context.BufferFreePtr = (PBYTE)Buffer;
    Context.Ansi = Ansi;
    Context.NumItemsEnumerated = 0;
    Context.ErrorCode = ERROR_SUCCESS;

    //Copy over the fixed part of the WSANAMESPACE_INFO struct(s) into the
    //user buffer
    Catalog->EnumerateCatalogItems(
                    CopyFixedPortionNameSpaceInfo,
                    & Context );

    if ( Context.ErrorCode==ERROR_SUCCESS ) {
        //Copy over the variable part of the WSANAMESPACE_INFO struct(s) into
        //the user buffer
         Catalog->EnumerateCatalogItems(
                        CopyVariablePortionNameSpaceInfo,
                        & Context );
        if (Context.ErrorCode==ERROR_SUCCESS) {
            ReturnCode = Context.NumItemsEnumerated;
        }
        else {
            *ErrorCode = Context.ErrorCode;
        }
    }
    else
        *ErrorCode = Context.ErrorCode;

    return(ReturnCode);
}


INT
WSAAPI
WSAEnumNameSpaceProvidersA(
    IN OUT  PDWORD                  lpdwBufferLength,
    IN OUT  LPWSANAMESPACE_INFOA    lpnspBuffer
    )
/*++

Routine Description:

    Retrieve information about available name spaces.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpnspBuffer.  On output (if the API fails,
                       and the error is  WSAEFAULT), the minimum number of
                       bytes to pass for the lpnspBuffer to retrieve all the
                       requested information. The passed-in buffer must be
                       sufficient to hold all of the name space information.

    lpnspBuffer - A buffer which is filled with WSANAMESPACE_INFO structures
                  described below.  The returned structures are located
                  consecutively at the head of the buffer. Variable sized
                  information referenced by pointers in the structures point to
                  locations within the buffer located between the end of the
                  fixed sized structures and the end of the buffer.  The number
                  of structures filled in is the return value of
                  WSAEnumNameSpaceProviders().

Return Value:

    WSAEnumNameSpaceProviders() returns the number of WSANAMESPACE_INFO
    structures copied into lpnspBuffer. Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/
{
    INT        ReturnValue;
    PDPROCESS  Process;
    PDTHREAD   Thread;
    INT        ErrorCode;
    PNSCATALOG Catalog;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if


    Catalog = Process->GetNamespaceCatalog();

    ReturnValue = EnumNameSpaceProviders(
        Catalog,
        TRUE,    // Ansi
        lpdwBufferLength,
        (LPWSANAMESPACE_INFOW)lpnspBuffer,
        (LPDWORD)&ErrorCode);

    // If there was an error set this threads lasterror
    if (SOCKET_ERROR == ReturnValue ) {
        SetLastError(ErrorCode);
    } //if
    return(ReturnValue);
}

INT
WSAAPI
WSAEnumNameSpaceProvidersW(
    IN OUT  PDWORD                  lpdwBufferLength,
    IN OUT  LPWSANAMESPACE_INFOW    lpnspBuffer
    )
/*++

Routine Description:

    Retrieve information about available name spaces.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpnspBuffer.  On output (if the API fails,
                       and the error is  WSAEFAULT), the minimum number of
                       bytes to pass for the lpnspBuffer to retrieve all the
                       requested information. The passed-in buffer must be
                       sufficient to hold all of the name space information.

    lpnspBuffer - A buffer which is filled with WSANAMESPACE_INFO structures
                  described below.  The returned structures are located
                  consecutively at the head of the buffer. Variable sized
                  information referenced by pointers in the structures point to
                  locations within the buffer located between the end of the
                  fixed sized structures and the end of the buffer.  The number
                  of structures filled in is the return value of
                  WSAEnumNameSpaceProviders().

Return Value:

    WSAEnumNameSpaceProviders() returns the number of WSANAMESPACE_INFO
    structures copied into lpnspBuffer. Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/
{
    INT        ReturnValue;
    PDPROCESS  Process;
    PDTHREAD   Thread;
    INT        ErrorCode;
    PNSCATALOG Catalog;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();

    ReturnValue = EnumNameSpaceProviders(
        Catalog,
        FALSE,    //Unicode
        lpdwBufferLength,
        lpnspBuffer,
        (LPDWORD)&ErrorCode);

    // If there was an error set this threads lasterror
    if (SOCKET_ERROR == ReturnValue ) {
        SetLastError(ErrorCode);
    } //if
    return(ReturnValue);
}


#ifdef _WIN64
INT
WSAAPI
WSCEnumNameSpaceProviders32(
    IN OUT  LPDWORD                 lpdwBufferLength,
    IN OUT  LPWSANAMESPACE_INFOW    lpnspBuffer
    )
/*++

Routine Description:

    Retrieve information about available name spaces.

Arguments:

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed to by lpnspBuffer.  On output (if the API fails,
                       and the error is  WSAEFAULT), the minimum number of
                       bytes to pass for the lpnspBuffer to retrieve all the
                       requested information. The passed-in buffer must be
                       sufficient to hold all of the name space information.

    lpnspBuffer - A buffer which is filled with WSANAMESPACE_INFO structures
                  described below.  The returned structures are located
                  consecutively at the head of the buffer. Variable sized
                  information referenced by pointers in the structures point to
                  locations within the buffer located between the end of the
                  fixed sized structures and the end of the buffer.  The number
                  of structures filled in is the return value of
                  WSAEnumNameSpaceProviders().

Return Value:

    WSAEnumNameSpaceProviders() returns the number of WSANAMESPACE_INFO
    structures copied into lpnspBuffer. Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().

--*/
{
    INT         ReturnValue=SOCKET_ERROR;
    INT         ErrorCode;
    PNSCATALOG  Catalog = NULL;
    HKEY        registry_root;


    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        ErrorCode = WSANO_RECOVERY;
        goto Exit;
    }

    //
    // Build the protocol catalog
    //
    Catalog = new(NSCATALOG);

    if (Catalog!=NULL) {
        
        ErrorCode = Catalog->InitializeFromRegistry32(
                            registry_root
                            );
    }
    else {
        ErrorCode = WSA_NOT_ENOUGH_MEMORY;
        DEBUGF(
            DBG_ERR,
            ("Allocating dcatalog object\n"));
    }


    {
        LONG close_result;
        close_result = RegCloseKey(
            registry_root);  // hkey
        assert(close_result == ERROR_SUCCESS);
    }


    if (ErrorCode==ERROR_SUCCESS) {
        ReturnValue = EnumNameSpaceProviders(
            Catalog,
            FALSE,    //Unicode
            lpdwBufferLength,
            lpnspBuffer,
            (LPDWORD)&ErrorCode);
    }

Exit:
    if (Catalog!=NULL) {
        delete Catalog;
    }

    // If there was an error set this threads lasterror
    if (SOCKET_ERROR == ReturnValue ) {
        SetLastError(ErrorCode);
    } //if
    return(ReturnValue);
}
#endif


INT
WSAAPI
WSALookupServiceBeginA(
    IN      LPWSAQUERYSETA  lpqsRestrictions,
    IN      DWORD           dwControlFlags,
    OUT     LPHANDLE        lphLookup
    )
/*++

Routine Description:

    WSALookupServiceBegin() is used to initiate a client query that is
    constrained by the information contained within a WSAQUERYSET
    structure. WSALookupServiceBegin() only returns a handle, which should be
    used by subsequent calls to WSALookupServiceNext() to get the actual
    results.

Arguments:

    lpqsRestrictions - contains the search criteria.

    dwControlFlags - controls the depth of the search.

    lphLookup - Addr to receive handle to be used when calling WSALookupServiceNext
                in order to start retrieving the results set.

Returns:

    Zero if successful.
    SOCKET_ERROR on failure.  GetLastError() contains error code.

--*/
{
    INT             returnCode;
    PWSAQUERYSETW   UniCodeBuffer = NULL;
    DWORD           UniCodeBufferSize;

    //
    //  Verify that pointer is valid (lphLookup verified in XxxW func)
    //

    if ( IsBadReadPtr( lpqsRestrictions, sizeof(*lpqsRestrictions)) )
    {
        returnCode = WSAEFAULT;
        goto Done;
    }

    //
    // The Winsock spec says that these are ignored fields, clear them
    // so that they don't cause a problem in the Ansi to Unicode copy
    // routines - NT bug #91655
    //

    lpqsRestrictions->dwOutputFlags = 0;
    lpqsRestrictions->lpszComment = NULL;
    lpqsRestrictions->dwNumberOfCsAddrs = 0;
    lpqsRestrictions->lpcsaBuffer;

    //
    //  determine size of unicode buffer
    //

    UniCodeBufferSize = 0;

    returnCode = MapAnsiQuerySetToUnicode(
                    lpqsRestrictions,
                    & UniCodeBufferSize,
                    UniCodeBuffer );

    if ( WSAEFAULT != returnCode )
    {
        goto Done;
    }

    //
    //  copy input buffer to unicode
    //

    UniCodeBuffer = (LPWSAQUERYSETW)new BYTE[UniCodeBufferSize];
    if ( !UniCodeBuffer )
    {
        goto Done;
    }

    returnCode = MapAnsiQuerySetToUnicode(
                        lpqsRestrictions,
                        &UniCodeBufferSize,
                        UniCodeBuffer );

    if ( ERROR_SUCCESS != returnCode )
    {
        goto Done;
    }

    //
    //  call unicode version
    //

    returnCode = WSALookupServiceBeginW(
                    UniCodeBuffer,
                    dwControlFlags,
                    lphLookup );

    
Done:

    if ( UniCodeBuffer )
    {
        delete( UniCodeBuffer );
    }

    //
    //  on error, set last error and return SOCKET_ERROR
    //      - WSALookupServiceBeginW() will already have
    //      set error and returned SOCKET_ERROR

    if ( returnCode &&
         returnCode != SOCKET_ERROR )
    {
        SetLastError( returnCode );
        returnCode = SOCKET_ERROR;
    }

    return( returnCode );
}


INT
WSAAPI
WSALookupServiceBeginW(
    IN      LPWSAQUERYSETW  lpqsRestrictions,
    IN      DWORD           dwControlFlags,
    OUT     LPHANDLE        lphLookup
    )
/*++

Routine Description:

    WSALookupServiceBegin() is used to initiate a client query that is
    constrained by the information contained within a WSAQUERYSET
    structure. WSALookupServiceBegin() only returns a handle, which should be
    used by subsequent calls to WSALookupServiceNext() to get the actual
    results.

Arguments:

    lpqsRestrictions - contains the search criteria.

    dwControlFlags - controls the depth of the search.

    lphLookup - A pointer Handle to be used when calling WSALookupServiceNext
                in order to start retrieving the results set.

Returns:

    Zero if successful.
    SOCKET_ERROR on failure.  GetLastError() contains error code.

--*/
{
    PDPROCESS   Process;
    PDTHREAD    Thread;
    INT         errorCode;
    PNSQUERY    Query = NULL;


    errorCode = PROLOG( &Process, &Thread );

    if ( errorCode != ERROR_SUCCESS )
    {
        goto Done;
    }

    //
    //  verify that pointers are valid
    //

    if ( IsBadWritePtr( lphLookup, sizeof(*lphLookup) ) ||
         IsBadReadPtr( lpqsRestrictions, sizeof(*lpqsRestrictions) ) )
    {
        errorCode = WSAEFAULT;
        goto Done;
    }

    //
    //  Make sure we've got a current name space catalog
    //

    Query = new NSQUERY;
    if ( !Query )
    {
        errorCode = WSAENOBUFS;
        goto Done;
    }

    errorCode = Query->Initialize();
    if ( errorCode != NO_ERROR )
    {
        delete Query;
        goto Done;
    }

    //
    //  call provider
    //      - if successful save NSQUERY as context handle
    //      - if fails recover error code so not reset when
    //          dump NSQUERY
    //      


    errorCode = Query->LookupServiceBegin(
                            lpqsRestrictions,
                            dwControlFlags,
                            Process->GetNamespaceCatalog() );

    if ( ERROR_SUCCESS == errorCode )
    {
        *lphLookup = (LPHANDLE)Query;
    }
    else
    {
        *lphLookup = NULL;
        errorCode = GetLastError();
        delete Query;
    }

Done:

    //
    //  on error, set last error and return SOCKET_ERROR
    //

    if ( errorCode &&
         errorCode != SOCKET_ERROR )
    {
        SetLastError( errorCode );
        errorCode = SOCKET_ERROR;
    }

    return( errorCode );
}


INT
WSAAPI
WSALookupServiceNextA(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlFlags,
    IN OUT  LPDWORD         lpdwBufferLength,
    OUT     LPWSAQUERYSETA  lpqsResults
    )
/*++

Routine Description:

    WSALookupServiceNext() is called after obtaining a Handle from a previous
    call to WSALookupSefrviceBegin() in order to retrieve the requested service
    information.  The provider will pass back a WSAQUERYSET structure in the
    lpqsResults buffer.  The client should continue to call this API until it
    returns WSA_E_NOMORE, indicating that all of the WSAQUERYSET have been
    returned.

Arguments:

    hLookup - A Handle returned from the previous call to
              WSALookupServiceBegin().

    dwControlFlags - Flags to control the next operation.  This is currently
                     used to indicate to the provider what to do if the result
                     set is too big for the buffer.  If on the previous call to
                     WSALookupServiceNext() the result set was too large for
                     the buffer, the application can choose to do one of two
                     things on this call.  First, it can choose to pass a
                     bigger buffer and try again.  Second, if it cannot or is
                     unwilling to allocate a larger buffer, it can pass
                     LUP_FLUSHPREVIOUS to tell the provider to throw away the
                     last result set - which was too large - and move on to the
                     next set for this call.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpresResults.  On output - if the API
                       fails, and the error is WSAEFAULT, then it contains the
                       minimum number of bytes to pass for the lpqsResults to
                       retrieve the record.

    lpqsResults - a pointer to a block of memory, which will contain one result
                  set in a WSAQUERYSET structure on return.


Returns:

    Zero if successful.
    Otherwise the value SOCKET_ERROR is returned.

--*/
{
    INT            ReturnCode;
    DWORD          ErrorCode;
    LPWSAQUERYSETW UniCodeBuffer;
    DWORD          UniCodeBufferLength;

    //
    // Verify that pointers are valid
    //
    //  note:  this error is classic winsock WSAEFAULT,
    //      but unfortunately, WSAEFAULT was spec'd as the
    //      buffer-is-too-small error which is part of normal
    //      API operation;  to avoid overloading the EFAULT
    //      i'm switching this to WSAEINVAL (jamesg)
    //      

    if ( IsBadReadPtr( lpdwBufferLength, sizeof(*lpdwBufferLength) ) ||
         ( *lpdwBufferLength != 0  &&
           IsBadWritePtr( lpqsResults, *lpdwBufferLength ) ) )
    {
        SetLastError( WSAEINVAL );
        return SOCKET_ERROR;
    }

    // Find how big a buffer we need to allocate. Base first guess on the
    // user's provided buffer. The alogirthm is as follows:
    // If the user supplied a buffer, allocate a buffer of size
    // (user buffer - sizeof(WSAQUERYSET) * sizeof(WCHAR). This
    //  is guaranteed to hold the data that could be held in
    // the user's buffer.

    UniCodeBufferLength = *lpdwBufferLength;
    if( UniCodeBufferLength >= sizeof(WSAQUERYSETW) )
    {
        // Assume all space, except the defined structure, is to
        // be string space. So scale it by the size of a UNICODE
        // character. It won't be that bad, but this seems "safe".
        //
        // UniCodeBufferLength = 
                              // This calculation doesn't work out
                              // correctly. Just use the size that the caller
                              // is trying to use.
                              // (UniCodeBufferLength * sizeof(WCHAR)) -
                              //    sizeof(WSAQUERYSETW);
        UniCodeBuffer = (LPWSAQUERYSETW) new BYTE[UniCodeBufferLength];
        if(!UniCodeBuffer)
        {
            UniCodeBufferLength = 0;        // memory allocation failure
        }
    }
    else
    {
        UniCodeBuffer = NULL;
        UniCodeBufferLength = 0;
    }

    ReturnCode = WSALookupServiceNextW(
                    hLookup,
                    dwControlFlags,
                    &UniCodeBufferLength,
                    UniCodeBuffer );

    //
    // if the call did not supply a buffer, the user does have a buffer,
    // and it the call failed, do it again. This should never happen,
    // and if it does things are very odd, but account for it nonetheless.
    //

    if ( !UniCodeBuffer
              &&
         (*lpdwBufferLength >= sizeof(WSAQUERYSET))
              &&
         (ReturnCode == SOCKET_ERROR) )
    {
        ErrorCode = GetLastError();
        if (WSAEFAULT == ErrorCode)
        {
            //
            // delete old buffer, if any, and get a new buffer of the
            // proper size.
            //
            delete  (PBYTE)UniCodeBuffer;

            UniCodeBuffer = (LPWSAQUERYSETW) new BYTE[UniCodeBufferLength];

            //
            // if a buffer is allocated, call the provider again. Else,
            // return the EFAULT and the buffer size to the
            // caller to handle it.
            //
            if ( UniCodeBuffer )
            {
                ReturnCode = WSALookupServiceNextW(
                                hLookup,
                                dwControlFlags,
                                & UniCodeBufferLength,
                                UniCodeBuffer );
            }
        }
    }

    //
    // Either it worked, in which case UniCodeBuffer contains the results,
    // or it didn't work for one of the above branches.
    //
    if (ERROR_SUCCESS == ReturnCode)
    {
        ReturnCode = MapUnicodeQuerySetToAnsi(
                        UniCodeBuffer,
                        lpdwBufferLength,
                        lpqsResults);
        if ( ERROR_SUCCESS != ReturnCode )
        {
            SetLastError(ReturnCode);
            ReturnCode=SOCKET_ERROR;
        }
    }
    else
    {
        if ( GetLastError() == WSAEFAULT )
        {
            *lpdwBufferLength = UniCodeBufferLength + BONUSSIZE;
        }
    }

    if ( UniCodeBuffer != NULL )
    {
        delete (PBYTE)UniCodeBuffer;
    }
    return(ReturnCode);
}


INT
WSAAPI
WSALookupServiceNextW(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlFlags,
    IN OUT  LPDWORD         lpdwBufferLength,
    OUT     LPWSAQUERYSETW  lpqsResults
    )
/*++

Routine Description:

    WSALookupServiceNext() is called after obtaining a Handle from a previous
    call to WSALookupServiceBegin() in order to retrieve the requested service
    information.  The provider will pass back a WSAQUERYSET structure in the
    lpqsResults buffer.  The client should continue to call this API until it
    returns WSA_E_NOMORE, indicating that all of the WSAQUERYSET have been
    returned.

Arguments:

    hLookup - A Handle returned from the previous call to
              WSALookupServiceBegin().

    dwControlFlags - Flags to control the next operation.  This is currently
                     used to indicate to the provider what to do if the result
                     set is too big for the buffer.  If on the previous call to
                     WSALookupServiceNext() the result set was too large for
                     the buffer, the application can choose to do one of two
                     things on this call.  First, it can choose to pass a
                     bigger buffer and try again.  Second, if it cannot or is
                     unwilling to allocate a larger buffer, it can pass
                     LUP_FLUSHPREVIOUS to tell the provider to throw away the
                     last result set - which was too large - and move on to the
                     next set for this call.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpresResults.  On output - if the API
                       fails, and the error is WSAEFAULT, then it contains the
                       minimum number of bytes to pass for the lpqsResults to
                       retrieve the record.

    lpqsResults - a pointer to a block of memory, which will contain one result
                  set in a WSAQUERYSET structure on return.

Returns:

    Zero if successful.
    SOCKET_ERROR on failure.  GetLastError() contains error code.

--*/
{
    INT       ReturnValue;
    INT       ErrorCode;
    PNSQUERY  Query;

    ErrorCode = TURBO_PROLOG();
    if ( ErrorCode != ERROR_SUCCESS )
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    //
    // Verify that pointers are valid
    //

    if ( IsBadReadPtr(lpdwBufferLength, sizeof(*lpdwBufferLength) ) ||
         ( *lpdwBufferLength != 0  &&
           IsBadWritePtr(lpqsResults, *lpdwBufferLength) ) )
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    if ( !hLookup )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    Query = (PNSQUERY) hLookup;

    if ( !Query->ValidateAndReference() )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    ReturnValue = Query->LookupServiceNext(
                            dwControlFlags,
                            lpdwBufferLength,
                            lpqsResults );

    Query->Dereference();
    return( ReturnValue );
}


INT
WSAAPI
WSANSPIoctl(
    IN      HANDLE          hLookup,
    IN      DWORD           dwControlCode,
    IN      PVOID           lpvInBuffer,
    IN      DWORD           cbInBuffer,
    OUT     PVOID           lpvOutBuffer,
    IN      DWORD           cbOutBuffer,
    OUT     PDWORD          lpcbBytesReturned,
    IN      LPWSACOMPLETION lpCompletion
    )
/*++
Routine Description:

Arguments:

Returns:
--*/
{
    PDTHREAD Thread;
    PNSQUERY Query;
    int ReturnValue;
    int ErrorCode;
    
    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }

    //
    // Verify that the completion structure is readable if given.
    //
    if ((lpCompletion != NULL) && IsBadReadPtr(lpCompletion, sizeof(*lpCompletion))) {
        SetLastError(WSAEINVAL);
        return (SOCKET_ERROR);
    }

    //
    // Verify lpcbBytesReturned.
    //
    if ((lpcbBytesReturned == NULL) ||
        IsBadWritePtr(lpcbBytesReturned, sizeof(*lpcbBytesReturned))) {
        SetLastError(WSAEINVAL);
        return (SOCKET_ERROR);
    }

    //
    // Verify that the query handle is valid.
    //
    if (!hLookup) {
        SetLastError(WSA_INVALID_HANDLE);
        return (SOCKET_ERROR);
    }
    Query = (PNSQUERY)hLookup;
    if (!Query->ValidateAndReference()) {
        SetLastError(WSA_INVALID_HANDLE);
        return (SOCKET_ERROR);
    }

    //
    // Perform the IOCTL.
    //
    ReturnValue = Query->Ioctl(
                        dwControlCode,
                        lpvInBuffer,
                        cbInBuffer,
                        lpvOutBuffer,
                        cbOutBuffer,
                        lpcbBytesReturned,
                        lpCompletion,
                        Thread->GetWahThreadID()
                        );
    Query->Dereference();

    return( ReturnValue );
}


INT
WSAAPI
WSALookupServiceEnd(
    IN      HANDLE          hLookup
    )
/*++

Routine Description:

    WSALookupServiceEnd() is called to free the handle after previous calls to
    WSALookupServiceBegin() and WSALookupServiceNext().  Note that if you call
    WSALookupServiceEnd() from another thread while an existing
    WSALookupServiceNext() is blocked, then the end call will have the same
    effect as a cancel, and will cause the WSALookupServiceNext() call to
    return immediately.

Arguments:

    hLookup - Handle previously obtained by calling WSALookupServiceBegin().

Returns:

    Zero if the operation was successful.
    SOCKET_ERROR on failure, GetLastError() contains error code.

--*/
{
    INT       ReturnValue;
    INT       ErrorCode;
    PNSQUERY  Query;

    ErrorCode = TURBO_PROLOG();
    if ( ErrorCode != ERROR_SUCCESS )
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    if ( !hLookup )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    Query = (PNSQUERY) hLookup;

    if ( !Query->ValidateAndReference() )
    {
        SetLastError(WSA_INVALID_HANDLE);
        return(SOCKET_ERROR);
    }

    ReturnValue = Query->LookupServiceEnd();

    Query->Dereference();
    Query->Dereference();   // Remove initial reference.
    //
    // Why ?
    //
    return( NO_ERROR );
}


INT
WSAAPI
WSASetServiceA(
    IN      LPWSAQUERYSETA      lpqsRegInfo,
    IN      WSAESETSERVICEOP    essOperation,
    IN      DWORD               dwControlFlags
    )
/*++

Routine Description:

    WSASetService() is used to register or deregister a service instance within
    one or more name spaces.  This function may be used to affect a specific
    name space provider, all providers associated with a specific name space,
    or all providers across all name spaces.

Arguments:

    lpqsRegInfo - specifies service information for registration, identifies
                  service for deregistration.

    essOperation - an enumeration whose values include:
        REGISTER register the service.  For SAP, this means sending out a
        periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means updating the address information.

        DEREGISTER deregister the service.  For SAP, this means stop sending
        out the periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means deleting address information.

        FLUSH used to initiate the registration requests that have previously
        occurred.

    dwControlFlags - The meaning of dwControlFlags is dependent on the value of
    essOperation as follows:

        essOperation    dwControlFlags    Meaning
        REGISTER        SERVICE_DEFER     delay the request (use FLUSH to
                                          subsequently issue the request)
                        SERVICE_HARD      send the request immediately.
                        SERVICE_MULTIPLE  the registering service can be
                                          represented by multiple instances.
        DEREGISTER      SERVICE_HARD      remove all knowledge of the object
                                          within the name space.
Returns:

    Zero if the operation was successful.
    SOCKET_ERROR on failure, GetLastError() contains error code.

--*/
{
    INT            ReturnCode;
    DWORD          ErrorCode;
    LPWSAQUERYSETW UniCodeBuffer;
    DWORD          UniCodeBufferSize;

    ReturnCode = SOCKET_ERROR;
    UniCodeBuffer = NULL;
    UniCodeBufferSize = 0;

    if ( !lpqsRegInfo )
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    //find out how big a buffer we need
    ErrorCode = MapAnsiQuerySetToUnicode(
        lpqsRegInfo,
        &UniCodeBufferSize,
        UniCodeBuffer);
    if (WSAEFAULT == ErrorCode){
        UniCodeBuffer = (LPWSAQUERYSETW) new BYTE[UniCodeBufferSize];
        if (UniCodeBuffer){
            ErrorCode = MapAnsiQuerySetToUnicode(
                lpqsRegInfo,
                &UniCodeBufferSize,
                UniCodeBuffer);
            if (ERROR_SUCCESS == ErrorCode){
                ReturnCode = WSASetServiceW(
                    UniCodeBuffer,
                    essOperation,
                    dwControlFlags);
            } //if
            delete UniCodeBuffer;
        } //if
    } //if
    return(ReturnCode);
}


typedef class NSCATALOGENTRYSTATE *PNSCATALOGENTRYSTATE;
class NSCATALOGENTRYSTATE {
public:
    NSCATALOGENTRYSTATE();

    INT
    Initialize(
        PNSCATALOGENTRY  CatalogEntry
        );

    PNSPROVIDER
    GetProvider(
        IN  PNSCATALOG    Catalog
        );

    ~NSCATALOGENTRYSTATE();

    LIST_ENTRY   m_context_linkage;
    //Public data member to support putting this object on a linked list
private:
    PNSCATALOGENTRY  m_catalog_entry;
    // Pointer to the NSCATALOGENTRY object associated with this boject.
}; // NSCATALOGENTRYSTATE

inline
NSCATALOGENTRYSTATE::NSCATALOGENTRYSTATE()
/*++

Routine Description:

    Constructor for the NSCATALOGENTRYSTATE object.  The first member function
    called after this must be Initialize.

Arguments:

    None

Return Value:

    Returns a pointer to a NSCATALOGENTRYSTATE object.
--*/
{
    m_catalog_entry = NULL;
}

inline
INT
NSCATALOGENTRYSTATE::Initialize(
    PNSCATALOGENTRY  CatalogEntry
    )
/*++

Routine Description:

    This  procedure  performs  all initialization for the NSCATALOGENTRYSTATE
    object.  This function  must  be  invoked  after the constructor, before
    any other member function is invoked.

Arguments:

    CatalogEntry - A pointer to a namespace catalog entry object.

Return Value:

    If  the  function  is  successful,  it  returns ERROR_SUCCESS, otherwise it
    returns an appropriate WinSock 2 error code.
--*/
{
    assert (m_catalog_entry==NULL);
    CatalogEntry->Reference ();
    m_catalog_entry = CatalogEntry;
    return(ERROR_SUCCESS);
}

PNSPROVIDER
NSCATALOGENTRYSTATE::GetProvider(
    IN  PNSCATALOG    Catalog
    )
/*++

Routine Description:

    Returns provider object associated with this object
    Loads it if necessary

Arguments:

    None

Return Value:

    NS provider object
--*/
{
    PNSPROVIDER     Provider;
    Provider = m_catalog_entry->GetProvider ();
    if (Provider==NULL) {
        INT ErrorCode = Catalog->LoadProvider (m_catalog_entry);
        if (ErrorCode==ERROR_SUCCESS) {
            Provider = m_catalog_entry->GetProvider ();
            assert (Provider!=NULL);
        }
    }

    return Provider;
}

inline
NSCATALOGENTRYSTATE::~NSCATALOGENTRYSTATE()
/*++

Routine Description:

    Denstructor for the NSCATALOGENTRYSTATE object. 

Arguments:

    None

Return Value:

    None
--*/
{
    if (m_catalog_entry!=NULL) {
        m_catalog_entry->Dereference ();
        m_catalog_entry = NULL;
    }
}



typedef struct _MATCH_PROVIDERS_CONTEXT {
    IN  BOOL            UseGuid;
    union {
        IN  GUID        ProviderId;
        IN  DWORD       NameSpaceId;
    };
    OUT LIST_ENTRY      EntryList;
    OUT INT             ErrorCode;
} MATCH_PROVIDERS_CONTEXT, * PMATCH_PROVIDERS_CONTEXT;

BOOL
MatchProviders(
    IN PVOID                PassBack,
    IN PNSCATALOGENTRY      CatalogEntry
    )
/*++

Routine Description:

    This function is the enumeration procedure passed to EnumerateCatalogItems
    in a call to WSASetServiceW(). This function inspects the current catalog
    item to see if it meets the selection criteria contained in the context
    value passed back from EnumerateCatalogItems(). 

Arguments:

    PassBack - The context value passed to EnumerateCatalogItems().

    CatalogEntry - A pointer to a NSCATALOGENTRY object.

Return Value:

    TRUE if the enumeration should be continued else FALSE.

--*/
{
    PMATCH_PROVIDERS_CONTEXT Context;
    BOOLEAN ContinueEnumeration = TRUE;
    BOOLEAN UseThisProvider = FALSE;

    Context = (PMATCH_PROVIDERS_CONTEXT)PassBack;
    if (Context->UseGuid) {
        if (Context->ProviderId==*(CatalogEntry->GetProviderId())) {
            UseThisProvider = TRUE;
        }
    }
    else {
        if (CatalogEntry->GetEnabledState () &&
                ((Context->NameSpaceId==CatalogEntry->GetNamespaceId()) ||
                    Context->NameSpaceId==NS_ALL)) {
            UseThisProvider = TRUE;
        }
    }

    if (UseThisProvider) {
        PNSCATALOGENTRYSTATE    EntryState;

        EntryState = new NSCATALOGENTRYSTATE;
        if (EntryState!=NULL) {
            EntryState->Initialize (CatalogEntry);
            InsertTailList (&Context->EntryList,
                                &EntryState->m_context_linkage);
        }
        else {
            Context->ErrorCode = WSA_NOT_ENOUGH_MEMORY;
            ContinueEnumeration = FALSE;
        }
    }

    return ContinueEnumeration;
}

INT WSAAPI
WSASetServiceW(
    IN  LPWSAQUERYSETW    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    )
/*++
Routine Description:
    WSASetService() is used to register or deregister a service instance within
    one or more name spaces.  This function may be used to affect a specific
    name space provider, all providers associated with a specific name space,
    or all providers across all name spaces.
Arguments:
    lpqsRegInfo - specifies service information for registration, identifies
                  service for deregistration.

    essOperation - an enumeration whose values include:
        REGISTER register the service.  For SAP, this means sending out a
        periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means updating the address information.

        DEREGISTER deregister the service.  For SAP, this means stop sending
        out the periodic broadcast.  This is a NOP for the DNS name space.  For
        persistent data stores this means deleting address information.

        FLUSH used to initiate the registration requests that have previously
        occurred.

    dwControlFlags - The meaning of dwControlFlags is dependent on the value of
    essOperation as follows:

        essOperation    dwControlFlags    Meaning
        REGISTER        SERVICE_DEFER     delay the request (use FLUSH to
                                          subsequently issue the request)
                        SERVICE_HARD      send the request immediately.
                        SERVICE_MULTIPLE  the registering service can be
                                          represented by multiple instances.
        DEREGISTER      SERVICE_HARD      remove all knowledge of the object
                                          within the name space.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.
--*/
{
    PDPROCESS          Process;
    PDTHREAD           Thread;
    INT                ErrorCode;
    PNSCATALOG         Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    if ( !lpqsRegInfo )
    {
        SetLastError (WSAEFAULT);
        return SOCKET_ERROR;
    }

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();

    __try {
        if (lpqsRegInfo->lpNSProviderId!=NULL) {
            Context.ProviderId = *(lpqsRegInfo->lpNSProviderId);
            Context.UseGuid = TRUE;
        }
        else {
            Context.NameSpaceId = lpqsRegInfo->dwNameSpace;
            Context.UseGuid = FALSE;
        }
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError (WSAEFAULT);
        return(SOCKET_ERROR);
    }

    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS) {
        ErrorCode = NO_DATA;
        while (!IsListEmpty (&Context.EntryList)) {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;
            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );
            Provider = EntryState->GetProvider (Catalog);
            if (Provider!=NULL) {
                if (Provider->NSPSetService(
                                        NULL, // lpServiceClassInfo
                                        lpqsRegInfo,
                                        essOperation,
                                        dwControlFlags)==ERROR_SUCCESS) {
                    ErrorCode = ERROR_SUCCESS;
                }
                else {
                    if (ErrorCode!=ERROR_SUCCESS) {
                        ErrorCode = GetLastError ();
                        //
                        // Reset error code if provider fails
                        // to set last error for some reason
                        //
                        if (ErrorCode==ERROR_SUCCESS)
                            ErrorCode = NO_DATA;
                    }
                }
            }
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}


INT WSAAPI
WSAInstallServiceClassA(
    IN  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    )
/*++
Routine Description:
    WSAInstallServiceClass() is used to register a service class schema within
    a name space. This schema includes the class name, class id, and any name
    space specific information that is common to all instances of the service,
    such as the SAP ID or object ID.

Arguments:
    lpServiceClasslnfo - contains service class to name space specific type
                         mapping information.  Multiple mappings can be handled
                         at one time.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.
--*/
{
    LPWSASERVICECLASSINFOW WideServiceClassInfo;
    DWORD WideServiceClassInfoSize;
    DWORD ErrorCode;
    INT   ReturnCode;

    if ( !lpServiceClassInfo ) {
        SetLastError (WSAEINVAL);
        return SOCKET_ERROR;
    }

    WideServiceClassInfo = NULL;
    WideServiceClassInfoSize = 0;
    ReturnCode = SOCKET_ERROR;

    //Find the size of buffer we are going to need
    ErrorCode = MapAnsiServiceClassInfoToUnicode(
        lpServiceClassInfo,
        &WideServiceClassInfoSize,
        WideServiceClassInfo);

    if (WSAEFAULT == ErrorCode){
        WideServiceClassInfo = (LPWSASERVICECLASSINFOW)
            new BYTE[WideServiceClassInfoSize];
        if (WideServiceClassInfo){
            ErrorCode = MapAnsiServiceClassInfoToUnicode(
                lpServiceClassInfo,
                &WideServiceClassInfoSize,
                WideServiceClassInfo);
            if (ERROR_SUCCESS == ErrorCode){
                ReturnCode = WSAInstallServiceClassW(
                    WideServiceClassInfo);
            } //if
            delete WideServiceClassInfo;
        } //if
    } //if
    else{
        SetLastError(ErrorCode);
    } //else
    return(ReturnCode);

}

INT WSAAPI
WSAInstallServiceClassW(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    )
/*++
Routine Description:
    WSAInstallServiceClass() is used to register a service class schema within
    a name space. This schema includes the class name, class id, and any name
    space specific information that is common to all instances of the service,
    such as the SAP ID or object ID.

Arguments:
    lpServiceClasslnfo - contains service class to name space specific type
                         mapping information.  Multiple mappings can be handled
                         at one time.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.
--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if ( !lpServiceClassInfo ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    Catalog = Process->GetNamespaceCatalog();

    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS)
    {
        ErrorCode = NO_DATA;

        while (!IsListEmpty (&Context.EntryList))
        {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);

            if (Provider!=NULL)
            {
                INT Error = Provider->NSPInstallServiceClass(
                                         lpServiceClassInfo);

                if (!Error)
                {
                    ErrorCode = ERROR_SUCCESS;
                }
                else
                {
                    if (ErrorCode)
                    {
                        ErrorCode = GetLastError();
                        //
                        // Reset error code if provider fails
                        // to set last error for some reason
                        //
                        if (ErrorCode==ERROR_SUCCESS)
                            ErrorCode = NO_DATA;
                    }
                }
            }
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS)
    {
        return (ERROR_SUCCESS);
    }
    else
    {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}


INT WSAAPI
WSARemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    )
/*++
Routine Description:
    WSARemoveServiceClass() is used to permanently unregister service class
    schema.
Arguments:
    lpServiceClassId - Pointer to the service class GUID that you wish to
                       remove.
Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS)
    {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if ( !lpServiceClassId )
    {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    Catalog = Process->GetNamespaceCatalog();
    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS)
    {
        ErrorCode = NO_DATA;

        while (!IsListEmpty (&Context.EntryList))
        {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);

            if (Provider!=NULL)
            {
                INT Error = Provider->NSPRemoveServiceClass(lpServiceClassId);

                if (!Error)
                {
                    ErrorCode = ERROR_SUCCESS;
                }
                else
                {
                    if (ErrorCode)
                    {
                        ErrorCode = GetLastError();
                        //
                        // Reset error code if provider fails
                        // to set last error for some reason
                        //
                        if (ErrorCode==ERROR_SUCCESS)
                            ErrorCode = NO_DATA;
                    }
                }
            }
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS)
    {
        return (ERROR_SUCCESS);
    }
    else
    {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}


INT WSAAPI
WSAGetServiceClassNameByClassIdA(
    IN      LPGUID  lpServiceClassId,
    OUT     LPSTR lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
/*++
Routine Description:
    This API will return the name of the service associated with the given
    type.  This name is the generic service name, like FTP, or SNA, and not the
    name of a specific instance of that service.

Arguments:
    lpServiceClassId - pointer to the GUID for the service class.

    lpszServiceClassName - service name.

    lpdwBufferLength - on input length of buffer returned by
                       lpszServiceClassName. On output, the length of the
                       service name copied into lpszServiceClassName.

Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();
    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS) {
        ErrorCode = NO_DATA;
        while (!IsListEmpty (&Context.EntryList)) {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;
            WSASERVICECLASSINFOW    Buffer, *pBuffer;
            DWORD                   BufferSize;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);
            if (Provider!=NULL) {
                BufferSize = sizeof (Buffer);
                Buffer.lpServiceClassId = lpServiceClassId;
                ErrorCode = Provider->NSPGetServiceClassInfo(
                                                &BufferSize,
                                                &Buffer);
                if(ErrorCode == ERROR_SUCCESS)
                {
                    //
                    // this is impossible. The provider has made an error, so
                    // concoct an error for it.
                    //
                    //
                    // ErrorCode = WSANO_DATA; // done above
                }
                else
                {
                    ErrorCode = GetLastError();
                    if (ErrorCode==ERROR_SUCCESS)
                        ErrorCode = WSANO_DATA;
                }

                if (WSAEFAULT == ErrorCode){
                    // The service provider claimed that it had an answer but our
                    // buffer was to small big suprise :-() so get a new buffer and go
                    // get the answer.
                    pBuffer = (LPWSASERVICECLASSINFOW) new BYTE[BufferSize];

                    if( pBuffer != NULL ) {

                        pBuffer->lpServiceClassId = lpServiceClassId;

                        ErrorCode = Provider->NSPGetServiceClassInfo(
                                        &BufferSize,
                                        pBuffer);
                        if ( ErrorCode == ERROR_SUCCESS &&
                             pBuffer->lpszServiceClassName )
                        {
                            DWORD StringLen = ((wcslen(pBuffer->lpszServiceClassName)+1)
                                                * sizeof(WCHAR));

                            __try {
                                if (*lpdwBufferLength >= StringLen){
                                    WideCharToMultiByte(
                                        CP_ACP,                         // CodePage (ANSI)
                                        0,                              // dwFlags
                                        pBuffer->lpszServiceClassName,  // lpWideCharStr
                                        -1,                             // cchWideChar
                                        lpszServiceClassName,           // lpMultiByteStr
                                        StringLen,                      // cchMultiByte
                                        NULL,                           // lpDefaultChar
                                        NULL                            // lpUsedDefaultChar
                                        );
                    
                                } //if
                                else{
                                    ErrorCode  = WSAEFAULT;
                                } //else
                                *lpdwBufferLength = StringLen;
                            }
                            __except (WS2_EXCEPTION_FILTER()) {
                                // Not much more we can do
                                ErrorCode = WSAEFAULT;
                            }

                        }
                        else
                        {
                            ErrorCode = GetLastError();
                            if (ErrorCode==ERROR_SUCCESS)
                                ErrorCode = WSANO_DATA;
                        }
                        delete pBuffer;
                    }
                    else {
                        ErrorCode = WSAENOBUFS;
                    }

                    delete EntryState;
                    // Provider at least once told us that he has
                    // something for us. Delete the rest and complete.
                    while (!IsListEmpty (&Context.EntryList)) {
                        ListItem = RemoveHeadList (&Context.EntryList);
                        EntryState = CONTAINING_RECORD (ListItem,
                                                            NSCATALOGENTRYSTATE,
                                                            m_context_linkage
                                                            );
                        delete EntryState;
                    }
                    break;
                } //if GetSize call succeeded
            } //if Provider is loaded
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}

INT WSAAPI
WSAGetServiceClassNameByClassIdW(
    IN      LPGUID  lpServiceClassId,
    OUT     LPWSTR lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    )
/*++
Routine Description:
    This API will return the name of the service associated with the given
    type.  This name is the generic service name, like FTP, or SNA, and not the
    name of a specific instance of that service.

Arguments:
    lpServiceClassId - pointer to the GUID for the service class.

    lpszServiceClassName - service name.

    lpdwBufferLength - on input length of buffer returned by
                       lpszServiceClassName. On output, the length of the
                       service name copied into lpszServiceClassName.

Returns:
    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    MATCH_PROVIDERS_CONTEXT Context;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    Catalog = Process->GetNamespaceCatalog();
    //
    // Specifying all namespaces gives us all enabled providers
    // which is exactly what we want
    //

    Context.NameSpaceId = NS_ALL;
    Context.UseGuid = FALSE;
    InitializeListHead (&Context.EntryList);
    Context.ErrorCode = ERROR_SUCCESS;

    Catalog->EnumerateCatalogItems(
        MatchProviders,
        &Context);

    if (Context.ErrorCode == ERROR_SUCCESS) {
        ErrorCode = NO_DATA;
        while (!IsListEmpty (&Context.EntryList)) {
            PNSCATALOGENTRYSTATE    EntryState;
            PLIST_ENTRY             ListItem;
            PNSPROVIDER             Provider;
            WSASERVICECLASSINFOW    Buffer, *pBuffer;
            DWORD                   BufferSize;

            ListItem = RemoveHeadList (&Context.EntryList);
            EntryState = CONTAINING_RECORD (ListItem,
                                                NSCATALOGENTRYSTATE,
                                                m_context_linkage
                                                );

            Provider = EntryState->GetProvider (Catalog);
            if (Provider!=NULL) {
                BufferSize = sizeof (Buffer);
                Buffer.lpServiceClassId = lpServiceClassId;
                ErrorCode = Provider->NSPGetServiceClassInfo(
                                                &BufferSize,
                                                &Buffer);
                if(ErrorCode == ERROR_SUCCESS)
                {
                    //
                    // this is impossible. The provider has made an error, so
                    // concoct an error for it.
                    //
                    //
                    // ErrorCode = WSANO_DATA; // done above
                }
                else
                {
                    ErrorCode = GetLastError();
                    if (ErrorCode==ERROR_SUCCESS)
                        ErrorCode = WSANO_DATA;
                }

                if (WSAEFAULT == ErrorCode){
                    // The service provider claimed that it had an answer but our
                    // buffer was to small big suprise :-() so get a new buffer and go
                    // get the answer.
                    pBuffer = (LPWSASERVICECLASSINFOW) new BYTE[BufferSize];

                    if( pBuffer != NULL ) {

                        pBuffer->lpServiceClassId = lpServiceClassId;

                        ErrorCode = Provider->NSPGetServiceClassInfo(
                                        &BufferSize,
                                        pBuffer);
                        if(ErrorCode == ERROR_SUCCESS) {
                            DWORD StringLen = ((wcslen(pBuffer->lpszServiceClassName)+1)
                                                * sizeof(WCHAR));

                            __try {
                                if (*lpdwBufferLength >= StringLen){
                                    wcscpy( lpszServiceClassName,
                                            pBuffer->lpszServiceClassName);
                    
                                } //if
                                else{
                                    ErrorCode  = WSAEFAULT;
                                } //else
                                *lpdwBufferLength = StringLen;
                            }
                            __except (WS2_EXCEPTION_FILTER()) {
                                // Not much more we can do
                                ErrorCode = WSAEFAULT;
                            }

                        }
                        else
                        {
                            ErrorCode = GetLastError();
                            if (ErrorCode==ERROR_SUCCESS)
                                ErrorCode = WSANO_DATA;
                        }
                        delete pBuffer;
                    }
                    else {
                        ErrorCode = WSAENOBUFS;
                    }

                    delete EntryState;
                    // Provider at least once told us that he has
                    // something for us. Delete the rest and complete.
                    while (!IsListEmpty (&Context.EntryList)) {
                        ListItem = RemoveHeadList (&Context.EntryList);
                        EntryState = CONTAINING_RECORD (ListItem,
                                                            NSCATALOGENTRYSTATE,
                                                            m_context_linkage
                                                            );
                        delete EntryState;
                    }
                    break;
                } //if GetSize call succeeded
            } //if Provider is loaded
            delete EntryState;
        }
    }
    else
        ErrorCode = Context.ErrorCode;

    if (ErrorCode == ERROR_SUCCESS) {
        return (ERROR_SUCCESS);
    }
    else {
        SetLastError(ErrorCode);
        return (SOCKET_ERROR);
    }
}




INT
WSAAPI
WSAGetServiceClassInfoA(
    IN  LPGUID                  lpProviderId,
    IN  LPGUID                  lpServiceClassId,
    OUT LPDWORD                 lpdwBufSize,
    OUT LPWSASERVICECLASSINFOA  lpServiceClassInfo
    )
/*++

Routine Description:

    WSAGetServiceClassInfo() is used to retrieve all of the class information
    (schema) pertaining to a specified service class from a specified name
    space provider.

Arguments:

    lpProviderId - Pointer to a GUID which identifies a specific name space
                   provider.

    lpServiceClassId - Pointer to a GUID identifying the service class in
                       question.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpServiceClassInfos.  On output - if the
                       API fails, and the error is WSAEFAULT, then it contains
                       the minimum number of bytes to pass for the
                       lpServiceClassInfo to retrieve the record.

    lpServiceClasslnfo - returns service class information from the indicated
                         name space provider for the specified service class.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    LPWSASERVICECLASSINFOW WideServiceClassInfo;
    INT   ReturnCode;
    DWORD ErrorCode;

    if (!lpProviderId ||      // Fix for bug #102088
        !lpServiceClassId ||
        !lpdwBufSize ||
        !lpServiceClassInfo ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    ReturnCode = SOCKET_ERROR;
    ErrorCode = WSAEINVAL;

    WideServiceClassInfo =(LPWSASERVICECLASSINFOW) new BYTE[*lpdwBufSize];
    if (WideServiceClassInfo){
        ReturnCode = WSAGetServiceClassInfoW(
            lpProviderId,
            lpServiceClassId,
            lpdwBufSize,
            WideServiceClassInfo);
        if (ERROR_SUCCESS == ReturnCode){
            MapUnicodeServiceClassInfoToAnsi(
                WideServiceClassInfo,
                lpdwBufSize,
                lpServiceClassInfo);
        } //if
        else{
            ErrorCode = GetLastError();
        } //else
        delete WideServiceClassInfo;
    } //if

    if (ERROR_SUCCESS != ReturnCode){
        SetLastError(ErrorCode);
    } //if
    return(ReturnCode);
}


INT
WSAAPI
WSAGetServiceClassInfoW(
    IN  LPGUID  lpProviderId,
    IN  LPGUID  lpServiceClassId,
    IN  OUT LPDWORD  lpdwBufSize,
    OUT LPWSASERVICECLASSINFOW lpServiceClassInfo
)
/*++

Routine Description:

    WSAGetServiceClassInfo() is used to retrieve all of the class information
    (schema) pertaining to a specified service class from a specified name
    space provider.

Arguments:

    lpProviderId - Pointer to a GUID which identifies a specific name space
                   provider.

    lpServiceClassId - Pointer to a GUID identifying the service class in
                       question.

    lpdwBufferLength - on input, the number of bytes contained in the buffer
                       pointed  to by lpServiceClassInfos.  On output - if the
                       API fails, and the error is WSAEFAULT, then it contains
                       the minimum number of bytes to pass for the
                       lpServiceClassInfo to retrieve the record.

    lpServiceClasslnfo - returns service class information from the indicated
                         name space provider for the specified service class.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{

    PDPROCESS       Process;
    PDTHREAD        Thread;
    INT             ErrorCode;
    PNSCATALOG      Catalog;
    PNSPROVIDER     Provider;
    PNSCATALOGENTRY CatalogEntry;

    if (!lpProviderId ||      // Fix for bug #102088
        !lpServiceClassId ||
        !lpdwBufSize ||
        !lpServiceClassInfo ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    }

    Catalog = Process->GetNamespaceCatalog();
    ErrorCode = Catalog->GetCountedCatalogItemFromProviderId(
        lpProviderId,
        &CatalogEntry);
    if(ERROR_SUCCESS == ErrorCode){
        if (CatalogEntry->GetEnabledState()) {
            WSASERVICECLASSINFOW scliTemp;
            Provider = CatalogEntry->GetProvider();
            if (Provider==NULL) {
                ErrorCode = Catalog->LoadProvider (CatalogEntry);
                if (ErrorCode!=NO_ERROR) {
                    goto DereferenceEntry;
                }
                Provider = CatalogEntry->GetProvider ();
                assert (Provider!=NULL);
            }


            __try {
                if(*lpdwBufSize < sizeof(*lpServiceClassInfo)) {
                    //
                    // this is sleazy as we don't adjust the buffer
                    // size. But it makes things work
                    //
                    lpServiceClassInfo = &scliTemp;
                }
                lpServiceClassInfo->lpServiceClassId = lpServiceClassId;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
                goto DereferenceEntry;
            }
            if (Provider->NSPGetServiceClassInfo(
                   lpdwBufSize,
                   lpServiceClassInfo)!=ERROR_SUCCESS) {
                ErrorCode = GetLastError ();
                if (ErrorCode==ERROR_SUCCESS)
                    ErrorCode = WSANO_DATA;

            }
        }
        else {
            ErrorCode = WSAEINVAL;
        }
    DereferenceEntry:
        CatalogEntry->Dereference ();
    }

    if(ErrorCode == ERROR_SUCCESS) {
        return ERROR_SUCCESS;
    }
    else {
        SetLastError(ErrorCode);
        return SOCKET_ERROR;
    }

}

INT
WSAAPI
WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR              lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
/*++

Routine Description:

    WSAAddressToString() converts a SOCKADDR structure into a human-readable
    string representation of the address.  This is intended to be used mainly
    for display purposes. If the caller wishes the translation to be done by a
    particular provider, it should supply the corresponding WSAPROTOCOL_INFO
    struct in the lpProtocolInfo parameter.

Arguments:

    lpsaAddress - points to a SOCKADDR structure to translate into a string.

    dwAddressLength - the length of the Address SOCKADDR.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular
                     provider.

    lpszAddressString - a buffer which receives the human-readable address
                        string.

    lpdwAddressStringLength - on input, the length of the AddressString buffer.
                              On output, returns the length of  the string
                              actually copied into the buffer.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned
--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if (!lpsaAddress ||      // Fix for bug #114256
        !dwAddressLength ||
        !lpszAddressString ||
        !lpdwAddressStringLength ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD   dwCatalogEntryId;
        __try {
            dwCatalogEntryId = lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else {
        int family;
        __try {
            family = lpsaAddress->sa_family;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            family,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );
        Provider = CatalogEntry->GetProvider();
        ReturnValue = Provider->WSPAddressToString(
            lpsaAddress,
            dwAddressLength,
            ProtocolInfo,
            lpszAddressString,
            lpdwAddressStringLength,
            &ErrorCode);
        CatalogEntry->Dereference ();
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;
    } //if

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);

}


INT
WSAAPI
WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    )
/*++

Routine Description:

    WSAAddressToString() converts a SOCKADDR structure into a human-readable
    string representation of the address.  This is intended to be used mainly
    for display purposes. If the caller wishes the translation to be done by a
    particular provider, it should supply the corresponding WSAPROTOCOL_INFO
    struct in the lpProtocolInfo parameter.

Arguments:

    lpsaAddress - points to a SOCKADDR structure to translate into a string.

    dwAddressLength - the length of the Address SOCKADDR.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFO struct for a particular
                     provider.

    lpszAddressString - a buffer which receives the human-readable address
                        string.

    lpdwAddressStringLength - on input, the length of the AddressString buffer.
                              On output, returns the length of  the string
                              actually copied into the buffer.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned
--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    LPWSTR              LocalString;
    DWORD               LocalStringLength;


    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    if (!lpsaAddress ||      // Fix for bug #114256
        !dwAddressLength ||
        !lpszAddressString ||
        !lpdwAddressStringLength ) {
        SetLastError(WSAEINVAL);
        return(SOCKET_ERROR);
    }

    //Get a buffer to hold the unicode string the service provider is going to
    //return
    __try {
        LocalStringLength = *lpdwAddressStringLength;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError(WSAEFAULT);
        return(SOCKET_ERROR);
    }

    LocalString = (LPWSTR) new WCHAR[LocalStringLength];
    if (LocalString==NULL) {
        SetLastError(WSAENOBUFS);
        return(SOCKET_ERROR);
    } //if

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD   dwCatalogEntryId;
        __try {
            dwCatalogEntryId = lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            delete(LocalString);
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else {
        int family;
        __try {
            family = lpsaAddress->sa_family;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            delete(LocalString);
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            family,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );
        Provider = CatalogEntry->GetProvider();

        ReturnValue = Provider->WSPAddressToString(
            lpsaAddress,
            dwAddressLength,
            ProtocolInfo,
            LocalString,
            lpdwAddressStringLength,
            &ErrorCode);

        if (ERROR_SUCCESS == ReturnValue){
            __try {
                WideCharToMultiByte(
                    CP_ACP,                        // CodePage (Ansi)
                    0,                             // dwFlags
                    LocalString,                   // lpWideCharStr
                    -1,                            // cchWideCharStr
                    lpszAddressString,             // lpMultiByte
                    LocalStringLength,             // cchMultiByte
                    NULL,
                    NULL);
            }
            __except (WS2_EXCEPTION_FILTER()) {
                ErrorCode = WSAEFAULT;
                ReturnValue = SOCKET_ERROR;
            }
        } //if

        delete(LocalString);
        CatalogEntry->Dereference ();
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;

    } //if
    else {
        delete(LocalString);
    }

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}

INT
WSAAPI
WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
/*++

Routine Description:

    WSAStringToAddress() converts a human-readable string to a socket address
    structure (SOCKADDR) suitable for pass to Windows Sockets routines which
    take such a structure.  If the caller wishes the translation to be done by
    a particular provider, it should supply the corresponding WSAPROTOCOL_INFOW
    struct in the lpProtocolInfo parameter.

Arguments:

    AddressString - points to the zero-terminated human-readable string to
                    convert.

    AddressFamily - the address family to which the string belongs.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOW struct for a particular
                     provider.

    Address - a buffer which is filled with a single SOCKADDR structure.

    lpAddressLength - The length of the Address buffer.  Returns the size of
                      the resultant SOCKADDR structure.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD dwCatalogEntryId;
        __try {
            dwCatalogEntryId =  lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }
        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else{
        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            AddressFamily,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );
        Provider = CatalogEntry->GetProvider();
        ReturnValue = Provider->WSPStringToAddress(
            AddressString,
            AddressFamily,
            ProtocolInfo,
            lpAddress,
            lpAddressLength,
            &ErrorCode);
        CatalogEntry->Dereference ();
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;
    } //if

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}

INT
WSAAPI
WSAStringToAddressA(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    )
/*++

Routine Description:

    WSAStringToAddress() converts a human-readable string to a socket address
    structure (SOCKADDR) suitable for pass to Windows Sockets routines which
    take such a structure.  If the caller wishes the translation to be done by
    a particular provider, it should supply the corresponding WSAPROTOCOL_INFOA
    struct in the lpProtocolInfo parameter.

Arguments:

    AddressString - points to the zero-terminated human-readable string to
                    convert.

    AddressFamily - the address family to which the string belongs.

    lpProtocolInfo - (optional) the WSAPROTOCOL_INFOA struct for a particular
                     provider.

    Address - a buffer which is filled with a single SOCKADDR structure.

    lpAddressLength - The length of the Address buffer.  Returns the size of
                      the resultant SOCKADDR structure.

Return Value:

    The return value is 0 if the operation was successful.  Otherwise the value
    SOCKET_ERROR is returned.

--*/
{
    INT                 ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    LPWSTR              LocalString;
    INT                 LocalStringLength;

    ErrorCode = PROLOG(&Process,
                        &Thread);
    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(SOCKET_ERROR);
    } //if

    __try {
        // Get a buffer to hold the ansi string handed in by the user.
        LocalStringLength = strlen(AddressString)+1;
        LocalString = (LPWSTR)new WCHAR[LocalStringLength];
        if (LocalString==NULL) {
            SetLastError (WSAENOBUFS);
            return (SOCKET_ERROR);
        }

        MultiByteToWideChar(
            CP_ACP,                          // CodePage (Ansi)
            0,                               // dwFlags
            AddressString,                   // lpMultiByte
            -1,                              // cchMultiByte
            LocalString,                     // lpWideChar
            LocalStringLength);              // ccWideChar
    }
    __except (WS2_EXCEPTION_FILTER()) {
        SetLastError(WSAEFAULT);
        return(SOCKET_ERROR);
    }

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {
        DWORD dwCatalogEntryId;
        __try {
            dwCatalogEntryId =  lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            delete (LocalString);
            SetLastError(WSAEFAULT);
            return(SOCKET_ERROR);
        }

        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogEntryId,
            &CatalogEntry);
    } //if
    else{
        ErrorCode = Catalog->GetCountedCatalogItemFromAddressFamily(
            AddressFamily,
            &CatalogEntry);
    }

    if ( ERROR_SUCCESS == ErrorCode) {
        ProtocolInfo = CatalogEntry->GetProtocolInfo();
        assert( ProtocolInfo != NULL );

        Provider = CatalogEntry->GetProvider();

        ReturnValue = Provider->WSPStringToAddress(
            LocalString,
            AddressFamily,
            ProtocolInfo,
            lpAddress,
            lpAddressLength,
            &ErrorCode);
        CatalogEntry->Dereference ();
        delete(LocalString);
        if (ReturnValue==ERROR_SUCCESS)
            return ERROR_SUCCESS;
    } //if
    else {
        delete(LocalString);
    }


    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}



PNSCATALOG
OpenInitializedNameSpaceCatalog()
{
    BOOL ReturnCode = TRUE;
    PNSCATALOG ns_catalog;
    HKEY RegistryKey = 0;

     TRY_START(mem_guard){

        //
        // Build the protocol catalog
        //

        ns_catalog = new (NSCATALOG);

        if (!ns_catalog) {

            DEBUGF (DBG_ERR, ("Allocating nscatalog object\n"));
            TRY_THROW(mem_guard);
        }

        RegistryKey = OpenWinSockRegistryRoot();

        if (!RegistryKey) {

            TRY_THROW(mem_guard);
        }

        ReturnCode = ns_catalog->InitializeFromRegistry(
                                    RegistryKey,
                                    NULL
                                    );

        if (ERROR_SUCCESS != ReturnCode) {

            DEBUGF (DBG_ERR, ("Initializing from registry\n"));
            TRY_THROW(mem_guard);
        }

    } TRY_CATCH(mem_guard) {

        delete (ns_catalog);
        ns_catalog = NULL;

    } TRY_END(mem_guard);

    LONG close_result;

    if (RegistryKey) {

        close_result = RegCloseKey (RegistryKey);
        assert(close_result == ERROR_SUCCESS);
    }

    return (ns_catalog);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\scihlpr.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    scihlpr.cpp

Abstract:

    This module contains the implementation of the helper functions for
    translating WSASERVICECLASSINFO structs from the ansi to unicode and uncode
    to ansi

Author:

    Dirk Brandewie dirk@mink.intel.com  12-1-1995

[Environment:]

[Notes:]

    $Revision:   1.0  $

    $Modtime:   29 Jan 1996 08:58:54  $

Revision History:

    25-Jan-1996 dirk@mink.intel.com
        Initial Revision

--*/

#include "precomp.h"


DWORD
CalculateBufferSize(
    BOOL IsAnsi,
    LPVOID Buffer
    )
{
    LPWSASERVICECLASSINFOW UnicodeBuffer;
    LPWSASERVICECLASSINFOA AnsiBuffer;
    LPWSTR                 Wstring=NULL;
    LPSTR                  Astring=NULL;
    INT                    StringLen=0;
    DWORD                  Index;
    DWORD                  Count;

    DWORD Size=0;

    if (IsAnsi){
        AnsiBuffer = (LPWSASERVICECLASSINFOA) Buffer;
    } //if
    else{
        UnicodeBuffer =(LPWSASERVICECLASSINFOW) Buffer;
    } //else

    //Size of the fixed portion of the buffer
    if (IsAnsi){
        Size += sizeof(WSASERVICECLASSINFO);
        Size += (sizeof(WSANSCLASSINFO) * AnsiBuffer->dwCount);
    } //if
    else{
        Size += sizeof(WSASERVICECLASSINFO);
        Size += (sizeof(WSANSCLASSINFO) * UnicodeBuffer->dwCount);
    } //else

    //The toplevel GUID
    Size += sizeof(GUID);
    //The GUID's in the NSCLLASSINFO's
    if (IsAnsi){
        Size += (sizeof(GUID) * AnsiBuffer->dwCount);
    } //if
    else{
        Size += (sizeof(GUID) * UnicodeBuffer->dwCount);
    } //else

    //The toplevle string
    if (IsAnsi){
        StringLen =0;
        StringLen = MultiByteToWideChar(
            CP_ACP,                      // CodePage (Ansi)
            0,                           // dwFlags
            AnsiBuffer->lpszServiceClassName,  // lpMultiByteStr
            -1,                          // cchMultiByte
            NULL,                     // lpWideCharStr
            StringLen);                  // cchWideChar
        Size += ((StringLen+1) * sizeof(WCHAR));
    } //if
    else{
        StringLen =0;
        StringLen = WideCharToMultiByte(
            CP_ACP,                        // CodePage (Ansi)
            0,                             // dwFlags
            UnicodeBuffer->lpszServiceClassName, // lpWideCharStr
            -1,                            // cchWideChar
            Astring,                       // lpMultiByteStr
            StringLen,                     // cchMultiByte
            NULL,                          // lpDefaultChar
            NULL);                         // lpUsedDefaultChar
        Size += (StringLen+1);
    } //else


    if (IsAnsi){
        Count = AnsiBuffer->dwCount;
    } //if
    else{
        Count = UnicodeBuffer->dwCount;
    } //else

    // The variable parts of NSCLASSINFO
    for (Index = 0; Index < Count ;Index++ ){
        if (IsAnsi){
            StringLen = 0;
            StringLen = MultiByteToWideChar(
                CP_ACP,                      // CodePage (Ansi)
                0,                           // dwFlags
                AnsiBuffer->lpClassInfos[Index].lpszName, // lpMultiByteStr
                -1,                          // cchMultiByte
                NULL,                     // lpWideCharStr
                StringLen);                  // cchWideChar
            Size += ((StringLen+1) * sizeof(WCHAR));
        } //if
        else{
            StringLen = 0;
            StringLen = WideCharToMultiByte(
                CP_ACP,                        // CodePage (Ansi)
                0,                             // dwFlags
                UnicodeBuffer->lpClassInfos[Index].lpszName,  // lpWideCharStr
                -1,                            // cchWideChar
                Astring,                       // lpMultiByteStr
                StringLen,                     // cchMultiByte
                NULL,                          // lpDefaultChar
                NULL);                         // lpUsedDefaultChar
            Size += (StringLen+1);
        } //else

        if (IsAnsi){
            Size += AnsiBuffer->lpClassInfos[Index].dwValueSize;
        } //if
        else{
            Size += UnicodeBuffer->lpClassInfos[Index].dwValueSize;
        } //else
    } //for
    return(Size);
}


INT
MapAnsiServiceClassInfoToUnicode(
    IN     LPWSASERVICECLASSINFOA Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOW Target
    )
{
    DWORD RequiredBufferSize;
    LPBYTE FreeSpace;
    INT    StringLen;
    DWORD  Index;

    __try {
        // Find the size of buffer we will need
        RequiredBufferSize = CalculateBufferSize(
            TRUE, // Ansi Source
            Source);
        if (RequiredBufferSize > *lpTargetSize){
            *lpTargetSize = RequiredBufferSize;
            return(WSAEFAULT);
        } //if

        // Copy known size portions of buffer

        // Toplevel structure
        FreeSpace = (LPBYTE)Target;
        CopyMemory(Target,
                   Source,
                   sizeof(WSASERVICECLASSINFOW));
        FreeSpace += sizeof(WSASERVICECLASSINFOW);

        // The array of WSANSCLASSINFO's
        Target->lpClassInfos = (LPWSANSCLASSINFOW)FreeSpace;
        CopyMemory(Target->lpClassInfos,
                   Source->lpClassInfos,
                   (sizeof(WSANSCLASSINFO) * Source->dwCount));
        FreeSpace += (sizeof(WSANSCLASSINFO) * Source->dwCount);

        // The service class ID GUID
        Target->lpServiceClassId = (LPGUID)FreeSpace;
        CopyMemory(Target->lpServiceClassId,
                   Source->lpServiceClassId,
                   sizeof(GUID));
        FreeSpace += sizeof(GUID);

        // Copy variable portion

        Target->lpszServiceClassName = (LPWSTR)FreeSpace;
        StringLen = MultiByteToWideChar(
            CP_ACP,                        // CodePage (Ansi)
            0,                             // dwFlags
            Source->lpszServiceClassName,  // lpMultiByteStr
            -1,                            // cchMultiByte
            NULL,                          // lpWideCharStr
            0);                            // cchWideChar

        FreeSpace += ((StringLen+1) * sizeof(WCHAR));
        MultiByteToWideChar(
            CP_ACP,                        // CodePage (Ansi)
            0,                             // dwFlags
            Source->lpszServiceClassName,  // lpMultiByteStr
            -1,                            // cchMultiByte
            Target->lpszServiceClassName,  // lpWideCharStr
            StringLen);  // cchWideChar

        for (Index=0;Index < Source->dwCount ;Index++ ){
            LPSTR SourceString;
            LPWSTR TargetString;

            SourceString = Source->lpClassInfos[Index].lpszName;
            Target->lpClassInfos[Index].lpszName = (LPWSTR)FreeSpace;
            TargetString = Target->lpClassInfos[Index].lpszName;

            StringLen = MultiByteToWideChar(
                CP_ACP,                        // CodePage (Ansi)
                0,                             // dwFlags
                SourceString,                  // lpMultiByteStr
                -1,                            // cchMultiByte
                NULL,                          // lpWideCharStr
                0);                            // cchWideChar

            FreeSpace += ((StringLen +1) * sizeof(WCHAR));
            MultiByteToWideChar(
                CP_ACP,                        // CodePage (Ansi)
                0,                             // dwFlags
                SourceString,                  // lpMultiByteStr
                -1,                            // cchMultiByte
                TargetString,                  // lpWideCharStr
                StringLen);                    // cchWideChar

            Target->lpClassInfos[Index].lpValue = FreeSpace;
            CopyMemory(
                Target->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].dwValueSize);
            FreeSpace += Source->lpClassInfos[Index].dwValueSize;
        } //for
        return(ERROR_SUCCESS);
    }
    __except (WS2_EXCEPTION_FILTER()) {
        return (WSAEFAULT);
    }
}


INT
MapUnicodeServiceClassInfoToAnsi(
    IN     LPWSASERVICECLASSINFOW Source,
    IN OUT LPDWORD                lpTargetSize,
    IN     LPWSASERVICECLASSINFOA Target
    )
{
    DWORD RequiredBufferSize;
    LPBYTE FreeSpace;
    INT    StringLen;
    DWORD  Index;

    __try {
        // Find the size of buffer we will need
        RequiredBufferSize = CalculateBufferSize(
            TRUE, // Ansi Source
            Source);
        if (RequiredBufferSize > *lpTargetSize){
            *lpTargetSize = RequiredBufferSize;
            return(WSAEFAULT);
        } //if

        // Copy known size portions of buffer

        // Toplevel structure
        FreeSpace = (LPBYTE)Target;
        CopyMemory(Target,
                   Source,
                   sizeof(WSASERVICECLASSINFOA));
        FreeSpace += sizeof(WSASERVICECLASSINFOA);

        // The array of WSANSCLASSINFO's
        Target->lpClassInfos = (LPWSANSCLASSINFOA)FreeSpace;
        CopyMemory(Target->lpClassInfos,
                   Source->lpClassInfos,
                   (sizeof(WSANSCLASSINFOA) * Source->dwCount));
        FreeSpace += (sizeof(WSANSCLASSINFOA) * Source->dwCount);

        // The service class ID GUID
        Target->lpServiceClassId = (LPGUID)FreeSpace;
        CopyMemory(Target->lpServiceClassId,
                   Source->lpServiceClassId,
                   sizeof(GUID));
        FreeSpace += sizeof(GUID);

        // Copy variable portion

        Target->lpszServiceClassName = (LPSTR)FreeSpace;
        StringLen = WideCharToMultiByte(
            CP_ACP,                          // CodePage (Ansi)
            0,                               // dwFlags
            Source->lpszServiceClassName,    // lpWideCharStr
            -1,                              // cchWideChar
            NULL         ,                   // lpMultiByteStr
            0,                               // cchMultiByte
            NULL,                            // lpDefaultChar
            NULL);                           // lpUsedDefaultChar

        FreeSpace += (StringLen+1);
        WideCharToMultiByte(
            CP_ACP,                          // CodePage (Ansi)
            0,                               // dwFlags
            Source->lpszServiceClassName,    // lpWideCharStr
            -1,                              // cchWideChar
            Target->lpszServiceClassName,    // lpMultiByteStr
            StringLen,                       // cchMultiByte
            NULL,                            // lpDefaultChar
            NULL);                           // lpUsedDefaultChar

        for (Index=0;Index < Source->dwCount ;Index++ ){
            LPWSTR SourceString;
            LPSTR TargetString;

            SourceString = Source->lpClassInfos[Index].lpszName;
            Target->lpClassInfos[Index].lpszName = (LPSTR)FreeSpace;
            TargetString = Target->lpClassInfos[Index].lpszName;

            StringLen = WideCharToMultiByte(
                CP_ACP,                          // CodePage (Ansi)
                0,                               // dwFlags
                SourceString,                    // lpWideCharStr
                -1,                              // cchWideChar
                NULL         ,                   // lpMultiByteStr
                0,                               // cchMultiByte
                NULL,                            // lpDefaultChar
                NULL);                           // lpUsedDefaultChar

            FreeSpace += (StringLen+1);
            WideCharToMultiByte(
                CP_ACP,                          // CodePage (Ansi)
                0,                               // dwFlags
                SourceString,                    // lpWideCharStr
                -1,                              // cchWideChar
                TargetString,                    // lpMultiByteStr
                StringLen,                       // cchMultiByte
                NULL,                            // lpDefaultChar
                NULL);                           // lpUsedDefaultChar

            Target->lpClassInfos[Index].lpValue = FreeSpace;
            CopyMemory(
                Target->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].lpValue,
                Source->lpClassInfos[Index].dwValueSize);
            FreeSpace += Source->lpClassInfos[Index].dwValueSize;
        } //for
        return(ERROR_SUCCESS);
    }
    __except (WS2_EXCEPTION_FILTER()) {
        return (WSAEFAULT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\select.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    select.c

Abstract:

    This module contains the "select" entry points from the winsock
    API. The following functions aare contained in this module.

    select()
    WSAEventSelect()
    WSAAsyncSelect()
    __WSAFDIsSet()

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h

    16-Aug-1995  dirk@mink.intel.com
        Added implementation of __WSAFDIsSet

--*/
#include "precomp.h"




int WSAAPI
select (
    IN int nfds,
    IN OUT fd_set FAR *readfds,
    IN OUT fd_set FAR *writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR *timeout
    )
/*++
Routine Description:

    Determine the status of one or more sockets, waiting if necessary.

Arguments:

    nfds - This argument is ignored and included only for the sake of
           compatibility.

    readfds - An optional pointer to a set of sockets to be checked
              for readability.

    writefds - An optional pointer to a set of sockets to be checked
               for writability.

    exceptfds - An optional pointer to a set of sockets to be checked
                for errors.

    timeout - The maximum time for select() to wait, or NULL for
              blocking operation.

Returns:
    select() returns the total number of descriptors which are ready
    and contained in the fd_set structures, 0 if the time limit
    expired, or SOCKET_ERROR if an error occurred.  If the return
    value is SOCKET_ERROR, The error code is stored with
    SetLastError().
--*/
{
    INT                ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;
    SOCKET             SocketID;
    BOOL               FoundSocket=FALSE;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {

        __try {
            // Look for a socket in the three fd_sets handed in. The first
            // socket found will be used to select the service provider to
            // service this call
            if (readfds && readfds->fd_count)
                {
                SocketID = readfds->fd_array[0];
                FoundSocket = TRUE;
                } //if

            if (!FoundSocket && writefds && writefds->fd_count )
                {
                SocketID = writefds->fd_array[0];
                FoundSocket = TRUE;
                } //if

            if (!FoundSocket && exceptfds && exceptfds->fd_count )
                {
                SocketID = exceptfds->fd_array[0];
                FoundSocket = TRUE;
                } //if
        }
        __except (WS2_EXCEPTION_FILTER()) {
            ErrorCode = WSAEFAULT;
            goto ReturnError;
        }

        if (FoundSocket) {
            Socket = DSOCKET::GetCountedDSocketFromSocket(SocketID);
            if(Socket != NULL){
                Provider = Socket->GetDProvider();
                ReturnValue = Provider->WSPSelect(
                    nfds,
                    readfds,
                    writefds,
                    exceptfds,
                    timeout,
                    &ErrorCode);
                Socket->DropDSocketReference();
                if (ReturnValue!=SOCKET_ERROR)
                    return ReturnValue;

                assert (ErrorCode!=NO_ERROR);
                if (ErrorCode==NO_ERROR)
                    ErrorCode = WSASYSCALLFAILURE;

            } //if
            else {
                ErrorCode = WSAENOTSOCK;
            }
        } //if
        else {
            ErrorCode = WSAEINVAL;
        } //else
    }

ReturnError:
    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
} //select




int WSAAPI
WSAEventSelect(
    IN SOCKET s,
    IN WSAEVENT hEventObject,
    IN long lNetworkEvents
    )
/*++
Routine Description:

    Specify an event object to be associated with the supplied set of
    FD_XXX network events.

Arguments:

    s - A descriptor identifying the socket.

    hEventObject - A handle identifying the event object to be
                   associated with the supplied set of FD_XXX network
                   events.

    lNetworkEvents - A bitmask which specifies the combination of
                     FD_XXX network events in which the application
                     has interest.

Returns:
    Zero on success else SOCKET_Error. The error code is stored with
    SetLastError().
--*/
{
    INT                ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPEventSelect(
                s,
                hEventObject,
                lNetworkEvents,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} //WSAEventSelect


int WSAAPI
WSAAsyncSelect(
    IN SOCKET s,
    IN HWND hWnd,
    IN u_int wMsg,
    IN long lEvent
    )
/*++
Routine Description:

    Request event notification for a socket.

Arguments:

    s - A descriptor identifying the socket for which event notification is
        required.

    hWnd - A handle identifying the window which should receive a message when
           a network event occurs.

    wMsg - The message to be received when a network event occurs.

    lEvent - A bitmask which specifies a combination of network events in which
             the application is interested.

Returns:
    The return value is 0 if the application's declaration of interest in the
    network event set was successful.  Otherwise the value SOCKET_ERROR is
    returned, and a specific error number may be retrieved by calling
    WSAGetLastError().
--*/
{
    INT                ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPAsyncSelect(
                s,
                hWnd,
                wMsg,
                lEvent,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} //WSAAsyncSelect



int FAR PASCAL
__WSAFDIsSet(
    SOCKET fd,
    fd_set FAR *set)
/*++
Routine Description:

    Determines if a specific socket is a contained in an FD_SET.

Arguments:

    s - A descriptor identifying the socket.

    set - A pointer to an FD_SET.
Returns:

    Returns TRUE if socket s is a member of set, otherwise FALSE.

--*/
{
    int i = set->fd_count; // index into FD_SET
    int rc=FALSE; // user return code

    while (i--){
        if (set->fd_array[i] == fd) {
            rc = TRUE;
        } //if
    } //while
    return (rc);
} // __WSAFDIsSet



int FAR PASCAL
WPUFDIsSet(
    SOCKET fd,
    fd_set FAR *set)
/*++
Routine Description:

    Determines if a specific socket is a contained in an FD_SET.

Arguments:

    s - A descriptor identifying the socket.

    set - A pointer to an FD_SET.
Returns:

    Returns TRUE if socket s is a member of set, otherwise FALSE.

--*/
{
    int return_value;

    return_value = __WSAFDIsSet(
        fd,
        set
        );
    return(return_value);
} // WPUFDIsSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\sockctrl.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    SockCtrl.c

Abstract:

    This  module  contains  functions  that control the state of a socket.  The
    following functions are contained in the module.

    bind()
    connect()
    getpeername()
    getsockname()
    listen()
    setsockopt()
    shutdown()
    WSAConnect()
    WSAEnumNetworkEvents()
    WSAGetOverlapedResult()
    WSAJoinLeaf()


Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes into precomp.h. Reworked all
        functions to remove extra if's and to be consistant with the rest of
        the project.

--*/
#include "precomp.h"



int WSAAPI
bind(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen
    )
/*++
Routine Description:

    Associate a local address with a socket.

Arguments:

    s       - A descriptor identifying an unbound socket.

    name    - The address to assign to the socket.

    namelen - The length of the name.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                ReturnValue;
    PDPROVIDER         Provider;
    INT                ErrorCode;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPBind(s,
                                            name,
                                            namelen,
                                            &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
connect(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen
    )
/*++
Routine Description:

    Establish a connection to a peer.

Arguments:

    s       - A descriptor identifying an unconnected socket.

    name    - The name of the peer to which the socket is to be connected.

    namelen - The length of the name.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{

    INT                ReturnValue;
    PDPROCESS          Process;
    PDTHREAD           Thread;
    PDPROVIDER         Provider;
    INT                ErrorCode;
    PDSOCKET           Socket;
    BOOL               RetryConnect;
    INT				   SavedErrorCode;


    ErrorCode = PROLOG(&Process, &Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
#ifdef RASAUTODIAL
			RetryConnect = FALSE;
        retry:
#endif // RASAUTODIAL
            ReturnValue = Provider->WSPConnect(s,
                                               name,
                                               namelen,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &ErrorCode);
#ifdef RASAUTODIAL
            if (ReturnValue == SOCKET_ERROR &&
                (ErrorCode == WSAEHOSTUNREACH || ErrorCode == WSAENETUNREACH))
            {
                if (!RetryConnect) {
                    //
                    // We preserve the original error
                    // so we can return it in case the
                    // second call to WSPConnect() fails
                    // also.
                    //
                    SavedErrorCode = ErrorCode;
                    //
                    // Only one retry per connect attempt.
                    //
                    RetryConnect = TRUE;
                    if (WSAttemptAutodialAddr(name, namelen))
                        goto retry;
                }
                else
                    ErrorCode = SavedErrorCode;
            }
#endif // RASAUTODIAL
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    //
    // If this is a 1.x application and the service provider
    // failed the request with WSAEALREADY, map the error code
    // to WSAEINVAL to be consistent with MS's WinSock 1.1
    // implementations.
    //

    if( ErrorCode == WSAEALREADY &&
        Process->GetMajorVersion() == 1 ) {
        ErrorCode = WSAEINVAL;
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
getpeername(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT int FAR * namelen
    )
/*++
Routine Description:

    Get the address of the peer to which a socket is connected.

Arguments:

    s       - A descriptor identifying a connected socket.

    name    - The structure which is to receive the name of the peer.

    namelen - A pointer to the size of the name structure.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetPeerName(s,
                                                   name,
                                                   namelen,
                                                   &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
getsockname(
    IN SOCKET s,
    OUT struct sockaddr FAR *name,
    OUT int FAR * namelen
    )
/*++
Routine Description:

    Get the local name for a socket.

Arguments:

    s       - A descriptor identifying a bound socket.

    name    - Receives the address (name) of the socket.

    namelen - The size of the name buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetSockName(s,
                                                   name,
                                                   namelen,
                                                   &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
getsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR *optlen
    )
/*++
Routine Description:

    Retrieve a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include   SOL_SOCKET   and  IPPROTO_TCP.   (See  annex  for  more
              protocol-specific levels.)

    optname - The socket option for which the value is to be retrieved.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is to be returned.

    optlen  - A pointer to the size of the optval buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;
    WSAPROTOCOL_INFOW   ProtocolInfoW;
    char FAR *          SavedOptionValue = NULL;
    int                 SavedOptionLen = 0;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS) {
        //
        // SO_OPENTYPE hack-o-rama.
        //

        if( level == SOL_SOCKET && optname == SO_OPENTYPE ) {
            __try {
                if( optlen == NULL || *optlen < sizeof(INT) ) {
                    SetLastError( WSAEFAULT );
                    return SOCKET_ERROR;
                }

                *((LPINT)optval) = Thread->GetOpenType();
                *optlen = sizeof(INT);
                return ERROR_SUCCESS;
            }
            __except (WS2_EXCEPTION_FILTER()) {
                SetLastError (WSAEFAULT);
                return SOCKET_ERROR;
            }
        }

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();

            //
            // If we managed to lookup the provider from the socket, and the
            // user is asking for the ANSI WSAPROTOCOL_INFOA information,
            // then validate their option length parameter, remember this fact,
            // and map the option name to SO_PROTOCOL_INFOW.
            //

            if( level == SOL_SOCKET &&
                optname == SO_PROTOCOL_INFOA ) {

                __try {
                    if( optval == NULL ||
                        optlen == NULL ||
                        *optlen < sizeof(WSAPROTOCOL_INFOA) ) {

                        * optlen = sizeof(WSAPROTOCOL_INFOA);
                        Socket->DropDSocketReference();
                        SetLastError (WSAEFAULT);
                        return (SOCKET_ERROR);
                    }


                    SavedOptionLen = *optlen;
                    *optlen = sizeof(WSAPROTOCOL_INFOW);
                    SavedOptionValue = optval;
                    optval = (char FAR *)&ProtocolInfoW;
                    optname = SO_PROTOCOL_INFOW;
                }
                __except (WS2_EXCEPTION_FILTER()) {
                    ErrorCode = WSAEFAULT;
                    Socket->DropDSocketReference();
                    goto ErrorExit;
                }
            }

            ReturnValue = Provider->WSPGetSockOpt(s,
                                                  level,
                                                  optname,
                                                  optval,
                                                  optlen,
                                                  &ErrorCode);

            Socket->DropDSocketReference();
            if( ReturnValue == ERROR_SUCCESS ) {
                if (SavedOptionValue == NULL ) {
                    return ReturnValue;
                }
                else {
                    //
                    // We successfully retrieved the UNICODE WSAPROTOCOL_INFOW
                    // structure. Now just map it to ANSI.
                    //

                    ErrorCode = MapUnicodeProtocolInfoToAnsi(
                        &ProtocolInfoW,
                        (LPWSAPROTOCOL_INFOA)SavedOptionValue
                        );
                    __try {
                        *optlen = SavedOptionLen;
                    }
                    __except (WS2_EXCEPTION_FILTER()) {
                        ErrorCode = WSAEFAULT;
                    }

                    if (ErrorCode==ERROR_SUCCESS) {
                        return ReturnValue;
                    }
                }
            }
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

ErrorExit:
    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}



int WSAAPI
listen(
    IN SOCKET s,
    IN int backlog
    )
/*++
Routine Description:

    Establish a socket to listen for incoming connection.

Arguments:

    s       - A descriptor identifying a bound, unconnected socket.

    backlog - The  maximum length to which the queue of pending connections may
              grow.   If  this  value is SOMAXCONN, then the underlying service
              provider  responsible  for  socket  s  will  set the backlog to a
              maximum reasonable value.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode == ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPListen(s,
                                              backlog,
                                              &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}




int WSAAPI
setsockopt(
    IN SOCKET s,
    IN int level,
    IN int optname,
    IN const char FAR * optval,
    IN int optlen
    )
/*++
Routine Description:

    Set a socket option.

Arguments:

    s       - A descriptor identifying a socket.

    level   - The  level  at  which the option is defined; the supported levels
              include SOL_SOCKET and IPPROTO_TCP.

    optname - The socket option for which the value is to be set.

    optval  - A  pointer  to  the  buffer  in which the value for the requested
              option is supplied.

    optlen  - The size of the optval buffer.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/

{
    INT                 ReturnValue;
    PDTHREAD            Thread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode == ERROR_SUCCESS) {
        //
        // SO_OPENTYPE hack-o-rama.
        //

        if( level == SOL_SOCKET && optname == SO_OPENTYPE ) {
            INT openType;
            if( optlen < sizeof(INT) ) {
                SetLastError( WSAEFAULT );
                return SOCKET_ERROR;
            }

            __try {
                openType = *((LPINT)optval);
            }
            __except (WS2_EXCEPTION_FILTER()) {
                SetLastError (WSAEFAULT);
                return SOCKET_ERROR;
            }

            Thread->SetOpenType( openType );
            return ERROR_SUCCESS;
        }

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSetSockOpt(s,
                                                  level,
                                                  optname,
                                                  optval,
                                                  optlen,
                                                  &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
shutdown(
    IN SOCKET s,
    IN int how
    )
/*++
Routine Description:

    Disable sends and/or receives on a socket.

Arguments:

     s   - A descriptor identifying a socket.

     how - A  flag  that  describes  what  types of operation will no longer be
           allowed.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPShutdown(s,
                                                how,
                                                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSAConnect(
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen,
    IN LPWSABUF lpCallerData,
    OUT LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS
    )
/*++
Routine Description:

    Establish a connection to a peer, exchange connect data, and specify needed
    quality of service based on the supplied flow spec.

Arguments:

    s            - A descriptor identifying an unconnected socket.

    name         - The name of the peer to which the socket is to be connected.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during connection establishment.

    lpCalleeData - A  pointer  to  the user data that is to be transferred back
                   from the peer during connection establishment.

    lpSQOS       - A pointer to the flow spec for socket s.

    lpGQOS       - A  pointer  to  the  flow  spec  for  the  socket  group (if
                   applicable).

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().

--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPConnect(s,
                                               name,
                                               namelen,
                                               lpCallerData,
                                               lpCalleeData,
                                               lpSQOS,
                                               lpGQOS,
                                               &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSAEnumNetworkEvents(
    IN SOCKET s,
    IN WSAEVENT hEventObject,
    IN LPWSANETWORKEVENTS lpNetworkEvents
    )
/*++
Routine Description:

    Discover occurrences of network events for the indicated socket.

Arguments:
     s               - A descriptor identifying the socket.

     hEventObject    - An  optional  handle  identifying  an  associated  event
                       object to be reset.

     lpNetworkEvents - A  pointer  to a WSANETWORKEVENTS struct which is filled
                       with  a  record  of  occurred  network  events  and  any
                       associated error codes.

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetLastError().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPEnumNetworkEvents(s,
                                                         hEventObject,
                                                         lpNetworkEvents,
                                                         &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



BOOL WSAAPI
WSAGetOverlappedResult(
    IN SOCKET s,
    IN LPWSAOVERLAPPED lpOverlapped,
    OUT LPDWORD lpcbTransfer,
    IN BOOL fWait,
    OUT LPDWORD lpdwFlags
    )
/*++
Routine Description:

    Returns the results of an overlapped operation on the specified socket.

Arguments:
    s            - Identifies  the  socket.   This  is the same socket that was
                   specified  when  the  overlapped  operation was started by a
                   call to WSARecv(), WSARecvFrom(), WSASend(), WSASendTo(), or
                   WSAIoctl().

    lpOverlapped - Points  to a WSAOVERLAPPED structure that was specified when
                   the overlapped operation was started.

    lpcbTransfer - Points  to  a  32-bit  variable  that receives the number of
                   bytes  that  were  actually transferred by a send or receive
                   operation, or by WSAIoctl().

    fWait        - Specifies  whether  the function should wait for the pending
                   overlapped  operation  to  complete.   If TRUE, the function
                   does  not return until the operation has been completed.  If
                   FALSE  and  the  operation  is  still  pending, the function
                   returns  FALSE  and  the  WSAGetLastError() function returns
                   WSA_IO_INCOMPLETE.

    lpdwFlags    - Points  to  a  32-bit variable that will receive one or more
                   flags   that  supplement  the  completion  status.   If  the
                   overlapped   operation   was   initiated  via  WSARecv()  or
                   WSARecvFrom(), this parameter will contain the results value
                   for lpFlags parameter.

Returns:

     If  the  function succeeds, the return value is TRUE.  This means that the
     overlapped  operation  has  completed  and  that  the  value pointed to by
     lpcbTransfer    has   been   updated.    The   application   should   call
     WSAGetLastError() to obtain any error status for the overlapped operation.
     If  the function fails, the return value is FALSE.  This means that either
     the overlapped operation has not completed or that completion status could
     not  be  determined  due to errors in one or more parameters.  On failure,
     the   value   pointed  to  by  lpcbTransfer  will  not  be  updated.   Use
     WSAGetLastError() to determine the cause of the failure.

--*/
{
    BOOL                ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        //
        // Handle may have been closed before overlapped operation
        // completed, avoid exporting it from another process/provider.
        // After all, it is almost impossible to do overlapped operation
        // in one process and get the result in another.
        //
        Socket = DSOCKET::GetCountedDSocketFromSocketNoExport (s);
        if(Socket != NULL){
            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPGetOverlappedResult(
                s,
                lpOverlapped,
                lpcbTransfer,
                fWait,
                lpdwFlags,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue)
                return ReturnValue;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\spinst64.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    64_32.cpp

Abstract:


Author:

Revision History:

--*/

#include "precomp.h"
#ifdef _WIN64
#define _WIN64_32
#include "spinstal.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\sputil.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    sputil.cpp

Abstract:

    This  module  contains the implementation of the utility functions provided
    to   winsock   service  providers.   This  module  contains  the  following
    functions.

    WPUCloseEvent
    WPUCreateEvent
    WPUResetEvent
    WPUSetEvent
    WPUQueryBlockingCallback
    WSCGetProviderPath

Author:

    Dirk Brandewie (dirk@mink.intel.com) 20-Jul-1995

Notes:

    $Revision:   1.21  $

    $Modtime:   08 Mar 1996 00:45:22  $


Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h. Added
        some trace code
--*/


#include "precomp.h"


PWINSOCK_POST_ROUTINE SockPostRoutine = NULL;


BOOL WSPAPI
WPUCloseEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Closes an open event object handle.

Arguments:

    hEvent  - Identifies an open event object handle.

    lpErrno - A pointer to the error code.

Returns:

    If the function succeeds, the return value is TRUE.

--*/
{
    BOOL ReturnCode;

    ReturnCode = CloseHandle(hEvent);
    if (!ReturnCode) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnCode);
}



WSAEVENT WSPAPI
WPUCreateEvent(
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Create a new event object.

Arguments:

    lpErrno - A pointer to the error code.

Returns:

    If  the  function  succeeds,  the  return  value is the handle of the event
    object.

    If the function fails, the return value is WSA_INVALID_EVENT and a specific
    error code is available in lpErrno.

--*/
{
    HANDLE ReturnValue;

    ReturnValue = CreateEvent(NULL, // default security
                              TRUE, // manual reset
                              FALSE, // nonsignalled state
                              NULL); // anonymous
    if (NULL == ReturnValue) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnValue);
}




int WSPAPI
WPUQueryBlockingCallback(
    IN DWORD dwCatalogEntryId,
    OUT LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    OUT PDWORD_PTR lpdwContext,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Returns a pointer to a callback function the service probider should invoke
    periodically while servicing blocking operations.

Arguments:

    dwCatalogEntryId - Identifies the calling service provider.

    lplpfnCallback   - Receives a pointer to the blocking callback function.

    lpdwContext      - Receives  a context value the service provider must pass
                       into the blocking callback.

    lpErrno          - A pointer to the error code.

Returns:

    If  the function succeeds, it returns ERROR_SUCCESS.  Otherwise, it returns
    SOCKET_ERROR and a specific error code is available in the location pointed
    to by lpErrno.
--*/
{
    int                  ReturnValue;
    INT                  ErrorCode;
    LPBLOCKINGCALLBACK   callback_func = NULL;
    PDTHREAD             Thread;
    PDPROCESS            Process;
    DWORD_PTR            ContextValue  = 0;
    PDCATALOG            Catalog;

    assert(lpdwContext);
    assert(lpErrno);

    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == ERROR_SUCCESS) {
        callback_func = Thread->GetBlockingCallback();

        if( callback_func != NULL ) {
            PPROTO_CATALOG_ITEM  CatalogItem;
            PDPROVIDER           Provider;

            Catalog = Process->GetProtocolCatalog();
            assert(Catalog);
            ErrorCode = Catalog->GetCountedCatalogItemFromCatalogEntryId(
                dwCatalogEntryId,  // CatalogEntryId
                & CatalogItem);    // CatalogItem
            if (ERROR_SUCCESS == ErrorCode) {

                Provider = CatalogItem->GetProvider();
                assert(Provider);
                ContextValue = Provider->GetCancelCallPtr();
                CatalogItem->Dereference ();
            } //if
        } //if
    } //if

    if (ERROR_SUCCESS == ErrorCode) {
        ReturnValue = ERROR_SUCCESS;
    }
    else {
        ReturnValue = SOCKET_ERROR;
        callback_func = NULL;
    } //if

    // Set the out parameters.
    *lpdwContext = ContextValue;
    *lpErrno = ErrorCode;
    *lplpfnCallback = callback_func;

    return(ReturnValue);
}




int WSPAPI
WPUQueueApc(
    IN LPWSATHREADID lpThreadId,
    IN LPWSAUSERAPC lpfnUserApc,
    IN DWORD_PTR dwContext,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Queues  a  user-mode  APC  to  the  specified thread in order to facilitate
    invocation of overlapped I/O completion routines.

Arguments:

    lpThreadId  - A  pointer  to  a  WSATHREADID  structure that identifies the
                  thread  context.   This  is typically supplied to the service
                  provider  by  the  WinSock  DLL  as  in input parameter to an
                  overlapped operation.

    lpfnUserApc - Points to the APC function to be called.


    dwContext   - A  32  bit context value which is subsequently supplied as an
                  input parameter to the APC function.

    lpErrno     - A pointer to the error code.

Returns:

    If  no  error  occurs,  WPUQueueApc()  returns  0 and queues the completion
    routine  for the specified thread.  Otherwise, it returns SOCKET_ERROR, and
    a specific error code is available in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetAsyncHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
    {
        ErrorCode = (INT) WahQueueUserApc(HelperHandle,
                                           lpThreadId,
                                           lpfnUserApc,
                                           dwContext);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}


int
WSPAPI
WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
)
/*++
Routine Description:

    This function simmulates completion of overlapped IO request
    on socket handle created for non-IFS providers

Arguments:

    s            - socket handle to complete request on
    lpOverlapped - pointer to overlapped structure
    dwError      - WinSock 2.0 error code for opreation being completed
    cbTransferred- number of bytes transferred to/from user buffers as the
                    result of the operation being completed
    lpErrno     - A pointer to the error code.

Returns:

    If  no  error  occurs,  WPUCompleteOverlappedRequest()  returns  0 and
    completes the overlapped request as request by the application.
    Otherwise, it returns SOCKET_ERROR, and a specific error code is available
    in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetHandleHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
    {
        ErrorCode = (INT) WahCompleteRequest (HelperHandle,
                                           s,
                                           lpOverlapped,
                                           dwError,
                                           cbTransferred);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}


int WSPAPI
WPUOpenCurrentThread(
    OUT LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Opens the current thread. This is intended to be used by layered service
    providers that wish to initiate overlapped IO from non-application threads.

Arguments:

    lpThreadId  - A pointer to a WSATHREADID structure that will receive the
                  thread data.

    lpErrno     - A pointer to the error code.

Returns:

    If no error occurs, WPUOpenCurrentThread() returns 0 and the caller is
    responsible for (eventually) closing the thread by calling WPUCloseThread().
    Otherwise, WPUOpenCurrentThread() returns SOCKET_ERROR and a specific
    error code is available in lpErrno.

--*/
{
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetAsyncHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
    {
        ErrorCode = (INT) WahOpenCurrentThread(HelperHandle,
                                                lpThreadId);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}


int WSPAPI
WPUCloseThread(
    IN LPWSATHREADID lpThreadId,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Closes a thread opened via WPUOpenCurrentThread().

Arguments:

    lpThreadId  - A pointer to a WSATHREADID structure that identifies the
                  thread context.  This structure must have been initialized
                  by a previous call to WPUOpenCurrentThread().

    lpErrno     - A pointer to the error code.

Returns:

    If no error occurs, WPUCloseThread() returns 0.  Otherwise, it returns
    SOCKET_ERROR, and a specific error code is available in lpErrno.

--*/
{
    INT ReturnCode= SOCKET_ERROR;
    HANDLE HelperHandle;
    PDPROCESS Process;
    PDTHREAD Thread;
    INT      ErrorCode=0;

    // Use ProLog to fill in Process and thread pointers. Only fail if
    // there is no valid process context
    ErrorCode = PROLOG(&Process,
           &Thread);
    if (ErrorCode == WSANOTINITIALISED) {
        *lpErrno = ErrorCode;
        return(SOCKET_ERROR);
    } //if
    assert (Process!=NULL);

    ErrorCode = Process->GetAsyncHelperDeviceID(&HelperHandle);
    if (ERROR_SUCCESS == ErrorCode )
        {
        ErrorCode = (INT) WahCloseThread(HelperHandle,
                                          lpThreadId);

    } //if

    if( ErrorCode == NO_ERROR ) {
        return ERROR_SUCCESS;
    }
    else {
        *lpErrno = ErrorCode;
        return SOCKET_ERROR;
    }
}



BOOL WSPAPI
WPUResetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Resets the state of the specified event object to nonsignaled.

Arguments:

    hEvent  - Identifies an open event object handle.

    lpErrno - A pointer to the error code.

Returns:

    If the function succeeds, the return value is TRUE.  If the function fails,
    the  return  value  is  FALSE  and  a  specific  error code is available in
    lpErrno.
--*/
{
    BOOL ReturnCode;

    ReturnCode = ResetEvent(hEvent);
    if (FALSE == ReturnCode) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnCode);
}




BOOL WSPAPI
WPUSetEvent(
    IN WSAEVENT hEvent,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Sets the state of the specified event object to signaled.

Arguments:

    hEvent  - Identifies an open event object handle.

    lpErrno - A pointer to the error code.

Returns:

    If the function succeeds, the return value is TRUE.  If the function fails,
    the  return  value  is  FALSE  and  a  specific  error code is available in
    lpErrno.
--*/
{
    BOOL ReturnCode;

    ReturnCode = SetEvent(hEvent);
    if (FALSE == ReturnCode) {
        *lpErrno = GetLastError();
    } //if
    return(ReturnCode);
}


BOOL
WINAPI
WPUPostMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PWINSOCK_POST_ROUTINE   sockPostRoutine;
    sockPostRoutine = GET_SOCK_POST_ROUTINE ();
    if (sockPostRoutine==NULL)
        return FALSE;

    //
    // Special post routine works only for 16 bit apps.
    // It assumes that message is in HIWORD of Msg and LOWORD
    // is an index that tells it what post routine to call
    // (so it can properly map parameters for async name resolution).
    // If layered provider did its own async select and used its own
    // message and window in the context of 16 bit process it will simply
    // crash when processing message posted by the base provider. Grrr...
    //
    // So in the code below we try our best to figure out if message is
    // directed not to application but to layered provider window.
    //
    if (sockPostRoutine!=PostMessage) {
        PDSOCKET    Socket = DSOCKET::GetCountedDSocketFromSocketNoExport((SOCKET)wParam);
        BOOL        apiSocket;
        if (Socket!=NULL) {
            apiSocket = Socket->IsApiSocket();
            Socket->DropDSocketReference ();
            if (!apiSocket) {
                //
                // We use delayload option with user32.dll, hence
                // the exception handler here.
                //
                __try {
                    return PostMessage (hWnd, Msg, wParam, lParam);
                }
                __except (WS2_EXCEPTION_FILTER()) {
                    return FALSE;
                }
            }
        }
    }

    return (sockPostRoutine)( hWnd, Msg, wParam, lParam );
}   // WPUPostMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\send.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    Send.cpp

Abstract:

    This module contains the winsock API entrypoints for transmitting data.

Author:

    Dirk Brandewie dirk@mink.intel.com  14-06-1995

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes into precomp.h. Reworked
        entirre file to conform to coding standard.

    Mark Hamilton mark_hamilton@ccm.jf.intel.com 18-07-1995
        Implemented all functions.


--*/

#include "precomp.h"



int WSAAPI
send(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags
    )
/*++
Routine Description:

    Send data on a connected socket.

Arguments:

    s     - A descriptor identifying a connected socket.

    buf   - A buffer containing the data to be transmitted.

    len   - The length of the data in buf.

    flags - Specifies the way in which the call is made.

Returns:

    The  total  number  of  bytes  sent.  Otherwise, a value of SOCKET_ERROR is
    returned, and the error code is stored with SetLastError().

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;


	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT           ReturnValue;
            PDPROVIDER    Provider;
            WSABUF        Buffer;
            DWORD         BytesSent;

            Buffer.len = len;
            Buffer.buf = (char*)buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSend(s,
                                            &Buffer,
                                            1,
                                            &BytesSent,
                                            (DWORD)flags,
                                            NULL,               // lpOverlapped
                                            NULL,               // lpCompletionRoutine
                                            Thread->GetWahThreadID(),
                                            &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return (INT)BytesSent;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} //send



int WSAAPI
sendto (
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags,
    IN const struct sockaddr FAR *to,
    IN int tolen
    )
/*++
Routine Description:

    Send data to a specific destination.

Arguments:

    s     - A descriptor identifying a socket.

    buf   - A buffer containing the data to be transmitted.

    len   - The length of the data in buf.

    flags - Specifies the way in which the call is made.

    to    - An optional pointer to the address of the target socket.

    tolen - The size of the address in to.

Returns:

    The  total  number  of  bytes  sent.  Otherwise, a value of SOCKET_ERROR is
    returned, and the error code is stored with SetLastError().

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT             ReturnValue;
            PDPROVIDER      Provider;
            WSABUF          Buffers;
            DWORD           BytesSent;

            Buffers.len = len;
            Buffers.buf = (char*)buf;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSendTo(s,
                                &Buffers,
                                1,
                                &BytesSent,
                                (DWORD)flags,
                                to,
                                tolen,
                                NULL,                   // lpOverlapped
                                NULL,                   // lpCompletionRoutine
                                Thread->GetWahThreadID(),
                                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return (INT)BytesSent;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
} // End of sendTo



int WSAAPI
WSASend(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Send data on a connected socket.

Arguments:

    s                   - A descriptor identifying a connected socket.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          the length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call if
                          the I/O operation completes immediately.

    dwFlags             - Specifies the way in which the call is made.

    lpOverlapped        - A  pointer  to a WSAOVERLAPPED structure (ignored for
                          non-overlapped sockets).

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send   operation  has  been  completed  (ignored  for
                          non-overlapped sockets).

Returns:

    If  no  error  occurs  and  the  send  operation has completed immediately,
    WSASend() returns 0.  Otherwise, a value of SOCKET_ERROR is returned, and a
    specific  error  code  may  be retrieved by calling WSAGetLastError().  The
    error  code WSA_IO_PENDING indicates that the overlapped operation has been
    successfully  initiated  and  that  completion will be indicated at a later
    time.  Any other error code indicates that the overlapped operation was not
    successfully  initiated  and  no  completion indication will occur.  If the
    MSG_INTERRUPT  flag  is set, the meaning of the return value is changed.  A
    value  of  zero  indicates  success  and is interpreted as described above.
    Otherwise,  the  return  value  will directly contain the appropriate error
    code.  Note that this is applicable only to Win16 environments and only for
    protocols that have the XP1_INTERRUPT bit set in the WSAPROTOCOL_INFO
    struct.

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                ReturnValue;
            PDPROVIDER         Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSend(s,
                                            lpBuffers,
                                            dwBufferCount,
                                            lpNumberOfBytesSent,
                                            dwFlags,
                                            lpOverlapped,
                                            lpCompletionRoutine,
                                            Thread->GetWahThreadID(),
                                            &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSASendDisconnect(
    IN SOCKET s,
    OUT LPWSABUF lpOutboundDisconnectData
    )
/*++
Routine Description:

    Initiate termination of the connection for the socket.

Arguments:

    s                        - A descriptor identifying a socket.

    lpOutboundDisconnectData - A pointer to the outgoing disconnect data.

Returns:

    ERROR_SUCCESS  on  success  else  SOCKET_ERROR.   The  error  code
    is  stored  with SetLastError().

--*/
{
    INT                ErrorCode;
    PDSOCKET           Socket;

    ErrorCode = TURBO_PROLOG();
    if (ErrorCode==ERROR_SUCCESS) {

        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                ReturnValue;
            PDPROVIDER         Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSendDisconnect(
                s,
                lpOutboundDisconnectData,
                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ERROR_SUCCESS;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}



int WSAAPI
WSASendTo(
    IN SOCKET s,
    IN LPWSABUF lpBuffers,
    IN DWORD dwBufferCount,
    OUT LPDWORD lpNumberOfBytesSent,
    IN DWORD dwFlags,
    IN const struct sockaddr * lpTo,
    IN int iTolen,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
/*++
Routine Description:

    Send data to a specific destination, using overlapped I/O where
    applicable.

Arguments:


    s                   - A descriptor identifying a connected socket which was
                          created      using      WSASocket()     with     flag
                          WSA_FLAG_OVERLAPPED.

    lpBuffers           - A  pointer  to  an  array of WSABUF structures.  Each
                          WSABUF  structure  contains a pointer to a buffer and
                          thee length of the buffer.

    dwBufferCount       - The  number  of  WSABUF  structures  in the lpBuffers
                          array.

    lpNumberOfBytesSent - A pointer to the number of bytes sent by this call if
                          the I/O operation completes immediately.

    dwFlags             - Specifies the way in which the call is made.

    lpTo                - An  optional  pointer  to  the  address of the target
                          socket.

    iToLen              - The size of the address in lpTo.

    lpOverlapped        - A  pointer  to a WSAOVERLAPPED structure (ignored for
                          non-overlapped sockets).

    lpCompletionRoutine - A  pointer  to the completion routine called when the
                          send   operation  has  been  completed  (ignored  for
                          non-overlapped sockets).

Returns:

    If the function completes successfully, it returns ERROR_SUCCESS, otherwise
    it returns SOCKET_ERROR.

--*/
{
    PDSOCKET           Socket;
    INT                ErrorCode;
    PDTHREAD           Thread;

	ErrorCode = TURBO_PROLOG_OVLP(&Thread);
    if (ErrorCode==ERROR_SUCCESS)
    {
        Socket = DSOCKET::GetCountedDSocketFromSocket(s);
        if(Socket != NULL){
            INT                ReturnValue;
            PDPROVIDER         Provider;

            Provider = Socket->GetDProvider();
            ReturnValue = Provider->WSPSendTo(s,
                                lpBuffers,
                                dwBufferCount,
                                lpNumberOfBytesSent,
                                dwFlags,
                                lpTo,
                                iTolen,
                                lpOverlapped,
                                lpCompletionRoutine,
                                Thread->GetWahThreadID(),
                                &ErrorCode);
            Socket->DropDSocketReference();
            if (ReturnValue==ERROR_SUCCESS)
                return ReturnValue;
            assert (ErrorCode!=NO_ERROR);
            if (ErrorCode==NO_ERROR)
                ErrorCode = WSASYSCALLFAILURE;
        }
        else {
            ErrorCode = WSAENOTSOCK;
        }
    }

    SetLastError(ErrorCode);
    return SOCKET_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\socklife.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    socklife.c

Abstract:

    This module contains the Winsock API functions concerned with socket
    lifetime. The following API functions are contained in this module.

    socket()
    WSASocketA()
    WSASocketW()
    accept()
    WSAAccept()
    WPUCreateSocketHandle()
    WPUCloseSocketHandle
    WPUQuerySocketHandleContext
    WPUModifyIFSHandle
    WSAJoinLeaf()
    closesocket()

Author:

    dirk@mink.intel.com  14-06-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review. Moved includes to precomp.h. Added
        asserts for debugging
--*/

#include "precomp.h"
#pragma hdrstop
#include <wsipx.h>
#include <wsnwlink.h>
#include <atalkwsh.h>

#define NSPROTO_MAX (NSPROTO_IPX + 255)


SOCKET WSAAPI
socket(
    IN int af,
    IN int type,
    IN int protocol)
/*++
Routine Description:

     Create a socket which is bound to a specific service provider.

Arguments:
    af - An address family specification.  The
         only format currently supported is
         PF_INET, which is the ARPA Internet
         address format.

    type - A type specification for the new socket.

    protocol- A particular protocol to be used with
              the socket, or 0 if the caller does not
              wish to specify a protocol.

Returns:
    A socket descriptor referencing the new socket. Otherwise, a value
    of INVALID_SOCKET is returned and the error code is stored with
    SetErrorCode.
--*/
{
    PDTHREAD  Thread;
    INT       ErrorCode;
    DWORD     dwFlags;

    ErrorCode = TURBO_PROLOG_OVLP(
        &Thread);

    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(INVALID_SOCKET);
    } //if

    if( Thread->GetOpenType() == 0 ) {
        dwFlags = WSA_FLAG_OVERLAPPED;
    } else {
        dwFlags = 0;
    }

    //
    // HACK for NetBIOS!
    //

    if( af == AF_NETBIOS && protocol > 0 ) {
        protocol *= -1;
    }

    return(WSASocketW(
        af,
        type,
        protocol,
        NULL,      // lpProtocolInfo
        0,         // g
        dwFlags));
}

SOCKET WSAAPI
WSASocketW (
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags)
/*++
Routine Description:

    Create  a  socket  which is bound to a specific transport service provider,
    optionally create and/or join a socket group.

Arguments:

    af             - An   address   family   specification.   The  only  format
                     currently supported is PF_INET, which is the ARPA Internet
                     address format.

    type           - A type specification for the new socket.

    protocol       - A  particular protocol to be used with the socket, or 0 if
                     the caller does not wish to specify a protocol.

    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFOW struct that defines the
                     characteristics  of  the  socket  to  be created.  If this
                     parameter  is  not  NULL,  the first three parameters (af,
                     type, protocol) are ignored.

     g             - The identifier of the socket group.

     dwFlags       - The socket attribute specification.


Returns:

    A  socket  descriptor  referencing  the  new socket.  Otherwise, a value of
    INVALID_SOCKET is returned and the error code is stored with SetErrorCode.
--*/
{
    SOCKET              ReturnValue;
    PDPROCESS           Process;
    PDTHREAD            CurrentThread;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDCATALOG           Catalog;
    PPROTO_CATALOG_ITEM CatalogEntry;
    LPWSAPROTOCOL_INFOW ProtocolInfo;
    DWORD               dwCatalogId;

    ErrorCode = PROLOG(
        &Process,
        &CurrentThread);

    if (ErrorCode != ERROR_SUCCESS) {
        SetLastError(ErrorCode);
        return(INVALID_SOCKET);
        } //if

    //Set Default return code
    ReturnValue = INVALID_SOCKET;

    // Find a provider that can support the user request
    Catalog = Process->GetProtocolCatalog();

    if (lpProtocolInfo) {

        __try {
            dwCatalogId =  lpProtocolInfo->dwCatalogEntryId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SetLastError(WSAEFAULT);
            return(INVALID_SOCKET);
        }
        ErrorCode =  Catalog->GetCountedCatalogItemFromCatalogEntryId(
            dwCatalogId,
            &CatalogEntry);
    } //if
    else {
        dwCatalogId = 0;

RestartCatalogLookupHack:

        ErrorCode = Catalog->GetCountedCatalogItemFromAttributes(
            af,
            type,
            protocol,
            dwCatalogId,
            &CatalogEntry
            );

        //
        // If we failed to find a provider, try to reload the catalog
        // from the registry and retry the lookup. This handles the
        // case (first noticed in CAIRO SETUP) where WS2_32.DLL is loaded
        // and WSAStartup() is called *before* CAIRO SETUP has had the
        // opportunity to install the necessary providers. Later, CAIRO
        // SETUP needs to create sockets.
        //
        // Do not need this anymore, we now support dynamic notifications
        // of protocol installation/removal and check for changes every
        // time we access the catalog.
        //

    } // else choosing from attributes

    if ( ERROR_SUCCESS == ErrorCode) {

        Provider = CatalogEntry->GetProvider();
        if (lpProtocolInfo) {
            // Must  be  sure  we  use  the  client's lpProtocolInfo if one was
            // supplied, to support the WSADuplicateSocket model.
            ProtocolInfo = lpProtocolInfo;
        } //if
        else {
            ProtocolInfo = CatalogEntry->GetProtocolInfo();
        } //else

        assert(ProtocolInfo != NULL);

        //
        // Hack-O-Rama. Temporary set the open type of the thread
        // depending on the overlapped flag so that we can create
        // appropriate socket handle for the layered service
        // provider.  However, if layered service provide caches
        // the handles we create for it, not much we can do.
        //
        {
            INT oldOpenType = CurrentThread->GetOpenType ();
            CurrentThread->SetOpenType ((dwFlags & WSA_FLAG_OVERLAPPED) ? 0 : SO_SYNCHRONOUS_NONALERT);

            // Now we have a provider that can support the user
            // request lets ask get a socket
            ReturnValue = Provider->WSPSocket(
                af,
                type,
                protocol,
                ProtocolInfo,
                g,
                dwFlags,
                &ErrorCode);

            //
            // Reset saved open type
            //
            CurrentThread->SetOpenType (oldOpenType);
        }

        //
        // Hack-O-Rama. If WSPSocket() failed with the distinguished
        // error code WSAEINPROGRESS *and* this was not a request for a
        // specific provider (i.e. lpProtocolInfo == NULL) then
        // restart the catalog lookup starting at the current item
        // (the current catalog id).
        //

        //
        // Snap the catalog id and dereference the catalog entry
        //
        dwCatalogId = ProtocolInfo->dwCatalogEntryId;
        CatalogEntry->Dereference ();

        if( ReturnValue == INVALID_SOCKET &&
                ErrorCode == WSAEINPROGRESS &&
                lpProtocolInfo == NULL ) {
            goto RestartCatalogLookupHack;
        }

        if( ReturnValue != INVALID_SOCKET ) {
            DSOCKET::AddSpecialApiReference( ReturnValue );
            return ReturnValue;
        }
    } //if

    assert (ErrorCode!=ERROR_SUCCESS);
    // There was an error, set this threads lasterror
    SetLastError(ErrorCode);
    return(INVALID_SOCKET);
}


SOCKET WSAAPI
WSASocketA (
    IN int af,
    IN int type,
    IN int protocol,
    IN LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN GROUP g,
    IN DWORD dwFlags)
/*++

Routine Description:

    ANSI thunk to WSASocketW.

Arguments:

    af             - An   address   family   specification.   The  only  format
                     currently supported is PF_INET, which is the ARPA Internet
                     address format.

    type           - A type specification for the new socket.

    protocol       - A  particular protocol to be used with the socket, or 0 if
                     the caller does not wish to specify a protocol.

    lpProtocolInfo - A pointer to a WSAPROTOCOL_INFOA struct that defines the
                     characteristics  of  the  socket  to  be created.  If this
                     parameter  is  not  NULL,  the first three parameters (af,
                     type, protocol) are ignored.

     g             - The identifier of the socket group.

     dwFlags       - The socket attribute specification.


Returns:

    A  socket  descriptor  referencing  the  new socket.  Otherwise, a value of
    INVALID_SOCKET is returned and the error code is stored with SetErrorCode.
--*/
{

    INT                 error;
    WSAPROTOCOL_INFOW   ProtocolInfoW;

    //
    // Map the ANSI WSAPROTOCOL_INFOA structure to UNICODE.
    //

    if( lpProtocolInfo != NULL ) {

        error = MapAnsiProtocolInfoToUnicode(
                    lpProtocolInfo,
                    &ProtocolInfoW
                    );

        if( error != ERROR_SUCCESS ) {

            SetLastError( error );
            return INVALID_SOCKET;

        }

    }

    //
    // Call through to the UNICODE version.
    //

    return WSASocketW(
               af,
               type,
               protocol,
               lpProtocolInfo
                    ? &ProtocolInfoW
                    : NULL,
               g,
               dwFlags
               );

}   // WSASocketA




SOCKET WSAAPI
accept(
    IN SOCKET s,
    OUT struct sockaddr FAR *addr,
    OUT int FAR *addrlen
    )
/*++
Routine Description:

    Accept a connection on a socket.

Arguments:

    s - A descriptor identifying a socket which is listening for connections
        after a listen().

    addr - An optional pointer to a buffer which receives the address of the
           connecting entity, as known to the communications layer.  The exact
           format of the addr argument is determined by the address family
           established when the socket was  created.

    addrlen - An optional pointer to an integer which contains the length of
              the address addr.

Returns:
    A descriptor for the accepted socket. Otherwise, a value of INVALID_SOCKET
    is returned and the error code is stored with SetErrorCode.
--*/
{
    return(WSAAccept(
        s,
        addr,
        addrlen,
        NULL,   // No condition function
        NULL)); //No callback data
}





SOCKET WSAAPI
WSAAccept(
    IN SOCKET s,
    OUT struct sockaddr FAR *addr,
    OUT LPINT addrlen,
    IN LPCONDITIONPROC lpfnCondition,
    IN DWORD_PTR dwCallbackData
    )
/*++
Routine Description:

     Conditionally accept a connection based on the return value of a
     condition function, and optionally create and/or join a socket
     group.

Arguments:

    s - A descriptor identifying a socket which is listening for connections
        after a listen().

    addr - An optional pointer to a buffer which receives the address of the
           connecting entity, as known to the communications layer. The exact
           format of the addr argument is determined by the address family
           established when the socket was  created.

    addrlen - An optional pointer to an integer which contains the length of
              the address addr.

    lpfnCondition - The procedure instance address of the optional,
                    application-supplied condition function which will make an
                    accept/reject decision based on the caller information
                    passed in as parameters, and optionally create and/or join
                    a socket group by assigning an appropriate value to the
                    result parameter g of this function.


    dwCallbackData - The callback data passed back to the application as a
                     condition function parameter.  This parameter is not
                     interpreted by WinSock.
Returns:
    A socket descriptor for the newly accepted socket on success, otherwise
    INVALID_SOCKET.
--*/
{
    SOCKET             ReturnValue;
    INT                ErrorCode;
    PDSOCKET           Socket;
    PDPROVIDER         Provider;
    PDTHREAD           CurrentThread;

    ErrorCode = TURBO_PROLOG_OVLP(&CurrentThread);

    if (ErrorCode == ERROR_SUCCESS) {

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
            //
            // Hack-O-Rama. Temporary set the open type of the thread
            // depending on the overlapped flag so that we can create
            // appropriate socket handle for the layered service
            // provider.  However, if layered service provide caches
            // the handles we create for it, not much we can do.
            //
            INT oldOpenType = CurrentThread->GetOpenType ();
            CurrentThread->SetOpenType (Socket->IsOverlappedSocket() ? 0 : SO_SYNCHRONOUS_NONALERT);

			Provider = Socket->GetDProvider();
			ReturnValue = Provider->WSPAccept(
				s,
				addr,
				addrlen,
				lpfnCondition,
				dwCallbackData,
				&ErrorCode);

            //
            // Reset saved open type
            //
            CurrentThread->SetOpenType (oldOpenType);

			Socket->DropDSocketReference();
            if( ReturnValue != INVALID_SOCKET) {
				//
				// Add a reference if the socket we got back was different
				// that the one we passed in (just in case someone
                // implements it this way which is not explicitly
                // prohibited by the specification).
				//

                if (ReturnValue != s ) {
				    DSOCKET::AddSpecialApiReference( ReturnValue );
                }
				return ReturnValue;
			}

		} //if
		else {
			ErrorCode = WSAENOTSOCK;
		}
	}

    SetLastError(ErrorCode);
    return(INVALID_SOCKET);
}




SOCKET WSPAPI
WPUCreateSocketHandle(
    IN DWORD dwCatalogEntryId,
    IN DWORD_PTR lpContext,
    OUT LPINT lpErrno )
/*++
Routine Description:

    Creates a new socket handle.

Arguments:

    dwCatalogEntryId - Indentifies the calling service provider.

    lpContext - A context value to associate with the new socket handle.

    lpErrno - A pointer to the error code.

Returns:
    A socket handle if successful, otherwise INVALID_SOCKET.
--*/
{
    SOCKET              ReturnCode=INVALID_SOCKET;
    INT                 ErrorCode=ERROR_SUCCESS;
    PDPROCESS           Process;
    PDCATALOG           Catalog;
    SOCKET              SocketID;
    HANDLE              HelperHandle;


    Process = DPROCESS::GetCurrentDProcess();
    if (Process!=NULL) {
        Catalog = Process->GetProtocolCatalog();
        if (Catalog)
        {
            PPROTO_CATALOG_ITEM CatalogEntry;

            ErrorCode = Catalog->GetCountedCatalogItemFromCatalogEntryId(
                dwCatalogEntryId,
                &CatalogEntry);

            if (ERROR_SUCCESS == ErrorCode) {
#if DBG
                if (CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES) {
                    DEBUGF(DBG_WARN,("IFS provider %ls asking for non-IFS socket handle\n",
                                        CatalogEntry->GetProtocolInfo()->szProtocol));
                }
#endif
                ErrorCode = Process->GetHandleHelperDeviceID (&HelperHandle);
                if (ErrorCode == ERROR_SUCCESS) {
                    ErrorCode = WahCreateSocketHandle (HelperHandle, &SocketID);
                    if (ErrorCode == ERROR_SUCCESS) {
                        PDSOCKET            Socket;
                        // Alloc new DSocket object
                        Socket = new(DSOCKET);
                        if (Socket) {
                            // Init the new socket
                            Socket->Initialize(CatalogEntry);

                            // Add Socket into the handle table allocated.
                            ErrorCode = Socket->AssociateSocketHandle(
                                    SocketID, // Socket handler
                                    FALSE);   // ProviderSocket
                            if (ErrorCode == ERROR_SUCCESS) {
                                //Finish putting the socket together
                                Socket->SetContext(lpContext);
                                ReturnCode = SocketID;
                            }
                            else {
                                WahCloseSocketHandle (HelperHandle, SocketID);
                                Socket->DropDSocketReference ();
                            }

                            Socket->DropDSocketReference ();
                        } // if socket was allocated
                        else {
                            WahCloseSocketHandle (HelperHandle, SocketID);
                            ErrorCode = WSAENOBUFS;
                        }
                    }
                } // Helper device was loaded OK

                CatalogEntry->Dereference ();
            } //if catalog entry found
            else
            {
                DEBUGF(DBG_ERR,("Failed to find catalog entry for provider %ld\n",
                                    dwCatalogEntryId));

            } //else
        } //if catalog is there
        else {
            ErrorCode = WSANOTINITIALISED;
        }
    } //if process is initialized
    else {
        ErrorCode = WSANOTINITIALISED;
    }

    *lpErrno = ErrorCode;
    return(ReturnCode);

} // WPUCreateSocketHandle


int WSPAPI
WPUCloseSocketHandle(
    IN SOCKET s,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Closes an exsisting socket handle.

Arguments:

    s       - Identifies a socket handle created with WPUCreateSocketHandle().

    lpErrno - A pointer to the error code.

Returns:

    Zero on success else SOCKET_ERROR.
--*/
{
    INT                 ReturnValue = ERROR_SUCCESS;
    PDPROCESS           Process;
    INT                 ErrorCode;
    PDSOCKET            Socket;
    HANDLE              HandleHelper;

    assert(lpErrno);

	Process = DPROCESS::GetCurrentDProcess ();
	if (Process!=NULL) {


		//
		// We use the no-export version because there is no way such handle
		// can be exported anyway.
		//

		Socket = DSOCKET::GetCountedDSocketFromSocketNoExport(s);
		if (Socket!=NULL) {
			if (!Socket->IsProviderSocket()) {
				ErrorCode = Socket->DisassociateSocketHandle();
                assert (ErrorCode == ERROR_SUCCESS);
				ErrorCode = Process->GetHandleHelperDeviceID(&HandleHelper);
				if (ErrorCode==ERROR_SUCCESS) {
					ErrorCode = WahCloseSocketHandle (HandleHelper, Socket->GetSocketHandle ());
					if (ErrorCode!=ERROR_SUCCESS) {
						ReturnValue = SOCKET_ERROR;
					}
				}
				else {
					*lpErrno = ErrorCode;
					ReturnValue = SOCKET_ERROR;
				}
				//
				// Drop active reference.  IFS socket's active reference
				// is dropped in closesocket routine.
				//
				Socket->DropDSocketReference();
			}
			else {
				DEBUGF(
					DBG_ERR,
					("Foreign socket handle %p handed in by service provider for closure\n", s));
				*lpErrno = WSAEINVAL;
				ReturnValue = SOCKET_ERROR;
			}
			Socket->DropDSocketReference();
		} // if ERROR_SUCCESS
		else {
			DEBUGF(
				DBG_ERR,
				("Bad socket handle %p handed in by service provider for closure\n", s));
			*lpErrno = WSAENOTSOCK;
			ReturnValue = SOCKET_ERROR;
		}
	}
	else {
		*lpErrno = WSANOTINITIALISED;
		ReturnValue = SOCKET_ERROR;
	}

    return (ReturnValue);
}


int WSPAPI
WPUQuerySocketHandleContext(
    IN SOCKET s,
    OUT PDWORD_PTR lpContext,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Queries the context value associated with the specified socket handle.

Arguments:

    s         - Identifies the socket whose context is to be queried.

    lpContext - A pointer to an DWORD that will receive the context value.

    lpErrno   - A pointer to the error code.

Returns:

    If  no error occurs, WPUQuerySocketHandleContext() returns 0 and stores the
    current  context  value  in lpdwContext.  Otherwise, it returns
    SOCKET_ERROR, and a specific error code is available in lpErrno.
--*/
{
    INT ReturnCode=SOCKET_ERROR;
    INT ErrorCode=WSAENOTSOCK;
    PDSOCKET Socket;

    //
    // We use the no-export version because there is no way such handle
    // can be exported anyway.
    //
    Socket = DSOCKET::GetCountedDSocketFromSocketNoExport(s);
    if (Socket!=NULL) {
        if (!Socket->IsProviderSocket()) {
            *lpContext = Socket->GetContext();
            ReturnCode = ERROR_SUCCESS;
        }
        else {
            DEBUGF(
                DBG_ERR,
                ("Foreign socket handle %p handed in by service provider for query\n", s));
            *lpErrno = WSAEINVAL;
        }
        Socket->DropDSocketReference ();
    }
    else {
        DEBUGF(
            DBG_ERR,
            ("Bad socket handle %p handed in by service provider for query\n", s));
        *lpErrno = ErrorCode;
    }
    return(ReturnCode);
}



SOCKET WSPAPI
WPUModifyIFSHandle(
    IN DWORD dwCatalogEntryId,
    IN SOCKET ProposedHandle,
    OUT LPINT lpErrno
    )
/*++
Routine Description:

    Receive (possibly) modifies IFS handle from winsock DLL.

Arguments:

    dwCatalogEntryId - Identifies the calling service provider.

    ProposedHandle   - An  Installable File System(IFS) handle allocated by the
                       provider.

    lpErrno          - A pointer to the error code.

Returns:

    If  no  error  occurs,  WPUModifyIFSHandle()  returns  the  modified socket
    handle.  Otherwise, it returns INVALID_SOCKET, and a specific error code is
    available in lpErrno.
--*/
{
    SOCKET              ReturnCode=INVALID_SOCKET;
    INT                 ErrorCode=ERROR_SUCCESS;
    PDPROCESS           Process;
    PDCATALOG           Catalog;


    // Alloc new DSocket object
    Process = DPROCESS::GetCurrentDProcess();
    if (Process!=NULL) {
        Catalog = Process->GetProtocolCatalog();
        if (Catalog) {
            PPROTO_CATALOG_ITEM CatalogEntry;

            ErrorCode = Catalog->GetCountedCatalogItemFromCatalogEntryId(
                dwCatalogEntryId,
                &CatalogEntry);

            if (ERROR_SUCCESS == ErrorCode) {
                PDSOCKET            Socket;

                // Create new socket object
                Socket = new DSOCKET;

                if (Socket!=NULL) {
                    // Init the new socket
                    Socket->Initialize(CatalogEntry);

                    //
                    // Add socket to the handle table.  In this implementation, we
                    // wind up never changing the proposed IFS handle.
                    //

                    ErrorCode = Socket->AssociateSocketHandle(
                        ProposedHandle, // SocketHandle
                        TRUE);           // ProviderSocket

                    if (ErrorCode == ERROR_SUCCESS) {

                        ReturnCode = ProposedHandle;
                        *lpErrno = ERROR_SUCCESS;
                    } //if
                    else {
                        //
                        // Failed to insert into the table
                        // Remove creation reference
                        //
                        Socket->DropDSocketReference ();
                        *lpErrno = ErrorCode;
                    }

                    //
                    // Note that the new DSOCKET starts out with a ref count
                    // of two, so we'll always need to dereference it once.
                    //
                    Socket->DropDSocketReference ();

                } // if socket was created or found
                else {
                    *lpErrno = WSAENOBUFS;
                }
                CatalogEntry->Dereference ();
            } //if catalog entry was found
            else {
                DEBUGF(DBG_ERR,("Failed to find catalog entry for provider %ld\n",
                                    dwCatalogEntryId));
                *lpErrno = ErrorCode;
            }
        } //if catalog is there
        else
        {
            DEBUGF(DBG_ERR,("Failed to find Catalog object"));
            *lpErrno = WSANOTINITIALISED;

        } //else
    } //if process is initialized
    else {
        *lpErrno = WSANOTINITIALISED;
    }

    return(ReturnCode);

}  // WPUModifyIfsHandle




SOCKET WSAAPI
WSAJoinLeaf(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen,
    IN LPWSABUF lpCallerData,
    OUT LPWSABUF lpCalleeData,
    IN LPQOS lpSQOS,
    IN LPQOS lpGQOS,
    IN DWORD dwFlags
    )
/*++
Routine Description:

    Join  a  leaf  node  into  a multipoint session, exchange connect data, and
    specify needed quality of service based on the supplied flow specs.

Arguments:

    s            - A descriptor identifying an multipoint socket.

    name         - The name of the peer to which the socket is to be joined.

    namelen      - The length of the name.

    lpCallerData - A  pointer to the user data that is to be transferred to the
                   peer during multipoint session establishment.

    lpCalleeData - pointer to the user data that is to be transferred back from
                   the peer during multipoint session establishment.

    lpSQOS       - A  pointer  to  the  flow  specs  for socket s, one for each
                   direction.

    lpGQOS       - A  pointer  to  the  flow  specs  for  the  socket group (if
                   applicable).

    dwFlags      - Flags  to  indicate the socket acting as a sender, receiver,
                   or both.

Returns:
    If no error occurs, WSAJoinLeaf() returns a value of type SOCKET which is a
    descriptor  for the newly created multipoint socket.  Otherwise, a value of
    INVALID_SOCKET  is  returned, and a specific error code may be retrieved by
    calling WSAGetLastError().

--*/
{

    SOCKET             ReturnValue;
    INT                ErrorCode;
    PDPROVIDER         Provider;
    PDSOCKET           Socket;
    PDTHREAD           CurrentThread;

    ErrorCode = TURBO_PROLOG_OVLP(&CurrentThread);

    if (ErrorCode == ERROR_SUCCESS) {

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
            //
            // Hack-O-Rama. Temporary set the open type of the thread
            // depending on the overlapped flag so that we can create
            // appropriate socket handle for the layered service
            // provider.  However, if layered service provide caches
            // the handles we create for it, not much we can do.
            //
            INT oldOpenType = CurrentThread->GetOpenType ();
            CurrentThread->SetOpenType (Socket->IsOverlappedSocket() ? 0 : SO_SYNCHRONOUS_NONALERT);

            Provider = Socket->GetDProvider();
			ReturnValue = Provider->WSPJoinLeaf(
				s,
				name,
				namelen,
				lpCallerData,
				lpCalleeData,
				lpSQOS,
				lpGQOS,
				dwFlags,
				&ErrorCode);

            //
            // Reset saved open type
            //
            CurrentThread->SetOpenType (oldOpenType);

            Socket->DropDSocketReference();


			if( ReturnValue != INVALID_SOCKET) {

				//
				// Add a reference if the socket we got back was different
				// that the one we passed in (c_root cases only)
				//
				if (ReturnValue != s) {
					DSOCKET::AddSpecialApiReference( ReturnValue );
				}

				return ReturnValue;
			}

		} //if
		else {
			ErrorCode = WSAENOTSOCK;
		}
	}

    SetLastError(ErrorCode);
    return(INVALID_SOCKET);
}




int WSAAPI
closesocket(
    IN SOCKET s
    )
/*++
Routine Description:

    Close a socket.

Arguments:

    s - A descriptor identifying a socket.

Returns:
    Zero on success else SOCKET_ERROR. The error code is stored with
    SetErrorCode().
--*/
{
    INT                 ReturnValue;
    INT                 ErrorCode;
    PDPROVIDER          Provider;
    PDSOCKET            Socket;

    ErrorCode = TURBO_PROLOG();

    if (ErrorCode == ERROR_SUCCESS) {

		Socket = DSOCKET::GetCountedDSocketFromSocket(s);
		if(Socket != NULL){
			// The   actual  destruction  of  the  DSOCKET  object  closed  through
			// "closesocket"   happens  after  we  return  from  the  provider  and
			// determine  that  no  other  threads have remaining references to the
			// object.

			//
			// First, determine if this handle is for the provider socket so
			// we can clear the context table entry BEFORE closing the
			// socket. This plugs a nasty race condition where the provider
			// closes its handle and another thread creates a new socket
			// with the same handle value BEFORE the first thread manages
			// to clear the handle table entry.
			//
            // This is now handled by new context referencing functions
            // which will not clear handle table entry if it was replaced.
            //

			// if (ProviderSocket) {
			//	Socket->DisassociateSocketHandle();
			// }


			//Call the provider to close the socket.
			Provider = Socket->GetDProvider();
			ReturnValue = Provider->WSPCloseSocket( s,
												   &ErrorCode);
			if( (ReturnValue == ERROR_SUCCESS)
                    && Socket->IsProviderSocket ()){

				//
				// Remove context from the table and "active" reference
                // from the socket.
				// Non-provider generated socket active reference
                // is removed when provider destroys the handle
                // via WPUCloseSocketHandle call.
				//
				// Note the spec flow in case provider generated socket was
				// used only by the layered provider above and never
				// returned via socket/WSASocket call.  closesocket
				// is not called for such socket and we never get to
				// execute the code below. which leads to socket object
				// leak.
                //
                // It may have been replaced by another handle
                // when we call this funciton in which case
                // we do not need to drop the reference count
                // becuase it was done by whoever bumped it
                // out of the table, see comment above
                //
                if (Socket->DisassociateSocketHandle()==NO_ERROR)
                    Socket->DropDSocketReference();
			}

			//
			// Remove the reference added by GetCountedDSocketFromSocket.
			//

			Socket->DropDSocketReference();

			if( ReturnValue == ERROR_SUCCESS)
				return ReturnValue;
            //
			// The close failed. Restore the context table entry if
			// necessary.
			//
            // Don't need to do this anymore, see comment above
            //

			// if( ProviderSocket ) {
			//	if (Socket->AssociateSocketHandle(s, TRUE)!=NO_ERROR) {
					//
					// Failed to reinsert the socket into the table
					// This is the only thing we can do here.
					//
			//		assert (FALSE);
			//	}
			//}

		} // if
		else {
			ErrorCode = WSAENOTSOCK;
		}
	}

    SetLastError(ErrorCode);
    return(SOCKET_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\spinstal.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    spinstall.cpp

Abstract:

    This module contains the entry points for service provider installation and
    deinstallation.

Author:

    Paul Drews (drewsxpa@ashland.intel.com) 2-Aug-1995

Notes:

    $Revision:   1.16  $

    $Modtime:   12 Jan 1996 14:55:36  $

Revision History:

    most-recent-revision-date email-name
        description

    23-Aug-1995 dirk@mink.intel.com
        Moved includes to precomp.h

    2-Aug-1995 drewsxpa@ashland.intel.com
        Original created

--*/

#include "precomp.h"


// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when attempting to match a provider.
typedef struct {
    GUID                ProviderId;
    PPROTO_CATALOG_ITEM CatalogItem;
} GUID_MATCH_CONTEXT,  FAR * PGUID_MATCH_CONTEXT;


BOOL
GuidMatcher (
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
#ifndef _WIN64_32
/*++

Routine Description:

    This  procedure determines if ProviderId of a passed CatalogEntry matches
    a  target  provider GUID.  If so, it sets a flag to indicate that the match
    was  found  and  returns  FALSE to terminate the enumeration.  Otherwise it
    returns TRUE and the enumeration continues.

Arguments:

    PassBack     - Supplies  a  reference  to  a  GUID_MATCH_CONTEXT structure.
                    Returns catalog entry reference if it was discovered

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.

Return Value:

    If a match is found, the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE to continue the iteration.
--*/
{
    PGUID_MATCH_CONTEXT  context;

    context = (PGUID_MATCH_CONTEXT)PassBack;

    if( context->ProviderId == *(CatalogEntry->GetProviderId()) ) {
        context->CatalogItem = CatalogEntry;
        return FALSE;  // do not continue iteration
    }

    return TRUE;  // continue iteration
}  // GuidMatcher
#else
;
#endif


int
WSPAPI
#ifndef _WIN64_32
WSCInstallProvider(
#else
WSCInstallProvider64_32(
#endif
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
/*++

Routine Description:

    This   procedure   installs   the   specified   provider  into  the  system
    configuration  database.   After  this  call,  a  WinSock  2  DLL  instance
    initialized  via  a  first call to WSAStartup will return the new protocols
    from the WSAEnumProtocols function.

    It  is the caller's responsibility to perform required file installation or
    service provider specific configuration.

Arguments:

    lpProviderId        - Supplies a GUID giving the locally unique identifier
                          for the newly installed provider.

    lpszProviderDllPath - Supplies a reference to a fully qualified path to the
                          providers  DLL image.  This path may contain embedded
                          environment  strings  (such  as  %SystemRoot%).  Such
                          environment strings are expanded whenever the WinSock
                          2  DLL  needs  to  load  the provider DLL.  After any
                          embedded   environment   strings  are  expanded,  the
                          WinSock  2  DLL  passes the resulting string into the
                          LoadLibrary() API to load the provider into memory.

    lpProtocolInfoList  - Supplies a reference to an array of WSAPROTOCOL_INFOW
                          structures.      Each     structure     defines     a
                          protocol/address_family/socket_type  supported by the
                          provider.

    dwNumberOfEntries   - Supplies    the    number    of    entries   in   the
                          lpProtocolInfoList array.

    lpErrno             - Returns the error code.

Return Value:

    If no error occurs, WSCInstallProvider() returns ERROR_SUCCESS.  Otherwise,
    it  returns  SOCKET_ERROR, and a specific error code is returned in the int
    referenced by lpErrno.

Implementation Notes:

    open winsock registry
    create catalog from registry
    check provider name for uniqueness
    providerid = allocate provider id
    for each protocolinfo in list
        allocate catalog entry id
        write provider id and catalog entry id into protocol info
        create catalogitem from values
        append item to catalog
        check if item is for NonIFS provider
    end for
    enable non-IFS handle support if any NonIFS providers
    write catalog to registry
    close winsock registry
--*/
{
    int  errno_result;
    int  return_value;
    HKEY  registry_root;
    DWORD  entry_id;
    int pindex;
    WSAPROTOCOL_INFOW proto_info;
    BOOL NonIFS = FALSE;

    // objects protected by "try" block
    PDCATALOG            catalog = NULL;
    PPROTO_CATALOG_ITEM  item = NULL;
    PCHAR                provider_path = NULL;
    BOOL InstalledNonIFS = FALSE;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        * lpErrno = WSANO_RECOVERY;
        return SOCKET_ERROR;
    }

    //
    // Check the current protocol catalog key. If it doesn't match
    // the expected value, blow away the old key and update the
    // stored value.
    //

    ValidateCurrentCatalogName(
        registry_root,
        WINSOCK_CURRENT_PROTOCOL_CATALOG_NAME,
        DCATALOG::GetCurrentCatalogName()
        );

    errno_result = ERROR_SUCCESS;
    return_value = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        GUID_MATCH_CONTEXT  context;

        context.CatalogItem = NULL;
        __try {
            context.ProviderId = *lpProviderId;
            provider_path = ansi_dup_from_wcs((LPWSTR)lpszProviderDllPath);
        }
        __except (WS2_EXCEPTION_FILTER()) {
            errno_result = WSAEFAULT;
            TRY_THROW (guard_memalloc);
        }

        if (provider_path == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry64_32(
            registry_root  // ParentKey
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        catalog->EnumerateCatalogItems(
            GuidMatcher,         // Iteration
            & context  // PassBack
            );
        if (context.CatalogItem!=NULL) {
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }

        for (pindex = 0; pindex < (int) dwNumberOfEntries; pindex++) {
            entry_id = catalog->AllocateCatalogEntryId();
            __try {
                proto_info = lpProtocolInfoList[pindex];
            }
            __except (WS2_EXCEPTION_FILTER()) {
                errno_result = WSAEFAULT;
                TRY_THROW(guard_memalloc);
            }

            if (!(proto_info.dwServiceFlags1 & XP1_IFS_HANDLES)) {
                NonIFS = TRUE;
            }

            proto_info.ProviderId = *lpProviderId;
            proto_info.dwCatalogEntryId = entry_id;

            item = new PROTO_CATALOG_ITEM();
            if (item == NULL) {
                errno_result = WSA_NOT_ENOUGH_MEMORY;
                TRY_THROW(guard_memalloc);
            }
            errno_result = item->InitializeFromValues(
                provider_path,  // LibraryPath
                & proto_info    // ProtoInfo
                );
            if (errno_result != ERROR_SUCCESS) {
                TRY_THROW(guard_memalloc);
            }

            catalog->AppendCatalogItem(
                item  // CatalogItem
                );
#ifdef _WIN64_32
            item = new PROTO_CATALOG_ITEM();
            if (item == NULL) {
                errno_result = WSA_NOT_ENOUGH_MEMORY;
                TRY_THROW(guard_memalloc);
            }
            errno_result = item->InitializeFromValues(
                provider_path,  // LibraryPath
                & proto_info    // ProtoInfo
                );
            if (errno_result != ERROR_SUCCESS) {
                TRY_THROW(guard_memalloc);
            }

            catalog->AppendCatalogItem32(
                item  // CatalogItem
                );
#endif
            item = NULL;  // item deletion is now covered by catalog
        }  // for pindex
    
        if (NonIFS) {
            errno_result = WahEnableNonIFSHandleSupport();
            if (errno_result==ERROR_SUCCESS)
                InstalledNonIFS = TRUE;
            else if (errno_result==ERROR_SERVICE_ALREADY_RUNNING) {
                errno_result = ERROR_SUCCESS;
            }
            else {
                TRY_THROW(guard_memalloc);
            }
        }

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;
        delete provider_path;

    } TRY_CATCH(guard_memalloc) {
        if (errno_result == ERROR_SUCCESS) {
            errno_result = WSANO_RECOVERY;
        }
        if (item != NULL) {
            item->Dereference ();
        }
        if (catalog != NULL) {
            delete catalog;
        }
        if (provider_path != NULL) {
            delete provider_path;
        }

        if (InstalledNonIFS)
            WahDisableNonIFSHandleSupport ();
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    }
    else {

        __try {
            * lpErrno = errno_result;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            // Not much we can do about this
        }
        return SOCKET_ERROR;
    }

}  // WSCInstallProvider


// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when attempting to update a provider.
typedef struct {
    LPGUID              ProviderId;
    PCHAR               LibraryPath;
    LPWSAPROTOCOL_INFOW ProtocolInfoArray;
    DWORD               ProtocolInfoCount;
    DWORD               UpdatedProtocolCount;
    INT                 Error;
    INT                 OriginalNonIfsCount;
    INT                 FinalNonIfsCount;
} PROVIDER_UPDATE_CONTEXT,  FAR * PPROVIDER_UPDATE_CONTEXT;


BOOL
ProviderUpdater(
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry
    )
#ifndef _WIN64_32
/*++

Routine Description:

    This  procedure determines if ProviderId and any of catalog entry id
    of a passed context matches provider GUID and catalog entry of the  target  
    provider.  If so, it updates it and increments the updated count.

Arguments:

    PassBack     - Supplies  a  reference  to  a  GUID_MATCH_CONTEXT structure.
                    Returns catalog entry reference if it was discovered

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.

Return Value:

    If a match is found, the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE to continue the iteration.
--*/
{
    PPROVIDER_UPDATE_CONTEXT    context;
    DWORD                       i;

    context = (PPROVIDER_UPDATE_CONTEXT)PassBack;
    assert (context->UpdatedProtocolCount<=context->ProtocolInfoCount);
    assert (context->Error==NO_ERROR);
    if (!(CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES)) {
        context->OriginalNonIfsCount += 1;
    }

    __try {
        if( *context->ProviderId == *(CatalogEntry->GetProviderId())) {
            for (i=0; i<context->ProtocolInfoCount; i++) {
                if (context->ProtocolInfoArray[i].dwCatalogEntryId==
                        CatalogEntry->GetProtocolInfo()->dwCatalogEntryId) {
                    WSAPROTOCOL_INFOW    protoInfo;
                    protoInfo = context->ProtocolInfoArray[i];
                    protoInfo.ProviderId = *context->ProviderId;
                    CatalogEntry->InitializeFromValues (context->LibraryPath,
                                                        &protoInfo);
                    context->UpdatedProtocolCount += 1;
                    break;
                }
            }
        }
        if (!(CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES)) {
            context->FinalNonIfsCount += 1;
        }
        return TRUE;  // continue iteration
    }
    __except (WS2_EXCEPTION_FILTER ()) {
        context->Error = WSAEFAULT;
        return FALSE; // Stop iteration on error.
    }

}  // ProviderUpdater
#else
;
#endif


int
WSPAPI
#ifndef _WIN64_32
WSCUpdateProvider(
#else _WIN64_32
WSCUpdateProvider32(
#endif
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    )
/*++

Routine Description:

    This   procedure   installs   the   specified   provider  into  the  system
    configuration  database.   After  this  call,  a  WinSock  2  DLL  instance
    initialized  via  a  first call to WSAStartup will return the new protocols
    from the WSAEnumProtocols function.

    It  is the caller's responsibility to perform required file installation or
    service provider specific configuration.

Arguments:

    lpProviderId        - Supplies a GUID giving the locally unique identifier
                          for the newly installed provider.

    lpszProviderDllPath - Supplies a reference to a fully qualified path to the
                          providers  DLL image.  This path may contain embedded
                          environment  strings  (such  as  %SystemRoot%).  Such
                          environment strings are expanded whenever the WinSock
                          2  DLL  needs  to  load  the provider DLL.  After any
                          embedded   environment   strings  are  expanded,  the
                          WinSock  2  DLL  passes the resulting string into the
                          LoadLibrary() API to load the provider into memory.

    lpProtocolInfoList  - Supplies a reference to an array of WSAPROTOCOL_INFOW
                          structures.      Each     structure     defines     a
                          protocol/address_family/socket_type  supported by the
                          provider.

    dwNumberOfEntries   - Supplies    the    number    of    entries   in   the
                          lpProtocolInfoList array.

    lpErrno             - Returns the error code.

Return Value:

    If no error occurs, WSCInstallProvider() returns ERROR_SUCCESS.  Otherwise,
    it  returns  SOCKET_ERROR, and a specific error code is returned in the int
    referenced by lpErrno.

Implementation Notes:

    open winsock registry
    create catalog from registry
    check provider name for uniqueness
    providerid = allocate provider id
    for each protocolinfo in list
        allocate catalog entry id
        write provider id and catalog entry id into protocol info
        create catalogitem from values
        append item to catalog
        check if item is for NonIFS provider
    end for
    enable non-IFS handle support if any NonIFS providers
    write catalog to registry
    close winsock registry
--*/
{
    int  errno_result;
    int  return_value;
    HKEY  registry_root;
    BOOL NonIFS = FALSE;

    // objects protected by "try" block
    PDCATALOG   catalog = NULL;
    BOOL        InstalledNonIFS = FALSE;
    PROVIDER_UPDATE_CONTEXT  context;
    context.ProviderId = lpProviderId;
    context.LibraryPath = NULL;
    context.ProtocolInfoArray = lpProtocolInfoList;
    context.ProtocolInfoCount = dwNumberOfEntries;
    context.UpdatedProtocolCount = 0;
    context.Error = NO_ERROR;
    context.OriginalNonIfsCount = 0;
    context.FinalNonIfsCount = 0;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        * lpErrno = WSANO_RECOVERY;
        return SOCKET_ERROR;
    }

    //
    // Check the current protocol catalog key. If it doesn't match
    // the expected value, blow away the old key and update the
    // stored value.
    //

    ValidateCurrentCatalogName(
        registry_root,
        WINSOCK_CURRENT_PROTOCOL_CATALOG_NAME,
        DCATALOG::GetCurrentCatalogName()
        );

    errno_result = ERROR_SUCCESS;
    return_value = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {

        __try {
            context.LibraryPath = ansi_dup_from_wcs((LPWSTR)lpszProviderDllPath);
        }
        __except (WS2_EXCEPTION_FILTER()) {
            errno_result = WSAEFAULT;
            TRY_THROW (guard_memalloc);
        }

        if (context.LibraryPath == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root   // ParentKey
            );
#endif

        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        catalog->EnumerateCatalogItems(
            ProviderUpdater,         // Iteration
            & context  // PassBack
            );
        if (context.UpdatedProtocolCount!=context.ProtocolInfoCount) {
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }

        if (context.OriginalNonIfsCount==0 && context.FinalNonIfsCount!=0) {
            errno_result = WahEnableNonIFSHandleSupport();
            if (errno_result==ERROR_SUCCESS)
                InstalledNonIFS = TRUE;
            else if (errno_result==ERROR_SERVICE_ALREADY_RUNNING) {
                errno_result = ERROR_SUCCESS;
            }
            else {
                TRY_THROW(guard_memalloc);
            }
        }

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        if (context.OriginalNonIfsCount!=0 && context.FinalNonIfsCount==0) {
            WahDisableNonIFSHandleSupport(); // ignore the error.
        }

        delete catalog;
        delete context.LibraryPath;

    } TRY_CATCH(guard_memalloc) {
        if (errno_result == ERROR_SUCCESS) {
            errno_result = WSANO_RECOVERY;
        }
        if (catalog != NULL) {
            delete catalog;
        }
        if (context.LibraryPath != NULL) {
            delete context.LibraryPath;
        }

        if (InstalledNonIFS)
            WahDisableNonIFSHandleSupport ();
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }

        return ERROR_SUCCESS;
    }
    else {

        __try {
            * lpErrno = errno_result;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            // Not much we can do about this
        }
        return SOCKET_ERROR;
    }

}  // WSCInstallProvider


BOOL
NonIFSFinder(
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry)
#ifndef _WIN64_32
/*++

Routine Description:

    This  procedure  checks catalog for NonIFS transport service providers.
    If one is found, it clears a flag to indicate that NonIFS handle support
    should not be removed and returns FALSE to terminate the enumeration.  
    Otherwise it returns TRUE and the enumeration continues.

Arguments:

    PassBack     - Supplies a pointer to bool that servers as the flag to
                    tell if NonIFS provider is found

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.  The
                   pointer  is  not guaranteed to be valid after this procedure
                   returns, so the client should copy data if required.

Return Value:

    If a match is found, the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE.
--*/
{
    PBOOL  context;

    context = (PBOOL)PassBack;

    if( !(CatalogEntry->GetProtocolInfo()->dwServiceFlags1 & XP1_IFS_HANDLES) ) {
        *context = FALSE;
        return FALSE;  // do not continue iteration
    }

    return TRUE;  // continue iteration
}  // NonIFSFinder
#else
;
#endif


int
WSPAPI
#ifndef _WIN64_32
WSCDeinstallProvider(
#else
WSCDeinstallProvider32(
#endif
    IN  LPGUID lpProviderId,
    OUT LPINT lpErrno
    )
/*++

Routine Description:

    This procedure removes the specified provider from the system configuration
    database.   After  this  call,  a  WinSock 2 DLL instance initialized via a
    first  call  to  WSAStartup  will no longer return the specified provider's
    protocols from the WSAEnumProtocols function.

    Any  additional  file  removal  or  service provider specific configuration
    information  removal  needed  to completely de-install the service provider
    must be performed by the caller.

Arguments:

    lpProviderId - Supplies  the  locally  unique identifier of the provider to
                   deinstall.   This  must  be  a  value previously passed to
                   WSCInstallProvider().

    lpErrno      - Returns the error code.

Return Value:

    If   no   error   occurs,   WSCDeinstallProvider()  returns  ERROR_SUCCESS.
    Otherwise,  it returns SOCKET_ERROR, and a specific error code is available
    in lpErrno.

Implementation Notes:

    open winsock registry
    create catalog from registry
    while (item = enumerate until find provider id) do
        remove item from catalog
        delete item
    end while
    write catalog to registry
    close winsock registry

--*/
{
    int  errno_result;
    int  return_value;
    HKEY  registry_root;
    BOOL  items_found;
    BOOL  DeinstallNonIFS = FALSE;

    // objects protected by "try" block
    PDCATALOG            catalog = NULL;

    registry_root = OpenWinSockRegistryRoot();
    if (registry_root == NULL) {
        DEBUGF(
            DBG_ERR,
            ("Opening registry root\n"));
        * lpErrno = WSANO_RECOVERY;
        return SOCKET_ERROR;
    }

    errno_result = ERROR_SUCCESS;
    return_value = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        GUID_MATCH_CONTEXT  context;
        __try {
            context.ProviderId = *lpProviderId;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            errno_result = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }
#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root   // ParentKey
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        items_found = FALSE;
        do {
            context.CatalogItem = NULL;
            catalog->EnumerateCatalogItems(
                GuidMatcher,    // Iteration
                & context           // PassBack
                );
            if (context.CatalogItem!=NULL) {
                items_found = TRUE;
                //
                // Check if provider we are deinstalling is 
                // a non-ifs provider, we may want to disable
                // non-ifs support is this was the last non-ifs 
                // provider.
                //
                if (!DeinstallNonIFS) {
                    DeinstallNonIFS 
                        = !(context.CatalogItem->GetProtocolInfo()->dwServiceFlags1 
                            & XP1_IFS_HANDLES);
                }
                catalog->RemoveCatalogItem(context.CatalogItem);
                context.CatalogItem->Dereference ();
            }
        }
        while (context.CatalogItem!=NULL);

        if (! items_found) {
            errno_result = WSAEFAULT;
            TRY_THROW(guard_memalloc);
        }

        if (DeinstallNonIFS) {
            //
            // Check if there are any remaining non-IFS
            // providers left, if none left we will disable
            // non-IFS support
            //
            catalog->EnumerateCatalogItems(
                NonIFSFinder,               // Iteration
                & DeinstallNonIFS           // PassBack
                );
        }
        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;

        if (DeinstallNonIFS)
            WahDisableNonIFSHandleSupport();

    } TRY_CATCH(guard_memalloc) {
        if (errno_result == ERROR_SUCCESS) {
            errno_result = WSANO_RECOVERY;
        }
        if (catalog != NULL) {
            delete catalog;
        }
    } TRY_END(guard_memalloc);

    CloseWinSockRegistryRoot(registry_root);

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //


        if (WahOpenNotificationHandleHelper( &hHelper )==ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            // This is non-fatal and catalog was updated anyway
        }

        return ERROR_SUCCESS;
    }
    else {

        __try {
            * lpErrno = errno_result;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            // Not much we can do about this
        }
        return SOCKET_ERROR;
    }

}  // WSCDeinstallProvider



// The  following  type is used to pass context back and forth to an enumerator
// iteration procedure when removing all items form the catalog
typedef struct {
    IN  DWORD               Count;      // Number of ids / size of item array
    IN  DWORD               *CatIds;    // Array of catalog id's to match against
    OUT PPROTO_CATALOG_ITEM *Items;     // Array of item pointers to return
    OUT INT                 ErrorCode;
} PROVIDER_SNAP_CONTEXT,  FAR * PPROVIDER_SNAP_CONTEXT;




BOOL
ProviderSnap(
    IN PVOID                PassBack,
    IN PPROTO_CATALOG_ITEM  CatalogEntry)
#ifndef _WIN64_32
/*++

Routine Description:
    Snaps all the catalog items in the current catalog

Arguments:

    PassBack     - Supplies  a reference to a PROVIDER_SNAP_CONTEXT structure.
                   Returns an array of items in the order specified by catalog
                   id array.

    CatalogEntry - Supplies  to  the client a reference to a PROTO_CATALOG_ITEM
                   structure with values for this item of the enumeration.  The
                   pointer  is  not guaranteed to be valid after this procedure
                   returns, so the client should copy data if required.

Return Value:

    If an item is found that could not be matched to catalog id in the array,
    the function returns FALSE to terminate the iteration,
    otherwise it returns TRUE.
--*/
{
    PPROVIDER_SNAP_CONTEXT      context;
    DWORD                       i;

    context = (PPROVIDER_SNAP_CONTEXT)PassBack;

    for (i=0; i<context->Count; i++) {
        __try {
            if (context->CatIds[i]
                    ==CatalogEntry->GetProtocolInfo ()->dwCatalogEntryId) {
                assert (context->Items[i]==NULL);
                context->Items[i] = CatalogEntry;
                return TRUE;
            }
        }
        __except (WS2_EXCEPTION_FILTER ()) {
            context->ErrorCode = WSAEFAULT;
            return FALSE;
        }
    }

    DEBUGF (DBG_ERR,
        ("Checking item array against catalog, CatId:%ld not in the array.\n",
        CatalogEntry->GetProtocolInfo ()->dwCatalogEntryId));
    context->ErrorCode = WSAEINVAL;

    return FALSE;
}  // ProviderSnap
#else
;
#endif _WIN64_32



int
WSPAPI
#ifndef _WIN64_32
WSCWriteProviderOrder (
#else
WSCWriteProviderOrder32 (
#endif
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    )
/*++

Routine Description:

    Reorder existing WinSock2 service providers.  The order of the service
    providers determines their priority in being selected for use.  The
    sporder.exe tool will show you the installed provider and their ordering,
    Alternately, WSCEnumProtocols(), in conjunction with this function,
    will allow you to write your own tool.

Arguments:

    lpwdCatalogEntryId  [in]
      An array of CatalogEntryId elements as found in the WSAPROTOCOL_INFO
      structure.  The order of the CatalogEntryId elements is the new
      priority ordering for the service providers.

    dwNumberOfEntries  [in]
      The number of elements in the lpwdCatalogEntryId array.


Return Value:

    ERROR_SUCCESS   - the service providers have been reordered.
    WSAEINVAL       - input parameters were bad, no action was taken.
    WSAEFAULT       - CatalogEnryId array is not fully contained within
                        process address space.
    WSATRY_AGAIN    - the routine is being called by another thread or process.
    any registry error code


Comments:

    Here are scenarios in which the WSCWriteProviderOrder function may fail:

      The dwNumberOfEntries is not equal to the number of registered service
      providers.

      The lpwdCatalogEntryId contains an invalid catalog ID.

      The lpwdCatalogEntryId does not contain all valid catalog IDs exactly
      1 time.

      The routine is not able to access the registry for some reason
      (e.g. inadequate user persmissions)

      Another process (or thread) is currently calling the routine.


--*/
{
    INT     errno_result;
    HKEY    registry_root;
    PPROTO_CATALOG_ITEM *items = NULL;
    DWORD   i;

    // object protected by "try" block
    PDCATALOG           catalog = NULL;


    items = new PPROTO_CATALOG_ITEM[dwNumberOfEntries];
    if (items==NULL) {
        DEBUGF(
            DBG_ERR,
            ("Allocating items array\n"));
        return WSA_NOT_ENOUGH_MEMORY;
    }

    memset (items, 0, sizeof (PPROTO_CATALOG_ITEM)*dwNumberOfEntries);
    errno_result = ERROR_SUCCESS;

    TRY_START(guard_memalloc) {
        PROVIDER_SNAP_CONTEXT context;
        registry_root = OpenWinSockRegistryRoot();
        if (registry_root == NULL) {
            DEBUGF(
                DBG_ERR,
                ("Opening registry root\n"));
            errno_result = WSANO_RECOVERY;
            TRY_THROW(guard_memalloc);
        }
        catalog = new DCATALOG();
        if (catalog == NULL) {
            errno_result = WSA_NOT_ENOUGH_MEMORY;
            TRY_THROW(guard_memalloc);
        }

#ifndef _WIN64_32
        errno_result = catalog->InitializeFromRegistry(
            registry_root,  // ParentKey
            NULL            // ChangeEvent
            );
#else
        errno_result = catalog->InitializeFromRegistry32(
            registry_root
            );
#endif
        if (errno_result != ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        context.Items = items;
        context.CatIds = lpwdCatalogEntryId;
        context.Count = dwNumberOfEntries;
        context.ErrorCode = ERROR_SUCCESS;

        catalog->EnumerateCatalogItems(
            ProviderSnap,         // Iteration
            & context               // PassBack
            );

        if (context.ErrorCode!=ERROR_SUCCESS) {
            errno_result = context.ErrorCode;
            TRY_THROW(guard_memalloc);
        }

        for (i=0; i<dwNumberOfEntries; i++) {
            if (context.Items[i]!=NULL) {
                //
                // Remove catalog item and add it in the end.
                //
                catalog->RemoveCatalogItem (context.Items[i]);
                catalog->AppendCatalogItem (context.Items[i]);
            }
            else {
                DEBUGF (DBG_ERR,
                    ("Checking item array against catalog, item: %ld(CatId:%ld) not in the catalog.\n",
                    i,lpwdCatalogEntryId[i]));
                errno_result = WSAEINVAL;
                TRY_THROW(guard_memalloc);
            }
        } // for i

        errno_result = catalog->WriteToRegistry();
        if (errno_result!=ERROR_SUCCESS) {
            TRY_THROW(guard_memalloc);
        }

        delete catalog;
        CloseWinSockRegistryRoot(registry_root);

    } TRY_CATCH(guard_memalloc) {
        assert (errno_result != ERROR_SUCCESS);
        if (catalog != NULL) {
            delete catalog; // This destroys the items as well
        }

        if (registry_root!=NULL) {
            CloseWinSockRegistryRoot(registry_root);
        }
    } TRY_END(guard_memalloc);

    delete items;

    if (errno_result == ERROR_SUCCESS) {
        HANDLE hHelper;

        //
        // Alert all interested apps of change via the notification method
        //

        if (WahOpenNotificationHandleHelper( &hHelper) == ERROR_SUCCESS) {
            WahNotifyAllProcesses( hHelper );
            WahCloseNotificationHandleHelper( hHelper );
        }
        else {
            //
            // This in non-fatal and catalog was updated anyway.
            //
        }
    }

    return errno_result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\startup.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    startup.c

Abstract:

    This module contains the startup and cleanup code for winsock2 DLL

Author:

    dirk@mink.intel.com  14-JUN-1995

Revision History:

    22-Aug-1995 dirk@mink.intel.com
        Cleanup after code review.

--*/

#include "precomp.h"


INT
CheckForHookersOrChainers();

static
CRITICAL_SECTION  Startup_Synchro;
    // Startup_Synchro  is  used  as  a  synchronization  mechanism  to prevent
    // multiple  threads  from  overlapping  execution  of  the  WSAStartup and
    // WSACleanup procedures.




VOID
CreateStartupSynchronization()
/*++

Routine Description:

    This procedure creates the Startup/Cleanup synchronization mechanism.  This
    must  be  called  once  before  the  WSAStartup  procedure  may  be called.
    Typically, this is called from the DLL_PROCESS_ATTACH branch of DllMain, as
    the  only  reliable  way to guarantee that it gets called before any thread
    calls WSAStartup.

Arguments:

    None

Return Value:

    None
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("Initializing Startup/Cleanup critical section\n"));

    InitializeCriticalSection(
        & Startup_Synchro
        );
}  // CreateStartupSynchronization




VOID
DestroyStartupSynchronization()
/*++

Routine Description:

    This  procedure  destroys  the  Startup/Cleanup  synchronization mechanism.
    This  must  be  called once after the final WSACleanup procedure is called.
    Typically, this is called from the DLL_PROCESS_DETACH branch of DllMain, as
    the  only  reliable  way  to guarantee that it gets called after any thread
    calls WSACleanup.

Arguments:

    None

Return Value:

    None
--*/
{
    DEBUGF(
        DBG_TRACE,
        ("Deleting Startup/Cleanup critical section\n"));

    DeleteCriticalSection(
        & Startup_Synchro
        );
}  // DestroyStartupSynchronization



int WSAAPI
WSAStartup(
    IN WORD wVersionRequired,
    OUT LPWSADATA lpWSAData
    )
/*++
Routine Description:

    Winsock  DLL initialization routine.  A Process must successfully call this
    routine before calling any other winsock API function.

Arguments:

    wVersionRequested - The  highest version of WinSock support that the caller
                        can  use.   The  high  order  byte  specifies the minor
                        version (revision) number; the low-order byte specifies
                        the major version number.

    lpWSAData         - A  pointer  to  the  WSADATA  data structure that is to
                        receive details of the WinSock implementation.

Returns:

    Zero if sucessful or an error code as listed in the specification.

Implementation Notes:

    check versions for validity
    enter critical section
        current_proc = get current process
        if failed to get current process then
            dprocess class initialize
            dthread class initialize
            current_proc = get current process
        endif
        current_proc->increment_ref_count
    leave critical section
--*/
{
    int ReturnCode = ERROR_SUCCESS;
    BOOL ContinueInit = TRUE;
    WORD SupportedVersion=0;
    WORD MajorVersion=0;
    WORD MinorVersion=0;

    // Our DLL initialization routine has not been called yet
    if (gDllHandle==NULL)
        return WSASYSNOTREADY;

    // Extract the version number from the user request
    MajorVersion = LOBYTE(wVersionRequired);
    MinorVersion = HIBYTE(wVersionRequired);

    // Check  the  version the user requested and see if we can support it.  If
    // the requested version is less than 2.0 then we can support it
    // Extract the version number from the user request
    MajorVersion = LOBYTE(wVersionRequired);
    MinorVersion = HIBYTE(wVersionRequired);

    //
    // Version checks
    //

    switch (MajorVersion) {

    case 0:

        ReturnCode = WSAVERNOTSUPPORTED;
        break;

    case 1:

        if( MinorVersion == 0 ) {
            SupportedVersion = MAKEWORD(1,0);
        } else {
            MinorVersion = 1;
            SupportedVersion = MAKEWORD(1,1);
        }

        break;

    case 2:

        if( MinorVersion <= 2 ) {
            SupportedVersion = MAKEWORD(2,(BYTE)MinorVersion);
        } else {
            MinorVersion = 2;
            SupportedVersion = MAKEWORD(2,2);
        }

        break;

    default:

        MajorVersion =
        MinorVersion = 2;
        SupportedVersion = MAKEWORD(2,2);
        break;
    }


    __try {
        //
        // Fill in the user structure
        //
        lpWSAData->wVersion = SupportedVersion;
        lpWSAData->wHighVersion = WINSOCK_HIGH_API_VERSION;

        // Fill in the required fields from 1.0 and 1.1 these fields are
        // ignored in 2.0 and later versions of API spec
        if (MajorVersion == 1) {

            // WinSock  1.1  under  NT  always  set iMaxSockets=32767.  WinSock 1.1
            // under  Windows  95  always  set  iMaxSockets=256.   Either  value is
            // actually  incorrect,  since there was no fixed upper limit.  We just
            // use  32767,  since  it  is likely to damage the fewest number of old
            // applications.
            lpWSAData->iMaxSockets = 32767;

            // WinSock 1.1 under Windows 95 and early versions of NT used the value
            // 65535-68  for  iMaxUdpDg.   This  number  is  also  meaningless, but
            // preserving  the  same value is likely to damage the fewest number of
            // old applications.
            lpWSAData->iMaxUdpDg = 65535 - 68;
        } //if
        else {

            // iMaxSockets  and  iMaxUdpDg  are no longer relevant in WinSock 2 and
            // later.  No applications should depend on their values.  We use 0 for
            // both  of  these  as  a  means  of  flushing  out  applications  that
            // incorrectly  depend  on  the  values.   This is NOT a bug.  If a bug
            // report  is  ever  issued  against  these 0 values, the bug is in the
            // caller's code that is incorrectly depending on the values.
            lpWSAData->iMaxSockets = 0;
            lpWSAData->iMaxUdpDg = 0;
        } // else


        (void) lstrcpy(
            lpWSAData->szDescription,
            "WinSock 2.0");
    #if defined(TRACING) && defined(BUILD_TAG_STRING)
        (void) lstrcat(
            lpWSAData->szDescription,
            " Alpha BUILD_TAG=");
        (void) lstrcat(
            lpWSAData->szDescription,
            BUILD_TAG_STRING);
    #endif  // TRACING && BUILD_TAG_STRING

        //TODO: Think up a good value for "system status"
        (void) lstrcpy(
            lpWSAData->szSystemStatus,
            "Running");

        //
        // The following line is commented-out due to annoying and totally
        // nasty alignment problems in WINSOCK[2].H. The exact location of
        // the lpVendorInfo field of the WSAData structure is dependent on
        // the structure alignment used when compiling the source. Since we
        // cannot change the structure alignment of existing apps, the best
        // way to handle this mess is to just not set this value. This turns
        // out to not be too bad a solution, as neither the WinNT nor the Win95
        // WinSock implementations set this value, and nobody appears to pay
        // any attention to it anyway.
        //
        // lpWSAData->lpVendorInfo = NULL;
        //
    }
    __except (WS2_EXCEPTION_FILTER()) {
        if (ReturnCode==ERROR_SUCCESS)
            ReturnCode = WSAEFAULT;
    }

    if (ReturnCode==ERROR_SUCCESS) {
        // Do this outside of critical section
        // because it does GetModuleHandle and GetProcAddress
        // which take loader lock.
        if (CheckForHookersOrChainers() == ERROR_SUCCESS) {

            BOOL process_class_init_done = FALSE;
            BOOL thread_class_init_done = FALSE;
            BOOL socket_class_init_done = FALSE;
            PDPROCESS CurrentProcess=NULL;
            PDTHREAD CurrentThread=NULL;

            EnterCriticalSection(
                & Startup_Synchro
                );

            while (1) {
                CurrentProcess = DPROCESS::GetCurrentDProcess();

                // GetCurrentDProcess  has  a  most-likely "normal" failure case in the
                // case  where  this  is  the first time WSAStartup is called.

                if (CurrentProcess != NULL) {
                    break;
                }

                ReturnCode = DPROCESS::DProcessClassInitialize();
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
                process_class_init_done = TRUE;

                ReturnCode = DSOCKET::DSocketClassInitialize();
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
                socket_class_init_done = TRUE;

                ReturnCode = DTHREAD::DThreadClassInitialize();
                if (ReturnCode != ERROR_SUCCESS) {
                    break;
                }
                thread_class_init_done = TRUE;

                CurrentProcess = DPROCESS::GetCurrentDProcess();
                if (CurrentProcess==NULL) {
                    ReturnCode = WSASYSNOTREADY;
                    break;
                }

                // We   don't   need   a   reference  to  the  current  thread.
                // Nevertheless,  we retrieve the current thread here just as a
                // means  of  validating  that  initialization  has  gotten far
                // enough   to   be   able  to  retrieve  the  current  thread.
                // Otherwise,  we might detect a peculiar failure at some later
                // time when the client tries to do some real operation.
                CurrentThread = DTHREAD::GetCurrentDThread();
                if (CurrentThread==NULL) {
                    ReturnCode = DTHREAD::CreateDThreadForCurrentThread(
                        CurrentProcess,    // Process
                        & CurrentThread);  // CurrentThread
                }
                else {
                    assert (ReturnCode == ERROR_SUCCESS);
                }
            } // while (1)

            if (ReturnCode == ERROR_SUCCESS) {

                //
                // Save the version number. If the new version is 1.x,
                // set the API prolog to the old, inefficient prolog.
                // If the new version is NOT 1.x, don't touch the prolog
                // pointer because:
                //
                //     1. It defaults to the 2.x prolog.
                //
                //     2. The process may have already negotiated version
                //        1.x in anticipation of using 1.x-specific features
                //        (such as blocking hooks) and we don't want to
                //        overwrite the prolog pointer with the 2.x prolog.
                //

                CurrentProcess->SetVersion( wVersionRequired );

                if( CurrentProcess->GetMajorVersion() == 1 ) {

                    PrologPointer = &Prolog_v1;

                }

                //
                // Bump the ref count.
                //

                CurrentProcess->IncrementRefCount();
            }  // if success so far

            else {  // some failure occurred, cleanup
                INT dont_care;
                if (thread_class_init_done) {
                    DTHREAD::DThreadClassCleanup();
                } // if thread init done
                if (socket_class_init_done) {
                    dont_care = DSOCKET::DSocketClassCleanup();
                }
                if (process_class_init_done) {
                    if (CurrentProcess != NULL) {
                        delete CurrentProcess;
                    }  // if CurrentProcess is non-null
                } // if process init done
            }  // else

            LeaveCriticalSection(
                & Startup_Synchro
                );
        }
        else {
            ReturnCode = WSASYSNOTREADY;
        }

    }  // if ReturnCode==ERROR_SUCCESS

    return(ReturnCode);
}





extern BOOL SockAsyncThreadInitialized;

int WSAAPI
WSACleanup(
    void
    )
/*++
Routine Description:

     Terminate use of the WinSock DLL.

Arguments:

    None

Returns:

    Zero  on  success  else  SOCKET_ERROR.   The  error  code  is  stored  with
    SetErrorCode().

Implementation Notes:

    enter critical section
        current_proc = get current process
        current_proc->decrement_ref_count
        if current count is zero then
            destroy the process
            dthread class cleanup
        endif
    leave critical section

--*/
{
    INT ReturnValue;
    PDPROCESS CurrentProcess;
    PDTHREAD CurrentThread;
    INT      ErrorCode;
    DWORD    CurrentRefCount;


    EnterCriticalSection(
        & Startup_Synchro
        );

    ErrorCode = PROLOG(&CurrentProcess,
                        &CurrentThread);
    if (ErrorCode == ERROR_SUCCESS) {

        CurrentRefCount = CurrentProcess->DecrementRefCount();

        if (CurrentRefCount == 0) {
            delete CurrentProcess;
        }  // if ref count is zero

        else if (CurrentRefCount == 1  &&  SockAsyncThreadInitialized ) {

            SockTerminateAsyncThread();
        }

        ReturnValue = ERROR_SUCCESS;

    }  // if prolog succeeded
    else {
        SetLastError(ErrorCode);
        ReturnValue = SOCKET_ERROR;
    }

    LeaveCriticalSection(
        & Startup_Synchro
        );

    return(ReturnValue);

}  // WSACleanup


PWINSOCK_POST_ROUTINE
GetSockPostRoutine(
    VOID
    )
{
    EnterCriticalSection(
        & Startup_Synchro
        );

    if (SockPostRoutine==NULL) {
        //
        // We use delayload option with user32.dll, hence
        // the exception handler here.
        //
        __try {
            SockPostRoutine = PostMessage;
        }
        __except (WS2_EXCEPTION_FILTER()) {
            SockPostRoutine = NULL;
        }
    }
    LeaveCriticalSection(
        & Startup_Synchro
        );

    return SockPostRoutine;

}   // InitializeSockPostRoutine


int
PASCAL
WSApSetPostRoutine (
    IN PVOID PostRoutine
    )
{

    EnterCriticalSection(
        & Startup_Synchro
        );

    //
    // Save the routine locally.
    //

    SockPostRoutine = (LPFN_POSTMESSAGE)PostRoutine;

    LeaveCriticalSection(
        & Startup_Synchro
        );
    return ERROR_SUCCESS;

}   // WSApSetPostRoutine


#if defined(DEBUG_TRACING)

extern "C" {

SOCKET WSAAPI
DTHOOK_accept (
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen);

int WSAAPI
DTHOOK_bind (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen);

int WSAAPI
DTHOOK_closesocket (
    SOCKET s);

int WSAAPI
DTHOOK_connect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen);

int WSAAPI
DTHOOK_getpeername (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen);

int WSAAPI
DTHOOK_getsockname (
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen);

int WSAAPI
DTHOOK_getsockopt (
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen);

u_long WSAAPI
DTHOOK_htonl (
    u_long hostlong);

u_short WSAAPI
DTHOOK_htons (
    u_short hostshort);

int WSAAPI
DTHOOK_ioctlsocket (
    SOCKET s,
    long cmd,
    u_long FAR *argp);

unsigned long WSAAPI
DTHOOK_inet_addr (
    const char FAR * cp);

char FAR * WSAAPI
DTHOOK_inet_ntoa (
    struct in_addr in);

int WSAAPI
DTHOOK_listen (
    SOCKET s,
    int backlog);

u_long WSAAPI
DTHOOK_ntohl (
    u_long netlong);

u_short WSAAPI
DTHOOK_ntohs (
    u_short netshort);

int WSAAPI
DTHOOK_recv (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags);

int WSAAPI
DTHOOK_recvfrom (
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from,
    int FAR * fromlen);

int WSAAPI
DTHOOK_select (
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout);

int WSAAPI
DTHOOK_send (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags);

int WSAAPI
DTHOOK_sendto (
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to,
    int tolen);

int WSAAPI
DTHOOK_setsockopt (
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen);

int WSAAPI
DTHOOK_shutdown (
    SOCKET s,
    int how);

SOCKET WSAAPI
DTHOOK_socket (
    int af,
    int type,
    int protocol);


SOCKET WSAAPI
DTHOOK_WSAAccept (
    SOCKET s,
    struct sockaddr FAR *addr,
    LPINT addrlen,
    LPCONDITIONPROC lpfnCondition,
    DWORD dwCallbackData);

int WSAAPI
DTHOOK_WSAAsyncSelect(
    SOCKET s,
    HWND hWnd,
    u_int wMsg,
    long lEvent);

int WSAAPI
DTHOOK_WSACleanup(
    void);

BOOL WSAAPI
DTHOOK_WSACloseEvent (
    WSAEVENT hEvent);

int WSAAPI
DTHOOK_WSAConnect (
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS);

WSAEVENT WSAAPI
DTHOOK_WSACreateEvent (
    void);

int WSAAPI
DTHOOK_WSADuplicateSocketA (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOA lpProtocolInfo);

int WSAAPI
DTHOOK_WSADuplicateSocketW (
    SOCKET s,
    DWORD dwProcessId,
    LPWSAPROTOCOL_INFOW lpProtocolInfo);

int WSAAPI
DTHOOK_WSAEnumNetworkEvents (
    SOCKET s,
    WSAEVENT hEventObject,
    LPWSANETWORKEVENTS lpNetworkEvents);

int WSAAPI
DTHOOK_WSAEnumProtocolsA (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOA lpProtocolBuffer,
    LPDWORD lpdwBufferLength);

int WSAAPI
DTHOOK_WSAEnumProtocolsW (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength);

int WSPAPI
DTHOOK_WSCEnumProtocols (
    LPINT lpiProtocols,
    LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    LPDWORD lpdwBufferLength,
    LPINT  lpErrno);

int WSAAPI
DTHOOK_WSAEventSelect (
    SOCKET s,
    WSAEVENT hEventObject,
    long lNetworkEvents);

int WSAAPI
DTHOOK_WSAGetLastError(
    void);

BOOL WSAAPI
DTHOOK_WSAGetOverlappedResult (
    SOCKET s,
    LPWSAOVERLAPPED lpOverlapped,
    LPDWORD lpcbTransfer,
    BOOL fWait,
    LPDWORD lpdwFlags);

BOOL WSAAPI
DTHOOK_WSAGetQOSByName (
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS);

int WSAAPI
DTHOOK_WSAHtonl (
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong);

int WSAAPI
DTHOOK_WSAHtons (
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort);

int WSAAPI
DTHOOK_WSAIoctl (
    SOCKET s,
    DWORD dwIoControlCode,
    LPVOID lpvInBuffer,
    DWORD cbInBuffer,
    LPVOID lpvOutBuffer,
    DWORD cbOutBuffer,
    LPDWORD lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

SOCKET WSAAPI
DTHOOK_WSAJoinLeaf (
    SOCKET s,
    const struct sockaddr FAR * name,
    int namelen,
    LPWSABUF lpCallerData,
    LPWSABUF lpCalleeData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    DWORD dwFlags);

int WSAAPI
DTHOOK_WSANtohl (
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong);

int WSAAPI
DTHOOK_WSANtohs (
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort);

int WSAAPI
DTHOOK_WSARecv (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

int WSAAPI
DTHOOK_WSARecvDisconnect (
    SOCKET s,
    LPWSABUF lpInboundDisconnectData);

int WSAAPI
DTHOOK_WSARecvFrom (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

BOOL WSAAPI
DTHOOK_WSAResetEvent (
    WSAEVENT hEvent);

int WSAAPI
DTHOOK_WSASend (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

int WSAAPI
DTHOOK_WSASendDisconnect (
    SOCKET s,
    LPWSABUF lpOutboundDisconnectData);

int WSAAPI
DTHOOK_WSASendTo (
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    const struct sockaddr FAR * lpTo,
    int iTolen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

BOOL WSAAPI
DTHOOK_WSASetEvent(
    WSAEVENT hEvent);

void WSAAPI
DTHOOK_WSASetLastError(
    int iError);

SOCKET WSAAPI
DTHOOK_WSASocketA(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOA lpProtocolInfo,
    GROUP g,
    DWORD dwFlags);

SOCKET WSAAPI
DTHOOK_WSASocketW(
    int af,
    int type,
    int protocol,
    LPWSAPROTOCOL_INFOW lpProtocolInfo,
    GROUP g,
    DWORD dwFlags);

int WSAAPI
DTHOOK_WSAStartup(
    WORD wVersionRequested,
    LPWSADATA lpWSAData);

DWORD WSAAPI
DTHOOK_WSAWaitForMultipleEvents(
    DWORD cEvents,
    const WSAEVENT FAR * lphEvents,
    BOOL fWaitAll,
    DWORD dwTimeout,
    BOOL fAlertable);

struct hostent FAR * WSAAPI
DTHOOK_gethostbyaddr(
    const char FAR * addr,
    int len,
    int type);

struct hostent FAR * WSAAPI
DTHOOK_gethostbyname(
    const char FAR * name);

int WSAAPI
DTHOOK_gethostname (
    char FAR * name,
    int namelen);

struct protoent FAR * WSAAPI
DTHOOK_getprotobyname(
    const char FAR * name);

struct protoent FAR * WSAAPI
DTHOOK_getprotobynumber(
    int number);

struct servent FAR * WSAAPI
DTHOOK_getservbyname(
    const char FAR * name,
    const char FAR * proto);

struct servent FAR * WSAAPI
DTHOOK_getservbyport(
    int port,
    const char FAR * proto);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByAddr(
    HWND hWnd,
    u_int wMsg,
    const char FAR * addr,
    int len,
    int type,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetHostByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetProtoByNumber(
    HWND hWnd,
    u_int wMsg,
    int number,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByName(
    HWND hWnd,
    u_int wMsg,
    const char FAR * name,
    const char FAR * proto,
    char FAR * buf,
    int buflen);

HANDLE WSAAPI
DTHOOK_WSAAsyncGetServByPort(
    HWND hWnd,
    u_int wMsg,
    int port,
    const char FAR * proto,
    char FAR * buf,
    int buflen);

int WSAAPI
DTHOOK_WSACancelAsyncRequest(
    HANDLE hAsyncTaskHandle);

BOOL WSPAPI
DTHOOK_WPUCloseEvent(
    WSAEVENT hEvent,
    LPINT lpErrno );

int WSPAPI
DTHOOK_WPUCloseSocketHandle(
    SOCKET s,
    LPINT lpErrno );

WSAEVENT WSPAPI
DTHOOK_WPUCreateEvent(
    LPINT lpErrno );

SOCKET WSPAPI
DTHOOK_WPUCreateSocketHandle(
    DWORD dwCatalogEntryId,
    DWORD_PTR dwContext,
    LPINT lpErrno);

SOCKET WSPAPI
DTHOOK_WPUModifyIFSHandle(
    DWORD dwCatalogEntryId,
    SOCKET ProposedHandle,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WPUQueryBlockingCallback(
    DWORD dwCatalogEntryId,
    LPBLOCKINGCALLBACK FAR * lplpfnCallback,
    PDWORD_PTR lpdwContext,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WPUQuerySocketHandleContext(
    SOCKET s,
    PDWORD_PTR lpContext,
    LPINT lpErrno );

int WSPAPI
DTHOOK_WPUQueueApc(
    LPWSATHREADID lpThreadId,
    LPWSAUSERAPC lpfnUserApc,
    DWORD_PTR dwContext,
    LPINT lpErrno);

BOOL WSPAPI
DTHOOK_WPUResetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno);

BOOL WSPAPI
DTHOOK_WPUSetEvent(
    WSAEVENT hEvent,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WSCDeinstallProvider(
    LPGUID lpProviderId,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WSCInstallProvider(
    LPGUID lpProviderId,
    const WCHAR FAR * lpszProviderDllPath,
    const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    DWORD dwNumberOfEntries,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WPUGetProviderPath(
    IN     LPGUID     lpProviderId,
    OUT    WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT      lpProviderDllPathLen,
    OUT    LPINT      lpErrno
    );

BOOL WSPAPI
DTHOOK_WPUPostMessage(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
    );

int WSPAPI
DTHOOK_WPUFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    );

int WSPAPI
DTHOOK___WSAFDIsSet(
    SOCKET       s,
    fd_set FAR * set
    );

INT
WSPAPI
DTHOOK_WSAAddressToStringA(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOA lpProtocolInfo,
    IN OUT LPSTR               lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    );

INT
WSPAPI
DTHOOK_WSAAddressToStringW(
    IN     LPSOCKADDR          lpsaAddress,
    IN     DWORD               dwAddressLength,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPWSTR              lpszAddressString,
    IN OUT LPDWORD             lpdwAddressStringLength
    );

INT
WSPAPI
DTHOOK_WSAStringToAddressA(
    IN     LPSTR               AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOA  lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    );

INT
WSPAPI
DTHOOK_WSAStringToAddressW(
    IN     LPWSTR              AddressString,
    IN     INT                 AddressFamily,
    IN     LPWSAPROTOCOL_INFOW lpProtocolInfo,
    IN OUT LPSOCKADDR          lpAddress,
    IN OUT LPINT               lpAddressLength
    );

INT
WSPAPI
DTHOOK_WSALookupServiceBeginA(
    IN  LPWSAQUERYSETA lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    );

INT
WSPAPI
DTHOOK_WSALookupServiceBeginW(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    );

INT
WSPAPI
DTHOOK_WSALookupServiceNextA(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETA   lpqsResults
    );

INT
WSPAPI
DTHOOK_WSALookupServiceNextW(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    );

INT
WSPAPI
DTHOOK_WSANSPIoctl(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    );

INT
WSPAPI
DTHOOK_WSALookupServiceEnd(
    IN HANDLE  hLookup
    );

INT
WSPAPI
DTHOOK_WSAInstallServiceClassA(
    IN  LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );

INT
WSPAPI
DTHOOK_WSAInstallServiceClassW(
    IN  LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );

INT WSPAPI
DTHOOK_WSASetServiceA(
    IN  LPWSAQUERYSETA    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    );

INT WSPAPI
DTHOOK_WSASetServiceW(
    IN  LPWSAQUERYSETW    lpqsRegInfo,
    IN  WSAESETSERVICEOP  essOperation,
    IN  DWORD             dwControlFlags
    );

INT
WSPAPI
DTHOOK_WSARemoveServiceClass(
    IN  LPGUID  lpServiceClassId
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoA(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOA   lpServiceClassInfo
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassInfoW(
    IN     LPGUID                  lpProviderId,
    IN     LPGUID                  lpServiceClassId,
    IN OUT LPDWORD                 lpdwBufSize,
    OUT    LPWSASERVICECLASSINFOW   lpServiceClassInfo
    );

INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersA(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOA  Lpnspbuffer
    );

INT
WSPAPI
DTHOOK_WSAEnumNameSpaceProvidersW(
    IN OUT LPDWORD              lpdwBufferLength,
    IN     LPWSANAMESPACE_INFOW  Lpnspbuffer
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdA(
    IN      LPGUID  lpServiceClassId,
    OUT     LPSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    );

INT
WSPAPI
DTHOOK_WSAGetServiceClassNameByClassIdW(
    IN      LPGUID  lpServiceClassId,
    OUT     LPWSTR   lpszServiceClassName,
    IN OUT  LPDWORD lpdwBufferLength
    );

INT
WSAAPI
DTHOOK_WSACancelBlockingCall(
    VOID
    );

FARPROC
WSAAPI
DTHOOK_WSASetBlockingHook(
    FARPROC lpBlockFunc
    );

INT
WSAAPI
DTHOOK_WSAUnhookBlockingHook(
    VOID
    );

BOOL
WSAAPI
DTHOOK_WSAIsBlocking(
    VOID
    );

int WSPAPI
DTHOOK_WSCGetProviderPath(
    LPGUID lpProviderId,
    WCHAR FAR * lpszProviderDllPath,
    LPINT lpProviderDllPathLen,
    LPINT lpErrno);

int WSPAPI
DTHOOK_WSCInstallNameSpace(
    LPWSTR lpszIdentifier,
    LPWSTR lpszPathName,
    DWORD dwNameSpace,
    DWORD dwVersion,
    LPGUID lpProviderId);

int WSPAPI
DTHOOK_WSCUnInstallNameSpace(
    LPGUID lpProviderId
    );

int WSPAPI
DTHOOK_WSCEnableNSProvider(
    LPGUID lpProviderId,
    BOOL fEnable
    );

int
WSPAPI
DTHOOK_WPUCompleteOverlappedRequest (
    SOCKET s, 	
    LPWSAOVERLAPPED lpOverlapped, 	
    DWORD dwError, 	
    DWORD cbTransferred, 	
    LPINT lpErrno
    );

int WSAAPI
DTHOOK_WSAProviderConfigChange(
    IN OUT LPHANDLE lpNotificationHandle,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

int
WSPAPI
DTHOOK_WSCWriteProviderOrder (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

int
WSPAPI
DTHOOK_WSCUpdateProvider(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

int WSAAPI
DTHOOK_getaddrinfo(
    const char FAR *NodeName,
    const char FAR *ServiceName,
    const struct addrinfo FAR *Hints,
    struct addrinfo FAR * FAR *Result
    );

int WSAAPI
DTHOOK_getnameinfo(
    const struct sockaddr *SocketAddress,
    socklen_t SocketAddressLength,
    char *NodeName,
    DWORD NodeBufferSize,
    char *ServiceName,
    DWORD ServiceBufferSize,
    int Flags
    );

void WSAAPI
DTHOOK_freeaddrinfo(
    struct addrinfo *Free
    );

#ifdef _WIN64

int 
WSPAPI
DTHOOK_WSCEnumProtocols32(
    IN LPINT                lpiProtocols,
    OUT LPWSAPROTOCOL_INFOW lpProtocolBuffer,
    IN OUT LPDWORD          lpdwBufferLength,
    LPINT                   lpErrno
    );

int
WSPAPI
DTHOOK_WSCInstallProvider64_32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCDeinstallProvider32(
    IN  LPGUID lpProviderId,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCGetProviderPath32 (
    IN LPGUID lpProviderId,
    OUT WCHAR FAR * lpszProviderDllPath,
    IN OUT LPINT ProviderDLLPathLen,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCUpdateProvider32(
    IN  LPGUID lpProviderId,
    IN  const WCHAR FAR * lpszProviderDllPath,
    IN  const LPWSAPROTOCOL_INFOW lpProtocolInfoList,
    IN  DWORD dwNumberOfEntries,
    OUT LPINT lpErrno
    );

int
WSPAPI
DTHOOK_WSCWriteProviderOrder32 (
    IN LPDWORD lpwdCatalogEntryId,
    IN DWORD dwNumberOfEntries
    );

INT 
WSAAPI
DTHOOK_WSCEnumNameSpaceProviders32(
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPWSANAMESPACE_INFOW lpnspBuffer
    );

INT 
WSAAPI
DTHOOK_WSCInstallNameSpace32 (
    IN  LPWSTR  lpszIdentifier,
    IN  LPWSTR  lpszPathName,
    IN  DWORD   dwNameSpace,
    IN  DWORD   dwVersion,
    IN  LPGUID  lpProviderId
    );

INT
WSAAPI
DTHOOK_WSCUnInstallNameSpace32 (
    IN  LPGUID  lpProviderId
    );

INT
WSAAPI
DTHOOK_WSCEnableNSProvider32 (
    IN  LPGUID  lpProviderId,
    IN  BOOL    fEnable
    );

int
WSPAPI
DTHOOK_WSCWriteNameSpaceOrder32 (
    IN LPGUID lpProviderId,
    IN DWORD dwNumberOfEntries
    );

#endif // _WIN64
} // extern "C"

#endif // DEBUG_TRACING


LPVOID apfns[] =
{
#if defined(DEBUG_TRACING)
    (LPVOID) DTHOOK_accept,
    (LPVOID) DTHOOK_bind,
    (LPVOID) DTHOOK_closesocket,
    (LPVOID) DTHOOK_connect,
    (LPVOID) DTHOOK_getpeername,
    (LPVOID) DTHOOK_getsockname,
    (LPVOID) DTHOOK_getsockopt,
    (LPVOID) DTHOOK_htonl,
    (LPVOID) DTHOOK_htons,
    (LPVOID) DTHOOK_ioctlsocket,
    (LPVOID) DTHOOK_inet_addr,
    (LPVOID) DTHOOK_inet_ntoa,
    (LPVOID) DTHOOK_listen,
    (LPVOID) DTHOOK_ntohl,
    (LPVOID) DTHOOK_ntohs,
    (LPVOID) DTHOOK_recv,
    (LPVOID) DTHOOK_recvfrom,
    (LPVOID) DTHOOK_select,
    (LPVOID) DTHOOK_send,
    (LPVOID) DTHOOK_sendto,
    (LPVOID) DTHOOK_setsockopt,
    (LPVOID) DTHOOK_shutdown,
    (LPVOID) DTHOOK_socket,
    (LPVOID) DTHOOK_gethostbyaddr,
    (LPVOID) DTHOOK_gethostbyname,
    (LPVOID) DTHOOK_getprotobyname,
    (LPVOID) DTHOOK_getprotobynumber,
    (LPVOID) DTHOOK_getservbyname,
    (LPVOID) DTHOOK_getservbyport,
    (LPVOID) DTHOOK_gethostname,
    (LPVOID) DTHOOK_WSAAsyncSelect,
    (LPVOID) DTHOOK_WSAAsyncGetHostByAddr,
    (LPVOID) DTHOOK_WSAAsyncGetHostByName,
    (LPVOID) DTHOOK_WSAAsyncGetProtoByNumber,
    (LPVOID) DTHOOK_WSAAsyncGetProtoByName,
    (LPVOID) DTHOOK_WSAAsyncGetServByPort,
    (LPVOID) DTHOOK_WSAAsyncGetServByName,
    (LPVOID) DTHOOK_WSACancelAsyncRequest,
    (LPVOID) DTHOOK_WSASetBlockingHook,
    (LPVOID) DTHOOK_WSAUnhookBlockingHook,
    (LPVOID) DTHOOK_WSAGetLastError,
    (LPVOID) DTHOOK_WSASetLastError,
    (LPVOID) DTHOOK_WSACancelBlockingCall,
    (LPVOID) DTHOOK_WSAIsBlocking,
    (LPVOID) DTHOOK_WSAStartup,
    (LPVOID) DTHOOK_WSACleanup,

    (LPVOID) DTHOOK_WSAAccept,
    (LPVOID) DTHOOK_WSACloseEvent,
    (LPVOID) DTHOOK_WSAConnect,
    (LPVOID) DTHOOK_WSACreateEvent,
    (LPVOID) DTHOOK_WSADuplicateSocketA,
    (LPVOID) DTHOOK_WSADuplicateSocketW,
    (LPVOID) DTHOOK_WSAEnumNetworkEvents,
    (LPVOID) DTHOOK_WSAEnumProtocolsA,
    (LPVOID) DTHOOK_WSAEnumProtocolsW,
    (LPVOID) DTHOOK_WSAEventSelect,
    (LPVOID) DTHOOK_WSAGetOverlappedResult,
    (LPVOID) DTHOOK_WSAGetQOSByName,
    (LPVOID) DTHOOK_WSAHtonl,
    (LPVOID) DTHOOK_WSAHtons,
    (LPVOID) DTHOOK_WSAIoctl,
    (LPVOID) DTHOOK_WSAJoinLeaf,
    (LPVOID) DTHOOK_WSANtohl,
    (LPVOID) DTHOOK_WSANtohs,
    (LPVOID) DTHOOK_WSARecv,
    (LPVOID) DTHOOK_WSARecvDisconnect,
    (LPVOID) DTHOOK_WSARecvFrom,
    (LPVOID) DTHOOK_WSAResetEvent,
    (LPVOID) DTHOOK_WSASend,
    (LPVOID) DTHOOK_WSASendDisconnect,
    (LPVOID) DTHOOK_WSASendTo,
    (LPVOID) DTHOOK_WSASetEvent,
    (LPVOID) DTHOOK_WSASocketA,
    (LPVOID) DTHOOK_WSASocketW,
    (LPVOID) DTHOOK_WSAWaitForMultipleEvents,

    (LPVOID) DTHOOK_WSAAddressToStringA,
    (LPVOID) DTHOOK_WSAAddressToStringW,
    (LPVOID) DTHOOK_WSAStringToAddressA,
    (LPVOID) DTHOOK_WSAStringToAddressW,
    (LPVOID) DTHOOK_WSALookupServiceBeginA,
    (LPVOID) DTHOOK_WSALookupServiceBeginW,
    (LPVOID) DTHOOK_WSALookupServiceNextA,
    (LPVOID) DTHOOK_WSALookupServiceNextW,
    (LPVOID) DTHOOK_WSANSPIoctl,
    (LPVOID) DTHOOK_WSALookupServiceEnd,
    (LPVOID) DTHOOK_WSAInstallServiceClassA,
    (LPVOID) DTHOOK_WSAInstallServiceClassW,
    (LPVOID) DTHOOK_WSARemoveServiceClass,
    (LPVOID) DTHOOK_WSAGetServiceClassInfoA,
    (LPVOID) DTHOOK_WSAGetServiceClassInfoW,
    (LPVOID) DTHOOK_WSAEnumNameSpaceProvidersA,
    (LPVOID) DTHOOK_WSAEnumNameSpaceProvidersW,
    (LPVOID) DTHOOK_WSAGetServiceClassNameByClassIdA,
    (LPVOID) DTHOOK_WSAGetServiceClassNameByClassIdW,
    (LPVOID) DTHOOK_WSASetServiceA,
    (LPVOID) DTHOOK_WSASetServiceW,

    (LPVOID) DTHOOK_WSCDeinstallProvider,
    (LPVOID) DTHOOK_WSCInstallProvider,
    (LPVOID) DTHOOK_WSCEnumProtocols,
    (LPVOID) DTHOOK_WSCGetProviderPath,
    (LPVOID) DTHOOK_WSCInstallNameSpace,
    (LPVOID) DTHOOK_WSCUnInstallNameSpace,
    (LPVOID) DTHOOK_WSCEnableNSProvider,
    
    (LPVOID) DTHOOK_WPUCompleteOverlappedRequest,
    
    (LPVOID) DTHOOK_WSAProviderConfigChange,
    
    (LPVOID) DTHOOK_WSCWriteProviderOrder,
    (LPVOID) DTHOOK_WSCWriteNameSpaceOrder,
    (LPVOID) DTHOOK_WSCUpdateProvider,

    (LPVOID) DTHOOK_getaddrinfo,
    (LPVOID) DTHOOK_getnameinfo,
    (LPVOID) DTHOOK_freeaddrinfo,

#ifdef _WIN64
    (LPVOID) DTHOOK_WSCEnumProtocols32,
    (LPVOID) DTHOOK_WSCInstallProvider64_32,
    (LPVOID) DTHOOK_WSCDeinstallProvider32,
    (LPVOID) DTHOOK_WSCGetProviderPath32,
    (LPVOID) DTHOOK_WSCUpdateProvider32,
    (LPVOID) DTHOOK_WSCWriteProviderOrder32,
    (LPVOID) DTHOOK_WSCEnumNameSpaceProviders32,
    (LPVOID) DTHOOK_WSCInstallNameSpace32,
    (LPVOID) DTHOOK_WSCUnInstallNameSpace32,
    (LPVOID) DTHOOK_WSCEnableNSProvider32,
    (LPVOID) DTHOOK_WSCWriteNameSpaceOrder32,
#endif //_WIN64

#else // DEBUG_TRACING

    (LPVOID) accept,
    (LPVOID) bind,
    (LPVOID) closesocket,
    (LPVOID) connect,
    (LPVOID) getpeername,
    (LPVOID) getsockname,
    (LPVOID) getsockopt,
    (LPVOID) htonl,
    (LPVOID) htons,
    (LPVOID) ioctlsocket,
    (LPVOID) inet_addr,
    (LPVOID) inet_ntoa,
    (LPVOID) listen,
    (LPVOID) ntohl,
    (LPVOID) ntohs,
    (LPVOID) recv,
    (LPVOID) recvfrom,
    (LPVOID) select,
    (LPVOID) send,
    (LPVOID) sendto,
    (LPVOID) setsockopt,
    (LPVOID) shutdown,
    (LPVOID) socket,
    (LPVOID) gethostbyaddr,
    (LPVOID) gethostbyname,
    (LPVOID) getprotobyname,
    (LPVOID) getprotobynumber,
    (LPVOID) getservbyname,
    (LPVOID) getservbyport,
    (LPVOID) gethostname,
    (LPVOID) WSAAsyncSelect,
    (LPVOID) WSAAsyncGetHostByAddr,
    (LPVOID) WSAAsyncGetHostByName,
    (LPVOID) WSAAsyncGetProtoByNumber,
    (LPVOID) WSAAsyncGetProtoByName,
    (LPVOID) WSAAsyncGetServByPort,
    (LPVOID) WSAAsyncGetServByName,
    (LPVOID) WSACancelAsyncRequest,
    (LPVOID) WSASetBlockingHook,
    (LPVOID) WSAUnhookBlockingHook,
    (LPVOID) WSAGetLastError,
    (LPVOID) WSASetLastError,
    (LPVOID) WSACancelBlockingCall,
    (LPVOID) WSAIsBlocking,
    (LPVOID) WSAStartup,
    (LPVOID) WSACleanup,

    (LPVOID) WSAAccept,
    (LPVOID) WSACloseEvent,
    (LPVOID) WSAConnect,
    (LPVOID) WSACreateEvent,
    (LPVOID) WSADuplicateSocketA,
    (LPVOID) WSADuplicateSocketW,
    (LPVOID) WSAEnumNetworkEvents,
    (LPVOID) WSAEnumProtocolsA,
    (LPVOID) WSAEnumProtocolsW,
    (LPVOID) WSAEventSelect,
    (LPVOID) WSAGetOverlappedResult,
    (LPVOID) WSAGetQOSByName,
    (LPVOID) WSAHtonl,
    (LPVOID) WSAHtons,
    (LPVOID) WSAIoctl,
    (LPVOID) WSAJoinLeaf,
    (LPVOID) WSANtohl,
    (LPVOID) WSANtohs,
    (LPVOID) WSARecv,
    (LPVOID) WSARecvDisconnect,
    (LPVOID) WSARecvFrom,
    (LPVOID) WSAResetEvent,
    (LPVOID) WSASend,
    (LPVOID) WSASendDisconnect,
    (LPVOID) WSASendTo,
    (LPVOID) WSASetEvent,
    (LPVOID) WSASocketA,
    (LPVOID) WSASocketW,
    (LPVOID) WSAWaitForMultipleEvents,

    (LPVOID) WSAAddressToStringA,
    (LPVOID) WSAAddressToStringW,
    (LPVOID) WSAStringToAddressA,
    (LPVOID) WSAStringToAddressW,
    (LPVOID) WSALookupServiceBeginA,
    (LPVOID) WSALookupServiceBeginW,
    (LPVOID) WSALookupServiceNextA,
    (LPVOID) WSALookupServiceNextW,
    (LPVOID) WSANSPIoctl,
    (LPVOID) WSALookupServiceEnd,
    (LPVOID) WSAInstallServiceClassA,
    (LPVOID) WSAInstallServiceClassW,
    (LPVOID) WSARemoveServiceClass,
    (LPVOID) WSAGetServiceClassInfoA,
    (LPVOID) WSAGetServiceClassInfoW,
    (LPVOID) WSAEnumNameSpaceProvidersA,
    (LPVOID) WSAEnumNameSpaceProvidersW,
    (LPVOID) WSAGetServiceClassNameByClassIdA,
    (LPVOID) WSAGetServiceClassNameByClassIdW,
    (LPVOID) WSASetServiceA,
    (LPVOID) WSASetServiceW,

    (LPVOID) WSCDeinstallProvider,
    (LPVOID) WSCInstallProvider,
    (LPVOID) WSCEnumProtocols,
    (LPVOID) WSCGetProviderPath,
    (LPVOID) WSCInstallNameSpace,
    (LPVOID) WSCUnInstallNameSpace,
    (LPVOID) WSCEnableNSProvider,

    (LPVOID) WPUCompleteOverlappedRequest,

    (LPVOID) WSAProviderConfigChange,

    (LPVOID) WSCWriteProviderOrder,
    (LPVOID) WSCWriteNameSpaceOrder,
    (LPVOID) WSCUpdateProvider,

    (LPVOID) getaddrinfo,
    (LPVOID) getnameinfo,
    (LPVOID) freeaddrinfo,
#ifdef _WIN64
    (LPVOID) WSCEnumProtocols32,
    (LPVOID) WSCInstallProvider64_32,
    (LPVOID) WSCDeinstallProvider32,
    (LPVOID) WSCGetProviderPath32,
    (LPVOID) WSCUpdateProvider32,
    (LPVOID) WSCWriteProviderOrder32,
    (LPVOID) WSCEnumNameSpaceProviders32,
    (LPVOID) WSCInstallNameSpace32,
    (LPVOID) WSCUnInstallNameSpace32,
    (LPVOID) WSCEnableNSProvider32,
    (LPVOID) WSCWriteNameSpaceOrder32,
#endif //_WIN64
#endif // DEBUG_TRACING
};

static char *aszFuncNames[] =
{
    "accept",
    "bind",
    "closesocket",
    "connect",
    "getpeername",
    "getsockname",
    "getsockopt",
    "htonl",
    "htons",
    "ioctlsocket",
    "inet_addr",
    "inet_ntoa",
    "listen",
    "ntohl",
    "ntohs",
    "recv",
    "recvfrom",
    "select",
    "send",
    "sendto",
    "setsockopt",
    "shutdown",
    "socket",
    "gethostbyaddr",
    "gethostbyname",
    "getprotobyname",
    "getprotobynumber",
    "getservbyname",
    "getservbyport",
    "gethostname",
    "WSAAsyncSelect",
    "WSAAsyncGetHostByAddr",
    "WSAAsyncGetHostByName",
    "WSAAsyncGetProtoByNumber",
    "WSAAsyncGetProtoByName",
    "WSAAsyncGetServByPort",
    "WSAAsyncGetServByName",
    "WSACancelAsyncRequest",
    "WSASetBlockingHook",
    "WSAUnhookBlockingHook",
    "WSAGetLastError",
    "WSASetLastError",
    "WSACancelBlockingCall",
    "WSAIsBlocking",
    "WSAStartup",
    "WSACleanup",

    "WSAAccept",
    "WSACloseEvent",
    "WSAConnect",
    "WSACreateEvent",
    "WSADuplicateSocketA",
    "WSADuplicateSocketW",
    "WSAEnumNetworkEvents",
    "WSAEnumProtocolsA",
    "WSAEnumProtocolsW",
    "WSAEventSelect",
    "WSAGetOverlappedResult",
    "WSAGetQOSByName",
    "WSAHtonl",
    "WSAHtons",
    "WSAIoctl",
    "WSAJoinLeaf",
    "WSANtohl",
    "WSANtohs",
    "WSARecv",
    "WSARecvDisconnect",
    "WSARecvFrom",
    "WSAResetEvent",
    "WSASend",
    "WSASendDisconnect",
    "WSASendTo",
    "WSASetEvent",
    "WSASocketA",
    "WSASocketW",
    "WSAWaitForMultipleEvents",

    "WSAAddressToStringA",
    "WSAAddressToStringW",
    "WSAStringToAddressA",
    "WSAStringToAddressW",
    "WSALookupServiceBeginA",
    "WSALookupServiceBeginW",
    "WSALookupServiceNextA",
    "WSALookupServiceNextW",
    "WSANSPIoctl",
    "WSALookupServiceEnd",
    "WSAInstallServiceClassA",
    "WSAInstallServiceClassW",
    "WSARemoveServiceClass",
    "WSAGetServiceClassInfoA",
    "WSAGetServiceClassInfoW",
    "WSAEnumNameSpaceProvidersA",
    "WSAEnumNameSpaceProvidersW",
    "WSAGetServiceClassNameByClassIdA",
    "WSAGetServiceClassNameByClassIdW",
    "WSASetServiceA",
    "WSASetServiceW",

    "WSCDeinstallProvider",
    "WSCInstallProvider",
    "WSCEnumProtocols",
    "WSCGetProviderPath",
    "WSCInstallNameSpace",
    "WSCUnInstallNameSpace",
    "WSCEnableNSProvider",

    "WPUCompleteOverlappedRequest",

    "WSAProviderConfigChange",

    "WSCWriteProviderOrder",
    "WSCWriteNameSpaceOrder",
    "WSCUpdateProvider",

    "getaddrinfo",
    "getnameinfo",
    "freeaddrinfo",

#ifdef _WIN64
    "WSCEnumProtocols32",
    "WSCInstallProvider64_32",
    "WSCDeinstallProvider32",
    "WSCGetProviderPath32",
    "WSCUpdateProvider32",
    "WSCWriteProviderOrder32",
    "WSCEnumNameSpaceProviders32",
    "WSCInstallNameSpace32",
    "WSCUnInstallNameSpace32",
    "WSCEnableNSProvider32",
    "WSCWriteNameSpaceOrder32",
#endif // _WIN64
    NULL
};


INT
CheckForHookersOrChainers()
/*++

Routine Description:

    This procedure checks to see if there are any ws2_32 hookers or chainers
    out there, returning ERROR_SUCCESS if not or SOCKET_ERROR if so.

Arguments:

    None

Return Value:

    None
--*/
{
    LPVOID pfnXxx;
    int i;

    DEBUGF(DBG_TRACE, ("Checking for ws2_32 hookers or chainers...\n"));

    for (i = 0; aszFuncNames[i]; i++)
    {
        if (!(pfnXxx = (LPVOID) GetProcAddress (gDllHandle, aszFuncNames[i])) ||
            pfnXxx != apfns[i])
        {
            DEBUGF(DBG_ERR, ("Hooker or chainer found for %s @ %p, failing init\n",
                            aszFuncNames[i], pfnXxx));

            return SOCKET_ERROR;
        }
    }

    DEBUGF(DBG_TRACE, ("No ws2_32 hookers or chainers found\n"));

    return ERROR_SUCCESS;

}  // CheckForHookersOrChainers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsock32\makefile.inc ===
$(O)\nlstxt.mc: $(PROJECT_ROOT)\inc\unixapis.mc ..\..\sockutil\sockutil.mc localmsg.mc
    copy $(PROJECT_ROOT)\inc\unixapis.mc+..\..\sockutil\sockutil.mc+localmsg.mc $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\ws2_32\src\wsautil.cpp ===
/*++


    Intel Corporation Proprietary Information
    Copyright (c) 1995 Intel Corporation

    This listing is supplied under the terms of a license agreement with
    Intel Corporation and may not be used, copied, nor disclosed except in
    accordance with the terms of that agreeement.


Module Name:

    wsautil.cpp

Abstract:

    This  module  contains utility functions for the winsock DLL implementation
    that did not seem to fit into the other module.

Author:

    Dirk Brandewie dirk@mink.intel.com

Notes:

    $Revision:   1.24  $

    $Modtime:   14 Feb 1996 10:32:32  $

Revision History:

    23-Aug-1995 dirk@mink.intel.com
        Moved includes into precomp.h

    07-31-1995 drewsxpa@ashland.intel.com
        Added Registry-manipulation functions

    07-18-1995 dirk@mink.intel.com
        Initial revision

--*/

#include "precomp.h"

//
// Global pointer to the appropriate prolog function. This either points
// to Prolog_v1 for WinSock 1.1 apps or Prolog_v2 for WinSock 2.x apps.
//

LPFN_PROLOG PrologPointer = &Prolog_v2;
HANDLE      gHeap = NULL;



INT
WINAPI
SlowPrologOvlp (
        OUT     PDTHREAD FAR *  Thread
        ) 
{
    PDPROCESS   Process;
        
    return PROLOG( &Process, Thread );
}



INT
WINAPI
SlowProlog(
    VOID
    ) 
{
    PDPROCESS   Process;
    PDTHREAD    Thread;

    return PROLOG( &Process, &Thread );
}



INT
WINAPI
Prolog_v2(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    )
/*++

Routine Description:

     This routine is the standard WinSock 1.1 prolog function used at all the
     winsock API entrypoints.  This function ensures that the process has
     called WSAStartup.

Arguments:

    Process   - Pointer to the DPROCESS object for the process calling the
                winsock API.

    Thread    - Pointer to the DTHREAD object for the calling thread

Returns:

    This function returns ERROR_SUCCESS if successful, otherwise 
    the specific WinSock error code

--*/

{   
    INT ErrorCode;
    if ((*Process = DPROCESS::GetCurrentDProcess()) !=NULL) {
        *Thread = DTHREAD::GetCurrentDThread();
        if (*Thread!=NULL) {
            ErrorCode = ERROR_SUCCESS;
        }
        else {
            ErrorCode = DTHREAD::CreateDThreadForCurrentThread (*Process, Thread);
        }
    } //if
    else {
        ErrorCode = WSANOTINITIALISED;
    }
    return(ErrorCode);

}   // Prolog_v2



INT
WINAPI
Prolog_v1(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    )
/*++

Routine Description:

    This routine is the standard WinSock 1.1 prolog function used at all the
    winsock API entrypoints.  This function ensures that the process has
    called WSAStartup and that the current thread in the process does not have
    a WinSock call outstanding.

Arguments:

    Process   - Pointer to the DPROCESS object for the process calling the
                winsock API.

    Thread    - Pointer to the DTHREAD object for the calling thread


Returns:

    This function returns ERROR_SUCCESS if successful, otherwise 
    the specific WinSock error code

--*/
{
    INT ErrorCode;


    if ((*Process=DPROCESS::GetCurrentDProcess())!=NULL) {
        *Thread = DTHREAD::GetCurrentDThread();
        if (*Thread!=NULL) {
            ErrorCode = ERROR_SUCCESS;
        }
        else {
            ErrorCode = DTHREAD::CreateDThreadForCurrentThread (*Process, Thread);
        }
        if (ErrorCode == ERROR_SUCCESS) {
            if( !(*Thread)->IsBlocking() ) {
                ;
            } else {
                ErrorCode = WSAEINPROGRESS;
            }
        } //if

    } //if
    else {
        ErrorCode = WSANOTINITIALISED;
    }
    return(ErrorCode);
}   // Prolog_v1



INT
WINAPI
Prolog_Detached(
    OUT PDPROCESS FAR * Process,
    OUT PDTHREAD FAR * Thread
    )
/*++

Routine Description:

    API prolog used after we've been detached from the process's address
    space. In theory, this should be totally unnecessary, but at least one
    popular DLL (MFC 4.x) calls WSACleanup() in its process detach handler,
    which may occur *after* our DLL is already detached. Grr...

Arguments:

    Process - Unused.

    Thread - Unused.

Returns:

    INT - Always WSASYSNOTREADY.

--*/
{
    Process;
    Thread;

    return WSASYSNOTREADY;

}   // Prolog_Detached



BOOL
WriteRegistryEntry(
    IN      HKEY            EntryKey,
    IN      LPCTSTR         EntryName,
    IN      PVOID           Data,
    IN      DWORD           TypeFlag
    )
/*++

Routine Description:

    This  procedure  writes  a  single named value into an opened registry key.
    The  value  may  be  any  type whose length can be determined from its type
    (e.g., scalar types, zero-terminated strings).

Arguments:

    EntryKey  - Supplies  the open entry key under which the new named value is
                to be written.

    EntryName - Supplies the name of the value to be written.

    Data      - Supplies  a  reference  to the location where the entry data is
                found,  or to a WSABUF describing the data location in the case
                of REG_BINARY data.

    TypeFlag  - Supplies  an identifier for the type of the data to be written.
                Supported   types  are  REG_BINARY,  REG_DWORD,  REG_EXPAND_SZ,
                REG_SZ.    Types   not   supported   are  REG_DWORD_BIG_ENDIAN,
                REG_DWORD_LITTLE_ENDIAN,   REG_LINK,   REG_MULTI_SZ,  REG_NONE,
                REG_RESOURCE_LIST.   Note  that  depending on the architecture,
                one   of   the   "big_endian"   or   "little_endian"  forms  of
                REG_DWORD_x_ENDIAN  is implicitly allowed, since it is equal to
                REG_DWORD.

Return Value:

    The function returns TRUE if successful, or FALSE if an error occurred.

Implementation note:

    There was no need identified for the REG_MULTI_SZ case, so support for this
    case  was  omitted  since  it was more difficult to derive the data length.
    There  is  no  reason  in  principle why this case cannot be added if it is
    really needed.

--*/
{
    DWORD   cbData;
    LONG    result;
    BOOL    ok_so_far;
    BYTE *  data_buf;

    assert( (TypeFlag == REG_BINARY) ||
            (TypeFlag == REG_DWORD) ||
            (TypeFlag == REG_EXPAND_SZ) ||
            (TypeFlag == REG_SZ));


    ok_so_far = TRUE;

    switch (TypeFlag) {
        case REG_BINARY:
            cbData = (DWORD) (((LPWSABUF) Data)->len);
            data_buf = (BYTE *) (((LPWSABUF) Data)->buf);
            break;

        case REG_DWORD:
            cbData = sizeof(DWORD);
            data_buf = (BYTE *) Data;
            break;

        case REG_EXPAND_SZ:
            cbData = (DWORD) (lstrlen((char *) Data)+1);
            data_buf = (BYTE *) Data;
            break;

        case REG_SZ:
            cbData = (DWORD) (lstrlen((char *) Data)+1);
            data_buf = (BYTE *) Data;
            break;

        default:
            DEBUGF(
                DBG_ERR,
                ("Unsupported type flag specified (%lu)",
                TypeFlag));
            ok_so_far = FALSE;
            break;

    }  // switch (TypeFlag)

    if (ok_so_far) {
        result = RegSetValueEx(
                    EntryKey,             // hkey
                    (LPCTSTR) EntryName,  // lpszValueName
                    0,                    // dwReserved
                    TypeFlag,             // fdwType
                    data_buf,             // lpbData
                    cbData                // cbData
                    );
        if (result != ERROR_SUCCESS) {
            DEBUGF(
                DBG_ERR,
                ("Setting value %s, err:%ld\n",
                EntryName, result));
            ok_so_far = FALSE;
        } // if not success
    } // if ok_so_far

    return (ok_so_far);

}  // WriteRegistryEntry



BOOL
ReadRegistryEntry(
    IN      HKEY    EntryKey,
    IN      LPTSTR  EntryName,
    OUT     PVOID   Data,
    IN      DWORD   MaxBytes,
    IN      DWORD   TypeFlag
    )
/*++

Routine Description:

    This procedure reads a single named value from an opened registry key.  The
    value  may  be any type whose length can be determined from its type (e.g.,
    scalar  types,  zero-terminated  strings).  The function checks the type of
    the newly read value to make sure it matches the expected type.

Arguments:

    EntryKey  - Supplies  the  open entry key from which the new named value is
                to be read.

    EntryName - Supplies the name of the value to be read.

    Data      - Supplies  a  reference  to the location where the entry data is
                placed.   Returns  the registry entry value.  In the case where
                the  TypeFlag  is  REG_BINARY,  this is a reference to a WSABUF
                describing the target data buffer.  The "len" field returns the
                length read (or required) from the registry.

    MaxData   - Supplies the size in bytes of the Data buffer supplied.

    TypeFlag  - Supplies  an  identifier  for  the type of the data to be read.
                Supported   types  are  REG_BINARY,  REG_DWORD,  REG_EXPAND_SZ,
                REG_SZ.    Types   not   supported   are  REG_DWORD_BIG_ENDIAN,
                REG_DWORD_LITTLE_ENDIAN,   REG_LINK,   REG_MULTI_SZ,  REG_NONE,
                REG_RESOURCE_LIST.   Note  that  depending on the architecture,
                one   of   the   "big_endian"   or   "little_endian"  forms  of
                REG_DWORD_x_ENDIAN  is implicitly allowed, since it is equal to
                REG_DWORD.

Return Value:

    The  function  returns  TRUE  if successful, or FALSE if an error occurred.
    Errors include unsupported types, non-matching types, and oversize data.

Implementation note:

    There was no need identified for the REG_MULTI_SZ case, so support for this
    case  was  omitted  since  it was more difficult to derive the data length.
    There  is  no  reason  in  principle why this case cannot be added if it is
    really needed.

    The  validity  checks  in this routine have been written as a linear series
    instead  of  in the "conditional-tunnelling" nested-if form.  The series of
    tests  is  long  enough that the nested-if form is far too complex to read.
    This  procedure  should  not  be sensitive to execution speed, so the extra
    tests and branches in the linear series form should not be a problem.
--*/
{
    DWORD  count_expected;
    LONG   result;
    DWORD  type_read;
    DWORD  entry_size;
    BOOL   need_exact_length;
    BOOL   ok_so_far;
    BYTE * data_buf;

    assert(
        (TypeFlag == REG_BINARY) ||
        (TypeFlag == REG_DWORD) ||
        (TypeFlag == REG_EXPAND_SZ) ||
        (TypeFlag == REG_SZ));

    ok_so_far = TRUE;

    switch (TypeFlag) {
        case REG_BINARY:
            count_expected = MaxBytes;
            // Special case: REG_BINARY length compared against maximum
            need_exact_length = FALSE;
            data_buf = (BYTE *) (((LPWSABUF) Data)->buf);
            break;

        case REG_DWORD:
            count_expected = sizeof(DWORD);
            need_exact_length = TRUE;
            data_buf = (BYTE *) Data;
            break;

        case REG_EXPAND_SZ:
            count_expected = MaxBytes;
            // Special case: strings length compared against maximum
            need_exact_length = FALSE;
            data_buf = (BYTE *) Data;
            break;

        case REG_SZ:
            count_expected = MaxBytes;
            // Special case: strings length compared against maximum
            need_exact_length = FALSE;
            data_buf = (BYTE *) Data;
            break;

        default:
            DEBUGF(
                DBG_ERR,
                ("Unsupported type flag specified (%lu)",
                TypeFlag));
            ok_so_far = FALSE;
            break;

    }  // switch (TypeFlag)


    // Read from registry
    if (ok_so_far) {
        entry_size = MaxBytes;
        result = RegQueryValueEx(
            EntryKey,            // hkey
            (LPTSTR) EntryName,  // lpszValueName
            0,                   // dwReserved
            & type_read,         // lpdwType
            data_buf,            // lpbData
            & entry_size         // lpcbData
            );
        if (result != ERROR_SUCCESS) {
            DEBUGF(
                DBG_WARN,
                ("Reading value %s, err: %ld\n",
                EntryName, result));
            if (result == ERROR_MORE_DATA) {
                DEBUGF(
                    DBG_WARN,
                    ("Data buffer too small\n"));
            } // if ERROR_MORE_DATA
            ok_so_far = FALSE;
        } // if result != ERROR_SUCCESS
    } // if ok_so_far


    // Special case for REG_BINARY
    if (TypeFlag == REG_BINARY) {
        (((LPWSABUF) Data)->len) = (u_long) entry_size;
    }


    // check type
    if (ok_so_far) {
        if (type_read != TypeFlag) {
            DEBUGF(
                DBG_ERR,
                ("Type read (%lu) different from expected (%lu)\n",
                type_read,
                TypeFlag));
            ok_so_far = FALSE;
        } // if type_read != TypeFlag
    } // if ok_so_far


    // Check length
    if (ok_so_far) {
        if (need_exact_length) {
            if (count_expected != entry_size) {
                DEBUGF(
                    DBG_ERR,
                    ("Length read (%lu) different from expected (%lu)\n",
                    entry_size,
                    count_expected));
                ok_so_far = FALSE;
             } // if size mismatch
        } // if need_exact_length
    } // if ok_so_far

    return ok_so_far;

}  // ReadRegistryEntry




LONG
RegDeleteKeyRecursive(
    IN      HKEY            hkey,
    IN      LPCTSTR         lpszSubKey
    )
/*++

Routine Description:

    The RegDeleteKeyRecursive function deletes the specified key and all of its
    subkeys, recursively.

Arguments:

    hkey       - Supplies  a  currently  open  key  or  any  of  the  following
                 predefined reserved handle values:

                 HKEY_CLASSES_ROOT
                 HKEY_CURRENT_USER
                 HKEY_LOCAL_MACHINE
                 HKEY_USERS

                 The key specified by the lpszSubKey parameter must be a subkey
                 of the key identified by hkey.

    lpszSubKey - Supplies  a  reference  to a null-terminated string specifying
                 the name of the key to delete.  This parameter cannot be NULL.
                 The specified key may have subkeys.

Return Value:

    If  the  function  succeeds,  the  return  value  is ERROR_SUCCESS.  If the
    function fails, the return value is an operating system error value.

Implementation Notes:

    Open targetkey
    while find subkey
        RegDeleteKeyRecursive(... subkey)
    end while
    close targetkey
    delete targetkey

--*/
{
    LONG    result;
    HKEY    targetkey;
    LONG    return_value;

    DEBUGF(
        DBG_TRACE,
        ("RegDeleteKeyRecursive (%lu), '%s'\n",
        (ULONG_PTR) hkey,
        lpszSubKey));

    result = RegOpenKeyEx(
                hkey,            // hkey
                lpszSubKey,      // lpszSubKey
                0,               // dwReserved
                KEY_READ|KEY_WRITE,// samDesired
                & targetkey      // phkResult
                );

    if (result != ERROR_SUCCESS) {
        DEBUGF(
            DBG_WARN,
            ("Opening key '%s' to be deleted, err: %ld\n",
            lpszSubKey, result));
        return result;
    }

    //
    //  delete subkeys of target key
    //

    {
        BOOL      deleting_subkeys;
        LPTSTR    subkey_name;
        DWORD     subkey_name_len;
        FILETIME  dont_care;

        return_value = ERROR_SUCCESS;
        deleting_subkeys = TRUE;
        subkey_name = (LPTSTR) new char[MAX_PATH];
        if ( subkey_name == NULL ) {
            return_value = ERROR_OUTOFMEMORY;
            deleting_subkeys = FALSE;
        }
        while (deleting_subkeys) {
            subkey_name_len = MAX_PATH;
            // Since  we  delete  a  subkey  each  time  through this loop, the
            // remaining  subkeys  effectively  get  renumbered.  Therefore the
            // subkey   index  we  "enumerate"  each  time  is  0  (instead  of
            // incrementing) to retrieve any remaining subkey.
            result = RegEnumKeyEx(
                        targetkey,         // hkey
                        0,                 // iSubkey
                        subkey_name,       // lpszName
                        & subkey_name_len, // lpcchName
                        0,                 // lpdwReserved
                        NULL,              // lpszClass
                        NULL,              // lpcchClass
                        & dont_care        // lpftLastWrite
                        );
            switch (result) {
                case ERROR_SUCCESS:
                    result = RegDeleteKeyRecursive(
                        targetkey,   // hkey
                        subkey_name  // lpszSubKey
                        );
                    if (result != ERROR_SUCCESS) {
                        deleting_subkeys = FALSE;
                        return_value = result;
                    }
                    break;

                case ERROR_NO_MORE_ITEMS:
                    deleting_subkeys = FALSE;
                    break;

                default:
                    DEBUGF(
                        DBG_ERR,
                        ("Unable to enumerate subkeys\n"));
                    deleting_subkeys = FALSE;
                    return_value = result;
                    break;

            }  // switch (result)
        }  // while (deleting_subkeys)

        delete subkey_name;
    }

    //
    //  finally delete target key itself
    //

    result = RegCloseKey( targetkey );

    if ( result != ERROR_SUCCESS ) {
        DEBUGF(
            DBG_ERR,
            ("Closing subkey %s, err: %ld\n",
            lpszSubKey, result));
        return_value = result;
    }

    result = RegDeleteKey(
                hkey,       // hkey
                lpszSubKey  // lpszSubKey
                );
    if ( result != ERROR_SUCCESS ) {
        DEBUGF(
            DBG_WARN,
            ("Deleting subkey %s, err: %ld\n",
            lpszSubKey, result));
        return_value = result;
    }

    return return_value;

}  // RegDeleteKeyRecursive



LONG
RegDeleteSubkeys(
    IN      HKEY            hkey
    )
/*++

Routine Description:

    Deletes all the first level subkeys of the specified key

Arguments:

    hkey -  Supplies a currently open key or any of the following
            predefined reserved handle values:
                HKEY_CLASSES_ROOT
                HKEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

Return Value:

    ERROR_SUCCESS if successful.
    Win32 error on failure.

--*/
{
    BOOL        deleting_subkeys = TRUE;
    LONG        result;
    LONG        return_value;
    LPTSTR      subkey_name;
    DWORD       subkey_name_len;
    FILETIME    dont_care;

    DEBUGF( DBG_TRACE, (
        "RegDeleteSubkeys (%lu)\n",
        (ULONG_PTR)hkey));

    subkey_name = (LPTSTR) new char[MAX_PATH];
    if (subkey_name == NULL) {
        return WSA_NOT_ENOUGH_MEMORY;
    }

    return_value = ERROR_SUCCESS;
    while (deleting_subkeys) {
        subkey_name_len = MAX_PATH;
        // Since  we  delete  a  subkey  each  time  through this loop, the
        // remaining  subkeys  effectively  get  renumbered.  Therefore the
        // subkey   index  we  "enumerate"  each  time  is  0  (instead  of
        // incrementing) to retrieve any remaining subkey.
        result = RegEnumKeyEx(
                    hkey,               // hkey
                    0,                 // iSubkey
                    subkey_name,       // lpszName
                    & subkey_name_len, // lpcchName
                    0,                 // lpdwReserved
                    NULL,              // lpszClass
                    NULL,              // lpcchClass
                    & dont_care        // lpftLastWrite
                    );
        switch (result) {
            case ERROR_SUCCESS:
                result = RegDeleteKey(
                    hkey,        // hkey
                    subkey_name  // lpszSubKey
                    );
                if (result != ERROR_SUCCESS) {
                    deleting_subkeys = FALSE;
                    return_value = result;
                }
                break;

            case ERROR_NO_MORE_ITEMS:
                deleting_subkeys = FALSE;
                break;

            default:
                DEBUGF(
                    DBG_ERR,
                    ("Enumerating subkeys %ld\n", result));
                deleting_subkeys = FALSE;
                return_value = result;
                break;

        }  // switch (result)
    }  // while (deleting_subkeys)

    delete subkey_name;

    return return_value;

}  // RegDeleteSubkeys



HKEY
OpenWinSockRegistryRoot(
    VOID
    )
/*++

Routine Description:

    This  procedure opens the root of the WinSock2 portion of the registry.  It
    takes  care  of  creating  and initializing the root if necessary.  It also
    takes  care  of  comparing versions of the WinSock2 portion of the registry
    and updating the registry version if required.

    It   is   the  caller's  responsibility  to  call  CloseWinSockRegistryRoot
    eventually with the returned key.

Arguments:

    None

Return Value:

    The  function  returns the opened registry key if successful.  If it is not
    successful, it returns NULL.

Implementation Notes:

    The first version of this function has no previous versions of the registry
    to  be  compatible  with,  so it does not have to take care of updating any
    out-of-date  registry  information.   If  and  when  the  WinSock  spec  or
    implementation  is  updated  in a way that changes the registry information
    this procedure may have to be updated to update the registry.
--*/
{
    HKEY    root_key;
    LONG    lresult;
    DWORD   create_disp;

    DEBUGF(
        DBG_TRACE,
        ("OpenWinSockRegistryRoot\n"));

    //
    // We must first try to open the key before trying to create it.
    // RegCreateKeyEx() will fail with ERROR_ACCESS_DENIED if the current
    // user has insufficient privilege to create the target registry key,
    // even if that key already exists.
    //

    lresult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,             // hkey
        WINSOCK_REGISTRY_ROOT,          // lpszSubKey
        0,                              // dwReserved
        MAXIMUM_ALLOWED,                // samDesired
        & root_key                      // phkResult
        );

    if( lresult == ERROR_SUCCESS ) {
        create_disp = REG_OPENED_EXISTING_KEY;
    } else if( lresult == ERROR_FILE_NOT_FOUND ) {
        lresult = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,         // hkey
            WINSOCK_REGISTRY_ROOT,      // lpszSubKey
            0,                          // dwReserved
            NULL,                       // lpszClass
            REG_OPTION_NON_VOLATILE,    // fdwOptions
            KEY_READ|KEY_WRITE,         // samDesired
            NULL,                       // lpSecurityAttributes
            & root_key,                 // phkResult
            & create_disp               // lpdwDisposition
            );
    }
    if (lresult != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Creating/opening registry root, err: %ld\n",
            lresult));
        return NULL;
    }

    TRY_START(guard_root_open) {

        BOOL   bresult;
        TCHAR  reg_version[] = WINSOCK_REGISTRY_VERSION_VALUE;
        // Initialization forces size to be the size desired.

        switch (create_disp) {
            case REG_CREATED_NEW_KEY:
                bresult = WriteRegistryEntry(
                    root_key,                               // EntryKey
                    WINSOCK_REGISTRY_VERSION_NAME,          // EntryName
                    (PVOID)WINSOCK_REGISTRY_VERSION_VALUE,  // Data
                    REG_SZ                                  // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Writing version value to registry\n"));
                    TRY_THROW(guard_root_open);
                }
                break;

            case REG_OPENED_EXISTING_KEY:
                bresult = ReadRegistryEntry(
                    root_key,                               // EntryKey
                    WINSOCK_REGISTRY_VERSION_NAME,          // EntryName
                    (PVOID) reg_version,                    // Data
                    sizeof(reg_version),                    // MaxBytes
                    REG_SZ                                  // TypeFlag
                    );
                if (! bresult) {
                    DEBUGF(
                        DBG_ERR,
                        ("Reading version value from registry\n"));
                    TRY_THROW(guard_root_open);
                }
                if (lstrcmp(reg_version, WINSOCK_REGISTRY_VERSION_VALUE) != 0) {
                    DEBUGF(
                        DBG_ERR,
                        ("Expected registry version '%s', got '%s'\n",
                        WINSOCK_REGISTRY_VERSION_VALUE,
                        reg_version));
                    TRY_THROW(guard_root_open);
                }
                break;

            default:
                break;

        }  // switch (create_disp)

    } TRY_CATCH(guard_root_open) {
        CloseWinSockRegistryRoot(root_key);
        root_key = NULL;
    } TRY_END(guard_root_open);

    return root_key;

}  // OpenWinSockRegistryRoot



VOID
CloseWinSockRegistryRoot(
    IN      HKEY            RootKey
    )
/*++

Routine Description:

    This  procedure  closes  the open registry key representing the root of the
    WinSock  portion  of the registry.  The function checks for and handles any
    errors that might occur.

Arguments:

    RootKey - Supplies  the  open  registry  key  representing  the root of the
              WinSock portion of the registry.

Return Value:

    None

--*/
{
    LONG lresult;

    DEBUGF( DBG_TRACE,
        ("Closing registry root\n"));

    lresult = RegCloseKey( RootKey );

    if ( lresult != ERROR_SUCCESS) {
        DEBUGF(
            DBG_ERR,
            ("Closing registry root, err: %ld\n",
            lresult));
    }

}  // CloseWinSockRegistryRoot



INT
MapUnicodeProtocolInfoToAnsi(
    IN      LPWSAPROTOCOL_INFOW UnicodeProtocolInfo,
    OUT     LPWSAPROTOCOL_INFOA AnsiProtocolInfo
    )
/*++

Routine Description:

    This procedure maps a UNICODE WSAPROTOCOL_INFOW structure to the
    corresponding ANSI WSAPROTOCOL_INFOA structure. All scalar fields
    are copied over "as is" and any embedded strings are mapped.

Arguments:

    UnicodeProtocolInfo - Points to the source WSAPROTOCOL_INFOW structure.

    AnsiProtocolInfo - Points to the destination WSAPROTOCOL_INFOA structure.

Return Value:

    INT - ERROR_SUCCESS if successful, a Win32 status code otherwise.

--*/
{
    INT result;

    //
    // Sanity check.
    //

    assert( UnicodeProtocolInfo != NULL );
    assert( AnsiProtocolInfo != NULL );


    __try {
        //
        // Copy over the scalar values.
        //
        // Just to make things a bit easier, this code depends on the fact
        // that the szProtocol[] character array is the last field of the
        // WSAPROTOCOL_INFO structure.
        //

        CopyMemory(
            AnsiProtocolInfo,
            UnicodeProtocolInfo,
            sizeof(*UnicodeProtocolInfo) - sizeof(UnicodeProtocolInfo->szProtocol)
            );

        //
        // And now map the string from UNICODE to ANSI.
        //

        result = WideCharToMultiByte(
                     CP_ACP,                                    // CodePage (ANSI)
                     0,                                         // dwFlags
                     UnicodeProtocolInfo->szProtocol,           // lpWideCharStr
                     -1,                                        // cchWideChar
                     AnsiProtocolInfo->szProtocol,              // lpMultiByteStr
                     sizeof(AnsiProtocolInfo->szProtocol),      // cchMultiByte
                     NULL,                                      // lpDefaultChar
                     NULL                                       // lpUsedDefaultChar
                     );

        if( result == 0 ) {

            // WideCharToMultiByte() failed.

            return WSASYSCALLFAILURE;
        }

        //
        // Success!
        //

        return ERROR_SUCCESS;
    }
    __except (WS2_EXCEPTION_FILTER()) {
        return WSAEFAULT;
    }

}   // MapUnicodeProtocolInfoToAnsi




INT
MapAnsiProtocolInfoToUnicode(
    IN      LPWSAPROTOCOL_INFOA AnsiProtocolInfo,
    OUT     LPWSAPROTOCOL_INFOW UnicodeProtocolInfo
    )
/*++

Routine Description:

    This procedure maps an ANSI WSAPROTOCOL_INFOA structure to the
    corresponding UNICODE WSAPROTOCOL_INFOW structure. All scalar fields
    are copied over "as is" and any embedded strings are mapped.

Arguments:

    AnsiProtocolInfo - Points to the source WSAPROTOCOL_INFOA structure.

    UnicodeProtocolInfo - Points to the destination WSAPROTOCOL_INFOW
        structure.

Return Value:

    INT - ERROR_SUCCESS if successful, a Win32 status code otherwise.

--*/
{
    INT result;

    //
    // Sanity check.
    //

    assert( AnsiProtocolInfo != NULL );
    assert( UnicodeProtocolInfo != NULL );

    __try {
        //
        // Copy over the scalar values.
        //
        // Just to make things a bit easier, this code depends on the fact
        // that the szProtocol[] character array is the last field of the
        // WSAPROTOCOL_INFO structure.
        //

        CopyMemory(
            UnicodeProtocolInfo,
            AnsiProtocolInfo,
            sizeof(*AnsiProtocolInfo) - sizeof(AnsiProtocolInfo->szProtocol)
            );

        //
        // And now map the string from ANSI to UNICODE.
        //

        result = MultiByteToWideChar(
                     CP_ACP,                                    // CodePage (ANSI)
                     0,                                         // dwFlags
                     AnsiProtocolInfo->szProtocol,              // lpMultiByteStr
                     -1,                                        // cchWideChar
                     UnicodeProtocolInfo->szProtocol,           // lpWideCharStr
                     sizeof(UnicodeProtocolInfo->szProtocol)    // cchMultiByte
                     );

        if( result == 0 ) {

            //
            // MultiByteToWideChar() failed.
            //

            return WSASYSCALLFAILURE;

        }

        //
        // Success!
        //

        return ERROR_SUCCESS;

    }
    __except (WS2_EXCEPTION_FILTER()) {
        return WSAEFAULT;
    }
}   // MapAnsiProtocolInfoToUnicode



VOID
ValidateCurrentCatalogName(
    IN      HKEY            RootKey,
    IN      LPSTR           ValueName,
    IN      LPSTR           ExpectedName
    )
/*++

Routine Description:

    This routine checks for consistency between the protocol or namespace
    catalog as stored in the registry and the catalog format expected by
    the current version of this DLL. There's no great magic here; this
    code assumes that the person updating the registry format will change
    the catalog to use a different catalog name (such as Protocol_Catalog9,
    Protocol_Catalog10, etc.). This assumption means we can validate the
    registry format by validating the *name* of the registry key used
    for this catalog.

    The following steps are performed:

        1.  Try to read 'ValueName' from the registry.

        2.  If it doesn't exist, cool. Just create the new value. This
            typically means we're updating a pre-release system that
            did not support this mechanism.

        3.  If it does, and its value matches 'ExpectedName', fine.

        4.  If it does, and its value doesn't match, then the catalog
            format has been updated, so blow away the old catalog, then
            write the updated value into the registry.

    Since this routine is called at setup/upgrade time, it should only
    fail if something truly horrible happens. In other words, it should
    be very 'fault tolerant'.

Arguments:

    RootKey - An open key to the WinSock configuration registry tree.

    ValueName - The name of the registry value that contains the name
        of the current catalog. This will typically be a value such as
        "Current_Protocol_Catalog" or "Current_NameSpace_Catalog".

    ExpectedName - The expected value stored in the 'ValueName' registry
        value. This will typically be a value such as "Protocol_Catalog9"
        or "NameSpace_Catalog5".

Return Value:

    None.

--*/
{
    BOOL    result;
    LONG    err;
    CHAR    value[MAX_CATALOG_NAME_LENGTH];

    //
    // Try to read the name from the registry.
    //

    result = ReadRegistryEntry(
                 RootKey,
                 ValueName,
                 (PVOID)value,
                 sizeof(value),
                 REG_SZ
                 );

    if( result ) {

        if( lstrcmp( value, ExpectedName ) == 0 ) {

            //
            // No update in format. We're done.
            //

            return;
        }

        //
        // The values don't match, indicating an update in registry format.
        // So, blow away the old key.
        //

        err = RegDeleteKeyRecursive(
                  RootKey,
                  value
                  );

        if( err != NO_ERROR ) {

            // Unfortunate, but nonfatal.

            DEBUGF(
                DBG_ERR,
                ("Deleting key %s, continuing\n",
                value
                ));
        }
    }

    //
    // At this point, we either couldn't read the value from the registry
    // (probably indicating that we're upgrading a pre-release system
    // that was setup before we supported this particular feature) OR
    // the values don't match and we've just blown away the old catalog.
    // In either case we need to update the value in the registry before
    // returning.
    //

    result = WriteRegistryEntry(
                 RootKey,
                 ValueName,
                 ExpectedName,
                 REG_SZ
                 );

    if( !result ) {

        // Also unfortunate, but nonfatal.

        DEBUGF(
            DBG_ERR,
            ("Writing %s with value %s\n",
            ValueName,
            ExpectedName
            ));
    }

}   // ValidateCurrentCatalogName



INT
AcquireExclusiveCatalogAccess(
    IN      HKEY    CatalogKey,
    IN      DWORD   ExpectedSerialNum,
    OUT     PHKEY   AccessKey
    )
/*++

Routine Description:

    This procedure acquires registry lock using volatile registry key.
    This ensures that only one application at a time can modify
    registry catalog.

Arguments:

    CatalogKey - Supplies catalog key to lock

    ExpectedSerialNum - Supplies catalog serial number that caller
                        expects to see in the registry. It validates
                        that catalog has not changed since it was last read
                        by the client

    AccessKey - Returns handle to the registry key that is used
                for synchronization (to be passed back in
                ReleaseExclusiveCatalogAccess)

Return Value:

    If  the  function  is  successful, it returns ERROR_SUCCESS.
    Otherwise, it returns an appropriate WinSock error code:

        WSATRY_AGAIN - catalog serial number in the registry does not
                       match the one supplied
        WSAEACCESS   - caller does not have write access to the catalog portion
                       of the registry
        WSASYSCALLFAILURE - one of the registry operation failed

--*/
{
    LONG        lresult;
    BOOL        bresult;
    DWORD       serial_num, disposition;
    HKEY        access_key;
    TCHAR       serial_num_buffer[32];


    // Initialize return value
    *AccessKey = NULL;

    // Read current serial number
    bresult = ReadRegistryEntry (
                    CatalogKey,             // EntryKey
                    SERIAL_NUMBER_NAME,     // EntryName
                    (PVOID) &serial_num,    // Data
                    sizeof (DWORD),         // MaxBytes
                    REG_DWORD               // TypeFlag
                    ); 
    if (!bresult) {
        DEBUGF (DBG_ERR, ("Reading catalog serial number value.\n"));
        return WSASYSCALLFAILURE;
    }

        // Check if it what caller was expecting
    if (ExpectedSerialNum!=serial_num) {
        DEBUGF (DBG_ERR,
            ("Catalog serial number changed since we read it, %ld->%ld.\n",
            ExpectedSerialNum, serial_num));
        return WSATRY_AGAIN;
    }

    // Create synchronization key
    _stprintf (serial_num_buffer, TEXT("%08.8lX"), serial_num);

    lresult = RegCreateKeyEx (
                    CatalogKey,              // hKey
                    serial_num_buffer,      // lpSubKey
                    0,                      // dwReserved
                    NULL,                   // lpszClass
                    REG_OPTION_VOLATILE,    // fdwOptions
                    KEY_READ|KEY_WRITE,     // samDesired
                    NULL,                   // lpSecurityAttributes
                    &access_key,            // phkResult
                    &disposition            // lpdwDisposition
                    );
    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR, ("Creating access key '%s', err: %ld.\n",
            serial_num_buffer));
        if (lresult == ERROR_ACCESS_DENIED)
            return WSAEACCES;
        else
            return WSASYSCALLFAILURE;
    }

    if (disposition==REG_CREATED_NEW_KEY) {
        // We created the key, so caller can have the registry to itself
        *AccessKey = access_key;
        return ERROR_SUCCESS;
    }
    else {
        // The key was there already, someone must be writing to the
        // registry and thus current callers representation of it
        // becomes invalid.
        RegCloseKey (access_key);
        DEBUGF (DBG_WARN, 
            ("Trying to lock accessed catalog, serial num: %ld.\n",
            serial_num));
        return WSATRY_AGAIN;
    }

} // AcquireExclusiveRegistryAccess



VOID
ReleaseExclusiveCatalogAccess(
    IN      HKEY            CatalogKey,
    IN      DWORD           CurrentSerialNum,
    IN      HKEY            access_key
    )
/*++

Routine Description:

    This procedure releases registry lock acquired using
    AcuireExclusiveCatalogAccess.

Arguments:

    CatalogKey       - Supplies catalog key to lock

    CurrentSerialNum - Supplies catalog serial number which was in
                       effect when catalog was locked.

    AccessKey        - Supplise handle to the registry key that was used
                       for synchronization.

Return Value:

    None

--*/
{
    LONG        lresult;
    BOOL        bresult;
    TCHAR       serial_num_buffer[32];

    // Save and increment catalog serial number
    _stprintf (serial_num_buffer, TEXT("%08.8lX"), CurrentSerialNum);
        
    CurrentSerialNum += 1;

    // Store new catalog serial number
    bresult = WriteRegistryEntry (
                    CatalogKey,                                 // EntryKey
                    SERIAL_NUMBER_NAME,                 // EntryName
                    (PVOID)&CurrentSerialNum,   // Data
                    REG_DWORD                                   // TypeFlag
                    );
    if (!bresult) {
        DEBUGF (DBG_ERR,
            ("Writing serial number value %ld.\n", CurrentSerialNum));
        assert (FALSE);
        //
        // Nothing we can do, writer has done its job anyway
        // To recover, the user will have to reboot the machine
        // and the volatile key will not be there anymore.
        //
    }

    lresult = RegDeleteKey (CatalogKey, serial_num_buffer);
    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR,
            ("Deleting serial access key '%s', err: %ld.\n",
                        serial_num_buffer, lresult));
        //
        // Unfortunate but not fatal (just leaves it in the regstry until
        // next reboot);
        //
    }

    lresult = RegCloseKey (access_key);
    if (lresult != ERROR_SUCCESS) {
        DEBUGF (DBG_ERR,
            ("Closing serial access key '%s', err: %ld.\n", 
                        serial_num_buffer, lresult));
        //
        // Unfortunate but not fatal (does not deallocate memory
        // and possibly leaves it in the regstry until next reboot);
        //
    }

} //ReleaseExclusiveRegistryAccess



#define MAX_WRITER_WAIT_TIME    (3*60*1000)
INT
SynchronizeSharedCatalogAccess(
    IN      HKEY            CatalogKey,
    IN      HANDLE          ChangeEvent,
    OUT     LPDWORD         CurrentSerialNum
    )
/*++

Routine Description:

    This procedure synchronizes reades access to the registry
    catalog against possible writers.  It waits for any writers
    that are accessing the catalog at the time of the call
    and establishes event notification mechanism for any registry
    catalog modification afterwards

Arguments:
        CatalogKey      -       Supplies catalog key to synchronize with

    ChangeEvent -   Supplies event to signal when registry catalog 
                    is changed.

    CurrentSerialNumber - Returns current catalog serial number

Return Value:
    If  the  function  is  successful, it returns ERROR_SUCCESS.  Otherwise, it
    returns an appropriate WinSock error code:

    
--*/
{
    LONG    lresult;
    INT     return_value;
    BOOL    bresult;
    DWORD   serial_num;
    TCHAR   serial_num_buffer[32];
    HKEY    access_key;

    do {
        //
        // Register for notification of key creation/deletion
        // (The writer creates and keeps access key while it
        // modifies the catalog)
        //

        lresult = RegNotifyChangeKeyValue (
                    CatalogKey,                 // hKey
                    FALSE,                      // bWatchSubtree
                    REG_NOTIFY_CHANGE_NAME,     // dwNotifyFilter,
                    ChangeEvent,                // hEvent
                    TRUE                        // fAsynchronous
                    );
        if (lresult != ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Registering for registry key change notification, err: %ld.\n",
                lresult));
            return_value = WSASYSCALLFAILURE;
            break;
        }

        // Read current catalog serial number, which is also
        // the name of the writer access key
        bresult = ReadRegistryEntry (
                        CatalogKey,             // EntryKey
                        SERIAL_NUMBER_NAME,     // EntryName
                        (PVOID) &serial_num,    // Data
                        sizeof (DWORD),         // MaxBytes
                        REG_DWORD               // TypeFlag
                        ); 
        if (!bresult) {
            DEBUGF (DBG_ERR, ("Reading '%s' value.\n", SERIAL_NUMBER_NAME));
            return_value = WSASYSCALLFAILURE;
            break;
        }

        // Try to open writer access key.

        _stprintf (serial_num_buffer, TEXT("%08.8lX"), serial_num);

        lresult = RegOpenKeyEx(
                        CatalogKey,             // hkey
                        serial_num_buffer,      // lpszSubKey
                        0,                      // dwReserved
                        MAXIMUM_ALLOWED,        // samDesired
                        & access_key            // phkResult
                        );
        if ((lresult == ERROR_FILE_NOT_FOUND)
                || (lresult == ERROR_KEY_DELETED)) {
            // Key was not found or is being deleted,
            // we can access the catalog
            return_value = ERROR_SUCCESS;
            *CurrentSerialNum = serial_num;
            break;
        }
        else if (lresult != ERROR_SUCCESS) {
            // Some other failure
            DEBUGF (DBG_ERR,
                ("Opening access key '%s', err: %ld.\n", 
                serial_num_buffer, lresult));
            return_value = WSASYSCALLFAILURE;
            break;
        }

        // Success, writer is active, close the key,
        // wait till it gets removed, and start over again

        lresult = RegCloseKey (access_key);
        if (lresult!=ERROR_SUCCESS) {
            DEBUGF (DBG_ERR,
                ("Closing access key '%ls', err: %ld.\n", 
                serial_num_buffer, lresult));
            // Non-fatal.
        }
        // Set the error code in case we fail the wait.
        return_value = WSANO_RECOVERY;
        // Limit the wait time in case writer crashed or
        // failed to remove the key.
    }
    while ( WaitForSingleObject( ChangeEvent, MAX_WRITER_WAIT_TIME ) == WAIT_OBJECT_0 );

    return return_value;
}



BOOL
HasCatalogChanged(
    IN      HANDLE  ChangeEvent
    )
/*++

Routine Description:

    This procedure checks if registry catalog has changes since the
    caller has last synchronized with it

Arguments:

    ChangeEvent - Event used for catalog syncrhonization.

Return Value:

    TRUE - catalog has changed
    FALSE - otherwise
    
--*/
{
    DWORD   wait_result;

    // Simply check the event state

    wait_result = WaitForSingleObject( ChangeEvent, 0 );
    if (wait_result==WAIT_OBJECT_0)
            return TRUE;
    if (wait_result==WAIT_TIMEOUT)
            return FALSE;

    DEBUGF (DBG_ERR, ("Waiting for registry change event, rc=%ld, err=%ld.\n",
                            wait_result, GetLastError ()));
    assert (FALSE);
    return FALSE;
}



extern "C" {

VOID
WEP( VOID )
{
    // empty
}   // WEP

}   // extern "C"


void * __cdecl operator new(size_t sz)
{
    return HeapAlloc (gHeap, 0, sz);
}

void __cdecl operator delete(void *p)
{
    HeapFree (gHeap, 0, p);
}

void * __cdecl renew(void *p, size_t sz)
{
    return HeapReAlloc (gHeap, 0, p, sz);
}

//
//  End wsautil.cpp
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsock32\sockopt.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Sockopt.c

Abstract:

    This module contains support for the getsockopt( ) and setsockopt( )
    WinSock APIs.

Author:

    David Treadwell (davidtr)    31-Mar-1992

Revision History:

--*/

#define WINSOCK_API_LINKAGE
#define getsockopt getsockopt_v11
#define setsockopt setsockopt_v11

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>

//
// The versions of WSOCK32.DLL that shiped with NT 3.1, NT 3.5, NT 3.51,
// TCP/IP-32 for WFW, and Win95 all use the "Steve Deering" values for the
// IP Multicast options. Unfortunately, the TCP/IP subgroup of the Windows
// Sockets 2.0 standards effort chose to use the BSD values for these options.
// Since these values overlap considerably, we have a rather unfortunate
// situation.
//
// Here's how we'll deal with this.
//
// Applications built using WINSOCK2.H & WS2TCPIP.H will use the BSD
// values as #defined in WS2TCPIP.H. These applications will link with
// WS2_32.DLL, and life is swell.
//
// Applications built using WINSOCK.H will use the Steve Deering values
// as #defined in WINSOCK.H. These applications will link with WSOCK32.DLL,
// which will map these options to the BSD values before passing them
// down to WS2_32.DLL. Life is still swell.
//
// These are the "old" Steve Deering values that must be mapped:
//

#define OLD_IP_MULTICAST_IF     2
#define OLD_IP_MULTICAST_TTL    3
#define OLD_IP_MULTICAST_LOOP   4
#define OLD_IP_ADD_MEMBERSHIP   5
#define OLD_IP_DROP_MEMBERSHIP  6
#define OLD_IP_TTL              7
#define OLD_IP_TOS              8
#define OLD_IP_DONTFRAGMENT     9

#define TCP_BSDURGENT           0x7000

INT
MapOldIpMulticastOptionToBsdValue(
    INT OptionName
    );


int PASCAL
getsockopt(
    IN SOCKET Handle,
    IN int Level,
    IN int OptionName,
    char *OptionValue,
    int *OptionLength
    )

/*++

Routine Description:

    getsockopt() retrieves the current value for a socket option
    associated with a socket of any type, in any state, and stores the
    result in optval.  Options may exist at multiple protocol levels,
    but they are always present at the uppermost "socket'' level.
    Options affect socket operations, such as whether an operation
    blocks or not, the routing of packets, out-of-band data transfer,
    etc.

    The value associated with the selected option is returned in the
    buffer optval.  The integer pointed to by optlen should originally
    contain the size of this buffer; on return, it will be set to the
    size of the value returned.  For SO_LINGER, this will be the size of
    a struct linger; for all other options it will be the size of an
    integer.

    If the option was never set with setsockopt(), then getsockopt()
    returns the default value for the option.

    The following options are supported for
    getsockopt().  The Type identifies the type of
    data addressed by optval.

         Value         Type     Meaning

         SO_ACCEPTCONN BOOL     Socket is listen()ing.

         SO_BROADCAST  BOOL     Socket is configured for the transmission
                                of broadcast messages.

         SO_DEBUG      BOOL     Debugging is enabled.

         SO_DONTLINGER BOOL     If true, the SO_LINGER option is disabled.

         SO_DONTROUTE  BOOL     Routing is disabled.

         SO_ERROR      int      Retrieve error status and clear.

         SO_KEEPALIVE  BOOL     Keepalives are being sent.

         SO_LINGER     struct   Returns the current linger
                       linger   options.
                       FAR *

         SO_OOBINLINE  BOOL     Out-of-band data is being received in the
                                normal data stream.

         SO_RCVBUF     int      Buffer size for receives

         SO_REUSEADDR  BOOL     The socket may be bound to an address which
                                is already in use.

         SO_SNDBUF     int      Buffer size for sends

         SO_TYPE       int      The type of the socket (e.g. SOCK_STREAM).

Arguments:

    s - A descriptor identifying a socket.

    level - The level at which the option is defined; the only supported
        level is SOL_SOCKET.

    optname - The socket option for which the value is to be retrieved.

    optval - A pointer to the buffer in which the value for the
        requested option is to be returned.

    optlen - A pointer to the size of the optval buffer.

Return Value:

    If no error occurs, getsockopt() returns 0.  Otherwise, a value of
    SOCKET_ERROR is returned, and a specific error code may be retrieved
    by calling WSAGetLastError().

--*/

{
    ULONG error;
#undef getsockopt
    extern int WSAAPI getsockopt( SOCKET s, int level, int optname,
                                        char FAR * optval, int FAR * optlen );

    //
    // Set up locals so that we know how to clean up on exit.
    //

    error = NO_ERROR;

    //
    // Map the old IP multicast values to their BSD equivilants.
    //

    if( Level == IPPROTO_IP ) {

        OptionName = MapOldIpMulticastOptionToBsdValue( OptionName );

    }

    //
    // Handle TCP_BSDURGENT specially.
    //

    if( Level == IPPROTO_TCP && OptionName == TCP_BSDURGENT ) {

        if( getsockopt(
                Handle,
                Level,
                TCP_EXPEDITED_1122,
                OptionValue,
                OptionLength
                ) == SOCKET_ERROR ) {

            return SOCKET_ERROR;

        }

        //
        // TCP_BSDURGENT is the inverse of TCP_EXPEDITED_1122.
        //

        *OptionValue = !(*OptionValue);
        goto exit;

    }

    //
    // Forward it to the "real" WS2_32.DLL.
    //

    if( getsockopt(
            Handle,
            Level,
            OptionName,
            OptionValue,
            OptionLength
            ) == SOCKET_ERROR ) {

        return SOCKET_ERROR;

    }

exit:

    if ( error != NO_ERROR ) {
        SetLastError( error );
        return SOCKET_ERROR;
    }

    return NO_ERROR;

} // getsockopt


int PASCAL
setsockopt(
    IN SOCKET Handle,
    IN int Level,
    IN int OptionName,
    IN const char *OptionValue,
    IN int OptionLength
    )

/*++

Routine Description:

    setsockopt() sets the current value for a socket option associated
    with a socket of any type, in any state.  Although options may exist
    at multiple protocol levels, this specification only defines options
    that exist at the uppermost "socket'' level.  Options affect socket
    operations, such as whether expedited data is received in the normal
    data stream, whether broadcast messages may be sent on the socket,
    etc.

    There are two types of socket options: Boolean options that enable
    or disable a feature or behavior, and options which require an
    integer value or structure.  To enable a Boolean option, optval
    points to a nonzero integer.  To disable the option optval points to
    an integer equal to zero.  optlen should be equal to sizeof(int) for
    Boolean options.  For other options, optval points to the an integer
    or structure that contains the desired value for the option, and
    optlen is the length of the integer or structure.

    SO_LINGER controls the action taken when unsent data is queued on a
    socket and a closesocket() is performed.  See closesocket() for a
    description of the way in which the SO_LINGER settings affect the
    semantics of closesocket().  The application sets the desired
    behavior by creating a struct linger (pointed to by the optval
    argument) with the following elements:

        struct linger {
             int  l_onoff;
             int  l_linger;
        }

    To enable SO_LINGER, the application should set l_onoff to a
    non-zero value, set l_linger to 0 or the desired timeout (in
    seconds), and call setsockopt().  To enable SO_DONTLINGER (i.e.
    disable SO_LINGER) l_onoff should be set to zero and setsockopt()
    should be called.

    By default, a socket may not be bound (see bind()) to a local
    address which is already in use.  On occasions, however, it may be
    desirable to "re- use" an address in this way.  Since every
    connection is uniquely identified by the combination of local and
    remote addresses, there is no problem with having two sockets bound
    to the same local address as long as the remote addresses are
    different.  To inform the Windows Sockets implementation that a
    bind() on a socket should not be disallowed because of address
    re-use, the application should set the SO_REUSEADDR socket option
    for the socket before issuing the bind().  Note that the option is
    interpreted only at the time of the bind(): it is therefore
    unnecessary (but harmless) to set the option on a socket which is
    not to be bound to an existing address, and setting or resetting the
    option after the bind() has no effect on this or any other socket..

    An application may request that the Windows Sockets implementation
    enable the use of "keep- alive" packets on TCP connections by
    turning on the SO_KEEPALIVE socket option.  A Windows Sockets
    implementation need not support the use of keep- alives: if it does,
    the precise semantics are implementation-specific but should conform
    to section 4.2.3.6 of RFC 1122: Requirements for Internet Hosts --
    Communication Layers.  If a connection is dropped as the result of
    "keep- alives" the error code WSAENETRESET is returned to any calls
    in progress on the socket, and any subsequent calls will fail with
    WSAENOTCONN.

    The following options are supported for setsockopt().  The Type
    identifies the type of data addressed by optval.

         Value         Type     Meaning

         SO_ACCEPTCONN BOOL     Socket is listen()ing.

         SO_BROADCAST  BOOL     Socket is configured for the transmission
                                of broadcast messages.

         SO_DEBUG      BOOL     Debugging is enabled.

         SO_DONTLINGER BOOL     If true, the SO_LINGER option is disabled.

         SO_DONTROUTE  BOOL     Routing is disabled.

         SO_ERROR      int      Retrieve error status and clear.

         SO_KEEPALIVE  BOOL     Keepalives are being sent.

         SO_LINGER     struct   Returns the current linger
                       linger   options.
                       FAR *

         SO_OOBINLINE  BOOL     Out-of-band data is being received in the
                                normal data stream.

         SO_RCVBUF     int      Buffer size for receives

         SO_REUSEADDR  BOOL     The socket may be bound to an address which
                                is already in use.

         SO_SNDBUF     int      Buffer size for sends

         SO_TYPE       int      The type of the socket (e.g. SOCK_STREAM).

Arguments:

Return Value:

    If no error occurs, setsockopt() returns 0.  Otherwise, a value of
    SOCKET_ERROR is returned, and a specific error code may be retrieved
    by calling WSAGetLastError().

--*/

{
    ULONG error;
    INT optionValue;
    INT invertedValue;
    char FAR * valuePointer;

#undef setsockopt
    extern int WSAAPI setsockopt( SOCKET s, int level, int optname,
                                        const char FAR * optval, int optlen );

    //
    // Set up locals so that we know how to clean up on exit.
    //

    error = NO_ERROR;

    //
    // Map the old IP multicast values to their BSD equivilants.
    //

    if( Level == IPPROTO_IP ) {

        OptionName = MapOldIpMulticastOptionToBsdValue( OptionName );

    }

    //
    // Handle TCP_BSDURGENT specially.
    //

    valuePointer = (char FAR *)OptionValue;

    if( Level == IPPROTO_TCP && OptionName == TCP_BSDURGENT ) {

        OptionName = TCP_EXPEDITED_1122;

        if( OptionLength >= sizeof(INT) ) {

            invertedValue = !(*OptionValue);
            valuePointer = (char FAR *)&invertedValue;
            OptionLength = sizeof(invertedValue);

        }

    }

    return setsockopt(
               Handle,
               Level,
               OptionName,
               valuePointer,
               OptionLength
               );

} // setsockopt


INT
MapOldIpMulticastOptionToBsdValue(
    INT OptionName
    )
{

    switch( OptionName ) {

    case OLD_IP_MULTICAST_IF :
        OptionName = IP_MULTICAST_IF;
        break;

    case OLD_IP_MULTICAST_TTL :
        OptionName = IP_MULTICAST_TTL;
        break;

    case OLD_IP_MULTICAST_LOOP :
        OptionName = IP_MULTICAST_LOOP;
        break;

    case OLD_IP_ADD_MEMBERSHIP :
        OptionName = IP_ADD_MEMBERSHIP;
        break;

    case OLD_IP_DROP_MEMBERSHIP :
        OptionName = IP_DROP_MEMBERSHIP;
        break;

    case OLD_IP_TTL :
        OptionName = IP_TTL;
        break;

    case OLD_IP_TOS :
        OptionName = IP_TOS;
        break;

    case OLD_IP_DONTFRAGMENT :
        OptionName = IP_DONTFRAGMENT;
        break;
    }

    return OptionName;

}   // MapOldIpMulticastOptionToBsdValue


int WSAAPI
recv(
     IN SOCKET s,
     OUT char FAR * buf,
     IN int len,
     IN int flags
     )
/*++
Routine Description:

    Receive data from a socket.

Arguments:

    s     - A descriptor identifying a connected socket.

    buf   - A buffer for the incoming data.

    len   - The length of buf.

    flags - Specifies the way in which the call is made.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT     ReturnValue;
    WSABUF  Buffers;
    DWORD   LocalFlags;
    INT     ErrorCode;

    Buffers.len = len;
    Buffers.buf = buf;
    LocalFlags = (DWORD) flags;

    ErrorCode = WSARecv(s,
            &Buffers,
            1, // Buffer count
            (LPDWORD)&ReturnValue,
            &LocalFlags,
            NULL,
            NULL);
    if (SOCKET_ERROR == ErrorCode) {
        ReturnValue = SOCKET_ERROR;
    } else if (LocalFlags & MSG_PARTIAL) {

        // If the receive was a partial message (won't happen on a
        // streams transport like TCP) set the last error to
        // WSAEMSGSIZE and negate ths number of bytes received.
        // This allows the app to know that the receive was partial
        // and also how many bytes were received.
        //

        ReturnValue *= -1;
        SetLastError (WSAEMSGSIZE);
    }

    return(ReturnValue);
}


int WSAAPI
recvfrom(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR *from,
    IN OUT int FAR * fromlen
    )
/*++
Routine Description:

    Receive a datagram and store the source address.

Arguments:

    s       - A descriptor identifying a bound socket.

    buf     - A buffer for the incoming data.

    len     - The length of buf.

    flags   - Specifies the way in which the call is made.

    from    - An  optional  pointer  to  a  buffer  which  will hold the source
              address upon return.

    fromlen - An optional pointer to the size of the from buffer.

Returns:

    The  number  of  bytes  received.   If  the  connection has been gracefully
    closed,  the  return  value  is  0.   Otherwise, a value of SOCKET_ERROR is
    returned, and a specific error code is stored with SetErrorCode().

--*/

{
    INT     ReturnValue;
    WSABUF  Buffers;
    DWORD   LocalFlags;
    INT     ErrorCode;

    Buffers.len = len;
    Buffers.buf = buf;
    LocalFlags = (DWORD) flags;

    ErrorCode = WSARecvFrom(s,
                &Buffers,
                1,
                (LPDWORD)&ReturnValue,
                &LocalFlags,
                from,
                fromlen,
                NULL,
                NULL);

    if (SOCKET_ERROR == ErrorCode) {
        ReturnValue = SOCKET_ERROR;
    } else if (LocalFlags & MSG_PARTIAL) {

        // If the receive was a partial message (won't happen on a
        // streams transport like TCP) set the last error to
        // WSAEMSGSIZE and negate ths number of bytes received.
        // This allows the app to know that the receive was partial
        // and also how many bytes were received.
        //

        ReturnValue *= -1;
        SetLastError (WSAEMSGSIZE);
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\afdprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afdprocs.h

Abstract:

    This module contains routine prototypes for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#ifndef _AFDPROCS_
#define _AFDPROCS_

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FASTCALL
AfdAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSuperAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdDeferAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdRestartSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdCancelSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdCleanupSuperAccept (
    IN PIRP Irp,
    IN NTSTATUS Status
    );


BOOLEAN
AfdServiceSuperAccept (
    IN  PAFD_ENDPOINT   Endpoint,
    IN  PAFD_CONNECTION Connection,
    IN  PAFD_LOCK_QUEUE_HANDLE LockHandle,
    OUT PLIST_ENTRY     AcceptIrpList
    );

NTSTATUS
AfdAcceptCore (
    IN PIRP          AcceptIrp,
    IN PAFD_ENDPOINT AcceptEndpoint,
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdSetupAcceptEndpoint (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_ENDPOINT   AcceptEndpoint,
    PAFD_CONNECTION Connection
    );

VOID
AfdRestartSuperAcceptListen (
    IN PIRP Irp,
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdRestartDelayedSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PMDL
AfdAdvanceMdlChain(
    IN PMDL Mdl,
    IN ULONG Offset
    );

#ifdef _WIN64
NTSTATUS
AfdAllocateMdlChain32(
    IN PIRP Irp,
    IN LPWSABUF32 BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    );
#endif

NTSTATUS
AfdAllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    );

BOOLEAN
AfdAreTransportAddressesEqual (
    IN PTRANSPORT_ADDRESS EndpointAddress,
    IN ULONG EndpointAddressLength,
    IN PTRANSPORT_ADDRESS RequestAddress,
    IN ULONG RequestAddressLength,
    IN BOOLEAN HonorWildcardIpPortInEndpointAddress
    );

NTSTATUS
AfdBeginAbort (
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdBeginDisconnect (
    IN PAFD_ENDPOINT Endpoint,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PIRP *DisconnectIrp OPTIONAL
    );

NTSTATUS
FASTCALL
AfdBind (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

ULONG
AfdCalcBufferArrayByteLength(
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount
    );

VOID
AfdCancelReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
AfdCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
AfdCompleteIrpList (
    IN PLIST_ENTRY IrpListHead,
    IN PAFD_ENDPOINT Endpoint,
    IN NTSTATUS Status,
    IN PAFD_IRP_CLEANUP_ROUTINE CleanupRoutine OPTIONAL
    );

VOID
AfdCompleteClosePendedTransmit (
    IN PVOID    Context
    );

NTSTATUS
FASTCALL
AfdConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdJoinLeaf (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSuperConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdConnectEventHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

#ifdef _WIN64
ULONG
AfdComputeCMSGLength32 (
    PVOID   ControlBuffer,
    ULONG   ControlLength
    );

VOID
AfdCopyCMSGBuffer32 (
    PVOID   Dst,
    PVOID   ControlBuffer,
    ULONG   CopyLength
    );
#endif //_WIN64

ULONG
AfdCopyBufferArrayToBuffer(
    IN PVOID Destination,
    IN ULONG DestinationLength,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount
    );

ULONG
AfdCopyBufferToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG Offset,
    IN ULONG BufferCount,
    IN PVOID Source,
    IN ULONG SourceLength
    );

ULONG
AfdCopyMdlChainToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG BufferOffset,
    IN ULONG BufferCount,
    IN PMDL  Source,
    IN ULONG SourceOffset,
    IN ULONG SourceLength
    );

NTSTATUS
AfdCopyMdlChainToMdlChain (
    PMDL    Destination,
    ULONG   DestinationOffset,
    PMDL    Source,
    ULONG   SourceOffset,
    ULONG   SourceLength,
    PULONG  BytesCopied
    );

NTSTATUS
AfdCopyMdlChainToBufferAvoidMapping(
    IN PMDL     SourceMdl,
    IN ULONG    SourceOffset,
    IN ULONG    SourceLength,
    IN PUCHAR   Buffer,
    IN ULONG    BufferSize
    );

NTSTATUS
AfdMapMdlChain (
    PMDL    MdlChain
    );

NTSTATUS
FASTCALL
AfdCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdDelayedAcceptListen (
    PAFD_ENDPOINT   Endpoint,
    PAFD_CONNECTION Connection
    );

VOID
AfdDestroyMdlChain (
    IN PIRP Irp
    );

NTSTATUS
AfdDisconnectEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
AfdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdDispatchDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
AfdDispatchImmediateIrp(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdEnumNetworkEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdErrorEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status
    );

NTSTATUS
AfdErrorExEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status,
    IN PVOID Context
    );

NTSTATUS
AfdEventSelect (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

LONG
AfdExceptionFilter(
#if DBG
    PCHAR SourceFile,
    LONG LineNumber,
#endif
    PEXCEPTION_POINTERS ExceptionPointers,
    PNTSTATUS   ExceptionCode
    );

BOOLEAN
AfdFastTransmitFile (
    IN PAFD_ENDPOINT endpoint,
    IN PAFD_TRANSMIT_FILE_INFO transmitInfo,
    OUT PIO_STATUS_BLOCK IoStatus
    );


VOID
AfdFreeConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers
    );

VOID
AfdFreeQueuedConnections (
    IN PAFD_ENDPOINT Endpoint
    );

NTSTATUS
FASTCALL
AfdGetAddress (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdGetRemoteAddress (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdGetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdGetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdGetTransportInfo (
    IN  PUNICODE_STRING TransportDeviceName,
    IN OUT PAFD_TRANSPORT_INFO *TransportInfo
    );

NTSTATUS
AfdQueryProviderInfo (
    IN  PUNICODE_STRING TransportDeviceName,
    OUT PTDI_PROVIDER_INFO ProviderInfo
    );

VOID
AfdIndicateEventSelectEvent (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    );



VOID
AfdIndicatePollEventReal (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    );

#define AfdIndicatePollEvent(_e,_m,_s)  \
    ((_e)->PollCalled ? (AfdIndicatePollEventReal((_e),(_m),(_s)), TRUE) : FALSE)

VOID
AfdInitiateListenBacklogReplenish (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdInitializeData (
    VOID
    );

NTSTATUS
AfdIssueDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction
    );


VOID
AfdIncrementLockCount (
    VOID
    );

VOID
AfdDecrementLockCount (
    VOID
    );

VOID
AfdInsertNewEndpointInList (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdRemoveEndpointFromList (
    IN PAFD_ENDPOINT Endpoint
    );

PVOID
AfdLockEndpointContext (
    PAFD_ENDPOINT   Endpoint
    );

VOID
AfdUnlockEndpointContext (
    PAFD_ENDPOINT   Endpoint,
    PVOID           Context
    );


NTSTATUS
AfdPartialDisconnect (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
FASTCALL
AfdPoll (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


VOID
AfdQueueWorkItem (
    IN PWORKER_THREAD_ROUTINE AfdWorkerRoutine,
    IN PAFD_WORK_ITEM AfdWorkItem
    );

PAFD_WORK_ITEM
AfdGetWorkerByRoutine (
    PWORKER_THREAD_ROUTINE  Routine
    );

NTSTATUS
AfdQueryHandles (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdQueryReceiveInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSetEventHandler (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    );

NTSTATUS
AfdSetInLineMode (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN InLine
    );

NTSTATUS
FASTCALL
AfdReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdBReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG RecvFlags,
    IN ULONG AfdFlags,
    IN ULONG RecvLength
    );

NTSTATUS
FASTCALL
AfdReceiveDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdSetupReceiveDatagramIrp (
    IN PIRP Irp,
    IN PVOID DatagramBuffer OPTIONAL,
    IN ULONG DatagramLength,
    IN PVOID OptionsBuffer OPTIONAL,
    IN ULONG OptionsLength,
    IN PVOID SourceAddress OPTIONAL,
    IN ULONG SourceAddressLength,
    IN ULONG TdiFlags
    );

BOOLEAN
AfdCleanupReceiveDatagramIrp(
    IN PIRP Irp
    );

BOOLEAN
AfdCleanupSendIrp (
    PIRP    Irp
    );

NTSTATUS
AfdReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );


NTSTATUS
AfdBChainedReceiveEventHandler(
    IN PVOID  TdiEventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG  ReceiveFlags,
    IN ULONG  ReceiveLength,
    IN ULONG  StartingOffset,
    IN PMDL  Tsdu,
    IN PVOID  TsduDescriptor
    );
    
NTSTATUS
AfdBReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdReceiveDatagramEventHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdBReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    );

NTSTATUS
AfdRestartBufferReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartAbort (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
FASTCALL
AfdSend (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSendDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdSendPossibleEventHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable
    );

NTSTATUS
AfdRestartBufferSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdProcessBufferSend (
    IN PAFD_CONNECTION Connection,
    IN PIRP            Irp
    );

NTSTATUS
AfdSetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

BOOLEAN
AfdShouldSendBlock (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN ULONG SendLength
    );

NTSTATUS
AfdStartListen (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
FASTCALL
AfdTransmitFile (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


NTSTATUS
FASTCALL
AfdWaitForListen (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSetQos (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdGetQos (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdNoOperation (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdValidateGroup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdGetUnacceptedConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );


#define AfdReferenceEventObjectByHandle(Handle, AccessMode, Object) \
            ObReferenceObjectByHandle(                              \
                (Handle),                                           \
                EVENT_MODIFY_STATE,                                 \
                *(POBJECT_TYPE *)ExEventObjectType,                 \
                (AccessMode),                                       \
                (Object),                                           \
                NULL                                                \
                )

//
// Endpoint handling routines.
//

NTSTATUS
AfdAllocateEndpoint (
    OUT PAFD_ENDPOINT * NewEndpoint,
    IN PUNICODE_STRING TransportDeviceName,
    IN LONG GroupID
    );

#if REFERENCE_DEBUG

VOID
AfdReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdUpdateEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define REFERENCE_ENDPOINT(_e) {                                            \
        static LONG _arl;                                                   \
        AfdReferenceEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)+"),__LINE__);   \
    }

#define REFERENCE_ENDPOINT2(_e,_s,_p) {                                     \
        static LONG _arl;                                                   \
        AfdReferenceEndpoint((_e),AFD_GET_ARL(_s"+"),(_p));                 \
    }

#define CHECK_REFERENCE_ENDPOINT(_e,_r) {                                   \
        static LONG _arl;                                                   \
        _r = AfdCheckAndReferenceEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)*"),\
                                                                __LINE__);  \
    }

#define DEREFERENCE_ENDPOINT(_e) {                                          \
        static LONG _arl;                                                   \
        AfdDereferenceEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)-"),__LINE__); \
    }

#define DEREFERENCE_ENDPOINT2(_e,_s,_p) {                                   \
        static LONG _arl;                                                   \
        AfdDereferenceEndpoint((_e),AFD_GET_ARL(_s"-"),(_p));               \
    }

#define UPDATE_ENDPOINT(_e) {                                               \
        static LONG _arl;                                                   \
        AfdUpdateEndpoint((_e),AFD_GET_ARL(__FILE__"(%d)="),__LINE__);      \
    }

#define UPDATE_ENDPOINT2(_e,_s,_p) {                                        \
        static LONG _arl;                                                   \
        AfdUpdateEndpoint((_e),AFD_GET_ARL(_s"="),(_p));                    \
    }

#else

BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    );

#define REFERENCE_ENDPOINT(_e) (VOID)InterlockedIncrement( (PLONG)&(_e)->ReferenceCount )
#define REFERENCE_ENDPOINT2(_e,_s,_p) InterlockedIncrement( (PLONG)&(_e)->ReferenceCount )
#define CHECK_REFERENCE_ENDPOINT(_e,_r) _r=AfdCheckAndReferenceEndpoint((_e))

#define DEREFERENCE_ENDPOINT(_e) AfdDereferenceEndpoint((_e))
#define DEREFERENCE_ENDPOINT2(_e,_s,_p) AfdDereferenceEndpoint((_e))
#define UPDATE_ENDPOINT(_e)
#define UPDATE_ENDPOINT2(_e,_s,_p)

#endif

VOID
AfdRefreshEndpoint (
    IN PAFD_ENDPOINT Endpoint
    );

//
// Connection handling routines.
//

VOID
AfdAbortConnection (
    IN PAFD_CONNECTION Connection
    );

NTSTATUS
AfdAddFreeConnection (
    IN PAFD_ENDPOINT Endpoint
    );

PAFD_CONNECTION
AfdAllocateConnection (
    VOID
    );

NTSTATUS
AfdCreateConnection (
    IN PUNICODE_STRING TransportDeviceName,
    IN HANDLE AddressHandle OPTIONAL,
    IN BOOLEAN TdiBufferring,
    IN LOGICAL InLine,
    IN PEPROCESS ProcessToCharge,
    OUT PAFD_CONNECTION *Connection
    );

PAFD_CONNECTION
AfdGetFreeConnection (
    IN PAFD_ENDPOINT Endpoint,
    OUT PIRP        *Irp
    );

PAFD_CONNECTION
AfdGetReturnedConnection (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    );

PAFD_CONNECTION
AfdFindReturnedConnection(
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    );

PAFD_CONNECTION
AfdGetUnacceptedConnection (
    IN PAFD_ENDPOINT Endpoint
    );

PAFD_CONNECTION
AfdGetConnectionReferenceFromEndpoint (
    PAFD_ENDPOINT   Endpoint
    );

#if REFERENCE_DEBUG

VOID
AfdReferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

VOID
AfdDereferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define REFERENCE_CONNECTION(_c) {                                          \
        static LONG _arl;                                                   \
        AfdReferenceConnection((_c),AFD_GET_ARL(__FILE__"(%d)+"),__LINE__); \
    }

#define REFERENCE_CONNECTION2(_c,_s,_p) {                                   \
        static LONG _arl;                                                   \
        AfdReferenceConnection((_c),AFD_GET_ARL(_s"+"),(_p));               \
    }

#define CHECK_REFERENCE_CONNECTION(_c,_r) {                                 \
        static LONG _arl;                                                   \
        _r=AfdCheckAndReferenceConnection((_c),AFD_GET_ARL(__FILE__"(%d)*"),\
                                                                __LINE__);  \
    }

#define CHECK_REFERENCE_CONNECTION2(_c,_s,_p,_r) {                          \
        static LONG _arl;                                                   \
        _r = AfdCheckAndReferenceConnection((_c),AFD_GET_ARL(_s"*"),(_p));  \
    }

#define DEREFERENCE_CONNECTION(_c) {                                        \
        static LONG _arl;                                                   \
        AfdDereferenceConnection((_c),AFD_GET_ARL(__FILE__"(%d)-"),__LINE__);\
    }

#define DEREFERENCE_CONNECTION2(_c,_s,_p) {                                 \
        static LONG _arl;                                                   \
        AfdDereferenceConnection((_c),AFD_GET_ARL(_s"-"),(_p));             \
    }

VOID
AfdUpdateConnectionTrack (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    );

#define UPDATE_CONN(_c)                             \
    if( (_c) != NULL ) {                            \
        static LONG _arl;                           \
        AfdUpdateConnectionTrack(                   \
            (_c),                                   \
            AFD_GET_ARL(__FILE__"(%d)="),           \
            __LINE__                                \
            );                                      \
    } else

#define UPDATE_CONN2(_c,_s,_p)                                              \
    if( (_c) != NULL ) {                                                    \
        static LONG _arl;                                                   \
        AfdUpdateConnectionTrack((_c),AFD_GET_ARL(_s"="),(_p));             \
    } else

#else

VOID
AfdCloseConnection (
    IN PAFD_CONNECTION Connection
    );

BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection
    );

#define REFERENCE_CONNECTION(_c) (VOID)InterlockedIncrement( (PLONG)&(_c)->ReferenceCount )
#define REFERENCE_CONNECTION2(_c,_s,_p) (VOID)InterlockedIncrement( (PLONG)&(_c)->ReferenceCount )
#define CHECK_REFERENCE_CONNECTION(_c,_r) _r=AfdCheckAndReferenceConnection((_c))
#define CHECK_REFERENCE_CONNECTION2(_c,_s,_p,_r) _r=AfdCheckAndReferenceConnection((_c))

#define DEREFERENCE_CONNECTION(_c)                                  \
    if (InterlockedDecrement((PLONG)&(_c)->ReferenceCount)==0) {    \
        AfdCloseConnection (_c);                                    \
    }                                                               \

#define DEREFERENCE_CONNECTION2(_c,_s,_p)                           \
    if (InterlockedDecrement((PLONG)&(_c)->ReferenceCount)==0) {    \
        AfdCloseConnection (_c);                                    \
    }                                                               \


#define UPDATE_CONN(_c)
#define UPDATE_CONN2(_c,_s,_p)

#endif

VOID
AfdAddConnectedReference (
    IN PAFD_CONNECTION Connection
    );

VOID
AfdDeleteConnectedReference (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN EndpointLockHeld
    );


//
// Routines to handle fast IO.
//

BOOLEAN
AfdFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Routines to handle getting and setting connect data.
//

NTSTATUS
AfdGetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSaveReceivedConnectData (
    IN OUT PAFD_CONNECT_DATA_BUFFERS * DataBuffers,
    IN ULONG IoControlCode,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

//
// Buffer management routines.
//

PVOID
AfdAllocateBuffer (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

PVOID
AfdAllocateBufferTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
AfdFreeBufferTag(
    IN PVOID AfdBufferTag
    );

PVOID
AfdAllocateRemoteAddress (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
AfdFreeRemoteAddress(
    IN PVOID AfdBufferTag
    );

VOID
AfdInitializeBufferTag (
    IN PAFD_BUFFER_TAG AfdBufferTag,
    IN ULONG AddressSize
    );

#define AFDB_RAISE_ON_FAILURE  ((ULONG_PTR)1)

PAFD_BUFFER_TAG
AfdGetBufferTag (
    IN ULONG AddressSize,
    IN PEPROCESS Process
    );
#define AfdGetBufferTagRaiseOnFailure(_as,_pr)  \
    AfdGetBufferTag((_as),((PEPROCESS)((ULONG_PTR)(_pr)|AFDB_RAISE_ON_FAILURE)))

ULONG
AfdCalculateBufferSize (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize
    );

PAFD_BUFFER
AfdGetBuffer (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize,
    IN PEPROCESS Process
    );
#define AfdGetBufferRaiseOnFailure(_ds,_as,_pr)  \
    AfdGetBuffer((_ds),(_as),((PEPROCESS)((ULONG_PTR)(_pr)|AFDB_RAISE_ON_FAILURE)))


VOID
AfdReturnBuffer (
    IN PAFD_BUFFER_HEADER AfdBufferHeader,
    IN PEPROCESS Process
    );

VOID
NTAPI
AfdFreeBuffer(
    IN PVOID AfdBuffer
    );

VOID
AfdInitializeBufferManager (
    VOID
    );

//
// Group ID managment routines.
//

BOOLEAN
AfdInitializeGroup(
    VOID
    );

VOID
AfdTerminateGroup(
    VOID
    );

BOOLEAN
AfdReferenceGroup(
    IN LONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    );

BOOLEAN
AfdDereferenceGroup(
    IN LONG Group
    );

BOOLEAN
AfdGetGroup(
    IN OUT PLONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    );

BOOLEAN
AfdCancelIrp (
    IN PIRP Irp
    );


// PnP and PM routines
NTSTATUS
FASTCALL
AfdPnpPower (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdRoutingInterfaceQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
FASTCALL
AfdRoutingInterfaceChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdAddressListQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
FASTCALL
AfdAddressListChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
AfdDeregisterPnPHandlers (
    PVOID   Param
    );

VOID
AfdDereferenceRoutingQuery (
    IN USHORT               AddressType
    );


NTSTATUS
FASTCALL
AfdDoTransportIoctl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

BOOLEAN
AfdLRRepostReceive (
    PAFD_LR_LIST_ITEM ListEntry
    );

VOID
AfdLRListAddItem (
    PAFD_LR_LIST_ITEM  Item,
    PAFD_LR_LIST_ROUTINE Routine
    );

VOID
AfdCheckLookasideLists (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );


ULONG
AfdComputeTpInfoSize (
    ULONG   ElementCount,
    LONG    IrpCount,
    CCHAR   IrpStackCount
    );

NTSTATUS
FASTCALL
AfdTransmitPackets (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FASTCALL
AfdSuperDisconnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

VOID
AfdCompleteClosePendedTPackets (
    PAFD_ENDPOINT   Endpoint
    );

PVOID
AfdAllocateTpInfo (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

VOID
NTAPI
AfdFreeTpInfo (
    PVOID   TpInfo
    );

//
// SAN prototypes
//
NTSTATUS
AfdServiceWaitForListen (
    PIRP            Irp,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    );

VOID
AfdSanCancelAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdSanAcceptCore (
    PIRP            AcceptIrp,
    PFILE_OBJECT    AcceptFileObject,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    );


NTSTATUS
AfdSanCreateHelper (
    PIRP                        Irp,
    PFILE_FULL_EA_INFORMATION   EaBuffer,
    PAFD_ENDPOINT               *Endpoint
    );

VOID
AfdSanCleanupHelper (
    PAFD_ENDPOINT   Endpoint
    );

VOID
AfdSanCleanupEndpoint (
    PAFD_ENDPOINT   Endpoint
    );

NTSTATUS
AfdSanFastCementEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastSetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastResetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
FASTCALL
AfdSanConnectHandler (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
AfdSanFastCompleteAccept (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
FASTCALL
AfdSanRedirectRequest (
    PIRP    Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
AfdSanFastCompleteRequest (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastCompleteIo (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastRefreshEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastGetPhysicalAddr (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanPollBegin (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    );

VOID
AfdSanPollEnd (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    );

VOID
AfdSanPollUpdate (
    PAFD_ENDPOINT   Endpoint,
    ULONG           EventMask
    );

NTSTATUS
AfdSanPollMerge (
    PAFD_ENDPOINT       Endpoint,
    PAFD_SWITCH_CONTEXT Context
    );

NTSTATUS
AfdSanFastTransferCtx (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastGetServicePid (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastSetServiceProcess (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

NTSTATUS
AfdSanFastProviderChange (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );


NTSTATUS
FASTCALL
AfdSanAddrListChange (
    PIRP    Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
FASTCALL
AfdSanAcquireContext (
    PIRP    Irp,
    PIO_STACK_LOCATION  IrpSp
    );

BOOLEAN
AfdSanFastUnlockAll (
    IN PFILE_OBJECT     FileObject,
    IN PEPROCESS        Process,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
AfdSanReleaseConnection (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_CONNECTION Connection,
    BOOLEAN         CheckBacklog
    );

VOID
AfdSanAbortConnection (
    PAFD_CONNECTION Connection
    );

NTSTATUS
AfdValidateStatus (
    NTSTATUS    Status
    );




//
// Check if datagram part of the union is valid
//
#define IS_DGRAM_ENDPOINT(endp) \
            ((endp)->Type==AfdBlockTypeDatagram)

//
// Check if Vc part of the union is valid
//
#define IS_VC_ENDPOINT(endp)                            \
        ( ((endp)->Type==AfdBlockTypeEndpoint) ||       \
          ((endp)->Type==AfdBlockTypeVcConnecting) ||   \
          ((endp)->Type==AfdBlockTypeVcListening) ||    \
          ((endp)->Type==AfdBlockTypeVcBoth) )

#define IS_SAN_ENDPOINT(endp)                                   \
        ((endp)->Type==AfdBlockTypeSanEndpoint)
#define IS_SAN_HELPER(endp)                                     \
        ((endp)->Type==AfdBlockTypeSanHelper)

#define IS_MESSAGE_ENDPOINT(endp) \
            ((endp)->afdMessageMode)
#define IS_RAW_ENDPOINT(endp) \
            ((endp)->afdRaw)
#define IS_CROOT_ENDPOINT(endp) \
            ((endp)->afdMultipoint && (endp)->afdC_Root)
#define IS_DELAYED_ACCEPTANCE_ENDPOINT(endp) \
            ((endp)->DelayedAcceptance)

#define IS_TDI_MESSAGE_MODE(endp) \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_MESSAGE_MODE)!=0))
#define IS_TDI_BUFFERRING(endp) \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_INTERNAL_BUFFERING)!=0))
#define IS_TDI_EXPEDITED(endp) \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_EXPEDITED_DATA)!=0))
#define IS_TDI_ORDERLY_RELEASE(endp) \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_ORDERLY_RELEASE)!=0))
#define IS_TDI_DGRAM_CONNECTION(endp)                              \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_DGRAM_CONNECTION)!=0))
#define IS_TDI_FORCE_ACCESS_CHECK(endp)                              \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_FORCE_ACCESS_CHECK)!=0))
#define IS_TDI_DELAYED_ACCEPTANCE(endp)                              \
            ((BOOLEAN)(((endp)->TdiServiceFlags&TDI_SERVICE_DELAYED_ACCEPTANCE)!=0))

#define IS_DATA_ON_CONNECTION_B(conn)                                         \
            ((conn)->Common.Bufferring.ReceiveBytesIndicated.QuadPart >       \
                 ((conn)->Common.Bufferring.ReceiveBytesTaken.QuadPart +      \
                  (conn)->Common.Bufferring.ReceiveBytesOutstanding.QuadPart )\
             ||                                                               \
             (conn)->VcZeroByteReceiveIndicated)

#define IS_EXPEDITED_DATA_ON_CONNECTION_B(conn)                                        \
            ((conn)->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart >       \
                ((conn)->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +       \
                 (conn)->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart) )

#define IS_DATA_ON_CONNECTION_NB(conn)                                        \
            ( (conn)->VcBufferredReceiveCount != 0 )

#define IS_EXPEDITED_DATA_ON_CONNECTION_NB(conn)                              \
            ( (conn)->VcBufferredExpeditedCount != 0 )

#define IS_DATA_ON_CONNECTION(conn)                                           \
            ((conn)->TdiBufferring ?                            \
                IS_DATA_ON_CONNECTION_B(conn) :                 \
                IS_DATA_ON_CONNECTION_NB(conn) )

#define IS_EXPEDITED_DATA_ON_CONNECTION(conn)                                 \
            ((conn)->TdiBufferring ?                            \
                IS_EXPEDITED_DATA_ON_CONNECTION_B(conn) :       \
                IS_EXPEDITED_DATA_ON_CONNECTION_NB(conn) )

#define ARE_DATAGRAMS_ON_ENDPOINT(endp)                          \
            ( (endp)->DgBufferredReceiveCount != 0 )

#define AFD_START_STATE_CHANGE(endp,newState)                   \
        (InterlockedCompareExchange(                            \
                &(endp)->StateChangeInProgress,                 \
                newState,                                       \
                0)==0)

#if DBG
#define AFD_END_STATE_CHANGE(endp)                              \
    ASSERT (InterlockedExchange(&(endp)->StateChangeInProgress,0)!=0)
#else
#define AFD_END_STATE_CHANGE(endp)                              \
        (endp)->StateChangeInProgress = 0;
#endif

#define AFD_ALLOCATE_REMOTE_ADDRESS(_l)                         \
    (((ULONG)(_l)<=AfdStandardAddressLength)                    \
            ? ExAllocateFromNPagedLookasideList(                \
                            &AfdLookasideLists->RemoteAddrList )\
            : AFD_ALLOCATE_POOL(NonPagedPool,                   \
                            (_l), AFD_REMOTE_ADDRESS_POOL_TAG)  \
        )

#define AFD_RETURN_REMOTE_ADDRESS(_a,_l)                        \
    (((ULONG)(_l)<=AfdStandardAddressLength)                    \
            ? ExFreeToNPagedLookasideList(                      \
                            &AfdLookasideLists->RemoteAddrList, \
                            (_a))                               \
            : AFD_FREE_POOL((_a), AFD_REMOTE_ADDRESS_POOL_TAG)  \
        )

#if DBG
LONG
AfdApcExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCHAR SourceFile,
    LONG LineNumber
    );
#endif
//
// Debug statistic manipulators. On checked builds these macros update
// their corresponding statistic counter. On retail builds, these macros
// evaluate to nothing.
//

#if AFD_KEEP_STATS

#define AfdRecordPoolQuotaCharged( b )                                      \
            ExInterlockedAddLargeStatistic(                                 \
                &AfdQuotaStats.Charged,                                     \
                (b)                                                         \
                )

#define AfdRecordPoolQuotaReturned( b )                                     \
            ExInterlockedAddLargeStatistic(                                 \
                &AfdQuotaStats.Returned,                                    \
                (b)                                                         \
                )

#define AfdRecordAddrOpened() InterlockedIncrement( &AfdHandleStats.AddrOpened )
#define AfdRecordAddrClosed() InterlockedIncrement( &AfdHandleStats.AddrClosed )
#define AfdRecordAddrRef()    InterlockedIncrement( &AfdHandleStats.AddrRef )
#define AfdRecordAddrDeref()  InterlockedIncrement( &AfdHandleStats.AddrDeref )
#define AfdRecordConnOpened() InterlockedIncrement( &AfdHandleStats.ConnOpened )
#define AfdRecordConnClosed() InterlockedIncrement( &AfdHandleStats.ConnClosed )
#define AfdRecordConnRef()    InterlockedIncrement( &AfdHandleStats.ConnRef )
#define AfdRecordConnDeref()  InterlockedIncrement( &AfdHandleStats.ConnDeref )
#define AfdRecordFileRef()    InterlockedIncrement( &AfdHandleStats.FileRef )
#define AfdRecordFileDeref()  InterlockedIncrement( &AfdHandleStats.FileDeref )

#define AfdRecordAfdWorkItemsQueued()    InterlockedIncrement( &AfdQueueStats.AfdWorkItemsQueued )
#define AfdRecordExWorkItemsQueued()     InterlockedIncrement( &AfdQueueStats.ExWorkItemsQueued )
#define AfdRecordWorkerEnter()           InterlockedIncrement( &AfdQueueStats.WorkerEnter )
#define AfdRecordWorkerLeave()           InterlockedIncrement( &AfdQueueStats.WorkerLeave )
#define AfdRecordAfdWorkItemsProcessed() InterlockedIncrement( &AfdQueueStats.AfdWorkItemsProcessed )

#define AfdRecordAfdWorkerThread(t) \
            if( 1 ) { \
                ASSERT( AfdQueueStats.AfdWorkerThread == NULL || \
                        (t) == NULL ); \
                AfdQueueStats.AfdWorkerThread = (t); \
            } else

#define AfdRecordConnectedReferencesAdded()      InterlockedIncrement( &AfdConnectionStats.ConnectedReferencesAdded )
#define AfdRecordConnectedReferencesDeleted()    InterlockedIncrement( &AfdConnectionStats.ConnectedReferencesDeleted )
#define AfdRecordGracefulDisconnectsInitiated()  InterlockedIncrement( &AfdConnectionStats.GracefulDisconnectsInitiated )
#define AfdRecordGracefulDisconnectsCompleted()  InterlockedIncrement( &AfdConnectionStats.GracefulDisconnectsCompleted )
#define AfdRecordGracefulDisconnectIndications() InterlockedIncrement( &AfdConnectionStats.GracefulDisconnectIndications )
#define AfdRecordAbortiveDisconnectsInitiated()  InterlockedIncrement( &AfdConnectionStats.AbortiveDisconnectsInitiated )
#define AfdRecordAbortiveDisconnectsCompleted()  InterlockedIncrement( &AfdConnectionStats.AbortiveDisconnectsCompleted )
#define AfdRecordAbortiveDisconnectIndications() InterlockedIncrement( &AfdConnectionStats.AbortiveDisconnectIndications )
#define AfdRecordConnectionIndications()         InterlockedIncrement( &AfdConnectionStats.ConnectionIndications )
#define AfdRecordConnectionsDropped()            InterlockedIncrement( &AfdConnectionStats.ConnectionsDropped )
#define AfdRecordConnectionsAccepted()           InterlockedIncrement( &AfdConnectionStats.ConnectionsAccepted )
#define AfdRecordConnectionsPreaccepted()        InterlockedIncrement( &AfdConnectionStats.ConnectionsPreaccepted )
#define AfdRecordConnectionsReused()             InterlockedIncrement( &AfdConnectionStats.ConnectionsReused )
#define AfdRecordEndpointsReused()               InterlockedIncrement( &AfdConnectionStats.EndpointsReused )

#else   // !AFD_KEEP_STATS

#define AfdRecordPoolQuotaCharged(b)
#define AfdRecordPoolQuotaReturned(b)

#define AfdRecordAddrOpened()
#define AfdRecordAddrClosed()
#define AfdRecordAddrRef()
#define AfdRecordAddrDeref()
#define AfdRecordConnOpened()
#define AfdRecordConnClosed()
#define AfdRecordConnRef()
#define AfdRecordConnDeref()
#define AfdRecordFileRef()
#define AfdRecordFileDeref()

#define AfdRecordAfdWorkItemsQueued()
#define AfdRecordExWorkItemsQueued()
#define AfdRecordWorkerEnter()
#define AfdRecordWorkerLeave()
#define AfdRecordAfdWorkItemsProcessed()
#define AfdRecordAfdWorkerThread(t)

#define AfdRecordConnectedReferencesAdded()
#define AfdRecordConnectedReferencesDeleted()
#define AfdRecordGracefulDisconnectsInitiated()
#define AfdRecordGracefulDisconnectsCompleted()
#define AfdRecordGracefulDisconnectIndications()
#define AfdRecordAbortiveDisconnectsInitiated()
#define AfdRecordAbortiveDisconnectsCompleted()
#define AfdRecordAbortiveDisconnectIndications()
#define AfdRecordConnectionIndications()
#define AfdRecordConnectionsDropped()
#define AfdRecordConnectionsAccepted()
#define AfdRecordConnectionsPreaccepted()
#define AfdRecordConnectionsReused()
#define AfdRecordEndpointsReused()

#endif // if AFD_KEEP_STATS

#endif // ndef _AFDPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\afdstr.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afdstr.h

Abstract:

    This module contains typedefs for structures used by AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#ifndef _AFDSTR_
#define _AFDSTR_

//
// Make sure that queued spinlocks are not used with
// regular spinlock functions by wrapping them into
// a different structure.
//
typedef struct _AFD_QSPIN_LOCK {
    KSPIN_LOCK  ActualSpinLock;
} AFD_QSPIN_LOCK, *PAFD_QSPIN_LOCK;

#if DBG

#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 1
#endif

#ifndef GLOBAL_REFERENCE_DEBUG
#define GLOBAL_REFERENCE_DEBUG 0
#endif

//
// Debug aid for queued spinlocks
// Allows us to verify that spinlock is released using
// the same handle as it was taken with.
//
typedef struct _AFD_LOCK_QUEUE_HANDLE {
    KLOCK_QUEUE_HANDLE  LockHandle;
    PAFD_QSPIN_LOCK     SpinLock;
} AFD_LOCK_QUEUE_HANDLE, *PAFD_LOCK_QUEUE_HANDLE;

#else

#ifndef REFERENCE_DEBUG
#define REFERENCE_DEBUG 0
#endif

#ifndef GLOBAL_REFERENCE_DEBUG
#define GLOBAL_REFERENCE_DEBUG 0
#endif

#define AFD_LOCK_QUEUE_HANDLE KLOCK_QUEUE_HANDLE
#define PAFD_LOCK_QUEUE_HANDLE PKLOCK_QUEUE_HANDLE

#endif // DBG

#if REFERENCE_DEBUG

#define MAX_REFERENCE 64

typedef union _AFD_REFERENCE_DEBUG {
    struct {
        ULONGLONG   NewCount:4;
        ULONGLONG   LocationId:12;
        ULONGLONG   TickCount:16;
        ULONGLONG   Param:32;
    };
    ULONGLONG       QuadPart;
} AFD_REFERENCE_DEBUG, *PAFD_REFERENCE_DEBUG;
C_ASSERT (sizeof (AFD_REFERENCE_DEBUG)==sizeof (ULONGLONG));

typedef struct _AFD_REFERENCE_LOCATION {
    PCHAR       Format;
    PVOID       Address;
} AFD_REFERENCE_LOCATION, *PAFD_REFERENCE_LOCATION;

LONG
AfdFindReferenceLocation (
    IN  PCHAR   Format,
    OUT PLONG   LocationId
    );

#define AFD_GET_ARL(_s) (_arl ? _arl : AfdFindReferenceLocation((_s),&_arl))

#define AFD_UPDATE_REFERENCE_DEBUG(_rd,_r,_l,_p) {                          \
            PAFD_REFERENCE_DEBUG _s;                                        \
            LONG _n;                                                        \
            LARGE_INTEGER   _t;                                             \
            _n = InterlockedIncrement( &(_rd)->CurrentReferenceSlot );      \
            _s = &(_rd)->ReferenceDebug[_n % MAX_REFERENCE];                \
            _s->NewCount = _r;                                              \
            _s->LocationId = _l;                                            \
            _s->Param = _p;                                                 \
            KeQueryTickCount (&_t);                                         \
            _s->TickCount = _t.QuadPart;                                    \
        }


#if GLOBAL_REFERENCE_DEBUG
#define MAX_GLOBAL_REFERENCE 4096

typedef struct _AFD_GLOBAL_REFERENCE_DEBUG {
    PVOID Info1;
    PVOID Info2;
    PVOID Connection;
    ULONG_PTR Action;
    LARGE_INTEGER TickCounter;
    ULONG NewCount;
    ULONG Dummy;
} AFD_GLOBAL_REFERENCE_DEBUG, *PAFD_GLOBAL_REFERENCE_DEBUG;
#endif

#endif

//
// A structure for maintaining work queue information in AFD.
//

typedef struct _AFD_WORK_ITEM {
    LIST_ENTRY WorkItemListEntry;
    PWORKER_THREAD_ROUTINE AfdWorkerRoutine;
    PVOID Context;
} AFD_WORK_ITEM, *PAFD_WORK_ITEM;

//
// Structures for holding connect data pointers and lengths.  This is
// kept separate from the normal structures to save space in those
// structures for transports that do not support and applications
// which do not use connect data.
//

typedef struct _AFD_CONNECT_DATA_INFO {
    PVOID Buffer;
    ULONG BufferLength;
} AFD_CONNECT_DATA_INFO, *PAFD_CONNECT_DATA_INFO;

typedef struct _AFD_CONNECT_DATA_BUFFERS {
    AFD_CONNECT_DATA_INFO SendConnectData;
    AFD_CONNECT_DATA_INFO SendConnectOptions;
    AFD_CONNECT_DATA_INFO ReceiveConnectData;
    AFD_CONNECT_DATA_INFO ReceiveConnectOptions;
    AFD_CONNECT_DATA_INFO SendDisconnectData;
    AFD_CONNECT_DATA_INFO SendDisconnectOptions;
    AFD_CONNECT_DATA_INFO ReceiveDisconnectData;
    AFD_CONNECT_DATA_INFO ReceiveDisconnectOptions;
    TDI_CONNECTION_INFORMATION RequestConnectionInfo;
    TDI_CONNECTION_INFORMATION ReturnConnectionInfo;
    ULONG Flags;
} AFD_CONNECT_DATA_BUFFERS, *PAFD_CONNECT_DATA_BUFFERS;

//
// Structure used for holding disconnect context information.
//

struct _AFD_ENDPOINT;
struct _AFD_CONNECTION;


typedef struct _AFD_DISCONNECT_CONTEXT {
    LARGE_INTEGER Timeout;
    PIRP          Irp;
} AFD_DISCONNECT_CONTEXT, *PAFD_DISCONNECT_CONTEXT;


typedef struct _AFD_LR_LIST_ITEM AFD_LR_LIST_ITEM, *PAFD_LR_LIST_ITEM;
typedef BOOLEAN (* PAFD_LR_LIST_ROUTINE) (PAFD_LR_LIST_ITEM Item);

struct _AFD_LR_LIST_ITEM {
    SINGLE_LIST_ENTRY       SListLink;    // Link in the list
    PAFD_LR_LIST_ROUTINE    Routine;      // Processing routine;
};


//
// Endpoint and connection structures and related informaion.
//
//
// Block types that identify which fields are
// available in the strucutures.
//

#define AfdBlockTypeEndpoint        0xAFD0
#define AfdBlockTypeDatagram        0xAFD1
#define AfdBlockTypeVcConnecting    0xAFD2
#define AfdBlockTypeVcListening     0xAFD4
#define AfdBlockTypeVcBoth          0xAFD6
#define AfdBlockTypeConnection      0xAFD8

#define AfdBlockTypeHelper              0xAAFD
#define AfdBlockTypeInvalidConnection   0xEAFD
#define AfdBlockTypeInvalidEndpoint     0xCAFD

#define AfdBlockTypeSanHelper           0x0AFD
#define AfdBlockTypeSanEndpoint         0x1AFD

#if DBG
#define IS_AFD_ENDPOINT_TYPE( endpoint )                         \
            ( (endpoint)->Type == AfdBlockTypeEndpoint ||        \
              (endpoint)->Type == AfdBlockTypeDatagram ||        \
              (endpoint)->Type == AfdBlockTypeVcConnecting ||    \
              (endpoint)->Type == AfdBlockTypeVcListening ||     \
              (endpoint)->Type == AfdBlockTypeVcBoth ||          \
              (endpoint)->Type == AfdBlockTypeHelper ||          \
              (endpoint)->Type == AfdBlockTypeSanHelper ||       \
              (endpoint)->Type == AfdBlockTypeSanEndpoint )
#endif

#define AfdConnectionStateFree       0
#define AfdConnectionStateUnaccepted 1
#define AfdConnectionStateReturned   2
#define AfdConnectionStateConnected  3
#define AfdConnectionStateClosing    4

//
// Flags that further qualify the state of the connection
//
typedef struct AFD_CONNECTION_STATE_FLAGS {
	union {
		struct {
		    LOGICAL TdiBufferring:1,    // (Does not really belon here)
			        :3,                 // This spacing makes strcutures
                                        // much more readable (hex) in the 
                                        // debugger and has no effect
                                        // on the generated code as long
                                        // as number of flags is less than
                                        // 8 (we still take up full 32 bits
                                        // because of aligment requiremens
                                        // of most other fields)
		            AbortIndicated:1,
			        :3,
    		        DisconnectIndicated:1,
			        :3,
		            ConnectedReferenceAdded:1,
			        :3,
		            SpecialCondition:1,
			        :3,
		            CleanupBegun:1,
			        :3,
		            ClosePendedTransmit:1,
			        :3,
                    OnLRList:1,
                    SanConnection:1,
                    :2;
		};
		LOGICAL		ConnectionStateFlags;
	};
} AFD_CONNECTION_STATE_FLAGS;
C_ASSERT (sizeof (AFD_CONNECTION_STATE_FLAGS)==sizeof (LOGICAL));

typedef struct _AFD_CONNECTION {
    // *** Frequently used, mostly read-only fields (state/type/flag changes are rare).
    USHORT Type;
    USHORT State;
    AFD_CONNECTION_STATE_FLAGS ;

    struct _AFD_ENDPOINT *Endpoint;
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    PEPROCESS   OwningProcess;


    union {
	    LONGLONG ConnectTime;
        PIRP     AcceptIrp;
        PIRP     ListenIrp;
        PIRP     ConnectIrp;	// for SAN
    };

    // *** Frequently used volatile fields.
    volatile LONG ReferenceCount;

    union {

        struct {
            LARGE_INTEGER ReceiveBytesIndicated;
            LARGE_INTEGER ReceiveBytesTaken;
            LARGE_INTEGER ReceiveBytesOutstanding;

            LARGE_INTEGER ReceiveExpeditedBytesIndicated;
            LARGE_INTEGER ReceiveExpeditedBytesTaken;
            LARGE_INTEGER ReceiveExpeditedBytesOutstanding;
            BOOLEAN NonBlockingSendPossible;
            BOOLEAN ZeroByteReceiveIndicated;
        } Bufferring;

        struct {
            LIST_ENTRY ReceiveIrpListHead;
            LIST_ENTRY ReceiveBufferListHead;

            CLONG BufferredReceiveBytes;
            CLONG BufferredExpeditedBytes;

            USHORT BufferredReceiveCount;
            USHORT BufferredExpeditedCount;
            CLONG ReceiveBytesInTransport;

            LIST_ENTRY SendIrpListHead;
            
            CLONG BufferredSendBytes;
            CLONG BufferredSendCount;

            PIRP DisconnectIrp;

            LONG  ReceiveIrpsInTransport;   // debug only.
        } NonBufferring;

    } Common;


    CLONG MaxBufferredReceiveBytes;
    CLONG MaxBufferredSendBytes;

    PTRANSPORT_ADDRESS RemoteAddress;
    ULONG RemoteAddressLength;
    LONG    Sequence;

    HANDLE Handle;



    union {
        AFD_WORK_ITEM           WorkItem;   // Work item to free the connection
                                            // Connection has to be at ref 0 to be
                                            // on the work queue, so it cannot be
                                            // on the lists below or being disconnected
                                            // because when on any of these lists the
                                            // ref count is above 0.
        struct {
            union {
                AFD_DISCONNECT_CONTEXT  DisconnectContext;
                                            // Disconnect operation context, we cannot be
                                            // on the listening endpoint list
                SINGLE_LIST_ENTRY       SListEntry;
                                            // Links for listening endpoint lists
                LIST_ENTRY              ListEntry;
            };
            AFD_LR_LIST_ITEM    LRListItem; // Link for low resource list. When on this
                                            // list connection is referenced, but it can
                                            // also be on the listening endpoint list or
                                            // in the process of disconnecting.
        };
    };

    PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers;

#if REFERENCE_DEBUG
    LONG CurrentReferenceSlot;
    AFD_REFERENCE_DEBUG ReferenceDebug[MAX_REFERENCE];
#endif

#ifdef _AFD_VERIFY_DATA_
    ULONGLONG VerifySequenceNumber;
#endif // _AFD_VERIFY_DATA_

} AFD_CONNECTION, *PAFD_CONNECTION;

#ifdef _AFD_VERIFY_DATA_
VOID
AfdVerifyBuffer (
    PAFD_CONNECTION Connection,
    PVOID           Buffer,
    ULONG           Length
    );
VOID
AfdVerifyMdl (
    PAFD_CONNECTION Connection,
    PMDL            Mdl,
    ULONG           Offset,
    ULONG           Length
    );
VOID
AfdVerifyAddress (
    PAFD_CONNECTION Connection,
    PTRANSPORT_ADDRESS Address
    );

#define AFD_VERIFY_BUFFER(_connection,_buffer,_length) \
            AfdVerifyBuffer(_connection,_buffer,_length)
#define AFD_VERIFY_MDL(_connection,_mdl,_offset,_length) \
            AfdVerifyMdl(_connection,_mdl,_offset,_length)
#define AFD_VERIFY_ADDRESS(_connection,_address) \
            AfdVerifyAddress(_connection,_address)
#else
#define AFD_VERIFY_BUFFER(_connection,_buffer,_length)
#define AFD_VERIFY_MDL(_connection,_mdl,_offset,_length)
#define AFD_VERIFY_ADDRESS(_connection,_address)
#endif // _AFD_VERIFY_DATA_

//
// Some macros that make code more readable.
//

#define VcNonBlockingSendPossible Common.Bufferring.NonBlockingSendPossible
#define VcZeroByteReceiveIndicated Common.Bufferring.ZeroByteReceiveIndicated

#define VcReceiveIrpListHead Common.NonBufferring.ReceiveIrpListHead
#define VcReceiveBufferListHead Common.NonBufferring.ReceiveBufferListHead
#define VcSendIrpListHead Common.NonBufferring.SendIrpListHead

#define VcBufferredReceiveBytes Common.NonBufferring.BufferredReceiveBytes
#define VcBufferredExpeditedBytes Common.NonBufferring.BufferredExpeditedBytes
#define VcBufferredReceiveCount Common.NonBufferring.BufferredReceiveCount
#define VcBufferredExpeditedCount Common.NonBufferring.BufferredExpeditedCount

#define VcReceiveBytesInTransport Common.NonBufferring.ReceiveBytesInTransport
#if DBG
#define VcReceiveIrpsInTransport Common.NonBufferring.ReceiveIrpsInTransport
#endif

#define VcBufferredSendBytes Common.NonBufferring.BufferredSendBytes
#define VcBufferredSendCount Common.NonBufferring.BufferredSendCount

#define VcDisconnectIrp Common.NonBufferring.DisconnectIrp

//
// Information stored about each transport device name for which there
// is an open endpoint.
//

typedef struct _AFD_TRANSPORT_INFO {
    LIST_ENTRY TransportInfoListEntry;
    volatile LONG ReferenceCount;
    BOOLEAN InfoValid;
    UNICODE_STRING TransportDeviceName;
    TDI_PROVIDER_INFO ProviderInfo;
    //WCHAR TransportDeviceNameStructure;
} AFD_TRANSPORT_INFO, *PAFD_TRANSPORT_INFO;

//
// Endpoint state definitions (can't be zero or state change
// macros won't work correctly).
//

#define AfdEndpointStateOpen              1
#define AfdEndpointStateBound             2
#define AfdEndpointStateConnected         3
#define AfdEndpointStateCleanup           4
#define AfdEndpointStateClosing           5
#define AfdEndpointStateTransmitClosing   6
#define AfdEndpointStateInvalid           7

//
// Flags that further qualify the state of the endpoint
//
typedef struct AFD_ENDPOINT_STATE_FLAGS {
	union {
		struct {
            LOGICAL Listening:1,
                    DelayedAcceptance:1,
			        :2,                 // This spacing makes strcutures
                                        // much more readable (hex) in the 
                                        // debugger and has no effect
                                        // on the generated code as long
                                        // as number of flags is less than
                                        // 8 (we still take up full 32 bits
                                        // because of aligment requiremens
                                        // of most other fields)
			        NonBlocking:1,
			        :3,
			        InLine:1,
			        :3,
			        EndpointCleanedUp:1,
			        :3,
			        PollCalled:1,
			        :3,
                    RoutingQueryReferenced:1,
                    RoutingQueryIPv6:1,
                    :2,
                    DisableFastIoSend:1,
                    EnableSendEvent:1,
                    :2,
                    DisableFastIoRecv:1,
                    :3;
		};
		LOGICAL		EndpointStateFlags;
	};
} AFD_ENDPOINT_STATE_FLAGS;
C_ASSERT (sizeof (AFD_ENDPOINT_STATE_FLAGS)==sizeof (LOGICAL));

typedef struct _AFD_ENDPOINT {
    // *** Frequently used, mostly read-only fields (state/type/flag changes are rare).
    USHORT  Type;
    UCHAR   State;
    BOOLEAN AdminAccessGranted;
    ULONG   TdiServiceFlags;		// Tdi transport flags cached for quick access.

    AFD_ENDPOINT_FLAGS __f;			// As requested by the application through the
									// Winsock2 provider flags and/or socket type
    AFD_ENDPOINT_STATE_FLAGS ;

    PFILE_OBJECT	AddressFileObject;
    PDEVICE_OBJECT	AddressDeviceObject;
    PEPROCESS       OwningProcess;


    // *** Frequently used volatile fields.

    AFD_QSPIN_LOCK  SpinLock;       // Pointer sized.
    volatile LONG ReferenceCount;
    ULONG EventsActive;




    //
    // Use a union to overlap the fields that are exclusive to datagram
    // connecting, or listening endpoints.  Since many fields are
    // relevant to only one type of socket, it makes no sense to
    // maintain the fields for all sockets--instead, save some nonpaged
    // pool by combining them.
    //

    union {
        //
        // Information for circuit-based endpoints
        //
        struct {
            union {
                struct {
                    // These members are valid for listening endpoints
                    // (AfdBlockTypeVcListening).
                    LIST_ENTRY UnacceptedConnectionListHead;
                    LIST_ENTRY ReturnedConnectionListHead;
                    LIST_ENTRY ListeningIrpListHead;

                    // The below lists have their own lock which gets
                    // used on the machines that do not support 64-bit
                    // interlocked compare and exchange.  On these machines
                    // using endpoint spinlock to synchronize causes all kinds
                    // of nasty deadlock conditions.
                    union {
                        LIST_ENTRY  ListenConnectionListHead; // Delayed accept
                        SLIST_HEADER FreeConnectionListHead;
                    };
                    SLIST_HEADER PreacceptedConnectionsListHead;

                    LONG FailedConnectionAdds;
                    LONG TdiAcceptPendingCount;

                    LONG Sequence;
                    BOOLEAN EnableDynamicBacklog;
			        BOOLEAN	BacklogReplenishActive; // Worker is scheduled
                    USHORT  MaxExtraConnections;  // Extra connections we keep in the free queue
                                                  // based on maximum number of AcceptEx requests
                } Listening;
                struct {
                    KAPC    Apc;
                    USHORT  RemoteSocketAddressOffset;  // Offset inside of socket context
                                                        // pointing to remote address.
                    USHORT  RemoteSocketAddressLength;  // Length of the address.
#ifndef i386
                    BOOLEAN FixAddressAlignment;        // Fix address alignment in
                                                        // SuperAccept
#endif
                };
            };
            // These members are valid for all vc endpoints (but
            // can be NULL)
            PAFD_CONNECTION Connection;
            struct _AFD_ENDPOINT *ListenEndpoint;
            PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers;
        } VirtualCircuit;

#define VcConnecting    VirtualCircuit
#define VcListening     VirtualCircuit.Listening
#define VcConnection    VirtualCircuit.Connection
        //
        // Information for datagram endpoints.  Note that different
        // information is kept depending on whether the underlying
        // transport buffers internally.
        //

        struct {
            LIST_ENTRY ReceiveIrpListHead;
            LIST_ENTRY PeekIrpListHead;
            LIST_ENTRY ReceiveBufferListHead;

            CLONG BufferredReceiveBytes;
            CLONG BufferredReceiveCount;

            CLONG MaxBufferredReceiveBytes;
            CLONG BufferredSendBytes;
            CLONG MaxBufferredSendBytes;


            ULONG RemoteAddressLength;
            PTRANSPORT_ADDRESS RemoteAddress;

            union {
                struct {
                    LOGICAL CircularQueueing:1,
                        :3,
                        HalfConnect:1,
                        :3,
                        DisablePUError:1,
                        :3,
                        AddressDrop:1,
                        ResourceDrop:1,
                        BufferDrop:1,
                        ErrorDrop:1;
                };
                LOGICAL Flags;
            };
        } Datagram;

        struct {
            LIST_ENTRY SanListLink;
            PVOID   IoCompletionPort;
            PKEVENT IoCompletionEvent;
            LONG    Plsn;   // Provider list sequence number
        } SanHlpr;

        struct {
            struct _AFD_ENDPOINT *SanHlpr;
            PFILE_OBJECT FileObject;
            union {
                //
                // We can only have either one of two at any given time.
                //
                PAFD_SWITCH_CONTEXT  SwitchContext;
                PVOID       SavedContext;
            };
            PAFD_SWITCH_CONTEXT  LocalContext;
            LIST_ENTRY  IrpList;
            ULONG       SavedContextLength;
            ULONG       RequestId;
            ULONG       SelectEventsActive;
            NTSTATUS    CtxTransferStatus;
            BOOLEAN     ImplicitDup; // Dup-ed into another process without
                                     // explicit request from the applicaiton
                                        
        } SanEndp;

    } Common;


    volatile PVOID Context;
    CLONG ContextLength;

    ULONG LocalAddressLength;
    PTRANSPORT_ADDRESS LocalAddress;

    CLONG DisconnectMode;
    CLONG OutstandingIrpCount;

    HANDLE	AddressHandle;		// TDI transport address object
	PAFD_TRANSPORT_INFO TransportInfo;

    LIST_ENTRY RoutingNotifications;  // For non-blocking sockets
    LIST_ENTRY RequestList;         // For misc requests

    LIST_ENTRY GlobalEndpointListEntry;
    AFD_WORK_ITEM WorkItem;

    PIRP            Irp;            // AcceptEx or TransmitPackets IRP
    //
    // Non-zero when state change such as binding, accepting,
    // conntecting, and transmit file are in progress.
    LONG  StateChangeInProgress;

    //
    // EventSelect info.
    //

    ULONG EventsEnabled;
    NTSTATUS EventStatus[AFD_NUM_POLL_EVENTS]; // Currently 13 events
    PKEVENT EventObject;

    //
    // Socket grouping.
    //

    LONG GroupID;
    AFD_GROUP_TYPE GroupType;
    LIST_ENTRY ConstrainedEndpointListEntry;

    //
    // Debug stuff.
    //

#if REFERENCE_DEBUG
    LONG CurrentReferenceSlot;
    AFD_REFERENCE_DEBUG ReferenceDebug[MAX_REFERENCE];
#endif

#if DBG
    LIST_ENTRY OutstandingIrpListHead;
    LONG ObReferenceBias;
#endif

} AFD_ENDPOINT, *PAFD_ENDPOINT;

typedef struct _AFD_POLL_ENDPOINT_INFO {
    PAFD_ENDPOINT Endpoint;
    PFILE_OBJECT FileObject;
    HANDLE Handle;
    ULONG PollEvents;
} AFD_POLL_ENDPOINT_INFO, *PAFD_POLL_ENDPOINT_INFO;

typedef struct _AFD_POLL_INFO_INTERNAL {
    LIST_ENTRY PollListEntry;
    ULONG NumberOfEndpoints;
    PIRP Irp;
    union {
        struct {
            KDPC Dpc;
            KTIMER Timer;
        };
        KAPC    Apc;			// for SAN
    };
    BOOLEAN Unique;
    BOOLEAN TimerStarted;
    BOOLEAN SanPoll;
    AFD_POLL_ENDPOINT_INFO EndpointInfo[1];
} AFD_POLL_INFO_INTERNAL, *PAFD_POLL_INFO_INTERNAL;

//
// A couple of useful manifests that make code more readable.
//

#define ReceiveDatagramIrpListHead Common.Datagram.ReceiveIrpListHead
#define PeekDatagramIrpListHead Common.Datagram.PeekIrpListHead
#define ReceiveDatagramBufferListHead Common.Datagram.ReceiveBufferListHead
#define DgBufferredReceiveCount Common.Datagram.BufferredReceiveCount
#define DgBufferredReceiveBytes Common.Datagram.BufferredReceiveBytes
#define DgBufferredSendBytes Common.Datagram.BufferredSendBytes

#define AFD_CONNECTION_FROM_ENDPOINT( endpoint ) (  \
        (((endpoint)->Type & AfdBlockTypeVcConnecting)==AfdBlockTypeVcConnecting) \
            ? (endpoint)->Common.VirtualCircuit.Connection                        \
            : NULL                                                                \
     )

//
// A structure which describes buffers used by AFD to perform bufferring
// for TDI providers which do not perform internal bufferring.
// It is also used in other code path as buffer descriptors.
//
typedef struct _AFD_BUFFER_HEADER AFD_BUFFER_HEADER, *PAFD_BUFFER_HEADER;

#define _AFD_BUFFER_HEADER_                                                     \
    union {                                                                     \
      TDI_CONNECTION_INFORMATION TdiInfo; /*holds info for TDI requests */      \
                                          /*with remote address */              \
      struct {                                                                  \
        union {           /* Links */                                           \
          struct {                                                              \
            union {                                                             \
              SINGLE_LIST_ENTRY SList; /* for buffer lookaside lists */         \
              PAFD_BUFFER_HEADER  Next; /* for transmit packet lists */         \
            };                                                                  \
            PFILE_OBJECT FileObject; /* for cached file in transmit file */     \
          };                                                                    \
          LIST_ENTRY BufferListEntry; /* for endpoint/connection lists */       \
        };                                                                      \
        union {                                                                 \
          struct {                                                              \
            CLONG   DataOffset;    /* offset in buffer to start of unread data*/\
            union {                                                             \
              ULONG   DatagramFlags; /* flags for datagrams with control info */\
              CLONG   RefCount; /* Permit partial copy outside the lock*/       \
            };                                                                  \
          };                                                                    \
          LARGE_INTEGER FileOffset; /* data offset from the start of the file */\
        };                                                                      \
        UCHAR       _Test; /* used to test relative field pos in the union */   \
      };                                                                        \
    };                                                                          \
    union {                                                                     \
      PVOID     Context; /* stores context info (endp/conn/etc)*/               \
      NTSTATUS  Status;/* stores status of completed operation */               \
    };                                                                          \
    PMDL        Mdl;             /* pointer to an MDL describing the buffer*/   \
    CLONG       DataLength;      /* actual data in the buffer */                \
    CLONG       BufferLength;    /* amount of space allocated for the buffer */ \
    union {                                                                     \
      struct {                                                                  \
        /* Flags that describe data in the buffer */                            \
        UCHAR   ExpeditedData:1, /* The buffer contains expedited data*/        \
                :3,                                                             \
                PartialMessage:1,/* This is a partial message*/                 \
                :3;                                                             \
        /* Flags that keep allocation information */                            \
        UCHAR   NdisPacket:1,    /* Context is a packet to return to NDIS/TDI*/ \
                :3,                                                             \
                Placement:2,     /* Relative placement of the pieces */         \
                AlignmentAdjusted:1, /* MM block alignment was adjusted to */   \
                                 /* meet AFD buffer alignment requirement */    \
                Lookaside:1;     /* Poped from Slist (no quota charge)*/        \
      };                                                                        \
      USHORT    Flags;                                                          \
    };                                                                          \
    USHORT      AllocatedAddressLength/* length allocated for address */        \


struct _AFD_BUFFER_HEADER {
    _AFD_BUFFER_HEADER_ ;
};

//
// The buffer management code makes the following assumptions
// about the union at the top the buffer header so that list
// links and DataOffset field are not in conflict with
// RemoteAddress fields of the TDI_CONNECTION_INFORMATION.
//
C_ASSERT (FIELD_OFFSET (AFD_BUFFER_HEADER, TdiInfo.RemoteAddress) >=
                            FIELD_OFFSET (AFD_BUFFER_HEADER, _Test));
C_ASSERT (FIELD_OFFSET (AFD_BUFFER_HEADER, TdiInfo.RemoteAddressLength)>=
                            FIELD_OFFSET (AFD_BUFFER_HEADER, _Test));

C_ASSERT(FIELD_OFFSET (AFD_BUFFER_HEADER, AllocatedAddressLength)==
                FIELD_OFFSET(AFD_BUFFER_HEADER, Flags)+sizeof (USHORT));

typedef struct AFD_BUFFER_TAG {
    union {
        struct {
            _AFD_BUFFER_HEADER_;    // easy access to individual members
        };
        AFD_BUFFER_HEADER Header;   // access to the header as a whole
    };
#if DBG
    PVOID Caller;
    PVOID CallersCaller;
#endif
    // UCHAR Address[];            // address of datagram sender
} AFD_BUFFER_TAG, *PAFD_BUFFER_TAG;

typedef DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) struct _AFD_BUFFER {
    union {
        struct {
            _AFD_BUFFER_HEADER_;    // easy access to individual members
        };
        AFD_BUFFER_HEADER Header;   // access to the header as a whole
    };
    PIRP Irp;                      // pointer to the IRP associated w/the buffer
    PVOID Buffer;                  // a pointer to the actual data buffer

#if DBG
    LIST_ENTRY DebugListEntry;
    PVOID Caller;
    PVOID CallersCaller;
#endif
    // IRP Irp;                    // the IRP follows this structure
    // MDL Mdl;                    // the MDL follows the IRP
    // UCHAR Address[];            // address of datagram sender
    // UCHAR Buffer[BufferLength]; // the actual data buffer is last
} AFD_BUFFER, *PAFD_BUFFER;

//
// Placement of pieces that comprise the AFD_BUFFER.
// We have four pieces: header, IRP, MDL, data buffer
// and use 2 bits to encode each.
// We need to save the first piece so we know where the memory block
// starts when we need to return it to the memory manager.
//
#define AFD_PLACEMENT_HDR       0
#define AFD_PLACEMENT_IRP       1
#define AFD_PLACEMENT_MDL       2
#define AFD_PLACEMENT_BUFFER    3

#define AFD_PLACEMENT_HDR_IRP   (AFD_PLACEMENT_HDR|(AFD_PLACEMENT_IRP<<2))
#define AFD_PLACEMENT_HDR_MDL   (AFD_PLACEMENT_HDR|(AFD_PLACEMENT_MDL<<2))
#define AFD_PLACEMENT_IRP_MDL   (AFD_PLACEMENT_IRP|(AFD_PLACEMENT_MDL<<2))

#define AFD_PLACEMENT_HDR_IRP_MDL   (AFD_PLACEMENT_HDR|(AFD_PLACEMENT_IRP<<2)|(AFD_PLACEMENT_MDL<<4))


//
// ALIGN_DOWN_A aligns to given alignment requirement
// (as opposed to the type in the original ALIGN_DOWN macro)
//
#define ALIGN_DOWN_A(length,alignment)   \
    (((ULONG)(length)) & ~ ((alignment)-1))

//
// ALIGN_DOWN_A for pointers.
//
#define ALIGN_DOWN_A_POINTER(address,alignment)  \
    ((PVOID)(((ULONG_PTR)(address)) & ~ ((ULONG_PTR)(alignment)-1)))


//
// ALIGN_UP_A aligns to given alignment requirement
// (as opposed to the type in the original ALIGN_UP macro)
//
#define ALIGN_UP_A(length,alignment)   \
    ((((ULONG)(length)) + (alignment)-1) & ~ ((alignment)-1))

//
// ALIGN_UP_A for pointers.
//
#define ALIGN_UP_A_POINTER(address,alignment)  \
    ALIGN_DOWN_A_POINTER(((ULONG_PTR)(address) + alignment-1), alignment)

//
// ALIGN_UP_TO_TYPE aligns size to make sure it meets
// the type alignment requirement
//
#define ALIGN_UP_TO_TYPE(length,type)   \
    ALIGN_UP_A(length,TYPE_ALIGNMENT(type))

//
// ALIGN_UP_TO_TYPE for pointers.
//
#define ALIGN_UP_TO_TYPE_POINTER(address,type)   \
    ALIGN_UP_A_POINTER(address,TYPE_ALIGNMENT(type))

#if DBG

#define IS_VALID_AFD_BUFFER(b) (                                                                                                    \
    ((b)->Placement==AFD_PLACEMENT_HDR)                                                                                             \
        ? ((PUCHAR)b<(PUCHAR)(b)->Buffer && (PUCHAR)b<(PUCHAR)(b)->Mdl && (PUCHAR)b<(PUCHAR)(b)->Irp)                               \
        : (((b)->Placement==AFD_PLACEMENT_MDL)                                                                                      \
            ? ((PUCHAR)(b)->Mdl<(PUCHAR)(b)->Buffer && (PUCHAR)(b)->Mdl<(PUCHAR)b && (PUCHAR)(b)->Mdl<(PUCHAR)(b)->Irp)             \
            : ((b->Placement==AFD_PLACEMENT_IRP)                                                                                    \
                ? ((PUCHAR)(b)->Irp<(PUCHAR)(b)->Buffer && (PUCHAR)(b)->Irp<(PUCHAR)b && (PUCHAR)(b)->Irp<(PUCHAR)(b)->Mdl)         \
                : ((PUCHAR)(b)->Buffer<(PUCHAR)(b)->Irp && (PUCHAR)(b)->Buffer<(PUCHAR)b && (PUCHAR)(b)->Buffer<(PUCHAR)(b)->Mdl))  \
            )                                                                                                                       \
        )                                                                                                                           \

#endif


//
// Pointer to an IRP cleanup routine. This is used as a parameter to
// AfdCompleteIrpList().
//

typedef
BOOLEAN
(NTAPI * PAFD_IRP_CLEANUP_ROUTINE)(
    IN PIRP Irp
    );

//
// Debug statistics.
//

typedef struct _AFD_QUOTA_STATS {
    LARGE_INTEGER Charged;
    LARGE_INTEGER Returned;
} AFD_QUOTA_STATS;

typedef struct _AFD_HANDLE_STATS {
    LONG AddrOpened;
    LONG AddrClosed;
    LONG AddrRef;
    LONG AddrDeref;
    LONG ConnOpened;
    LONG ConnClosed;
    LONG ConnRef;
    LONG ConnDeref;
    LONG FileRef;
    LONG FileDeref;
} AFD_HANDLE_STATS;

typedef struct _AFD_QUEUE_STATS {
    LONG AfdWorkItemsQueued;
    LONG ExWorkItemsQueued;
    LONG WorkerEnter;
    LONG WorkerLeave;
    LONG AfdWorkItemsProcessed;
    PETHREAD AfdWorkerThread;
} AFD_QUEUE_STATS;

typedef struct _AFD_CONNECTION_STATS {
    LONG ConnectedReferencesAdded;
    LONG ConnectedReferencesDeleted;
    LONG GracefulDisconnectsInitiated;
    LONG GracefulDisconnectsCompleted;
    LONG GracefulDisconnectIndications;
    LONG AbortiveDisconnectsInitiated;
    LONG AbortiveDisconnectsCompleted;
    LONG AbortiveDisconnectIndications;
    LONG ConnectionIndications;
    LONG ConnectionsDropped;
    LONG ConnectionsAccepted;
    LONG ConnectionsPreaccepted;
    LONG ConnectionsReused;
    LONG EndpointsReused;
} AFD_CONNECTION_STATS;

//
// Global data. Resouces and lookaside list descriptors
// cannot be statically allocated, as they need to ALWAYS be nonpageable,
// even when the entire driver is paged out.
// Alignment table is variable-size and also cannot be statically allocated.
//

enum {
    AFD_LARGE_BUFFER_LIST=0,
    AFD_MEDIUM_BUFFER_LIST,
    AFD_SMALL_BUFFER_LIST,
    AFD_BUFFER_TAG_LIST,
    AFD_TP_INFO_LIST,
    AFD_REMOTE_ADDR_LIST,
    AFD_NUM_LOOKASIDE_LISTS
} AFD_LOOKASIDE_LISTS_INDEX;

typedef struct _AFD_GLOBAL_DATA {
    ERESOURCE               Resource;
    NPAGED_LOOKASIDE_LIST   List[AFD_NUM_LOOKASIDE_LISTS];
#define LargeBufferList     List[AFD_LARGE_BUFFER_LIST]
#define MediumBufferList    List[AFD_MEDIUM_BUFFER_LIST]
#define SmallBufferList     List[AFD_SMALL_BUFFER_LIST]
#define BufferTagList       List[AFD_BUFFER_TAG_LIST]
#define TpInfoList          List[AFD_TP_INFO_LIST]
#define RemoteAddrList      List[AFD_REMOTE_ADDR_LIST]
    LONG                    TrimFlags;
    KTIMER                  Timer;
    KDPC                    Dpc;
    UCHAR                   BufferAlignmentTable[ANYSIZE_ARRAY];
} AFD_GLOBAL_DATA, *PAFD_GLOBAL_DATA;

//
// Context structure for misc requests pended in AFD.
//
typedef struct _AFD_REQUEST_CONTEXT AFD_REQUEST_CONTEXT, *PAFD_REQUEST_CONTEXT;

//
// The routine is called after request is removed from endpoint list
// for cleanup purposes
//
typedef BOOLEAN (* PAFD_REQUEST_CLEANUP) (
                    PAFD_ENDPOINT           Endpoint,
                    PAFD_REQUEST_CONTEXT     NotifyCtx
                    );

//
// This structure has to no more 16 bytes long so we can
// reuse IrpSp->Parameters for it.
//
typedef struct _AFD_REQUEST_CONTEXT {
    LIST_ENTRY              EndpointListLink;   // Link in endpoint list
    PAFD_REQUEST_CLEANUP    CleanupRoutine;     // Routine to call to cancel
    PVOID                   Context;            // Request dependent context
                                                // (PIRP)
};

//
// We use list entry fields to synchronize completion with cleanup/cancel
// routine assuming that as long as the entry is in the list
// both Flink and Blink fields cannot be NULL. (using these
// fields for synchronization allows us to cut down on
// cancel spinlock usage)
//

#define AfdEnqueueRequest(Endpoint,Request)                     \
    ExInterlockedInsertTailList(&(Endpoint)->RequestList,       \
                                &(Request)->EndpointListLink,   \
                                &(Endpoint)->SpinLock)


#define AfdIsRequestInQueue(Request)                           \
            ((Request)->EndpointListLink.Flink!=NULL)

#define AfdMarkRequestCompleted(Request)                       \
            (Request)->EndpointListLink.Blink = NULL

#define AfdIsRequestCompleted(Request)                         \
            ((Request)->EndpointListLink.Blink==NULL)


typedef struct _ROUTING_NOTIFY {
    LIST_ENTRY      NotifyListLink;
    PIRP            NotifyIrp;
    PVOID           NotifyContext;
} ROUTING_NOTIFY, *PROUTING_NOTIFY;

typedef struct _AFD_ADDRESS_ENTRY {
    LIST_ENTRY      AddressListLink;
    UNICODE_STRING  DeviceName;
    TA_ADDRESS      Address;
} AFD_ADDRESS_ENTRY, *PAFD_ADDRESS_ENTRY;

typedef struct _AFD_ADDRESS_CHANGE {
    LIST_ENTRY      ChangeListLink;
    union {
        PAFD_ENDPOINT   Endpoint;
        PIRP            Irp;
    };
    USHORT          AddressType;
    BOOLEAN         NonBlocking;
} AFD_ADDRESS_CHANGE, *PAFD_ADDRESS_CHANGE;


typedef 
NTSTATUS
(* PAFD_IMMEDIATE_CALL) (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    );

typedef
NTSTATUS
(FASTCALL * PAFD_IRP_CALL) (
    IN  PIRP                Irp,
    IN  PIO_STACK_LOCATION  IrpSp
    );
    
typedef struct _AFD_TRANSMIT_PACKETS_ELEMENT {
#define TP_MDL      0x80000000
#define TP_COMBINE  0x40000000
    ULONG Flags;
    ULONG Length;
    union {
        struct {
            LARGE_INTEGER FileOffset;
            PFILE_OBJECT  FileObject;
        };
        struct {
            PVOID         Buffer;
            PMDL          Mdl;
        };
    };
} AFD_TRANSMIT_PACKETS_ELEMENT, *PAFD_TRANSMIT_PACKETS_ELEMENT;

//
// Structure to keep track of transmit packets request
//
typedef struct _AFD_TPACKETS_INFO_INTERNAL AFD_TPACKETS_INFO_INTERNAL, *PAFD_TPACKETS_INFO_INTERNAL;
struct _AFD_TPACKETS_INFO_INTERNAL {
    union {
        SINGLE_LIST_ENTRY   SListEntry;     // Link on S-List
        PFILE_OBJECT    TdiFileObject;      // Tdi objects (sending to)
    };

    PDEVICE_OBJECT  TdiDeviceObject;

    PMDL            HeadMdl;        // Ready to send chain
    PMDL            *TailMdl;
    
    PAFD_BUFFER_HEADER  HeadPd;     // Corresponding packet chain
    PAFD_BUFFER_HEADER  *TailPd;

    PIRP            ReadIrp;        // Irp used for file reads.
    PAFD_TRANSMIT_PACKETS_ELEMENT
                    ElementArray;   // Packet array
    
    ULONG           NextElement;    // Next element to send.
    ULONG           ElementCount;   // Total number of elements in the array
    
    ULONG           RemainingPkts;  // Number of packets remaining to be sent.
    USHORT          NumSendIrps;    // Actual number of send IRPs
    BOOLEAN         ArrayAllocated; // Element array is allocated (not built-in).
    BOOLEAN         PdNeedsPps;     // Packet descriptor being built needs post-
                                    // processing after completion.
    ULONG           PdLength;       // Currently accumulated send length
    ULONG           SendPacketLength; // Maximum length of the packet
                                    // APC/Work item for worker scheduling
    union {
        KAPC                Apc;
        WORK_QUEUE_ITEM     WorkItem;
    };

#if REFERENCE_DEBUG
    LONG CurrentReferenceSlot;
    AFD_REFERENCE_DEBUG ReferenceDebug[MAX_REFERENCE];
#endif
#if AFD_PERF_DBG
    LONG            WorkersExecuted;
#endif
#define AFD_TP_MIN_SEND_IRPS    2   // Need at least two to keep transport busy
#define AFD_TP_MAX_SEND_IRPS    8   // Max is based on current flags layout below
    PIRP            SendIrp[AFD_TP_MAX_SEND_IRPS];
    // ElementArray
    // SendIrp1
    // SendIrp2
};

//
// Structure maintained in driver context of the TPackets IRP
//
typedef struct _AFD_TPACKETS_IRP_CTX {
    LIST_ENTRY      EndpQueueEntry;
    volatile LONG   ReferenceCount;
    volatile LONG   StateFlags;
} AFD_TPACKETS_IRP_CTX, *PAFD_TPACKETS_IRP_CTX;

#define AFD_TP_ABORT_PENDING        0x00000001  // Request is being aborted
#define AFD_TP_WORKER_SCHEDULED     0x00000010  // Worker is scheduled or active
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
#define AFD_TP_SEND_AND_DISCONNECT  0x00000100  // S&D is enabled
#endif // TDI_SERVICE_SEND_AND_DISCONNECT

#define AFD_TP_READ_CALL_PENDING    0x00001000  // MDL_READ call is imminent or in progress on ReadIrp
#define AFD_TP_READ_COMP_PENDING    0x00002000  // Read completion is expected on ReadIrp
#define AFD_TP_READ_BUSY (AFD_TP_READ_CALL_PENDING|AFD_TP_READ_COMP_PENDING)

    // TDI_SEND call is imminent or in progress on send Irp i
#define AFD_TP_SEND_CALL_PENDING(i) (0x00010000<<((i)*2))
    // Send completion is expected on send Irp i
#define AFD_TP_SEND_COMP_PENDING(i) (0x00020000<<((i)*2))
#define AFD_TP_SEND_BUSY(i)         (0x00030000<<((i)*2))
#define AFD_TP_SEND_MASK            (0x55550000)
#define AFD_GET_TPIC(_i) ((PAFD_TPACKETS_IRP_CTX)&(_i)->Tail.Overlay.DriverContext)

//
// This macro verifies that the 32-bit mapping of the structures in 64-bit
// compiler match original 32-bit structures.  Note, that the verification is
// performed when this file is compiled by 32 bit compiler, but
// the actual structures are used by 64 bit code.
//

#ifdef _WIN64
#define AFD_CHECK32on64(_str,_fld)
#define AFD_MAX_NATURAL_ALIGNMENT32  sizeof(ULONG)
#else
#define AFD_CHECK32on64(_str,_fld)    \
    C_ASSERT (FIELD_OFFSET (_str,_fld)==FIELD_OFFSET(_str##32,_fld))
#endif

//
// Structures for mapping IOCTL parameters for 32-bit clients on 64-bit
// platform.
//
typedef UNALIGNED struct _WSABUF32 {
    ULONG            len;
    CHAR * POINTER_32 buf;
} WSABUF32, *LPWSABUF32;
AFD_CHECK32on64(WSABUF,len);
AFD_CHECK32on64(WSABUF,buf);

typedef UNALIGNED struct _QualityOfService32 {
    FLOWSPEC      SendingFlowspec;       /* the flow spec for data sending */
    FLOWSPEC      ReceivingFlowspec;     /* the flow spec for data receiving */
    WSABUF32      ProviderSpecific;      /* additional provider specific stuff */
} QOS32, * LPQOS32;
AFD_CHECK32on64(QOS,SendingFlowspec);
AFD_CHECK32on64(QOS,ReceivingFlowspec);
AFD_CHECK32on64(QOS,ProviderSpecific);

typedef UNALIGNED struct _AFD_ACCEPT_INFO32 {
    BOOLEAN     SanActive;
    LONG        Sequence;
    VOID * POINTER_32 AcceptHandle;
} AFD_ACCEPT_INFO32, *PAFD_ACCEPT_INFO32;
AFD_CHECK32on64(AFD_ACCEPT_INFO,SanActive);
AFD_CHECK32on64(AFD_ACCEPT_INFO,Sequence);
AFD_CHECK32on64(AFD_ACCEPT_INFO,AcceptHandle);

typedef UNALIGNED struct _AFD_SUPER_ACCEPT_INFO32 {
    BOOLEAN     SanActive;
    BOOLEAN     FixAddressAlignment;
    VOID * POINTER_32 AcceptHandle;
    ULONG ReceiveDataLength;
    ULONG LocalAddressLength;
    ULONG RemoteAddressLength;
} AFD_SUPER_ACCEPT_INFO32, *PAFD_SUPER_ACCEPT_INFO32;
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,SanActive);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,FixAddressAlignment);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,AcceptHandle);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,ReceiveDataLength);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,LocalAddressLength);
AFD_CHECK32on64(AFD_SUPER_ACCEPT_INFO,RemoteAddressLength);

typedef UNALIGNED struct _AFD_POLL_HANDLE_INFO32 {
    VOID * POINTER_32 Handle;
    ULONG             PollEvents;
    NTSTATUS          Status;
} AFD_POLL_HANDLE_INFO32, *PAFD_POLL_HANDLE_INFO32;
AFD_CHECK32on64(AFD_POLL_HANDLE_INFO,Handle);
AFD_CHECK32on64(AFD_POLL_HANDLE_INFO,PollEvents);
AFD_CHECK32on64(AFD_POLL_HANDLE_INFO,Status);

typedef UNALIGNED struct _AFD_POLL_INFO32 {
    LARGE_INTEGER Timeout;
    ULONG NumberOfHandles;
    BOOLEAN Unique;
    AFD_POLL_HANDLE_INFO32 Handles[1];
} AFD_POLL_INFO32, *PAFD_POLL_INFO32;
AFD_CHECK32on64(AFD_POLL_INFO,Timeout);
AFD_CHECK32on64(AFD_POLL_INFO,NumberOfHandles);
AFD_CHECK32on64(AFD_POLL_INFO,Unique);
AFD_CHECK32on64(AFD_POLL_INFO,Handles);

typedef UNALIGNED struct _AFD_HANDLE_INFO632 {
    VOID * POINTER_32 TdiAddressHandle;
    VOID * POINTER_32 TdiConnectionHandle;
} AFD_HANDLE_INFO32, *PAFD_HANDLE_INFO32;
AFD_CHECK32on64(AFD_HANDLE_INFO,TdiAddressHandle);
AFD_CHECK32on64(AFD_HANDLE_INFO,TdiConnectionHandle);

typedef UNALIGNED struct _AFD_TRANSMIT_FILE_INFO32 {
    LARGE_INTEGER Offset;
    LARGE_INTEGER WriteLength;
    ULONG SendPacketLength;
    VOID * POINTER_32 FileHandle;
    VOID * POINTER_32 Head;
    ULONG HeadLength;
    VOID * POINTER_32 Tail;
    ULONG TailLength;
    ULONG Flags;
} AFD_TRANSMIT_FILE_INFO32, *PAFD_TRANSMIT_FILE_INFO32;
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Offset);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,WriteLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,SendPacketLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,FileHandle);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Head);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,HeadLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Tail);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,TailLength);
AFD_CHECK32on64(AFD_TRANSMIT_FILE_INFO,Flags);

typedef UNALIGNED struct _AFD_SEND_INFO32 {
    WSABUF32 * POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_SEND_INFO32, *PAFD_SEND_INFO32;
AFD_CHECK32on64(AFD_SEND_INFO,BufferArray);
AFD_CHECK32on64(AFD_SEND_INFO,BufferCount);
AFD_CHECK32on64(AFD_SEND_INFO,AfdFlags);
AFD_CHECK32on64(AFD_SEND_INFO,TdiFlags);

typedef UNALIGNED struct _TDI_REQUEST32 {
    union {
        VOID * POINTER_32 AddressHandle;
        VOID * POINTER_32 ConnectionContext;
        VOID * POINTER_32 ControlChannel;
    } Handle;

    VOID * POINTER_32 RequestNotifyObject;
    VOID * POINTER_32 RequestContext;
    TDI_STATUS TdiStatus;
} TDI_REQUEST32, *PTDI_REQUEST32;
AFD_CHECK32on64(TDI_REQUEST,Handle);
AFD_CHECK32on64(TDI_REQUEST,RequestNotifyObject);
AFD_CHECK32on64(TDI_REQUEST,RequestContext);
AFD_CHECK32on64(TDI_REQUEST,TdiStatus);

typedef UNALIGNED struct _TDI_CONNECTION_INFORMATION32 {
    LONG UserDataLength;            // length of user data buffer
    VOID * POINTER_32 UserData;     // pointer to user data buffer
    LONG OptionsLength;             // length of follwoing buffer
    VOID * POINTER_32 Options;      // pointer to buffer containing options
    LONG RemoteAddressLength;       // length of following buffer
    VOID * POINTER_32 RemoteAddress;// buffer containing the remote address
} TDI_CONNECTION_INFORMATION32, *PTDI_CONNECTION_INFORMATION32;
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,UserDataLength);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,UserData);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,OptionsLength);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,Options);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,RemoteAddressLength);
AFD_CHECK32on64(TDI_CONNECTION_INFORMATION,RemoteAddress);

typedef UNALIGNED struct _TDI_REQUEST_SEND_DATAGRAM32 {
    TDI_REQUEST32 Request;
    TDI_CONNECTION_INFORMATION32 * POINTER_32 SendDatagramInformation;
} TDI_REQUEST_SEND_DATAGRAM32, *PTDI_REQUEST_SEND_DATAGRAM32;
AFD_CHECK32on64(TDI_REQUEST_SEND_DATAGRAM,Request);
AFD_CHECK32on64(TDI_REQUEST_SEND_DATAGRAM,SendDatagramInformation);


typedef UNALIGNED struct _AFD_SEND_DATAGRAM_INFO32 {
    WSABUF32 * POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    TDI_REQUEST_SEND_DATAGRAM32 TdiRequest;
    TDI_CONNECTION_INFORMATION32 TdiConnInfo;
} AFD_SEND_DATAGRAM_INFO32, *PAFD_SEND_DATAGRAM_INFO32;
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,BufferArray);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,BufferCount);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,AfdFlags);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,TdiRequest);
AFD_CHECK32on64(AFD_SEND_DATAGRAM_INFO,TdiConnInfo);

typedef UNALIGNED struct _AFD_RECV_INFO32 {
    WSABUF32 * POINTER_32  BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
} AFD_RECV_INFO32, *PAFD_RECV_INFO32;
AFD_CHECK32on64(AFD_RECV_INFO,BufferArray);
AFD_CHECK32on64(AFD_RECV_INFO,BufferCount);
AFD_CHECK32on64(AFD_RECV_INFO,AfdFlags);
AFD_CHECK32on64(AFD_RECV_INFO,TdiFlags);

typedef UNALIGNED struct _AFD_RECV_DATAGRAM_INFO32 {
    WSABUF32 * POINTER_32 BufferArray;
    ULONG BufferCount;
    ULONG AfdFlags;
    ULONG TdiFlags;
    VOID * POINTER_32 Address;
    ULONG * POINTER_32 AddressLength;
} AFD_RECV_DATAGRAM_INFO32, *PAFD_RECV_DATAGRAM_INFO32;
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,BufferArray);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,BufferCount);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,AfdFlags);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,TdiFlags);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,Address);
AFD_CHECK32on64(AFD_RECV_DATAGRAM_INFO,AddressLength);

typedef UNALIGNED struct _AFD_CONNECT_JOIN_INFO32 {
    BOOLEAN     SanActive;
    VOID * POINTER_32   RootEndpoint;   // Root endpoint for joins
    VOID * POINTER_32   ConnectEndpoint;// Connect/leaf endpoint for async connects
    TRANSPORT_ADDRESS   RemoteAddress;  // Remote address
} AFD_CONNECT_JOIN_INFO32, *PAFD_CONNECT_JOIN_INFO32;
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,SanActive);
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,RootEndpoint);
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,ConnectEndpoint);
AFD_CHECK32on64(AFD_CONNECT_JOIN_INFO,RemoteAddress);

typedef UNALIGNED struct _AFD_EVENT_SELECT_INFO32 {
    VOID * POINTER_32 Event;
    ULONG PollEvents;
} AFD_EVENT_SELECT_INFO32, *PAFD_EVENT_SELECT_INFO32;
AFD_CHECK32on64(AFD_EVENT_SELECT_INFO,Event);
AFD_CHECK32on64(AFD_EVENT_SELECT_INFO,PollEvents);

typedef UNALIGNED struct _AFD_QOS_INFO32 {
    QOS32 Qos;
    BOOLEAN GroupQos;
} AFD_QOS_INFO32, *PAFD_QOS_INFO32;
AFD_CHECK32on64(AFD_QOS_INFO,Qos);
AFD_CHECK32on64(AFD_QOS_INFO,GroupQos);

typedef UNALIGNED struct _AFD_TRANSPORT_IOCTL_INFO32 {
    VOID *  POINTER_32 Handle;
    VOID *  POINTER_32 InputBuffer;
    ULONG   InputBufferLength;
    ULONG   IoControlCode;
    ULONG   AfdFlags;
    ULONG   PollEvent;
} AFD_TRANSPORT_IOCTL_INFO32, *PAFD_TRANSPORT_IOCTL_INFO32;
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,Handle);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,InputBuffer);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,InputBufferLength);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,IoControlCode);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,AfdFlags);
AFD_CHECK32on64(AFD_TRANSPORT_IOCTL_INFO,PollEvent);

typedef UNALIGNED struct _TRANSMIT_PACKETS_ELEMENT32 {
    ULONG dwElFlags;
#define TP_MEMORY   1
#define TP_FILE     2
#define TP_EOP      4
    ULONG cLength;
    union {
        struct {
            LARGE_INTEGER       nFileOffset;
            VOID *  POINTER_32  hFile;
        };
        VOID *  POINTER_32      pBuffer;
    };
} TRANSMIT_PACKETS_ELEMENT32, *LPTRANSMIT_PACKETS_ELEMENT32;
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,dwElFlags);
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,nFileOffset);
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,hFile);
AFD_CHECK32on64(TRANSMIT_PACKETS_ELEMENT,pBuffer);

typedef UNALIGNED struct _AFD_TPACKETS_INFO32 {
    TRANSMIT_PACKETS_ELEMENT  * POINTER_32 ElementArray;
    ULONG                       ElementCount;
    ULONG                       SendSize;
    ULONG                       Flags;
} AFD_TPACKETS_INFO32, *PAFD_TPACKETS_INFO32;
AFD_CHECK32on64(AFD_TPACKETS_INFO,ElementArray);
AFD_CHECK32on64(AFD_TPACKETS_INFO,ElementCount);
AFD_CHECK32on64(AFD_TPACKETS_INFO,SendSize);
AFD_CHECK32on64(AFD_TPACKETS_INFO,Flags);

typedef UNALIGNED struct _AFD_RECV_MESSAGE_INFO32 {
    AFD_RECV_DATAGRAM_INFO32    dgi;
    VOID  * POINTER_32          ControlBuffer;
    ULONG * POINTER_32          ControlLength;
    ULONG * POINTER_32          MsgFlags;
} AFD_RECV_MESSAGE_INFO32, *PAFD_RECV_MESSAGE_INFO32;
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,dgi);
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,MsgFlags);
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,ControlBuffer);
AFD_CHECK32on64(AFD_RECV_MESSAGE_INFO,ControlLength);


typedef UNALIGNED struct _AFD_SWITCH_OPEN_PACKET32 {
    VOID * POINTER_32   CompletionPort; 
    VOID * POINTER_32   CompletionEvent;
} AFD_SWITCH_OPEN_PACKET32, *PAFD_SWITCH_OPEN_PACKET32;
AFD_CHECK32on64(AFD_SWITCH_OPEN_PACKET,CompletionPort);
AFD_CHECK32on64(AFD_SWITCH_OPEN_PACKET,CompletionEvent);

typedef UNALIGNED struct _AFD_SWITCH_CONTEXT_INFO32 {
    VOID * POINTER_32               SocketHandle;
    AFD_SWITCH_CONTEXT * POINTER_32 SwitchContext;
} AFD_SWITCH_CONTEXT_INFO32, *PAFD_SWITCH_CONTEXT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_CONTEXT_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_CONTEXT_INFO,SwitchContext);

typedef UNALIGNED struct _AFD_SWITCH_CONNECT_INFO32 {
    VOID * POINTER_32               ListenHandle;
    AFD_SWITCH_CONTEXT * POINTER_32 SwitchContext;
    TRANSPORT_ADDRESS               RemoteAddress;
} AFD_SWITCH_CONNECT_INFO32, *PAFD_SWITCH_CONNECT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_CONNECT_INFO,ListenHandle);
AFD_CHECK32on64(AFD_SWITCH_CONNECT_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_CONNECT_INFO,RemoteAddress);

typedef UNALIGNED struct _AFD_SWITCH_ACCEPT_INFO32 {
    VOID * POINTER_32   AcceptHandle;
    ULONG               ReceiveLength;
} AFD_SWITCH_ACCEPT_INFO32, *PAFD_SWITCH_ACCEPT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_ACCEPT_INFO,AcceptHandle);
AFD_CHECK32on64(AFD_SWITCH_ACCEPT_INFO,ReceiveLength);

typedef UNALIGNED struct _AFD_SWITCH_EVENT_INFO32 {
	VOID * POINTER_32	SocketHandle;
    AFD_SWITCH_CONTEXT * POINTER_32 SwitchContext;
	ULONG		        EventBit;
    NTSTATUS            Status;
} AFD_SWITCH_EVENT_INFO32, *PAFD_SWITCH_EVENT_INFO32;
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,EventBit);
AFD_CHECK32on64(AFD_SWITCH_EVENT_INFO,Status);

typedef UNALIGNED struct _AFD_SWITCH_REQUEST_INFO32 {
	VOID * POINTER_32   SocketHandle;
    AFD_SWITCH_CONTEXT * POINTER_32 SwitchContext;
    VOID * POINTER_32   RequestContext;
    NTSTATUS            RequestStatus;
    ULONG               DataOffset;
} AFD_SWITCH_REQUEST_INFO32, *PAFD_SWITCH_REQUEST_INFO32;
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,RequestContext);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,RequestStatus);
AFD_CHECK32on64(AFD_SWITCH_REQUEST_INFO,DataOffset);

typedef UNALIGNED struct _AFD_SWITCH_ACQUIRE_CTX_INFO32 {
    VOID * POINTER_32   SocketHandle;
    AFD_SWITCH_CONTEXT * POINTER_32 SwitchContext;
    VOID * POINTER_32   SocketCtxBuf;
    ULONG               SocketCtxBufSize;
} AFD_SWITCH_ACQUIRE_CTX_INFO32, *PAFD_SWITCH_ACQUIRE_CTX_INFO32;
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SocketCtxBuf);
AFD_CHECK32on64(AFD_SWITCH_ACQUIRE_CTX_INFO,SocketCtxBufSize);

typedef UNALIGNED struct _AFD_SWITCH_TRANSFER_CTX_INFO32 {
    VOID * POINTER_32   SocketHandle;
    AFD_SWITCH_CONTEXT * POINTER_32 SwitchContext;
    VOID * POINTER_32   RequestContext;
    VOID * POINTER_32   SocketCtxBuf;
    ULONG               SocketCtxBufSize;
    WSABUF * POINTER_32 RcvBufferArray;
    ULONG               RcvBufferCount;
    NTSTATUS            Status;
} AFD_SWITCH_TRANSFER_CTX_INFO32, *PAFD_SWITCH_TRANSFER_CTX_INFO32;
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SocketHandle);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SwitchContext);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,RequestContext);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SocketCtxBuf);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,SocketCtxBufSize);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,RcvBufferArray);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,RcvBufferCount);
AFD_CHECK32on64(AFD_SWITCH_TRANSFER_CTX_INFO,Status);

typedef UNALIGNED struct _AFD_PARTIAL_DISCONNECT_INFO32 {
    ULONG DisconnectMode;
    LARGE_INTEGER Timeout;
} AFD_PARTIAL_DISCONNECT_INFO32, *PAFD_PARTIAL_DISCONNECT_INFO32;
AFD_CHECK32on64(AFD_PARTIAL_DISCONNECT_INFO,DisconnectMode);
AFD_CHECK32on64(AFD_PARTIAL_DISCONNECT_INFO,Timeout);

typedef UNALIGNED struct _AFD_SUPER_DISCONNECT_INFO32 {
    ULONG  Flags;
} AFD_SUPER_DISCONNECT_INFO32, *PAFD_SUPER_DISCONNECT_INFO32;
AFD_CHECK32on64(AFD_SUPER_DISCONNECT_INFO,Flags);

typedef UNALIGNED struct _AFD_INFORMATION32 {
    ULONG InformationType;
    union {
        BOOLEAN Boolean;
        ULONG Ulong;
        LARGE_INTEGER LargeInteger;
    } Information;
} AFD_INFORMATION32, *PAFD_INFORMATION32;
AFD_CHECK32on64(AFD_INFORMATION,InformationType);
AFD_CHECK32on64(AFD_INFORMATION,Information);
AFD_CHECK32on64(AFD_INFORMATION,Information.Boolean);
AFD_CHECK32on64(AFD_INFORMATION,Information.Ulong);
AFD_CHECK32on64(AFD_INFORMATION,Information.LargeInteger);


typedef UNALIGNED struct _TDI_CMSGHDR32 {
    ULONG       cmsg_len;
    LONG        cmsg_level;
    LONG        cmsg_type;
    /* followed by UCHAR cmsg_data[] */
} TDI_CMSGHDR32, *PTDI_CMSGHDR32;
AFD_CHECK32on64(TDI_CMSGHDR,cmsg_len);
AFD_CHECK32on64(TDI_CMSGHDR,cmsg_level);
AFD_CHECK32on64(TDI_CMSGHDR,cmsg_type);

#ifdef _WIN64
#define TDI_CMSGHDR_ALIGN32(length)                         \
            ( ((length) + TYPE_ALIGNMENT(TDI_CMSGHDR32)-1) &\
                (~(TYPE_ALIGNMENT(TDI_CMSGHDR32)-1)) )      \

#define TDI_CMSGDATA_ALIGN32(length)                        \
            ( ((length) + AFD_MAX_NATURAL_ALIGNMENT32-1) &  \
                (~(AFD_MAX_NATURAL_ALIGNMENT32-1)) )
#endif //_WIN64

#endif // ndef _AFDSTR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\afdp.h ===
/*+r

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afd.h

Abstract:

    This is the local header file for AFD.  It includes all other
    necessary header files for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#ifndef _AFDP_
#define _AFDP_


#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>


#ifndef _AFDKDP_H_
extern POBJECT_TYPE *ExEventObjectType;
#endif  // _AFDKDP_H_


#if DBG

#ifndef AFD_PERF_DBG
#define AFD_PERF_DBG   1
#endif

#ifndef AFD_KEEP_STATS
#define AFD_KEEP_STATS 1
#endif

#else

#ifndef AFD_PERF_DBG
#define AFD_PERF_DBG   0
#endif

#ifndef AFD_KEEP_STATS
#define AFD_KEEP_STATS 0
#endif

#endif  // DBG

//
// Hack-O-Rama. TDI has a fundamental flaw in that it is often impossible
// to determine exactly when a TDI protocol is "done" with a connection
// object. The biggest problem here is that AFD may get a suprious TDI
// indication *after* an abort request has completed. As a temporary work-
// around, whenever an abort request completes, we'll start a timer. AFD
// will defer further processing on the connection until that timer fires.
//
// If the following symbol is defined, then our timer hack is enabled.
// Afd now uses InterlockedCompareExchange to protect itself
//

// #define ENABLE_ABORT_TIMER_HACK 0

//
// The following constant defines the relative time interval (in seconds)
// for the "post abort request complete" timer.
//

// #define AFD_ABORT_TIMER_TIMEOUT_VALUE 5 // seconds

//
// Goodies stolen from other header files.
//

#ifndef FAR
#define FAR
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

typedef unsigned short u_short;

#ifndef SG_UNCONSTRAINED_GROUP
#define SG_UNCONSTRAINED_GROUP   0x01
#endif

#ifndef SG_CONSTRAINED_GROUP
#define SG_CONSTRAINED_GROUP     0x02
#endif


#include <afd.h>
#include "afdstr.h"
#include "afddata.h"
#include "afdprocs.h"

#define AFD_EA_POOL_TAG                 ( (ULONG)'AdfA' | PROTECTED_POOL )
#define AFD_DATA_BUFFER_POOL_TAG        ( (ULONG)'BdfA' | PROTECTED_POOL )
#define AFD_CONNECTION_POOL_TAG         ( (ULONG)'CdfA' | PROTECTED_POOL )
#define AFD_CONNECT_DATA_POOL_TAG       ( (ULONG)'cdfA' | PROTECTED_POOL )
#define AFD_DEBUG_POOL_TAG              ( (ULONG)'DdfA' | PROTECTED_POOL )
#define AFD_ENDPOINT_POOL_TAG           ( (ULONG)'EdfA' | PROTECTED_POOL )
#define AFD_TRANSMIT_INFO_POOL_TAG      ( (ULONG)'FdfA' | PROTECTED_POOL )
#define AFD_GROUP_POOL_TAG              ( (ULONG)'GdfA' | PROTECTED_POOL )
#define AFD_ADDRESS_CHANGE_POOL_TAG     ( (ULONG)'hdfA' | PROTECTED_POOL )
#define AFD_TDI_POOL_TAG                ( (ULONG)'IdfA' | PROTECTED_POOL )
#define AFD_LOCAL_ADDRESS_POOL_TAG      ( (ULONG)'LdfA' | PROTECTED_POOL )
#define AFD_POLL_POOL_TAG               ( (ULONG)'PdfA' | PROTECTED_POOL )
#define AFD_TRANSPORT_IRP_POOL_TAG      ( (ULONG)'pdfA' | PROTECTED_POOL )
#define AFD_ROUTING_QUERY_POOL_TAG      ( (ULONG)'qdfA' | PROTECTED_POOL )
#define AFD_REMOTE_ADDRESS_POOL_TAG     ( (ULONG)'RdfA' | PROTECTED_POOL )
#define AFD_RESOURCE_POOL_TAG           ( (ULONG)'rdfA' | PROTECTED_POOL )
// Can't be protected - freed by kernel.
#define AFD_SECURITY_POOL_TAG           ( (ULONG)'SdfA' )
#define AFD_TRANSPORT_ADDRESS_POOL_TAG  ( (ULONG)'tdfA' | PROTECTED_POOL )
#define AFD_TRANSPORT_INFO_POOL_TAG     ( (ULONG)'TdfA' | PROTECTED_POOL )
// Can't be protected - freed by kernel.
#define AFD_TEMPORARY_POOL_TAG          ( (ULONG)' dfA' )
#define AFD_CONTEXT_POOL_TAG            ( (ULONG)'XdfA' | PROTECTED_POOL )
#define AFD_SAN_CONTEXT_POOL_TAG        ( (ULONG)'xdfA' | PROTECTED_POOL )

#define MyFreePoolWithTag(a,t) ExFreePoolWithTag(a,t)


#if DBG
//
// N.B. This structure MUST be quadword aligned!
//

typedef struct DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) _AFD_POOL_HEADER {
    SIZE_T Size;
    PCHAR FileName;
    ULONG LineNumber;
    ULONG InUse;
} AFD_POOL_HEADER, *PAFD_POOL_HEADER;
#define AFD_POOL_OVERHEAD  (sizeof(AFD_POOL_HEADER))
#else
#define AFD_POOL_OVERHEAD   0
#endif


#if DBG

extern ULONG AfdDebug;
extern ULONG AfdLocksAcquired;

#undef IF_DEBUG
#define IF_DEBUG(a) if ( (AFD_DEBUG_ ## a & AfdDebug) != 0 )

#define AFD_DEBUG_OPEN_CLOSE        0x00000001
#define AFD_DEBUG_ENDPOINT          0x00000002
#define AFD_DEBUG_CONNECTION        0x00000004
#define AFD_DEBUG_EVENT_SELECT      0x00000008

#define AFD_DEBUG_BIND              0x00000010
#define AFD_DEBUG_CONNECT           0x00000020
#define AFD_DEBUG_LISTEN            0x00000040
#define AFD_DEBUG_ACCEPT            0x00000080

#define AFD_DEBUG_SEND              0x00000100
#define AFD_DEBUG_QUOTA             0x00000200
#define AFD_DEBUG_RECEIVE           0x00000400
#define AFD_DEBUG_11                0x00000800

#define AFD_DEBUG_POLL              0x00001000
#define AFD_DEBUG_FAST_IO           0x00002000
#define AFD_DEBUG_ROUTING_QUERY     0x00010000
#define AFD_DEBUG_ADDRESS_LIST      0x00020000
#define AFD_DEBUG_TRANSMIT          0x00100000

#define AFD_DEBUG_SAN_SWITCH        0x00200000

#define DEBUG

#define AFD_ALLOCATE_POOL(a,b,t) AfdAllocatePool( a,b,t,__FILE__,__LINE__,FALSE,LowPoolPriority )
#define AFD_ALLOCATE_POOL_WITH_QUOTA(a,b,t) AfdAllocatePool( (a)|POOL_RAISE_IF_ALLOCATION_FAILURE,b,t,__FILE__,__LINE__,TRUE,LowPoolPriority )
#define AFD_ALLOCATE_POOL_PRIORITY(a,b,t,p) AfdAllocatePool( a,b,t,__FILE__,__LINE__,FALSE,p )

PVOID
AfdAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN BOOLEAN WithQuota,
    IN EX_POOL_PRIORITY Priority
    );

#define AFD_FREE_POOL(a,t) AfdFreePool(a,t)
VOID
AfdFreePool (
    IN PVOID Pointer,
    IN ULONG Tag
    );

#define AfdRecordOutstandingIrp(a,b,c)  \
          AfdRecordOutstandingIrpDebug(a,b,c,__FILE__,__LINE__)

BOOLEAN
AfdRecordOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

#define AfdIoCallDriver(a,b,c)                              \
    (AfdRecordOutstandingIrp(a,b,c)                         \
        ? IoCallDriver (b,c)                                \
        : STATUS_INSUFFICIENT_RESOURCES                     \
    )

#define AfdCompleteOutstandingIrp(a,b) \
    AfdCompleteOutstandingIrpDebug(a,b)

VOID
AfdCompleteOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PIRP Irp
    );

#ifdef AFDDBG_QUOTA
VOID
AfdRecordQuotaHistory(
    IN PEPROCESS Process,
    IN LONG Bytes,
    IN PSZ Type,
    IN PVOID Block
    );
#else
#define AfdRecordQuotaHistory(a,b,c,d)
#endif

//
// Queued spinlock wrappers - perform basic validation
//
#define AfdAcquireSpinLock(a,b) \
            ASSERT(AfdLoaded); (b)->SpinLock=(a); KeAcquireInStackQueuedSpinLock(&(a)->ActualSpinLock,&((b)->LockHandle)); AfdLocksAcquired++

#define AfdReleaseSpinLock(a,b) \
            AfdLocksAcquired--; ASSERT ((b)->SpinLock==(a)); ASSERT( AfdLoaded ); KeReleaseInStackQueuedSpinLock(&((b)->LockHandle)); 

#define AfdAcquireSpinLockAtDpcLevel(a,b) \
            ASSERT( AfdLoaded ); (b)->SpinLock=(a); KeAcquireInStackQueuedSpinLockAtDpcLevel(&(a)->ActualSpinLock,&((b)->LockHandle)); AfdLocksAcquired++

#define AfdReleaseSpinLockFromDpcLevel(a,b) \
            AfdLocksAcquired--; ASSERT ((b)->SpinLock==(a)); ASSERT( AfdLoaded );  KeReleaseInStackQueuedSpinLockFromDpcLevel(&((b)->LockHandle))

#define AfdInitializeSpinLock(a) \
            KeInitializeSpinLock(&(a)->ActualSpinLock)

//
// Define our own assert so that we can actually catch assertion failures
// when running a checked AFD on a free kernel.
//

VOID
AfdAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        AfdAssert( #exp, __FILE__, __LINE__, NULL )

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        AfdAssert( #exp, __FILE__, __LINE__, msg )

#define AFD_EXCEPTION_FILTER(_s)                                            \
            AfdExceptionFilter(                                             \
                (LPSTR)__FILE__,                                            \
                (LONG)__LINE__,                                             \
                GetExceptionInformation(),                                  \
                _s                                                          \
                )

#else   // !DBG

#undef IF_DEBUG
#define IF_DEBUG(a) if (FALSE)
#define DEBUG if ( FALSE )

#define AFD_ALLOCATE_POOL(a,b,t) ExAllocatePoolWithTagPriority(a,b,t,LowPoolPriority)
#define AFD_ALLOCATE_POOL_WITH_QUOTA(a,b,t) ExAllocatePoolWithQuotaTag((a)|POOL_RAISE_IF_ALLOCATION_FAILURE,b,t)
#define AFD_ALLOCATE_POOL_PRIORITY(a,b,t,p) ExAllocatePoolWithTagPriority(a,b,t,p)
#define AFD_FREE_POOL(a,t) MyFreePoolWithTag(a,t)

#define AfdRecordOutstandingIrp(a,b,c) \
    (InterlockedIncrement(&((a)->OutstandingIrpCount)), TRUE)
#define AfdIoCallDriver(a,b,c) \
    (AfdRecordOutstandingIrp(a,b,c), IoCallDriver(b,c))
#define AfdCompleteOutstandingIrp(a,b) \
    InterlockedDecrement(&((a)->OutstandingIrpCount))

NTSTATUS
AfdIoCallDriverFree (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdCompleteOutstandingIrpFree (
    IN PAFD_ENDPOINT Endpoint,
    IN PIRP Irp
    );

#define AfdRecordQuotaHistory(a,b,c,d)

#define AfdAcquireSpinLock(a,b) KeAcquireInStackQueuedSpinLock(&(a)->ActualSpinLock,(b))
#define AfdReleaseSpinLock(a,b) KeReleaseInStackQueuedSpinLock((b))
#define AfdAcquireSpinLockAtDpcLevel(a,b) KeAcquireInStackQueuedSpinLockAtDpcLevel(&(a)->ActualSpinLock,(b))
#define AfdReleaseSpinLockFromDpcLevel(a,b) KeReleaseInStackQueuedSpinLockFromDpcLevel((b))
#define AfdInitializeSpinLock(a) \
            KeInitializeSpinLock(&(a)->ActualSpinLock)

#define AFD_EXCEPTION_FILTER(_s)                                            \
            AfdExceptionFilter(                                             \
                GetExceptionInformation(),                                  \
                _s                                                          \
                )
#endif // def DBG

#if DBG || REFERENCE_DEBUG
VOID
AfdInitializeDebugData(
    VOID
    );

VOID
AfdFreeDebugData (
    VOID
    );
#endif


//
// Make some of the receive code a bit prettier.
//

#define TDI_RECEIVE_EITHER ( TDI_RECEIVE_NORMAL | TDI_RECEIVE_EXPEDITED )

#endif // ndef _AFDP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\accept.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    accept.c

Abstract:

    This module contains the handling code for IOCTL_AFD_ACCEPT.
    as well as IOCTL_AFD_SUPER_ACCEPT

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime) 1999 - No spinlock performance path in super accept,
                                general code restructuring.

--*/

#include "afdp.h"

VOID
AfdDoListenBacklogReplenish (
    IN PVOID Context
    );

NTSTATUS
AfdReplenishListenBacklog (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdReportConnectionAllocationFailure (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    );


NTSTATUS
AfdContinueSuperAccept (
    IN PIRP         Irp,
    PAFD_CONNECTION Connection
    );

NTSTATUS
AfdRestartSuperAcceptGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartSuperAcceptReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDelayedAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdSuperAcceptApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdSuperAcceptApcRundownRoutine (
    IN struct _KAPC *Apc
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdAccept )
#pragma alloc_text( PAGEAFD, AfdSuperAccept )
#pragma alloc_text( PAGEAFD, AfdDeferAccept )
#pragma alloc_text( PAGE, AfdDoListenBacklogReplenish )
#pragma alloc_text( PAGEAFD, AfdSetupAcceptEndpoint )
#pragma alloc_text( PAGE, AfdReplenishListenBacklog )
#pragma alloc_text( PAGEAFD, AfdReportConnectionAllocationFailure )
#pragma alloc_text( PAGEAFD, AfdInitiateListenBacklogReplenish )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAccept )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAcceptListen )
#pragma alloc_text( PAGEAFD, AfdContinueSuperAccept )
#pragma alloc_text( PAGEAFD, AfdServiceSuperAccept )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAcceptGetAddress )
#pragma alloc_text( PAGEAFD, AfdRestartSuperAcceptReceive )
#pragma alloc_text( PAGE, AfdSuperAcceptApcKernelRoutine )
#pragma alloc_text( PAGE, AfdSuperAcceptApcRundownRoutine )
#pragma alloc_text( PAGEAFD, AfdCancelSuperAccept )
#pragma alloc_text( PAGEAFD, AfdCleanupSuperAccept )
#pragma alloc_text( PAGEAFD, AfdRestartDelayedAccept)
#pragma alloc_text( PAGEAFD, AfdRestartDelayedSuperAccept)
#endif


//
// Macros to make the super accept restart code more maintainable.
//

#define AfdRestartSuperAcceptInfo   DeviceIoControl

// Used while IRP is in AFD queue (otherwise AfdAcceptFileObject
// is stored as completion routine context).
#define AfdAcceptFileObject         Type3InputBuffer
// Used when IRP is passed to the transport (otherwise MdlAddress
// is stored in the IRP itself).
#define AfdMdlAddress               Type3InputBuffer

#define AfdReceiveDataLength        OutputBufferLength
#define AfdRemoteAddressLength      InputBufferLength
#define AfdLocalAddressLength       IoControlCode


//
// Similar macros for delayed accept restart code.
//
#define AfdRestartDelayedAcceptInfo DeviceIoControl
#define AfdSystemBuffer             Type3InputBuffer


NTSTATUS
FASTCALL
AfdAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Accepts an incoming connection.  The connection is identified by the
    sequence number returned in the wait for listen IRP, and then
    associated with the endpoint specified in this request.  When this
    request completes, the connection is fully established and ready for
    data transfer.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_SUCCESS if the request was completed successfully, or a
    failure status code if there was an error.

--*/

{
    NTSTATUS status;
    PAFD_ACCEPT_INFO acceptInfo;
    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;


    //
    // Set up local variables.
    //

    listenEndpoint = IrpSp->FileObject->FsContext;
    Irp->IoStatus.Information = 0;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_ACCEPT_INFO      newSystemBuffer;
        PAFD_ACCEPT_INFO32    oldSystemBuffer = Irp->AssociatedIrp.SystemBuffer;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(AFD_ACCEPT_INFO32) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        try {
            newSystemBuffer = ExAllocatePoolWithQuota (NonPagedPool, sizeof (AFD_ACCEPT_INFO));
                                                
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            goto complete;
        }

        newSystemBuffer->AcceptHandle = oldSystemBuffer->AcceptHandle;
        newSystemBuffer->Sequence = oldSystemBuffer->Sequence;

        ExFreePool (Irp->AssociatedIrp.SystemBuffer);
        Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof (AFD_ACCEPT_INFO);
    }
#endif // _WIN64

    acceptInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that this request is valid.
    //

    if ( !listenEndpoint->Listening ||
             IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(AFD_ACCEPT_INFO) ||
             Irp->MdlAddress!=NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    ASSERT ((listenEndpoint->Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening);

    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!acceptInfo->SanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on accept\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }

    //
    // Add another free connection to replace the one we're accepting.
    // Also, add extra to account for past failures in calls to
    // AfdAddFreeConnection().
    //

    InterlockedIncrement(
        &listenEndpoint->Common.VcListening.FailedConnectionAdds
        );

    AfdReplenishListenBacklog( listenEndpoint );

    //
    // Obtain a pointer to the endpoint on which we're going to
    // accept the connection.
    //

    status = ObReferenceObjectByHandle(
                 acceptInfo->AcceptHandle,
                 (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
												// DesiredAccess
                 *IoFileObjectType,
                 Irp->RequestorMode,
                 (PVOID *)&acceptFileObject,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete;
    }


    //
    // We may have a file object that is not an AFD endpoint.  Make sure
    // that this is an actual AFD endpoint.
    //

    if ( acceptFileObject->DeviceObject!=AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete_deref;
    }

    acceptEndpoint = acceptFileObject->FsContext;
    if (acceptEndpoint->TransportInfo!=listenEndpoint->TransportInfo) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_deref;
    }

    ASSERT( InterlockedIncrement( &acceptEndpoint->ObReferenceBias ) > 0 );

    IF_DEBUG(ACCEPT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAccept: file object %p, accept endpoint %p, listen endpoint %p\n",
                      acceptFileObject, acceptEndpoint, listenEndpoint ));
    }

    if (AFD_START_STATE_CHANGE (acceptEndpoint, AfdEndpointStateConnected)) {
        if (acceptEndpoint->State!=AfdEndpointStateOpen) {
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            AFD_LOCK_QUEUE_HANDLE   lockHandle;
            AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
            connection = AfdGetReturnedConnection (listenEndpoint,
                                                    acceptInfo->Sequence);
            if (connection==NULL) {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                status = STATUS_INVALID_PARAMETER;
            }
            else if (connection->SanConnection) {
                Irp->Tail.Overlay.DriverContext[3] = acceptInfo->AcceptHandle;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject = acceptFileObject;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength = 0;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength = 0;
                IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength = 0;
                status = AfdSanAcceptCore (Irp, acceptFileObject, connection, &lockHandle);
                if (status==STATUS_PENDING) {
                    return STATUS_PENDING;
                }
            }
            else {
                status = AfdAcceptCore (Irp, acceptEndpoint, connection);
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);

                AFD_RETURN_REMOTE_ADDRESS (
                        connection->RemoteAddress,
                        connection->RemoteAddressLength
                        );
                connection->RemoteAddress = NULL;

                if (status==STATUS_SUCCESS) {
                    NOTHING;
                }
                else if (status==STATUS_PENDING) {

                    //
                    // Remember that a TDI accept has started on this endpoint.
                    //

                    InterlockedIncrement(
                        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
                        );

                    IrpSp->Parameters.AfdRestartDelayedAcceptInfo.AfdSystemBuffer = 
                            Irp->AssociatedIrp.SystemBuffer;
                    Irp->AssociatedIrp.SystemBuffer = NULL;

                    ASSERT (Irp->MdlAddress==NULL);

                    IoSetCompletionRoutine(
                            Irp,
                            AfdRestartDelayedAccept,
                            acceptFileObject,
                            TRUE,
                            TRUE,
                            TRUE
                            );

                    AfdIoCallDriver (
                            acceptEndpoint,
                            acceptEndpoint->Common.VcConnecting.Connection->DeviceObject,
                            Irp
                            );

                    return STATUS_PENDING;
                }
                else {
                    AfdAbortConnection (connection);
                    ASSERT (status==STATUS_CANCELLED);
                }
            }
        }
        AFD_END_STATE_CHANGE (acceptEndpoint);
    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

    ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

complete_deref:
    ObDereferenceObject( acceptFileObject );

complete:

    Irp->IoStatus.Status = status;
    ASSERT( Irp->CancelRoutine == NULL );

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdAccept



NTSTATUS
AfdAcceptCore (
    IN PIRP AcceptIrp,
    IN PAFD_ENDPOINT AcceptEndpoint,
    IN PAFD_CONNECTION Connection
    )

/*++

Routine Description:

    Performs the key functions of associating a connection accepted
    on a listening endpoint with a new endpoint.

Arguments:

    AcceptIrp - Irp used for accept operation

    AcceptEndpoint - the new endpoint with which to associate the
        connectuion.

    Connection -  the connection being accepted.

Return Value:

    STATUS_SUCCESS if the operation was completed successfully,
    STATUS_PENDING if IRP was passed further to the transport
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT   listenEndpoint;
    NTSTATUS        status;
    PIO_STACK_LOCATION  irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    irpSp = IoGetCurrentIrpStackLocation (AcceptIrp);
    listenEndpoint = irpSp->FileObject->FsContext;

    //
    // Reenable the accept event bit, and if there are additional
    // unaccepted connections on the endpoint, post another event.
    //


    listenEndpoint->EventsActive &= ~AFD_POLL_ACCEPT;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdAcceptCore: Endp %08lX, Active %08lX\n",
            listenEndpoint,
            listenEndpoint->EventsActive
            ));
    }

    if( !IsListEmpty( &listenEndpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {

        AfdIndicateEventSelectEvent(
            listenEndpoint,
            AFD_POLL_ACCEPT,
            STATUS_SUCCESS
            );

    }

    //
    // Do not release the listening endpoint spinlock here.
    // We are going to be chaning connection object which assumes
    // protection from listening endpoint spinlock until it is associated
    // with accept endpoint (this plugs nasty racing conditions when
    // receive is indicated rigth before connection object is updated, so
    // it takes listening endpoint spinlock, and rigth before it queues
    // the buffer to the connection object, it gets associated with accept
    // endpoint and AcceptEx'es receive does not notice the buffer because
    // it takes accept endpoint spinlock)
    //
    // AfdReleaseSpinLock( &ListenEndpoint->SpinLock, &lockHandle );

    //
    // Check the state of the accepting endpoint under the guard
    // of the endpoint's spinlock.
    //

    AfdAcquireSpinLockAtDpcLevel( &AcceptEndpoint->SpinLock, &lockHandle);
    status = AfdSetupAcceptEndpoint (listenEndpoint, AcceptEndpoint, Connection);
    if (status==STATUS_SUCCESS) {


        if (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint)) {
            PTDI_CONNECTION_INFORMATION requestConnectionInformation;

            if( Connection->ConnectDataBuffers != NULL ) {

                //
                // We allocated extra space at the end of the connect data
                // buffers structure.  We'll use this for the
                // TDI_CONNECTION_INFORMATION structure that holds response
                // connect data and options.  Not pretty, but the fastest
                // and easiest way to accomplish this.
                //

                requestConnectionInformation =
                    &Connection->ConnectDataBuffers->RequestConnectionInfo;

                RtlZeroMemory(
                    requestConnectionInformation,
                    sizeof(*requestConnectionInformation)
                    );

                requestConnectionInformation->UserData =
                    Connection->ConnectDataBuffers->SendConnectData.Buffer;
                requestConnectionInformation->UserDataLength =
                    Connection->ConnectDataBuffers->SendConnectData.BufferLength;
                requestConnectionInformation->Options =
                    Connection->ConnectDataBuffers->SendConnectOptions.Buffer;
                requestConnectionInformation->OptionsLength =
                    Connection->ConnectDataBuffers->SendConnectOptions.BufferLength;

            } else {

                requestConnectionInformation = NULL;

            }

            TdiBuildAccept(
                AcceptIrp,
                Connection->DeviceObject,
                Connection->FileObject,
                NULL,
                NULL,
                requestConnectionInformation,
                NULL
                );

            status = STATUS_PENDING;
        }
        else {
            //
            // Set the endpoint to the connected state.
            //

            AcceptEndpoint->State = AfdEndpointStateConnected;
            Connection->State = AfdConnectionStateConnected;

            //
            // Set events active field base on data accumulated on the connection.
            //

            if( IS_DATA_ON_CONNECTION( Connection ) ||
                ( AcceptEndpoint->InLine &&
                  IS_EXPEDITED_DATA_ON_CONNECTION( Connection ) ) ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_RECEIVE;

            }

            if( !AcceptEndpoint->InLine &&
                IS_EXPEDITED_DATA_ON_CONNECTION( Connection ) ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_RECEIVE_EXPEDITED;

            }

            AcceptEndpoint->EventsActive |= AFD_POLL_SEND;

            if( Connection->DisconnectIndicated ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_DISCONNECT;
            }


            if( Connection->AbortIndicated ) {

                AcceptEndpoint->EventsActive |= AFD_POLL_ABORT;

            }


            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAcceptCore: Endp %08lX, Active %08lX\n",
                    AcceptEndpoint,
                    AcceptEndpoint->EventsActive
                    ));
            }

            status = STATUS_SUCCESS;
        }
    }

    AfdReleaseSpinLockFromDpcLevel( &AcceptEndpoint->SpinLock, &lockHandle);
    return status;
} // AfdAcceptCore


VOID
AfdInitiateListenBacklogReplenish (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Queues a work item to begin replenishing the listen backlog
    on a listening endpoint.

Arguments:

    Endpoint - the listening endpoint on which to replenish the
        backlog.

Return Value:

    None.

--*/

{
	AFD_LOCK_QUEUE_HANDLE	lockHandle;

	//
	// Check if backlog replenish is active already.
	//
	AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
	if (!Endpoint->Common.VcListening.BacklogReplenishActive) {

		Endpoint->Common.VcListening.BacklogReplenishActive = TRUE;
		//
		// Reference the endpoint so that it won't go away until we're
		// done with it.
		//

		REFERENCE_ENDPOINT( Endpoint );


		AfdQueueWorkItem(
			AfdDoListenBacklogReplenish,
			&Endpoint->WorkItem
			);
	}

	AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
	return;
} // AfdInitiateListenBacklogReplenish


VOID
AfdDoListenBacklogReplenish (
    IN PVOID Context
    )

/*++

Routine Description:

    The worker routine for replenishing the listen backlog on a
    listening endpoint.  This routine only runs in the context of
    an executive worker thread.

Arguments:

    Context - Points to an AFD_WORK_ITEM structure. The Context field
        of this structure points to the endpoint on which to replenish
        the listen backlog.

Return Value:

     None.

--*/

{
    PAFD_ENDPOINT endpoint;

    PAGED_CODE( );

    endpoint = CONTAINING_RECORD(
                   Context,
                   AFD_ENDPOINT,
                   WorkItem
                   );

    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

	ASSERT (endpoint->Common.VcListening.BacklogReplenishActive == TRUE);
	//
	// It is ok to do this without spinlock protection
	// because only one thread can do this at a time
	// inside of the worker routine.
	//
	endpoint->Common.VcListening.BacklogReplenishActive = FALSE;

    //
    // If the endpoint's state changed, don't replenish the backlog.
    //

    if ( endpoint->Listening ) {
        NTSTATUS    status;
		//
		// Fill up the free connection backlog.
		//

		status = AfdReplenishListenBacklog( endpoint );
        if (!NT_SUCCESS (status)) {
            //
            // If we failed, try to notify application
            //
            AfdReportConnectionAllocationFailure (endpoint, status);
        }
    }


    //
    // Clean up and return.
    //

    DEREFERENCE_ENDPOINT( endpoint );

    return;

} // AfdDoListenBacklogReplenish


NTSTATUS
AfdReplenishListenBacklog (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Does the actual work of filling up the listen backlog on a listening
    endpoint.

Arguments:

    Endpoint - the listening endpoint on which to replenish the
        listen backlog.

Return Value:

    STATUS_SUCCESS - if new connection was allocated or we already
                        had enough
    status of conneciton allocation failure otherwise
--*/

{
    NTSTATUS status;
    LONG result;

    PAGED_CODE( );

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );


    //
    // Decrement the count of failed connection additions.
    //

    result = InterlockedDecrement(
                 &Endpoint->Common.VcListening.FailedConnectionAdds
                 );

    //
    // Continue opening new free conections until we've hit the
    // backlog or a connection open fails.
    //
    // If the result of the decrement is negative, then we are either
    // all set on the connection count or else have available extra
    // connection objects on the listening endpoint.  These connections
    // have been reused from prior connections which have now
    // terminated.
    //

    while ( result >= 0 ) {

        status = AfdAddFreeConnection( Endpoint );

        if ( !NT_SUCCESS(status) ) {

            InterlockedIncrement(
                &Endpoint->Common.VcListening.FailedConnectionAdds
                );

            IF_DEBUG(LISTEN) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdReplenishListenBacklog: AfdAddFreeConnection failed: %X, fail count = %ld\n", status,
                            Endpoint->Common.VcListening.FailedConnectionAdds ));
            }

            //
            // Return connection allocation failure to the application
            // if it cares to know (posted accept request).
            //

            return status;
        }

        result = InterlockedDecrement(
                     &Endpoint->Common.VcListening.FailedConnectionAdds
                     );
    }

    //
    // Correct the counter to reflect the number of connections
    // we have available.  Then just return from here.
    //

    InterlockedIncrement(
        &Endpoint->Common.VcListening.FailedConnectionAdds
        );

    return STATUS_SUCCESS;

} // AfdReplenishListenBacklog



VOID
AfdReportConnectionAllocationFailure (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    )
/*++

Routine Description:

    Reports connection allocation failure to the application by 
    failing then first wait for listen irp in the queue (if application
    has AcceptEx or blockin accept outstanding, it will get this notification).

Arguments:

    Endpoint - the listening endpoint on which to report an error
    Status - status code to report

Return Value:

    None
--*/
{
    AFD_LOCK_QUEUE_HANDLE       lockHandle;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if ((Endpoint->Common.VcListening.FailedConnectionAdds>0) &&
            IsListEmpty (&Endpoint->Common.VcListening.UnacceptedConnectionListHead) &&
            !IsListEmpty (&Endpoint->Common.VcListening.ListeningIrpListHead)) {
        PIRP                irp;
        PIO_STACK_LOCATION  irpSp;

        irp = CONTAINING_RECORD (Endpoint->Common.VcListening.ListeningIrpListHead.Flink,
                                        IRP,
                                        Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation (irp);
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        irp->Tail.Overlay.ListEntry.Flink = NULL;

        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        if (IoSetCancelRoutine (irp, NULL)==NULL) {
            KIRQL   cancelIrql;
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
    
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( irp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
        }
        if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
            AfdCleanupSuperAccept (irp, Status);
        }
        else {
            irp->IoStatus.Status = Status;
            irp->IoStatus.Information = 0;
        }
        IoCompleteRequest (irp, AfdPriorityBoost);
    }
    else {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    }
}




NTSTATUS
FASTCALL
AfdSuperAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Initial entrypoint for handling super accept IRPs.  A super accept
    combines several operations for high-performance connection
    acceptance.  The combined operations are waiting for an incoming
    connection, accepting it, retrieving the local and remote socket
    addresses, and receiving the first chunk of data on the connection.

    This routine verifies parameters, initializes data structures to be
    used for the request, and initiates the I/O.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_PENDING if the request was initiated successfully, or a
    failure status code if there was an error.

--*/

{
    PAFD_ENDPOINT listenEndpoint;
    PAFD_ENDPOINT acceptEndpoint;
    PFILE_OBJECT acceptFileObject;
    HANDLE  acceptHandle;
    ULONG receiveDataLength, localAddressLength, remoteAddressLength;
    BOOLEAN sanActive;
#ifndef i386
    BOOLEAN fixAddressAlignment;
#endif
    NTSTATUS status;
	ULONG totalLength;
    PSINGLE_LIST_ENTRY listEntry;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Set up local variables.
    //

    listenEndpoint = IrpSp->FileObject->FsContext;
    acceptFileObject = NULL;
    acceptEndpoint = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SUPER_ACCEPT_INFO32    superAcceptInfo32;
        superAcceptInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(AFD_SUPER_ACCEPT_INFO32) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (superAcceptInfo32,
                                    sizeof (*superAcceptInfo32),
                                    PROBE_ALIGNMENT32 (AFD_SUPER_ACCEPT_INFO32));
            }

            acceptHandle = superAcceptInfo32->AcceptHandle;
            receiveDataLength = superAcceptInfo32->ReceiveDataLength;
            localAddressLength = superAcceptInfo32->LocalAddressLength;
            remoteAddressLength = superAcceptInfo32->RemoteAddressLength;
            sanActive = superAcceptInfo32->SanActive;
            fixAddressAlignment = superAcceptInfo32->FixAddressAlignment;
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }
    }
    else 
#endif // _WIN64
    {
        PAFD_SUPER_ACCEPT_INFO    superAcceptInfo;
        superAcceptInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (superAcceptInfo,
                                    sizeof (*superAcceptInfo),
                                    PROBE_ALIGNMENT (AFD_SUPER_ACCEPT_INFO));
            }
            acceptHandle = superAcceptInfo->AcceptHandle;
            receiveDataLength = superAcceptInfo->ReceiveDataLength;
            localAddressLength = superAcceptInfo->LocalAddressLength;
            remoteAddressLength = superAcceptInfo->RemoteAddressLength;
            sanActive = superAcceptInfo->SanActive;
#ifndef i386
            fixAddressAlignment = superAcceptInfo->FixAddressAlignment;
#endif
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }
    }


    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!sanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on AcceptEx\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto complete;
    }
    //
    // Validate the input information.  The input buffer must be large
    // enough to hold all the input information, plus some extra to use
    // here to hold the local address.  The output buffer must be
    // non-NULL and large enough to hold the specified information.
    //
    //

    if ( !listenEndpoint->Listening

                ||

            remoteAddressLength < (ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS, 
                                        Address[0].Address)

                ||

				//
				// Do the check in such a manner that integer overflow
				// (which is not enabled by the compiler) does not
				// affect the validity of the result.
				//
		    (totalLength=IrpSp->Parameters.DeviceIoControl.OutputBufferLength)<
			        receiveDataLength
			 
			    ||

		    (totalLength-=receiveDataLength) < localAddressLength

			    ||

		    (totalLength-=localAddressLength) < remoteAddressLength

												) {

        if( !listenEndpoint->Listening ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdSuperAccept: non-listening endpoint @ %08lX\n",
                listenEndpoint
                ));
            status = STATUS_INVALID_PARAMETER;
        }
        else {
            status = STATUS_BUFFER_TOO_SMALL;
        }

        goto complete;
    }

    try {
        if (IoAllocateMdl(Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            FALSE,      // Secondary buffer
                            TRUE,       // Charge quota
                            Irp
                            )==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }

        MmProbeAndLockPages (Irp->MdlAddress, Irp->RequestorMode, IoWriteAccess);
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        goto complete;
    }

    ASSERT ((listenEndpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening);
    //
    // Obtain a pointer to the endpoint on which we're going to
    // accept the connection.
    //

    status = ObReferenceObjectByHandle(
                 acceptHandle,
                 (IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
													// DesiredAccess
                 *IoFileObjectType,
                 Irp->RequestorMode,
                 &acceptFileObject,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete;
    }


    //
    // We may have a file object that is not an AFD endpoint.  Make sure
    // that this is an actual AFD endpoint.
    //

    if (acceptFileObject->DeviceObject!= AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }


    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT( InterlockedIncrement( &acceptEndpoint->ObReferenceBias ) > 0 );


    if (!AFD_START_STATE_CHANGE (acceptEndpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (acceptEndpoint->TransportInfo!=listenEndpoint->TransportInfo || 
            acceptEndpoint->State != AfdEndpointStateOpen ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }


#ifndef i386
    acceptEndpoint->Common.VcConnecting.FixAddressAlignment = fixAddressAlignment;
#endif
    Irp->Tail.Overlay.DriverContext[3] = acceptHandle;

    //
    // Save common IRP parameters in our stack location so
    // we can retreive them when necessary
    //

    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject = acceptFileObject;
    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength = receiveDataLength;
    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength = localAddressLength;
    IrpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength = remoteAddressLength;

    //
    // Add another free connection to replace the one we're accepting.
    // Also, add extra to account for past failures in calls to
    // AfdAddFreeConnection().
    //

    InterlockedIncrement(
        &listenEndpoint->Common.VcListening.FailedConnectionAdds
        );

    status = AfdReplenishListenBacklog( listenEndpoint );


    //
    // Save the IRP, so that accept enpoint cleanup can find it.
    // Note, that even if found, the cleanup won't touch the IRP
    // until cancel routine is set in it.
    //
    ASSERT (acceptEndpoint->Irp==NULL);
    acceptEndpoint->Irp = Irp;

    //
    // Get free connection from the list, if none is available,
    // or direct super accept is disabled, go through the regular
    // listen-accept path.
    //

    if (AfdDisableDirectSuperAccept ||
        IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
        ExQueryDepthSList (&listenEndpoint->Common.VcListening.PreacceptedConnectionsListHead)
                    > AFD_MAXIMUM_FREE_CONNECTIONS ||
        ((listEntry = InterlockedPopEntrySList (
                     &listenEndpoint->Common.VcListening.FreeConnectionListHead
                     ))==NULL)) {
    
        //
        // Setup super accept IRP to be put into the wait for
        // listen queue. Internal device control distinguishes this
        // from the regular wait for listen IRPs that come directly
        // from the application.
        //
        IrpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

        //
        // Mark this IRP as pending since we are going to return
        // STATUS_PENDING no matter what (sometimes the actual
        // status is hidden very deep inside the call stack and
        // it is impossible to propagate it all the way up).
        //
        IoMarkIrpPending (Irp);

        AfdWaitForListen (Irp, IrpSp);

        //
        // If connection allocation failed above, we need to report 
        // this to application.  We delay this call in case there is
        // already a preaccepted connection, so the allocation failure
        // is not important.
        //
        if (!NT_SUCCESS (status)) {
            AfdReportConnectionAllocationFailure (listenEndpoint, status);
        }

        return STATUS_PENDING;
    }

    //
    // Get connection object of the list entry
    //
    connection = CONTAINING_RECORD(
                     listEntry,
                     AFD_CONNECTION,
                     SListEntry
                     );


    //
    // Stuff special constant into the connection object accept IRP
    // pointer, so that cancel routine does not complete the IRP
    // while we are still looking at it, but in the same time we
    // can detect that the IRP was cancelled (cancel routine will
    // replace the -1 with NULL to indicate that it has been ran).
    // This technique avoids extra spinlock acquire/release and
    // associated IRQL raise/lower on an extremely performance-sensitive 
    // code path.
    //

    connection->AcceptIrp = (PIRP)-1;
    Irp->Tail.Overlay.DriverContext[0] = connection;

    //
    // We are going to pend this Irp, so mark it as pending
    // and set up the cancel routine. 
    //

    IoMarkIrpPending (Irp);

    IoSetCancelRoutine( Irp, AfdCancelSuperAccept );


    //
    // Check if the IRP has already been canceled.
    // If the cancel routine ran, it just reset the connection
    // object accept pointer to NULL (instead of -1 that we stuffed
    // in it above), but it did not complete the IRP.
    //

    if ( !Irp->Cancel &&
            (InterlockedCompareExchangePointer (
                    (PVOID *)&connection->AcceptIrp,
                    Irp,
                    (PVOID)-1)==(PVOID)-1)) {
        //
        // Can't touch the IRP after this point since it may have already
        // been canceled.
        //
        DEBUG   Irp = NULL;

        //
        // Push the connection and associated Irp/endpoint
        // onto preaccepted connection list.
        //

        if (InterlockedPushEntrySList(
                &listenEndpoint->Common.VcListening.PreacceptedConnectionsListHead,
                &connection->SListEntry
                )==NULL) {

            //
            // This is the first Irp in the list, we need to check
            // if there are any unaccepted connections that we
            // can use to satisfy super accept.
            //

            AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);

            if (!listenEndpoint->EndpointCleanedUp) {
                LIST_ENTRY  irpList;
                InitializeListHead (&irpList);

                //
                // First see if there is an unaccepted connection
                //
                while (!IsListEmpty (&listenEndpoint->Common.VcListening.UnacceptedConnectionListHead)) {
                    connection = CONTAINING_RECORD(
                                         listenEndpoint->Common.VcListening.UnacceptedConnectionListHead.Flink,
                                         AFD_CONNECTION,
                                         ListEntry
                                         );
                    RemoveEntryList (&connection->ListEntry);
                    //
                    // Now make sure we still have super accept irp
                    //
                    if (AfdServiceSuperAccept (listenEndpoint, connection, &lockHandle, &irpList)) {
                        //
                        // The routine has found and completed super accept IRP
                        // Reaquire a spinlock and continue searching for more.
                        //
                        AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                    }
                    else {
                        //
                        // No super accept Irps, put connection back onto the list
                        // while we are still holding the lock and bail out.
                        //
                        InsertHeadList (&listenEndpoint->Common.VcListening.UnacceptedConnectionListHead,
                                            &connection->ListEntry);
                        break;
                    }
                }
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);

                //
                // Complete failed super accept IRPs (if any)
                //
                if (!IsListEmpty (&irpList)) {
                    KIRQL   cancelIrql;
                    //
                    // Make sure cancel routines will
                    // not access the completed IRPs
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                    while (!IsListEmpty (&irpList)) {
                        PIRP    irp;
                        irp = CONTAINING_RECORD (irpList.Flink, IRP, Tail.Overlay.ListEntry);
                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                        IoCompleteRequest (irp, AfdPriorityBoost);
                    }
                }
            }
            else {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                AfdFreeQueuedConnections (listenEndpoint);
            }
        }
        else {
            USHORT  depth = 
                ExQueryDepthSList (&listenEndpoint->Common.VcListening.PreacceptedConnectionsListHead);

            if (depth > listenEndpoint->Common.VcListening.MaxExtraConnections) {
                //
                // Update under the lock, so we do not corrupt
                // other fields in the same memory access granularity unit.
                // This should be infrequent operation anyway.
                //
                AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                listenEndpoint->Common.VcListening.MaxExtraConnections = depth;
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
             }
        }
    }
    else {
        //
        // Reset and call the cancel routine, since
        // even if cancel routine ran, it could not complete
        // the irp because it was not set in the connection
        // object. Note that cancel routine is done with the IRP
        // once it releases cancel spinlock which we acquire here.
        //
        AfdCleanupSuperAccept (Irp, STATUS_CANCELLED);
        if (IoSetCancelRoutine (Irp, NULL)==NULL) {
            KIRQL cancelIrql;
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }

        IoCompleteRequest (Irp, AfdPriorityBoost);

        //
        // We have to return pending because we have already
        // marked the Irp as pending.
        //
    }

    return STATUS_PENDING;

complete_state_change:
    AFD_END_STATE_CHANGE (acceptEndpoint);

complete:

    if ( acceptFileObject != NULL ) {
        if (acceptEndpoint!=NULL) {
            ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        }
        ObDereferenceObject( acceptFileObject );
    }

    //
    // Free MDL here as IO system can't do it if it is
    // not locked.
    //
    if (Irp->MdlAddress!=NULL) {
        if (Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (Irp->MdlAddress);
        }

        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdSuperAccept



NTSTATUS
AfdRestartSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD wait for listen IRP portion
    of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to accept file object.

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    listenEndpoint = irpSp->FileObject->FsContext;

    acceptFileObject = Context;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    connection = acceptEndpoint->Common.VcConnecting.Connection;
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==acceptEndpoint);


    //
    // Overwrite listen file object with accept file object
    // since we won't be using listen file object anymore,
    // while we still need to deference accept file object
    // upon IRP completion.
    //
    irpSp->FileObject = acceptFileObject;


    //
    // Fix up the MDL pointer in the IRP.
    //

    ASSERT (Irp->MdlAddress==NULL);
    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
        );

    connection->ConnectTime = KeQueryInterruptTime();

    if ( NT_SUCCESS(Irp->IoStatus.Status)) {

        //
        // Set the endpoint to the connected state.
        //

        AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

        acceptEndpoint->State = AfdEndpointStateConnected;
        connection->State = AfdConnectionStateConnected;
        acceptEndpoint->EventsActive |= AFD_POLL_SEND;


        //
        // Reference connection to prevent it from going away during
        // accept process as the result of transmit file completion.
        // (transmit file can now occur at any time since we
        // marked the endpoint as connected and about to end state change)
        //
        REFERENCE_CONNECTION (connection);

        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
        AFD_END_STATE_CHANGE(acceptEndpoint);

        return AfdContinueSuperAccept (Irp, connection);
    }
    else {
        //
        // If the accept failed, treat it like an abortive disconnect.
        // This way the application still gets a new endpoint, but it gets
        // told about the reset.
        //

        AFD_END_STATE_CHANGE(acceptEndpoint);
        AfdDisconnectEventHandler(
            NULL,
            connection,
            0,
            NULL,
            0,
            NULL,
            TDI_DISCONNECT_ABORT
            );

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        ObDereferenceObject( acceptFileObject );

        //
        // Check if we have secondary MDL for local address query and
        // free it.
        //
        if (Irp->MdlAddress->Next!=NULL) {
            //
            // We never lock pages for this one (they are locked
            // as part of main MDL).
            //
            ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0);
            ASSERT ((Irp->MdlAddress->Next->MdlFlags & MDL_PAGES_LOCKED)==0);
            IoFreeMdl (Irp->MdlAddress->Next);
            Irp->MdlAddress->Next = NULL;
        }

        return STATUS_SUCCESS;
    }

} // AfdRestartSuperAccept


VOID
AfdRestartSuperAcceptListen (
    IN PIRP            Irp,
    IN PAFD_CONNECTION Connection
    )

/*++

Routine Description:

    The completion routine for the AFD wait for listen IRP portion
    of a super accept.

Arguments:

    Irp - The super accept IRP.

    Connection - points to the connection object

Return Value:

    None
--*/

{
    PAFD_ENDPOINT acceptEndpoint;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS    status;

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    acceptEndpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));
    AFD_END_STATE_CHANGE(acceptEndpoint);

    //
    // Fix up the system buffer and MDL pointers in the IRP.
    //

    ASSERT (Irp->MdlAddress==NULL);
    ASSERT (Irp->AssociatedIrp.SystemBuffer == NULL);
    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    //
    // This routine shouldn't have been called if accept failed
    //
    ASSERT ( NT_SUCCESS(Irp->IoStatus.Status) );

    //
    // Reference connection to prevent it from going away during
    // accept process as the result of transmit file completion.
    // (transmit file can now occur at any time since we
    // marked the endpoint as connected and about to end state change)
    //
    REFERENCE_CONNECTION (Connection);

    status = AfdContinueSuperAccept (Irp, Connection);

    //
    // If completion routine return anything other
    // than STATUS_MORE_PROCESSING_REQUIRED, the IRP
    // is ready to be completed.  Otherwise, is was
    // reused to call transport driver and will be completed
    // by the driver.  Note that in the latter case
    // the IRP cannot be touched because
    // it could have been completed inside of the
    // completion routine or by the driver before the
    // completion routine returned.
    //
    if (status!=STATUS_MORE_PROCESSING_REQUIRED) {
        IoCompleteRequest (Irp, AfdPriorityBoost);
    }

} // AfdRestartSuperAcceptListen

NTSTATUS
AfdRestartDelayedSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD wait for delayed accept IRP portion
    of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to accept file object

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT  acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    listenEndpoint = irpSp->FileObject->FsContext;
    acceptFileObject = Context;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    //
    // Overwrite listen file object with accept file object
    // since we won't be using listen file object anymore,
    // while we still need to deference accept file object
    // upon IRP completion.
    //
    irpSp->FileObject = acceptFileObject;

    //
    // Fix up the MDL pointer in the IRP.
    //

    ASSERT (Irp->MdlAddress==NULL);
    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
        );

    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
    //
    // The AFD connection object should now be in the endpoiont.
    //

    connection = AFD_CONNECTION_FROM_ENDPOINT( acceptEndpoint );
    if (connection!=NULL) {
        //
        // If the IRP failed, quit processing.
        //

        if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

            acceptEndpoint->State = AfdEndpointStateConnected;
            connection->State = AfdConnectionStateConnected;
            acceptEndpoint->EventsActive |= AFD_POLL_SEND;

            //
            // Reference connection to prevent it from going away during
            // accept process as the result of transmit file completion.
            // (transmit file can now occur at any time since we
            // marked the endpoint as connected and about to end state change)
            //
            REFERENCE_CONNECTION (connection);

            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
            AFD_END_STATE_CHANGE(acceptEndpoint);

            return AfdContinueSuperAccept (Irp, connection);

        }
        else {
            //
            // If the accept failed, treat it like an abortive disconnect.
            // This way the application still gets a new endpoint, but it gets
            // told about the reset.
            //

            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

            AFD_END_STATE_CHANGE(acceptEndpoint);
            AfdDisconnectEventHandler(
                NULL,
                connection,
                0,
                NULL,
                0,
                NULL,
                TDI_DISCONNECT_ABORT
                );

            ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
            ObDereferenceObject( acceptFileObject );
            //
            // After dereferencing file object we shouldn't be accessing it
            // or associated endpoint structure
            //
        }
    }
    else {
        // this could happed if transmit file cleaned up the object
        // really quickly somehow,
        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );
        ObDereferenceObject( acceptFileObject );
        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
    }

    //
    // Check if we have secondary MDL for local address query and
    // free it.
    //
    if (Irp->MdlAddress->Next!=NULL) {
        //
        // We never lock pages for this one (they are locked
        // as part of main MDL).
        //
        ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0);
        ASSERT ((Irp->MdlAddress->Next->MdlFlags & MDL_PAGES_LOCKED)==0);
        IoFreeMdl (Irp->MdlAddress->Next);
        Irp->MdlAddress->Next = NULL;
    }

    return STATUS_SUCCESS;

} // AfdRestartDelayedSuperAccept

NTSTATUS
AfdContinueSuperAccept (
    IN PIRP         Irp,
    PAFD_CONNECTION Connection
    )
/*++

Routine Description:

    Continues super accept IRP processing after the initial accept
    phase by requesting local address and/or first portion of the 
    received data.

Arguments:

    Irp - a pointer to the super accept IRP
    Connection - pointer to the accepted connection


Return Value:
    STATUS_SUCCESS if Irp processing is completed
    STATUS_MORE_PROCESSING_REQUIRED if it submits another request
        and processing will ocurr in the completion routine.

--*/

{
    PAFD_ENDPOINT       acceptEndpoint;
    PIO_STACK_LOCATION  irpSp;
    ULONG               length;


    //
    // Initialize locals
    //
    irpSp = IoGetCurrentIrpStackLocation (Irp);
    acceptEndpoint = irpSp->FileObject->FsContext;

    //
    // See if we need to get local address.
    //
    if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) {

        ASSERT (Irp->MdlAddress->Next!=NULL);

        //
        // Get the MDL that describes local address part of the user buffer
        // The oritinal mdl chain address is safe in our stack location
        //
        Irp->MdlAddress = Irp->MdlAddress->Next;

        //
        // Unchain the address MDL from the receive MDL - we will
        // free it upon completion of the address query operation
        //
        ((PMDL)irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress)->Next = NULL;

        ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                    == MmGetMdlByteCount (Irp->MdlAddress));

        IoBuildPartialMdl (
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress,
                    Irp->MdlAddress,
                    MmGetMdlVirtualAddress (Irp->MdlAddress),
                    MmGetMdlByteCount (Irp->MdlAddress)
                    );
                            

        TdiBuildQueryInformation(
            Irp,
            Connection->DeviceObject,
            Connection->FileObject,
            AfdRestartSuperAcceptGetAddress,
            Connection,
            TDI_QUERY_ADDRESS_INFO,
            Irp->MdlAddress
            );

        //
        // Perform the local address query.  We'll continue processing from
        // the completion routine.
        //

        AfdIoCallDriver( acceptEndpoint, Connection->DeviceObject, Irp );
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    //
    // See if want to get first portion of the data
    //
    else if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength>0) {
        PIO_STACK_LOCATION  nextIrpSp;

        ASSERT (Irp->MdlAddress->Next==NULL);
        //
        // Get the length of the receive portion of the buffer
        // and save the length of the MDL to restore in the completion routine
        // Set the length of the MDL to match that of the receive request
        //

        length = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;
        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength =
                        MmGetMdlByteCount (Irp->MdlAddress);
        Irp->MdlAddress->ByteCount = length;

        //
        // Prepare the IRP to be used to receive the first chunk of data on
        // the connection.
        //
        // Also note that we send ourselves an IRP_MJ_READ IRP because
        // the I/O subsystem has already probed & locked the output buffer,
        // which just happens to look just like an IRP_MJ_READ IRP.
        //

        nextIrpSp = IoGetNextIrpStackLocation( Irp );

        nextIrpSp->FileObject = irpSp->FileObject;
        nextIrpSp->DeviceObject = IoGetRelatedDeviceObject( nextIrpSp->FileObject );
        nextIrpSp->MajorFunction = IRP_MJ_READ;

        nextIrpSp->Parameters.Read.Length = length;
        nextIrpSp->Parameters.Read.Key = 0;
        nextIrpSp->Parameters.Read.ByteOffset.QuadPart = 0;


        IoSetCompletionRoutine(
            Irp,
            AfdRestartSuperAcceptReceive,
            Connection,
            TRUE,
            TRUE,
            TRUE
            );


        //
        // Perform the receive.  We'll continue processing from
        // the completion routine.
        //

        AfdIoCallDriver( acceptEndpoint, nextIrpSp->DeviceObject, Irp );
        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    Irp->IoStatus.Information = 0;

    if (Connection->AbortIndicated && NT_SUCCESS (Irp->IoStatus.Status)) {
        Irp->IoStatus.Status = STATUS_CONNECTION_RESET;
    }

    if (NT_SUCCESS (Irp->IoStatus.Status) &&
            (Connection->RemoteAddress!=NULL) &&
            (KeInitializeApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdSuperAcceptApcKernelRoutine,
                            AfdSuperAcceptApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            Irp,
                            Connection,
                            AfdPriorityBoost))) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // Dereference the accept file object and tell IO to complete this IRP.
        //

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

        ObDereferenceObject( irpSp->FileObject );

        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
        DEREFERENCE_CONNECTION (Connection);
        return STATUS_SUCCESS;
    }

}


NTSTATUS
AfdRestartSuperAcceptGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD wait for query local address
    portion of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to the accepted connection 

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION irpSp;


    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    acceptEndpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    connection = Context;
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==acceptEndpoint);

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }


    ASSERT (Irp->MdlAddress->MdlFlags & MDL_PARTIAL);
    IoFreeMdl( Irp->MdlAddress );

    //
    // Fix up the MDL pointer in the IRP and set local address length
    // to 0 to use the common routine for receive part of the super
    // accept Irp
    //

    Irp->MdlAddress = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress;

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
#ifndef i386
        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
            PTDI_ADDRESS_INFO   addressInfo = (PVOID)
                    ((PUCHAR)MmGetSystemAddressForMdl(Irp->MdlAddress)
                        + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
            USHORT addressLength = addressInfo->Address.Address[0].AddressLength+sizeof(USHORT);
            USHORT UNALIGNED *pAddrLength = (PVOID)
                    ((PUCHAR)addressInfo 
                    +irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                    -sizeof(USHORT));
            RtlMoveMemory (addressInfo,
                            &addressInfo->Address.Address[0].AddressType,
                            addressLength);
            *pAddrLength = addressLength;
        }
#endif // ifndef i386
        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength = 0;
        return AfdContinueSuperAccept (Irp, connection);
    }
    else {
        //
        // Dereference the accept file object and tell IO to complete this IRP.
        //

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

        ObDereferenceObject( irpSp->FileObject );
        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
        DEREFERENCE_CONNECTION (connection);

        return STATUS_SUCCESS;
    }

} // AfdRestartSuperAcceptGetAddress


NTSTATUS
AfdRestartSuperAcceptReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    The completion routine for the AFD receive portion of a super accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The super accept IRP.

    Context - points to the accepted connection 

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/

{
    PAFD_ENDPOINT acceptEndpoint;
    PAFD_CONNECTION connection;

    PIO_STACK_LOCATION  irpSp;

    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);

    acceptEndpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    connection = Context;
    ASSERT (connection->Type == AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==acceptEndpoint);

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);


    //
    // Restore MDL length so that IO system can properly unmap 
    // and unlock it when it completes the IRP
    //

    ASSERT (Irp->MdlAddress!=NULL);
    ASSERT (Irp->MdlAddress->Next==NULL);
    Irp->MdlAddress->ByteCount = 
        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }




    if (NT_SUCCESS (Irp->IoStatus.Status) &&
            (connection->RemoteAddress!=NULL) &&
            (KeInitializeApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdSuperAcceptApcKernelRoutine,
                            AfdSuperAcceptApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&acceptEndpoint->Common.VcConnecting.Apc,
                            Irp,
                            connection,
                            AfdPriorityBoost))) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // Dereference the accept file object and tell IO to complete this IRP.
        //

        ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

        ObDereferenceObject( irpSp->FileObject );

        //
        // After dereferencing file object we shouldn't be accessing it
        // or associated endpoint structure
        //
        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }


} // AfdRestartSuperAcceptReceive

VOID
AfdSuperAcceptApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
{
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PVOID   context;

    PAGED_CODE ();
#if DBG
    try {
#endif

    ASSERT (*NormalRoutine == NULL);

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    irp = *SystemArgument1;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    ASSERT (irpSp->FileObject->FsContext==endpoint);

    connection = *SystemArgument2;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    ASSERT (connection->Endpoint==endpoint);

    //
    // Copy remote address to the user mode context
    //
    context = AfdLockEndpointContext (endpoint);
    if ( (((CLONG)(endpoint->Common.VcConnecting.RemoteSocketAddressOffset+
                endpoint->Common.VcConnecting.RemoteSocketAddressLength)) <
                endpoint->ContextLength) &&
            (endpoint->Common.VcConnecting.RemoteSocketAddressLength >=
                connection->RemoteAddress->Address[0].AddressLength +
                                          sizeof(u_short))) {

        RtlMoveMemory ((PUCHAR)context +
                            endpoint->Common.VcConnecting.RemoteSocketAddressOffset,
            &connection->RemoteAddress->Address[0].AddressType,
            connection->RemoteAddress->Address[0].AddressLength +
                                          sizeof(u_short));
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
            "AfdSuperAcceptApcKernelRoutine: Could not copy remote address for AcceptEx on endpoint: %p, process: %p\n",
                        endpoint, endpoint->OwningProcess));
    }
    AfdUnlockEndpointContext (endpoint, context);

    AFD_RETURN_REMOTE_ADDRESS (
            connection->RemoteAddress,
            connection->RemoteAddressLength
            );
    connection->RemoteAddress = NULL;

    //
    // Dereference the accept file object and tell IO to complete this IRP.
    //

    ASSERT( InterlockedDecrement( &endpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( irpSp->FileObject );

    //
    // After dereferencing file object we shouldn't be accessing it
    // or associated endpoint structure
    //
    DEREFERENCE_CONNECTION (connection);

    IoCompleteRequest (irp, AfdPriorityBoost);
#if DBG
    }
    except (AfdApcExceptionFilter (
                GetExceptionInformation(),
                (LPSTR)__FILE__,
                (LONG)__LINE__)) {
        DbgBreakPoint ();
    }
#endif

}

VOID
AfdSuperAcceptApcRundownRoutine (
    IN struct _KAPC *Apc
    )
{
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;

    PAGED_CODE ();

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));
    
    irp = Apc->SystemArgument1;
    irpSp = IoGetCurrentIrpStackLocation( irp );
    ASSERT (irpSp->FileObject->FsContext==endpoint);

    connection = Apc->SystemArgument2;
    ASSERT( connection->Type == AfdBlockTypeConnection );
    
    ASSERT (connection->Endpoint==endpoint);

    //
    // Dereference the accept file object and tell IO to complete this IRP.
    //

    ASSERT( InterlockedDecrement( &endpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( irpSp->FileObject );

    //
    // After dereferencing file object we shouldn't be accessing it
    // or associated endpoint structure
    //
    DEREFERENCE_CONNECTION (connection);

    IoCompleteRequest (irp, AfdPriorityBoost);
}


NTSTATUS
FASTCALL
AfdDeferAccept (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Defers acceptance of an incoming connection for which an
    AFD_WAIT_FOR_LISTEN IOCTL has already completed. The caller
    may specify that the connection be deferred for later acceptance
    or rejected totally.

Arguments:

    Irp - a pointer to a transmit file IRP.

    IrpSp - Our stack location for this IRP.

Return Value:

    STATUS_SUCCESS if the request was completed successfully, or a
    failure status code if there was an error.

--*/

{
    NTSTATUS status;
    PAFD_DEFER_ACCEPT_INFO deferAcceptInfo;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Set up local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;
    deferAcceptInfo = Irp->AssociatedIrp.SystemBuffer;

    Irp->IoStatus.Information = 0;

    //
    // Make sure that this request is valid.
    //

    if( !endpoint->Listening ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(AFD_DEFER_ACCEPT_INFO) ) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;

    }

    ASSERT ((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening);
    
    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    //
    // Find the specified connection. If it cannot be found, then this
    // is a bogus request.
    //

    connection = AfdGetReturnedConnection(
                     endpoint,
                     deferAcceptInfo->Sequence
                     );

    if( connection == NULL ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto complete;

    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // If this is a request to reject the accepted connection, then
    // abort the connection. Otherwise (this is a request to defer
    // acceptance until later) then insert the connection at the *head*
    // of the endpoint's unaccepted connection queue.
    //

    if( deferAcceptInfo->Reject ) {


        //
        // Reenable the accept event bit, and if there are additional
        // unaccepted connections on the endpoint, post another event.
        //


        endpoint->EventsActive &= ~AFD_POLL_ACCEPT;

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdDeferAccept: Endp %08lX, Active %08lX\n",
                endpoint,
                endpoint->EventsActive
                ));
        }

        if( !IsListEmpty( &endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_ACCEPT,
                STATUS_SUCCESS
                );

        }

        //
        // Special handling for SAN connections
        //
        if (connection->SanConnection) {
            PIRP    connectIrp;
            //
            // Snag the connect indication IRP
            //
            connectIrp = connection->ConnectIrp;
            ASSERT (connectIrp!=NULL);
            connection->ConnectIrp = NULL;

            //
            // We can now release listen endpoint spinlock
            // The cancel routine will not find IRP in the connection
            //
            if (IoSetCancelRoutine (connectIrp, NULL)==NULL) {
                KIRQL   cancelIrql;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                //
                // Cancel routine is running, make sure
                // it finishes before proceeding further
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
                connectIrp->IoStatus.Status = STATUS_CANCELLED;
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                connectIrp->IoStatus.Status = STATUS_CONNECTION_REFUSED;
            }
                

            //
            // Return the connection and complete SAN provider IRP
            //

            connection->Endpoint = NULL;
            connection->SanConnection = FALSE;

            AfdSanReleaseConnection (endpoint, connection, FALSE);
            DEREFERENCE_ENDPOINT (endpoint);

            connectIrp->IoStatus.Information = 0;
            IoCompleteRequest (connectIrp, AfdPriorityBoost);
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            //
            // Abort the connection.
            //

            AfdAbortConnection( connection );

            //
            // Add another free connection to replace the one we're rejecting.
            // Also, add extra to account for past failures in calls to
            // AfdAddFreeConnection().
            //

            InterlockedIncrement(
                &endpoint->Common.VcListening.FailedConnectionAdds
                );

            AfdReplenishListenBacklog( endpoint );
        }

    } else {

        //
        // Restore the connection's state before putting it back
        // on the queue.
        //

        connection->State = AfdConnectionStateUnaccepted;

        InsertHeadList(
            &endpoint->Common.VcListening.UnacceptedConnectionListHead,
            &connection->ListEntry
            );
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    status = STATUS_SUCCESS;

complete:

    Irp->IoStatus.Status = status;
    ASSERT( Irp->CancelRoutine == NULL );

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdDeferAccept



NTSTATUS
AfdRestartDelayedAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    The completion routine for the AFD wait for delayed accept IRP portion
    of an accept.

Arguments:

    DeviceObject - the devoce object on which the request is completing.

    Irp - The accept IRP.

    Context - points to accept file object

Return Value:

    STATUS_SUCCESS if the I/O system should complete the super accept
    request, or STATUS_MORE_PROCESSING_REQUIRED if the super accept
    request is still being processed.

--*/
{
    PIO_STACK_LOCATION  irpSp;
    PFILE_OBJECT    acceptFileObject;
    PAFD_ENDPOINT   acceptEndpoint;
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT   listenEndpoint;
    AFD_LOCK_QUEUE_HANDLE   lockHandle;

    acceptFileObject = Context;
    acceptEndpoint = acceptFileObject->FsContext;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    listenEndpoint = irpSp->FileObject->FsContext;

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
        );

    AfdCompleteOutstandingIrp (acceptEndpoint, Irp);

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
    //
    // The AFD connection object should now be in the endpoiont.
    //

    connection = AFD_CONNECTION_FROM_ENDPOINT( acceptEndpoint );
    if (connection!=NULL) {
        if (NT_SUCCESS (Irp->IoStatus.Status)) {
            acceptEndpoint->State = AfdEndpointStateConnected;
            connection->State = AfdConnectionStateConnected;
            acceptEndpoint->EventsActive |= AFD_POLL_SEND;
            acceptEndpoint->EnableSendEvent = TRUE;
            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
            AFD_END_STATE_CHANGE (acceptEndpoint);
        }
        else {
            //
            // If the accept failed, treat it like an abortive disconnect.
            // This way the application still gets a new endpoint, but it gets
            // told about the reset.
            //
            REFERENCE_CONNECTION (connection);

            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

            AFD_END_STATE_CHANGE (acceptEndpoint);

            AfdDisconnectEventHandler(
                NULL,
                connection,
                0,
                NULL,
                0,
                NULL,
                TDI_DISCONNECT_ABORT
                );
            DEREFERENCE_CONNECTION (connection);
        }
    }


    ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( acceptFileObject );

    Irp->AssociatedIrp.SystemBuffer = irpSp->Parameters.AfdRestartDelayedAcceptInfo.AfdSystemBuffer;

    return STATUS_SUCCESS;
}



VOID
AfdCleanupSuperAccept (
    IN PIRP     Irp,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    Cleans up a super accept IRP and prepeares it for completion

Arguments:

    Irp - the IRP to cleanup.
    Status - failure status

Return Value:

    None.

--*/

{

    PAFD_ENDPOINT listenEndpoint;
    PFILE_OBJECT  acceptFileObject;
    PAFD_ENDPOINT acceptEndpoint;
    PIO_STACK_LOCATION  irpSp;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    ASSERT (!NT_SUCCESS (Status));
    //
    // Initialize some locals.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    listenEndpoint = irpSp->FileObject->FsContext;

    //
    // Reduce the count of failed connection adds on the listening
    // endpoint to account for this connection object which we're
    // adding back onto the queue once it is pulled from pre-accepted connection
    // list.
    //
    InterlockedDecrement (&listenEndpoint->Common.VcListening.FailedConnectionAdds);


    acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
    acceptEndpoint = acceptFileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

    //
    // Cleanup super accept IRP out of endpoint.
    //
    AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
    ASSERT (acceptEndpoint->Irp==Irp); // May need to remove this assert 
                                       // in the future.
    acceptEndpoint->Irp = NULL;
    AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

    //
    // Mark the end of state change letting the endpoint
    // to be used again in state change operation (e.g. accept).
    //

    AFD_END_STATE_CHANGE (acceptEndpoint);

    //
    // Dereference accept file object
    //
    ASSERT( InterlockedDecrement( &acceptEndpoint->ObReferenceBias ) >= 0 );

    ObDereferenceObject( acceptFileObject );

    //
    // Check if we have secondary MDL for local address query and
    // free it.
    //
    if (Irp->MdlAddress->Next!=NULL) {
        //
        // We never lock pages for this one (they are locked
        // as part of main MDL).
        //
        ASSERT (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0);
        ASSERT ((Irp->MdlAddress->Next->MdlFlags & MDL_PAGES_LOCKED)==0);
        IoFreeMdl (Irp->MdlAddress->Next);
        Irp->MdlAddress->Next = NULL;
    }

   
    //
    // Set the status specified in the IRP and return
    // The caller will eventually complete it.
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;

    return;
}


VOID
AfdCancelSuperAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a super accept IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PAFD_CONNECTION connection;

    connection = Irp->Tail.Overlay.DriverContext[0];
    ASSERT (connection->Type==AfdBlockTypeConnection);
    ASSERT (connection->Endpoint==NULL);
    //
    // If IRP is in the connection object, cleanup and complete it
    //
    if (InterlockedExchangePointer (
                (PVOID *)&connection->AcceptIrp, 
                NULL)==Irp) {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
        AfdCleanupSuperAccept (Irp, STATUS_CANCELLED);
        IoCompleteRequest( Irp, AfdPriorityBoost );

    }
    else {
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    return;
}


BOOLEAN
AfdServiceSuperAccept (
    IN  PAFD_ENDPOINT   Endpoint,
    IN  PAFD_CONNECTION Connection,
    IN  PAFD_LOCK_QUEUE_HANDLE LockHandle,
    OUT PLIST_ENTRY     AcceptIrpList
    )
/*++

Routine Description:

    Attemts to satisfy super accept irp using the incoming
    connection. This routine must be called with listening endpoint
    spinlock held.

Arguments:

    Endpoint - listening endpoint on which connection is
                being accepted
    Connection - connection being accepted.
    AcceptIrpList - returns a list of accept Irps which were failed and 
                    need to be completed after listening endpoint spinlock
                    is released.


Return Value:

    TRUE - the super accept IRP was found and is in the head of the list
    FALSE - no usable super accept IRP exists.

--*/

 
{
    PSINGLE_LIST_ENTRY  listEntry;
    PIRP                acceptIrp;
    PAFD_CONNECTION     oldConnection;

    //
    // Keep removing super accept IRPs while there are any there
    //
    while ((listEntry = InterlockedPopEntrySList (
                 &Endpoint->Common.VcListening.PreacceptedConnectionsListHead
                 ))!=NULL) {
        NTSTATUS            status;

        //
        // Find the connection pointer from the list entry and return a
        // pointer to the connection object.
        //

        oldConnection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         SListEntry
                         );

        acceptIrp = InterlockedExchangePointer ((PVOID *)&oldConnection->AcceptIrp, NULL);
        //
        // Check if there is accept irp associated with
        // this connection, if not just put it back on the free list
        // (the IRP must have been cancelled)
        //
        if (acceptIrp!=NULL) {
            if (IoSetCancelRoutine (acceptIrp, NULL)!=NULL) {

                PFILE_OBJECT            acceptFileObject;
                PAFD_ENDPOINT           acceptEndpoint;
                PIO_STACK_LOCATION      irpSp;

                //
                // Initialize some locals.
                //

                irpSp = IoGetCurrentIrpStackLocation (acceptIrp);
                acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
                acceptEndpoint = acceptFileObject->FsContext;
                ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));

                //
                // Check if super accept Irp has enough space for
                // the remote address
                //
                if (Connection->RemoteAddressLength>
                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength) {
                
                    status = STATUS_BUFFER_TOO_SMALL;

                }
                //
                // Check if we have enough system PTE's to map
                // the buffer.
                //
                else if ((status = AfdMapMdlChain (acceptIrp->MdlAddress)),
                            !NT_SUCCESS (status)) {
                    NOTHING;
                }
                else if (Connection->SanConnection) {
                    status = AfdSanAcceptCore (acceptIrp, acceptFileObject, Connection, LockHandle);
                    if (status==STATUS_PENDING) {
                        //
                        // Accept IRP is pending waiting for Switch
                        // completion notification
                        // Release old connection object
                        //
                        ASSERT (oldConnection->Endpoint==NULL);
                        InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &oldConnection->SListEntry);


                    }
                    else {
                        //
                        // Something failed, we need to complete accept IRP
                        //
                        ASSERT (NT_ERROR (status));
                        AfdCleanupSuperAccept (acceptIrp, status);
                        IoCompleteRequest (acceptIrp, AfdPriorityBoost);
                        //
                        // This connection has already been diassociated from endpoint.
                        // If backlog is below the level we need, put it on the free
                        // list, otherwise, get rid of it.
                        //

                        ASSERT (oldConnection->Endpoint==NULL);
                        if (InterlockedIncrement (&Endpoint->Common.VcListening.FailedConnectionAdds)>0) {
                            InterlockedDecrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
                            InterlockedPushEntrySList (
                                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                                            &oldConnection->SListEntry);
                        }
                        else {
                            DEREFERENCE_CONNECTION (oldConnection);
                        }
                    }
                    //
                    // Complete previously failed accept irps if any.
                    //
                    while (!IsListEmpty (AcceptIrpList)) {
                        PIRP    irp;
                        irp = CONTAINING_RECORD (AcceptIrpList->Flink, IRP, Tail.Overlay.ListEntry);
                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                        IoCompleteRequest (irp, AfdPriorityBoost);
                    }
                    return TRUE;
                }
                //
                // Allocate MDL for local address query if requested
                //
                else if ((irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) &&
                    (IoAllocateMdl ((PUCHAR)acceptIrp->UserBuffer+irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength,
                                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                    TRUE,
                                    FALSE,
                                    acceptIrp)==NULL)){
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
                else {
                    //
                    // Copy over the address information to the user's buffer.
                    //
#ifndef i386
                    if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                        USHORT addressLength = 
                                Connection->RemoteAddress->Address[0].AddressLength
                                + sizeof (USHORT);
                        USHORT UNALIGNED *pAddrLength = (PVOID)
                                    ((PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                                     - sizeof (USHORT));
                        RtlMoveMemory (
                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                     &Connection->RemoteAddress->Address[0].AddressType,
                                     addressLength);
                        *pAddrLength = addressLength;
                    }
                    else
#endif
                    {
                        RtlMoveMemory (
                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                     Connection->RemoteAddress,
                                     Connection->RemoteAddressLength);
                    }
                    status = AfdAcceptCore (acceptIrp, acceptEndpoint, Connection);
                    if (status==STATUS_SUCCESS) {
                        AfdReleaseSpinLock (&Endpoint->SpinLock, LockHandle);


                        //
                        // Decrement counter to account for connection being
                        // returned to the free pool.  No need to do this because
                        // we are picking up a connection from the free pool
                        // InterlockedDecrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
                        //
                        ASSERT (oldConnection->Endpoint==NULL);
                        InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &oldConnection->SListEntry);



                        //
                        // Complete previously failed accept irps if any.
                        //
                        while (!IsListEmpty (AcceptIrpList)) {
                            PIRP    irp;
                            irp = CONTAINING_RECORD (AcceptIrpList->Flink, IRP, Tail.Overlay.ListEntry);
                            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                            IoCompleteRequest (irp, AfdPriorityBoost);
                        }

                        //
                        // Make irp look like it is completed by the
                        // transport.
                        //
                        acceptIrp->IoStatus.Status = STATUS_SUCCESS;
                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress = acceptIrp->MdlAddress;
                        acceptIrp->MdlAddress = NULL;
                        irpSp->FileObject = acceptFileObject;

                        //
                        // Call completion routine directly to simulate
                        // completion by the transport stack
                        //
                        AfdRestartSuperAcceptListen (acceptIrp, Connection);

                        return TRUE;
                    }
                    else {
                        ASSERT (status!=STATUS_PENDING);
                    }
                }
            }
            else { // if (IoSetCancelRoutine (accpetIrp, NULL)!=NULL)
                status = STATUS_CANCELLED;
            }

            //
            // Cleanup the IRP and insert it into the completion list
            //
            AfdCleanupSuperAccept (acceptIrp, status);
            InsertTailList (AcceptIrpList,
                            &acceptIrp->Tail.Overlay.ListEntry);
        } // if (acceptIrp!=NULL)
        else {
            status = STATUS_CANCELLED;
        }
            
        //
        // This connection has already been diassociated from endpoint.
        // If backlog is below the level we need, put it on the free
        // list, otherwise, get rid of it.
        //

        ASSERT (oldConnection->Endpoint==NULL);
        if (Endpoint->Common.VcListening.FailedConnectionAdds>=0 &&
                status!=STATUS_INSUFFICIENT_RESOURCES &&
                ExQueryDepthSList (&Endpoint->Common.VcListening.FreeConnectionListHead)<AFD_MAXIMUM_FREE_CONNECTIONS) {
            InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &oldConnection->SListEntry);
        }
        else {
            InterlockedIncrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
            DEREFERENCE_CONNECTION (oldConnection);
        }
    }

    return FALSE;
}


NTSTATUS
AfdSetupAcceptEndpoint (
    PAFD_ENDPOINT   ListenEndpoint,
    PAFD_ENDPOINT   AcceptEndpoint,
    PAFD_CONNECTION Connection
    )
/*++

Routine Description:

    Sets up the accept endpoint to get ready to accept connection
    (copies parameters of the listening endpoint on which connection
    was indicated)

Arguments:

    ListenEndpoint   - endpoint on which connection was indicated
    AcceptEndpoint   - endpoint on which to accept the connection
    Connection       - connection to accept

Return Value:

    STATUS_SUCCESS   - endpoint state/parameters adjusted OK
    STATUS_CANCELLED - endpoint has already been cleaned up.

Note:
    Both accepting and listening endpoint spinlocks must be held when
    calling this routine.

--*/
{
    //
    // Check the state of the accepting endpoint.
    //


    if ( AcceptEndpoint->EndpointCleanedUp ) {
        return STATUS_CANCELLED;
    }


    //
    // Remove super accept IRP from the endpoint
    //
    AcceptEndpoint->Irp = NULL;

    //
    // Note that the returned connection structure already has a
    // referenced pointer to the listening endpoint. Rather than
    // removing the reference here, only to re-add it later, we'll
    // just not touch the reference count.
    //

    ASSERT( Connection->Endpoint == ListenEndpoint );

    //
    // Set up the accept endpoint's type, and remember blocking
    // characteristics of the TDI provider.
    //

    AcceptEndpoint->Type = AfdBlockTypeVcConnecting;
    AcceptEndpoint->TdiServiceFlags = ListenEndpoint->TdiServiceFlags;

    ASSERT (AcceptEndpoint->TransportInfo == ListenEndpoint->TransportInfo);
    ASSERT (AcceptEndpoint->TransportInfo->ReferenceCount>0);

    //
    // Place the connection on the endpoint we'll accept it on.  It is
    // still referenced from when it was created.
    //

    AcceptEndpoint->Common.VcConnecting.Connection = Connection;

    //
    // Set up a referenced pointer from the connection to the accept
    // endpoint.  Note that we actually already have a refernce to
    // the endpoint by the virtue of its file object
    //

    REFERENCE_ENDPOINT( AcceptEndpoint );
    Connection->Endpoint = AcceptEndpoint;

    //
    // Set up a referenced pointer to the listening endpoint.  This is
    // necessary so that the endpoint does not go away until all
    // accepted endpoints have gone away.  Without this, a connect
    // indication could occur on a TDI address object held open
    // by an accepted endpoint after the listening endpoint has
    // been closed and the memory for it deallocated.
    //
    // Note that, since we didn't remove the reference above, we don't
    // need to add it here.
    //

    AcceptEndpoint->Common.VcConnecting.ListenEndpoint = ListenEndpoint;

    //
    // Set up a referenced pointer in the accepted endpoint to the
    // TDI address object.
    //

    ObReferenceObject( ListenEndpoint->AddressFileObject );
    AfdRecordAddrRef();

    AcceptEndpoint->AddressFileObject = ListenEndpoint->AddressFileObject;
    AcceptEndpoint->AddressDeviceObject = ListenEndpoint->AddressDeviceObject;

    //
    // Copy the pointer to the local address. Because we keep listen
    // endpoint alive for as long as any of its connection is
    // active, we can rely on the fact that address structure won't go
    // away as well.
    //
    AcceptEndpoint->LocalAddress = ListenEndpoint->LocalAddress;
    AcceptEndpoint->LocalAddressLength = ListenEndpoint->LocalAddressLength;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\afddata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    afddata.h

Abstract:

    This module declares global data for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999   NT5.0 optimizations

--*/

#ifndef _AFDDATA_
#define _AFDDATA_

extern PDEVICE_OBJECT AfdDeviceObject;


extern LIST_ENTRY AfdEndpointListHead;
extern LIST_ENTRY AfdConstrainedEndpointListHead;

extern LIST_ENTRY AfdPollListHead;
extern AFD_QSPIN_LOCK AfdPollListLock;

extern LIST_ENTRY AfdTransportInfoListHead;
extern KEVENT AfdContextWaitEvent;
#define AFD_CONTEXT_BUSY    ((PVOID)-1)
#define AFD_CONTEXT_WAITING ((PVOID)-2)

extern PKPROCESS AfdSystemProcess;
extern FAST_IO_DISPATCH AfdFastIoDispatch;

//
// Global data which must always be in nonpaged pool,
// even when the driver is paged out (resource, lookaside lists).
//
PAFD_GLOBAL_DATA AfdGlobalData;
#define AfdResource  (&AfdGlobalData->Resource)
#define AfdLookasideLists (AfdGlobalData)
#define AfdAlignmentTable (AfdGlobalData->BufferAlignmentTable)

//
// Globals for dealing with AFD's executive worker thread.
//

extern LIST_ENTRY AfdWorkQueueListHead;
extern BOOLEAN AfdWorkThreadRunning;
extern PIO_WORKITEM AfdWorkQueueItem;

//
// Globals to track the buffers used by AFD.
//

extern ULONG AfdLargeBufferListDepth;
#define AFD_SM_DEFAULT_LARGE_LIST_DEPTH 0
#define AFD_MM_DEFAULT_LARGE_LIST_DEPTH 2
#define AFD_LM_DEFAULT_LARGE_LIST_DEPTH 10

extern ULONG AfdMediumBufferListDepth;
#define AFD_SM_DEFAULT_MEDIUM_LIST_DEPTH 4
#define AFD_MM_DEFAULT_MEDIUM_LIST_DEPTH 8
#define AFD_LM_DEFAULT_MEDIUM_LIST_DEPTH 24

extern ULONG AfdSmallBufferListDepth;
#define AFD_SM_DEFAULT_SMALL_LIST_DEPTH 8
#define AFD_MM_DEFAULT_SMALL_LIST_DEPTH 16
#define AFD_LM_DEFAULT_SMALL_LIST_DEPTH 32

extern ULONG AfdBufferTagListDepth;
#define AFD_SM_DEFAULT_TAG_LIST_DEPTH 16
#define AFD_MM_DEFAULT_TAG_LIST_DEPTH 32
#define AFD_LM_DEFAULT_TAG_LIST_DEPTH 64

extern CLONG AfdLargeBufferSize;
// default value is AfdBufferLengthForOnePage

extern CLONG AfdMediumBufferSize;
#define AFD_DEFAULT_MEDIUM_BUFFER_SIZE 1504

extern CLONG AfdSmallBufferSize;
#define AFD_DEFAULT_SMALL_BUFFER_SIZE 128

extern CLONG AfdBufferTagSize;
#define AFD_DEFAULT_TAG_BUFFER_SIZE 0

extern CLONG AfdStandardAddressLength;
#define AFD_DEFAULT_STD_ADDRESS_LENGTH sizeof(TA_IP_ADDRESS)

extern CLONG AfdBufferLengthForOnePage;
extern ULONG AfdBufferAlignment;
#define AFD_MINIMUM_BUFFER_ALIGNMENT                        \
    max(TYPE_ALIGNMENT(TRANSPORT_ADDRESS),                  \
        max(TYPE_ALIGNMENT(KAPC),                           \
            max(TYPE_ALIGNMENT(WORK_QUEUE_ITEM),            \
                max(TYPE_ALIGNMENT(AFD_BUFFER),             \
                    max(TYPE_ALIGNMENT(MDL),                \
                        max(TYPE_ALIGNMENT(IRP),            \
                            MAX_NATURAL_ALIGNMENT))))))

extern ULONG AfdAlignmentTableSize;
extern ULONG AfdAlignmentOverhead;
extern ULONG AfdBufferOverhead;

//
// Globals for tuning TransmitFile().
//

extern LIST_ENTRY AfdQueuedTransmitFileListHead;
extern AFD_QSPIN_LOCK AfdQueuedTransmitFileSpinLock;
extern ULONG AfdActiveTransmitFileCount;
extern ULONG AfdMaxActiveTransmitFileCount;
#define AFD_DEFAULT_MAX_ACTIVE_TRANSMIT_FILE_COUNT 2

extern ULONG AfdDefaultTransmitWorker;
#define AFD_DEFAULT_TRANSMIT_WORKER AFD_TF_USE_SYSTEM_THREAD

#define AFD_MAX_FAST_TRANSPORT_ADDRESS  32
//
// Various pieces of configuration information, with default values.
//

extern CCHAR AfdIrpStackSize;
#define AFD_DEFAULT_IRP_STACK_SIZE 4

extern CCHAR AfdPriorityBoost;
#define AFD_DEFAULT_PRIORITY_BOOST 2

extern ULONG AfdFastSendDatagramThreshold;
#define AFD_FAST_SEND_DATAGRAM_THRESHOLD 1024
extern ULONG AfdTPacketsCopyThreshold;
#define AFD_TPACKETS_COPY_THRESHOLD 512

extern PVOID AfdDiscardableCodeHandle;
extern PKEVENT AfdLoaded;
extern AFD_WORK_ITEM AfdUnloadWorker;
extern BOOLEAN AfdVolatileConfig;
extern HANDLE AfdParametersNotifyHandle;
extern WORK_QUEUE_ITEM AfdParametersNotifyWorker;
extern PKEVENT AfdParametersUnloadEvent;

//
// Various globals for SAN
//
extern HANDLE AfdSanCodeHandle;
extern LIST_ENTRY AfdSanHelperList;
extern PAFD_ENDPOINT   AfdSanServiceHelper;
extern HANDLE  AfdSanServicePid;
extern POBJECT_TYPE IoCompletionObjectType;
extern LONG AfdSanProviderListSeqNum;

extern CLONG AfdReceiveWindowSize;
#define AFD_LM_DEFAULT_RECEIVE_WINDOW 8192
#define AFD_MM_DEFAULT_RECEIVE_WINDOW 8192
#define AFD_SM_DEFAULT_RECEIVE_WINDOW 4096

extern CLONG AfdSendWindowSize;
#define AFD_LM_DEFAULT_SEND_WINDOW 8192
#define AFD_MM_DEFAULT_SEND_WINDOW 8192
#define AFD_SM_DEFAULT_SEND_WINDOW 4096

extern CLONG AfdBufferMultiplier;
#define AFD_DEFAULT_BUFFER_MULTIPLIER 4

extern CLONG AfdTransmitIoLength;
#define AFD_LM_DEFAULT_TRANSMIT_IO_LENGTH 65536
#define AFD_MM_DEFAULT_TRANSMIT_IO_LENGTH (PAGE_SIZE*2)
#define AFD_SM_DEFAULT_TRANSMIT_IO_LENGTH PAGE_SIZE

extern CLONG AfdMaxFastTransmit;
#define AFD_DEFAULT_MAX_FAST_TRANSMIT 65536
extern CLONG AfdMaxFastCopyTransmit;
#define AFD_DEFAULT_MAX_FAST_COPY_TRANSMIT 128

extern ULONG AfdEndpointsOpened;
extern ULONG AfdEndpointsCleanedUp;
extern ULONG AfdEndpointsClosed;
#define AFD_ENDPOINTS_FREEING_MAX       10
extern ULONG AfdEndpointsFreeing;
#define AFD_CONNECTIONS_FREEING_MAX     10
extern ULONG AfdConnectionsFreeing;

extern BOOLEAN AfdIgnorePushBitOnReceives;

extern BOOLEAN AfdEnableDynamicBacklog;
#define AFD_DEFAULT_ENABLE_DYNAMIC_BACKLOG FALSE

extern LONG AfdMinimumDynamicBacklog;
#define AFD_DEFAULT_MINIMUM_DYNAMIC_BACKLOG 0

extern LONG AfdMaximumDynamicBacklog;
#define AFD_DEFAULT_MAXIMUM_DYNAMIC_BACKLOG 0

extern LONG AfdDynamicBacklogGrowthDelta;
#define AFD_DEFAULT_DYNAMIC_BACKLOG_GROWTH_DELTA 0

// Maximum number of free connections that we keep
// on listening endpoint. This is not the same as a backlog,
// it is just a policy on connection object reuse via AcceptEx
// We stop reusing if we have that many free objects in the list
// Currently the main reason for this limit is the ability to use the
// SLists which have USHORT for item count.
#define AFD_MAXIMUM_FREE_CONNECTIONS    32767

//
// These are limits on backlog in AFD_START_LISTEN
// Application can work around this limit by posting AcceptEx(-s)
//
#define AFD_MAXIMUM_BACKLOG_NTS         200
#define AFD_MAXIMUM_BACKLOG_NTW         5
#define AFD_MINIMUM_BACKLOG             1

extern BOOLEAN AfdDisableRawSecurity;
extern PSECURITY_DESCRIPTOR AfdAdminSecurityDescriptor;
extern BOOLEAN AfdDontShareAddresses;
extern BOOLEAN AfdDisableDirectSuperAccept;
extern BOOLEAN AfdDisableChainedReceive;
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
extern BOOLEAN AfdUseTdiSendAndDisconnect;
#endif //TDI_SERVICE_SEND_AND_DISCONNECT

#define AFD_MINIMUM_TPINFO_ELEMENT_COUNT    3 // For transmit file compatibility.
extern ULONG   AfdDefaultTpInfoElementCount;
//
// Data for transport address lists and queued change queries
//
extern HANDLE          AfdBindingHandle;
extern LIST_ENTRY      AfdAddressEntryList;
extern LIST_ENTRY      AfdAddressChangeList;
extern PERESOURCE      AfdAddressListLock;
extern AFD_QSPIN_LOCK  AfdAddressChangeLock;
extern AFD_WORK_ITEM   AfdPnPDeregisterWorker;


extern IO_STATUS_BLOCK AfdDontCareIoStatus;
// Holds TDI connect timeout (-1).
extern const LARGE_INTEGER AfdInfiniteTimeout;
                        



extern SLIST_HEADER    AfdLRList;

extern KDPC            AfdLRListDpc;
extern KTIMER          AfdLRListTimer;
extern AFD_WORK_ITEM   AfdLRListWorker;
extern LONG            AfdLRListCount;
extern SLIST_HEADER    AfdLRFileMdlList;
extern AFD_LR_LIST_ITEM AfdLRFileMdlListItem;


#if AFD_PERF_DBG

extern CLONG AfdFullReceiveIndications;
extern CLONG AfdPartialReceiveIndications;

extern CLONG AfdFullReceiveDatagramIndications;
extern CLONG AfdPartialReceiveDatagramIndications;

extern CLONG AfdFastSendsSucceeded;
extern CLONG AfdFastSendsFailed;
extern CLONG AfdFastReceivesSucceeded;
extern CLONG AfdFastReceivesFailed;

extern CLONG AfdFastSendDatagramsSucceeded;
extern CLONG AfdFastSendDatagramsFailed;
extern CLONG AfdFastReceiveDatagramsSucceeded;
extern CLONG AfdFastReceiveDatagramsFailed;

extern CLONG AfdFastReadsSucceeded;
extern CLONG AfdFastReadsFailed;
extern CLONG AfdFastWritesSucceeded;
extern CLONG AfdFastWritesFailed;

extern CLONG AfdFastTfSucceeded;
extern CLONG AfdFastTfFailed;
extern CLONG AfdFastTfReadFailed;

extern CLONG AfdTPWorkersExecuted;
extern CLONG AfdTPRequests;

extern BOOLEAN AfdDisableFastIo;
extern BOOLEAN AfdDisableConnectionReuse;

#endif  // if AFD_PERF_DBG

#if AFD_KEEP_STATS

extern AFD_QUOTA_STATS AfdQuotaStats;
extern AFD_HANDLE_STATS AfdHandleStats;
extern AFD_QUEUE_STATS AfdQueueStats;
extern AFD_CONNECTION_STATS AfdConnectionStats;

#endif // if AFD_KEEP_STATS

#if DBG
extern BOOLEAN AfdUsePrivateAssert;
#endif

#ifdef _WIN64
extern QOS32 AfdDefaultQos32;
#endif
extern QOS AfdDefaultQos;

ULONG AfdIoctlTable[AFD_NUM_IOCTLS];
PAFD_IMMEDIATE_CALL AfdImmediateCallDispatch[AFD_NUM_IOCTLS];
PAFD_IRP_CALL AfdIrpCallDispatch[AFD_NUM_IOCTLS];


#define AFD_FAST_CONNECT_DATA_SIZE  256
#endif // ndef _AFDDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\bind.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Contains AfdBind for binding an endpoint to a transport address.

Author:

    David Treadwell (davidtr)    25-Feb-1992

Revision History:
    Vadim Eydelman (vadime) 1999 - C_ROOT endpoint handling,
                                    exclusive access endpoints.

--*/

#include "afdp.h"

NTSTATUS
AfdRestartGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartBindGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
AfdIsAddressInUse (
    PAFD_ENDPOINT   Endpoint,
    BOOLEAN         OtherProcessesOnly
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdBind )
#pragma alloc_text( PAGE, AfdIsAddressInUse )
#pragma alloc_text( PAGE, AfdGetAddress )
#pragma alloc_text( PAGEAFD, AfdAreTransportAddressesEqual )
#pragma alloc_text( PAGEAFD, AfdRestartGetAddress )
#pragma alloc_text( PAGEAFD, AfdRestartBindGetAddress )
#endif

NTSTATUS
FASTCALL
AfdBind (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_BIND IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    ULONG shareAccess, afdShareAccess;
    ULONG tdiAddressLength;
    PAFD_ENDPOINT endpoint;

    ULONG options;
    PTRANSPORT_ADDRESS localAddress;
    HANDLE addressHandle;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     iosb;
    PFILE_FULL_EA_INFORMATION eaInfo;
    ULONG eaLength;
    // Local buffer to avoid memory allocation
    PCHAR   eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                         TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                         AFD_MAX_FAST_TRANSPORT_ADDRESS];


    PAGED_CODE( );

    //
    // Initialize returned parameter
    //
    Irp->IoStatus.Information = 0;


    //
    // Need to have output buffer at least as long as input buffer
	// to pass the address that was actually used by the transport
	// back.
	//

	if ( (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
	    		(ULONG)FIELD_OFFSET (AFD_BIND_INFO, Address.Address)) ||
            IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                sizeof (TDI_ADDRESS_INFO) ||
			(IrpSp->Parameters.DeviceIoControl.OutputBufferLength-
                    (ULONG)FIELD_OFFSET (TDI_ADDRESS_INFO, Address) <
				IrpSp->Parameters.DeviceIoControl.InputBufferLength-
                    (ULONG)FIELD_OFFSET (AFD_BIND_INFO, Address) ) ) {

		status = STATUS_INVALID_PARAMETER;
		goto complete;
	}

   
    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    localAddress = NULL;
    addressHandle = NULL;

    tdiAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_BIND_INFO, Address);

    //
    // This is a state change operation, there should be no other
    // state changes going at the same time.
    //
    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateBound)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }


    //
    // Bomb off if this endpoind already has address associated with it
    //

    if ( endpoint->State != AfdEndpointStateOpen ) {
        status = STATUS_ADDRESS_ALREADY_ASSOCIATED;
        goto complete_wrong_state;
    }


    try {
        PAFD_BIND_INFO bindInfo;

        bindInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        if (Irp->RequestorMode!=KernelMode) {
            ProbeForRead (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            PROBE_ALIGNMENT (AFD_BIND_INFO));
        }

        //
        // Allocate space for local address
        //
        localAddress = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                     NonPagedPool,
                                     tdiAddressLength,
                                     AFD_LOCAL_ADDRESS_POOL_TAG
                                     );

        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
        ASSERT ( localAddress != NULL );

        afdShareAccess = bindInfo->ShareAccess;
        RtlMoveMemory(
            localAddress,
            &bindInfo->Address,
            tdiAddressLength
            );
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((localAddress->TAAddressCount!=1) ||
                (LONG)tdiAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[localAddress->Address[0].AddressLength])) {
            status = STATUS_INVALID_PARAMETER;
            goto complete_state_change;
        }

        if (IoAllocateMdl (Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            Irp                 // Irp
                            )==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_state_change;
        }
        MmProbeAndLockPages (Irp->MdlAddress,
                                Irp->RequestorMode,
                                IoWriteAccess);
        if (MmGetSystemAddressForMdlSafe (Irp->MdlAddress, HighPagePriority)==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_state_change;
        }
    }
    except (AFD_EXCEPTION_FILTER(&status)) {
        goto complete_state_change;
    }



    //
    // Make sure we have a valid provider info structure.
    // (we do not take any locks because this is read access only
    // and additional verification will be performed inside of the
    // routine under the lock).
    // If not, attempt to get it from provider
    // (this can happen if when the socket was created, transport
    // was not loaded yet)
    //
    if (!endpoint->TransportInfo->InfoValid) {
        status = AfdGetTransportInfo (
                        &endpoint->TransportInfo->TransportDeviceName,
                        &endpoint->TransportInfo);
        if (!NT_SUCCESS (status)) {
            goto complete_state_change;
        }
        //
        // Must be valid because we got success.
        //
        ASSERT (endpoint->TransportInfo->InfoValid);
    }

    //
    // Cache service flags for quick determination of provider characteristics
    // such as bufferring and messaging
    //
    endpoint->TdiServiceFlags = endpoint->TransportInfo->ProviderInfo.ServiceFlags;


    //
    // Attempt to take ownership of the address.
    // We have to do this before we start looking for a conflict
    // so if someone does it in parallel with us, will see him or
    // he sees us.
    //
    ASSERT (endpoint->LocalAddress==NULL);
    endpoint->LocalAddress = localAddress;
    endpoint->LocalAddressLength = tdiAddressLength;



    //
    // There are three possibilities here.
    //
    switch (afdShareAccess) {
    case AFD_NORMALADDRUSE:
            //
            // This is the default. Application did not request to reuse
            // the address that is already owned by someone else, so we
            // have to check against all addresses that we know about.
            // There is still a possibility that another TDI client has
            // this address in exclusive use, so the transport can reject 
            // our request even if we succeed. Note that we cannot relegate
            // this check to the transport because we request shared access
            // to the transport address: we cannot request exclusive access
            // because this is not what application asked for.
            //

        if (AfdIsAddressInUse (endpoint, FALSE)) {
            status = STATUS_SHARING_VIOLATION;
            goto complete_state_change;
        }
        shareAccess = FILE_SHARE_READ|FILE_SHARE_WRITE;
        break;
    case AFD_REUSEADDRESS:
        //
        // We are asked to reuse the existing address 
        //
        // Check if we are configured to prevent sharing addresses
        // between applications by default.
        //
        if (AfdDontShareAddresses) {
            if (AfdIsAddressInUse (endpoint, TRUE)) {
                status = STATUS_ACCESS_DENIED;
                goto complete_state_change;
            }
        }
        //
        // Lack of break is intentional.
        //
    case AFD_WILDCARDADDRESS:
        //
        // Application is binding to a wildcard port, so we leave the 
        // decision with the transport.
        //

        shareAccess = FILE_SHARE_READ|FILE_SHARE_WRITE;
        break;
    case AFD_EXCLUSIVEADDRUSE:
        //
        // Application has requested exclisuve access to the address.
        // We let the transport to decide, but perform a security check
        // so that only admin can take an address for exclusive use.
        // The transport can check for this but not all of them are
        // aware of this new feature.
        //

        if (!endpoint->AdminAccessGranted) {
            status = STATUS_ACCESS_DENIED;
            goto complete_state_change;
        }
        shareAccess = 0;
        break;
    default:
        ASSERT (!"Invalid share access");
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }

    //
    // Set create options.
    //

    options = IO_NO_PARAMETER_CHECKING;
    if (IS_TDI_FORCE_ACCESS_CHECK(endpoint)) {
        options |=  IO_FORCE_ACCESS_CHECK;
    }
    else {
        //
        // If this is an open of a raw address, fail if user is
        // not an admin and transport does not perform security
        // checking itself.
        //
        if ( endpoint->afdRaw && !AfdDisableRawSecurity) {

            if (!endpoint->AdminAccessGranted) {
                status = STATUS_ACCESS_DENIED;
                goto complete_state_change;
            }
        }
    }

    //
    // Allocate memory to hold the EA buffer we'll use to specify the
    // transport address to NtCreateFile.
    //

    eaLength = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                         TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                         tdiAddressLength;

    if (eaLength<=sizeof (eaBuffer)) {
        eaInfo = (PVOID)eaBuffer;
    }
    else {
        try {
#if DBG
            eaInfo = AFD_ALLOCATE_POOL_WITH_QUOTA(
                     NonPagedPool,
                     eaLength,
                     AFD_EA_POOL_TAG
                     );
#else
            eaInfo = AFD_ALLOCATE_POOL_WITH_QUOTA(
                     PagedPool,
                     eaLength,
                     AFD_EA_POOL_TAG
                     );
#endif
            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
            ASSERT ( eaInfo != NULL );
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            goto complete_state_change;
        }

    }


    //
    // Initialize the EA.
    //

    eaInfo->NextEntryOffset = 0;
    eaInfo->Flags = 0;
    eaInfo->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    eaInfo->EaValueLength = (USHORT)tdiAddressLength;

    RtlMoveMemory(
        eaInfo->EaName,
        TdiTransportAddress,
        TDI_TRANSPORT_ADDRESS_LENGTH + 1
        );

    RtlMoveMemory(
        &eaInfo->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1],
        localAddress,
        tdiAddressLength
        );

    //
    // Prepare for opening the address object.
    // We ask to create a kernel handle which is 
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    //
    
    InitializeObjectAttributes(
        &objectAttributes,
        &endpoint->TransportInfo->TransportDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    ASSERT (endpoint->AddressHandle==NULL);
    status = IoCreateFile(
                 &endpoint->AddressHandle,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 shareAccess,                    // share access
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 eaInfo,                         // EaBuffer
                 eaLength,                       // EaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 options
                 );

    if (eaInfo!=(PVOID)eaBuffer) {
        AFD_FREE_POOL (eaInfo, AFD_EA_POOL_TAG);
    }

    if ( !NT_SUCCESS(status) ) {
		//
		// Map error code if application requested address
		// reuse, but the transport denied it (due to
		// other client having this address for exclusive use).
		//
        if (((status==STATUS_SHARING_VIOLATION) ||
                (status==STATUS_ADDRESS_ALREADY_EXISTS)) 
                    &&
            (afdShareAccess==AFD_REUSEADDRESS)) {
            status = STATUS_ACCESS_DENIED;
        }
        goto complete_state_change;
    }
#if DBG
    {
        NTSTATUS    status1;
        OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
        handleInfo.Inherit = FALSE;
        handleInfo.ProtectFromClose = TRUE;
        status1 = ZwSetInformationObject (
                        endpoint->AddressHandle,
                        ObjectHandleFlagInformation,
                        &handleInfo,
                        sizeof (handleInfo)
                        );
        ASSERT (NT_SUCCESS (status1));
    }
#endif

    AfdRecordAddrOpened();

    //
    // Get a pointer to the file object of the address.
    //

    status = ObReferenceObjectByHandle(
                 endpoint->AddressHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 (PVOID *)&endpoint->AddressFileObject,
                 NULL
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }
    AfdRecordAddrRef();


    //
    // Now open the handle for our caller.
    // If transport does not support new TDI_SERVICE_FORCE_ACCESS_CHECK_FLAG
    // we get the maximum possible access for the handle so that helper
    // DLL can do what it wants with it.  Of course this compromises the
    // security, but we can't enforce it without the transport cooperation.
    //
    status = ObOpenObjectByPointer(
                 endpoint->AddressFileObject,
                 OBJ_CASE_INSENSITIVE,
                 NULL,
                 MAXIMUM_ALLOWED,
                 *IoFileObjectType,
                 (KPROCESSOR_MODE)((endpoint->TdiServiceFlags&TDI_SERVICE_FORCE_ACCESS_CHECK)
                    ? Irp->RequestorMode
                    : KernelMode),
                 &addressHandle
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }
    //
    // Remember the device object to which we need to give requests for
    // this address object.  We can't just use the
    // fileObject->DeviceObject pointer because there may be a device
    // attached to the transport protocol.
    //

    endpoint->AddressDeviceObject =
        IoGetRelatedDeviceObject( endpoint->AddressFileObject );

    //
    // Set up indication handlers on the address object.  Only set up
    // appropriate event handlers--don't set unnecessary event handlers.
    //

    status = AfdSetEventHandler(
                 endpoint->AddressFileObject,
                 TDI_EVENT_ERROR,
                 AfdErrorEventHandler,
                 endpoint
                 );
#if DBG
    if ( !NT_SUCCESS(status) ) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdBind: Transport %*ls failed setting TDI_EVENT_ERROR: %lx\n",
                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                    status ));
    }
#endif


    if ( IS_DGRAM_ENDPOINT(endpoint) ) {

        endpoint->EventsActive = AFD_POLL_SEND;

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdBind: Endp %08lX, Active %08lX\n",
                endpoint,
                endpoint->EventsActive
                ));
        }

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_RECEIVE_DATAGRAM,
                     AfdReceiveDatagramEventHandler,
                     endpoint
                     );
#if DBG
        if ( !NT_SUCCESS(status) ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE_DATAGRAM: %lx\n",
                        endpoint->TransportInfo->TransportDeviceName.Length/2,
                        endpoint->TransportInfo->TransportDeviceName.Buffer,
                        status ));
        }
#endif

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_ERROR_EX,
                     AfdErrorExEventHandler,
                     endpoint
                     );

        if ( !NT_SUCCESS(status)) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdBind: Transport %*ls failed setting TDI_EVENT_ERROR_EX: %lx\n",
                            endpoint->TransportInfo->TransportDeviceName.Length/2,
                            endpoint->TransportInfo->TransportDeviceName.Buffer,
                            status ));
        }
		//
		// Remember that the endpoint has been bound to a transport address.
		// (this is the fact even though the call below can fail for some reason)

		endpoint->State = AfdEndpointStateBound;
    } else {

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_DISCONNECT,
                     AfdDisconnectEventHandler,
                     endpoint
                     );
#if DBG
        if ( !NT_SUCCESS(status) ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdBind: Transport %*ls failed setting TDI_EVENT_DISCONNECT: %lx\n",
                        endpoint->TransportInfo->TransportDeviceName.Length/2,
                        endpoint->TransportInfo->TransportDeviceName.Buffer,
                        status ));
        }
#endif


        if ( IS_TDI_BUFFERRING(endpoint) ) {
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE,
                         AfdReceiveEventHandler,
                         endpoint
                         );
#if DBG
            if ( !NT_SUCCESS(status) ) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE: %lx\n",
                            endpoint->TransportInfo->TransportDeviceName.Length/2,
                            endpoint->TransportInfo->TransportDeviceName.Buffer,
                            status ));
            }
#endif
//
// PROBLEM:  Why don't we check for this
//            if (IS_TDI_EXPEDITED (endpoint)) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_RECEIVE_EXPEDITED,
                             AfdReceiveExpeditedEventHandler,
                             endpoint
                             );
#if DBG
                if ( !NT_SUCCESS(status) ) {
                    DbgPrint( "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE_EXPEDITED: %lx\n",
                                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                                    status );
                }
#endif
//            }
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_SEND_POSSIBLE,
                         AfdSendPossibleEventHandler,
                         endpoint
                         );
#if DBG
            if ( !NT_SUCCESS(status) ) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdBind: Transport %*ls failed setting TDI_EVENT_SEND_POSSIBLE: %lx\n",
                            endpoint->TransportInfo->TransportDeviceName.Length/2,
                            endpoint->TransportInfo->TransportDeviceName.Buffer,
                            status ));
            }
#endif

        } else {

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE,
                         AfdBReceiveEventHandler,
                         endpoint
                         );
#if DBG
            if ( !NT_SUCCESS(status) ) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                                "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE: %lx\n",
                                endpoint->TransportInfo->TransportDeviceName.Length/2,
                                endpoint->TransportInfo->TransportDeviceName.Buffer,
                                status ));
            }
#endif

            if (IS_TDI_EXPEDITED (endpoint)) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_RECEIVE_EXPEDITED,
                             AfdBReceiveExpeditedEventHandler,
                             endpoint
                             );
#if DBG
                if ( !NT_SUCCESS(status) ) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                    "AfdBind: Transport %*ls failed setting TDI_EVENT_RECEIVE_EXPEDITED: %lx\n",
                                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                                    status ));
                }
#endif
            }
            if (!AfdDisableChainedReceive) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_CHAINED_RECEIVE,
                             AfdBChainedReceiveEventHandler,
                             endpoint
                             );
                if ( !NT_SUCCESS(status) ) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdBind: Transport %*ls failed setting TDI_EVENT_CHAINED_RECEIVE: %lx\n",
                                        endpoint->TransportInfo->TransportDeviceName.Length/2,
                                        endpoint->TransportInfo->TransportDeviceName.Buffer,
                                        status ));
                }
            }
        }

        if (IS_CROOT_ENDPOINT(endpoint)) {
            PAFD_CONNECTION     connection;
            //
            // Create root connection
            // This one will be used to send data to all
            // leaf nodes (what if there are none -> the transport
            // should handle this.
            //
            status = AfdCreateConnection(
                         &endpoint->TransportInfo->TransportDeviceName,
                         endpoint->AddressHandle,
                         IS_TDI_BUFFERRING(endpoint),
                         endpoint->InLine,
                         endpoint->OwningProcess,
                         &connection
                         );
            if (!NT_SUCCESS (status)) {
                goto complete_state_change;
            }
            //
            // Set up a referenced pointer from the connection to the endpoint.
            // Note that we set up the connection's pointer to the endpoint
            // BEFORE the endpoint's pointer to the connection so that AfdPoll
            // doesn't try to back reference the endpoint from the connection.
            //

            REFERENCE_ENDPOINT( endpoint );
            connection->Endpoint = endpoint;

            //
            // Remember that this is now a connecting type of endpoint, and set
            // up a pointer to the connection in the endpoint.  This is
            // implicitly a referenced pointer.
            //

            endpoint->Common.VirtualCircuit.Connection = connection;
            endpoint->Type = AfdBlockTypeVcConnecting;

            // 
            // The root connection is marked as connected immediately upon
            // creation. See the comment above
            //

            AfdAddConnectedReference (connection);
            endpoint->State = AfdEndpointStateConnected;
            connection->State = AfdConnectionStateConnected;

            ASSERT( IS_TDI_BUFFERRING(endpoint) == connection->TdiBufferring );
        }
		else {
			//
			// Remember that the endpoint has been bound to a transport address.
			// (this is the fact even though the call below can fail for some reason)

			endpoint->State = AfdEndpointStateBound;
		}
    }

    AFD_END_STATE_CHANGE (endpoint);

    TdiBuildQueryInformation(
        Irp,
        endpoint->AddressDeviceObject,
        endpoint->AddressFileObject,
        AfdRestartBindGetAddress,
        endpoint,
        TDI_QUERY_ADDRESS_INFO,
        Irp->MdlAddress
        );

    //
    // Save address handle to use in completion routine
    //
    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = addressHandle;

    IF_DEBUG(BIND) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdBind: endpoint at %p (address at %p, address file at %p).\n",
                     endpoint,
                     endpoint->LocalAddress,
                     endpoint->AddressFileObject ));
    }

    status = AfdIoCallDriver( endpoint, endpoint->AddressDeviceObject, Irp );
    return status;

complete_state_change:

    if (endpoint->AddressFileObject!=NULL) {
        ObDereferenceObject (endpoint->AddressFileObject);
        endpoint->AddressFileObject = NULL;
        ASSERT (endpoint->AddressHandle!=NULL);
    }


    if (endpoint->AddressHandle!=NULL) {
#if DBG
        {
            NTSTATUS    status1;
            OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
            handleInfo.Inherit = FALSE;
            handleInfo.ProtectFromClose = FALSE;
            status1 = ZwSetInformationObject (
                            endpoint->AddressHandle,
                            ObjectHandleFlagInformation,
                            &handleInfo,
                            sizeof (handleInfo)
                            );
            ASSERT (NT_SUCCESS (status1));
        }
#endif
        ZwClose(endpoint->AddressHandle);
        endpoint->AddressHandle = NULL;
        ASSERT (localAddress!=NULL);
    }


    if (localAddress!=NULL) {

        //
        // Need to have exclusive access to make sure no one
        // uses it (to compare) as we are going to free it.
        // We'll use a local variable to free memory
        //

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE);

        endpoint->LocalAddress = NULL;
        endpoint->LocalAddressLength = 0;

        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();
        AFD_FREE_POOL (
            localAddress,
            AFD_LOCAL_ADDRESS_POOL_TAG
            );
    }

complete_wrong_state:

    AFD_END_STATE_CHANGE (endpoint);

    //
    // Free MDL here as IO system can't do it if it is
    // not locked.
    //
    if (Irp->MdlAddress!=NULL) {
        if (Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (Irp->MdlAddress);
        }
        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

complete:

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdBind


NTSTATUS
AfdRestartBindGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint = Context;

    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    //
    // If the request succeeded, save the address in the endpoint so
    // we can use it to handle address sharing.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        ULONG addressLength;
        //
        // First determine the length of the address by walking the MDL
        // chain.
        //

        //
        // We cannot have a chain here.
        //
        ASSERT( Irp->MdlAddress != NULL);
        ASSERT( Irp->MdlAddress->Next == NULL );

        //
        // If the new address is longer than the original address, allocate
        // a new local address buffer.  The +4 accounts for the ActivityCount
        // field that is returned by a query address but is not part
        // of a TRANSPORT_ADDRESS.
        //
        // This cannot happen, in any case msafd does not retry if buffer is
        // insuffucient, so application perceives this as failure to bind
        // or get address.
        //

        addressLength = MmGetMdlByteCount (Irp->MdlAddress) - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);
        if (addressLength>endpoint->LocalAddressLength) {
            addressLength = (ULONG)Irp->IoStatus.Information - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);
        }
        if ( addressLength <= endpoint->LocalAddressLength) {
            status = TdiCopyMdlToBuffer(
                         Irp->MdlAddress,
                         FIELD_OFFSET (TDI_ADDRESS_INFO, Address),
                         endpoint->LocalAddress,
                         0,
                         addressLength,
                         &endpoint->LocalAddressLength
                         );
            ASSERT( NT_SUCCESS(status) );
        }
        else {
            DbgPrint ("AfdRestartBindGetAddress: Endpoint %p transport returned"
                    " address is longer than the original one.\n",
                    endpoint);
            ASSERT (FALSE);
        }

    }
    else {
        //
        //
        //
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
            "AfdRestartBindGetAddress: Transport %*ls failed get address query, status %lx.\n",
                    endpoint->TransportInfo->TransportDeviceName.Length/2,
                    endpoint->TransportInfo->TransportDeviceName.Buffer,
                    Irp->IoStatus.Status));
    }


    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Retreive and return address handle in the information field
    //
    Irp->IoStatus.Information = 
        (ULONG_PTR)IoGetCurrentIrpStackLocation (Irp)->Parameters.DeviceIoControl.Type3InputBuffer;

    AfdCompleteOutstandingIrp( endpoint, Irp );

    return STATUS_SUCCESS;

} // AfdRestartBindGetAddress




NTSTATUS
FASTCALL
AfdGetAddress (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_BIND IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE( );

    Irp->IoStatus.Information = 0;
    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
            sizeof (TDI_ADDRESS_INFO)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    try {
        if (IoAllocateMdl (Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            Irp                 // Irp
                            )==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }
        MmProbeAndLockPages (Irp->MdlAddress,
                                Irp->RequestorMode,
                                IoWriteAccess);
        if (MmGetSystemAddressForMdlSafe (Irp->MdlAddress, HighPagePriority)==NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        goto complete;
    }

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    if ( endpoint->State!=AfdEndpointStateBound &&
             endpoint->State != AfdEndpointStateConnected ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // If the endpoint is connected, use the connection's file object.
    // Otherwise, use the address file object.  Don't use the connection
    // file object if this is a Netbios endpoint because NETBT cannot
    // support this TDI feature.
    //

    if ( endpoint->LocalAddress->Address[0].AddressType !=
                 TDI_ADDRESS_TYPE_NETBIOS &&
            endpoint->Type == AfdBlockTypeVcConnecting &&
            endpoint->State == AfdEndpointStateConnected &&
            ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint)) != NULL)
              ) {
        ASSERT( connection->Type == AfdBlockTypeConnection );
        fileObject = connection->FileObject;
        deviceObject = connection->DeviceObject;
        DEREFERENCE_CONNECTION (connection);
    } else {
        fileObject = endpoint->AddressFileObject;
        deviceObject = endpoint->AddressDeviceObject;
    }

    //
    // Set up the query info to the TDI provider.
    //

    TdiBuildQueryInformation(
        Irp,
        deviceObject,
        fileObject,
        AfdRestartGetAddress,
        endpoint,
        TDI_QUERY_ADDRESS_INFO,
        Irp->MdlAddress
        );

    //
    // Call the TDI provider to get the address.
    //

    return AfdIoCallDriver( endpoint, deviceObject, Irp );

complete:
    if (Irp->MdlAddress!=NULL) {
        if (Irp->MdlAddress->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (Irp->MdlAddress);
        }
        IoFreeMdl (Irp->MdlAddress);
        Irp->MdlAddress = NULL;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdGetAddress


NTSTATUS
AfdRestartGetAddress (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint = Context;

    //
    // If the request succeeded, save the address in the endpoint so
    // we can use it to handle address sharing.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        ULONG addressLength;
        //
        // First determine the length of the address by walking the MDL
        // chain.
        //

        //
        // We cannot have a chain here.
        //
        ASSERT( Irp->MdlAddress != NULL);
        ASSERT( Irp->MdlAddress->Next == NULL );

        //
        // If the new address is longer than the original address, allocate
        // a new local address buffer.  The +4 accounts for the ActivityCount
        // field that is returned by a query address but is not part
        // of a TRANSPORT_ADDRESS.
        //
        // This cannot happen, in any case msafd does not retry if buffer is
        // insuffucient, so application perceives this as failure to bind
        // or get address.
        //

        addressLength = MmGetMdlByteCount (Irp->MdlAddress) - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);

        if (addressLength>endpoint->LocalAddressLength) {
            addressLength = (ULONG)Irp->IoStatus.Information - FIELD_OFFSET (TDI_ADDRESS_INFO, Address);
        }
        if ( addressLength <= endpoint->LocalAddressLength) {
            status = TdiCopyMdlToBuffer(
                         Irp->MdlAddress,
                         FIELD_OFFSET (TDI_ADDRESS_INFO, Address),
                         endpoint->LocalAddress,
                         0,
                         addressLength,
                         &endpoint->LocalAddressLength
                         );
            ASSERT( NT_SUCCESS(status) );
        }
        else {
            DbgPrint ("AfdRestartGetAddress: Endpoint %p transport returned"
                    " address is longer than the original one.\n",
                    endpoint);
            ASSERT (FALSE);
        }
    }

    //
    // If pending has been returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    return STATUS_SUCCESS;

} // AfdRestartGetAddress

const CHAR ZeroNodeAddress[6]={0};
const CHAR ZeroIP6Address[16]={0};


BOOLEAN
AfdAreTransportAddressesEqual (
    IN PTRANSPORT_ADDRESS EndpointAddress,
    IN ULONG EndpointAddressLength,
    IN PTRANSPORT_ADDRESS RequestAddress,
    IN ULONG RequestAddressLength,
    IN BOOLEAN HonorWildcardIpPortInEndpointAddress
    )
{
    //
    // Make sure we can safely access the address type and length fields
    // 
    if ((EndpointAddressLength<(ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,Address[0].Address))
            || (RequestAddressLength<(ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,Address[0].Address)) ) {
        return FALSE;
    }
    
    if ( EndpointAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP &&
         RequestAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP ) {

        TDI_ADDRESS_IP UNALIGNED *ipEndpointAddress;
        TDI_ADDRESS_IP UNALIGNED *ipRequestAddress;

        //
        // They are both IP addresses.  If the ports are the same, and
        // the IP addresses are or _could_be_ the same, then the addresses
        // are equal.  The "cound be" part is true if either IP address
        // is 0, the "wildcard" IP address.
        //

        ipEndpointAddress = (TDI_ADDRESS_IP UNALIGNED *)&EndpointAddress->Address[0].Address[0];
        ipRequestAddress = (TDI_ADDRESS_IP UNALIGNED *)&RequestAddress->Address[0].Address[0];

        if ( (EndpointAddressLength>=(ULONG)FIELD_OFFSET (TA_IP_ADDRESS, Address[0].Address[0].sin_zero)) &&
                (RequestAddressLength>=(ULONG)FIELD_OFFSET (TA_IP_ADDRESS, Address[0].Address[0].sin_zero)) &&
                ( ipEndpointAddress->sin_port == ipRequestAddress->sin_port ||
               ( HonorWildcardIpPortInEndpointAddress &&
                 ipEndpointAddress->sin_port == 0 ) ) &&
             ( ipEndpointAddress->in_addr == ipRequestAddress->in_addr ||
               ipEndpointAddress->in_addr == 0 || ipRequestAddress->in_addr == 0 ) ) {

            return TRUE;
        }

        //
        // The addresses are not equal.
        //

        return FALSE;
    }

    if ( EndpointAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP6 &&
         RequestAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP6 ) {

        TDI_ADDRESS_IP6 UNALIGNED *ipEndpointAddress;
        TDI_ADDRESS_IP6 UNALIGNED *ipRequestAddress;
        C_ASSERT (sizeof (ZeroIP6Address)==sizeof (ipEndpointAddress->sin6_addr));

        //
        // They are both IPv6 addresses.  If the ports are the same, and
        // the IPv6 addresses are or _could_be_ the same, then the addresses
        // are equal.  The "could be" part is true if either IPv6 address
        // is the unspecified IPv6 address.
        //

        ipEndpointAddress = (TDI_ADDRESS_IP6 UNALIGNED *)&EndpointAddress->Address[0].Address;
        ipRequestAddress = (TDI_ADDRESS_IP6 UNALIGNED *)&RequestAddress->Address[0].Address;

        if ( (EndpointAddressLength>=sizeof (TA_IP6_ADDRESS)) &&
             (RequestAddressLength>=sizeof (TA_IP6_ADDRESS)) &&

             (ipEndpointAddress->sin6_port == ipRequestAddress->sin6_port ||
               ( HonorWildcardIpPortInEndpointAddress &&
                 ipEndpointAddress->sin6_port == 0 ) ) &&

             ( RtlEqualMemory(&ipEndpointAddress->sin6_addr,
                              &ipRequestAddress->sin6_addr,
                              sizeof (ipEndpointAddress->sin6_addr)) ||
               RtlEqualMemory(&ipEndpointAddress->sin6_addr,
                              ZeroIP6Address,
                              sizeof (ipEndpointAddress->sin6_addr)) ||
               RtlEqualMemory(&ipRequestAddress->sin6_addr,
                              ZeroIP6Address,
                              sizeof (ipEndpointAddress->sin6_addr)) ) ) {

            return TRUE;
        }

        //
        // The addresses are not equal.
        //

        return FALSE;
    }

    if ( EndpointAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IPX &&
         RequestAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IPX ) {

        TDI_ADDRESS_IPX UNALIGNED *ipxEndpointAddress;
        TDI_ADDRESS_IPX UNALIGNED *ipxRequestAddress;
        C_ASSERT (sizeof (ZeroNodeAddress)==sizeof (ipxEndpointAddress->NodeAddress));

        ipxEndpointAddress = (TDI_ADDRESS_IPX UNALIGNED *)&EndpointAddress->Address[0].Address[0];
        ipxRequestAddress = (TDI_ADDRESS_IPX UNALIGNED *)&RequestAddress->Address[0].Address[0];

        //
        // They are both IPX addresses.  Check the network addresses
        // first--if they don't match and both != 0, the addresses
        // are different.
        //

        if ( (EndpointAddressLength<sizeof (TA_IPX_ADDRESS)) ||
                (RequestAddressLength<sizeof (TA_IPX_ADDRESS)) ||
            ( ipxEndpointAddress->NetworkAddress != ipxRequestAddress->NetworkAddress &&
             ipxEndpointAddress->NetworkAddress != 0 &&
             ipxRequestAddress->NetworkAddress != 0 )) {
            return FALSE;
        }

        //
        // Now check the node addresses.  Again, if they don't match
        // and neither is 0, the addresses don't match.
        //

        ASSERT( ZeroNodeAddress[0] == 0 );
        ASSERT( ZeroNodeAddress[1] == 0 );
        ASSERT( ZeroNodeAddress[2] == 0 );
        ASSERT( ZeroNodeAddress[3] == 0 );
        ASSERT( ZeroNodeAddress[4] == 0 );
        ASSERT( ZeroNodeAddress[5] == 0 );

        if ( !RtlEqualMemory(
                 ipxEndpointAddress->NodeAddress,
                 ipxRequestAddress->NodeAddress,
                 6 ) &&
             !RtlEqualMemory(
                 ipxEndpointAddress->NodeAddress,
                 ZeroNodeAddress,
                 6 ) &&
             !RtlEqualMemory(
                 ipxRequestAddress->NodeAddress,
                 ZeroNodeAddress,
                 6 ) ) {
            return FALSE;
        }

        //
        // Finally, make sure the socket numbers match.
        //

        if ( ipxEndpointAddress->Socket != ipxRequestAddress->Socket ) {
            return FALSE;
        }

        return TRUE;

    }

    //
    // If either address is not of a known address type, then do a
    // simple memory compare. (Don't go out of bounds on either
    // structure).
    //
    if (RequestAddressLength>EndpointAddressLength)
        RequestAddressLength = EndpointAddressLength;

    return (EndpointAddressLength == RtlCompareMemory(
                                   EndpointAddress,
                                   RequestAddress,
                                   RequestAddressLength ) );
} // AfdAreTransportAddressesEqual



BOOLEAN
AfdIsAddressInUse (
    PAFD_ENDPOINT   Endpoint,
    BOOLEAN         OtherProcessesOnly
    )
{
    PLIST_ENTRY listEntry;
    BOOLEAN     res = FALSE;

    PAGED_CODE ();

    //
    // We use shared access to the resource because we only need to make
    // sure that endpoint list is not modified while we are accessing it
    // and existing local addresses are not removed (both of these
    // operations are performed under exclusive access).
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // Walk the global list of endpoints,
    // and compare this address againat the address on each endpoint.
    //

    for ( listEntry = AfdEndpointListHead.Flink;
          listEntry != &AfdEndpointListHead;
          listEntry = listEntry->Flink ) {

        PAFD_ENDPOINT compareEndpoint;

        compareEndpoint = CONTAINING_RECORD(
                              listEntry,
                              AFD_ENDPOINT,
                              GlobalEndpointListEntry
                              );

        ASSERT( IS_AFD_ENDPOINT_TYPE( compareEndpoint ) );

        //
        // Check whether the endpoint has a local address, whether
        // the endpoint has been disconnected, whether the
        // endpoint is in the process of closing, and whether
        // it represents accepted connection.  If any of these
        // is true, don't compare addresses with this endpoint.
        //

        if (compareEndpoint!=Endpoint &&
                 compareEndpoint->LocalAddress != NULL &&
                 ( (compareEndpoint->DisconnectMode &
                        (AFD_PARTIAL_DISCONNECT_SEND |
                         AFD_ABORTIVE_DISCONNECT) ) == 0 ) &&
                 (compareEndpoint->State != AfdEndpointStateClosing) &&
                 ((compareEndpoint->State != AfdEndpointStateConnected)
                    || (compareEndpoint->Type!=AfdBlockTypeVcConnecting)
                    || (compareEndpoint->Common.VcConnecting.ListenEndpoint==NULL)) &&
                 (!OtherProcessesOnly ||
                    compareEndpoint->OwningProcess!=Endpoint->OwningProcess)
                 ) {

            //
            // Compare the bits in the endpoint's address and the
            // address we're attempting to bind to.  Note that we
            // also compare the transport device names on the
            // endpoints, as it is legal to bind to the same address
            // on different transports (e.g.  bind to same port in
            // TCP and UDP).  We can just compare the transport
            // device name pointers because unique names are stored
            // globally.
            //

            if ( compareEndpoint->LocalAddressLength == Endpoint->LocalAddressLength &&

                 AfdAreTransportAddressesEqual(
                     compareEndpoint->LocalAddress,
                     compareEndpoint->LocalAddressLength,
                     Endpoint->LocalAddress,
                     Endpoint->LocalAddressLength,
                     FALSE
                     )

                 &&

                 Endpoint->TransportInfo ==
                     compareEndpoint->TransportInfo ) {

                //
                // The addresses are equal.
                //
                res = TRUE;
                break;
            }
        }
    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\afddata.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    afddata.c

Abstract:

    This module contains global data for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999   NT5.0 Optimization changes

--*/

#include "afdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfdInitializeData )
#endif

PDEVICE_OBJECT AfdDeviceObject;

LIST_ENTRY AfdEndpointListHead;
LIST_ENTRY AfdConstrainedEndpointListHead;

LIST_ENTRY AfdPollListHead;
AFD_QSPIN_LOCK AfdPollListLock;

LIST_ENTRY AfdTransportInfoListHead;
KEVENT     AfdContextWaitEvent;

PKPROCESS AfdSystemProcess;

//
// Global data which must always be in nonpaged pool,
// even when the driver is paged out (resource, lookaside lists).
//
PAFD_GLOBAL_DATA AfdGlobalData;

//
// Globals for dealing with AFD's executive worker thread.
//

LIST_ENTRY AfdWorkQueueListHead;
BOOLEAN AfdWorkThreadRunning = FALSE;
PIO_WORKITEM AfdWorkQueueItem;

//
// Globals to track the buffers used by AFD.
//

ULONG AfdLargeBufferListDepth;
ULONG AfdMediumBufferListDepth;
ULONG AfdSmallBufferListDepth;
ULONG AfdBufferTagListDepth;

CLONG AfdLargeBufferSize;   // default == AfdBufferLengthForOnePage
CLONG AfdMediumBufferSize = AFD_DEFAULT_MEDIUM_BUFFER_SIZE;
CLONG AfdSmallBufferSize = AFD_DEFAULT_SMALL_BUFFER_SIZE;
CLONG AfdBufferTagSize = AFD_DEFAULT_TAG_BUFFER_SIZE;

ULONG AfdCacheLineSize;
CLONG AfdBufferLengthForOnePage;
ULONG AfdBufferOverhead;
ULONG AfdBufferAlignment;
ULONG AfdAlignmentTableSize;
ULONG AfdAlignmentOverhead;

//
// Globals for tuning TransmitFile().
//

LIST_ENTRY AfdQueuedTransmitFileListHead;
AFD_QSPIN_LOCK AfdQueuedTransmitFileSpinLock;
ULONG AfdActiveTransmitFileCount;
ULONG AfdMaxActiveTransmitFileCount;
ULONG AfdDefaultTransmitWorker = AFD_DEFAULT_TRANSMIT_WORKER;

//
// Various pieces of configuration information, with default values.
//

CLONG AfdStandardAddressLength = AFD_DEFAULT_STD_ADDRESS_LENGTH;
CCHAR AfdIrpStackSize = AFD_DEFAULT_IRP_STACK_SIZE;
CCHAR AfdPriorityBoost = AFD_DEFAULT_PRIORITY_BOOST;

ULONG AfdFastSendDatagramThreshold = AFD_FAST_SEND_DATAGRAM_THRESHOLD;
ULONG AfdTPacketsCopyThreshold = AFD_TPACKETS_COPY_THRESHOLD;

CLONG AfdReceiveWindowSize;
CLONG AfdSendWindowSize;

CLONG AfdTransmitIoLength;
CLONG AfdMaxFastTransmit = AFD_DEFAULT_MAX_FAST_TRANSMIT;
CLONG AfdMaxFastCopyTransmit = AFD_DEFAULT_MAX_FAST_COPY_TRANSMIT;


ULONG AfdEndpointsOpened = 0;
ULONG AfdEndpointsCleanedUp = 0;
ULONG AfdEndpointsClosed = 0;
ULONG AfdEndpointsFreeing = 0;
ULONG AfdConnectionsFreeing = 0;

BOOLEAN AfdIgnorePushBitOnReceives = FALSE;

BOOLEAN AfdEnableDynamicBacklog = AFD_DEFAULT_ENABLE_DYNAMIC_BACKLOG;
LONG AfdMinimumDynamicBacklog = AFD_DEFAULT_MINIMUM_DYNAMIC_BACKLOG;
LONG AfdMaximumDynamicBacklog = AFD_DEFAULT_MAXIMUM_DYNAMIC_BACKLOG;
LONG AfdDynamicBacklogGrowthDelta = AFD_DEFAULT_DYNAMIC_BACKLOG_GROWTH_DELTA;

PSECURITY_DESCRIPTOR AfdAdminSecurityDescriptor = NULL;
BOOLEAN AfdDisableRawSecurity = FALSE;
BOOLEAN AfdDontShareAddresses = FALSE;

BOOLEAN AfdDisableDirectSuperAccept = FALSE;
BOOLEAN AfdDisableChainedReceive = FALSE;
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
BOOLEAN AfdUseTdiSendAndDisconnect = TRUE;
#endif //TDI_SERVICE_SEND_AND_DISCONNECT

ULONG   AfdDefaultTpInfoElementCount = 3;
//
// Data for transport address lists and queued change queries
//
HANDLE          AfdBindingHandle = NULL;
LIST_ENTRY      AfdAddressEntryList;
LIST_ENTRY      AfdAddressChangeList;
PERESOURCE      AfdAddressListLock = NULL;
AFD_QSPIN_LOCK  AfdAddressChangeLock;
AFD_WORK_ITEM   AfdPnPDeregisterWorker;



IO_STATUS_BLOCK AfdDontCareIoStatus;
// Holds TDI connect timeout (-1).
const LARGE_INTEGER AfdInfiniteTimeout = {-1,-1};

SLIST_HEADER    AfdLRList;
KDPC            AfdLRListDpc;
KTIMER          AfdLRListTimer;
AFD_WORK_ITEM   AfdLRListWorker;
LONG            AfdLRListCount;

SLIST_HEADER    AfdLRFileMdlList;
AFD_LR_LIST_ITEM AfdLRFileMdlListItem;


//
// Global which holds AFD's discardable code handle, and a BOOLEAN
// that tells whether AFD is loaded.
//

PVOID AfdDiscardableCodeHandle;
PKEVENT AfdLoaded = NULL;
AFD_WORK_ITEM AfdUnloadWorker;
BOOLEAN AfdVolatileConfig=0;
HANDLE AfdParametersNotifyHandle;
WORK_QUEUE_ITEM AfdParametersNotifyWorker;
PKEVENT AfdParametersUnloadEvent = NULL;

// SAN code segment handle, loaded only when SAN support is needed by the app.
HANDLE AfdSanCodeHandle = NULL;
// List of SAN helper endpoints
LIST_ENTRY AfdSanHelperList;
// San helper endpoint for special service process used for socket handle
// duplication and provider change notifications.
PAFD_ENDPOINT   AfdSanServiceHelper = NULL;
// PID of service process.
HANDLE  AfdSanServicePid = NULL;
// Completion object type (kernel does not export this constant)
POBJECT_TYPE IoCompletionObjectType = NULL;
// Provider list sequence number.
LONG AfdSanProviderListSeqNum = 0;

FAST_IO_DISPATCH AfdFastIoDispatch =
{
    sizeof (FAST_IO_DISPATCH), // SizeOfFastIoDispatch
    NULL,                      // FastIoCheckIfPossible
    AfdFastIoRead,             // FastIoRead
    AfdFastIoWrite,            // FastIoWrite
    NULL,                      // FastIoQueryBasicInfo
    NULL,                      // FastIoQueryStandardInfo
    NULL,                      // FastIoLock
    NULL,                      // FastIoUnlockSingle
    AfdSanFastUnlockAll,       // FastIoUnlockAll
    NULL,                      // FastIoUnlockAllByKey
    AfdFastIoDeviceControl     // FastIoDeviceControl
};

//
// Lookup table to verify incoming IOCTL codes.
//

ULONG AfdIoctlTable[AFD_NUM_IOCTLS] =
        {
            IOCTL_AFD_BIND,
            IOCTL_AFD_CONNECT,
            IOCTL_AFD_START_LISTEN,
            IOCTL_AFD_WAIT_FOR_LISTEN,
            IOCTL_AFD_ACCEPT,
            IOCTL_AFD_RECEIVE,
            IOCTL_AFD_RECEIVE_DATAGRAM,
            IOCTL_AFD_SEND,
            IOCTL_AFD_SEND_DATAGRAM,
            IOCTL_AFD_POLL,
            IOCTL_AFD_PARTIAL_DISCONNECT,
            IOCTL_AFD_GET_ADDRESS,
            IOCTL_AFD_QUERY_RECEIVE_INFO,
            IOCTL_AFD_QUERY_HANDLES,
            IOCTL_AFD_SET_INFORMATION,
            IOCTL_AFD_GET_REMOTE_ADDRESS,
            IOCTL_AFD_GET_CONTEXT,
            IOCTL_AFD_SET_CONTEXT,
            IOCTL_AFD_SET_CONNECT_DATA,
            IOCTL_AFD_SET_CONNECT_OPTIONS,
            IOCTL_AFD_SET_DISCONNECT_DATA,
            IOCTL_AFD_SET_DISCONNECT_OPTIONS,
            IOCTL_AFD_GET_CONNECT_DATA,
            IOCTL_AFD_GET_CONNECT_OPTIONS,
            IOCTL_AFD_GET_DISCONNECT_DATA,
            IOCTL_AFD_GET_DISCONNECT_OPTIONS,
            IOCTL_AFD_SIZE_CONNECT_DATA,
            IOCTL_AFD_SIZE_CONNECT_OPTIONS,
            IOCTL_AFD_SIZE_DISCONNECT_DATA,
            IOCTL_AFD_SIZE_DISCONNECT_OPTIONS,
            IOCTL_AFD_GET_INFORMATION,
            IOCTL_AFD_TRANSMIT_FILE,
            IOCTL_AFD_SUPER_ACCEPT,
            IOCTL_AFD_EVENT_SELECT,
            IOCTL_AFD_ENUM_NETWORK_EVENTS,
            IOCTL_AFD_DEFER_ACCEPT,
            IOCTL_AFD_WAIT_FOR_LISTEN_LIFO,
            IOCTL_AFD_SET_QOS,
            IOCTL_AFD_GET_QOS,
            IOCTL_AFD_NO_OPERATION,
            IOCTL_AFD_VALIDATE_GROUP,
            IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA,
            IOCTL_AFD_ROUTING_INTERFACE_QUERY,
            IOCTL_AFD_ROUTING_INTERFACE_CHANGE,
            IOCTL_AFD_ADDRESS_LIST_QUERY,
            IOCTL_AFD_ADDRESS_LIST_CHANGE,
            IOCTL_AFD_JOIN_LEAF,
			0,                         // AFD_TRANSPORT_IOCTL
            IOCTL_AFD_TRANSMIT_PACKETS,
            IOCTL_AFD_SUPER_CONNECT,
            IOCTL_AFD_SUPER_DISCONNECT,
            IOCTL_AFD_RECEIVE_MESSAGE,


			//
			// SAN Ioctls
			//
            IOCTL_AFD_SWITCH_CEMENT_SAN,
            IOCTL_AFD_SWITCH_SET_EVENTS,
            IOCTL_AFD_SWITCH_RESET_EVENTS,
            IOCTL_AFD_SWITCH_CONNECT_IND,
            IOCTL_AFD_SWITCH_CMPL_ACCEPT,
            IOCTL_AFD_SWITCH_CMPL_REQUEST,
            IOCTL_AFD_SWITCH_CMPL_IO,
            IOCTL_AFD_SWITCH_REFRESH_ENDP,
            IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR,
            IOCTL_AFD_SWITCH_ACQUIRE_CTX,
            IOCTL_AFD_SWITCH_TRANSFER_CTX,
            IOCTL_AFD_SWITCH_GET_SERVICE_PID,
            IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS,
            IOCTL_AFD_SWITCH_PROVIDER_CHANGE,
            IOCTL_AFD_SWITCH_ADDRLIST_CHANGE
        };

//
// Table of IRP based IOCTLS.
//
PAFD_IRP_CALL AfdIrpCallDispatch[AFD_NUM_IOCTLS]= {
     AfdBind,                  // IOCTL_AFD_BIND
     AfdConnect,               // IOCTL_AFD_CONNECT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_START_LISTEN,
     AfdWaitForListen,         // IOCTL_AFD_WAIT_FOR_LISTEN,
     AfdAccept,                // IOCTL_AFD_ACCEPT,
     AfdReceive,               // IOCTL_AFD_RECEIVE,
     AfdReceiveDatagram,       // IOCTL_AFD_RECEIVE_DATAGRAM,
     AfdSend,                  // IOCTL_AFD_SEND,
     AfdSendDatagram,          // IOCTL_AFD_SEND_DATAGRAM,
     AfdPoll,                  // IOCTL_AFD_POLL,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_PARTIAL_DISCONNECT,
     AfdGetAddress,            // IOCTL_AFD_GET_ADDRESS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_QUERY_RECEIVE_INFO,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_QUERY_HANDLES,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_INFORMATION,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_REMOTE_ADDRESS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_CONTEXT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_CONTEXT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_CONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_CONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_DISCONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SET_DISCONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_CONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_CONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_DISCONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_DISCONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_CONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_CONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_DISCONNECT_DATA,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SIZE_DISCONNECT_OPTIONS,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_INFORMATION,
     AfdTransmitFile,          // IOCTL_AFD_TRANSMIT_FILE,
     AfdSuperAccept,           // IOCTL_AFD_SUPER_ACCEPT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_EVENT_SELECT,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_ENUM_NETWORK_EVENTS,
     AfdDeferAccept,           // IOCTL_AFD_DEFER_ACCEPT,
     AfdWaitForListen,         // IOCTL_AFD_WAIT_FOR_LISTEN_LIFO,
     AfdSetQos,                // IOCTL_AFD_SET_QOS,
     AfdGetQos,                // IOCTL_AFD_GET_QOS,
     AfdNoOperation,           // IOCTL_AFD_NO_OPERATION,
     AfdValidateGroup,         // IOCTL_AFD_VALIDATE_GROUP,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA
     AfdDispatchImmediateIrp,  // IOCTL_AFD_ROUTING_INTERFACE_QUERY,
     AfdRoutingInterfaceChange,// IOCTL_AFD_ROUTING_INTERFACE_CHANGE,
     AfdDispatchImmediateIrp,  // IOCTL_AFD_ADDRESS_LIST_QUERY,
     AfdAddressListChange,     // IOCTL_AFD_ADDRESS_LIST_CHANGE,
     AfdJoinLeaf,              // IOCTL_AFD_JOIN_LEAF,
	 NULL,                     // IOCTL_AFD_TRANSPORT_IOCTL,
     AfdTransmitPackets,       // IOCTL_AFD_TRANSMIT_PACKETS 
     AfdSuperConnect,          // IOCTL_AFD_SUPER_CONNECT
     AfdSuperDisconnect,       // IOCTL_AFD_SUPER_DISCONNECT
     AfdReceiveDatagram,       // IOCTL_AFD_RECEIVE_MESSAGE

     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CEMENT_SAN
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_SET_EVENTS
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_RESET_EVENTS
     AfdSanConnectHandler,     // IOCTL_AFD_SWITCH_CONNECT_IND
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CMPL_ACCEPT
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CMPL_REQUEST
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_CMPL_IO
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_REFRESH_ENDP
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR
     AfdSanAcquireContext,     // IOCTL_AFD_SWITCH_ACQUIRE_CTX
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_TRANSFER_CTX
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_GET_SERVICE_PID
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS
     AfdDispatchImmediateIrp,  // IOCTL_AFD_SWITCH_PROVIDER_CHANGE
     AfdSanAddrListChange      // IOCTL_AFD_SWITCH_ADDRLIST_CHANGE
    };

//
// Table of immediate IOCTLS (can never be pended).
//
PAFD_IMMEDIATE_CALL AfdImmediateCallDispatch[AFD_NUM_IOCTLS]= {
     NULL,                     // IOCTL_AFD_BIND
     NULL,                     // IOCTL_AFD_CONNECT,
     AfdStartListen,           // IOCTL_AFD_START_LISTEN,
     NULL,                     // IOCTL_AFD_WAIT_FOR_LISTEN,
     NULL,                     // IOCTL_AFD_ACCEPT,
     NULL,                     // IOCTL_AFD_RECEIVE,
     NULL,                     // IOCTL_AFD_RECEIVE_DATAGRAM,
     NULL,                     // IOCTL_AFD_SEND,
     NULL,                     // IOCTL_AFD_SEND_DATAGRAM,
     NULL,                     // IOCTL_AFD_POLL,
     AfdPartialDisconnect,     // IOCTL_AFD_PARTIAL_DISCONNECT,
     NULL,                     // IOCTL_AFD_GET_ADDRESS,
     AfdQueryReceiveInformation,// IOCTL_AFD_QUERY_RECEIVE_INFO,
     AfdQueryHandles,          // IOCTL_AFD_QUERY_HANDLES,
     AfdSetInformation,        // IOCTL_AFD_SET_INFORMATION,
     AfdGetRemoteAddress,      // IOCTL_AFD_GET_REMOTE_ADDRESS,
     AfdGetContext,            // IOCTL_AFD_GET_CONTEXT,
     AfdSetContext,            // IOCTL_AFD_SET_CONTEXT,
     AfdSetConnectData,        // IOCTL_AFD_SET_CONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SET_CONNECT_OPTIONS,
     AfdSetConnectData,        // IOCTL_AFD_SET_DISCONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SET_DISCONNECT_OPTIONS,
     AfdGetConnectData,        // IOCTL_AFD_GET_CONNECT_DATA,
     AfdGetConnectData,        // IOCTL_AFD_GET_CONNECT_OPTIONS,
     AfdGetConnectData,        // IOCTL_AFD_GET_DISCONNECT_DATA,
     AfdGetConnectData,        // IOCTL_AFD_GET_DISCONNECT_OPTIONS,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_CONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_CONNECT_OPTIONS,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_DISCONNECT_DATA,
     AfdSetConnectData,        // IOCTL_AFD_SIZE_DISCONNECT_OPTIONS,
     AfdGetInformation,        // IOCTL_AFD_GET_INFORMATION,
     NULL,                     // IOCTL_AFD_TRANSMIT_FILE,
     NULL,                     // IOCTL_AFD_SUPER_ACCEPT,
     AfdEventSelect,           // IOCTL_AFD_EVENT_SELECT,
     AfdEnumNetworkEvents,     // IOCTL_AFD_ENUM_NETWORK_EVENTS,
     NULL,                     // IOCTL_AFD_DEFER_ACCEPT,
     NULL,                     // IOCTL_AFD_WAIT_FOR_LISTEN_LIFO,
     NULL,                     // IOCTL_AFD_SET_QOS,
     NULL,                     // IOCTL_AFD_GET_QOS,
     NULL,                     // IOCTL_AFD_NO_OPERATION,
     NULL,                     // IOCTL_AFD_VALIDATE_GROUP,
     AfdGetUnacceptedConnectData,// IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA
     AfdRoutingInterfaceQuery, // IOCTL_AFD_ROUTING_INTERFACE_QUERY,
     NULL,                     // IOCTL_AFD_ROUTING_INTERFACE_CHANGE,
     AfdAddressListQuery,      // IOCTL_AFD_ADDRESS_LIST_QUERY,
     NULL,                     // IOCTL_AFD_ADDRESS_LIST_CHANGE,
     NULL,                     // IOCTL_AFD_JOIN_LEAF,
	 NULL,                     // IOCTL_AFD_TRANSPORT_IOCTL,
     NULL,                     // IOCTL_AFD_TRANSMIT_PACKETS 
     NULL,                     // IOCTL_AFD_SUPER_CONNECT
     NULL,                     // IOCTL_AFD_SUPER_DISCONNECT
     NULL,                     // IOCTL_AFD_RECEIVE_MESSAGE

     AfdSanFastCementEndpoint, // IOCTL_AFD_SWITCH_CEMENT_SAN
     AfdSanFastSetEvents,      // IOCTL_AFD_SWITCH_SET_EVENTS
     AfdSanFastResetEvents,    // IOCTL_AFD_SWITCH_RESET_EVENTS
     NULL,                     // IOCTL_AFD_SWITCH_CONNECT_IND
     AfdSanFastCompleteAccept, // IOCTL_AFD_SWITCH_CMPL_ACCEPT
     AfdSanFastCompleteRequest,// IOCTL_AFD_SWITCH_CMPL_REQUEST
     AfdSanFastCompleteIo,     // IOCTL_AFD_SWITCH_CMPL_IO
     AfdSanFastRefreshEndpoint,// IOCTL_AFD_SWITCH_REFRESH_ENDP
     AfdSanFastGetPhysicalAddr,// IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR
     NULL,                     // IOCTL_AFD_SWITCH_ACQUIRE_CTX
     AfdSanFastTransferCtx,    // IOCTL_AFD_SWITCH_TRANSFER_CTX
     AfdSanFastGetServicePid,  // IOCTL_AFD_SWITCH_GET_SERVICE_PID
     AfdSanFastSetServiceProcess,// IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS
     AfdSanFastProviderChange, // IOCTL_AFD_SWITCH_PROVIDER_CHANGE
     NULL                      // IOCTL_AFD_SWITCH_ADDRLIST_CHANGE
    };
//
// Make sure the above IOCTLs have method neither.
//
C_ASSERT ((IOCTL_AFD_START_LISTEN & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_PARTIAL_DISCONNECT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_QUERY_RECEIVE_INFO & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_QUERY_HANDLES & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_INFORMATION & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_REMOTE_ADDRESS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_CONTEXT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_CONTEXT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_CONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_DISCONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SET_DISCONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_CONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_DISCONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_DISCONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_CONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_DISCONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SIZE_DISCONNECT_OPTIONS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_INFORMATION & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_EVENT_SELECT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_ENUM_NETWORK_EVENTS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_GET_UNACCEPTED_CONNECT_DATA & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_ADDRESS_LIST_QUERY & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_ROUTING_INTERFACE_QUERY & 3) == METHOD_NEITHER);

C_ASSERT ((IOCTL_AFD_SWITCH_CEMENT_SAN & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_SET_EVENTS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_RESET_EVENTS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_CMPL_ACCEPT & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_CMPL_REQUEST & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_CMPL_IO & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_REFRESH_ENDP & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_GET_PHYSICAL_ADDR & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_TRANSFER_CTX & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_GET_SERVICE_PID & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_SET_SERVICE_PROCESS & 3) == METHOD_NEITHER);
C_ASSERT ((IOCTL_AFD_SWITCH_PROVIDER_CHANGE & 3) == METHOD_NEITHER);


#if DBG
ULONG AfdDebug = 0;
ULONG AfdLocksAcquired = 0;
BOOLEAN AfdUsePrivateAssert = TRUE;
#endif


//
// Some counters used for monitoring performance.  These are not enabled
// in the normal build.
//

#if AFD_PERF_DBG

CLONG AfdFullReceiveIndications = 0;
CLONG AfdPartialReceiveIndications = 0;

CLONG AfdFullReceiveDatagramIndications = 0;
CLONG AfdPartialReceiveDatagramIndications = 0;

CLONG AfdFastSendsSucceeded = 0;
CLONG AfdFastSendsFailed = 0;
CLONG AfdFastReceivesSucceeded = 0;
CLONG AfdFastReceivesFailed = 0;

CLONG AfdFastSendDatagramsSucceeded = 0;
CLONG AfdFastSendDatagramsFailed = 0;
CLONG AfdFastReceiveDatagramsSucceeded = 0;
CLONG AfdFastReceiveDatagramsFailed = 0;

CLONG AfdFastReadsSucceeded = 0;
CLONG AfdFastReadsFailed = 0;
CLONG AfdFastWritesSucceeded = 0;
CLONG AfdFastWritesFailed = 0;

CLONG AfdFastTfSucceeded=0;
CLONG AfdFastTfFailed=0;
CLONG AfdFastTfReadFailed=0;

CLONG AfdTPWorkersExecuted=0;
CLONG AfdTPRequests=0;

BOOLEAN AfdDisableFastIo = FALSE;
BOOLEAN AfdDisableConnectionReuse = FALSE;

#endif  // AFD_PERF_DBG

#if AFD_KEEP_STATS

AFD_QUOTA_STATS AfdQuotaStats;
AFD_HANDLE_STATS AfdHandleStats;
AFD_QUEUE_STATS AfdQueueStats;
AFD_CONNECTION_STATS AfdConnectionStats;

#endif  // AFD_KEEP_STATS

#ifdef _WIN64
QOS32 AfdDefaultQos32 =
        {
            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },

            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },
        };
#endif

QOS AfdDefaultQos =
        {
            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },

            {                           // SendingFlowspec
                (ULONG)-1,                  // TokenRate
                (ULONG)-1,                  // TokenBucketSize
                (ULONG)-1,                  // PeakBandwidth
                (ULONG)-1,                  // Latency
                (ULONG)-1,                  // DelayVariation
                SERVICETYPE_BESTEFFORT,     // ServiceType
                (ULONG)-1,                  // MaxSduSize
                (ULONG)-1                   // MinimumPolicedSize
            },
        };

VOID
AfdInitializeData (
    VOID
    )
{
    PAGED_CODE( );

#if DBG || REFERENCE_DEBUG
    AfdInitializeDebugData( );
#endif

    //
    // Initialize global spin locks and lists.
    //

    AfdInitializeSpinLock( &AfdPollListLock );

    //
    // Initialize global lists.
    //

    InitializeListHead( &AfdEndpointListHead );
    InitializeListHead( &AfdPollListHead );
    InitializeListHead( &AfdTransportInfoListHead );
    InitializeListHead( &AfdWorkQueueListHead );
    InitializeListHead( &AfdConstrainedEndpointListHead );

    InitializeListHead( &AfdQueuedTransmitFileListHead );
    AfdInitializeSpinLock( &AfdQueuedTransmitFileSpinLock );

    InitializeListHead( &AfdAddressEntryList );
    InitializeListHead( &AfdAddressChangeList );

    ExInitializeSListHead( &AfdLRList);

    ExInitializeSListHead( &AfdLRFileMdlList);

    AfdBufferAlignment = KeGetRecommendedSharedDataAlignment( );
    if (AfdBufferAlignment < AFD_MINIMUM_BUFFER_ALIGNMENT) {
        AfdBufferAlignment = AFD_MINIMUM_BUFFER_ALIGNMENT;
    }
    AfdAlignmentTableSize = AfdBufferAlignment/AFD_MINIMUM_BUFFER_ALIGNMENT;

    AfdBufferOverhead = AfdCalculateBufferSize( PAGE_SIZE, AfdStandardAddressLength) - PAGE_SIZE;
    AfdBufferLengthForOnePage = ALIGN_DOWN_A(
                                    PAGE_SIZE-AfdBufferOverhead,
                                    AFD_MINIMUM_BUFFER_ALIGNMENT);

    AfdLargeBufferSize = AfdBufferLengthForOnePage;

    //
    // Set up buffer counts based on machine size.  For smaller
    // machines, it is OK to take the perf hit of the additional
    // allocations in order to save the nonpaged pool overhead.
    //

    switch ( MmQuerySystemSize( ) ) {

    case MmSmallSystem:

        AfdReceiveWindowSize = AFD_SM_DEFAULT_RECEIVE_WINDOW;
        AfdSendWindowSize = AFD_SM_DEFAULT_SEND_WINDOW;
        AfdTransmitIoLength = AFD_SM_DEFAULT_TRANSMIT_IO_LENGTH;
        AfdLargeBufferListDepth = AFD_SM_DEFAULT_LARGE_LIST_DEPTH;
        AfdMediumBufferListDepth = AFD_SM_DEFAULT_MEDIUM_LIST_DEPTH;
        AfdSmallBufferListDepth = AFD_SM_DEFAULT_SMALL_LIST_DEPTH;
        AfdBufferTagListDepth = AFD_SM_DEFAULT_TAG_LIST_DEPTH;
        break;

    case MmMediumSystem:

        AfdReceiveWindowSize = AFD_MM_DEFAULT_RECEIVE_WINDOW;
        AfdSendWindowSize = AFD_MM_DEFAULT_SEND_WINDOW;
        AfdTransmitIoLength = AFD_MM_DEFAULT_TRANSMIT_IO_LENGTH;
        AfdLargeBufferListDepth = AFD_MM_DEFAULT_LARGE_LIST_DEPTH;
        AfdMediumBufferListDepth = AFD_MM_DEFAULT_MEDIUM_LIST_DEPTH;
        AfdSmallBufferListDepth = AFD_MM_DEFAULT_SMALL_LIST_DEPTH;
        AfdBufferTagListDepth = AFD_MM_DEFAULT_TAG_LIST_DEPTH;
        break;

    case MmLargeSystem:

        AfdReceiveWindowSize = AFD_LM_DEFAULT_RECEIVE_WINDOW;
        AfdSendWindowSize = AFD_LM_DEFAULT_SEND_WINDOW;
        AfdTransmitIoLength = AFD_LM_DEFAULT_TRANSMIT_IO_LENGTH;
        AfdLargeBufferListDepth = AFD_LM_DEFAULT_LARGE_LIST_DEPTH;
        AfdMediumBufferListDepth = AFD_LM_DEFAULT_MEDIUM_LIST_DEPTH;
        AfdSmallBufferListDepth = AFD_LM_DEFAULT_SMALL_LIST_DEPTH;
        AfdBufferTagListDepth = AFD_LM_DEFAULT_TAG_LIST_DEPTH;
        break;

    default:

        ASSERT(!"Unknown system size" );
        __assume (0);
    }


    if( MmIsThisAnNtAsSystem() ) {

        //
        // On the NT Server product, there is no maximum active TransmitFile
        // count. Setting this counter to zero short-circuits a number of
        // tests for queueing TransmitFile IRPs.
        //

        AfdMaxActiveTransmitFileCount = 0;

    } else {

        //
        // On the workstation product, the TransmitFile default I/O length
        // is always a page size.  This conserves memory on workstatioons
        // and keeps the server product's performance high.
        //

        AfdTransmitIoLength = PAGE_SIZE;

        //
        // Enforce a maximum active TransmitFile count.
        //

        AfdMaxActiveTransmitFileCount =
            AFD_DEFAULT_MAX_ACTIVE_TRANSMIT_FILE_COUNT;

    }


} // AfdInitializeData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\blkconn.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blkconn.c

Abstract:

    This module contains allocate, free, close, reference, and dereference
    routines for AFD connections.

Author:

    David Treadwell (davidtr)    10-Mar-1992

Revision History:

--*/

#include "afdp.h"

VOID
AfdFreeConnection (
    IN PVOID Context
    );

VOID
AfdFreeConnectionResources (
    PAFD_CONNECTION connection
    );

VOID
AfdFreeNPConnectionResources (
    PAFD_CONNECTION connection
    );

VOID
AfdRefreshConnection (
    PAFD_CONNECTION connection
    );

PAFD_CONNECTION
AfdReuseConnection (
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdAbortConnection )
#pragma alloc_text( PAGE, AfdAddFreeConnection )
#pragma alloc_text( PAGE, AfdAllocateConnection )
#pragma alloc_text( PAGE, AfdCreateConnection )
#pragma alloc_text( PAGE, AfdFreeConnection )
#pragma alloc_text( PAGE, AfdFreeConnectionResources )
#pragma alloc_text( PAGE, AfdReuseConnection )
#pragma alloc_text( PAGEAFD, AfdRefreshConnection )
#pragma alloc_text( PAGEAFD, AfdFreeNPConnectionResources )
#pragma alloc_text( PAGEAFD, AfdGetConnectionReferenceFromEndpoint )
#if REFERENCE_DEBUG
#pragma alloc_text( PAGEAFD, AfdReferenceConnection )
#pragma alloc_text( PAGEAFD, AfdDereferenceConnection )
#else
#pragma alloc_text( PAGEAFD, AfdCloseConnection )
#endif
#pragma alloc_text( PAGEAFD, AfdGetFreeConnection )
#pragma alloc_text( PAGEAFD, AfdGetReturnedConnection )
#pragma alloc_text( PAGEAFD, AfdFindReturnedConnection )
#pragma alloc_text( PAGEAFD, AfdGetUnacceptedConnection )
#pragma alloc_text( PAGEAFD, AfdAddConnectedReference )
#pragma alloc_text( PAGEAFD, AfdDeleteConnectedReference )
#endif

#if GLOBAL_REFERENCE_DEBUG
AFD_GLOBAL_REFERENCE_DEBUG AfdGlobalReference[MAX_GLOBAL_REFERENCE];
LONG AfdGlobalReferenceSlot = -1;
#endif

#if AFD_PERF_DBG
#define CONNECTION_REUSE_DISABLED   (AfdDisableConnectionReuse)
#else
#define CONNECTION_REUSE_DISABLED   (FALSE)
#endif


VOID
AfdAbortConnection (
    IN PAFD_CONNECTION Connection
    )
{

    NTSTATUS status;

    ASSERT( Connection != NULL );
    ASSERT( Connection->ConnectedReferenceAdded );

    //
    // Abort the connection. We need to set the CleanupBegun flag
    // before initiating the abort so that the connected reference
    // will get properly removed in AfdRestartAbort.
    //
    // Note that if AfdBeginAbort fails then AfdRestartAbort will not
    // get invoked, so we must remove the connected reference ourselves.
    //

    Connection->CleanupBegun = TRUE;
    status = AfdBeginAbort( Connection );

    if( !NT_SUCCESS(status) ) {
        AfdDeleteConnectedReference( Connection, FALSE );
    }

    //
    // Remove the active reference.
    //

    DEREFERENCE_CONNECTION( Connection );

} // AfdAbortConnection


NTSTATUS
AfdAddFreeConnection (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Adds a connection object to an endpoints pool of connections available
    to satisfy a connect indication.

Arguments:

    Endpoint - a pointer to the endpoint to which to add a connection.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    PAFD_CONNECTION connection;
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Create a new connection block and associated connection object.
    //

    status = AfdCreateConnection(
                 &Endpoint->TransportInfo->TransportDeviceName,
                 Endpoint->AddressHandle,
                 IS_TDI_BUFFERRING(Endpoint),
                 Endpoint->InLine,
                 Endpoint->OwningProcess,
                 &connection
                 );

    if ( NT_SUCCESS(status) ) {
        ASSERT( IS_TDI_BUFFERRING(Endpoint) == connection->TdiBufferring );

        if (IS_DELAYED_ACCEPTANCE_ENDPOINT (Endpoint)) {
            status = AfdDelayedAcceptListen (Endpoint, connection);
            if (!NT_SUCCESS (status)) {
                DEREFERENCE_CONNECTION (connection);
            }
        }
        else {
            //
            // Set up the handle in the listening connection structure and place
            // the connection on the endpoint's list of listening connections.
            //

            ASSERT (connection->Endpoint==NULL);
            InterlockedPushEntrySList(
                &Endpoint->Common.VcListening.FreeConnectionListHead,
                &connection->SListEntry);
            status = STATUS_SUCCESS;
        }
    }

    return status;
} // AfdAddFreeConnection


PAFD_CONNECTION
AfdAllocateConnection (
    VOID
    )
{
    PAFD_CONNECTION connection;

    PAGED_CODE( );

    if ((AfdConnectionsFreeing<AFD_CONNECTIONS_FREEING_MAX)
            || ((connection = AfdReuseConnection ())==NULL)) {

        //
        // Allocate a buffer to hold the connection structure.
        //

        connection = AFD_ALLOCATE_POOL(
                         NonPagedPool,
                         sizeof(AFD_CONNECTION),
                         AFD_CONNECTION_POOL_TAG
                         );

        if ( connection == NULL ) {
            return NULL;
        }
    }

    RtlZeroMemory( connection, sizeof(AFD_CONNECTION) );

    //
    // Initialize the reference count to 1 to account for the caller's
    // reference.  Connection blocks are temporary--as soon as the last
    // reference goes away, so does the connection.  There is no active
    // reference on a connection block.
    //

    connection->ReferenceCount = 1;

    //
    // Initialize the connection structure.
    //

    connection->Type = AfdBlockTypeConnection;
    connection->State = AfdConnectionStateFree;
    //connection->Handle = NULL;
    //connection->FileObject = NULL;
    //connection->RemoteAddress = NULL;
    //connection->Endpoint = NULL;
    //connection->ReceiveBytesIndicated = 0;
    //connection->ReceiveBytesTaken = 0;
    //connection->ReceiveBytesOutstanding = 0;
    //connection->ReceiveExpeditedBytesIndicated = 0;
    //connection->ReceiveExpeditedBytesTaken = 0;
    //connection->ReceiveExpeditedBytesOutstanding = 0;
    //connection->ConnectDataBuffers = NULL;
    //connection->DisconnectIndicated = FALSE;
    //connection->AbortIndicated = FALSE;
    //connection->ConnectedReferenceAdded = FALSE;
    //connection->SpecialCondition = FALSE;
    //connection->CleanupBegun = FALSE;
    //connection->OwningProcess = NULL;
    //connection->ClosePendedTransmit = FALSE;

#if REFERENCE_DEBUG
    connection->CurrentReferenceSlot = -1;
    RtlZeroMemory(
        &connection->ReferenceDebug,
        sizeof(AFD_REFERENCE_DEBUG) * MAX_REFERENCE
        );
#endif

    //
    // Return a pointer to the new connection to the caller.
    //

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAllocateConnection: connection at %p\n", connection ));
    }

    return connection;

} // AfdAllocateConnection


NTSTATUS
AfdCreateConnection (
    IN PUNICODE_STRING TransportDeviceName,
    IN HANDLE AddressHandle,
    IN BOOLEAN TdiBufferring,
    IN LOGICAL InLine,
    IN PEPROCESS ProcessToCharge,
    OUT PAFD_CONNECTION *Connection
    )

/*++

Routine Description:

    Allocates a connection block and creates a connection object to
    go with the block.  This routine also associates the connection
    with the specified address handle (if any).

Arguments:

    TransportDeviceName - Name to use when creating the connection object.

    AddressHandle - a handle to an address object for the specified
        transport.  If specified (non NULL), the connection object that
        is created is associated with the address object.

    TdiBufferring - whether the TDI provider supports data bufferring.
        Only passed so that it can be stored in the connection
        structure.

    InLine - if TRUE, the endpoint should be created in OOB inline
        mode.

    ProcessToCharge - the process which should be charged the quota
        for this connection.

    Connection - receives a pointer to the new connection.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    CHAR eaBuffer[sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                  TDI_CONNECTION_CONTEXT_LENGTH + 1 +
                  sizeof(CONNECTION_CONTEXT)];
    PFILE_FULL_EA_INFORMATION ea;
    CONNECTION_CONTEXT UNALIGNED *ctx;
    PAFD_CONNECTION connection;

    PAGED_CODE( );


    //
    // Attempt to charge this process quota for the data bufferring we
    // will do on its behalf.
    //

    status = PsChargeProcessPoolQuota(
        ProcessToCharge,
        NonPagedPool,
        sizeof (AFD_CONNECTION)
        );
    if (!NT_SUCCESS (status)) {
       KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdCreateConnection: PsChargeProcessPoolQuota failed.\n" ));

       return status;
    }

    //
    // Allocate a connection block.
    //

    connection = AfdAllocateConnection( );

    if ( connection == NULL ) {
        PsReturnPoolQuota(
            ProcessToCharge,
            NonPagedPool,
            sizeof (AFD_CONNECTION)
            );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    AfdRecordQuotaHistory(
        ProcessToCharge,
        (LONG)sizeof (AFD_CONNECTION),
        "CreateConn  ",
        connection
        );

    AfdRecordPoolQuotaCharged(sizeof (AFD_CONNECTION));

    //
    // Remember the process that got charged the pool quota for this
    // connection object.  Also reference the process to which we're
    // going to charge the quota so that it is still around when we
    // return the quota.
    //

    ASSERT( connection->OwningProcess == NULL );
    connection->OwningProcess = ProcessToCharge;

    ObReferenceObject( ProcessToCharge );

    //
    // If the provider does not buffer, initialize appropriate lists in
    // the connection object.
    //

    connection->TdiBufferring = TdiBufferring;

    if ( !TdiBufferring ) {

        InitializeListHead( &connection->VcReceiveIrpListHead );
        InitializeListHead( &connection->VcSendIrpListHead );
        InitializeListHead( &connection->VcReceiveBufferListHead );

        connection->VcBufferredReceiveBytes = 0;
        connection->VcBufferredExpeditedBytes = 0;
        connection->VcBufferredReceiveCount = 0;
        connection->VcBufferredExpeditedCount = 0;

        connection->VcReceiveBytesInTransport = 0;

#if DBG
        connection->VcReceiveIrpsInTransport = 0;
#endif

        connection->VcBufferredSendBytes = 0;
        connection->VcBufferredSendCount = 0;

    } else {

        connection->VcNonBlockingSendPossible = TRUE;
        connection->VcZeroByteReceiveIndicated = FALSE;
    }

    //
    // Set up the send and receive window with default maximums.
    //

    connection->MaxBufferredReceiveBytes = AfdReceiveWindowSize;

    connection->MaxBufferredSendBytes = AfdSendWindowSize;

    //
    // We need to open a connection object to the TDI provider for this
    // endpoint.  First create the EA for the connection context and the
    // object attributes structure which will be used for all the
    // connections we open here.
    //

    ea = (PFILE_FULL_EA_INFORMATION)eaBuffer;
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_CONNECTION_CONTEXT_LENGTH;
    ea->EaValueLength = sizeof(CONNECTION_CONTEXT);

    RtlMoveMemory( ea->EaName, TdiConnectionContext, ea->EaNameLength + 1 );

    //
    // Use the pointer to the connection block as the connection context.
    //

    ctx = (CONNECTION_CONTEXT UNALIGNED *)&ea->EaName[ea->EaNameLength + 1];
    *ctx = (CONNECTION_CONTEXT)connection;

    // We ask to create a kernel handle which is
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    InitializeObjectAttributes(
        &objectAttributes,
        TransportDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    //
    // Do the actual open of the connection object.
    //

    status = IoCreateFile(
                &connection->Handle,
                GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                &objectAttributes,
                &ioStatusBlock,
                NULL,                               // AllocationSize
                0,                                  // FileAttributes
                0,                                  // ShareAccess
                FILE_CREATE,                        // CreateDisposition
                0,                                  // CreateOptions
                eaBuffer,
                FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0] ) +
                            ea->EaNameLength + 1 + ea->EaValueLength,
                CreateFileTypeNone,                 // CreateFileType
                NULL,                               // ExtraCreateParameters
                IO_NO_PARAMETER_CHECKING            // Options
                );

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }
    if ( !NT_SUCCESS(status) ) {
        DEREFERENCE_CONNECTION( connection );
        return status;
    }

#if DBG
    {
        NTSTATUS    status1;
        OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
        handleInfo.Inherit = FALSE;
        handleInfo.ProtectFromClose = TRUE;
        status1 = ZwSetInformationObject (
                        connection->Handle,
                        ObjectHandleFlagInformation,
                        &handleInfo,
                        sizeof (handleInfo)
                        );
        ASSERT (NT_SUCCESS (status1));
    }
#endif
    AfdRecordConnOpened();

    //
    // Reference the connection's file object.
    //

    status = ObReferenceObjectByHandle(
                connection->Handle,
                0,
                (POBJECT_TYPE) NULL,
                KernelMode,
                (PVOID *)&connection->FileObject,
                NULL
                );

    ASSERT( NT_SUCCESS(status) );


    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdCreateConnection: file object for connection %p at %p\n",
            connection, connection->FileObject ));
    }

    AfdRecordConnRef();

    //
    // Remember the device object to which we need to give requests for
    // this connection object.  We can't just use the
    // fileObject->DeviceObject pointer because there may be a device
    // attached to the transport protocol.
    //

    connection->DeviceObject =
        IoGetRelatedDeviceObject( connection->FileObject );

    //
    // Associate the connection with the address object on the endpoint if
    // an address handle was specified.
    //

    if ( AddressHandle != NULL ) {

        TDI_REQUEST_KERNEL_ASSOCIATE associateRequest;

        associateRequest.AddressHandle = AddressHandle;

        status = AfdIssueDeviceControl(
                    connection->FileObject,
                    &associateRequest,
                    sizeof (associateRequest),
                    NULL,
                    0,
                    TDI_ASSOCIATE_ADDRESS
                    );
        if ( !NT_SUCCESS(status) ) {
            DEREFERENCE_CONNECTION( connection );
            return status;
        }
    }

    //
    // If requested, set the connection to be inline.
    //

    if ( InLine ) {
        status = AfdSetInLineMode( connection, TRUE );
        if ( !NT_SUCCESS(status) ) {
            DEREFERENCE_CONNECTION( connection );
            return status;
        }
    }

    //
    // Set up the connection pointer and return.
    //

    *Connection = connection;

    UPDATE_CONN2( connection, "Connection object handle: %lx", HandleToUlong (connection->Handle));

    return STATUS_SUCCESS;

} // AfdCreateConnection


VOID
AfdFreeConnection (
    IN PVOID Context
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT   listenEndpoint;

    PAGED_CODE( );

    InterlockedDecrement (&AfdConnectionsFreeing);
    ASSERT( Context != NULL );

    connection = CONTAINING_RECORD(
                     Context,
                     AFD_CONNECTION,
                     WorkItem
                     );

    if (connection->Endpoint != NULL &&
             !CONNECTION_REUSE_DISABLED &&
             !connection->Endpoint->EndpointCleanedUp &&
             connection->Endpoint->Type == AfdBlockTypeVcConnecting &&
             (listenEndpoint=connection->Endpoint->Common.VcConnecting.ListenEndpoint) != NULL &&
             -listenEndpoint->Common.VcListening.FailedConnectionAdds <
                    listenEndpoint->Common.VcListening.MaxExtraConnections &&
             (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
                ExQueryDepthSList (
                    &listenEndpoint->Common.VcListening.FreeConnectionListHead)
                        < AFD_MAXIMUM_FREE_CONNECTIONS ) ) {

        AfdRefreshConnection (connection);
    }
    else {
        AfdFreeConnectionResources (connection);

        //
        // Free the space that holds the connection itself.
        //

        IF_DEBUG(CONNECTION) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFreeConnection: Freeing connection at %p\n", 
                        connection ));
        }

        connection->Type = AfdBlockTypeInvalidConnection;

        AFD_FREE_POOL(
            connection,
            AFD_CONNECTION_POOL_TAG
            );
    }

} // AfdFreeConnection


PAFD_CONNECTION
AfdReuseConnection (
    ) {
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT   listenEndpoint;
    PVOID           Context;

    PAGED_CODE( );

    while ((Context = AfdGetWorkerByRoutine (AfdFreeConnection))!=NULL) {
        connection = CONTAINING_RECORD(
                   Context,
                   AFD_CONNECTION,
                   WorkItem
                   );
        if (connection->Endpoint != NULL &&
                 !CONNECTION_REUSE_DISABLED &&
                 !connection->Endpoint->EndpointCleanedUp &&
                 connection->Endpoint->Type == AfdBlockTypeVcConnecting &&
                 (listenEndpoint=connection->Endpoint->Common.VcConnecting.ListenEndpoint) != NULL &&
                 -listenEndpoint->Common.VcListening.FailedConnectionAdds <
                        listenEndpoint->Common.VcListening.MaxExtraConnections &&
                 (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
                    ExQueryDepthSList (
                        &listenEndpoint->Common.VcListening.FreeConnectionListHead)
                            < AFD_MAXIMUM_FREE_CONNECTIONS ) ) {
            AfdRefreshConnection (connection);
        }
        else {
            AfdFreeConnectionResources (connection);
            return connection;
        }
    }

    return NULL;
}


VOID
AfdFreeNPConnectionResources (
    PAFD_CONNECTION connection
    )
{

    if ( !connection->TdiBufferring && connection->VcDisconnectIrp != NULL ) {
        IoFreeIrp( connection->VcDisconnectIrp );
        connection->VcDisconnectIrp = NULL;
    }

    if ( connection->ConnectDataBuffers != NULL ) {
        AfdFreeConnectDataBuffers( connection->ConnectDataBuffers );
        connection->ConnectDataBuffers = NULL;
    }

    //
    // If this is a bufferring connection, remove all the AFD buffers
    // from the connection's lists and free them.
    //

    if ( !connection->TdiBufferring ) {

        PAFD_BUFFER_HEADER  afdBuffer;

        PLIST_ENTRY         listEntry;

        ASSERT( IsListEmpty( &connection->VcReceiveIrpListHead ) );
        ASSERT( IsListEmpty( &connection->VcSendIrpListHead ) );

        while ( !IsListEmpty( &connection->VcReceiveBufferListHead  ) ) {

            listEntry = RemoveHeadList( &connection->VcReceiveBufferListHead );
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
            ASSERT (afdBuffer->RefCount == 1);

            afdBuffer->ExpeditedData = FALSE;

            AfdReturnBuffer( afdBuffer, connection->OwningProcess );
        }
    }

    if ( connection->Endpoint != NULL ) {

        //
        // If there is a transmit file IRP on the endpoint, complete it.
        //

        if ( connection->ClosePendedTransmit ) {
            AfdCompleteClosePendedTPackets( connection->Endpoint );
        }

        DEREFERENCE_ENDPOINT( connection->Endpoint );
        connection->Endpoint = NULL;
    }
}


VOID
AfdRefreshConnection (
    PAFD_CONNECTION connection
    )
{
    PAFD_ENDPOINT listeningEndpoint;

    ASSERT( connection->ReferenceCount == 0 );
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( connection->OnLRList == FALSE );

    UPDATE_CONN( connection);

    //
    // Reference the listening endpoint so that it does not
    // go away while we are cleaning up this connection object
    // for reuse.  Note that we actually have an implicit reference
    // to the listening endpoint through the connection's endpoint
    //

    listeningEndpoint = connection->Endpoint->Common.VcConnecting.ListenEndpoint;

#if REFERENCE_DEBUG
    {
        BOOLEAN res;
        CHECK_REFERENCE_ENDPOINT (listeningEndpoint, res);
        ASSERT (res);
    }
#else
    REFERENCE_ENDPOINT( listeningEndpoint );
#endif

    ASSERT( listeningEndpoint->Type == AfdBlockTypeVcListening ||
            listeningEndpoint->Type == AfdBlockTypeVcBoth );

    AfdFreeNPConnectionResources (connection);


    //
    // Reinitialize various fields in the connection object.
    //

    connection->ReferenceCount = 1;
    ASSERT( connection->Type == AfdBlockTypeConnection );
    connection->State = AfdConnectionStateFree;

    connection->ConnectionStateFlags = 0;

    connection->TdiBufferring = IS_TDI_BUFFERRING (listeningEndpoint);
    if ( !connection->TdiBufferring ) {

        ASSERT( IsListEmpty( &connection->VcReceiveIrpListHead ) );
        ASSERT( IsListEmpty( &connection->VcSendIrpListHead ) );
        ASSERT( IsListEmpty( &connection->VcReceiveBufferListHead ) );

        connection->VcBufferredReceiveBytes = 0;
        connection->VcBufferredExpeditedBytes = 0;
        connection->VcBufferredReceiveCount = 0;
        connection->VcBufferredExpeditedCount = 0;

        connection->VcReceiveBytesInTransport = 0;
#if DBG
        connection->VcReceiveIrpsInTransport = 0;
#endif

        connection->VcBufferredSendBytes = 0;
        connection->VcBufferredSendCount = 0;

    } else {

        connection->VcNonBlockingSendPossible = TRUE;
        connection->VcZeroByteReceiveIndicated = FALSE;
    }

    if (IS_DELAYED_ACCEPTANCE_ENDPOINT (listeningEndpoint)) {
        NTSTATUS    status;
        status = AfdDelayedAcceptListen (listeningEndpoint, connection);
        if (NT_SUCCESS (status)) {
            //
            // Reduce the count of failed connection adds on the listening
            // endpoint to account for this connection object which we're
            // adding back onto the queue.
            //

            InterlockedDecrement(
                &listeningEndpoint->Common.VcListening.FailedConnectionAdds
                );

            AfdRecordConnectionsReused ();
        }
        else {
            DEREFERENCE_CONNECTION (connection);
        }
    }
    else {
        //
        // Place the connection on the listening endpoint's list of
        // available connections.
        //

        ASSERT (connection->Endpoint == NULL);
        InterlockedPushEntrySList(
            &listeningEndpoint->Common.VcListening.FreeConnectionListHead,
            &connection->SListEntry);
        //
        // Reduce the count of failed connection adds on the listening
        // endpoint to account for this connection object which we're
        // adding back onto the queue.
        //

        InterlockedDecrement(
            &listeningEndpoint->Common.VcListening.FailedConnectionAdds
            );

        AfdRecordConnectionsReused ();
    }


    //
    // Get rid of the reference we added to the listening endpoint
    // above.
    //

    DEREFERENCE_ENDPOINT( listeningEndpoint );
}


VOID
AfdFreeConnectionResources (
    PAFD_CONNECTION connection
    )
{
    NTSTATUS status;

    PAGED_CODE( );

    ASSERT( connection->ReferenceCount == 0 );
    ASSERT( connection->Type == AfdBlockTypeConnection );
    ASSERT( connection->OnLRList == FALSE );

    UPDATE_CONN( connection );


    //
    // Free and dereference the various objects on the connection.
    // Close and dereference the TDI connection object on the endpoint,
    // if any.
    //

    if ( connection->Handle != NULL ) {


        //
        // Disassociate this connection object from the address object.
        //

        status = AfdIssueDeviceControl(
                    connection->FileObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TDI_DISASSOCIATE_ADDRESS
                    );
        // ASSERT( NT_SUCCESS(status) );


        //
        // Close the handle.
        //

#if DBG
        {
            NTSTATUS    status1;
            OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
            handleInfo.Inherit = FALSE;
            handleInfo.ProtectFromClose = FALSE;
            status1 = ZwSetInformationObject (
                            connection->Handle,
                            ObjectHandleFlagInformation,
                            &handleInfo,
                            sizeof (handleInfo)
                            );
            ASSERT (NT_SUCCESS (status1));
        }
#endif
        status = ZwClose( connection->Handle );

#if DBG
        if (!NT_SUCCESS(status) ) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                "AfdFreeConnectionResources: ZwClose() failed (%lx)\n",
                status));
            ASSERT (FALSE);
        }
#endif
        AfdRecordConnClosed();
    }

    if ( connection->FileObject != NULL ) {

        ObDereferenceObject( connection->FileObject );
        connection->FileObject = NULL;
        AfdRecordConnDeref();

    }
    //
    // Free remaining buffers and return quota charges associated with them.
    //

    AfdFreeNPConnectionResources (connection);

    //
    // Return the quota we charged to this process when we allocated
    // the connection object and buffered data on it.
    //

    PsReturnPoolQuota(
        connection->OwningProcess,
        NonPagedPool,
        sizeof (AFD_CONNECTION)
        );
    AfdRecordQuotaHistory(
        connection->OwningProcess,
        -(LONG)sizeof (AFD_CONNECTION),
        "ConnDealloc ",
        connection
        );
    AfdRecordPoolQuotaReturned(
        sizeof (AFD_CONNECTION)
        );

    //
    // Dereference the process that  got the quota charge.
    //

    ASSERT( connection->OwningProcess != NULL );
    ObDereferenceObject( connection->OwningProcess );
    connection->OwningProcess = NULL;

    if ( connection->RemoteAddress != NULL ) {
        AFD_RETURN_REMOTE_ADDRESS (
            connection->RemoteAddress,
            connection->RemoteAddressLength,
            );
        connection->RemoteAddress = NULL;
    }

}


#if REFERENCE_DEBUG
VOID
AfdReferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
{

    LONG result;

    ASSERT( Connection->Type == AfdBlockTypeConnection );
    ASSERT( Connection->ReferenceCount > 0 );
    ASSERT( Connection->ReferenceCount != 0xD1000000 );

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReferenceConnection: connection %p, new refcnt %ld\n",
                    Connection, Connection->ReferenceCount+1 ));
    }

    //
    // Do the actual increment of the reference count.
    //

    result = InterlockedIncrement( (PLONG)&Connection->ReferenceCount );

#if REFERENCE_DEBUG
    AFD_UPDATE_REFERENCE_DEBUG(Connection, result, LocationId, Param)
#endif

} // AfdReferenceConnection
#endif


PAFD_CONNECTION
AfdGetConnectionReferenceFromEndpoint (
    PAFD_ENDPOINT   Endpoint
    )
// Why do we need this routine?
// If VC endpoint is in connected state it maintains the referenced
// pointer to the connection object until it is closed (e.g. all references
// to the underlying file object are removed). So checking for connected
// state should be enough in any dispatch routine (or any routine called
// from the dispatch routine) because Irp that used to get to AFD maintains
// a reference to the corresponding file object.
// However, there exist a notable exception from this case: TransmitFile
// can remove the reference to the connection object in the process of endpoint
// reuse.  So, to be 100% safe, it is better to use this routine in all cases.
{
    AFD_LOCK_QUEUE_HANDLE   lockHandle;
    PAFD_CONNECTION connection;

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    connection = AFD_CONNECTION_FROM_ENDPOINT (Endpoint);
    if (connection!=NULL) {
        REFERENCE_CONNECTION (connection);
    }
    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

    return connection;
}


#if REFERENCE_DEBUG
VOID
AfdDereferenceConnection (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
{
    LONG result;
    PAFD_ENDPOINT   listenEndpoint;

    ASSERT( Connection->Type == AfdBlockTypeConnection );
    ASSERT( Connection->ReferenceCount > 0 );
    ASSERT( Connection->ReferenceCount != 0xD1000000 );

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdDereferenceConnection: connection %p, new refcnt %ld\n",
                    Connection, Connection->ReferenceCount-1 ));
    }

    //
    // Note that if we're tracking refcnts, we *must* call
    // AfdUpdateConnectionTrack before doing the dereference.  This is
    // because the connection object might go away in another thread as
    // soon as we do the dereference.  However, because of this,
    // the refcnt we store with this may sometimes be incorrect.
    //

    AFD_UPDATE_REFERENCE_DEBUG(Connection, Connection->ReferenceCount-1, LocationId, Param);
    
    //
    // We must hold AfdSpinLock while doing the dereference and check
    // for free.  This is because some code makes the assumption that
    // the connection structure will not go away while AfdSpinLock is
    // held, and that code references the endpoint before releasing
    // AfdSpinLock.  If we did the InterlockedDecrement() without the
    // lock held, our count may go to zero, that code may reference the
    // connection, and then a double free might occur.
    //
    // There is no such code anymore. The endpoint spinlock is now
    // held when getting a connection from endpoint structure.
    // Other code uses InterlockedCompareExchange to never increment
    // connection reference if it is at 0.
    //
    //

    result = InterlockedDecrement( (PLONG)&Connection->ReferenceCount );

    //
    // If the reference count is now 0, free the connection in an
    // executive worker thread.
    //

    if ( result == 0 ) {
#else
VOID
AfdCloseConnection (
    IN PAFD_CONNECTION Connection
    )
{
    PAFD_ENDPOINT   listenEndpoint;
#endif

    if (Connection->Endpoint != NULL &&
             !CONNECTION_REUSE_DISABLED &&
             !Connection->Endpoint->EndpointCleanedUp &&
             Connection->Endpoint->Type == AfdBlockTypeVcConnecting &&
             (listenEndpoint=Connection->Endpoint->Common.VcConnecting.ListenEndpoint) != NULL &&
             -listenEndpoint->Common.VcListening.FailedConnectionAdds <
                    listenEndpoint->Common.VcListening.MaxExtraConnections &&
             (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint) ||
                ExQueryDepthSList (
                    &listenEndpoint->Common.VcListening.FreeConnectionListHead)
                        < AFD_MAXIMUM_FREE_CONNECTIONS ) ) {

        AfdRefreshConnection (Connection);
    }
    else {
        InterlockedIncrement (&AfdConnectionsFreeing);
        //
        // We're going to do this by queueing a request to an executive
        // worker thread.  We do this for several reasons: to ensure
        // that we're at IRQL 0 so we can free pageable memory, and to
        // ensure that we're in a legitimate context for a close
        // operation
        //

        AfdQueueWorkItem(
            AfdFreeConnection,
            &Connection->WorkItem
            );
    }
#if REFERENCE_DEBUG
    }
} // AfdDereferenceConnection
#else
} // AfdCloseConnection
#endif



#if REFERENCE_DEBUG
BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
#else
BOOLEAN
AfdCheckAndReferenceConnection (
    PAFD_CONNECTION     Connection
    )
#endif
{
    LONG            result;

    do {
        result = Connection->ReferenceCount;
        if (result<=0) {
            result = 0;
            break;
        }
    }
    while (InterlockedCompareExchange ((PLONG)&Connection->ReferenceCount,
                                                (result+1),
                                                result)!=result);

    if (result>0) {
#if REFERENCE_DEBUG
        AFD_UPDATE_REFERENCE_DEBUG(Connection, result+1, LocationId, Param);
#endif
        ASSERT( result < 0xFFFF );
        return TRUE;
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdCheckAndReferenceConnection: Connection %p is gone (refcount: %ld!\n",
                    Connection, result));
        return FALSE;
    }
}

PAFD_CONNECTION
AfdGetFreeConnection (
    IN  PAFD_ENDPOINT   Endpoint,
    OUT PIRP            *Irp
    )

/*++

Routine Description:

    Takes a connection off of the endpoint's queue of listening
    connections.

Arguments:

    Endpoint - a pointer to the endpoint from which to get a connection.
    Irp     - place to return a super accept IRP if we have any

Return Value:

    AFD_CONNECTION - a pointer to an AFD connection block.

--*/

{
    PAFD_CONNECTION connection;
    PSINGLE_LIST_ENTRY listEntry;
    PIRP    irp;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );


    //
    // First try pre-accepted connections
    //

    while ((listEntry = InterlockedPopEntrySList (
                 &Endpoint->Common.VcListening.PreacceptedConnectionsListHead
                 ))!=NULL) {


        //
        // Find the connection pointer from the list entry and return a
        // pointer to the connection object.
        //

        connection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         SListEntry
                         );

        //
        // Check if super accept Irp has not been cancelled
        //
        irp = InterlockedExchangePointer ((PVOID *)&connection->AcceptIrp, NULL);
        if ((irp!=NULL) && (IoSetCancelRoutine (irp, NULL)!=NULL)) {
            //
            // Return the IRP to the caller along with the connection.
            //
            *Irp = irp;
            goto ReturnConnection;
        }

        //
        // Irp has been or is about to be cancelled
        //
        if (irp!=NULL) {
            KIRQL   cancelIrql;

            //
            // Cleanup and cancel the super accept IRP.
            //
            AfdCleanupSuperAccept (irp, STATUS_CANCELLED);

            //
            // The cancel routine won't find the IRP in the connection,
            // so we need to cancel it ourselves.  Just make sure that
            // the cancel routine is done before doing so.
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);

            IoCompleteRequest (irp, AfdPriorityBoost);
        }

        //
        // This connection has already been diassociated from endpoint.
        // If backlog is below the level we need, put it on the free
        // list, otherwise, get rid of it.
        //

        ASSERT (connection->Endpoint==NULL);
        if (Endpoint->Common.VcListening.FailedConnectionAdds>=0 &&
                ExQueryDepthSList (&Endpoint->Common.VcListening.FreeConnectionListHead)<AFD_MAXIMUM_FREE_CONNECTIONS) {
            InterlockedPushEntrySList (
                            &Endpoint->Common.VcListening.FreeConnectionListHead,
                            &connection->SListEntry);
        }
        else {
            InterlockedIncrement (&Endpoint->Common.VcListening.FailedConnectionAdds);
            DEREFERENCE_CONNECTION (connection);
        }
    }

    //
    // Remove the first entry from the list.  If the list is empty,
    // return NULL.
    //

    listEntry = InterlockedPopEntrySList (
                 &Endpoint->Common.VcListening.FreeConnectionListHead);
    if (listEntry==NULL) {
        return NULL;
    }

    //
    // Find the connection pointer from the list entry and return a
    // pointer to the connection object.
    //

    connection = CONTAINING_RECORD(
                     listEntry,
                     AFD_CONNECTION,
                     SListEntry
                     );

    *Irp = NULL;

ReturnConnection:
    //
    // Assign unique non-zero sequence number (unique in the context
    // of the given listening endpoint).
    //

    connection->Sequence = InterlockedIncrement (&Endpoint->Common.VcListening.Sequence);
    if (connection->Sequence==0) {
        connection->Sequence = InterlockedIncrement (&Endpoint->Common.VcListening.Sequence);
        ASSERT (connection->Sequence!=0);
    }

    return connection;

} // AfdGetFreeConnection


PAFD_CONNECTION
AfdGetReturnedConnection (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    )

/*++

Routine Description:

    Takes a connection off of the endpoint's queue of returned
    connections.

    *** NOTE: This routine must be called with endpoint spinlock held!!

Arguments:

    Endpoint - a pointer to the endpoint from which to get a connection.

    Sequence - the sequence the connection must match.  If 0, the first returned
        connection is used.

Return Value:

    AFD_CONNECTION - a pointer to an AFD connection block.

--*/

{
    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );


    //
    // Walk the endpoint's list of returned connections until we reach
    // the end or until we find one with a matching sequence.
    //

    for ( listEntry = Endpoint->Common.VcListening.ReturnedConnectionListHead.Flink;
          listEntry != &Endpoint->Common.VcListening.ReturnedConnectionListHead;
          listEntry = listEntry->Flink ) {


        connection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         ListEntry
                         );

        if ( Sequence == connection->Sequence || Sequence == 0 ) {

            //
            // Found the connection we were looking for.  Remove
            // the connection from the list, release the spin lock,
            // and return the connection.
            //

            RemoveEntryList( listEntry );

            return connection;
        }
    }

    return NULL;

} // AfdGetReturnedConnection


PAFD_CONNECTION
AfdFindReturnedConnection(
    IN PAFD_ENDPOINT Endpoint,
    IN LONG Sequence
    )

/*++

Routine Description:

    Scans the endpoints queue of returned connections looking for one
    with the specified sequence number.

Arguments:

    Endpoint - A pointer to the endpoint from which to get a connection.

    Sequence - The sequence the connection must match.

Return Value:

    AFD_CONNECTION - A pointer to an AFD connection block if successful,
        NULL if not.

--*/

{

    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;

    ASSERT( Endpoint != NULL );
    ASSERT( IS_AFD_ENDPOINT_TYPE( Endpoint ) );

    //
    // Walk the endpoint's list of returned connections until we reach
    // the end or until we find one with a matching sequence.
    //

    for( listEntry = Endpoint->Common.VcListening.ReturnedConnectionListHead.Flink;
         listEntry != &Endpoint->Common.VcListening.ReturnedConnectionListHead;
         listEntry = listEntry->Flink ) {

        connection = CONTAINING_RECORD(
                         listEntry,
                         AFD_CONNECTION,
                         ListEntry
                         );

        if( Sequence == connection->Sequence ) {

            return connection;

        }

    }

    return NULL;

}   // AfdFindReturnedConnection


PAFD_CONNECTION
AfdGetUnacceptedConnection (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Takes a connection of the endpoint's queue of unaccpted connections.

    *** NOTE: This routine must be called with endpoint spinlock held!!

Arguments:

    Endpoint - a pointer to the endpoint from which to get a connection.

Return Value:

    AFD_CONNECTION - a pointer to an AFD connection block.

--*/

{
    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    if ( IsListEmpty( &Endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
        return NULL;
    }

    //
    // Dequeue a listening connection and remember its handle.
    //

    listEntry = RemoveHeadList( &Endpoint->Common.VcListening.UnacceptedConnectionListHead );
    connection = CONTAINING_RECORD( listEntry, AFD_CONNECTION, ListEntry );

    return connection;

} // AfdGetUnacceptedConnection



VOID
AfdAddConnectedReference (
    IN PAFD_CONNECTION Connection
    )

/*++

Routine Description:

    Adds the connected reference to an AFD connection block.  The
    connected reference is special because it prevents the connection
    object from being freed until we receive a disconnect event, or know
    through some other means that the virtual circuit is disconnected.

Arguments:

    Connection - a pointer to an AFD connection block.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock( &Connection->Endpoint->SpinLock, &lockHandle );

    IF_DEBUG(CONNECTION) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddConnectedReference: connection %p, new refcnt %ld\n",
                    Connection, Connection->ReferenceCount+1 ));
    }

    ASSERT( !Connection->ConnectedReferenceAdded );
    ASSERT( Connection->Type == AfdBlockTypeConnection );

    //
    // Increment the reference count and remember that the connected
    // reference has been placed on the connection object.
    //

    Connection->ConnectedReferenceAdded = TRUE;
    AfdRecordConnectedReferencesAdded();

    AfdReleaseSpinLock( &Connection->Endpoint->SpinLock, &lockHandle );

    REFERENCE_CONNECTION( Connection );

} // AfdAddConnectedReference


VOID
AfdDeleteConnectedReference (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN EndpointLockHeld
    )

/*++

Routine Description:

    Removes the connected reference to an AFD connection block.  If the
    connected reference has already been removed, this routine does
    nothing.  The connected reference should be removed as soon as we
    know that it is OK to close the connection object handle, but not
    before.  Removing this reference too soon could abort a connection
    which shouldn't get aborted.

Arguments:

    Connection - a pointer to an AFD connection block.

    EndpointLockHeld - TRUE if the caller already has the endpoint
      spin lock.  The lock remains held on exit.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
#if REFERENCE_DEBUG
    PVOID caller, callersCaller;

    RtlGetCallersAddress( &caller, &callersCaller );
#endif

    endpoint = Connection->Endpoint;

    if ( !EndpointLockHeld ) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Only do a dereference if the connected reference is still active
    // on the connectiuon object.
    //

    if ( Connection->ConnectedReferenceAdded ) {

        //
        // Three things must be true before we can remove the connected
        // reference:
        //
        // 1) There must be no sends outstanding on the connection if
        //    the TDI provider does not support bufferring.  This is
        //    because AfdRestartBufferSend() looks at the connection
        //    object.
        //
        // 2) Cleanup must have started on the endpoint.  Until we get a
        //    cleanup IRP on the endpoint, we could still get new sends.
        //
        // 3) We have been indicated with a disconnect on the
        //    connection.  We want to keep the connection object around
        //    until we get a disconnect indication in order to avoid
        //    premature closes on the connection object resulting in an
        //    unintended abort.  If the transport does not support
        //    orderly release, then this condition is not necessary.
        //

        if ( (Connection->TdiBufferring ||
                 Connection->VcBufferredSendCount == 0)

                 &&

             Connection->CleanupBegun

                 &&

             (Connection->AbortIndicated || Connection->DisconnectIndicated ||
                  !IS_TDI_ORDERLY_RELEASE(endpoint) ||
                  IS_CROOT_ENDPOINT(endpoint)) ) {

            IF_DEBUG(CONNECTION) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdDeleteConnectedReference: connection %p, new refcnt %ld\n",
                              Connection, Connection->ReferenceCount-1 ));
            }

            //
            // Be careful about the order of things here.  We must FIRST
            // reset the flag, then release the spin lock and call
            // AfdDereferenceConnection().  Note that it is illegal to
            // call AfdDereferenceConnection() with a spin lock held.
            //

            Connection->ConnectedReferenceAdded = FALSE;
            AfdRecordConnectedReferencesDeleted();

            if ( !EndpointLockHeld ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            DEREFERENCE_CONNECTION( Connection );

        } else {

            IF_DEBUG(CONNECTION) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdDeleteConnectedReference: connection %p, %ld sends pending\n",
                            Connection, Connection->VcBufferredSendCount ));
            }

            UPDATE_CONN2( Connection, "Not removing cref, state flags: %lx",
                                                Connection->ConnectionStateFlags);
            //
            // Remember that the connected reference deletion is still
            // pending, i.e.  there is a special condition on the
            // endpoint.  This will cause AfdRestartBufferSend() to do
            // the actual dereference when the last send completes.
            //

            Connection->SpecialCondition = TRUE;

            if ( !EndpointLockHeld ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
        }

    } else {

        IF_DEBUG(CONNECTION) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdDeleteConnectedReference: already removed on  connection %p, refcnt %ld\n",
                        Connection, Connection->ReferenceCount ));
        }

        if ( !EndpointLockHeld ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
    }

    return;

} // AfdDeleteConnectedReference


#if REFERENCE_DEBUG


VOID
AfdUpdateConnectionTrack (
    IN PAFD_CONNECTION Connection,
    IN LONG  LocationId,
    IN ULONG Param
    )
{
    AFD_UPDATE_REFERENCE_DEBUG (Connection, Connection->ReferenceCount, LocationId, Param);

#if GLOBAL_REFERENCE_DEBUG
    {
        PAFD_GLOBAL_REFERENCE_DEBUG globalSlot;

        newSlot = InterlockedIncrement( &AfdGlobalReferenceSlot );
        globalSlot = &AfdGlobalReference[newSlot % MAX_GLOBAL_REFERENCE];

        globalSlot->Info1 = Info1;
        globalSlot->Info2 = Info2;
        globalSlot->Action = Action;
        globalSlot->NewCount = NewReferenceCount;
        globalSlot->Connection = Connection;
        KeQueryTickCount( &globalSlot->TickCounter );
    }
#endif

} // AfdUpdateConnectionTrack

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\close.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module contains code for cleanup and close IRPs.

Author:

    David Treadwell (davidtr)    18-Mar-1992

Revision History:

--*/

#include "afdp.h"




#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdClose )
#pragma alloc_text( PAGEAFD, AfdCleanup )
#endif


NTSTATUS
FASTCALL
AfdCleanup (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Cleanup IRPs in AFD.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    LARGE_INTEGER processExitTime;

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdCleanup: cleanup on file object %p, endpoint %p, connection %p\n",
            IrpSp->FileObject,
            endpoint,
            AFD_CONNECTION_FROM_ENDPOINT( endpoint )
            ));
    }

    //
    // Get the process exit time while still at low IRQL.
    //

    processExitTime = PsGetProcessExitTime( );

    //
    // Indicate that there was a local close on this endpoint.  If there
    // are any outstanding polls on this endpoint, they will be
    // completed now.
    //
    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_LOCAL_CLOSE,
        STATUS_SUCCESS
        );

    //
    // Remember that the endpoint has been cleaned up.  This is important
    // because it allows AfdRestartAccept to know that the endpoint has
    // been cleaned up and that it should toss the connection.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    AfdIndicateEventSelectEvent (endpoint, AFD_POLL_LOCAL_CLOSE, STATUS_SUCCESS);

    ASSERT( endpoint->EndpointCleanedUp == FALSE );
    endpoint->EndpointCleanedUp = TRUE;

    //
    // If this a datagram endpoint, cancel all IRPs and free any buffers
    // of data.  Note that if the state of the endpoint is just "open"
    // (not bound, etc.) then we can't have any pended IRPs or datagrams
    // on the endpoint.  Also, the lists of IRPs and datagrams may not
    // yet been initialized if the state is just open.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        if ( endpoint->State == AfdEndpointStateBound ||
                endpoint->State == AfdEndpointStateConnected) {

            //
            // Reset the counts of datagrams bufferred on the endpoint.
            // This prevents anyone from thinking that there is bufferred
            // data on the endpoint.
            //

            endpoint->DgBufferredReceiveCount = 0;
            endpoint->DgBufferredReceiveBytes = 0;

            //
            // Cancel all receive datagram and peek datagram IRPs on the
            // endpoint.
            //

            AfdCompleteIrpList(
                &endpoint->ReceiveDatagramIrpListHead,
                endpoint,
                STATUS_CANCELLED,
                AfdCleanupReceiveDatagramIrp
                );

            AfdCompleteIrpList(
                &endpoint->PeekDatagramIrpListHead,
                endpoint,
                STATUS_CANCELLED,
                AfdCleanupReceiveDatagramIrp
                );

        }
    }
    else if (IS_SAN_ENDPOINT (endpoint)) {
        if (!IsListEmpty (&endpoint->Common.SanEndp.IrpList)) {
            PIRP    irp;
            PDRIVER_CANCEL  cancelRoutine;
            KIRQL   cancelIrql;
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Acquire cancel spinlock and endpoint spinlock in
            // this order and recheck the IRP list
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);

            //
            // While list is not empty attempt to cancel the IRPs
            //
            while (!IsListEmpty (&endpoint->Common.SanEndp.IrpList)) {
                irp = CONTAINING_RECORD (
                        endpoint->Common.SanEndp.IrpList.Flink,
                        IRP,
                        Tail.Overlay.ListEntry);
                //
                // Reset the cancel routine.
                //
                cancelRoutine = IoSetCancelRoutine (irp, NULL);
                if (cancelRoutine!=NULL) {
                    //
                    // Cancel routine was not NULL, cancel it here.
                    // If someone else attempts to complete this IRP
                    // it will have to wait at least until cancel
                    // spinlock is released, so we can release
                    // the endpoint spinlock
                    //
                    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                    irp->CancelIrql = cancelIrql;
                    irp->Cancel = TRUE;
                    (*cancelRoutine) (AfdDeviceObject, irp);
                    
                    //
                    // Reacquire the locks
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                }
            }
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        else {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        }
    }
    else if (IS_SAN_HELPER (endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        if (endpoint==AfdSanServiceHelper)  {
            //
            // Last handle to the service helper is being closed.
            // We can no longer count on it, clear our global.
            //
            KeEnterCriticalRegion ();
            ExAcquireResourceExclusiveLite( AfdResource, TRUE );
            AfdSanServiceHelper = NULL;
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
        }
    }
    else {
        PAFD_CONNECTION connection;

        connection = AFD_CONNECTION_FROM_ENDPOINT( endpoint );
        ASSERT( connection == NULL || connection->Type == AfdBlockTypeConnection );

        //
        // Reference the connection object so that it does not go away while
        // we are freeing the resources
        //

        if (connection!=NULL) {
            REFERENCE_CONNECTION (connection);

            //
            // If this is a connected non-datagram socket and the send side has
            // not been disconnected and there is no outstanding data to be
            // received, begin a graceful disconnect on the connection.  If there
            // is unreceived data out outstanding IO, abort the connection.
            //

            if ( (endpoint->State == AfdEndpointStateConnected 
                        || endpoint->State==AfdEndpointStateBound
                        || endpoint->State==AfdEndpointStateTransmitClosing)
                                // Endpoint is in bound state when connection
                                // request is in progress, we still need
                                // to abort those.
        
                    &&
                connection->ConnectedReferenceAdded

                    &&

                !endpoint->afdC_Root        // these are connected on bind

                    &&

                ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) == 0)

                    &&

                ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) == 0 ||
                  IS_DATA_ON_CONNECTION(connection) ||
                  IS_EXPEDITED_DATA_ON_CONNECTION(connection) ||
                  ( !IS_TDI_BUFFERRING(endpoint) &&
                    connection->Common.NonBufferring.ReceiveBytesInTransport > 0 ) ||
                    endpoint->StateChangeInProgress)

                    &&

                !connection->AbortIndicated ) {

                ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

                if ( IS_DATA_ON_CONNECTION( connection )

                     ||

                     IS_EXPEDITED_DATA_ON_CONNECTION( connection )

                     ||

                     ( !IS_TDI_BUFFERRING(endpoint) &&
                        connection->Common.NonBufferring.ReceiveBytesInTransport > 0 )

                     ||

                     processExitTime.QuadPart != 0

                     ||

                     endpoint->OutstandingIrpCount != 0

                     ||
             
                     endpoint->StateChangeInProgress

                     ||

                     ( !IS_TDI_BUFFERRING(endpoint) &&
                          (!IsListEmpty( &connection->VcReceiveIrpListHead ) ||
                           !IsListEmpty( &connection->VcSendIrpListHead )) )

                     ) {

#if DBG
                    if ( processExitTime.QuadPart != 0 ) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                    "AfdCleanup: process exiting w/o closesocket, aborting endp %p\n",
                                    endpoint ));
                    }
                    else {
                        if ( IS_DATA_ON_CONNECTION( connection ) ) {
                            if (IS_TDI_BUFFERRING(endpoint)) {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd data on endp %p, aborting.  "
                                            "%ld ind, %ld taken, %ld out\n",
                                            endpoint,
                                            connection->Common.Bufferring.ReceiveBytesIndicated,
                                            connection->Common.Bufferring.ReceiveBytesTaken,
                                            connection->Common.Bufferring.ReceiveBytesOutstanding ));
                            }
                            else {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd data (%ld) on endp %p, aborting.\n",
                                            connection->Common.NonBufferring.BufferredReceiveBytes,
                                            endpoint ));
                            }
                        }

                        if ( IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
                            if (IS_TDI_BUFFERRING(endpoint)) {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd exp data on endp %p, aborting.  "
                                            "%ld ind, %ld taken, %ld out\n",
                                            endpoint,
                                            connection->Common.Bufferring.ReceiveExpeditedBytesIndicated,
                                            connection->Common.Bufferring.ReceiveExpeditedBytesTaken,
                                            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding ));
                            }
                            else {
                                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                            "AfdCleanup: unrecv'd exp data (%ld) on endp %p, aborting.\n",
                                            connection->Common.NonBufferring.BufferredExpeditedBytes,
                                            endpoint ));
                            }
                        }

                        if ( !IS_TDI_BUFFERRING(endpoint) &&
                            connection->Common.NonBufferring.ReceiveBytesInTransport > 0 ) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                        "AfdCleanup: unrecv'd data (%ld) in transport on endp %p, aborting.\n",
                                        connection->Common.NonBufferring.ReceiveBytesInTransport,
                                        endpoint));
                        }

                        if ( endpoint->OutstandingIrpCount != 0 ) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                        "AfdCleanup: %ld IRPs %s outstanding on endpoint %p, "
                                        "aborting.\n",
                                        endpoint->OutstandingIrpCount,
                                        (endpoint->StateChangeInProgress 
                                            ? "(accept, connect, or transmit file)"
                                            : ""),
                                        endpoint ));
                        }
                    }
#endif

                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    (VOID)AfdBeginAbort( connection );

                } else {

                    endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    status = AfdBeginDisconnect( endpoint, NULL, NULL );
                    if (!NT_SUCCESS (status)) {
                        //
                        // If disconnect failed, we have no choice but to abort the
                        // connection because we cannot return error from close and
                        // have application try it again.  If we don't abort, connection
                        // ends up hanging there forever.
                        //
                        (VOID)AfdBeginAbort (connection);
                    }
                }

            } else {

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // If this is a connected VC endpoint on a nonbufferring TDI provider,
            // cancel all outstanding send and receive IRPs.
            //

            if ( !IS_TDI_BUFFERRING(endpoint) ) {

                AfdCompleteIrpList(
                    &connection->VcReceiveIrpListHead,
                    endpoint,
                    STATUS_CANCELLED,
                    NULL
                    );

                AfdCompleteIrpList(
                    &connection->VcSendIrpListHead,
                    endpoint,
                    STATUS_CANCELLED,
                    AfdCleanupSendIrp
                    );
            }

            //
            // Remember that we have started cleanup on this connection.
            // We know that we'll never get a request on the connection
            // after we start cleanup on the connection.
            //

            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            connection->CleanupBegun = TRUE;

            //
            // Attempt to remove the connected reference.
            //

            AfdDeleteConnectedReference( connection, TRUE );
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Remove connection reference added in the beginning of this
            // function.  We can't access connection object after this point
            // because in can be freed inside the AfdDereferenceConnection.
            //

            DEREFERENCE_CONNECTION (connection);
            connection = NULL;
        }
        else {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        }

        //
        // Complete any outstanding wait for listen IRPs on the endpoint.
        //

        if ( (endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening ) {

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            while ( !IsListEmpty( &endpoint->Common.VcListening.ListeningIrpListHead ) ) {

                PIRP waitForListenIrp;
                PIO_STACK_LOCATION irpSp;

                listEntry = RemoveHeadList( &endpoint->Common.VcListening.ListeningIrpListHead );
                waitForListenIrp = CONTAINING_RECORD(
                                       listEntry,
                                       IRP,
                                       Tail.Overlay.ListEntry
                                       );
                //
                // Set FLink to NULL so that cancel routine won't touch the IRP.
                //

                listEntry->Flink = NULL;

                irpSp = IoGetCurrentIrpStackLocation (waitForListenIrp);
                if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
                    AfdCleanupSuperAccept (waitForListenIrp, STATUS_CANCELLED);
                }
                else {
                    waitForListenIrp->IoStatus.Status = STATUS_CANCELLED;
                    waitForListenIrp->IoStatus.Information = 0;
                }

                //
                // Release the AFD spin lock so that we can complete the
                // wait for listen IRP.
                //

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                //
                // Cancel the IRP.
                //

                //
                // Reset the cancel routine in the IRP.
                //

                if ( IoSetCancelRoutine( waitForListenIrp, NULL ) == NULL ) {
                    KIRQL cancelIrql;

                    //
                    // If the cancel routine was NULL then cancel routine
                    // may be running.  Wait on the cancel spinlock until
                    // the cancel routine is done.
                    //
                    // Note: The cancel routine will not find the IRP
                    // since it is not in the list.
                    //
                
                    IoAcquireCancelSpinLock( &cancelIrql );
                    ASSERT( waitForListenIrp->Cancel );
                    IoReleaseCancelSpinLock( cancelIrql );

                }

                IoCompleteRequest( waitForListenIrp, AfdPriorityBoost );

                //
                // Reacquire the AFD spin lock for the next pass through the
                // loop.
                //

                AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // Free all queued (free, unaccepted, and returned) connections
            // on the endpoint.
            //

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdFreeQueuedConnections( endpoint );
            endpoint->Common.VcListening.FailedConnectionAdds = 0;
        }
    }



    //
    // If there are pending routing notifications on endpoint, cancel them.
    // We must hold both cancel and endpoint spinlocks to make
    // sure that IRP is not completed as we are cancelling it
    //

    if (endpoint->RoutingQueryReferenced) {
        KIRQL cancelIrql;
        SHORT queryAddrType;
        IoAcquireCancelSpinLock( &cancelIrql );
        AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle );

        //
        // Can only have one cleanup IRP per endpoint
        // So this should not change
        //

        ASSERT (endpoint->RoutingQueryReferenced);
        endpoint->RoutingQueryReferenced = FALSE;
        if (endpoint->RoutingQueryIPv6) {
            queryAddrType = TDI_ADDRESS_TYPE_IP6;
            endpoint->RoutingQueryIPv6 = FALSE;
        }
        else {
            queryAddrType = TDI_ADDRESS_TYPE_IP;
        }

        listEntry = endpoint->RoutingNotifications.Flink;
        while (listEntry!=&endpoint->RoutingNotifications) {
            PIRP            notifyIrp;
            PROUTING_NOTIFY notifyCtx = CONTAINING_RECORD (listEntry,
                                                            ROUTING_NOTIFY,
                                                            NotifyListLink);
            listEntry = listEntry->Flink;

            //
            // Check if IRP has not been completed yet
            //

            notifyIrp = (PIRP)InterlockedExchangePointer ((PVOID *)&notifyCtx->NotifyIrp, NULL);
            if (notifyIrp!=NULL) {

                //
                // Remove it from the list and call cancel routing while still
                // holding cancel spinlock
                //

                RemoveEntryList (&notifyCtx->NotifyListLink);
                AfdReleaseSpinLockFromDpcLevel ( &endpoint->SpinLock, &lockHandle);
                notifyIrp->CancelIrql = cancelIrql;
                AfdCancelIrp (notifyIrp);

                //
                // Reacquire cancel and endpoint spinlocks
                //

                IoAcquireCancelSpinLock( &cancelIrql );
                AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle );
            }
        }

        AfdReleaseSpinLockFromDpcLevel ( &endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock( cancelIrql );
        
        AfdDereferenceRoutingQuery (queryAddrType);
    }


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    while (!IsListEmpty (&endpoint->RequestList)) {
        PAFD_REQUEST_CONTEXT    requestCtx;
        listEntry = RemoveHeadList (&endpoint->RequestList);
        listEntry->Flink = NULL;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        requestCtx = CONTAINING_RECORD (listEntry,
                                        AFD_REQUEST_CONTEXT,
                                        EndpointListLink);
        (*requestCtx->CleanupRoutine) (endpoint, requestCtx);
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    if ( endpoint->Irp != NULL) {

        PIRP transmitIrp;
        KIRQL cancelIrql;

        //
        // Release the endpoint and acquire the cancel spinlock
        // and then the enpoint spinlock.
        //
        
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        IoAcquireCancelSpinLock( &cancelIrql );
        AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle );

        //
        // Make sure there is still a transmit IRP.
        //

        transmitIrp = endpoint->Irp;

        if ( transmitIrp != NULL ) {
            PDRIVER_CANCEL  cancelRoutine;

            // indicate that it has to be cancelled
            transmitIrp->Cancel = TRUE;
            cancelRoutine = IoSetCancelRoutine( transmitIrp, NULL );
            if ( cancelRoutine != NULL ) {

                //
                // The IRP needs to be canceled.  Release the
                // endpoint spinlock.  The value in endpoint->Irp can
                // now change, but the IRP cannot be completed while the
                // cancel spinlock is held since we set the cancel flag
                // in the IRP.
                //

                AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );

                transmitIrp->CancelIrql = cancelIrql;
                cancelRoutine ( NULL, transmitIrp );   
            }
            else {
                // The IRP has not been completely setup yet
                // and will be cancelled in the dispatch routine
                AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );
                IoReleaseCancelSpinLock( cancelIrql );
            }

        } else {

            //
            // The IRP has been completed or canceled.  Release the locks
            // and continue.
            //

            AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );
            IoReleaseCancelSpinLock( cancelIrql );
        }

    } else {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Remember the new state of the endpoint.
    //

    //endpoint->State = AfdEndpointStateCleanup;

    //
    // Reset relevant event handlers on the endpoint.  This prevents
    // getting indications after we free the endpoint and connection
    // objects.  We should not be able to get new connects after this
    // handle has been cleaned up.
    //
    // Note that these calls can fail if, for example, DHCP changes the
    // host's IP address while the endpoint is active.
    //
    //

    if ( endpoint->AddressHandle != NULL ) {

        if ( endpoint->Listening) {
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_CONNECT,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );
        }

        if ( IS_DGRAM_ENDPOINT(endpoint) ) {
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE_DATAGRAM,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_ERROR_EX,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );
            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_ERROR,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );
        }

    }

    InterlockedIncrement(
        &AfdEndpointsCleanedUp
        );

    return STATUS_SUCCESS;

} // AfdCleanup


NTSTATUS
FASTCALL
AfdClose (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Close IRPs in AFD.  It
    dereferences the endpoint specified in the IRP, which will result in
    the endpoint being freed when all other references go away.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;

    PAGED_CODE( );

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdClose: closing file object %p, endpoint %p\n",
                    IrpSp->FileObject, endpoint ));
    }

    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdClose: closing endpoint at %p\n",
                    endpoint ));
    }

    connection = AFD_CONNECTION_FROM_ENDPOINT (endpoint);

    //
    // If there is a connection on this endpoint, dereference it here
    // rather than in AfdDereferenceEndpoint, because the connection
    // has a referenced pointer to the endpoint which must be removed
    // before the endpoint can dereference the connection.
    //

    if (connection != NULL) {
        endpoint->Common.VcConnecting.Connection = NULL;
        DEREFERENCE_CONNECTION (connection);
        //
        // This is to simplify debugging.
        // If connection is not being closed by the transport
        // we want to be able to find it in the debugger faster
        // then thru !poolfind AfdC.
        //
        endpoint->WorkItem.Context = connection;
    }
    else if (IS_SAN_ENDPOINT (endpoint) &&
                endpoint->Common.SanEndp.SwitchContext!=NULL) {
        PVOID requestCtx;
        endpoint->Common.SanEndp.FileObject = NULL;
        requestCtx = AFD_SWITCH_MAKE_REQUEST_CONTEXT(
                            ((ULONG)0xFFFFFFFF),
                            AFD_SWITCH_REQUEST_CLOSE); 
        IoSetIoCompletion (
                    endpoint->Common.SanEndp.SanHlpr->Common.SanHlpr.IoCompletionPort,// Port
                    endpoint->Common.SanEndp.SwitchContext,     // Key
                    requestCtx,                                 // ApcContext
                    STATUS_SUCCESS,                             // Status
                    0,                                          // Information
                    FALSE                                       // ChargeQuota
                    );
    }

    //
    // Set the state of the endpoint to closing and dereference to
    // get rid of the active reference.
    //

    ASSERT (endpoint->State!=AfdEndpointStateClosing);
    endpoint->State = AfdEndpointStateClosing;

    //
    // Dereference the endpoint to get rid of the active reference.
    // This will result in the endpoint storage being freed as soon
    // as all other references go away.
    //

    DEREFERENCE_ENDPOINT( endpoint );

    return STATUS_SUCCESS;

} // AfdClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\disconn.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    disconn.c

Abstract:

    This module contains the dispatch routines for AFD.

Author:

    David Treadwell (davidtr)    31-Mar-1992

Revision History:

--*/

#include "afdp.h"



NTSTATUS
AfdRestartAbort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDgDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

typedef struct _AFD_ABORT_CONTEXT {
    PAFD_CONNECTION Connection;
} AFD_ABORT_CONTEXT, *PAFD_ABORT_CONTEXT;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdPartialDisconnect )
#pragma alloc_text( PAGEAFD, AfdDisconnectEventHandler )
#pragma alloc_text( PAGEAFD, AfdBeginAbort )
#pragma alloc_text( PAGEAFD, AfdRestartAbort )
#pragma alloc_text( PAGEAFD, AfdBeginDisconnect )
#pragma alloc_text( PAGEAFD, AfdRestartDisconnect )
#endif


NTSTATUS
AfdPartialDisconnect(
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_PARTIAL_DISCONNECT_INFO disconnectInfo;

    //
    // Nothing to return.
    //

    *Information = 0;

    status = STATUS_SUCCESS;
    connection = NULL;

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
#ifdef _WIN64
    {
        C_ASSERT (sizeof (AFD_PARTIAL_DISCONNECT_INFO)==sizeof (AFD_PARTIAL_DISCONNECT_INFO32));
    }
#endif
    if (InputBufferLength<sizeof (disconnectInfo)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (disconnectInfo),
                                PROBE_ALIGNMENT32 (AFD_PARTIAL_DISCONNECT_INFO32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            disconnectInfo.DisconnectMode = ((PAFD_PARTIAL_DISCONNECT_INFO32)InputBuffer)->DisconnectMode;
            disconnectInfo.Timeout = ((PAFD_PARTIAL_DISCONNECT_INFO32)InputBuffer)->Timeout;
        }
        else
#endif _WIN64
        {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (disconnectInfo),
                                PROBE_ALIGNMENT (AFD_PARTIAL_DISCONNECT_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            disconnectInfo = *((PAFD_PARTIAL_DISCONNECT_INFO)InputBuffer);
        }
    } except( AFD_EXCEPTION_FILTER(&status) ) {
        goto exit;
    }

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPartialDisconnect: disconnecting endpoint %p, "
                    "mode %lx, endp mode %lx\n",
                    endpoint, disconnectInfo.DisconnectMode,
                    endpoint->DisconnectMode ));
    }

    //
    // If this is a datagram endpoint, just remember how the endpoint
    // was shut down, don't actually do anything.  Note that it is legal
    // to do a shutdown() on an unconnected datagram socket, so the
    // test that the socket must be connected is after this case.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        if ( (disconnectInfo.DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
            endpoint->DisconnectMode |= AFD_ABORTIVE_DISCONNECT;
        }

        if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
        }

        if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 ) {
            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
        }

        if (AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateBound)) {
            if ( (disconnectInfo.DisconnectMode & AFD_UNCONNECT_DATAGRAM) != 0 &&
                    endpoint->State==AfdEndpointStateConnected) {
                if( endpoint->Common.Datagram.RemoteAddress != NULL ) {
                    AFD_RETURN_REMOTE_ADDRESS(
                        endpoint->Common.Datagram.RemoteAddress,
                        endpoint->Common.Datagram.RemoteAddressLength
                        );
                }
                endpoint->Common.Datagram.RemoteAddress = NULL;
                endpoint->Common.Datagram.RemoteAddressLength = 0;
                
                //
                // Even if disconnect fails, we consider
                // ourselves not connected anymore
                //
                endpoint->State = AfdEndpointStateBound;

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                if (IS_TDI_DGRAM_CONNECTION(endpoint)) {
                    PIRP            irp;
                    KEVENT          event;
                    IO_STATUS_BLOCK ioStatusBlock;


                    KeInitializeEvent( &event, SynchronizationEvent, FALSE );
                    irp = TdiBuildInternalDeviceControlIrp (
                                TDI_DISCONNECT,
                                endpoint->AddressDeviceObject,
                                endpoint->AddressFileObject,
                                &event,
                                &ioStatusBlock
                                );

                    if ( irp != NULL ) {
                        TdiBuildDisconnect(
                            irp,
                            endpoint->AddressDeviceObject,
                            endpoint->AddressFileObject,
                            NULL,
                            NULL,
                            &disconnectInfo.Timeout,
                            (disconnectInfo.DisconnectMode & AFD_ABORTIVE_DISCONNECT)
                                ? TDI_DISCONNECT_ABORT
                                : TDI_DISCONNECT_RELEASE,
                            NULL,
                            NULL
                            );

                        status = IoCallDriver( endpoint->AddressDeviceObject, irp );
                        if ( status == STATUS_PENDING ) {
                            status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
                            ASSERT (status==STATUS_SUCCESS);
                        }
                        else {
                            //
                            // The IRP must have been completed then and event set.
                            //
                            ASSERT (NT_ERROR (status) || KeReadStateEvent (&event));
                        }
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                status = STATUS_SUCCESS;
            }

            AFD_END_STATE_CHANGE (endpoint);
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
        }

        goto exit;
    }

    //
    // Make sure that the endpoint is in the correct state.
    //

    if ( (endpoint->Type & AfdBlockTypeVcConnecting)!=AfdBlockTypeVcConnecting ||
            endpoint->Listening || 
            endpoint->afdC_Root ||
            endpoint->State != AfdEndpointStateConnected ||
            ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint))==NULL)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // If we're doing an abortive disconnect, remember that the receive
    // side is shut down and issue a disorderly release.
    //

    if ( (disconnectInfo.DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ) {

        IF_DEBUG(CONNECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPartialDisconnect: abortively disconnecting endp %p\n",
                        endpoint ));
        }

        status = AfdBeginAbort( connection );
        if ( status == STATUS_PENDING ) {
            status = STATUS_SUCCESS;
        }

        goto exit;
    }

    //
    // If the receive side of the connection is being shut down,
    // remember the fact in the endpoint.  If there is pending data on
    // the VC, do a disorderly release on the endpoint.  If the receive
    // side has already been shut down, do nothing.
    //

    if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 &&
         (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) == 0 ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Determine whether there is pending data.
        //

        if ( IS_DATA_ON_CONNECTION( connection ) ||
                 IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {

            //
            // There is unreceived data.  Abort the connection.
            //

            IF_DEBUG(CONNECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdPartialDisconnect: unreceived data on endp %p, conn %p, aborting.\n",
                              endpoint, connection ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            (VOID)AfdBeginAbort( connection );

            status = STATUS_SUCCESS;
            goto exit;

        } else {

            IF_DEBUG(CONNECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdPartialDisconnect: disconnecting recv for endp %p\n",
                            endpoint ));
            }

            //
            // Remember that the receive side is shut down.  This will cause
            // the receive indication handlers to dump any data that
            // arrived.
            //
            // !!! This is a minor violation of RFC1122 4.2.2.13.  We
            //     should really do an abortive disconnect if data
            //     arrives after a receive shutdown.
            //

            endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
    }

    //
    // If the send side is being shut down, remember it in the endpoint
    // and pass the request on to the TDI provider for a graceful
    // disconnect.  If the send side is already shut down, do nothing here.
    //

    if ( (disconnectInfo.DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 &&
         (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) == 0 ) {

        status = AfdBeginDisconnect( endpoint, &disconnectInfo.Timeout, NULL );
        if ( !NT_SUCCESS(status) ) {
            goto exit;
        }
        if ( status == STATUS_PENDING ) {
            status = STATUS_SUCCESS;
        }
    }

    status = STATUS_SUCCESS;

exit:
    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    return status;
} // AfdPartialDisconnect


NTSTATUS
AfdDisconnectEventHandler(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN int DisconnectDataLength,
    IN PVOID DisconnectData,
    IN int DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    )
{
    PAFD_CONNECTION connection = ConnectionContext;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS status;
    BOOLEAN result;

    ASSERT( connection != NULL );

    //
    // Reference the connection object so that it does not go away while
    // we're processing it inside this function.  Without this
    // reference, the user application could close the endpoint object,
    // the connection reference count could go to zero, and the
    // AfdDeleteConnectedReference call at the end of this function
    // could cause a crash if the AFD connection object has been
    // completely cleaned up.
    //

    CHECK_REFERENCE_CONNECTION( connection, result);
    if (!result) {
        return STATUS_SUCCESS;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth);

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdDisconnectEventHandler called for endpoint %p, connection %p\n",
                    connection->Endpoint, connection ));
    }

    UPDATE_CONN2( connection, "DisconnectEvent, flags: %lx", DisconnectFlags );


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connection is referenced, so it is safe to 
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // Set up in the connection the fact that the remote side has
    // disconnected or aborted.
    //

    if ( (DisconnectFlags & TDI_DISCONNECT_ABORT) != 0 ) {
        connection->AbortIndicated = TRUE;
        status = STATUS_REMOTE_DISCONNECT;
        AfdRecordAbortiveDisconnectIndications();
    } else {
        connection->DisconnectIndicated = TRUE;
        if ( !IS_MESSAGE_ENDPOINT(endpoint) ) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_GRACEFUL_DISCONNECT;
        }
        AfdRecordGracefulDisconnectIndications();
    }

    if (connection->State==AfdConnectionStateConnected) {
        ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
        if ( (DisconnectFlags & TDI_DISCONNECT_ABORT) != 0 ) {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_ABORT,
                STATUS_SUCCESS
                );

        } else {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_DISCONNECT,
                STATUS_SUCCESS
                );

        }
    }

    //
    // If this is a nonbufferring transport, complete any pended receives.
    //

    if ( !connection->TdiBufferring ) {

        //
        // If this is an abort indication, complete all pended sends and
        // discard any bufferred receive data.
        //

        if ( connection->AbortIndicated ) {

            connection->VcBufferredReceiveBytes = 0;
            connection->VcBufferredReceiveCount = 0;
            connection->VcBufferredExpeditedBytes = 0;
            connection->VcBufferredExpeditedCount = 0;
            connection->VcReceiveBytesInTransport = 0;

            while ( !IsListEmpty( &connection->VcReceiveBufferListHead ) ) {

                PAFD_BUFFER_HEADER afdBuffer;
                PLIST_ENTRY listEntry;

                listEntry = RemoveHeadList( &connection->VcReceiveBufferListHead );
                afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

                DEBUG afdBuffer->BufferListEntry.Flink = NULL;

                if (afdBuffer->RefCount==1 || // Can't change once off the list
                        InterlockedDecrement (&afdBuffer->RefCount)==0) {
                    afdBuffer->ExpeditedData = FALSE;
                    AfdReturnBuffer( afdBuffer, connection->OwningProcess);
                }
            }

            //
            // Check for the most typical case where we do not
            // have anything to complete and thus do not need to
            // make a call and take/release the spinlock.
            //
            if ( (IsListEmpty (&connection->VcSendIrpListHead) &&
                        IsListEmpty (&connection->VcReceiveIrpListHead)) ||
                    ((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening) ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            else {

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                AfdCompleteIrpList(
                    &connection->VcSendIrpListHead,
                    endpoint,
                    status,
                    AfdCleanupSendIrp
                    );

                AfdCompleteIrpList(
                    &connection->VcReceiveIrpListHead,
                    endpoint,
                    status,
                    NULL
                    );
            }
        }
        else {
            //
            // Check for the most typical case where we do not
            // have anything to complete and thus do not need to
            // make a call and take/release the spinlock.
            //
            if ( IsListEmpty (&connection->VcReceiveIrpListHead) ||
                    ((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                AfdCompleteIrpList(
                    &connection->VcReceiveIrpListHead,
                    endpoint,
                    status,
                    NULL
                    );
            }
        }


    }
    else {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // If we got disconnect data or options, save it.
    //

    if( ( DisconnectData != NULL && DisconnectDataLength > 0 ) ||
        ( DisconnectInformation != NULL && DisconnectInformationLength > 0 ) ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Check if connection was accepted and use accept endpoint instead
        // of the listening.  Note that accept cannot happen while we are
        // holding listening endpoint spinlock, nor can endpoint change after
        // the accept and while connection is referenced, so it is safe to 
        // release listening spinlock if we discover that endpoint was accepted.
        //
        if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
                && (connection->Endpoint != endpoint)) {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            endpoint = connection->Endpoint;
            ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
            ASSERT( !IS_TDI_BUFFERRING(endpoint) );
            ASSERT(  IS_VC_ENDPOINT (endpoint) );

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        }

        if( DisconnectData != NULL && DisconnectDataLength > 0 ) {

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_DISCONNECT_DATA,
                         DisconnectData,
                         DisconnectDataLength
                         );

            if( !NT_SUCCESS(status) ) {

                //
                // We hit an allocation failure, but press on regardless.
                //

                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdSaveReceivedConnectData failed: %08lx\n",
                    status
                    ));

            }

        }

        if( DisconnectInformation != NULL && DisconnectInformationLength > 0 ) {

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_DISCONNECT_DATA,
                         DisconnectInformation,
                         DisconnectInformationLength
                         );

            if( !NT_SUCCESS(status) ) {

                //
                // We hit an allocation failure, but press on regardless.
                //

                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdSaveReceivedConnectData failed: %08lx\n",
                    status
                    ));

            }

        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    }

    //
    // Call AfdIndicatePollEvent in case anyone is polling on this
    // connection getting disconnected or aborted.
    //
    // Make sure the connection was accepted/connected
    // in order not to signal on listening endpoint
    //

    if (connection->State==AfdConnectionStateConnected) {
        ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
        if ( (DisconnectFlags & TDI_DISCONNECT_ABORT) != 0 ) {

            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_ABORT,
                STATUS_SUCCESS
                );

        } else {

            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_DISCONNECT,
                STATUS_SUCCESS
                );

        }
    }

    //
    // Remove the connected reference on the connection object.  We must
    // do this AFTER setting up the flag which remembers the disconnect
    // type that occurred.  We must also do this AFTER we have finished
    // handling everything in the endpoint, since the endpoint structure
    // may no longer have any information about the connection object if
    // a transmit request with AFD_TF_REUSE_SOCKET happenned on it.
    //

    AfdDeleteConnectedReference( connection, FALSE );

    //
    // Dereference the connection from the reference added above.
    //

    DEREFERENCE_CONNECTION( connection );

    return STATUS_SUCCESS;

} // AfdDisconnectEventHandler


NTSTATUS
AfdBeginAbort(
    IN PAFD_CONNECTION Connection
    )
{
    PAFD_ENDPOINT endpoint = Connection->Endpoint;
    PIRP irp;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBeginAbort: aborting on endpoint %p\n",
                    endpoint ));
    }

    UPDATE_CONN( Connection );

    //
    // Build an IRP to reset the connection.  First get the address
    // of the target device object.
    //

    ASSERT( Connection->Type == AfdBlockTypeConnection );
    fileObject = Connection->FileObject;
    ASSERT( fileObject != NULL );
    deviceObject = IoGetRelatedDeviceObject( fileObject );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connection is referenced, so it is safe to 
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (Connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = Connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // If the endpoint has already been abortively disconnected,
    // or if has been gracefully disconnected and the transport
    // does not support orderly (i.e. two-phase) release, then just
    // succeed this request.
    //
    // Note that, since the abort completion routine (AfdRestartAbort)
    // will not be called, we must delete the connected reference
    // ourselves and complete outstanding send IRPs if ANY.
    //

    if ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ||
         Connection->AbortIndicated ||
         (Connection->DisconnectIndicated &&
             !IS_TDI_ORDERLY_RELEASE(endpoint) )) {
        if ( !IS_TDI_BUFFERRING(endpoint) &&
                endpoint->Type != AfdBlockTypeVcListening ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdCompleteIrpList(
                &Connection->VcSendIrpListHead,
                endpoint,
                STATUS_LOCAL_DISCONNECT,
                AfdCleanupSendIrp
                );
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }
        AfdDeleteConnectedReference( Connection, FALSE );
        return STATUS_SUCCESS;
    }

    //
    // Remember that the connection has been aborted.
    //

    if ( (endpoint->Type & AfdBlockTypeVcListening)!= AfdBlockTypeVcListening ) {
        endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_RECEIVE;
        endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;
        endpoint->DisconnectMode |= AFD_ABORTIVE_DISCONNECT;
    }

    Connection->AbortIndicated = TRUE;

    //
    // Set the BytesTaken fields equal to the BytesIndicated fields so
    // that no more AFD_POLL_RECEIVE or AFD_POLL_RECEIVE_EXPEDITED
    // events get completed.
    //

    if ( IS_TDI_BUFFERRING(endpoint) ) {

        Connection->Common.Bufferring.ReceiveBytesTaken =
            Connection->Common.Bufferring.ReceiveBytesIndicated;
        Connection->Common.Bufferring.ReceiveExpeditedBytesTaken =
            Connection->Common.Bufferring.ReceiveExpeditedBytesIndicated;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    } else if ( endpoint->Type != AfdBlockTypeVcListening ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Complete all of the connection's pended sends and receives.
        //

        AfdCompleteIrpList(
            &Connection->VcReceiveIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            NULL
            );

        AfdCompleteIrpList(
            &Connection->VcSendIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            AfdCleanupSendIrp
            );

    } else {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Allocate an IRP.  The stack size is one higher than that of the
    // target device, to allow for the caller's completion routine.
    //

    irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize), FALSE );

    if ( irp == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the IRP for an abortive disconnect.
    //

    irp->MdlAddress = NULL;

    irp->Flags = 0;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

    TdiBuildDisconnect(
        irp,
        deviceObject,
        fileObject,
        AfdRestartAbort,
        Connection,
        NULL,
        TDI_DISCONNECT_ABORT,
        NULL,
        NULL
        );

    //
    // Reference the connection object so that it does not go away
    // until the abort completes.
    //

    REFERENCE_CONNECTION( Connection );

    AfdRecordAbortiveDisconnectsInitiated();

    //
    // Pass the request to the transport provider.
    //

    return IoCallDriver( deviceObject, irp );

} // AfdBeginAbort



NTSTATUS
AfdRestartAbort(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{

    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;

    connection = Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    IF_DEBUG(CONNECT) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdRestartAbort: abort completed, status = %X, endpoint = %p\n",
            Irp->IoStatus.Status,
            connection->Endpoint
            ));

    }
    endpoint = connection->Endpoint;

    UPDATE_CONN2 ( connection, "Restart abort, status: %lx", Irp->IoStatus.Status);
    AfdRecordAbortiveDisconnectsCompleted();

    //
    // Remember that the connection has been aborted, and indicate if
    // necessary.
    //

    if( connection->State==AfdConnectionStateConnected ) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent (
            endpoint,
            AFD_POLL_ABORT,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_ABORT,
            STATUS_SUCCESS
            );

    }

    if( !connection->TdiBufferring ) {

        //
        // Complete all of the connection's pended sends and receives.
        //

        AfdCompleteIrpList(
            &connection->VcReceiveIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            NULL
            );

        AfdCompleteIrpList(
            &connection->VcSendIrpListHead,
            endpoint,
            STATUS_LOCAL_DISCONNECT,
            AfdCleanupSendIrp
            );

    }

    //
    // Remove the connected reference from the connection, since we
    // know that the connection will not be active any longer.
    //

    AfdDeleteConnectedReference( connection, FALSE );

    //
    // Dereference the AFD connection object.
    //

    DEREFERENCE_CONNECTION( connection );

    //
    // Free the IRP now since it is no longer needed.
    //

    IoFreeIrp( Irp );

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartAbort



NTSTATUS
AfdBeginDisconnect(
    IN PAFD_ENDPOINT Endpoint,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PIRP *DisconnectIrp OPTIONAL
    )
{
    PTDI_CONNECTION_INFORMATION requestConnectionInformation = NULL;
    PTDI_CONNECTION_INFORMATION returnConnectionInformation = NULL;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PAFD_DISCONNECT_CONTEXT disconnectContext;
    PIRP irp;


    if ( DisconnectIrp != NULL ) {
        *DisconnectIrp = NULL;
    }

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    ASSERT( Endpoint->Type == AfdBlockTypeVcConnecting );

    connection = AFD_CONNECTION_FROM_ENDPOINT( Endpoint );

    if (connection==NULL) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_SUCCESS;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );
    UPDATE_CONN( connection );


    //
    // If the endpoint has already been abortively disconnected,
    // just succeed this request.
    //
    if ( (Endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) != 0 ||
             connection->AbortIndicated ) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_SUCCESS;
    }

    //
    // If this connection has already been disconnected, just succeed.
    //

    if ( (Endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_SEND) != 0 ) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_SUCCESS;
    }

    fileObject = connection->FileObject;
    ASSERT( fileObject != NULL );
    deviceObject = IoGetRelatedDeviceObject( fileObject );


    //
    // Allocate and initialize a disconnect IRP.
    //

    irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize), FALSE );
    if ( irp == NULL ) {
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the IRP.
    //

    irp->MdlAddress = NULL;

    irp->Flags = 0;
    irp->RequestorMode = KernelMode;
    irp->PendingReturned = FALSE;

    irp->UserIosb = NULL;
    irp->UserEvent = NULL;

    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

    irp->AssociatedIrp.SystemBuffer = NULL;
    irp->UserBuffer = NULL;

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.AuxiliaryBuffer = NULL;


    //
    // Use the disconnect context space in the connection structure.
    //

    disconnectContext = &connection->DisconnectContext;
    disconnectContext->Irp = irp;

    //
    // Remember that the send side has been disconnected.
    //

    Endpoint->DisconnectMode |= AFD_PARTIAL_DISCONNECT_SEND;

    //
    // If there are disconnect data buffers, allocate request
    // and return connection information structures and copy over
    // pointers to the structures.
    //

    if ( connection->ConnectDataBuffers != NULL ) {

        requestConnectionInformation = &connection->ConnectDataBuffers->RequestConnectionInfo;
        RtlZeroMemory (requestConnectionInformation, sizeof (*requestConnectionInformation));

        requestConnectionInformation->UserData =
            connection->ConnectDataBuffers->SendDisconnectData.Buffer;
        requestConnectionInformation->UserDataLength =
            connection->ConnectDataBuffers->SendDisconnectData.BufferLength;
        requestConnectionInformation->Options =
            connection->ConnectDataBuffers->SendDisconnectOptions.Buffer;
        requestConnectionInformation->OptionsLength =
            connection->ConnectDataBuffers->SendDisconnectOptions.BufferLength;

        returnConnectionInformation = &connection->ConnectDataBuffers->ReturnConnectionInfo;
        RtlZeroMemory (returnConnectionInformation, sizeof (*returnConnectionInformation));

        returnConnectionInformation->UserData =
            connection->ConnectDataBuffers->ReceiveDisconnectData.Buffer;
        returnConnectionInformation->UserDataLength =
            connection->ConnectDataBuffers->ReceiveDisconnectData.BufferLength;
        returnConnectionInformation->Options =
            connection->ConnectDataBuffers->ReceiveDisconnectOptions.Buffer;
        returnConnectionInformation->OptionsLength =
            connection->ConnectDataBuffers->ReceiveDisconnectOptions.BufferLength;
    }

    //
    // Set up the timeout for the disconnect.
    //

    if (Timeout==NULL) {
        disconnectContext->Timeout.QuadPart = -1;
    }
    else {
        disconnectContext->Timeout.QuadPart = Timeout->QuadPart;
    }

    //
    // Build a disconnect Irp to pass to the TDI provider.
    //

    TdiBuildDisconnect(
        irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartDisconnect,
        connection,
        &disconnectContext->Timeout,
        TDI_DISCONNECT_RELEASE,
        requestConnectionInformation,
        returnConnectionInformation
        );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBeginDisconnect: disconnecting endpoint %p\n",
                    Endpoint ));
    }

    //
    // Reference the connection so the space stays
    // allocated until the disconnect completes.
    //

    REFERENCE_CONNECTION( connection );

    //
    // If there are still outstanding sends and this is a nonbufferring
    // TDI transport which does not support orderly release, pend the
    // IRP until all the sends have completed.
    //

    if ( !IS_TDI_ORDERLY_RELEASE(Endpoint) &&
         !IS_TDI_BUFFERRING(Endpoint) && connection->VcBufferredSendCount != 0 ) {

        ASSERT( connection->VcDisconnectIrp == NULL );

        connection->VcDisconnectIrp = irp;
        connection->SpecialCondition = TRUE;
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

        return STATUS_PENDING;
    }

    AfdRecordGracefulDisconnectsInitiated();
    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );


    //
    // Pass the disconnect request on to the TDI provider.
    //

    if ( DisconnectIrp == NULL ) {
        return IoCallDriver( connection->DeviceObject, irp );
    } else {
        *DisconnectIrp = irp;
        return STATUS_SUCCESS;
    }

} // AfdBeginDisconnect


NTSTATUS
AfdRestartDisconnect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECTION connection=Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;


    UPDATE_CONN2( connection, "Restart disconnect, status: %lx", Irp->IoStatus.Status );
    AfdRecordGracefulDisconnectsCompleted();

    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartDisconnect: disconnect completed, status = %X, endpoint = %p\n",
                    Irp->IoStatus.Status, connection->Endpoint ));
    }

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        if (connection->ConnectDataBuffers!=NULL) {
            PAFD_ENDPOINT   endpoint = connection->Endpoint;

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

            //
            // Check if connection was accepted and use accept endpoint instead
            // of the listening.  Note that accept cannot happen while we are
            // holding listening endpoint spinlock, nor can endpoint change after
            // the accept and while connection is referenced, so it is safe to 
            // release listening spinlock if we discover that endpoint was accepted.
            //
            if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
                    && (connection->Endpoint != endpoint)) {
                AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

                endpoint = connection->Endpoint;
                ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
                ASSERT( !IS_TDI_BUFFERRING(endpoint) );
                ASSERT( IS_VC_ENDPOINT (endpoint) );

                AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            }

            connectDataBuffers = connection->ConnectDataBuffers;
            if (connectDataBuffers!=NULL) {
                if( connectDataBuffers->ReturnConnectionInfo.UserData != NULL && 
                        connectDataBuffers->ReturnConnectionInfo.UserDataLength > 0 ) {
                    NTSTATUS    status;


                    status = AfdSaveReceivedConnectData(
                                 &connectDataBuffers,
                                 IOCTL_AFD_SET_DISCONNECT_DATA,
                                 connectDataBuffers->ReturnConnectionInfo.UserData,
                                 connectDataBuffers->ReturnConnectionInfo.UserDataLength
                                 );
                    ASSERT (NT_SUCCESS(status));
                }

                if( connectDataBuffers->ReturnConnectionInfo.Options != NULL &&
                        connectDataBuffers->ReturnConnectionInfo.OptionsLength > 0 ) {
                    NTSTATUS    status;

                    status = AfdSaveReceivedConnectData(
                                 &connectDataBuffers,
                                 IOCTL_AFD_SET_DISCONNECT_OPTIONS,
                                 connectDataBuffers->ReturnConnectionInfo.Options,
                                 connectDataBuffers->ReturnConnectionInfo.OptionsLength
                                 );

                    ASSERT (NT_SUCCESS(status));
                }

            }
            AfdReleaseSpinLock (&connection->Endpoint->SpinLock, &lockHandle);
        }
    }
    else {
        AfdBeginAbort (connection);
    }


    DEREFERENCE_CONNECTION( connection );

    //
    // Free the IRP and return a status code so that the IO system will
    // stop working on the IRP.
    //

    IoFreeIrp( Irp );
    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartDisconnect
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\buffer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains routines for handling non-bufferring TDI
    providers.  The AFD interface assumes that bufferring will be done
    below AFD; if the TDI provider doesn't buffer, then AFD must.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

PAFD_BUFFER
AfdInitializeBuffer (
    IN PVOID MemBlock,
    IN ULONG BufferDataSize,
    IN ULONG AddressSize
    );


#if DBG
VOID
AfdFreeBufferReal (
    PVOID   AfdBuffer
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdAllocateBuffer )
#pragma alloc_text( PAGEAFD, AfdFreeBuffer )
#if DBG
#pragma alloc_text( PAGEAFD, AfdFreeBufferReal )
#endif
#pragma alloc_text( PAGEAFD, AfdCalculateBufferSize )
#pragma alloc_text( PAGEAFD, AfdInitializeBuffer )
#pragma alloc_text( PAGEAFD, AfdGetBuffer )
#pragma alloc_text( PAGEAFD, AfdReturnBuffer )
#pragma alloc_text( PAGEAFD, AfdAllocateBufferTag )
#pragma alloc_text( PAGEAFD, AfdFreeBufferTag )
#pragma alloc_text( PAGEAFD, AfdAllocateRemoteAddress )
#pragma alloc_text( PAGEAFD, AfdFreeRemoteAddress )
#pragma alloc_text( PAGEAFD, AfdInitializeBufferTag )
#pragma alloc_text( PAGEAFD, AfdGetBufferTag )
#pragma alloc_text( INIT, AfdInitializeBufferManager)
#endif


PVOID
AfdAllocateBuffer (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    AFD buffer structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the AFD buffer.

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized PAFD_BUFFER, or NULL if the allocation
        attempt fails.

--*/

{
    ULONG       dataLength;
    PVOID       memBlock;

    //
    // Get nonpaged pool for the buffer.
    //

    memBlock = AFD_ALLOCATE_POOL( PoolType, NumberOfBytes, Tag );
    if ( memBlock == NULL ) {
        return NULL;
    }

    if (NumberOfBytes==AfdLookasideLists->SmallBufferList.L.Size) {
        dataLength = AfdSmallBufferSize;
    }
    else if (NumberOfBytes==AfdLookasideLists->MediumBufferList.L.Size) {
        dataLength = AfdMediumBufferSize;
    }
    else if (NumberOfBytes==AfdLookasideLists->LargeBufferList.L.Size) {
        dataLength = AfdLargeBufferSize;
    }
    else {
        ASSERT (FALSE);
    }
    //
    // Initialize the buffer and return a pointer to it.
    //
#if DBG
    {
        PAFD_BUFFER afdBuffer = AfdInitializeBuffer( memBlock, dataLength, AfdStandardAddressLength );
        ASSERT ((PCHAR)afdBuffer+sizeof (AFD_BUFFER)<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->Buffer+dataLength<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->Irp+IoSizeOfIrp(AfdIrpStackSize-1)<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->Mdl+MmSizeOfMdl(afdBuffer->Buffer, dataLength)<=(PCHAR)memBlock+NumberOfBytes &&
                    (PCHAR)afdBuffer->TdiInfo.RemoteAddress+AfdStandardAddressLength<=(PCHAR)memBlock+NumberOfBytes);
        return afdBuffer;
    }
#else
    return AfdInitializeBuffer( memBlock, dataLength, AfdStandardAddressLength );
#endif


} // AfdAllocateBuffer


VOID
NTAPI
AfdFreeBuffer (
    PVOID   AfdBuffer
    )
{
    ASSERT( ((PAFD_BUFFER)AfdBuffer)->BufferLength == AfdSmallBufferSize ||
            ((PAFD_BUFFER)AfdBuffer)->BufferLength == AfdMediumBufferSize ||
            ((PAFD_BUFFER)AfdBuffer)->BufferLength == AfdLargeBufferSize );
#if DBG
    AfdFreeBufferReal (AfdBuffer);
}

VOID
NTAPI
AfdFreeBufferReal (
    PVOID   AfdBuffer
    )
{
#endif
    {
        PAFD_BUFFER hdr = AfdBuffer;
        switch (hdr->Placement) {
        case AFD_PLACEMENT_BUFFER:
            AfdBuffer = hdr->Buffer;
            break;
        case AFD_PLACEMENT_HDR:
            AfdBuffer = hdr;
            break;
        case AFD_PLACEMENT_MDL:
            AfdBuffer = hdr->Mdl;
            break;
        case AFD_PLACEMENT_IRP:
            AfdBuffer = hdr->Irp;
            break;
        default:
            ASSERT (!"Unknown placement!");
            __assume (0);
        }
        if (hdr->AlignmentAdjusted) {
            //
            // The original memory block was adjusted to meet alignment
            // requirement of AFD buffers.
            // The amount of adjustment should be stored in the space
            // used for adjustment (right below the first piece).
            //
            ASSERT ((*(((PSIZE_T)AfdBuffer)-1))>0 &&
                        (*(((PSIZE_T)AfdBuffer)-1))<AfdBufferAlignment);
            AfdBuffer = (PUCHAR)AfdBuffer - (*(((PSIZE_T)AfdBuffer)-1));
        }
        AFD_FREE_POOL (AfdBuffer, AFD_DATA_BUFFER_POOL_TAG);
    }
}


PVOID
AfdAllocateBufferTag (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    AFD buffer tag structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the AFD buffer tag (0).

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized PAFD_BUFFER_TAG, or NULL if the allocation
        attempt fails.

--*/

{
    PAFD_BUFFER_TAG afdBufferTag;

    //
    // The requested length must be the same as buffer tag size
    //

    ASSERT(NumberOfBytes == sizeof (AFD_BUFFER_TAG) );

    //
    // Get nonpaged pool for the buffer tag.
    //

    afdBufferTag = AFD_ALLOCATE_POOL( PoolType, sizeof (AFD_BUFFER_TAG), Tag );
    if ( afdBufferTag == NULL ) {
        return NULL;
    }

    //
    // Initialize the buffer tag and return a pointer to it.
    //

    AfdInitializeBufferTag( afdBufferTag, 0 );

    return afdBufferTag;


} // AfdAllocateBufferTag

VOID
NTAPI
AfdFreeBufferTag (
    PVOID   AfdBufferTag
    )
{
    AFD_FREE_POOL (AfdBufferTag, AFD_DATA_BUFFER_POOL_TAG);
}


PVOID
AfdAllocateRemoteAddress (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )

/*++

Routine Description:

    Used by the lookaside list allocation function to allocate a new
    remote address structure.  The returned structure will be fully
    initialized.

Arguments:

    PoolType - passed to ExAllocatePoolWithTag.

    NumberOfBytes - the number of bytes required for the data buffer
        portion of the AFD buffer tag (0).

    Tag - passed to ExAllocatePoolWithTag.

Return Value:

    PVOID - a fully initialized remote address, or NULL if the allocation
        attempt fails.

--*/

{
    //
    // The requested length must be the same as standard address size
    //

    ASSERT(NumberOfBytes == AfdStandardAddressLength );

    //
    // Get nonpaged pool for the remote address.
    //

    return AFD_ALLOCATE_POOL( PoolType, AfdStandardAddressLength, Tag );


} // AfdAllocateRemoteAddress

VOID
NTAPI
AfdFreeRemoteAddress (
    PVOID   AfdBufferTag
    )
{
    AFD_FREE_POOL (AfdBufferTag, AFD_REMOTE_ADDRESS_POOL_TAG);
}


ULONG
AfdCalculateBufferSize (
    IN ULONG BufferDataSize,
    IN ULONG AddressSize
    )

/*++

Routine Description:

    Determines the size of an AFD buffer structure given the amount of
    data that the buffer contains.

Arguments:

    BufferDataSize - data length of the buffer.

    AddressSize - length of address structure for the buffer.

Return Value:

    Number of bytes needed for an AFD_BUFFER structure for data of
    this size.

--*/

{
    ULONG irpSize;
    ULONG mdlSize;
    ULONG hdrSize;
    ULONG size;

    //
    // Determine the sizes of the various components of an AFD_BUFFER
    // structure.
    //

    hdrSize = sizeof (AFD_BUFFER);
    irpSize = IoSizeOfIrp( AfdIrpStackSize-1 );
    //
    // For mdl size calculation we rely on ex guarantee that buffer will be
    // aligned on the page boundary (for allocations >= PAGE_SIZE)
    // or will not spawn pages (for allocations < PAGE_SIZE).
    //
    mdlSize = (CLONG)MmSizeOfMdl( NULL, BufferDataSize );

    size = ALIGN_UP_A(hdrSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                ALIGN_UP_A(irpSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                ALIGN_UP_A(mdlSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                ALIGN_UP_A(BufferDataSize,AFD_MINIMUM_BUFFER_ALIGNMENT) +
                AddressSize;
    if (size>=PAGE_SIZE)
        return size;
    else {
        size += AfdAlignmentOverhead;
        if (size>=PAGE_SIZE) {
            return PAGE_SIZE;
        }
        else
            return size;
    }
} // AfdCalculateBufferSize


PAFD_BUFFER
AfdGetBuffer (
    IN ULONG BufferDataSize,
    IN ULONG  AddressSize,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    Obtains a buffer of the appropriate size for the caller.  Uses
    the preallocated buffers if possible, or else allocates a new buffer
    structure if required.

Arguments:

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

    AddressSize - size of the address field required for the buffer.

Return Value:

    PAFD_BUFFER - a pointer to an AFD_BUFFER structure, or NULL if one
        was not available or could not be allocated.

--*/

{
    ULONG bufferSize;
    PNPAGED_LOOKASIDE_LIST lookasideList;
    NTSTATUS    status;

    //
    // If possible, allocate the buffer from one of the lookaside lists.
    //

    if ( AddressSize <= AfdStandardAddressLength &&
             BufferDataSize <= AfdLargeBufferSize ) {
        PAFD_BUFFER afdBuffer;

        if ( BufferDataSize <= AfdSmallBufferSize ) {

            lookasideList = &AfdLookasideLists->SmallBufferList;

        } else if ( BufferDataSize <= AfdMediumBufferSize ) {

            lookasideList = &AfdLookasideLists->MediumBufferList;

        } else {

            lookasideList = &AfdLookasideLists->LargeBufferList;
        }

        afdBuffer = ExAllocateFromNPagedLookasideList( lookasideList );
        if ( afdBuffer != NULL) {

            if (!afdBuffer->Lookaside) {
                status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                lookasideList->L.Size);

                if (!NT_SUCCESS (status)) {
                    AfdFreeBuffer (afdBuffer);
                    goto ExitQuotaFailure;
                }

                AfdRecordQuotaHistory(
                    process,
                    (LONG)lookasideList->L.Size,
                    "BuffAlloc   ",
                    afdBuffer
                    );
                AfdRecordPoolQuotaCharged(lookasideList->L.Size);
            }

#if DBG
            RtlGetCallersAddress(
                &afdBuffer->Caller,
                &afdBuffer->CallersCaller
                );
#endif
            return afdBuffer;
        }
    }
    else if (AddressSize<=0xFFFF) {
        PVOID memBlock;
        LONG  sz;

        //
        // Couldn't find an appropriate buffer that was preallocated.
        // Allocate one manually.  If the buffer size requested was
        // zero bytes, give them four bytes.  This is because some of
        // the routines like MmSizeOfMdl() cannot handle getting passed
        // in a length of zero.
        //
        // !!! It would be good to ROUND_TO_PAGES for this allocation
        //     if appropriate, then use entire buffer size.
        //

        if ( BufferDataSize == 0 ) {
            BufferDataSize = sizeof(ULONG);
        }

        bufferSize = AfdCalculateBufferSize( BufferDataSize, AddressSize );

        //
        // Check for overflow.
        //
        if (bufferSize>=BufferDataSize && bufferSize>=AddressSize) {

            memBlock = AFD_ALLOCATE_POOL(
                            NonPagedPool,
                            bufferSize,
                            AFD_DATA_BUFFER_POOL_TAG
                            );

            if ( memBlock != NULL) {
                status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                sz = BufferDataSize
                                    +AfdBufferOverhead
                                    +AddressSize
                                    -AfdStandardAddressLength
                                    +BufferDataSize<PAGE_SIZE
                                        ? min (AfdAlignmentOverhead, PAGE_SIZE-BufferDataSize)
                                        : 0);
                if (NT_SUCCESS (status)) {
                    PAFD_BUFFER afdBuffer;

                    //
                    // Initialize the AFD buffer structure and return it.
                    //

                    afdBuffer = AfdInitializeBuffer( memBlock, BufferDataSize, AddressSize );

                    ASSERT ((PCHAR)afdBuffer+sizeof (AFD_BUFFER)<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->Buffer+BufferDataSize<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->Irp+IoSizeOfIrp(AfdIrpStackSize-1)<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->Mdl+MmSizeOfMdl(afdBuffer->Buffer, BufferDataSize)<=(PCHAR)memBlock+bufferSize &&
                                (PCHAR)afdBuffer->TdiInfo.RemoteAddress+AddressSize<=(PCHAR)memBlock+bufferSize);

                    AfdRecordPoolQuotaCharged(sz);
                
                    AfdRecordQuotaHistory(
                        process,
                        sz,
                        "BuffAlloc   ",
                        afdBuffer
                        );

    #if DBG
                    RtlGetCallersAddress(
                        &afdBuffer->Caller,
                        &afdBuffer->CallersCaller
                        );
    #endif

                    return afdBuffer;
                }
                else {
                    AFD_FREE_POOL (memBlock, AFD_DATA_BUFFER_POOL_TAG);
                    goto ExitQuotaFailure;
                }
            } // memblock==NULL
        } // overflow
    }
    else {
        // TDI does not support addresses > USHORT
        ASSERT (FALSE);
    }

    //
    // This is default status code.
    // Quota failures jump directly to the
    // label below to raise the status returned by
    // the quota charging code if requested by the caller..
    //
    status = STATUS_INSUFFICIENT_RESOURCES;

ExitQuotaFailure:
    if ((ULONG_PTR)Process & AFDB_RAISE_ON_FAILURE) {
        ExRaiseStatus (status);
    }

    return NULL;

} // AfdGetBuffer


PAFD_BUFFER_TAG
AfdGetBufferTag (
    IN ULONG AddressSize,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    Obtains a buffer for tagging TDSU received via chained indication.  Uses
    the preallocated buffers if possible, or else allocates a new buffer
    structure if required.

Arguments:

    AddressSize - size of the address field required for the buffer.

Return Value:

    PAFD_BUFFER_TAG - a pointer to an AFD_BUFFER_TAG structure, or NULL if one
        was not available or could not be allocated.

--*/

{
    PAFD_BUFFER_TAG afdBufferTag;
    ULONG           bufferSize;
    NTSTATUS        status;

    if ( AddressSize <= AfdStandardAddressLength) {
        if (AddressSize>0)
            AddressSize = AfdStandardAddressLength;
        afdBufferTag = ExAllocateFromNPagedLookasideList( 
                                &AfdLookasideLists->BufferTagList );
        if ( afdBufferTag != NULL &&
                ( AddressSize==0 || 
                    (afdBufferTag->TdiInfo.RemoteAddress = 
                                ExAllocateFromNPagedLookasideList( 
                                &AfdLookasideLists->RemoteAddrList ))!=NULL ) ) {

            afdBufferTag->AllocatedAddressLength = (USHORT)AddressSize;
            if (!afdBufferTag->Lookaside) {
                status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                sizeof (AFD_BUFFER_TAG)+AddressSize);
                if (!NT_SUCCESS (status)) {
                    if ((afdBufferTag->TdiInfo.RemoteAddress!=NULL) &&
                            (afdBufferTag->TdiInfo.RemoteAddress != (PVOID)(afdBufferTag+1))) {
                        ExFreeToNPagedLookasideList( &AfdLookasideLists->RemoteAddrList, 
                                                            afdBufferTag->TdiInfo.RemoteAddress );
                    }
                    AFD_FREE_POOL (afdBufferTag, AFD_DATA_BUFFER_POOL_TAG);
                    goto ExitQuotaFailure;
                }

                AfdRecordQuotaHistory(
                    process,
                    (LONG)(sizeof (AFD_BUFFER_TAG)+AddressSize),
                    "BuffAlloc   ",
                    afdBufferTag
                    );
                AfdRecordPoolQuotaCharged(sizeof (AFD_BUFFER_TAG)+AddressSize);
            }
#if DBG
            RtlGetCallersAddress(
                &afdBufferTag->Caller,
                &afdBufferTag->CallersCaller
                );
#endif
            return afdBufferTag;
        } // afdBufferTag==NULL || RemoteAddress==NULL
    }
    else if (AddressSize<=0xFFFF) {
        bufferSize = sizeof (AFD_BUFFER_TAG) + AddressSize;

        afdBufferTag = AFD_ALLOCATE_POOL(
                        NonPagedPool,
                        bufferSize,
                        AFD_DATA_BUFFER_POOL_TAG
                        );

        if (afdBufferTag!=NULL) {
            status = PsChargeProcessPoolQuota (
                                (PEPROCESS)((ULONG_PTR)Process & (~AFDB_RAISE_ON_FAILURE)),
                                NonPagedPool,
                                bufferSize);
            if (NT_SUCCESS (status)) {

                //
                // Initialize the AFD buffer structure and return it.
                //

                AfdInitializeBufferTag (afdBufferTag, AddressSize);
                AfdRecordQuotaHistory(
                    process,
                    (LONG)bufferSize,
                    "BuffAlloc   ",
                    afdBufferTag
                    );

                AfdRecordPoolQuotaCharged(bufferSize);
#if DBG
                RtlGetCallersAddress(
                    &afdBufferTag->Caller,
                    &afdBufferTag->CallersCaller
                    );
#endif
                return afdBufferTag;
            }
            else {
                AFD_FREE_POOL (afdBufferTag, AFD_DATA_BUFFER_POOL_TAG);
                goto ExitQuotaFailure;
            }
        }
    }
    else {
        // TDI does not support addresses > USHORT
        ASSERT (FALSE);
    }

    //
    // This is default status code.
    // Quota failures jump directly to the
    // label below to raise the status returned by
    // the quota charging code if requested by the caller..
    //

    status = STATUS_INSUFFICIENT_RESOURCES;

ExitQuotaFailure:

    if ((ULONG_PTR)Process & AFDB_RAISE_ON_FAILURE) {
        ExRaiseStatus (status);
    }

    return NULL;
}


VOID
AfdReturnBuffer (
    IN PAFD_BUFFER_HEADER AfdBufferHeader,
    IN PEPROCESS Process
    )

/*++

Routine Description:

    Returns an AFD buffer to the appropriate global list, or frees
    it if necessary.

Arguments:

    AfdBufferHeader - points to the AFD_BUFFER_HEADER structure to return or free.

Return Value:

    None.

--*/

{

    
    if (AfdBufferHeader->BufferLength!=AfdBufferTagSize) {
        PNPAGED_LOOKASIDE_LIST lookasideList;
        PAFD_BUFFER AfdBuffer = CONTAINING_RECORD (AfdBufferHeader, AFD_BUFFER, Header);

        ASSERT (IS_VALID_AFD_BUFFER (AfdBuffer));
        
        //
        // Most of the AFD buffer must be zeroed when returning the buffer.
        //

        ASSERT( !AfdBuffer->ExpeditedData );
        ASSERT( AfdBuffer->Mdl->ByteCount == AfdBuffer->BufferLength );
        ASSERT( AfdBuffer->Mdl->Next == NULL );



        //
        // If appropriate, return the buffer to one of the AFD buffer
        // lookaside lists.
        //

        if (AfdBuffer->AllocatedAddressLength == AfdStandardAddressLength &&
                    AfdBuffer->BufferLength <= AfdLargeBufferSize) {

            if (AfdBuffer->BufferLength==AfdSmallBufferSize) {
                lookasideList = &AfdLookasideLists->SmallBufferList;
            } else if (AfdBuffer->BufferLength == AfdMediumBufferSize) {
                lookasideList = &AfdLookasideLists->MediumBufferList;
            } else { 
                ASSERT (AfdBuffer->BufferLength==AfdLargeBufferSize);
                lookasideList = &AfdLookasideLists->LargeBufferList;
            }

            if (!AfdBuffer->Lookaside) {
                PsReturnPoolQuota (Process, NonPagedPool, lookasideList->L.Size);
                AfdRecordQuotaHistory(
                    Process,
                    -(LONG)lookasideList->L.Size,
                    "BuffDealloc ",
                    AfdBuffer
                    );
                AfdRecordPoolQuotaReturned(
                    lookasideList->L.Size
                    );
                AfdBuffer->Lookaside = TRUE;
            }
            ExFreeToNPagedLookasideList( lookasideList, AfdBuffer );

            return;

        }



        // The buffer was not from a lookaside list allocation, so just free
        // the pool we used for it.
        //

        ASSERT (AfdBuffer->Lookaside==FALSE);
        {
            LONG    sz;
            PsReturnPoolQuota (Process,
                                  NonPagedPool,
                                  sz=AfdBuffer->BufferLength
                                        +AfdBufferOverhead
                                        +AfdBuffer->AllocatedAddressLength
                                        -AfdStandardAddressLength
                                        +AfdBuffer->BufferLength<PAGE_SIZE 
                                            ? min (AfdAlignmentOverhead, PAGE_SIZE-AfdBuffer->BufferLength)
                                            : 0);
            AfdRecordQuotaHistory(
                Process,
                -(LONG)sz,
                "BuffDealloc ",
                AfdBuffer
                );
            AfdRecordPoolQuotaReturned(
                sz
                );
        }
#if DBG
        AfdFreeBufferReal (AfdBuffer);
#else
        AfdFreeBuffer (AfdBuffer);
#endif

        return;
    }
    else {
        PAFD_BUFFER_TAG AfdBufferTag = CONTAINING_RECORD (AfdBufferHeader, AFD_BUFFER_TAG, Header);

        ASSERT( !AfdBufferTag->ExpeditedData );

        if (AfdBufferTag->NdisPacket) {
            AfdBufferTag->NdisPacket = FALSE;
            TdiReturnChainedReceives (&AfdBufferTag->Context, 1);
        }

        if (AfdBufferTag->TdiInfo.RemoteAddress != (PVOID)(AfdBufferTag+1)) {
            if (AfdBufferTag->TdiInfo.RemoteAddress!=NULL) {
                ASSERT (AfdBufferTag->AllocatedAddressLength==AfdStandardAddressLength);
                ExFreeToNPagedLookasideList( &AfdLookasideLists->RemoteAddrList, 
                                                    AfdBufferTag->TdiInfo.RemoteAddress );
                AfdBufferTag->TdiInfo.RemoteAddress = NULL;
            }
            else {
                ASSERT (AfdBufferTag->AllocatedAddressLength==0);
            }

            if (!AfdBufferTag->Lookaside) {
                LONG    sz;
                PsReturnPoolQuota (
                                Process,
                                NonPagedPool,
                                sz=sizeof (AFD_BUFFER_TAG) 
                                        + AfdBufferTag->AllocatedAddressLength);
                AfdRecordQuotaHistory(
                    Process,
                    -(LONG)sz,
                    "BuffDealloc ",
                    AfdBufferTag
                    );
                AfdRecordPoolQuotaReturned(
                    sz
                    );
                AfdBufferTag->Lookaside = TRUE;
            }
            ExFreeToNPagedLookasideList( &AfdLookasideLists->BufferTagList, AfdBufferTag );
        }
        else {
            LONG    sz;
            ASSERT (AfdBufferTag->AllocatedAddressLength>AfdStandardAddressLength);
            ASSERT (AfdBufferTag->Lookaside == FALSE);
            PsReturnPoolQuota (
                                Process,
                                NonPagedPool,
                                sz = sizeof (AFD_BUFFER_TAG) 
                                        + AfdBufferTag->AllocatedAddressLength);
            AfdRecordQuotaHistory(
                Process,
                -(LONG)sz,
                "BuffDealloc ",
                AfdBufferTag
                );
            AfdRecordPoolQuotaReturned(
                sz
                );
            AFD_FREE_POOL(
                AfdBufferTag,
                AFD_DATA_BUFFER_POOL_TAG
                );
        }
    }

} // AfdReturnBuffer





PAFD_BUFFER
AfdInitializeBuffer (
    IN PVOID MemoryBlock,
    IN ULONG BufferDataSize,
    IN ULONG AddressSize
    )

/*++

Routine Description:

    Initializes an AFD buffer.  Sets up fields in the actual AFD_BUFFER
    structure and initializes the IRP and MDL associated with the
    buffer.  This routine assumes that the caller has properly allocated
    sufficient space for all this.

Arguments:

    AfdBuffer - points to the AFD_BUFFER structure to initialize.

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

    AddressSize - the size of data allocated for the address buffer.

    ListHead - the global list this buffer belongs to, or NULL if it
        doesn't belong on any list.  This routine does NOT place the
        buffer structure on the list.

Return Value:

    None.

--*/

{
    USHORT  irpSize;
    SIZE_T  mdlSize;
    SIZE_T  hdrSize;
    PAFD_BUFFER hdr;
    PMDL    mdl;
    PIRP    irp;
    PVOID   buf;
    PVOID   addr;
    UCHAR   placement;
    SIZE_T  alignment;
#ifdef AFD_CHECK_ALIGNMENT
    PLONG  alignmentCounters = (PLONG)&AfdAlignmentTable[AfdAlignmentTableSize];
#endif
    irpSize = IoSizeOfIrp( AfdIrpStackSize-1 );
    mdlSize = (ULONG)MmSizeOfMdl( NULL, BufferDataSize );
    hdrSize = sizeof (AFD_BUFFER);

    //
    // Compute the index into (mis)alignment table to determine
    // what placement of the buffer block elements (e.g. hdr, IRP, MDL,
    // and data buffer itself) we need to choose to compensate and
    // align data buffer on AfdBufferAlignment boundary.
    //
    ASSERT ((PtrToUlong(MemoryBlock)%AFD_MINIMUM_BUFFER_ALIGNMENT)==0);
    if (PAGE_ALIGN (MemoryBlock)==MemoryBlock) {
        //
        // For page-aligned blocks (which are >= page size),
        // we always place the buffer first.
        //
        placement = AFD_PLACEMENT_BUFFER;
    }
    else {
        placement = AfdAlignmentTable[
                (PtrToUlong(MemoryBlock)&(AfdBufferAlignment-1))/AFD_MINIMUM_BUFFER_ALIGNMENT];
    }

#ifdef AFD_CHECK_ALIGNMENT
    InterlockedIncrement (&alignmentCounters[
            (PtrToUlong(MemoryBlock)&(AfdBufferAlignment-1))/AFD_MINIMUM_BUFFER_ALIGNMENT]);
#endif

    switch (placement) {
    case AFD_PLACEMENT_BUFFER:
        //
        // Perfect case: the memory is aready aligned as we need it.
        //
        buf = ALIGN_UP_A_POINTER(MemoryBlock, AfdBufferAlignment);
        alignment = (PUCHAR)buf-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;

        //
        // Other cases, we use hdr, mdl, and IRP to try to compensate
        // and have the data buffer aligned at the AfdBufferAlignment
        // boundary.
        //
    case AFD_PLACEMENT_HDR:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        buf = ALIGN_UP_A_POINTER((PCHAR)hdr+hdrSize, AfdBufferAlignment);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, IRP);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;

    case AFD_PLACEMENT_MDL:
        mdl = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, MDL);
        alignment = (PUCHAR)mdl-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        addr = (PCHAR)irp+irpSize;
        break;
    case AFD_PLACEMENT_IRP:
        irp = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, IRP);
        alignment = (PUCHAR)irp-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        buf = ALIGN_UP_A_POINTER((PCHAR)irp+irpSize, AfdBufferAlignment);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;
    case AFD_PLACEMENT_HDR_IRP:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        buf = ALIGN_UP_A_POINTER((PCHAR)irp+irpSize, AfdBufferAlignment);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, MDL);
        addr = (PCHAR)mdl+mdlSize;
        break;
    case AFD_PLACEMENT_HDR_MDL:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, MDL);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, IRP);
        addr = (PCHAR)irp+irpSize;
        break;
    case AFD_PLACEMENT_IRP_MDL:
        irp = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, IRP);
        alignment = (PUCHAR)irp-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        hdr = ALIGN_UP_TO_TYPE_POINTER((PCHAR)buf+BufferDataSize, AFD_BUFFER);
        addr = (PCHAR)hdr+hdrSize;
        break;
    case AFD_PLACEMENT_HDR_IRP_MDL:
        hdr = ALIGN_UP_TO_TYPE_POINTER(MemoryBlock, AFD_BUFFER);
        alignment = (PUCHAR)hdr-(PUCHAR)MemoryBlock;
        ASSERT (alignment<=AfdAlignmentOverhead);
        irp = ALIGN_UP_TO_TYPE_POINTER((PCHAR)hdr+hdrSize, IRP);
        mdl = ALIGN_UP_TO_TYPE_POINTER((PCHAR)irp+irpSize, MDL);
        buf = ALIGN_UP_A_POINTER((PCHAR)mdl+mdlSize, AfdBufferAlignment);
        addr = (PCHAR)buf+BufferDataSize;
        break;
    default:
        ASSERT (!"Unknown placement!");
        __assume (0);
    }

    
    //
    // Initialize the AfdBuffer - most fields need to be 0.
    //

    RtlZeroMemory( hdr, sizeof(*hdr) );

    //
    // Setup buffer
    //
    hdr->Buffer = buf;
    hdr->BufferLength = BufferDataSize;
    
    //
    // We just need to store first two bits of placement
    // so we know which part comes first to free it properly.
    //
    hdr->Placement = placement & 3;

    //
    // If we have to align the memory block to meet the requirement
    // store this information right below the first piece.
    //
    if (alignment!=0) {
        C_ASSERT (AFD_MINIMUM_BUFFER_ALIGNMENT>=sizeof (SIZE_T));
        C_ASSERT ((AFD_MINIMUM_BUFFER_ALIGNMENT & (sizeof(SIZE_T)-1))==0);
        ASSERT (alignment>=sizeof (SIZE_T));
        hdr->AlignmentAdjusted = TRUE;
        *(((PSIZE_T)(((PUCHAR)MemoryBlock)+alignment))-1) = alignment;
    }


    //
    // Initialize the IRP pointer.
    //

    hdr->Irp = irp;
    IoInitializeIrp( hdr->Irp, irpSize, (CCHAR)(AfdIrpStackSize-1) );
    hdr->Irp->MdlAddress = mdl;

    //
    // Set up the MDL pointer.
    //

    hdr->Mdl = mdl;
    MmInitializeMdl( hdr->Mdl, buf, BufferDataSize );
    MmBuildMdlForNonPagedPool( hdr->Mdl );
    
    //
    // Set up the address buffer pointer.
    //

    if (AddressSize>0) {
        hdr->TdiInfo.RemoteAddress = ALIGN_UP_TO_TYPE_POINTER(addr, TRANSPORT_ADDRESS);;
        hdr->AllocatedAddressLength = (USHORT)AddressSize;
    }


#if DBG
    hdr->BufferListEntry.Flink = UIntToPtr( 0xE0E1E2E3 );
    hdr->BufferListEntry.Blink = UIntToPtr( 0xE4E5E6E7 );
#endif

    return hdr;

} // AfdInitializeBuffer


VOID
AfdInitializeBufferTag (
    IN PAFD_BUFFER_TAG AfdBufferTag,
    IN CLONG           AddressSize
    )

/*++

Routine Description:

    Initializes an AFD buffer.  Sets up fields in the actual AFD_BUFFER
    structure and initializes the IRP and MDL associated with the
    buffer.  This routine assumes that the caller has properly allocated
    sufficient space for all this.

Arguments:

    AfdBuffer - points to the AFD_BUFFER structure to initialize.

    BufferDataSize - the size of the data buffer that goes along with the
        buffer structure.

    AddressSize - the size of data allocated for the address buffer.

    ListHead - the global list this buffer belongs to, or NULL if it
        doesn't belong on any list.  This routine does NOT place the
        buffer structure on the list.

Return Value:

    None.

--*/

{
    AfdBufferTag->Mdl = NULL;
    AfdBufferTag->BufferLength = AfdBufferTagSize;
    AfdBufferTag->TdiInfo.RemoteAddress = AddressSize ? AfdBufferTag+1 : NULL;
    AfdBufferTag->AllocatedAddressLength = (USHORT)AddressSize;
    AfdBufferTag->Flags = 0;

#if DBG
    AfdBufferTag->BufferListEntry.Flink = UIntToPtr( 0xE0E1E2E3 );
    AfdBufferTag->BufferListEntry.Blink = UIntToPtr( 0xE4E5E6E7 );
    AfdBufferTag->Caller = NULL;
    AfdBufferTag->CallersCaller = NULL;
#endif
}


VOID
AfdInitializeBufferManager (
    VOID
    )
{
    SIZE_T  irpSize = ALIGN_UP_A(IoSizeOfIrp (AfdIrpStackSize-1), AFD_MINIMUM_BUFFER_ALIGNMENT);
    SIZE_T  hdrSize = ALIGN_UP_A(sizeof (AFD_BUFFER), AFD_MINIMUM_BUFFER_ALIGNMENT);
    SIZE_T  mdlSize = ALIGN_UP_A(MmSizeOfMdl (NULL, PAGE_SIZE),AFD_MINIMUM_BUFFER_ALIGNMENT);
    UCHAR   placement;
    ULONG   i;
    ULONG   currentOverhead;

    //
    // Initialize the alignment table.
    // This table is used to determine what kind of element
    // placement to use in AFD_BUFFER depending on the alignment
    // of the memory block returned by the executive pool manager.
    // The goal is to align the data buffer on the cache line
    // boundary.  However, since executive only guarantees alignment of
    // it's blocks at the CPU alignment requirements, we need to 
    // adjust and potentially waste up to CACHE_LIST_SIZE-CPU_ALIGNMENT_SIZE.
    // With some machines having cache line alignment at 128 such memory
    // waste is prohibitive (small buffers with default size of 128 will double
    // in size).
    // The table below allows us to rearrange pieces in AFD_BUFFER structure,
    // namely, the header, IRP, MDL, and data buffer, so that pieces with
    // lower alignment requirement can be used to consume the space needed
    // to adjust the memory block to the cache line boundary.
    
    //
    // AfdAlignmentTable has an entry for each possible case of memory block
    // misaligned against cache line size.  For example, in typical X86 system
    // case executive pool manager always returns blocks aligned on 8 byte bounday,
    // while cache lines are typically 64 bytes long, so memory manager can 
    // theoretically return blocks misaligned against cache by:
    //        8, 16, 24, 32, 40, 48, 56.
    // For each of these cases we will try to adjust the alignment by using
    // any possible combination of header, IRP, and MDL.  There will be some
    // cases that cannot be adjusted exactly, and we will have to pad.
    //

    //
    // First initialize the table assuming the data buffer is placed first.
    //
    RtlFillMemory (AfdAlignmentTable, AfdAlignmentTableSize, AFD_PLACEMENT_BUFFER);
#ifdef AFD_CHECK_ALIGNMENT
    RtlZeroMemory (&AfdAlignmentTable[AfdAlignmentTableSize],
                        AfdAlignmentTableSize*sizeof(LONG));
#endif
    //
    // Now identify the entries that can be padded with some combination of
    // header, IRP, and MDL:
    //      extract the bits that can be used for padding
    //      reverse to get corresponding memory block alignments
    //      divide by the step of the alignment table
    //      make sure we won't go past table size (last entry => 0 entry).
    //
#define AfdInitAlignmentTableRow(_size,_plcmnt)                     \
    AfdAlignmentTable[                                              \
            ((AfdBufferAlignment-(_size&(AfdBufferAlignment-1)))    \
                /AFD_MINIMUM_BUFFER_ALIGNMENT)                      \
                &(AfdAlignmentTableSize-1)] = _plcmnt

    //
    // We let placements beginning with header override others,
    // since it is more natural and easier to debug (header has references
    // to other pieces).
    //

    AfdInitAlignmentTableRow(mdlSize,AFD_PLACEMENT_MDL);
    AfdInitAlignmentTableRow(irpSize,AFD_PLACEMENT_IRP);
    AfdInitAlignmentTableRow((irpSize+mdlSize),AFD_PLACEMENT_IRP_MDL);
    AfdInitAlignmentTableRow((hdrSize+mdlSize),AFD_PLACEMENT_HDR_MDL);
    AfdInitAlignmentTableRow((hdrSize+irpSize),AFD_PLACEMENT_HDR_IRP);
    AfdInitAlignmentTableRow((hdrSize+irpSize+mdlSize),AFD_PLACEMENT_HDR_IRP_MDL);
    AfdInitAlignmentTableRow(hdrSize,AFD_PLACEMENT_HDR);

    //
    // Now scan the table from top to bottom and fill entries that do not have
    // exact match using the above combinations. Use the closest entry above and
    // in the process compute how much do we need to pad in addition to padding
    // achieved via placement.
    //
    AfdAlignmentOverhead = 0;
    currentOverhead = 0;
    //
    // By default use the placement of aligned block.
    //
    placement = AfdAlignmentTable[0];
    for (i=AfdAlignmentTableSize-1; i>0; i--) {
        if (AfdAlignmentTable[i]==AFD_PLACEMENT_BUFFER) {
            AfdAlignmentTable[i] = placement;
            currentOverhead += AFD_MINIMUM_BUFFER_ALIGNMENT;
        }
        else {
            placement = AfdAlignmentTable[i];
            if (AfdAlignmentOverhead<currentOverhead) {
                AfdAlignmentOverhead = currentOverhead;
            }
            currentOverhead = 0;
        }
    }
    if (AfdAlignmentOverhead<currentOverhead) {
        AfdAlignmentOverhead = currentOverhead;
    }


    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdInitializeBufferManager: Alignment requirements: MM-%d, cache-%d, overhead-%d\n",
                        AFD_MINIMUM_BUFFER_ALIGNMENT,
                        AfdBufferAlignment,
                        AfdAlignmentOverhead));
    {
        CLONG   oldBufferLengthForOnePage = AfdBufferLengthForOnePage;

        AfdBufferOverhead = AfdCalculateBufferSize( PAGE_SIZE, AfdStandardAddressLength) - PAGE_SIZE;
        AfdBufferLengthForOnePage = ALIGN_DOWN_A(
                                        PAGE_SIZE-AfdBufferOverhead,
                                        AFD_MINIMUM_BUFFER_ALIGNMENT);
        if (AfdLargeBufferSize==oldBufferLengthForOnePage) {
            AfdLargeBufferSize = AfdBufferLengthForOnePage;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\blkendp.c ===
/*++

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    blkendp.c

Abstract:

    This module contains allocate, free, close, reference, and dereference
    routines for AFD endpoints.

Author:

    David Treadwell (davidtr)    10-Mar-1992

Revision History:
    Vadim Eydelman (vadime)     1999 - Don't attach to system proces, use system handles instead
                                        Delayed acceptance endpoints.

--*/

#include "afdp.h"

VOID
AfdFreeEndpointResources (
    PAFD_ENDPOINT   endpoint
    );

VOID
AfdFreeEndpoint (
    IN PVOID Context
    );

PAFD_ENDPOINT
AfdReuseEndpoint (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdAllocateEndpoint )
#pragma alloc_text( PAGE, AfdFreeEndpointResources )
#pragma alloc_text( PAGE, AfdFreeEndpoint )
#pragma alloc_text( PAGE, AfdReuseEndpoint )
#pragma alloc_text( PAGE, AfdGetTransportInfo )
#pragma alloc_text( PAGEAFD, AfdRefreshEndpoint )
#pragma alloc_text( PAGEAFD, AfdDereferenceEndpoint )
#if REFERENCE_DEBUG
#pragma alloc_text( PAGEAFD, AfdReferenceEndpoint )
#endif
#pragma alloc_text( PAGEAFD, AfdFreeQueuedConnections )
#endif


NTSTATUS
AfdAllocateEndpoint (
    OUT PAFD_ENDPOINT * NewEndpoint,
    IN PUNICODE_STRING TransportDeviceName,
    IN LONG GroupID
    )

/*++

Routine Description:

    Allocates and initializes a new AFD endpoint structure.

Arguments:

    NewEndpoint - Receives a pointer to the new endpoint structure if
        successful.

    TransportDeviceName - the name of the TDI transport provider
        corresponding to the endpoint structure.

    GroupID - Identifies the group ID for the new endpoint.

Return Value:

    NTSTATUS - The completion status.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_TRANSPORT_INFO transportInfo = NULL;
    NTSTATUS status;
    AFD_GROUP_TYPE groupType;

    PAGED_CODE( );

    DEBUG *NewEndpoint = NULL;

    if ( TransportDeviceName != NULL ) {
        //
        // First, make sure that the transport device name is stored globally
        // for AFD.  Since there will typically only be a small number of
        // transport device names, we store the name strings once globally
        // for access by all endpoints.
        //

        status = AfdGetTransportInfo( TransportDeviceName, &transportInfo );

        //
        // If transport device is not activated, we'll try again during bind
        //
        if ( !NT_SUCCESS (status) && 
                (status!=STATUS_OBJECT_NAME_NOT_FOUND) &&
                (status!=STATUS_OBJECT_PATH_NOT_FOUND) &&
                (status!=STATUS_NO_SUCH_DEVICE) ) {
            //
            // Dereference transport info structure if one was created for us.
            // (Should not happen in current implementation).
            //
            ASSERT (transportInfo==NULL);
            return status;
        }

        ASSERT (transportInfo!=NULL);
    }


    //
    // Validate the incoming group ID, allocate a new one if necessary.
    //

    if( AfdGetGroup( &GroupID, &groupType ) ) {
        PEPROCESS process = IoGetCurrentProcess ();


        status = PsChargeProcessPoolQuota(
                process,
                NonPagedPool,
                sizeof (AFD_ENDPOINT)
                );

        if (!NT_SUCCESS (status)) {

           KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdAllocateEndpoint: PsChargeProcessPoolQuota failed.\n" ));

           goto CleanupTransportInfo;
        }

        // See if we have too many endpoins waiting to be freed and reuse one of them
        if ((AfdEndpointsFreeing<AFD_ENDPOINTS_FREEING_MAX)
                || ((endpoint = AfdReuseEndpoint ())==NULL)) {
            //
            // Allocate a buffer to hold the endpoint structure.
            // We use the priority version of this routine because
            // we are going to charge the process for this allocation
            // before it can make any use of it.
            //

            endpoint = AFD_ALLOCATE_POOL_PRIORITY(
                           NonPagedPool,
                           sizeof(AFD_ENDPOINT),
                           AFD_ENDPOINT_POOL_TAG,
                           NormalPoolPriority
                           );
        }

        if ( endpoint != NULL ) {

            AfdRecordQuotaHistory(
                process,
                (LONG)sizeof (AFD_ENDPOINT),
                "CreateEndp  ",
                endpoint
                );

            AfdRecordPoolQuotaCharged(sizeof (AFD_ENDPOINT));

            RtlZeroMemory( endpoint, sizeof(AFD_ENDPOINT) );

            //
            // Initialize the reference count to 2--one for the caller's
            // reference, one for the active reference.
            //

            endpoint->ReferenceCount = 2;

            //
            // Initialize the endpoint structure.
            //

            if ( TransportDeviceName == NULL ) {
                endpoint->Type = AfdBlockTypeHelper;
                endpoint->State = AfdEndpointStateInvalid;
            } else {
                endpoint->Type = AfdBlockTypeEndpoint;
                endpoint->State = AfdEndpointStateOpen;
                endpoint->TransportInfo = transportInfo;
                //
                // Cache service flags for quick determination of provider characteristics
                // such as bufferring and messaging
                //
                if (transportInfo->InfoValid) {
                    endpoint->TdiServiceFlags = endpoint->TransportInfo->ProviderInfo.ServiceFlags;
                }
            }

            endpoint->GroupID = GroupID;
            endpoint->GroupType = groupType;


            AfdInitializeSpinLock( &endpoint->SpinLock );
            InitializeListHead (&endpoint->RoutingNotifications);
            InitializeListHead (&endpoint->RequestList);

#if REFERENCE_DEBUG
            endpoint->CurrentReferenceSlot = -1;
#endif

#if DBG
            InitializeListHead( &endpoint->OutstandingIrpListHead );
#endif

            //
            // Remember the process which opened the endpoint.  We'll use this to
            // charge quota to the process as necessary.  Reference the process
            // so that it does not go away until we have returned all charged
            // quota to the process.
            //

            endpoint->OwningProcess = process;

            ObReferenceObject(endpoint->OwningProcess);

            //
            // Insert the endpoint on the global list.
            //

            AfdInsertNewEndpointInList( endpoint );

            //
            // Return a pointer to the new endpoint to the caller.
            //

            IF_DEBUG(ENDPOINT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdAllocateEndpoint: new endpoint at %p\n",
                            endpoint ));
            }

            *NewEndpoint = endpoint;
            return STATUS_SUCCESS;
        }
        else {
            PsReturnPoolQuota(
                process,
                NonPagedPool,
                sizeof (AFD_ENDPOINT)
                );
            status= STATUS_INSUFFICIENT_RESOURCES;
        }

        if( GroupID != 0 ) {
            AfdDereferenceGroup( GroupID );
        }

    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

CleanupTransportInfo:

    if (transportInfo!=NULL) {
        if (InterlockedDecrement ((PLONG)&transportInfo->ReferenceCount)==0) {
            //
            // Reference count has gone to 0, we need to remove the structure
            // from the global list and free it.
            // Note that no code increments reference count if doesn't
            // know for fact that its current reference count is above 0).
            //
            //
            // Make sure the thread in which we execute cannot get
            // suspeneded in APC while we own the global resource.
            //
            KeEnterCriticalRegion ();
            ExAcquireResourceExclusiveLite( AfdResource, TRUE );
            ASSERT (transportInfo->ReferenceCount==0);
            ASSERT (transportInfo->InfoValid==FALSE);
            RemoveEntryList (&transportInfo->TransportInfoListEntry);
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
            AFD_FREE_POOL (transportInfo, AFD_TRANSPORT_INFO_POOL_TAG);
        }
    }

    return status;
} // AfdAllocateEndpoint


VOID
AfdFreeQueuedConnections (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Frees queued connection objects on a listening AFD endpoint.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE  lockHandle;
    KIRQL               oldIrql;
    PAFD_CONNECTION connection;
    PIRP    irp;

    ASSERT( Endpoint->Type == AfdBlockTypeVcListening ||
            Endpoint->Type == AfdBlockTypeVcBoth );

    //
    // Free the unaccepted connections.
    //
    // We must hold endpoint spinLock to call AfdGetUnacceptedConnection,
    // but we may not hold it when calling AfdDereferenceConnection.
    //

    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

    AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    while ( (connection = AfdGetUnacceptedConnection( Endpoint )) != NULL ) {
        ASSERT( connection->Endpoint == Endpoint );

        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
        if (connection->SanConnection) {
            AfdSanAbortConnection ( connection );
        }
        else {
            AfdAbortConnection( connection );
        }
        AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    }


    //
    // Free the returned connections.
    //

    while ( (connection = AfdGetReturnedConnection( Endpoint, 0 )) != NULL ) {

        ASSERT( connection->Endpoint == Endpoint );

        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
        if (connection->SanConnection) {
            AfdSanAbortConnection ( connection );
        }
        else {
            AfdAbortConnection( connection );
        }
        
        AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );

    }



    if (IS_DELAYED_ACCEPTANCE_ENDPOINT (Endpoint)) {
        while (!IsListEmpty (&Endpoint->Common.VcListening.ListenConnectionListHead)) {
            PIRP    listenIrp;
            connection = CONTAINING_RECORD (
                            Endpoint->Common.VcListening.ListenConnectionListHead.Flink,
                            AFD_CONNECTION,
                            ListEntry
                            );
            RemoveEntryList (&connection->ListEntry);
            listenIrp = InterlockedExchangePointer ((PVOID *)&connection->ListenIrp, NULL);
            if (listenIrp!=NULL) {
                IoAcquireCancelSpinLock (&listenIrp->CancelIrql);
                ASSERT (listenIrp->CancelIrql==DISPATCH_LEVEL);
                AfdReleaseSpinLockFromDpcLevel (&Endpoint->SpinLock, &lockHandle);

                AfdCancelIrp (listenIrp);

                AfdAcquireSpinLockAtDpcLevel( &Endpoint->SpinLock, &lockHandle );
            }
        }
        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
    }
    else {
        AfdReleaseSpinLockFromDpcLevel( &Endpoint->SpinLock, &lockHandle );
        //
        // And finally, purge the free connection queue.
        //

        while ( (connection = AfdGetFreeConnection( Endpoint, &irp )) != NULL ) {
            ASSERT( connection->Type == AfdBlockTypeConnection );
            if (irp!=NULL) {
                AfdCleanupSuperAccept (irp, STATUS_CANCELLED);
                if (irp->Cancel) {
                    KIRQL cancelIrql;
                    //
                    // Need to sycn with cancel routine which may
                    // have been called from AfdCleanup for accepting
                    // endpoint
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
                IoCompleteRequest (irp, AfdPriorityBoost);
            }
            DEREFERENCE_CONNECTION( connection );
        }
    }
    KeLowerIrql (oldIrql);

    return;

} // AfdFreeQueuedConnections



VOID
AfdFreeEndpointResources (
    PAFD_ENDPOINT   endpoint
    )
/*++

Routine Description:
    Does the actual work to deallocate an AFD endpoint structure and
    associated structures.  Note that all other references to the
    endpoint structure must be gone before this routine is called, since
    it frees the endpoint and assumes that nobody else will be looking
    at the endpoint.

Arguments:
    Endpoint to be cleaned up

Return Value:

    None
--*/
{
    NTSTATUS status;
    PLIST_ENTRY listEntry;

    PAGED_CODE ();

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    ASSERT( endpoint->ReferenceCount == 0 );
    ASSERT( endpoint->State == AfdEndpointStateClosing );
    ASSERT( endpoint->ObReferenceBias == 0 );
    ASSERT( KeGetCurrentIrql( ) == 0 );

    //
    // If this is a listening endpoint, then purge the endpoint of all
    // queued connections.
    //

    if ( (endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening ) {

        AfdFreeQueuedConnections( endpoint );

    }

    //
    // Dereference any group ID associated with this endpoint.
    //

    if( endpoint->GroupID != 0 ) {

        AfdDereferenceGroup( endpoint->GroupID );

    }

    //
    // If this is a bufferring datagram endpoint, remove all the
    // bufferred datagrams from the endpoint's list and free them.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) &&
             endpoint->ReceiveDatagramBufferListHead.Flink != NULL ) {

        while ( !IsListEmpty( &endpoint->ReceiveDatagramBufferListHead ) ) {

            PAFD_BUFFER_HEADER afdBuffer;

            listEntry = RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
            AfdReturnBuffer( afdBuffer, endpoint->OwningProcess );
        }
    }

    //
    // Close and dereference the TDI address object on the endpoint, if
    // any.
    //

    if ( endpoint->AddressFileObject != NULL ) {
        //
        // Little extra precaution.  It is possible that there exists
        // a duplicated handle in user process, so transport can in
        // theory call event handler with bogus endpoint pointer that
        // we are about to free.  The event handlers for datagram
        // endpoints are reset in AfdCleanup.
        // Connection-oriented accepted endpoints cannot have address handles
        // in their structures because they share them with listening
        // endpoint (it would be a grave mistake if we tried to close
        // address handle owned by listening endpoint while closing connection
        // accepted on it).
        //
        if ( endpoint->AddressHandle != NULL &&
                IS_VC_ENDPOINT (endpoint)) {

            ASSERT (((endpoint->Type&AfdBlockTypeVcConnecting)!=AfdBlockTypeVcConnecting) 
                        || (endpoint->Common.VcConnecting.ListenEndpoint==NULL));


            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_ERROR,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_DISCONNECT,
                         NULL,
                         NULL
                         );
            //ASSERT( NT_SUCCESS(status) );

            status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE,
                         NULL,
                         NULL
                         );

            //ASSERT( NT_SUCCESS(status) );

            if (IS_TDI_EXPEDITED (endpoint)) {
                status = AfdSetEventHandler(
                         endpoint->AddressFileObject,
                         TDI_EVENT_RECEIVE_EXPEDITED,
                         NULL,
                         NULL
                         );
                //ASSERT( NT_SUCCESS(status) );
            }

            if ( IS_TDI_BUFFERRING(endpoint) ) {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_SEND_POSSIBLE,
                             NULL,
                             NULL
                             );
                //ASSERT( NT_SUCCESS(status) );
            }
            else {
                status = AfdSetEventHandler(
                             endpoint->AddressFileObject,
                             TDI_EVENT_CHAINED_RECEIVE,
                             NULL,
                             NULL
                             );
                //ASSERT( NT_SUCCESS(status) );
            }
        }
        ObDereferenceObject( endpoint->AddressFileObject );
        endpoint->AddressFileObject = NULL;
        AfdRecordAddrDeref();
    }

    if ( endpoint->AddressHandle != NULL ) {
#if DBG
        {
            NTSTATUS    status1;
            OBJECT_HANDLE_FLAG_INFORMATION  handleInfo;
            handleInfo.Inherit = FALSE;
            handleInfo.ProtectFromClose = FALSE;
            status1 = ZwSetInformationObject (
                            endpoint->AddressHandle,
                            ObjectHandleFlagInformation,
                            &handleInfo,
                            sizeof (handleInfo)
                            );
            ASSERT (NT_SUCCESS (status1));
        }
#endif
        status = ZwClose( endpoint->AddressHandle );
        ASSERT( NT_SUCCESS(status) );
        endpoint->AddressHandle = NULL;
        AfdRecordAddrClosed();
    }

    //
    // Remove the endpoint from the global list.  Do this before any
    // deallocations to prevent someone else from seeing an endpoint in
    // an invalid state.
    //

    AfdRemoveEndpointFromList( endpoint );

    //
    // Return the quota we charged to this process when we allocated
    // the endpoint object.
    //

    PsReturnPoolQuota(
        endpoint->OwningProcess,
        NonPagedPool,
        sizeof (AFD_ENDPOINT)
        );
    AfdRecordQuotaHistory(
        endpoint->OwningProcess,
        -(LONG)sizeof (AFD_ENDPOINT),
        "EndpDealloc ",
        endpoint
        );
    AfdRecordPoolQuotaReturned(
        sizeof (AFD_ENDPOINT)
        );

    //
    // If we set up an owning process for the endpoint, dereference the
    // process.
    //

    if ( endpoint->OwningProcess != NULL ) {
        ObDereferenceObject( endpoint->OwningProcess );
        endpoint->OwningProcess = NULL;
    }


    //
    // Dereference the listening or c-root endpoint on the endpoint, if
    // any.
    //

    if ( endpoint->Type == AfdBlockTypeVcConnecting &&
             endpoint->Common.VcConnecting.ListenEndpoint != NULL ) {
        PAFD_ENDPOINT   listenEndpoint = endpoint->Common.VcConnecting.ListenEndpoint;
        ASSERT (((listenEndpoint->Type&AfdBlockTypeVcListening)==AfdBlockTypeVcListening) ||
                 IS_CROOT_ENDPOINT (listenEndpoint));
        ASSERT (endpoint->LocalAddress==listenEndpoint->LocalAddress);
        DEREFERENCE_ENDPOINT( listenEndpoint );

        endpoint->Common.VcConnecting.ListenEndpoint = NULL;
        //
        // We used the local address from the listening endpoint,
        // simply reset it, it will be freed when listening endpoint
        // is freed.
        //
        endpoint->LocalAddress = NULL;
        endpoint->LocalAddressLength = 0;
    }

    if (IS_SAN_ENDPOINT (endpoint)) {
        AfdSanCleanupEndpoint (endpoint);

    }
    else if (IS_SAN_HELPER (endpoint)) {
        AfdSanCleanupHelper (endpoint);
    }
    //
    // Free local and remote address buffers.
    //

    if ( endpoint->LocalAddress != NULL ) {
        AFD_FREE_POOL(
            endpoint->LocalAddress,
            AFD_LOCAL_ADDRESS_POOL_TAG
            );
        endpoint->LocalAddress = NULL;
    }

    if ( IS_DGRAM_ENDPOINT(endpoint) &&
             endpoint->Common.Datagram.RemoteAddress != NULL ) {
        AFD_RETURN_REMOTE_ADDRESS(
            endpoint->Common.Datagram.RemoteAddress,
            endpoint->Common.Datagram.RemoteAddressLength
            );
        endpoint->Common.Datagram.RemoteAddress = NULL;
    }

    //
    // Free context and connect data buffers.
    //

    if ( endpoint->Context != NULL ) {

        AFD_FREE_POOL(
            endpoint->Context,
            AFD_CONTEXT_POOL_TAG
            );
        endpoint->Context = NULL;

    }

    if ( IS_VC_ENDPOINT (endpoint) &&
              endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdFreeConnectDataBuffers( endpoint->Common.VirtualCircuit.ConnectDataBuffers );
    }

    //
    // If there's an active EventSelect() on this endpoint, dereference
    // the associated event object.
    //

    if( endpoint->EventObject != NULL ) {
        ObDereferenceObject( endpoint->EventObject );
        endpoint->EventObject = NULL;
    }

    ASSERT ( endpoint->Irp == NULL );


    if (endpoint->TransportInfo!=NULL) {
        if  (InterlockedDecrement ((PLONG)&endpoint->TransportInfo->ReferenceCount)==0) {
            //
            // Reference count has gone to 0, we need to remove the structure
            // from the global list and free it.
            // Note that no code increments reference count if doesn't
            // know for fact that its current reference count is above 0).
            //
            //
            // Make sure the thread in which we execute cannot get
            // suspeneded in APC while we own the global resource.
            //
            KeEnterCriticalRegion ();
            ExAcquireResourceExclusiveLite( AfdResource, TRUE );
            ASSERT (endpoint->TransportInfo->ReferenceCount==0);
            ASSERT (endpoint->TransportInfo->InfoValid==FALSE);
            RemoveEntryList (&endpoint->TransportInfo->TransportInfoListEntry);
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
            AFD_FREE_POOL (endpoint->TransportInfo, AFD_TRANSPORT_INFO_POOL_TAG);
        }
        endpoint->TransportInfo = NULL;
    }

    ASSERT (endpoint->OutstandingIrpCount==0);

    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFreeEndpoint: freeing endpoint at %p\n",
                    endpoint ));
    }

    endpoint->Type = AfdBlockTypeInvalidEndpoint;

}


VOID
AfdFreeEndpoint (
    IN PVOID Context
    )

/*++

Routine Description:
    Calls AfdFreeEndpointResources to cleanup endpoint and frees the
    endpoint structure itself

Arguments:

    Context - Actually points to the endpoint's embedded AFD_WORK_ITEM
        structure. From this we can determine the endpoint to free.

Return Value:

    None.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAGED_CODE( );


    ASSERT( Context != NULL );

    InterlockedDecrement(&AfdEndpointsFreeing);

    endpoint = CONTAINING_RECORD(
                   Context,
                   AFD_ENDPOINT,
                   WorkItem
                   );


    AfdFreeEndpointResources (endpoint);
    //
    // Free the pool used for the endpoint itself.
    //

    AFD_FREE_POOL(
        endpoint,
        AFD_ENDPOINT_POOL_TAG
        );

} // AfdFreeEndpoint


PAFD_ENDPOINT
AfdReuseEndpoint (
    VOID
    )

/*++

Routine Description:
    Finds a AfdFreeEndpoint work item in the list and calls
     AfdFreeEndpointResources to cleanup endpoint

Arguments:
    None

Return Value:

    Reinitialized endpoint.

--*/

{
    PAFD_ENDPOINT endpoint;
    PVOID       Context;

    PAGED_CODE( );

    Context = AfdGetWorkerByRoutine (AfdFreeEndpoint);
    if (Context==NULL)
        return NULL;

    endpoint = CONTAINING_RECORD(
                   Context,
                   AFD_ENDPOINT,
                   WorkItem
                   );


    AfdFreeEndpointResources (endpoint);
    return endpoint;
} // AfdReuseEndpoint


#if REFERENCE_DEBUG
VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )
#else
VOID
AfdDereferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    )
#endif

/*++

Routine Description:

    Dereferences an AFD endpoint and calls the routine to free it if
    appropriate.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    LONG result;

#if REFERENCE_DEBUG
    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdDereferenceEndpoint: endpoint at %p, new refcnt %ld\n",
                    Endpoint, Endpoint->ReferenceCount-1 ));
    }

    ASSERT( IS_AFD_ENDPOINT_TYPE( Endpoint ) );
    ASSERT( Endpoint->ReferenceCount > 0 );
    ASSERT( Endpoint->ReferenceCount != 0xDAADF00D );

    AFD_UPDATE_REFERENCE_DEBUG(Endpoint, Endpoint->ReferenceCount-1, LocationId, Param);



    //
    // We must hold AfdSpinLock while doing the dereference and check
    // for free.  This is because some code makes the assumption that
    // the connection structure will not go away while AfdSpinLock is
    // held, and that code references the endpoint before releasing
    // AfdSpinLock.  If we did the InterlockedDecrement() without the
    // lock held, our count may go to zero, that code may reference the
    // connection, and then a double free might occur.
    //
    // It is still valuable to use the interlocked routines for
    // increment and decrement of structures because it allows us to
    // avoid having to hold the spin lock for a reference.
    //
    // In NT40+ we use InterlockedCompareExchange and make sure that
    // we do not increment reference count if it is 0, so holding
    // a spinlock is no longer necessary

    //
    // Decrement the reference count; if it is 0, we may need to
    // free the endpoint.
    //

#endif
    result = InterlockedDecrement( (PLONG)&Endpoint->ReferenceCount );

    if ( result == 0 ) {

        ASSERT( Endpoint->State == AfdEndpointStateClosing );

        if ((Endpoint->Type==AfdBlockTypeVcConnecting) &&
                (Endpoint->Common.VcConnecting.ListenEndpoint != NULL) &&
                (KeGetCurrentIrql()==PASSIVE_LEVEL)) {

            ASSERT (Endpoint->AddressHandle==NULL);
            //
            // If this is a connecting endpoint assoicated with the
            // listening endpoint and we already at passive level,
            // free the endpoint here.  We can do this because in such
            // a case we know that reference to the transport object
            // is not the last one - at least one more is still in the
            // listening endpoint and we remove transport object reference 
            // before dereferencing listening endpoint.
            // 
            //

            AfdFreeEndpointResources (Endpoint);

            //
            // Free the pool used for the endpoint itself.
            //

            AFD_FREE_POOL(
                Endpoint,
                AFD_ENDPOINT_POOL_TAG
                );
        }
        else
        {
            //
            // We're going to do this by queueing a request to an executive
            // worker thread.  We do this for several reasons: to ensure
            // that we're at IRQL 0 so we can free pageable memory, and to
            // ensure that we're in a legitimate context for a close
            // operation and not in conntext of event indication from
            // the transport driver
            //

            InterlockedIncrement(&AfdEndpointsFreeing);

            AfdQueueWorkItem(
                AfdFreeEndpoint,
                &Endpoint->WorkItem
                );
        }
    }

} // AfdDereferenceEndpoint

#if REFERENCE_DEBUG

VOID
AfdReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )

/*++

Routine Description:

    References an AFD endpoint.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{

    LONG result;

    ASSERT( Endpoint->ReferenceCount > 0 );

    ASSERT( Endpoint->ReferenceCount < 0xFFFF || 
        ((Endpoint->Listening ||
        Endpoint->afdC_Root) && Endpoint->ReferenceCount<0xFFFFFFF));

    result = InterlockedIncrement( (PLONG)&Endpoint->ReferenceCount );
    AFD_UPDATE_REFERENCE_DEBUG(Endpoint, result, LocationId, Param);

    IF_DEBUG(ENDPOINT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReferenceEndpoint: endpoint at %p, new refcnt %ld\n",
                    Endpoint, result ));
    }

} // AfdReferenceEndpoint

VOID
AfdUpdateEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )

/*++

Routine Description:

    Update an AFD endpoint reference debug information.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{
    ASSERT( Endpoint->ReferenceCount > 0 );

    ASSERT( Endpoint->ReferenceCount < 0xFFFF || 
        ((Endpoint->Listening ||
        Endpoint->afdC_Root) && Endpoint->ReferenceCount<0xFFFFFFF));

    AFD_UPDATE_REFERENCE_DEBUG(Endpoint, Endpoint->ReferenceCount, LocationId, Param);


} // AfdUpdateEndpoint
#endif


#if REFERENCE_DEBUG
BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint,
    IN LONG  LocationId,
    IN ULONG Param
    )
#else
BOOLEAN
AfdCheckAndReferenceEndpoint (
    IN PAFD_ENDPOINT Endpoint
    )
#endif
{
    LONG            result;

    do {
        result = Endpoint->ReferenceCount;
        if (result<=0)
            break;
    }
    while (InterlockedCompareExchange ((PLONG)&Endpoint->ReferenceCount,
                                                (result+1),
                                                result)!=result);



    if (result>0) {

#if REFERENCE_DEBUG
        AFD_UPDATE_REFERENCE_DEBUG(Endpoint, result+1, LocationId, Param);

        IF_DEBUG(ENDPOINT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdReferenceEndpoint: endpoint at %p, new refcnt %ld\n",
                Endpoint, result+1 ));
        }

        ASSERT( Endpoint->ReferenceCount < 0xFFFF || 
            ((Endpoint->Listening ||
            Endpoint->afdC_Root) && Endpoint->ReferenceCount<0xFFFFFFF));
#endif
        return TRUE;
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdCheckAndReferenceEndpoint: Endpoint %p is gone (refcount: %ld)!\n",
                    Endpoint, result));
        return FALSE;
    }
}


VOID
AfdRefreshEndpoint (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Prepares an AFD endpoint structure to be reused.  All other
    references to the endpoint must be freed before this routine is
    called, since this routine assumes that nobody will access the old
    information in the endpoint structure.
    This fact is ensured by the state change primitive.

Arguments:

    Endpoint - a pointer to the AFD endpoint structure.

Return Value:

    None.

--*/

{

    ASSERT( Endpoint->Type == AfdBlockTypeVcConnecting );
    ASSERT( Endpoint->Common.VcConnecting.Connection == NULL );
    ASSERT( Endpoint->StateChangeInProgress!=0);
    ASSERT( Endpoint->State == AfdEndpointStateTransmitClosing );

    if ( Endpoint->Common.VcConnecting.ListenEndpoint != NULL ) {
        //
        // TransmitFile after SuperAccept, cleanup back to open state.
        //

        //
        // Dereference the listening endpoint and its address object.
        //

        PAFD_ENDPOINT   listenEndpoint = Endpoint->Common.VcConnecting.ListenEndpoint;
        ASSERT (((listenEndpoint->Type&AfdBlockTypeVcListening)==AfdBlockTypeVcListening) ||
                 IS_CROOT_ENDPOINT (listenEndpoint));
        ASSERT (Endpoint->LocalAddress==listenEndpoint->LocalAddress);
        ASSERT (Endpoint->AddressFileObject==listenEndpoint->AddressFileObject);

        DEREFERENCE_ENDPOINT( listenEndpoint );
        Endpoint->Common.VcConnecting.ListenEndpoint = NULL;

        //
        // Close and dereference the TDI address object on the endpoint, if
        // any.
        //


        ObDereferenceObject( Endpoint->AddressFileObject );
        Endpoint->AddressFileObject = NULL;
        AfdRecordAddrDeref();

        //
        // We used the local address from the listening endpoint,
        // simply reset it, it will be freed when listening endpoint
        // is freed.
        //
        Endpoint->LocalAddress = NULL;
        Endpoint->LocalAddressLength = 0;
        ASSERT (Endpoint->AddressHandle == NULL);

        //
        // Reinitialize the endpoint structure.
        //

        Endpoint->Type = AfdBlockTypeEndpoint;
        Endpoint->State = AfdEndpointStateOpen;
    }
    else {
        //
        // TransmitFile after SuperConnect, cleanup back to bound state.
        //
        Endpoint->Type = AfdBlockTypeEndpoint;
        ASSERT (Endpoint->AddressHandle!=NULL);
        ASSERT (Endpoint->AddressFileObject!=NULL);
        Endpoint->State = AfdEndpointStateBound;
    }

    Endpoint->DisconnectMode = 0;
    Endpoint->EndpointStateFlags = 0;
    Endpoint->EventsActive = 0;
    AfdRecordEndpointsReused ();
    return;

} // AfdRefreshEndpoint


NTSTATUS
AfdGetTransportInfo (
    IN  PUNICODE_STRING TransportDeviceName,
    IN OUT PAFD_TRANSPORT_INFO *TransportInfo
    )

/*++

Routine Description:

    Returns a transport information structure corresponding to the
    specified TDI transport provider.  Each unique transport string gets
    a single provider structure, so that multiple endpoints for the same
    transport share the same transport information structure.

Arguments:

    TransportDeviceName - the name of the TDI transport provider.
    TransportInfo    - place to return referenced pointer to transport info

Return Value:

    STATUS_SUCCESS  - returned transport info is valid.
    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate
                                    transport info structure
    STATUS_OBJECT_NAME_NOT_FOUND - transport's device is not available yet

--*/

{
    PLIST_ENTRY listEntry;
    PAFD_TRANSPORT_INFO transportInfo;
    ULONG structureLength;
    NTSTATUS status;
    TDI_PROVIDER_INFO   localProviderInfo;
    BOOLEAN resourceShared = TRUE;

    PAGED_CODE( );

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // If this is the first endpoint, we may be paged out 
    // entirely.
    //
    if (!AfdLoaded) {
        //
        // Take the exclusive lock and page the locked sections in
        // if necessary
        //

        //
        // There should be no endpoints in the list.
        //
        ASSERT (IsListEmpty (&AfdEndpointListHead));

        ExReleaseResourceLite ( AfdResource);

        ExAcquireResourceExclusiveLite( AfdResource, TRUE );
        resourceShared = FALSE;
        if (!AfdLoaded) {
            //
            // There should be no endpoints in the list.
            //
            ASSERT (IsListEmpty (&AfdEndpointListHead));
            MmResetDriverPaging (DriverEntry);
            AfdLoaded = (PKEVENT)1;
        }
    }
    ASSERT (AfdLoaded==(PKEVENT)1);

    if (*TransportInfo==NULL) {

    ScanTransportList:
        //
        // If caller did not have transport info allocated, walk the list 
        // of transport device names looking for an identical name.
        //


        for ( listEntry = AfdTransportInfoListHead.Flink;
              listEntry != &AfdTransportInfoListHead;
              listEntry = listEntry->Flink ) 
        {

            transportInfo = CONTAINING_RECORD(
                                listEntry,
                                AFD_TRANSPORT_INFO,
                                TransportInfoListEntry
                                );

            if ( RtlCompareUnicodeString(
                     &transportInfo->TransportDeviceName,
                     TransportDeviceName,
                     TRUE ) == 0 ) {

                //
                // We found an exact match. Reference the structure
                // to return it to the caller
                //

                do {
                    LONG localCount;
                    localCount = transportInfo->ReferenceCount;
                    if (localCount==0) {
                        //
                        // We hit a small window when the structure is
                        // about to be freed.  We can't stop this from
                        // happenning, so we'll go on to allocate and
                        // requery.  After all info is not valid anyway,
                        // thus we are just loosing on the allocation/dealocation
                        // code.
                        //
                        ASSERT (transportInfo->InfoValid==FALSE);
                        goto AllocateInfo;
                    }

                    if (InterlockedCompareExchange (
                                (PLONG)&transportInfo->ReferenceCount,
                                (localCount+1),
                                localCount)==localCount) {
                        if (transportInfo->InfoValid) {
                            //
                            // Info is valid return referenced pointer to
                            // the caller.
                            //
                            *TransportInfo = transportInfo;
                            ExReleaseResourceLite( AfdResource );
                            KeLeaveCriticalRegion ();
                            return STATUS_SUCCESS;
                        }
                        else {
                            //
                            // We found match, but info is not valid
                            //
                            goto QueryInfo;
                        }
                    }
                }
                while (1);
            }
        } // for

    AllocateInfo:
        if (resourceShared) {
            //
            // If we do not own resource exlusively, we will
            // have to release and reacquire it and then
            // rescan the list
            //
            ExReleaseResourceLite ( AfdResource);
            ExAcquireResourceExclusiveLite( AfdResource, TRUE );
            resourceShared = FALSE;
            goto ScanTransportList;
        }
        //
        // This is a brand new device name, allocate transport info
        // structure for it.
        //

        structureLength = sizeof(AFD_TRANSPORT_INFO) +
                              TransportDeviceName->Length + sizeof(WCHAR);

        transportInfo = AFD_ALLOCATE_POOL_PRIORITY(
                            NonPagedPool,
                            structureLength,
                            AFD_TRANSPORT_INFO_POOL_TAG,
                            NormalPoolPriority
                            );

        if ( transportInfo == NULL ) {
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Initialize the structure
        //
        transportInfo->ReferenceCount = 1;
        transportInfo->InfoValid = FALSE;

        //
        // Fill in the transport device name.
        //

        transportInfo->TransportDeviceName.MaximumLength =
            TransportDeviceName->Length + sizeof(WCHAR);
        transportInfo->TransportDeviceName.Buffer =
            (PWSTR)(transportInfo + 1);

        RtlCopyUnicodeString(
            &transportInfo->TransportDeviceName,
            TransportDeviceName
            );
        //
        // Insert the structure into the list so that the successive callers
        // can reuse it.
        //
        InsertHeadList (&AfdTransportInfoListHead,
                                &transportInfo->TransportInfoListEntry);
    }
    else {
        transportInfo = *TransportInfo;
        //
        // Caller has already referenced info in the list
        // but transport device was not available at the
        // time of the call.  Recheck if it is valid under the lock
        //
        if (transportInfo->InfoValid) {
            //
            // Yes, it is, return success
            //
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
            return STATUS_SUCCESS;
        }
    }


QueryInfo:
    //
    // Release the resource and leave critical region to let
    // the IRP's in AfdQueryProviderInfo complete
    //
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();

    status = AfdQueryProviderInfo (TransportDeviceName, &localProviderInfo);

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    if (NT_SUCCESS (status)) {
        //
        // Check if someone did not get the info in parallel with us.
        //
        if (!transportInfo->InfoValid) {
            //
            // Copy local info structure to the one in the list.
            //
            transportInfo->ProviderInfo = localProviderInfo;

            //
            // Bump the reference count on this info structure
            // as we know that it is a valid TDI provider and we
            // want to cache, it so it stays even of all endpoints
            // that use it are gone.
            //
            InterlockedIncrement ((PLONG)&transportInfo->ReferenceCount);

            //
            // Set the flag so that everyone knows it is now valid.
            //
            transportInfo->InfoValid = TRUE;
        }

        *TransportInfo = transportInfo;
    }
    else {
        if (status==STATUS_OBJECT_NAME_NOT_FOUND ||
                status==STATUS_OBJECT_PATH_NOT_FOUND ||
                status==STATUS_NO_SUCH_DEVICE) {
            //
            // Transport driver must not have been loaded yet
            // Return transport info structure anyway
            // Caller will know that info structure is not
            // valid because we did not set the flag
            //
            *TransportInfo = transportInfo;
        }
        else {
            //
            // Something else went wrong, free the strucuture
            // if it was allocated in this routine
            //

            if (*TransportInfo==NULL) {
                if (InterlockedDecrement ((PLONG)&transportInfo->ReferenceCount)==0) {
                    RemoveEntryList (&transportInfo->TransportInfoListEntry);
                    AFD_FREE_POOL(
                        transportInfo,
                        AFD_TRANSPORT_INFO_POOL_TAG
                        );
                }
            }
        }
    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    return status;

} // AfdGetTransportInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\dispatch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains the dispatch routines for AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdDispatch )
#pragma alloc_text( PAGEAFD, AfdDispatchDeviceControl )
#endif


NTSTATUS
AfdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for AFD.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
#if DBG
    KIRQL currentIrql;

    currentIrql = KeGetCurrentIrql( );
#endif

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MajorFunction ) {

    case IRP_MJ_WRITE:

        //
        // Make the IRP look like a send IRP.
        //

        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Length ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Write.Key ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );
        irpSp->Parameters.Write.Key = 0;

        if (IS_SAN_ENDPOINT ((PAFD_ENDPOINT)irpSp->FileObject->FsContext)) {
            status = AfdSanRedirectRequest (Irp, irpSp);
        }
        else {
			status = AfdSend( Irp, irpSp );
		}

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;

    case IRP_MJ_READ:

        //
        // Make the IRP look like a receive IRP.
        //

        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Length ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );
        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Key ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.InputBufferLength ) );
        irpSp->Parameters.Read.Key = 0;

        if (IS_SAN_ENDPOINT ((PAFD_ENDPOINT)irpSp->FileObject->FsContext)) {
            status = AfdSanRedirectRequest (Irp, irpSp);
        }
        else {
			status = AfdReceive( Irp, irpSp );
		}

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;

    case IRP_MJ_CREATE:

        status = AfdCreate( Irp, irpSp );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        return status;

    case IRP_MJ_CLEANUP:

        status = AfdCleanup( Irp, irpSp );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;

    case IRP_MJ_CLOSE:

        status = AfdClose( Irp, irpSp );

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;
    case IRP_MJ_PNP:
        status = AfdPnpPower (Irp, irpSp );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

        return status;
    case IRP_MJ_DEVICE_CONTROL:

        return AfdDispatchDeviceControl( DeviceObject, Irp );

        //
		// SAN support.
        // Return special error code to let IO manager use default security.
        // (needed to support ObOpenObjectByPointer).
        //
    case IRP_MJ_QUERY_SECURITY:
    case IRP_MJ_SET_SECURITY:
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest( Irp, AfdPriorityBoost );
        return STATUS_INVALID_DEVICE_REQUEST;

    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdDispatch: Invalid major function %lx\n",
                    irpSp->MajorFunction ));
        Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest( Irp, AfdPriorityBoost );

        return STATUS_NOT_IMPLEMENTED;
    }

} // AfdDispatch


NTSTATUS
AfdDispatchDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the dispatch routine for AFD IOCTLs.

Arguments:

    DeviceObject - Pointer to device object for target device

    Irp - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    ULONG code;
    ULONG request;
    NTSTATUS status;
    PAFD_IRP_CALL irpProc;
    PIO_STACK_LOCATION  IrpSp = IoGetCurrentIrpStackLocation (Irp);
#if DBG
    KIRQL currentIrql;

    currentIrql = KeGetCurrentIrql( );
#endif
    UNREFERENCED_PARAMETER (DeviceObject);


    //
    // Extract the IOCTL control code and process the request.
    //

    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _AFD_REQUEST(code);

    if( request < AFD_NUM_IOCTLS && AfdIoctlTable[request] == code ) {

        //
        // Helps in debugging.
        //
        IrpSp->MinorFunction = (UCHAR)request;

        //
        // Try IRP dispatch first
        //
        irpProc = AfdIrpCallDispatch[request];
        if (irpProc!=NULL) {
            status = (*irpProc)(Irp, IrpSp);

            ASSERT( KeGetCurrentIrql( ) == currentIrql );

            return status;
        }
    }
//
// This is currently not used by helper dlls.
// Commented out because of security concerns
//
#if 0
    else if (request==AFD_TRANSPORT_IOCTL) {
        //
        // This is a "special" used to pass request
        // to transport driver using socket handle in
        // order to facilitate proper completion 
        // on sockets associated with completion port.
        // It accepts and properly handles all methods.
        //
        status = AfdDoTransportIoctl (Irp, IrpSp);
        ASSERT( KeGetCurrentIrql() == currentIrql );
        return status;
    }
#endif

    //
    // If we made it this far, then the ioctl is invalid.
    //

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                "AfdDispatchDeviceControl: invalid IOCTL %08lX\n",
                code
                ));

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return STATUS_INVALID_DEVICE_REQUEST;

} // AfdDispatchDeviceControl

NTSTATUS
FASTCALL
AfdDispatchImmediateIrp(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PAFD_IMMEDIATE_CALL immProc;
    ULONG code;
    ULONG request;
    NTSTATUS status;
#if DBG
    KIRQL currentIrql;

    currentIrql = KeGetCurrentIrql( );
#endif

    code = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    request = _AFD_REQUEST(code);

    immProc = AfdImmediateCallDispatch[request];
    if (immProc!=NULL) {
        //
        // Must be METHOD_NEITHER for the below code to be
        // valid.
        //
        ASSERT ( (code & 3) == METHOD_NEITHER );
#if DBG
        if (Irp->RequestorMode!=KernelMode) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdDispatchDeviceControl: "
                        "User mode application somehow bypassed fast io dispatch\n"));
        }
#endif
        status = (*immProc) (
                    IrpSp->FileObject,
                    code,
                    Irp->RequestorMode,
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    Irp->UserBuffer,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                    &Irp->IoStatus.Information
                    );

        ASSERT( KeGetCurrentIrql( ) == currentIrql );

    }
    else {
        ASSERT (!"Missing IOCTL in dispatch table!!!");
        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    This module contains code for opening a handle to AFD.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

BOOLEAN
AfdPerformSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdCreate )
#pragma alloc_text( PAGE, AfdPerformSecurityCheck )
#endif




NTSTATUS
FASTCALL
AfdCreate (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the routine that handles Create IRPs in AFD.  If creates an
    AFD_ENDPOINT structure and fills it in with the information
    specified in the open packet.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PFILE_FULL_EA_INFORMATION eaBuffer;
    UNICODE_STRING transportDeviceName;
    NTSTATUS status;

    PAGED_CODE( );

    DEBUG endpoint = NULL;

    //
    // Find the open packet from the EA buffer in the system buffer of
    // the associated IRP.  Fail the request if there was no EA
    // buffer specified.
    //

    eaBuffer = Irp->AssociatedIrp.SystemBuffer;

    if ( eaBuffer == NULL ) {

        //
        // Allocate an AFD "helper" endpoint.
        //

        status = AfdAllocateEndpoint(
                     &endpoint,
                     NULL,
                     0
                     );

        if( !NT_SUCCESS(status) ) {
            return status;
        }

    } else {
        STRING  EaName;
        STRING  CString;

        EaName.MaximumLength = eaBuffer->EaNameLength+1;
        EaName.Length = eaBuffer->EaNameLength;
        EaName.Buffer = eaBuffer->EaName;

        if (RtlInitString (&CString, AfdOpenPacket),
                RtlEqualString(&CString, &EaName, FALSE)) {
            PAFD_OPEN_PACKET openPacket;

            openPacket = (PAFD_OPEN_PACKET)(eaBuffer->EaName +
                                            eaBuffer->EaNameLength + 1);

            //
            // Make sure that the transport address fits within the specified
            // EA buffer.
            //

            if ((eaBuffer->EaValueLength<sizeof (*openPacket)) ||
                    //
                    // Check for overflow
                    //
                    (FIELD_OFFSET(AFD_OPEN_PACKET,
                            TransportDeviceName[openPacket->TransportDeviceNameLength/2+1])
                        <FIELD_OFFSET(AFD_OPEN_PACKET, TransportDeviceName[1])) ||
                    (eaBuffer->EaValueLength <
                     FIELD_OFFSET(AFD_OPEN_PACKET,
                        TransportDeviceName[openPacket->TransportDeviceNameLength/2+1])) ) {
                return STATUS_ACCESS_VIOLATION;
            }
            //
            // Validate parameters in the open packet.
            //

            if (openPacket->afdEndpointFlags&(~AFD_ENDPOINT_VALID_FLAGS)) {

                          
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Set up a string that describes the transport device name.
            //

            transportDeviceName.Buffer = openPacket->TransportDeviceName;
            transportDeviceName.Length = (USHORT)openPacket->TransportDeviceNameLength;
            transportDeviceName.MaximumLength =
                transportDeviceName.Length + sizeof(WCHAR);



            //
            // Allocate an AFD endpoint.
            //

            status = AfdAllocateEndpoint(
                         &endpoint,
                         &transportDeviceName,
                         openPacket->GroupID
                         );

            if( !NT_SUCCESS(status) ) {
                return status;
            }
            //
            // Store the flags.
            //
            endpoint->afdEndpointFlags = openPacket->afdEndpointFlags;

            //
            // Remember the type of endpoint that this is.  If this is a datagram
            // endpoint, change the block type to reflect this.
            //


            if (openPacket->afdConnectionLess) {

                endpoint->Type = AfdBlockTypeDatagram;

                //
                // Initialize lists which exist only in datagram endpoints.
                //

                InitializeListHead( &endpoint->ReceiveDatagramIrpListHead );
                InitializeListHead( &endpoint->PeekDatagramIrpListHead );
                InitializeListHead( &endpoint->ReceiveDatagramBufferListHead );

                endpoint->Common.Datagram.MaxBufferredReceiveBytes = AfdReceiveWindowSize;
                endpoint->Common.Datagram.MaxBufferredSendBytes = AfdSendWindowSize;
            }
        }
        else if (RtlInitString (&CString, AfdSwitchOpenPacket),
                RtlEqualString(&CString, &EaName, FALSE)) {
            status = AfdSanCreateHelper (Irp, eaBuffer, &endpoint);
            if (!NT_SUCCESS (status))
                return status;
        }
        else {
            IF_DEBUG(OPEN_CLOSE) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCreate: Invalid ea name.\n"));
            }
            return STATUS_INVALID_PARAMETER;
        }
    }

    ASSERT( endpoint != NULL );

    //
    // Perform security check on caller.
    // We need this to know whether to allow exclusive
    // address use when allocating transport address in bind
    // as well as giving access to raw sockets.

    endpoint->AdminAccessGranted = AfdPerformSecurityCheck (Irp, IrpSp, &status);


    //
    // Set up a pointer to the endpoint in the file object so that we
    // can find the endpoint in future calls.
    //

    IrpSp->FileObject->FsContext = endpoint;
    //
    // Setting this field to non-NULL value enable fast IO code path
    // for reads and writes.
    //
    IrpSp->FileObject->PrivateCacheMap = (PVOID)-1;

    IF_DEBUG(OPEN_CLOSE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCreate: opened file object = %p, endpoint = %p\n",
                    IrpSp->FileObject, endpoint ));

    }

    //
    // The open worked.  Dereference the endpoint and return success.
    //

    DEREFERENCE_ENDPOINT( endpoint );

    return STATUS_SUCCESS;

} // AfdCreate


BOOLEAN
AfdPerformSecurityCheck (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PNTSTATUS           Status
    )
/*++

Routine Description:

    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PPRIVILEGE_SET        privileges = NULL;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );


    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(
                        AfdAdminSecurityDescriptor,
                        &accessState->SubjectSecurityContext,
                        TRUE,
                        AccessMask,
                        0,
                        &privileges,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                   accessState,
                   privileges
                   );
        SeFreePrivileges(privileges);
    }

    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        ASSERT (NT_SUCCESS (*Status));
    }
    else {
        ASSERT (!NT_SUCCESS (*Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\connect.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    connect.c

Abstract:

    This module contains the code for passing on connect IRPs to
    TDI providers.

Author:

    David Treadwell (davidtr)    2-Mar-1992

Revision History:

    Vadim Eydelman (vadime) 1999  JoinLeaf implementation
                                    Datagram connect via transport
                                    Connect optimizations and syncronization with
                                    user mode code.

--*/

#include "afdp.h"

NTSTATUS
AfdDoDatagramConnect (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN BOOLEAN HalfConnect
    );

NTSTATUS
AfdRestartConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDgConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdSetupConnectDataBuffers (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN OUT PTDI_CONNECTION_INFORMATION *RequestConnectionInformation,
    IN OUT PTDI_CONNECTION_INFORMATION *ReturnConnectionInformation
    );

BOOLEAN
AfdConnectionStart (
    IN PAFD_ENDPOINT Endpoint
    );

VOID
AfdEnableFailedConnectEvent(
    IN PAFD_ENDPOINT Endpoint
    );


NTSTATUS
AfdRestartJoin (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdJoinInviteSetup (
    PAFD_ENDPOINT   RootEndpoint,
    PAFD_ENDPOINT   LeafEndpoint
    );

VOID
AfdConnectApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdConnectApcRundownRoutine (
    IN struct _KAPC *Apc
    );

VOID
AfdFinishConnect (
    PAFD_ENDPOINT   Endpoint,
    PIRP            Irp,
    PAFD_ENDPOINT   RootEndpoint
    );

NTSTATUS
AfdRestartSuperConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdConnect )
#pragma alloc_text( PAGEAFD, AfdDoDatagramConnect )
#pragma alloc_text( PAGEAFD, AfdRestartConnect )
#pragma alloc_text( PAGEAFD, AfdRestartDgConnect )
#pragma alloc_text( PAGEAFD, AfdSetupConnectDataBuffers )
#pragma alloc_text( PAGEAFD, AfdEnableFailedConnectEvent )
#pragma alloc_text( PAGE, AfdJoinLeaf )
#pragma alloc_text( PAGEAFD, AfdRestartJoin )
#pragma alloc_text( PAGEAFD, AfdJoinInviteSetup )
#pragma alloc_text( PAGE, AfdConnectApcKernelRoutine )
#pragma alloc_text( PAGE, AfdConnectApcRundownRoutine )
#pragma alloc_text( PAGEAFD, AfdFinishConnect )
#pragma alloc_text( PAGE, AfdSuperConnect )
#pragma alloc_text( PAGEAFD, AfdRestartSuperConnect )
#endif

typedef struct _AFD_CONNECT_CONTEXT {
    TDI_CONNECTION_INFORMATION  RequestConnectionInfo;
    TDI_CONNECTION_INFORMATION  ReturnConnectionInfo;
    TRANSPORT_ADDRESS           RemoteAddress;
} AFD_CONNECT_CONTEXT, *PAFD_CONNECT_CONTEXT;

C_ASSERT ( (FIELD_OFFSET (AFD_CONNECTION, SListEntry) % MEMORY_ALLOCATION_ALIGNMENT) == 0 );

NTSTATUS
FASTCALL
AfdConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_CONTEXT context;
    HANDLE connectEndpointHandle;
    PFILE_OBJECT fileObject;
    PTRANSPORT_ADDRESS remoteAddress;
    ULONG  remoteAddressLength;
    PTDI_CONNECTION_INFORMATION requestConnectionInfo, returnConnectionInfo;

    PAGED_CODE( );

    //
    // Initialize for proper cleanup
    //


    fileObject = NULL;
    context = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                    sizeof (AFD_CONNECT_JOIN_INFO32) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0
                    && IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                        sizeof (IO_STATUS_BLOCK32))){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        try {
            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT32 (AFD_CONNECT_JOIN_INFO32)
                    );

            }

            connectEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->ConnectEndpoint;
            remoteAddress = (PTRANSPORT_ADDRESS)&((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RemoteAddress;
            ASSERT (((ULONG_PTR)remoteAddress & (PROBE_ALIGNMENT(TRANSPORT_ADDRESS)-1))==0);
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO32, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }
    }
    else 
#endif //_WIN64
    {

        //
        // Determine where in the system buffer the request and return
        // connection information structures exist.  Pass pointers to
        // these locations instead of the user-mode pointers in the
        // tdiRequest structure so that the memory will be nonpageable.
        //

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                sizeof (AFD_CONNECT_JOIN_INFO) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0 &&
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (IO_STATUS_BLOCK))) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        try {
            PAFD_CONNECT_JOIN_INFO  connectInfo;

            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT (AFD_CONNECT_JOIN_INFO)
                    );

            }

            connectInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            //
            // Check for if the caller is unaware of the SAN
            // provider activation and report the error.
            //
            if (!connectInfo->SanActive && AfdSanServiceHelper!=NULL) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                            "AFD: Process %p is being told to enable SAN on connect\n",
                            PsGetCurrentProcessId ()));
                status = STATUS_INVALID_PARAMETER_12;
                goto complete;
            }

            connectEndpointHandle = connectInfo->ConnectEndpoint;
            remoteAddress = &connectInfo->RemoteAddress;
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }
    }

    try {

        context = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                            FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress)
                                + remoteAddressLength,
                            AFD_TDI_POOL_TAG
                            );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
        ASSERT (context!=NULL);

        Irp->AssociatedIrp.SystemBuffer = context;
        RtlZeroMemory (context,
              FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress));

        RtlCopyMemory (&context->RemoteAddress,
                remoteAddress,
                remoteAddressLength);
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((context->RemoteAddress.TAAddressCount!=1) ||
                (LONG)remoteAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[context->RemoteAddress.Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        context->RequestConnectionInfo.RemoteAddress = &context->RemoteAddress;
        context->RequestConnectionInfo.RemoteAddressLength = remoteAddressLength;

    
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0 && 
                Irp->RequestorMode==UserMode) {
            ProbeForWriteIoStatusEx (
                ((PIO_STATUS_BLOCK)Irp->UserBuffer),
                IoIs32bitProcess (Irp));
        }
    }
    except (AFD_EXCEPTION_FILTER(&status)) {
        goto complete;
    }

    if (FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[
                        context->RemoteAddress.Address[0].AddressLength])
            > (LONG)remoteAddressLength) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    fileObject = IrpSp->FileObject;
    endpoint = fileObject->FsContext;

    if (endpoint->Type==AfdBlockTypeHelper) {
        //
        // This is async connect which uses helper endpoint to
        // communicate to AFD. Get the real endpoint.
        //
        status = ObReferenceObjectByHandle(
                    connectEndpointHandle,
					(IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
												// DesiredAccess
                    *IoFileObjectType,			// ObjectType
                    Irp->RequestorMode,
                    (PVOID *)&fileObject,
                    NULL
                    );
        if (!NT_SUCCESS (status)) {
            goto complete;
        }

        if (fileObject->DeviceObject!=AfdDeviceObject) {
            status = STATUS_INVALID_HANDLE;
            goto complete_deref;
        }
        endpoint = fileObject->FsContext;
        IrpSp->FileObject = fileObject;
    }
    else {
        ObReferenceObject (fileObject);
    }

    if ( endpoint->Type != AfdBlockTypeEndpoint &&
                endpoint->Type != AfdBlockTypeVcConnecting &&
                endpoint->Type != AfdBlockTypeDatagram ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_deref;
    }

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdConnect: starting connect on endpoint %p\n",
                    endpoint ));
    }

    //
    // If this is a datagram endpoint, simply remember the specified
    // address so that we can use it on sends, receives, writes, and
    // reads.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        return AfdDoDatagramConnect( fileObject, Irp, FALSE );
    }

    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_deref;
    }
    //
    // If the endpoint is not bound, then this is an invalid request.
    // Listening endpoints are not allowed as well.
    //

    if ( endpoint->Listening ||
            endpoint->State != AfdEndpointStateBound ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }

    //
    // Create a connection object to use for the connect operation.
    //

    status = AfdCreateConnection(
                 &endpoint->TransportInfo->TransportDeviceName,
                 endpoint->AddressHandle,
                 IS_TDI_BUFFERRING(endpoint),
                 endpoint->InLine,
                 endpoint->OwningProcess,
                 &connection
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }

    //
    // Set up a referenced pointer from the connection to the endpoint.
    // Note that we set up the connection's pointer to the endpoint
    // BEFORE the endpoint's pointer to the connection so that AfdPoll
    // doesn't try to back reference the endpoint from the connection.
    //

    REFERENCE_ENDPOINT( endpoint );
    connection->Endpoint = endpoint;

    //
    // Remember that this is now a connecting type of endpoint, and set
    // up a pointer to the connection in the endpoint.  This is
    // implicitly a referenced pointer.
    //

    endpoint->Common.VcConnecting.Connection = connection;
    endpoint->Type = AfdBlockTypeVcConnecting;

    ASSERT( IS_TDI_BUFFERRING(endpoint) == connection->TdiBufferring );

    //
    // Add an additional reference to the connection.  This prevents the
    // connection from being closed until the disconnect event handler
    // is called.
    //

    AfdAddConnectedReference( connection );

    //
    // If there are connect data buffers, move them from the endpoint
    // structure to the connection structure and set up the necessary
    // pointers in the connection request we're going to give to the TDI
    // provider.  Do this in a subroutine so this routine can be pageable.
    //

    requestConnectionInfo = &context->RequestConnectionInfo;
    returnConnectionInfo = &context->ReturnConnectionInfo;

    if ( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdSetupConnectDataBuffers(
            endpoint,
            connection,
            &requestConnectionInfo,
            &returnConnectionInfo
            );
    }


    //
    // Since we may be reissuing a connect after a previous failed connect,
    // reenable the failed connect event bit.
    //

    AfdEnableFailedConnectEvent( endpoint );


    //
    // Reference the connection block so it does not go away even if
    // endpoint's reference to it is removed (in cleanup)
    //

    REFERENCE_CONNECTION (connection);

    //
    // Build a TDI kernel-mode connect request in the next stack location
    // of the IRP.
    //

    TdiBuildConnect(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartConnect,
        connection,
        &AfdInfiniteTimeout,
        requestConnectionInfo,
        returnConnectionInfo
        );



    AFD_VERIFY_ADDRESS (connection, &requestConnectionInfo->RemoteAddress);
    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete_state_change:
    AFD_END_STATE_CHANGE (endpoint);

complete_deref:
    ASSERT (fileObject!=NULL);
    ObDereferenceObject (fileObject);

complete:

    if (context!=NULL) {
        AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
        ASSERT (Irp->AssociatedIrp.SystemBuffer==context);
        Irp->AssociatedIrp.SystemBuffer = NULL;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdConnect


NTSTATUS
AfdDoDatagramConnect (
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN BOOLEAN HalfConnect
    )
{
    PAFD_ENDPOINT   endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS status;
    PAFD_CONNECT_CONTEXT context;

    endpoint = FileObject->FsContext;
    context = Irp->AssociatedIrp.SystemBuffer;

    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (endpoint->State!=AfdEndpointStateBound &&
            endpoint->State!=AfdEndpointStateConnected) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_state_change;
    }
            
    //
    // Save the remote address on the endpoint.  We'll use this to
    // send datagrams in the future and to compare received datagram's
    // source addresses.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    if ((endpoint->Common.Datagram.RemoteAddress==NULL) ||
            (endpoint->Common.Datagram.RemoteAddressLength<
                (ULONG)context->RequestConnectionInfo.RemoteAddressLength)) {
        
        if ( endpoint->Common.Datagram.RemoteAddress != NULL ) {
            AFD_RETURN_REMOTE_ADDRESS (
                endpoint->Common.Datagram.RemoteAddress,
                endpoint->Common.Datagram.RemoteAddressLength
                );
            endpoint->Common.Datagram.RemoteAddress = NULL;
        }

        endpoint->Common.Datagram.RemoteAddress =
            AFD_ALLOCATE_REMOTE_ADDRESS (
                    context->RequestConnectionInfo.RemoteAddressLength);

        if (endpoint->Common.Datagram.RemoteAddress == NULL) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_state_change;
        }
    }

    RtlCopyMemory(
        endpoint->Common.Datagram.RemoteAddress,
        context->RequestConnectionInfo.RemoteAddress,
        context->RequestConnectionInfo.RemoteAddressLength
        );

    endpoint->Common.Datagram.RemoteAddressLength =
        context->RequestConnectionInfo.RemoteAddressLength;


    endpoint->DisconnectMode = 0;

    endpoint->Common.Datagram.HalfConnect = HalfConnect;

    if (!IS_TDI_DGRAM_CONNECTION(endpoint)) {
    
        endpoint->State = AfdEndpointStateConnected;

        //
        // Indicate that the connect completed.  Implicitly, the
        // successful completion of a connect also means that the caller
        // can do a send on the socket.
        //

        endpoint->EnableSendEvent = TRUE;
        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_CONNECT | AFD_POLL_SEND,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_CONNECT | AFD_POLL_SEND,
            STATUS_SUCCESS
            );
        status = STATUS_SUCCESS;
    }
    else {

        //
        // Reset the connect status to success so that the poll code will
        // know if a connect failure occurs.
        // Do this inline as we already hold spinlock
        //

        endpoint->EventsActive &= ~AFD_POLL_CONNECT_FAIL;
        endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT] = STATUS_SUCCESS;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Build a TDI kernel-mode connect request in the next stack location
        // of the IRP.
        //

        TdiBuildConnect(
            Irp,
            endpoint->AddressDeviceObject,
            endpoint->AddressFileObject,
            AfdRestartDgConnect,
            endpoint,
            &AfdInfiniteTimeout,
            &context->RequestConnectionInfo,
            &context->ReturnConnectionInfo
            );

        //
        // Call the transport to actually perform the connect operation.
        //

        return AfdIoCallDriver( endpoint, endpoint->AddressDeviceObject, Irp );
    }

complete_state_change:
    AFD_END_STATE_CHANGE (endpoint);

complete:
    ObDereferenceObject (FileObject);

    AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
    ASSERT (Irp->AssociatedIrp.SystemBuffer==context);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdDoDatagramConnect


VOID
AfdSetupConnectDataBuffers (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN OUT PTDI_CONNECTION_INFORMATION *RequestConnectionInformation,
    IN OUT PTDI_CONNECTION_INFORMATION *ReturnConnectionInformation
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    ASSERT (Endpoint->Type!=AfdBlockTypeDatagram);

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    if ( Endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        PTDI_CONNECTION_INFORMATION requestConnectionInformation,
                                    returnConnectionInformation;

        ASSERT( Connection->ConnectDataBuffers == NULL );

        Connection->ConnectDataBuffers = Endpoint->Common.VirtualCircuit.ConnectDataBuffers;
        Endpoint->Common.VirtualCircuit.ConnectDataBuffers = NULL;

        requestConnectionInformation = &Connection->ConnectDataBuffers->RequestConnectionInfo,
        requestConnectionInformation->UserData =
            Connection->ConnectDataBuffers->SendConnectData.Buffer;
        requestConnectionInformation->UserDataLength =
            Connection->ConnectDataBuffers->SendConnectData.BufferLength;
        requestConnectionInformation->Options =
            Connection->ConnectDataBuffers->SendConnectOptions.Buffer;
        requestConnectionInformation->OptionsLength =
            Connection->ConnectDataBuffers->SendConnectOptions.BufferLength;
        requestConnectionInformation->RemoteAddress = 
            (*RequestConnectionInformation)->RemoteAddress;
        requestConnectionInformation->RemoteAddressLength = 
            (*RequestConnectionInformation)->RemoteAddressLength;
        *RequestConnectionInformation = requestConnectionInformation;

        returnConnectionInformation = &Connection->ConnectDataBuffers->ReturnConnectionInfo;
        returnConnectionInformation->UserData =
            Connection->ConnectDataBuffers->ReceiveConnectData.Buffer;
        returnConnectionInformation->UserDataLength =
            Connection->ConnectDataBuffers->ReceiveConnectData.BufferLength;
        returnConnectionInformation->Options =
            Connection->ConnectDataBuffers->ReceiveConnectOptions.Buffer;
        returnConnectionInformation->OptionsLength =
            Connection->ConnectDataBuffers->ReceiveConnectOptions.BufferLength;
        returnConnectionInformation->RemoteAddress = 
            (*ReturnConnectionInformation)->RemoteAddress;
        returnConnectionInformation->RemoteAddressLength = 
            (*ReturnConnectionInformation)->RemoteAddressLength;
        *ReturnConnectionInformation = returnConnectionInformation;
    }

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

} // AfdSetupConnectDataBuffers


NTSTATUS
AfdRestartConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    PAFD_CONNECT_CONTEXT context;

    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;
    ASSERT( fileObject->DeviceObject==AfdDeviceObject );
    
    endpoint = fileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
    ASSERT( endpoint==connection->Endpoint );

    context = Irp->AssociatedIrp.SystemBuffer;
    ASSERT( context != NULL );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartConnect: connect completed, status = %X, endpoint = %p\n", 
                    Irp->IoStatus.Status, endpoint ));
    }


    if ( connection->ConnectDataBuffers != NULL ) {

        //
        // If there are connect buffers on this endpoint, remember the
        // size of the return connect data.
        //

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Double-check under the lock
        //

        if ( connection->ConnectDataBuffers != NULL ) {
            NTSTATUS    status;

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_DATA,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserData,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserDataLength
                         );
            ASSERT (NT_SUCCESS (status));

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_OPTIONS,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.Options,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.OptionsLength
                         );
            ASSERT (NT_SUCCESS (status));
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status)) {


        //
        // If the request succeeded, set the endpoint to the connected
        // state.  The endpoint type has already been set to
        // AfdBlockTypeVcConnecting.
        //

        endpoint->State = AfdEndpointStateConnected;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

        //
        // Remember the time that the connection started.
        //

        connection->ConnectTime = KeQueryInterruptTime();

    } else {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // The connect failed, so reset the type to open.
        // Otherwise, we won't be able to start another connect
        //


        endpoint->Type = AfdBlockTypeEndpoint;

        if (endpoint->Common.VcConnecting.Connection!=NULL) {
            ASSERT (connection==endpoint->Common.VcConnecting.Connection);
            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // Manually delete the connected reference if somebody else
            // hasn't already done so.  We can't use
            // AfdDeleteConnectedReference() because it refuses to delete
            // the connected reference until the endpoint has been cleaned
            // up.
            //

            if ( connection->ConnectedReferenceAdded ) {
                connection->ConnectedReferenceAdded = FALSE;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_CONNECTION( connection );
            } else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            //
            // Dereference the connection block stored on the endpoint.
            // This should cause the connection object reference count to go
            // to zero to the connection object can be deleted.
            //
            DEREFERENCE_CONNECTION( connection );
        }
        else {
            //
            // The endpoint's reference to connection was removed
            // (perhaps in cleanup);
            //
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }


    }

    AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // Dereference connection to account for reference we added in AfdConnect
    //
    DEREFERENCE_CONNECTION( connection );

    //
    // Try to queue kernel APC to the user thread that
    // started the connection operation, so we can
    // communicate the status of the connect operation to
    // msafd.dll before we inform the application through
    // the select or EventSelect.  Otherwise, we run into the
    // race condition when application learns about connect first,
    // calls msafd.dll that is not aware of the completion and
    // returns WSAENOTCONN.
    //
    if ((Irp->RequestorMode==UserMode) && // Must be user mode calls
            (Irp->UserBuffer!=NULL) &&   // Must be interested in status
                                         // Thread should be able to 
                                         // run APCs.
            (KeInitializeApc (&endpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdConnectApcKernelRoutine,
                            AfdConnectApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&endpoint->Common.VcConnecting.Apc,
                                    Irp,
                                    NULL,
                                    AfdPriorityBoost))) {
        //
        // We will complete the IRP in the APC.
        //
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // APC was not necessary or did not work.
        // Complete it here.
        //
        AfdFinishConnect (endpoint, Irp, NULL);
        return STATUS_SUCCESS;
    }

} // AfdRestartConnect



VOID
AfdConnectApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
{
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT   endpoint, rootEndpoint;
#if DBG
    try {
#endif

    //
    // Validate parameters.
    //
    ASSERT (*NormalRoutine==NULL);

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    irp = *SystemArgument1;
    ASSERT (irp->UserBuffer!=NULL && irp->RequestorMode==UserMode);

    irpSp = IoGetCurrentIrpStackLocation( irp );

    rootEndpoint = *SystemArgument2;
    ASSERT (rootEndpoint==NULL || IS_AFD_ENDPOINT_TYPE (endpoint));
    //
    // Update the status for the user mode caller before
    // signalling events.
    //
    try {
#ifdef _WIN64
        if (IoIs32bitProcess (irp)) {
            ((PIO_STATUS_BLOCK32)irp->UserBuffer)->Status = (LONG)irp->IoStatus.Status;
        }
        else
#endif //_WIN64
        {
            ((PIO_STATUS_BLOCK)irp->UserBuffer)->Status = irp->IoStatus.Status;
        }
    }
    except (AFD_EXCEPTION_FILTER (NULL)) {
        NOTHING;
    }

    AfdFinishConnect (endpoint, irp, rootEndpoint);
    IoCompleteRequest (irp, AfdPriorityBoost);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}

VOID
AfdConnectApcRundownRoutine (
    IN struct _KAPC *Apc
    )
{
    PIRP            irp;
    PAFD_ENDPOINT   endpoint, rootEndpoint;
#if DBG
    try {
#endif

    endpoint = CONTAINING_RECORD (Apc, AFD_ENDPOINT, Common.VcConnecting.Apc);
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));
    irp = Apc->SystemArgument1;
    rootEndpoint = Apc->SystemArgument2;
    ASSERT (rootEndpoint==NULL || IS_AFD_ENDPOINT_TYPE (endpoint));
    
    ASSERT (irp->UserBuffer!=NULL && irp->RequestorMode==UserMode);

    //
    // Thread is exiting, don't bother updating user mode status.
    // Just signal the events and complet the IRP.
    //

    AfdFinishConnect (endpoint, irp, rootEndpoint);
    IoCompleteRequest (irp, AfdPriorityBoost);
#if DBG
    }
    except (AfdApcExceptionFilter (GetExceptionInformation (),
                                    __FILE__,
                                    __LINE__)) {
        DbgBreakPoint ();
    }
#endif
}

VOID
AfdFinishConnect (
    PAFD_ENDPOINT   Endpoint,
    PIRP            Irp,
    PAFD_ENDPOINT   RootEndpoint
    )
{
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG           eventMask;

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        eventMask = AFD_POLL_CONNECT;
    }
    else {
        eventMask = AFD_POLL_CONNECT_FAIL;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;

    if (RootEndpoint!=NULL) {
        AfdAcquireSpinLock (&RootEndpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent (RootEndpoint, eventMask, Irp->IoStatus.Status);
        AfdReleaseSpinLock (&RootEndpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent (RootEndpoint, eventMask, Irp->IoStatus.Status);
        AFD_END_STATE_CHANGE (RootEndpoint);
        eventMask = 0;
        if (!NT_SUCCESS (Irp->IoStatus.Status)) {
            DEREFERENCE_ENDPOINT (RootEndpoint);
        }
    }

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);

    if (NT_SUCCESS (Irp->IoStatus.Status)) {
        eventMask |= AFD_POLL_SEND;
        Endpoint->EnableSendEvent = TRUE;
        if (Endpoint->Common.VcConnecting.Connection!=NULL) {
            Endpoint->Common.VcConnecting.Connection->State = AfdConnectionStateConnected;
            if (IS_DATA_ON_CONNECTION (Endpoint->Common.VcConnecting.Connection)) {
                eventMask |= AFD_POLL_RECEIVE;
            }
        }
    }

    if (eventMask!=0) {
        AfdIndicateEventSelectEvent (Endpoint, eventMask, Irp->IoStatus.Status);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent (Endpoint, eventMask, Irp->IoStatus.Status);
    }
    else {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
    }

    AFD_END_STATE_CHANGE (Endpoint);
    ObDereferenceObject (fileObject);
}



NTSTATUS
AfdRestartDgConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG       eventMask;

    endpoint = Context;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;

    ASSERT (endpoint == fileObject->FsContext);

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdRestartDgConnect: connect completed, status = %X, endpoint = %p\n",
                Irp->IoStatus.Status, endpoint ));
    }




    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {

        endpoint->State = AfdEndpointStateConnected;

        endpoint->EnableSendEvent = TRUE;
        eventMask = AFD_POLL_CONNECT | AFD_POLL_SEND;

    } else {

        eventMask = AFD_POLL_CONNECT_FAIL;

    }
    AfdIndicateEventSelectEvent (endpoint, eventMask, Irp->IoStatus.Status);
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    AfdIndicatePollEvent (endpoint, eventMask, Irp->IoStatus.Status);

    AFD_END_STATE_CHANGE (endpoint);

    ASSERT (Irp->AssociatedIrp.SystemBuffer!=NULL);
    AFD_FREE_POOL (Irp->AssociatedIrp.SystemBuffer, AFD_TDI_POOL_TAG);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // Remove reference added in AfdConnect
    //
    ObDereferenceObject (fileObject);

    return STATUS_SUCCESS;

} // AfdRestartDgConnect



VOID
AfdEnableFailedConnectEvent(
    IN PAFD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Reenables the failed connect poll bit on the specified endpoint.
    This is off in a separate (nonpageable) routine so that the bulk
    of AfdConnect() can remain pageable.

Arguments:

    Endpoint - The endpoint to enable.

Return Value:

    None.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    ASSERT( ( Endpoint->EventsActive & AFD_POLL_CONNECT ) == 0 );
    Endpoint->EventsActive &= ~AFD_POLL_CONNECT_FAIL;
    Endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT] = STATUS_SUCCESS;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdConnect: Endp %08lX, Active %08lX\n",
                    Endpoint,
                    Endpoint->EventsActive
                    ));
    }

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

}   // AfdEnableFailedConnectEvent



NTSTATUS
FASTCALL
AfdJoinLeaf (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_JOIN_LEAF IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT leafEndpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_CONTEXT context;
    HANDLE connectEndpointHandle;
    HANDLE rootEndpointHandle;
    PFILE_OBJECT fileObject;
    PTRANSPORT_ADDRESS remoteAddress;
    ULONG  remoteAddressLength;
    PTDI_CONNECTION_INFORMATION requestConnectionInfo, returnConnectionInfo;

    PAGED_CODE( );

    //
    // Initialize for proper cleanup
    //

    fileObject = NULL;
    connection = NULL;
    context = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                    sizeof (AFD_CONNECT_JOIN_INFO32) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0 &&
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                        sizeof (IO_STATUS_BLOCK32))){
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        try {
            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT32 (AFD_CONNECT_JOIN_INFO32)
                    );

            }

            connectEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->ConnectEndpoint;
            rootEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RootEndpoint;
            remoteAddress = (PTRANSPORT_ADDRESS)&((PAFD_CONNECT_JOIN_INFO32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RemoteAddress;
            ASSERT (((ULONG_PTR)remoteAddress & (PROBE_ALIGNMENT(TRANSPORT_ADDRESS)-1))==0);
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO32, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }
    }
    else
#endif //_WIN64
    {

        //
        // Determine where in the system buffer the request and return
        // connection information structures exist.  Pass pointers to
        // these locations instead of the user-mode pointers in the
        // tdiRequest structure so that the memory will be nonpageable.
        //

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                sizeof (AFD_CONNECT_JOIN_INFO) ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0 &&
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (IO_STATUS_BLOCK))) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        try {
            if( Irp->RequestorMode != KernelMode ) {

                ProbeForRead(
                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    PROBE_ALIGNMENT (AFD_CONNECT_JOIN_INFO)
                    );

            }

            connectEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->ConnectEndpoint;
            rootEndpointHandle = 
                ((PAFD_CONNECT_JOIN_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RootEndpoint;
            remoteAddress = &((PAFD_CONNECT_JOIN_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->RemoteAddress;
            remoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength
                                    - FIELD_OFFSET (AFD_CONNECT_JOIN_INFO, RemoteAddress);
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }
    }

    try {

        context = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                            FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress)
                                + remoteAddressLength,
                            AFD_TDI_POOL_TAG
                            );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
        ASSERT (context!=NULL);

        Irp->AssociatedIrp.SystemBuffer = context;
        RtlZeroMemory (context,
              FIELD_OFFSET (AFD_CONNECT_CONTEXT, RemoteAddress));

        RtlCopyMemory (&context->RemoteAddress,
                remoteAddress,
                remoteAddressLength);
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((context->RemoteAddress.TAAddressCount!=1) ||
                (LONG)remoteAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[context->RemoteAddress.Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        context->RequestConnectionInfo.RemoteAddress = &context->RemoteAddress;
        context->RequestConnectionInfo.RemoteAddressLength = remoteAddressLength;

    
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0 && 
                Irp->RequestorMode==UserMode) {
            ProbeForWriteIoStatusEx (
                ((PIO_STATUS_BLOCK)Irp->UserBuffer),
                IoIs32bitProcess (Irp));
        }
    }
    except (AFD_EXCEPTION_FILTER(&status)) {
        goto complete;
    }

    fileObject = IrpSp->FileObject;
    leafEndpoint = fileObject->FsContext;

    if (leafEndpoint->Type==AfdBlockTypeHelper) {
        //
        // This is async join leaf which uses helper endpoint to
        // communicate to AFD. Get the real endpoint.
        //
        status = ObReferenceObjectByHandle(
					connectEndpointHandle,
					(IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
												// DesiredAccess
                    *IoFileObjectType,			// ObjectType
                    Irp->RequestorMode,
                    (PVOID *)&fileObject,
                    NULL
                    );
        if (!NT_SUCCESS (status)) {
            goto complete;
        }

        if (fileObject->DeviceObject!=AfdDeviceObject) {
            status = STATUS_INVALID_HANDLE;
            goto complete_deref;
        }

        leafEndpoint = fileObject->FsContext;
        IrpSp->FileObject = fileObject;
    }
    else
        ObReferenceObject (fileObject);


    if ( leafEndpoint->Type != AfdBlockTypeEndpoint &&
                leafEndpoint->Type != AfdBlockTypeVcConnecting &&
                leafEndpoint->Type != AfdBlockTypeDatagram ) {
        status = STATUS_INVALID_PARAMETER;
        goto complete_deref;
    }

    if (rootEndpointHandle!=NULL) {
        //
        // Root inviting leaf
        //
        PFILE_OBJECT    rootObject;
        PAFD_ENDPOINT   rootEndpoint;

        status = ObReferenceObjectByHandle(
                    rootEndpointHandle,
					(IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
												// DesiredAccess
                    *IoFileObjectType,			// ObjectType
                    Irp->RequestorMode,
                    (PVOID *)&rootObject,
                    NULL
                    );
        if (!NT_SUCCESS (status)) {
            goto complete_deref;
        }

        if (rootObject->DeviceObject!=AfdDeviceObject) {
            ObDereferenceObject (rootObject);
            status = STATUS_INVALID_HANDLE;
            goto complete_deref;
        }

        //
        // Get the endpoint structure of the file object
        //

        rootEndpoint = rootObject->FsContext;

        if (!AFD_START_STATE_CHANGE (leafEndpoint, AfdEndpointStateConnected)) {
            ObDereferenceObject (rootObject);
            status = STATUS_INVALID_PARAMETER;
            goto complete_deref;
        }

        //
        // Verify root and leaf endpoint's type and states
        //
        if (IS_VC_ENDPOINT(rootEndpoint) &&
                rootEndpoint->afdC_Root &&
                rootEndpoint->State==AfdEndpointStateConnected &&
                IS_VC_ENDPOINT(leafEndpoint) &&
                leafEndpoint->TransportInfo==rootEndpoint->TransportInfo &&
                leafEndpoint->State==AfdEndpointStateOpen) {
            //
            // Create a connection object to use for the connect operation.
            //

            status = AfdCreateConnection(
                         &rootEndpoint->TransportInfo->TransportDeviceName,
                         rootEndpoint->AddressHandle,
                         IS_TDI_BUFFERRING(rootEndpoint),
                         leafEndpoint->InLine,
                         leafEndpoint->OwningProcess,
                         &connection
                         );

            //
            // No more joins are allowed while this one is active
            //

            if (AFD_START_STATE_CHANGE (rootEndpoint, rootEndpoint->State)) {
                AfdJoinInviteSetup (rootEndpoint, leafEndpoint);
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }

        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }

        //
        // We referenced root endpoint in invite routine, so
        // we no longer need reference to root file object
        //
        ObDereferenceObject (rootObject);

        if (!NT_SUCCESS (status)) {
            goto complete_state_change;
        }
    }
    else {
        //
        // If this is a datagram endpoint, simply remember the specified
        // address so that we can use it on sends, and writes.
        //

        if ( IS_DGRAM_ENDPOINT(leafEndpoint) ) {
            if (leafEndpoint->State!=AfdEndpointStateConnected) {
                return AfdDoDatagramConnect( fileObject, Irp, TRUE);
            }
            else {
                //
                // If endpoint is already connected, that connection takes
                // precedence
                //
                status = STATUS_SUCCESS;
                goto complete_deref;
            }
        }
        else if (IS_VC_ENDPOINT (leafEndpoint)) {

            if (!AFD_START_STATE_CHANGE (leafEndpoint, AfdEndpointStateConnected)) {
                status = STATUS_INVALID_PARAMETER;
                goto complete_deref;
            }

            if (leafEndpoint->State != AfdEndpointStateBound) {
                status = STATUS_INVALID_PARAMETER;
                goto complete_state_change;
            }
            //
            // Create a connection object to use for the connect operation.
            //

            status = AfdCreateConnection(
                         &leafEndpoint->TransportInfo->TransportDeviceName,
                         leafEndpoint->AddressHandle,
                         IS_TDI_BUFFERRING(leafEndpoint),
                         leafEndpoint->InLine,
                         leafEndpoint->OwningProcess,
                         &connection
                         );

            if ( !NT_SUCCESS(status) ) {
                goto complete_state_change;
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER;
            goto complete_deref;
        }
    }


    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdJoinLeaf: starting join for endpoint %p\n",
                    leafEndpoint ));
    }


        

    //
    // Set up a referenced pointer from the connection to the endpoint.
    // Note that we set up the connection's pointer to the endpoint
    // BEFORE the endpoint's pointer to the connection so that AfdPoll
    // doesn't try to back reference the endpoint from the connection.
    //

    REFERENCE_ENDPOINT( leafEndpoint );
    connection->Endpoint = leafEndpoint;

    //
    // Remember that this is now a connecting type of endpoint, and set
    // up a pointer to the connection in the endpoint.  This is
    // implicitly a referenced pointer.
    //

    leafEndpoint->Common.VcConnecting.Connection = connection;
    leafEndpoint->Type = AfdBlockTypeVcConnecting;

    ASSERT( IS_TDI_BUFFERRING(leafEndpoint) == connection->TdiBufferring );

    //
    // Add an additional reference to the connection.  This prevents the
    // connection from being closed until the disconnect event handler
    // is called.
    //

    AfdAddConnectedReference( connection );

    //
    // If there are connect data buffers, move them from the endpoint
    // structure to the connection structure and set up the necessary
    // pointers in the connection request we're going to give to the TDI
    // provider.  Do this in a subroutine so this routine can be pageable.
    //

    requestConnectionInfo = &context->RequestConnectionInfo;
    returnConnectionInfo = &context->ReturnConnectionInfo;

    if ( leafEndpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdSetupConnectDataBuffers(
            leafEndpoint,
            connection,
            &requestConnectionInfo,
            &returnConnectionInfo
            );
    }

    //
    // Since we may be reissuing a connect after a previous failed connect,
    // reenable the failed connect event bit.
    //

    AfdEnableFailedConnectEvent( leafEndpoint );


    REFERENCE_CONNECTION (connection);
    
    //
    // Build a TDI kernel-mode connect request in the next stack location
    // of the IRP.
    //

    TdiBuildConnect(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartJoin,
        connection,
        &AfdInfiniteTimeout,
        requestConnectionInfo,
        returnConnectionInfo
        );

    AFD_VERIFY_ADDRESS (connection, &context->ReturnConnectionInfo->RemoteAddress);

    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( leafEndpoint, connection->DeviceObject, Irp );

complete_state_change:
    AFD_END_STATE_CHANGE (leafEndpoint);


complete_deref:
    ObDereferenceObject (fileObject);

complete:

    if (context!=NULL) {
        AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
        ASSERT (Irp->AssociatedIrp.SystemBuffer==context);
        Irp->AssociatedIrp.SystemBuffer = NULL;
    }

    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );


    return status;

} // AfdJoinLeaf


VOID
AfdJoinInviteSetup (
    PAFD_ENDPOINT   RootEndpoint,
    PAFD_ENDPOINT   LeafEndpoint
    )
{
    NTSTATUS    status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;


    RootEndpoint->EventsActive &= ~AFD_POLL_CONNECT;

    AfdAcquireSpinLock (&LeafEndpoint->SpinLock, &lockHandle);
    LeafEndpoint->TdiServiceFlags = RootEndpoint->TdiServiceFlags;

    //
    // Set up a referenced pointer to the root endpoint.  This is
    // necessary so that the endpoint does not go away until all
    // leaf endpoints have gone away.  Without this, we can free
    // several shared strucutures that are associated with root
    // endpoint and then attempt to use them in leaf endpoints.
    //

    REFERENCE_ENDPOINT (RootEndpoint);
    LeafEndpoint->Common.VcConnecting.ListenEndpoint = RootEndpoint;

    //
    // Set up a referenced pointer in the accepted endpoint to the
    // TDI address object.
    //

    ObReferenceObject( RootEndpoint->AddressFileObject );
    AfdRecordAddrRef();

    LeafEndpoint->AddressFileObject = RootEndpoint->AddressFileObject;
    LeafEndpoint->AddressDeviceObject = RootEndpoint->AddressDeviceObject;

    //
    // Copy the pointer to the local address. Because we keep listen
    // endpoint alive for as long as any of its connection is
    // active, we can rely on the fact that address structure won't go
    // away as well.
    //
    LeafEndpoint->LocalAddress = RootEndpoint->LocalAddress;
    LeafEndpoint->LocalAddressLength = RootEndpoint->LocalAddressLength;
    status = STATUS_SUCCESS;
    AfdReleaseSpinLock (&LeafEndpoint->SpinLock, &lockHandle);

} // AfdJoinInviteSetup



NTSTATUS
AfdRestartJoin (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint, rootEndpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT    fileObject;
    PAFD_CONNECT_CONTEXT context;

    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    fileObject = irpSp->FileObject;
    ASSERT( fileObject->DeviceObject == AfdDeviceObject );

    endpoint = fileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

    context = Irp->AssociatedIrp.SystemBuffer;
    ASSERT( context != NULL );


    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartJoin: join completed, status = %X, "
                    "LeafEndpoint = %p, RootEndpoint = %p\n", 
                    Irp->IoStatus.Status, endpoint,
                    endpoint->Common.VcConnecting.ListenEndpoint ));
    }

    //
    // If this endpoint has root associated with it, 
    // we need to update it as well.
    //
    rootEndpoint = endpoint->Common.VcConnecting.ListenEndpoint;
    ASSERT ( rootEndpoint==NULL || 
                (rootEndpoint->afdC_Root &&
                    (rootEndpoint->Type == AfdBlockTypeVcConnecting ||
                        rootEndpoint->Type == AfdBlockTypeVcBoth) ) );

    //
    // If there are connect buffers on this endpoint, remember the
    // size of the return connect data.
    //


    if ( connection->ConnectDataBuffers != NULL ) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Double-check under the lock
        //

        if ( connection->ConnectDataBuffers != NULL ) {
            NTSTATUS    status;

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_DATA,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserData,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserDataLength
                         );
            ASSERT (NT_SUCCESS (status));

            status = AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_OPTIONS,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.Options,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.OptionsLength
                         );
            ASSERT (NT_SUCCESS (status));
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }


    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status) ) {


        //
        // If the request succeeded, set the endpoint to the connected
        // state.  The endpoint type has already been set to
        // AfdBlockTypeVcConnecting.
        //

        endpoint->State = AfdEndpointStateConnected;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

        //
        // Remember the time that the connection started.
        //

        connection->ConnectTime = KeQueryInterruptTime();

    } else {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        //
        // The connect failed, so reset the type to open.
        // If we don't reset, we won't be able to start
        // another join
        //

        endpoint->Type = AfdBlockTypeEndpoint;

        //
        // Remove references to listening endpoint and connection
        // Actual dereferncing is below after we release the spinlock

        if (rootEndpoint!=NULL) {
            endpoint->Common.VcConnecting.ListenEndpoint = NULL;
            //
            // We used the local address from the listening endpoint,
            // simply reset it, it will be freed when listening endpoint
            // is freed.
            //

            ASSERT (endpoint->LocalAddress==rootEndpoint->LocalAddress);
            endpoint->LocalAddress = NULL;
            endpoint->LocalAddressLength = 0;
        }

        if (endpoint->Common.VcConnecting.Connection != NULL) {
            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // Manually delete the connected reference if somebody else
            // hasn't already done so.  We can't use
            // AfdDeleteConnectedReference() because it refuses to delete
            // the connected reference until the endpoint has been cleaned
            // up.
            //

            if ( connection->ConnectedReferenceAdded ) {
                connection->ConnectedReferenceAdded = FALSE;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_CONNECTION( connection );
            } else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // Dereference the connection block stored on the endpoint.
            // This should cause the connection object reference count to go
            // to zero to the connection object can be deleted.
            //

            DEREFERENCE_CONNECTION( connection );
        }
        else {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }

    }


    AFD_FREE_POOL (context, AFD_TDI_POOL_TAG);
    Irp->AssociatedIrp.SystemBuffer = NULL;

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }


    AfdCompleteOutstandingIrp( endpoint, Irp );

    //
    // Dereference connection  to account for reference
    // we added in AfdConnect
    //
    DEREFERENCE_CONNECTION( connection );

    //
    // Try to queue kernel APC to the user thread that
    // started the connection operation, so we can
    // communicate the status of the connect operation to
    // msafd.dll before we inform the application through
    // the select or EventSelect.  Otherwise, we run into the
    // race condition when application learns about connect first,
    // calls msafd.dll that is not aware of the completion and
    // returns WSAENOTCONN.
    //
    if ((Irp->RequestorMode==UserMode) && // Must be user mode calls
            (Irp->UserBuffer!=NULL) &&   // Must be interested in status
                                         // Thread should be able to 
                                         // run APCs.
            (KeInitializeApc (&endpoint->Common.VcConnecting.Apc,
                            PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                            Irp->ApcEnvironment,
                            AfdConnectApcKernelRoutine,
                            AfdConnectApcRundownRoutine,
                            (PKNORMAL_ROUTINE)NULL,
                            KernelMode,
                            NULL
                            ),
                KeInsertQueueApc (&endpoint->Common.VcConnecting.Apc,
                                    Irp,
                                    rootEndpoint,
                                    AfdPriorityBoost))) {
        //
        // We will complete the IRP in the APC.
        //
        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {
        //
        // APC was not necessary or did not work.
        // Complete it here.
        //
        AfdFinishConnect (endpoint, Irp, rootEndpoint);
        return STATUS_SUCCESS;
    }
} // AfdRestartJoin


NTSTATUS
FASTCALL
AfdSuperConnect (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_SUPER_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER afdBuffer;
    PTRANSPORT_ADDRESS remoteAddress;
    PVOID context;
    PTDI_CONNECTION_INFORMATION requestConnectionInfo, returnConnectionInfo;

    PAGED_CODE( );

    //
    // Initialize for proper cleanup
    //


    afdBuffer = NULL;
    endpoint = IrpSp->FileObject->FsContext;



    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<
            sizeof (TRANSPORT_ADDRESS)) {
        status = STATUS_BUFFER_TOO_SMALL;
        goto complete;
    }

    try {
        if( Irp->RequestorMode != KernelMode ) {

            ProbeForRead(
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                PROBE_ALIGNMENT (TRANSPORT_ADDRESS)
                );

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0) {
                ProbeForRead (Irp->UserBuffer,
                                IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                                sizeof (UCHAR));
            }
        }


        afdBuffer = AfdGetBufferRaiseOnFailure (
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            endpoint->OwningProcess
                            );

        remoteAddress = afdBuffer->TdiInfo.RemoteAddress; 

        RtlCopyMemory (afdBuffer->TdiInfo.RemoteAddress,
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                IrpSp->Parameters.DeviceIoControl.InputBufferLength);
        afdBuffer->TdiInfo.RemoteAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
        //
        // Validate internal consistency of the transport address structure.
        // Note that we HAVE to do this after copying since the malicious
        // application can change the content of the buffer on us any time
        // and our check will be bypassed.
        //
        if ((remoteAddress->TAAddressCount!=1) ||
                (LONG)afdBuffer->TdiInfo.RemoteAddressLength<
                    FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[remoteAddress->Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength>0) {
            RtlCopyMemory (afdBuffer->Buffer,
                            Irp->UserBuffer,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength
                            );
            afdBuffer->DataLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        }
        else {
            afdBuffer->DataLength = 0;
        }
    
    }
    except (AFD_EXCEPTION_FILTER(&status)) {
        goto complete;
    }

    if (!AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateConnected)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // If the endpoint is not bound, then this is an invalid request.
    // Listening endpoints are not allowed as well.
    // We do not support sending data with TDI buffering transports too.
    //

    if ( endpoint->Type != AfdBlockTypeEndpoint ||
            endpoint->State != AfdEndpointStateBound ||
            endpoint->Listening ||
            (IS_TDI_BUFFERRING (endpoint) && 
                IrpSp->Parameters.DeviceIoControl.OutputBufferLength!=0)) {
        if (endpoint->State==AfdEndpointStateConnected) {
            status = STATUS_CONNECTION_ACTIVE;
        }
        else {
            status = STATUS_INVALID_PARAMETER;
        }
        goto complete_state_change;
    }

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdSuperConnect: starting connect on endpoint %p\n",
                    endpoint ));
    }


    //
    // Create a connection object to use for the connect operation.
    //

    status = AfdCreateConnection(
                 &endpoint->TransportInfo->TransportDeviceName,
                 endpoint->AddressHandle,
                 IS_TDI_BUFFERRING(endpoint),
                 endpoint->InLine,
                 endpoint->OwningProcess,
                 &connection
                 );

    if ( !NT_SUCCESS(status) ) {
        goto complete_state_change;
    }

    //
    // Set up a referenced pointer from the connection to the endpoint.
    // Note that we set up the connection's pointer to the endpoint
    // BEFORE the endpoint's pointer to the connection so that AfdPoll
    // doesn't try to back reference the endpoint from the connection.
    //

    REFERENCE_ENDPOINT( endpoint );
    connection->Endpoint = endpoint;

    //
    // Remember that this is now a connecting type of endpoint, and set
    // up a pointer to the connection in the endpoint.  This is
    // implicitly a referenced pointer.
    //

    endpoint->Common.VcConnecting.Connection = connection;
    endpoint->Type = AfdBlockTypeVcConnecting;

    ASSERT( IS_TDI_BUFFERRING(endpoint) == connection->TdiBufferring );

    //
    // Add an additional reference to the connection.  This prevents the
    // connection from being closed until the disconnect event handler
    // is called.
    //

    AfdAddConnectedReference( connection );

    //
    // Since we may be reissuing a connect after a previous failed connect,
    // reenable the failed connect event bit.
    //

    AfdEnableFailedConnectEvent( endpoint );


    //
    // Copy remote address to the user mode context
    //
    context = AfdLockEndpointContext (endpoint);
    if ( (((CLONG)(endpoint->Common.VcConnecting.RemoteSocketAddressOffset+
                endpoint->Common.VcConnecting.RemoteSocketAddressLength)) <
                endpoint->ContextLength) &&
            (endpoint->Common.VcConnecting.RemoteSocketAddressLength >=
                remoteAddress->Address[0].AddressLength +
                                          sizeof(u_short))) {

        RtlMoveMemory ((PUCHAR)context +
                            endpoint->Common.VcConnecting.RemoteSocketAddressOffset,
            &remoteAddress->Address[0].AddressType,
            remoteAddress->Address[0].AddressLength +
                                          sizeof(u_short));
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdSuperConnect: Could not copy remote address for AcceptEx on endpoint: %p, process: %p\n",
                    endpoint, endpoint->OwningProcess));
    }
    AfdUnlockEndpointContext (endpoint, context);
    //
    // Reference the connection block so it does not go away even if
    // endpoint's reference to it is removed (in cleanup)
    //

    REFERENCE_CONNECTION (connection);

    //
    // If there are connect data buffers, move them from the endpoint
    // structure to the connection structure and set up the necessary
    // pointers in the connection request we're going to give to the TDI
    // provider.  Do this in a subroutine so this routine can be pageable.
    //

    requestConnectionInfo = &afdBuffer->TdiInfo;
    afdBuffer->TdiInfo.UserDataLength = 0;
    afdBuffer->TdiInfo.UserData = NULL;
    afdBuffer->TdiInfo.OptionsLength = 0;
    afdBuffer->TdiInfo.Options = NULL;
    //
    // Temporarily use IRP embedded in afd buffer
    // for return connection information.
    //
    {
        C_ASSERT (sizeof (TDI_CONNECTION_INFORMATION)<=
                    sizeof (IO_STACK_LOCATION));
    }
    returnConnectionInfo = 
        (PTDI_CONNECTION_INFORMATION)IoGetNextIrpStackLocation (afdBuffer->Irp);
    RtlZeroMemory (returnConnectionInfo, sizeof (*returnConnectionInfo));

    if ( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
        AfdSetupConnectDataBuffers(
            endpoint,
            connection,
            &requestConnectionInfo,
            &returnConnectionInfo
            );
    }

    afdBuffer->Context = connection;

    //
    // Build a TDI kernel-mode connect request in the next stack location
    // of the IRP.
    //

    TdiBuildConnect(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartSuperConnect,
        afdBuffer,
        &AfdInfiniteTimeout,
        requestConnectionInfo,
        returnConnectionInfo
        );



    AFD_VERIFY_ADDRESS (connection, afdBuffer->TdiInfo.RemoteAddress);

    ObReferenceObject (IrpSp->FileObject);
    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete_state_change:
    AFD_END_STATE_CHANGE (endpoint);

complete:

    if (afdBuffer!=NULL) {
        AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdSuperConnect

NTSTATUS
AfdRestartSuperConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles the IOCTL_AFD_CONNECT IOCTL.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION irpSp;
    PAFD_BUFFER afdBuffer;

    afdBuffer = Context;
    connection = afdBuffer->Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    endpoint = irpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
    ASSERT( endpoint==connection->Endpoint );

    IF_DEBUG(CONNECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartConnect: connect completed, status = %X, endpoint = %p\n",
                    Irp->IoStatus.Status, endpoint ));
    }


    if ( connection->ConnectDataBuffers != NULL ) {

        //
        // If there are connect buffers on this endpoint, remember the
        // size of the return connect data.
        //

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Double-check under the lock
        //

        if ( connection->ConnectDataBuffers != NULL ) {
            AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_DATA,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserData,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.UserDataLength
                         );

            AfdSaveReceivedConnectData(
                         &connection->ConnectDataBuffers,
                         IOCTL_AFD_SET_CONNECT_OPTIONS,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.Options,
                         connection->ConnectDataBuffers->ReturnConnectionInfo.OptionsLength
                         );
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // Indicate that the connect completed.  Implicitly, the successful
    // completion of a connect also means that the caller can do a send
    // on the socket.
    //

    if ( NT_SUCCESS(Irp->IoStatus.Status)) {


        //
        // If the request succeeded, set the endpoint to the connected
        // state.  The endpoint type has already been set to
        // AfdBlockTypeVcConnecting.
        //

        endpoint->State = AfdEndpointStateConnected;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );

        //
        // Remember the time that the connection started.
        //

        connection->ConnectTime = KeQueryInterruptTime();

    } else {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // The connect failed, so reset the type to open.
        // Otherwise, we won't be able to start another connect
        //


        endpoint->Type = AfdBlockTypeEndpoint;

        if (endpoint->Common.VcConnecting.Connection!=NULL) {
            ASSERT (connection==endpoint->Common.VcConnecting.Connection);
            endpoint->Common.VcConnecting.Connection = NULL;

            //
            // Manually delete the connected reference if somebody else
            // hasn't already done so.  We can't use
            // AfdDeleteConnectedReference() because it refuses to delete
            // the connected reference until the endpoint has been cleaned
            // up.
            //

            if ( connection->ConnectedReferenceAdded ) {
                connection->ConnectedReferenceAdded = FALSE;
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_CONNECTION( connection );
            } else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            //
            // Dereference the connection block stored on the endpoint.
            // This should cause the connection object reference count to go
            // to zero to the connection object can be deleted.
            //
            DEREFERENCE_CONNECTION( connection );
        }
        else {
            //
            // The endpoint's reference to connection was removed
            // (perhaps in cleanup);
            //
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        }


    }

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    AfdCompleteOutstandingIrp( endpoint, Irp );

    AfdFinishConnect (endpoint, Irp, NULL);

    if (NT_SUCCESS (Irp->IoStatus.Status) && afdBuffer->DataLength>0) {
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        if ( !connection->CleanupBegun && !connection->AbortIndicated ) {
            NTSTATUS status;
            //
            // Update count of send bytes pending on the connection.
            //

            connection->VcBufferredSendBytes += afdBuffer->DataLength;
            connection->VcBufferredSendCount += 1;
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

            afdBuffer->Mdl->ByteCount = afdBuffer->DataLength;
            ASSERT (afdBuffer->Context == connection );

            TdiBuildSend(
                afdBuffer->Irp,
                connection->DeviceObject,
                connection->FileObject,
                AfdRestartBufferSend,
                afdBuffer,
                afdBuffer->Mdl,
                0,
                afdBuffer->DataLength
                );

            Irp->IoStatus.Information = afdBuffer->DataLength;


            //
            // Call the transport to actually perform the send.
            //

            status = IoCallDriver(
                         connection->DeviceObject,
                         afdBuffer->Irp
                         );
            if (!NT_SUCCESS (status)) {
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
            }

            goto exit;
        }
        if (connection->CleanupBegun) {
            Irp->IoStatus.Status = STATUS_LOCAL_DISCONNECT;
        }
        else {
            ASSERT (connection->AbortIndicated);
            Irp->IoStatus.Status = STATUS_REMOTE_DISCONNECT;
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    afdBuffer->DataOffset = 0;
    AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
    //
    // Dereference connection to account for reference we added in AfdConnect
    //
    DEREFERENCE_CONNECTION (connection);

exit:
    return STATUS_SUCCESS;

} // AfdRestartSuperConnect
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\eventsel.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventsel.c

Abstract:

    This module contains routines for supporting the WinSock 2.0
    WSAEventSelect() and WSAEnumNetworkEvents() APIs.

Author:

    Keith Moore (keithmo)        02-Aug-1995

Revision History:

--*/

#include "afdp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdEventSelect )
#pragma alloc_text( PAGEAFD, AfdEnumNetworkEvents )
#endif



NTSTATUS
AfdEventSelect (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )

/*++

Routine Description:

    Associates an event object with the socket such that the event object
    will be signalled when any of the specified network events becomes
    active.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the APC was successfully queued.

--*/

{

    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PKEVENT eventObject;
    ULONG eventMask;
    AFD_EVENT_SELECT_INFO eventInfo;
    ULONG previousRecord = 0;
    BOOLEAN countsUpdated = FALSE;


    *Information = 0;
    status = STATUS_SUCCESS;

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {

            PAFD_EVENT_SELECT_INFO32 eventInfo32 = InputBuffer;

            if( InputBufferLength < sizeof(*eventInfo32)) {
                return STATUS_INVALID_PARAMETER;
            }
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (*eventInfo32),
                                PROBE_ALIGNMENT32(AFD_EVENT_SELECT_INFO32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            eventInfo.Event = eventInfo32->Event;
            eventInfo.PollEvents = eventInfo32->PollEvents;
        }
        else
#endif
        {

            if(InputBufferLength < sizeof(eventInfo)) {
                return STATUS_INVALID_PARAMETER;
            }

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (eventInfo),
                                PROBE_ALIGNMENT(AFD_EVENT_SELECT_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            eventInfo = *((PAFD_EVENT_SELECT_INFO)InputBuffer);
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    if ( eventInfo.Event == NULL &&
            eventInfo.PollEvents != 0 )  {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Grab the endpoint from the socket handle.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Reference the target event object.
    //


    eventObject = NULL;

    if( eventInfo.Event != NULL ) {

        status = AfdReferenceEventObjectByHandle(
                     eventInfo.Event,
                     RequestorMode,
                     (PVOID *)&eventObject
                     );

        if( !NT_SUCCESS(status) ) {
            return status;
        }

        ASSERT( eventObject != NULL );

        if (IS_SAN_ENDPOINT (endpoint)) {
            //
            // Inform the switch that select is active on this endpoint.
            //
            status = AfdSanPollBegin (endpoint, eventInfo.PollEvents);

            if (!NT_SUCCESS (status)) {
                ObDereferenceObject (eventObject);
                return status;
            }
            countsUpdated = TRUE;
        }

    }

    //
    // Acquire the spinlock protecting the endpoint.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If this endpoint has an active EventSelect, dereference the
    // associated event object.
    //

    if( endpoint->EventObject != NULL ) {

        ObDereferenceObject( endpoint->EventObject );

        if (IS_SAN_ENDPOINT (endpoint)) {
            previousRecord = endpoint->EventsEnabled;
        }

    }

    //
    // Fill in the info.
    //

    endpoint->EventObject = eventObject;
    endpoint->EventsEnabled = eventInfo.PollEvents;

    if (countsUpdated) {
        endpoint->EventsEnabled |= AFD_POLL_SANCOUNTS_UPDATED;
        //
		// AfdSanPollBegin puts latest events into 
		// Endpoint->Common.SanEndp.SelectEventsActive. This is fine for
		// select/AsyncSelect, but not for EventSelect. So, if being called
		// for the first time, then read current active events from there.
		//
		if (!(previousRecord & AFD_POLL_SANCOUNTS_UPDATED)) {
		    endpoint->EventsActive = endpoint->Common.SanEndp.SelectEventsActive;
		}
    }

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdEventSelect: Endpoint-%p, eventOb-%p, enabled-%lx, active-%lx\n",
                    endpoint,
                    eventObject,
                    endpoint->EventsEnabled,
                    endpoint->EventsActive
                    ));
    }

    //
    // While we've got the spinlock held, determine if any conditions
    // are met, and if so, signal the event object.
    //

    eventMask = endpoint->EventsActive & endpoint->EventsEnabled;

    if( eventMask != 0 && eventObject != NULL ) {

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdEventSelect: Setting event %p\n",
                eventObject
                ));
        }

        KeSetEvent(
            eventObject,
            AfdPriorityBoost,
            FALSE
            );

    }

    //
    // Release the spin lock and return.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (previousRecord & AFD_POLL_SANCOUNTS_UPDATED) {
        AfdSanPollEnd (endpoint, previousRecord);
    }

    return STATUS_SUCCESS;

} // AfdEventSelect


NTSTATUS
AfdEnumNetworkEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )

/*++

Routine Description:

    Retrieves event select information from the socket.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the APC was successfully queued.

--*/

{

    NTSTATUS status;
    PAFD_ENDPOINT endpoint;
    AFD_ENUM_NETWORK_EVENTS_INFO eventInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PKEVENT eventObject;
    ULONG pollEvents;

    status = STATUS_SUCCESS;
    *Information = 0;

    //
    // Validate the parameters.
    //

    if(OutputBufferLength < sizeof(eventInfo) ) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Reference the target event object.
    //

    eventObject = NULL;

    if( InputBuffer != NULL ) {

        status = AfdReferenceEventObjectByHandle(
                     InputBuffer,
                     RequestorMode,
                     (PVOID *)&eventObject
                     );

        if( !NT_SUCCESS(status) ) {

            return status;

        }

        ASSERT( eventObject != NULL );

    }

    //
    // Grab the endpoint from the socket handle.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Acquire the spinlock protecting the endpoint.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdEnumNetworkEvents: endp-%p, eventobj-%p, enabled-%lx, active-%lx\n",
            endpoint,
            eventObject,
            endpoint->EventsEnabled,
            endpoint->EventsActive
            ));
    }

    //
    // Copy the data to the user's structure.
    //

    pollEvents = endpoint->EventsActive & endpoint->EventsEnabled;
    eventInfo.PollEvents = pollEvents;

    RtlCopyMemory(
        eventInfo.EventStatus,
        endpoint->EventStatus,
        sizeof(eventInfo.EventStatus)
        );

    //
    // If there was an event object handle passed in with this
    // request, reset and dereference it.
    //

    if( eventObject != NULL ) {

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdEnumNetworkEvents: Resetting event %p\n",
                eventObject
                ));
        }

        KeResetEvent( eventObject );
        ObDereferenceObject( eventObject );

    }


    //
    // Reset internal event record for all the events that
    // we could potentially report to the application
    //

    endpoint->EventsActive &= ~(endpoint->EventsEnabled);

    //
    // Release the spin lock and return.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    try {
        //
        // Validate the output structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForWrite (OutputBuffer,
                            sizeof (eventInfo),
                            PROBE_ALIGNMENT (AFD_ENUM_NETWORK_EVENTS_INFO));
        }

        //
        // Copy parameters back to application's memory
        //

        *((PAFD_ENUM_NETWORK_EVENTS_INFO)OutputBuffer) = eventInfo;

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        return status;
    }

    //
    // Before returning, tell the I/O subsystem how may bytes to copy
    // to the user's output buffer.
    //

    *Information = sizeof(eventInfo);

    return STATUS_SUCCESS;

} // AfdEnumNetworkEvents


VOID
AfdIndicateEventSelectEvent (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    )
{
    ULONG oldEventsActive;
    ULONG eventBit;

    //
    // Sanity check.
    //

    ASSERT( IS_AFD_ENDPOINT_TYPE( Endpoint ) );
    ASSERT (PollEventMask!=0);
    ASSERT (((~((1<<AFD_NUM_POLL_EVENTS)-1)) & PollEventMask)==0);
    ASSERT( KeGetCurrentIrql() >= DISPATCH_LEVEL );

    //
    // Note that AFD_POLL_ABORT implies AFD_POLL_SEND.
    //
    if( PollEventMask & AFD_POLL_ABORT ) {
        PollEventMask |= AFD_POLL_SEND;
    }

    //
    // Special handling of send event. Don't record if not enabled
    // and disable further indication upon recording (it is only enabled
    // after we fail non-blocking send
    //

	//
	// Update the counts for the polls that were issued before
	// the endpoint was converted to SAN.
	//
	if ( IS_SAN_ENDPOINT (Endpoint) && 
            !(Endpoint->EventsEnabled & AFD_POLL_SANCOUNTS_UPDATED) &&
			Endpoint->Common.SanEndp.LocalContext!=NULL) {
		AfdSanPollUpdate (Endpoint, Endpoint->EventsEnabled);
		Endpoint->EventsEnabled |= AFD_POLL_SANCOUNTS_UPDATED;
	}

    if (PollEventMask&AFD_POLL_SEND) {
        if (Endpoint->EnableSendEvent) {
            Endpoint ->EnableSendEvent = FALSE;
        }
        else {
            PollEventMask &= (~AFD_POLL_SEND);
            if (PollEventMask==0) {
                return;
            }
        }
    }

    //
    // Calculate the actual event bit.
    //

    oldEventsActive = Endpoint->EventsActive;
    Endpoint->EventsActive |= PollEventMask;
    for (eventBit=0; eventBit<AFD_NUM_POLL_EVENTS; eventBit++) {
        if ((1<<eventBit) & PollEventMask) {
            Endpoint->EventStatus[eventBit] = Status;
        }
    }

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdIndicateEventSelectEvent: endp-%p, eventobj-%p, enabled-%lx, active-%lx, indicated-%lx\n",
            Endpoint,
            Endpoint->EventObject,
            Endpoint->EventsEnabled,
            Endpoint->EventsActive,
            PollEventMask
            ));
    }

    //
    // Only signal the endpoint's event object if the current event
    // is enabled, AND the current event was not already active, AND
    // there is an event object associated with this endpoint.
    //

    PollEventMask &= Endpoint->EventsEnabled & ~oldEventsActive;

    if( PollEventMask != 0 && Endpoint->EventObject != NULL ) {

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdIndicateEventSelectEvent: Setting event %p\n",
                Endpoint->EventObject
                ));
        }

        KeSetEvent(
            Endpoint->EventObject,
            AfdPriorityBoost,
            FALSE
            );

    }

} // AfdIndicateEventSelectEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\fastio.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fastio.c

Abstract:

    This module contains routines for handling fast ("turbo") IO
    in AFD.

Author:

    David Treadwell (davidtr)    12-Oct-1992

Revision History:
    VadimE  14-Jan-1998 Restructurred the code.

--*/

#include "afdp.h"


BOOLEAN
AfdFastConnectionReceive (
    IN PAFD_ENDPOINT        endpoint,
    IN PAFD_RECV_INFO       recvInfo,
    IN ULONG                recvLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    );

BOOLEAN
AfdFastDatagramReceive (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_RECV_MESSAGE_INFO   recvInfo,
    IN ULONG                    recvLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    );

BOOLEAN
AfdFastConnectionSend (
    IN PAFD_ENDPOINT        endpoint,
    IN PAFD_SEND_INFO       sendInfo,
    IN ULONG                sendLength,
    OUT PIO_STATUS_BLOCK    IoStatus
    );

BOOLEAN
AfdFastDatagramSend (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_SEND_DATAGRAM_INFO  sendInfo,
    IN ULONG                    sendLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    );

NTSTATUS
AfdRestartFastDatagramSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdFastIoDeviceControl )
#pragma alloc_text( PAGE, AfdFastIoRead )
#pragma alloc_text( PAGE, AfdFastIoWrite )
#pragma alloc_text( PAGEAFD, AfdFastDatagramSend )
#pragma alloc_text( PAGEAFD, AfdFastDatagramReceive )
#pragma alloc_text( PAGEAFD, AfdFastConnectionSend )
#pragma alloc_text( PAGEAFD, AfdFastConnectionReceive )
#pragma alloc_text( PAGEAFD, AfdRestartFastDatagramSend )
#pragma alloc_text( PAGEAFD, AfdShouldSendBlock )
#endif


#if AFD_PERF_DBG
BOOLEAN
AfdFastIoReadReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    BOOLEAN success;

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    success = AfdFastIoReadReal (
                FileObject,
                FileOffset,
                Length,
                Wait,
                LockKey,
                Buffer,
                IoStatus,
                DeviceObject
                );

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );
    if ( success ) {
        InterlockedIncrement (&AfdFastReadsSucceeded);
        ASSERT (IoStatus->Status == STATUS_SUCCESS ||
                    IoStatus->Status == STATUS_DEVICE_NOT_READY );
    } else {
        InterlockedIncrement (&AfdFastReadsFailed);
    }
    return success;
}

BOOLEAN
AfdFastIoReadReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

#else // AFD_PERF_DBG

BOOLEAN
AfdFastIoRead (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#endif  // AFD_PERF_DBG
{

    PAFD_ENDPOINT   endpoint;
    WSABUF          buf;

    PAGED_CODE( );

    //
    // All we want to do is pass the request through to the TDI provider
    // if possible.  If not, we want to bail out of this code path back
    // onto the main code path (with IRPs) with as little performance
    // overhead as possible.
    //
    // Thus this routine only does general preliminary checks and input
    // parameter validation. If it is determined that fast io path is
    // likely to succeed, an operation specific routine is called
    // to handle all the details.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );


    //
    // If fast IO recv is disabled
    //      or the endpoint is shut down in any way
    //      or the endpoint isn't connected yet
    //      or the TDI provider for this endpoint supports bufferring,
    // we do not want to do fast IO on it
    //
    if (endpoint->DisableFastIoRecv ||
            endpoint->DisconnectMode != 0 ||
            endpoint->State != AfdEndpointStateConnected ||
            IS_TDI_BUFFERRING(endpoint)) {
        return FALSE;
    }

    //
    // Fake buffer array.
    //

    buf.buf = Buffer;
    buf.len = Length;

    //
    // Call routine based on endpoint type
    //
    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        //
        // Fake input parameter strucuture
        //
        AFD_RECV_MESSAGE_INFO  msgInfo;

        msgInfo.dgi.BufferArray = &buf;
        msgInfo.dgi.BufferCount = 1;
        msgInfo.dgi.AfdFlags = AFD_OVERLAPPED;
        msgInfo.dgi.TdiFlags = TDI_RECEIVE_NORMAL;
        msgInfo.dgi.Address = NULL;
        msgInfo.dgi.AddressLength = 0;
        msgInfo.ControlBuffer = NULL;
        msgInfo.ControlLength = NULL;
        msgInfo.MsgFlags = NULL;

        return AfdFastDatagramReceive(
                   endpoint,
                   &msgInfo,
                   Length,
                   IoStatus
                   );
    }
    else if (IS_VC_ENDPOINT(endpoint)) {
        //
        // Fake input parameter strucuture
        //
        AFD_RECV_INFO  recvInfo;

        recvInfo.BufferArray = &buf;
        recvInfo.BufferCount = 1;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;

        return AfdFastConnectionReceive (
                    endpoint,
                    &recvInfo,
                    Length,
                    IoStatus);
    }
    else
        return FALSE;

} // AfdFastIoRead

#if AFD_PERF_DBG
BOOLEAN
AfdFastIoWriteReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
AfdFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    BOOLEAN success;

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    success = AfdFastIoWriteReal (
                    FileObject,
                    FileOffset,
                    Length,
                    Wait,
                    LockKey,
                    Buffer,
                    IoStatus,
                    DeviceObject
                    );

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );
    if ( success ) {
        InterlockedIncrement (&AfdFastWritesSucceeded);
        ASSERT (IoStatus->Status == STATUS_SUCCESS ||
                    IoStatus->Status == STATUS_DEVICE_NOT_READY);
    } else {
        InterlockedIncrement (&AfdFastWritesFailed);
    }
    return success;
}

BOOLEAN
AfdFastIoWriteReal (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )

#else // AFD_PERF_DBG

BOOLEAN
AfdFastIoWrite (
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#endif  // AFD_PERF_DBG
{


    PAFD_ENDPOINT   endpoint;
    WSABUF          buf;

    PAGED_CODE( );

    //
    // All we want to do is pass the request through to the TDI provider
    // if possible.  If not, we want to bail out of this code path back
    // onto the main code path (with IRPs) with as little performance
    // overhead as possible.
    //
    // Thus this routine only does general preliminary checks and input
    // parameter validation. If it is determined that fast io path is
    // likely to succeed, an operation specific routine is called
    // to handle all the details.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );


    //
    // If fast IO send is disabled
    //      or the endpoint is shut down in any way
    //      or the endpoint isn't connected yet
    //      or the TDI provider for this endpoint supports bufferring,
    // we do not want to do fast IO on it
    //
    if (endpoint->DisableFastIoSend ||
            endpoint->DisconnectMode != 0 ||
            endpoint->State != AfdEndpointStateConnected ||
            IS_TDI_BUFFERRING(endpoint) ) {
        return FALSE;
    }

    //
    // Fake buffer array.
    //
    buf.buf = Buffer;
    buf.len = Length;

    //
    // Call routine based on endpoint type
    //
    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        //
        // Fake input parameter strucuture
        //
        AFD_SEND_DATAGRAM_INFO  sendInfo;

        sendInfo.BufferArray = &buf;
        sendInfo.BufferCount = 1;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiConnInfo.RemoteAddress = NULL;
        sendInfo.TdiConnInfo.RemoteAddressLength = 0;

        return AfdFastDatagramSend(
                   endpoint,
                   &sendInfo,
                   Length,
                   IoStatus
                   );
    }
    else if (IS_VC_ENDPOINT (endpoint)) {
        //
        // Fake input parameter strucuture
        //
        AFD_SEND_INFO  sendInfo;

        sendInfo.BufferArray = &buf;
        sendInfo.BufferCount = 1;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        return AfdFastConnectionSend (
                    endpoint,
                    &sendInfo,
                    Length,
                    IoStatus);
    }
    else
        return FALSE;
} // AfdFastIoWrite

#if AFD_PERF_DBG

BOOLEAN
AfdFastIoDeviceControlReal (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );


BOOLEAN
AfdFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
{
    BOOLEAN success;

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    success = AfdFastIoDeviceControlReal (
                  FileObject,
                  Wait,
                  InputBuffer,
                  InputBufferLength,
                  OutputBuffer,
                  OutputBufferLength,
                  IoControlCode,
                  IoStatus,
                  DeviceObject
                  );

    ASSERT( KeGetCurrentIrql( ) == LOW_LEVEL );

    switch ( IoControlCode ) {

    case IOCTL_AFD_SEND:

        if ( success ) {
            InterlockedIncrement (&AfdFastSendsSucceeded);
        } else {
            InterlockedIncrement (&AfdFastSendsFailed);
        }
        break;

    case IOCTL_AFD_RECEIVE:

        if ( success ) {
            InterlockedIncrement (&AfdFastReceivesSucceeded);
        } else {
            InterlockedIncrement (&AfdFastReceivesFailed);
        }
        break;

    case IOCTL_AFD_SEND_DATAGRAM:

        if ( success ) {
            InterlockedIncrement (&AfdFastSendDatagramsSucceeded);
        } else {
            InterlockedIncrement (&AfdFastSendDatagramsFailed);
        }
        break;

    case IOCTL_AFD_RECEIVE_MESSAGE:
    case IOCTL_AFD_RECEIVE_DATAGRAM:

        if ( success ) {
            InterlockedIncrement (&AfdFastReceiveDatagramsSucceeded);
        } else {
            InterlockedIncrement (&AfdFastReceiveDatagramsFailed);
        }
        break;
    case IOCTL_AFD_TRANSMIT_FILE:

        if ( success ) {
            InterlockedIncrement (&AfdFastTfSucceeded);
        } else {
            InterlockedIncrement (&AfdFastTfFailed);
        }
        break;
    }


    return success;

} // AfdFastIoDeviceControl


BOOLEAN
AfdFastIoDeviceControlReal (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#else
BOOLEAN
AfdFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
#endif
{   
    PAFD_ENDPOINT   endpoint;
    KPROCESSOR_MODE previousMode;
    BOOLEAN         res;
    PAFD_IMMEDIATE_CALL proc;
    ULONG       request;

#ifdef _WIN64
    WSABUF          localArray[8];
    LPWSABUF        pArray = localArray;
#endif

    PAGED_CODE( );

    //
    // All we want to do is pass the request through to the TDI provider
    // if possible.  If not, we want to bail out of this code path back
    // onto the main code path (with IRPs) with as little performance
    // overhead as possible.
    //
    // Thus this routine only does general preliminary checks and input
    // parameter validation. If it is determined that fast io path is
    // likely to succeed, an operation specific routine is called
    // to handle all the details.
    //

    //
    // First get the endpoint pointer and previous mode for input parameter 
    // validation.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    previousMode = ExGetPreviousMode ();

    //
    // Switch based on control code
    //
    switch (IoControlCode) {
    case IOCTL_AFD_RECEIVE: 
        {
            union {
                AFD_RECV_INFO           recvInfo;
                AFD_RECV_MESSAGE_INFO   msgInfo;
            } u;
            ULONG   recvLength;

#if !defined (_ALPHA_)
//
// Alpha compiler does not see that the following FIELD_OFFSET
// is in fact a constant expression.
//
            //
            // Check the validity of the union above.
            //
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.BufferArray)
                        == FIELD_OFFSET (AFD_RECV_INFO, BufferArray));
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.BufferCount)
                        == FIELD_OFFSET (AFD_RECV_INFO, BufferCount));
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.AfdFlags)
                        == FIELD_OFFSET (AFD_RECV_INFO, AfdFlags));
            C_ASSERT (FIELD_OFFSET (AFD_RECV_MESSAGE_INFO, dgi.TdiFlags)
                        == FIELD_OFFSET (AFD_RECV_INFO, TdiFlags));

            //
#endif //!defined (_ALPHA_)
            //
            // If fast IO send is disabled
            //      or the endpoint is shut down in any way
            //      or the endpoint isn't connected yet
            //      or the TDI provider for this endpoint supports bufferring,
            // we do not want to do fast IO on it
            //
            if (endpoint->DisableFastIoRecv ||
                    endpoint->DisconnectMode != 0 ||
                    endpoint->State != AfdEndpointStateConnected ||
                    IS_TDI_BUFFERRING(endpoint) ) {
                res = FALSE;
                break;
            }

            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_RECV_INFO32    recvInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*recvInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (*recvInfo32),
                                        PROBE_ALIGNMENT32(AFD_RECV_INFO32));
                    }

                    recvInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = recvInfo32->BufferArray;
                    u.recvInfo.BufferCount = recvInfo32->BufferCount;
                    u.recvInfo.AfdFlags = recvInfo32->AfdFlags;
                    u.recvInfo.TdiFlags = recvInfo32->TdiFlags;

                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (u.recvInfo.AfdFlags & AFD_NO_FAST_IO) ||
                        u.recvInfo.TdiFlags != TDI_RECEIVE_NORMAL ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (u.recvInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.recvInfo.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.recvInfo.BufferCount * sizeof (WSABUF32), // Length
                            PROBE_ALIGNMENT32(WSABUF32)             // Alignment
                            );
                    }

                    if (u.recvInfo.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*u.recvInfo.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<u.recvInfo.BufferCount; i++) {
                        pArray[i].buf = tempArray[i].buf;
                        pArray[i].len = tempArray[i].len;
                    }

                    u.recvInfo.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(u.recvInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (u.recvInfo),
                                        PROBE_ALIGNMENT(AFD_RECV_INFO));
                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    u.recvInfo = *((PAFD_RECV_INFO)InputBuffer);
                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (u.recvInfo.AfdFlags & AFD_NO_FAST_IO) ||
                        u.recvInfo.TdiFlags != TDI_RECEIVE_NORMAL ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((u.recvInfo.BufferArray == NULL) ||
                            (u.recvInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.recvInfo.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            u.recvInfo.BufferArray,                     // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.recvInfo.BufferCount * sizeof (WSABUF),   // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }
                }

                recvLength = AfdCalcBufferArrayByteLength(
                                     u.recvInfo.BufferArray,
                                     u.recvInfo.BufferCount
                                     );

            } except( AFD_EXCEPTION_FILTER(NULL) ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;
            }

            //
            // Call routine based on endpoint type
            //
            if ( IS_DGRAM_ENDPOINT(endpoint) ) {
                u.msgInfo.dgi.Address = NULL;
                u.msgInfo.dgi.AddressLength = 0;
                u.msgInfo.ControlBuffer = NULL;
                u.msgInfo.ControlLength = NULL;
                u.msgInfo.MsgFlags = NULL;


                res = AfdFastDatagramReceive(
                           endpoint,
                           &u.msgInfo,
                           recvLength,
                           IoStatus
                           );
            }
            else if (IS_VC_ENDPOINT (endpoint)) {
                res = AfdFastConnectionReceive (
                            endpoint,
                            &u.recvInfo,
                            recvLength,
                            IoStatus);
            }
            else
                res = FALSE;

        }
        break;

    case IOCTL_AFD_RECEIVE_DATAGRAM:
    case IOCTL_AFD_RECEIVE_MESSAGE:
        {
            AFD_RECV_MESSAGE_INFO   msgInfo;
            ULONG   recvLength;

            if (endpoint->DisableFastIoRecv ||
                   !IS_DGRAM_ENDPOINT(endpoint) ||
                    ((endpoint->State != AfdEndpointStateBound ) &&
                        (endpoint->State != AfdEndpointStateConnected)) ) {
                return FALSE;
            }
            if (IoControlCode==IOCTL_AFD_RECEIVE_MESSAGE) {
#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_RECV_MESSAGE_INFO32    msgInfo32;
                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*msgInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (*msgInfo32),
                                        PROBE_ALIGNMENT32 (AFD_RECV_MESSAGE_INFO32));
                    }

                    msgInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    msgInfo.ControlBuffer = msgInfo32->ControlBuffer;
                    msgInfo.ControlLength = msgInfo32->ControlLength;
                    msgInfo.MsgFlags = msgInfo32->MsgFlags;
                }
                else
#endif // _WIN64
                {

                    if( InputBufferLength < sizeof(msgInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }

                    //
                    // Capture the input structure.
                    //


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (msgInfo),
                                        PROBE_ALIGNMENT (AFD_RECV_MESSAGE_INFO));
                    }
                    msgInfo = *(PAFD_RECV_MESSAGE_INFO)InputBuffer;
                }
                if (previousMode != KernelMode ) {

                    ProbeForWrite (msgInfo.MsgFlags,
                                    sizeof (*msgInfo.MsgFlags),
                                    PROBE_ALIGNMENT (ULONG));
                    ProbeForWrite (msgInfo.ControlLength,
                                    sizeof (*msgInfo.ControlLength),
                                    PROBE_ALIGNMENT (ULONG));
                    //
                    // Checking of recvInfo->Address is postponed till
                    // we know the length of the address.
                    //

                }
            }
            else 
            {
                msgInfo.ControlBuffer = NULL;
                msgInfo.ControlLength = NULL;
                msgInfo.MsgFlags = NULL;
            }

            //
            // If the input structure isn't large enough, return error.
            //

            try {
#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_RECV_DATAGRAM_INFO32    recvInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*recvInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (*recvInfo32),
                                        PROBE_ALIGNMENT32 (AFD_RECV_DATAGRAM_INFO32));
                    }

                    recvInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = recvInfo32->BufferArray;
                    msgInfo.dgi.BufferCount = recvInfo32->BufferCount;
                    msgInfo.dgi.AfdFlags = recvInfo32->AfdFlags;
                    msgInfo.dgi.TdiFlags = recvInfo32->TdiFlags;
                    msgInfo.dgi.Address = recvInfo32->Address;
                    msgInfo.dgi.AddressLength = recvInfo32->AddressLength;

                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (msgInfo.dgi.AfdFlags & AFD_NO_FAST_IO) ||
                        msgInfo.dgi.TdiFlags != TDI_RECEIVE_NORMAL ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (msgInfo.dgi.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (msgInfo.dgi.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            msgInfo.dgi.BufferCount * sizeof (WSABUF32), // Length
                            PROBE_ALIGNMENT (WSABUF32)                 // Alignment
                            );
                    }

                    if (msgInfo.dgi.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*msgInfo.dgi.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<msgInfo.dgi.BufferCount; i++) {
                        pArray[i].buf = tempArray[i].buf;
                        pArray[i].len = tempArray[i].len;
                    }

                    msgInfo.dgi.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    if( InputBufferLength < sizeof(AFD_RECV_DATAGRAM_INFO) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }

                    //
                    // Capture the input structure.
                    //


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (AFD_RECV_DATAGRAM_INFO),
                                        PROBE_ALIGNMENT (AFD_RECV_DATAGRAM_INFO));
                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    msgInfo.dgi = *(PAFD_RECV_DATAGRAM_INFO)InputBuffer;

                    //
                    // If fast IO is disabled or this is not a simple
                    // recv, fail
                    //

                    if( (msgInfo.dgi.AfdFlags & AFD_NO_FAST_IO) != 0 ||
                            msgInfo.dgi.TdiFlags != TDI_RECEIVE_NORMAL ||
                            ( (msgInfo.dgi.Address == NULL) ^ 
                                (msgInfo.dgi.AddressLength == NULL) ) ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us.
                    // and calculate total recv length.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((msgInfo.dgi.BufferArray == NULL) ||
                            (msgInfo.dgi.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (msgInfo.dgi.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            msgInfo.dgi.BufferArray,                       // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            msgInfo.dgi.BufferCount * sizeof (WSABUF),    // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }
                }

                recvLength = AfdCalcBufferArrayByteLength(
                                     msgInfo.dgi.BufferArray,
                                     msgInfo.dgi.BufferCount
                                     );

                if (previousMode != KernelMode ) {
                    if (msgInfo.dgi.AddressLength!=NULL) {
                        ProbeForWrite (msgInfo.dgi.AddressLength,
                                        sizeof (*msgInfo.dgi.AddressLength),
                                        PROBE_ALIGNMENT (ULONG));
                    }
                    //
                    // Checking of recvInfo->Address is postponed till
                    // we know the length of the address.
                    //

                }


            } except( AFD_EXCEPTION_FILTER(NULL) ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;

            }

            //
            // Attempt to perform fast IO on the endpoint.
            //

            res = AfdFastDatagramReceive(
                       endpoint,
                       &msgInfo,
                       recvLength,
                       IoStatus
                       );

        }
        break;

    case IOCTL_AFD_SEND:
        {
            union {
                AFD_SEND_INFO           sendInfo;
                AFD_SEND_DATAGRAM_INFO  sendInfoDg;
            } u;
            ULONG   sendLength;

            //
            // Check the validity of the union above.
            //
            C_ASSERT (FIELD_OFFSET (AFD_SEND_DATAGRAM_INFO, BufferArray)
                        == FIELD_OFFSET (AFD_SEND_INFO, BufferArray));
            C_ASSERT (FIELD_OFFSET (AFD_SEND_DATAGRAM_INFO, BufferCount)
                        == FIELD_OFFSET (AFD_SEND_INFO, BufferCount));
            C_ASSERT (FIELD_OFFSET (AFD_SEND_DATAGRAM_INFO, AfdFlags)
                        == FIELD_OFFSET (AFD_SEND_INFO, AfdFlags));

            //
            // If fast IO send is disabled
            //      or the endpoint is shut down in any way
            //      or the endpoint isn't connected yet
            //      or the TDI provider for this endpoint supports bufferring,
            // we do not want to do fast IO on it
            //
            if (endpoint->DisableFastIoSend ||
                    endpoint->DisconnectMode != 0 ||
                    endpoint->State != AfdEndpointStateConnected ||
                    IS_TDI_BUFFERRING(endpoint) ) {
                return FALSE;
            }



            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_SEND_INFO32    sendInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*sendInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (*sendInfo32),
                                        PROBE_ALIGNMENT32 (AFD_SEND_INFO32));
                    }

                    sendInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = sendInfo32->BufferArray;
                    u.sendInfo.BufferCount = sendInfo32->BufferCount;
                    u.sendInfo.AfdFlags = sendInfo32->AfdFlags;
                    u.sendInfo.TdiFlags = sendInfo32->TdiFlags;

                    //
                    // If fast IO is not possible or this is not a normal receive.
                    // bail.
                    //
                    if( (u.sendInfo.AfdFlags & AFD_NO_FAST_IO) ||
                        u.sendInfo.TdiFlags != 0 ) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (u.sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.sendInfo.BufferCount * sizeof (WSABUF32),   // Length
                            PROBE_ALIGNMENT32(WSABUF32)                     // Alignment
                            );
                    }

                    if (u.sendInfo.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*u.sendInfo.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<u.sendInfo.BufferCount; i++) {
                        pArray[i].buf = tempArray[i].buf;
                        pArray[i].len = tempArray[i].len;
                    }

                    u.sendInfo.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(u.sendInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode) {
                        ProbeForRead (InputBuffer,
                                sizeof (u.sendInfo),
                                PROBE_ALIGNMENT(AFD_SEND_INFO));
                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    u.sendInfo = *((PAFD_SEND_INFO)InputBuffer);

                    if( (u.sendInfo.AfdFlags & AFD_NO_FAST_IO) != 0 ||
                            u.sendInfo.TdiFlags != 0 ) {
                        res = FALSE;
                        break;
                    }

                    if ((u.sendInfo.BufferArray == NULL) ||
                            (u.sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (u.sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            u.sendInfo.BufferArray,                     // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            u.sendInfo.BufferCount * sizeof (WSABUF),   // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }

                }
                sendLength = AfdCalcBufferArrayByteLength(
                                     u.sendInfo.BufferArray,
                                     u.sendInfo.BufferCount
                                     );

            } except( AFD_EXCEPTION_FILTER(NULL) ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;
            }

            if (IS_DGRAM_ENDPOINT (endpoint)) {
                u.sendInfoDg.TdiConnInfo.RemoteAddress = NULL;
                u.sendInfoDg.TdiConnInfo.RemoteAddressLength = 0;
                res = AfdFastDatagramSend (
                            endpoint, 
                            &u.sendInfoDg, 
                            sendLength,
                            IoStatus);
            }
            else if (IS_VC_ENDPOINT (endpoint)) {
                res = AfdFastConnectionSend (
                            endpoint, 
                            &u.sendInfo,
                            sendLength,
                            IoStatus);
            }
            else
                res = FALSE;
        }

        break;
    case IOCTL_AFD_SEND_DATAGRAM:
        {
            AFD_SEND_DATAGRAM_INFO  sendInfo;
            ULONG   sendLength;


            if (endpoint->DisableFastIoSend ||
                    !IS_DGRAM_ENDPOINT(endpoint) ||
                    ((endpoint->State != AfdEndpointStateBound ) &&
                        (endpoint->State != AfdEndpointStateConnected)) ) {
                res = FALSE;
                break;
            }

            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_SEND_DATAGRAM_INFO32    sendInfo32;
                    LPWSABUF32          tempArray;
                    ULONG               i;
                    

                    //
                    // If the input structure isn't large enough, return error.
                    //

                    if( InputBufferLength < sizeof(*sendInfo32) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode ) {
                        ProbeForRead (InputBuffer,
                                        sizeof (*sendInfo32),
                                        PROBE_ALIGNMENT32(AFD_SEND_DATAGRAM_INFO32));
                    }

                    sendInfo32 = InputBuffer;


                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //
                    tempArray = sendInfo32->BufferArray;
                    sendInfo.BufferCount = sendInfo32->BufferCount;
                    sendInfo.AfdFlags = sendInfo32->AfdFlags;
                    sendInfo.TdiConnInfo.RemoteAddress = sendInfo32->TdiConnInfo.RemoteAddress;
                    sendInfo.TdiConnInfo.RemoteAddressLength = sendInfo32->TdiConnInfo.RemoteAddressLength;

                    //
                    // If fast IO is not possible bail.
                    //
                    if(sendInfo.AfdFlags & AFD_NO_FAST_IO) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us and
                    // calculate the length of the send buffer.
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((tempArray == NULL) ||
                            (sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF32))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            tempArray,                                  // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            sendInfo.BufferCount * sizeof (WSABUF32), // Length
                            PROBE_ALIGNMENT32(WSABUF32)           // Alignment
                            );
                    }

                    if (sendInfo.BufferCount>sizeof(localArray)/sizeof(localArray[0])) {
                        try {
                            pArray = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                            NonPagedPool,
                                            sizeof (WSABUF)*sendInfo.BufferCount,
                                            AFD_TEMPORARY_POOL_TAG);
                            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets 
                            // POOL_RAISE_IF_ALLOCATION_FAILURE flag
                            ASSERT (pArray!=NULL);
                        }
                        except (EXCEPTION_EXECUTE_HANDLER) {
                            // Fast io can't handle error returns
                            // if call is overlapped (completion port)
                            // IoStatus->Status = GetExceptionCode ();
                            pArray = localArray;
                            res = FALSE;
                            break;
                        }
                    }

                    for (i=0; i<sendInfo.BufferCount; i++) {
                        pArray[i].buf = tempArray[i].buf;
                        pArray[i].len = tempArray[i].len;
                    }

                    sendInfo.BufferArray = pArray;

                }
                else
#endif // _WIN64
                {
                    //
                    // If the input structure isn't large enough, bail on fast IO.
                    //

                    if( InputBufferLength < sizeof(sendInfo) ) {
                        // Fast io can't handle error returns
                        // if call is overlapped (completion port)
                        // IoStatus->Status = STATUS_INVALID_PARAMETER;
                        res = FALSE;
                        break;
                    }


                    //
                    // Validate the input structure if it comes from the user mode
                    // application
                    //

                    if (previousMode != KernelMode) {
                        ProbeForRead (InputBuffer,
                                sizeof (sendInfo),
                                PROBE_ALIGNMENT(AFD_SEND_DATAGRAM_INFO));

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    sendInfo = *((PAFD_SEND_DATAGRAM_INFO)InputBuffer);
                    //
                    // If fast IO is disabled, bail
                    //

                    if( (sendInfo.AfdFlags & AFD_NO_FAST_IO) != 0) {
                        res = FALSE;
                        break;
                    }

                    //
                    // Validate all the pointers that app gave to us
                    // and calculate total send length
                    // Buffers in the array will be validated in the
                    // process of copying
                    //

                    if ((sendInfo.BufferArray == NULL) ||
                            (sendInfo.BufferCount == 0) ||
                            // Check for integer overflow (disabled by compiler)
                            (sendInfo.BufferCount>(MAXULONG/sizeof (WSABUF))) ) {
                        ExRaiseStatus(STATUS_INVALID_PARAMETER);
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead(
                            sendInfo.BufferArray,                       // Address
                            // Note check for overflow above (should actually be
                            // done here by the compiler generating code
                            // that causes exception on integer overflow)
                            sendInfo.BufferCount * sizeof (WSABUF),     // Length
                            PROBE_ALIGNMENT(WSABUF)                     // Alignment
                            );
                    }
                }

                sendLength = AfdCalcBufferArrayByteLength(
                                 sendInfo.BufferArray,
                                 sendInfo.BufferCount
                                 );

                if (previousMode != KernelMode ) {
                    ProbeForRead (
                        sendInfo.TdiConnInfo.RemoteAddress,         // Address
                        sendInfo.TdiConnInfo.RemoteAddressLength,   // Length,
                        sizeof (UCHAR)                              // Aligment
                        );
                }

            } except( AFD_EXCEPTION_FILTER(NULL) ) {

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                res = FALSE;
                break;
            }
            //
            // Attempt to perform fast IO on the endpoint.
            //

            res = AfdFastDatagramSend(
                       endpoint,
                       &sendInfo,
                       sendLength,
                       IoStatus
                       );

        }

        break;

    case IOCTL_AFD_TRANSMIT_FILE:
        {

            AFD_TRANSMIT_FILE_INFO userTransmitInfo;
            try {

#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    PAFD_TRANSMIT_FILE_INFO32 userTransmitInfo32;
                    if ( InputBufferLength < sizeof(AFD_TRANSMIT_FILE_INFO32) ) {
                        return FALSE;
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead (InputBuffer,
                                        sizeof (*userTransmitInfo32),
                                        PROBE_ALIGNMENT32(AFD_TRANSMIT_FILE_INFO32));

                        userTransmitInfo32 = InputBuffer;
                        userTransmitInfo.Offset = userTransmitInfo32->Offset;
                        userTransmitInfo.WriteLength = userTransmitInfo32->WriteLength;
                        userTransmitInfo.SendPacketLength = userTransmitInfo32->SendPacketLength;
                        userTransmitInfo.FileHandle = userTransmitInfo32->FileHandle;
                        userTransmitInfo.Head = userTransmitInfo32->Head;
                        userTransmitInfo.HeadLength = userTransmitInfo32->HeadLength;
                        userTransmitInfo.Tail = userTransmitInfo32->Tail;
                        userTransmitInfo.TailLength = userTransmitInfo32->TailLength;
                        userTransmitInfo.Flags = userTransmitInfo32->Flags;


                        if (userTransmitInfo.HeadLength>0)
                            ProbeForRead (userTransmitInfo.Head,
                                            userTransmitInfo.HeadLength,
                                            sizeof (UCHAR));
                        if (userTransmitInfo.TailLength>0)
                            ProbeForRead (userTransmitInfo.Tail,
                                            userTransmitInfo.TailLength,
                                            sizeof (UCHAR));
                    }
                    else
                    {
                        ASSERT (FALSE);
                    }

                }
                else
#endif // _WIN64
                {
                    if ( InputBufferLength < sizeof(AFD_TRANSMIT_FILE_INFO) ) {
                        return FALSE;
                    }

                    if (previousMode != KernelMode) {
                        ProbeForRead (InputBuffer,
                                        sizeof (userTransmitInfo),
                                        PROBE_ALIGNMENT(AFD_TRANSMIT_FILE_INFO));
                        userTransmitInfo = *((PAFD_TRANSMIT_FILE_INFO)InputBuffer);
                        if (userTransmitInfo.HeadLength>0)
                            ProbeForRead (userTransmitInfo.Head,
                                            userTransmitInfo.HeadLength,
                                            sizeof (UCHAR));
                        if (userTransmitInfo.TailLength>0)
                            ProbeForRead (userTransmitInfo.Tail,
                                            userTransmitInfo.TailLength,
                                            sizeof (UCHAR));
                    }
                    else {
                        userTransmitInfo = *((PAFD_TRANSMIT_FILE_INFO)InputBuffer);
                    }
                }

            } except( AFD_EXCEPTION_FILTER(NULL) ) {

                res = FALSE;
                break;
            }

            res = AfdFastTransmitFile (endpoint,
                                        &userTransmitInfo,
                                        IoStatus);

        }

        return res;

    default:
        request = _AFD_REQUEST(IoControlCode);
        if( request < AFD_NUM_IOCTLS &&
                AfdIoctlTable[request] == IoControlCode &&
                AfdImmediateCallDispatch[request]!=NULL) {

            proc = AfdImmediateCallDispatch[request];
            IoStatus->Status = (*proc) (
                        FileObject,
                        IoControlCode,
                        previousMode,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        &IoStatus->Information
                        );

            ASSERT (IoStatus->Status!=STATUS_PENDING);
            res = TRUE;
        }
        else {
            res = FALSE;
        }
        break;
    }

#ifdef _WIN64

    if (pArray!=localArray) {
        AFD_FREE_POOL (pArray, AFD_TEMPORARY_POOL_TAG);
    }
#endif

    return res;
}


BOOLEAN
AfdFastConnectionSend (
    IN PAFD_ENDPOINT    endpoint,
    IN PAFD_SEND_INFO   sendInfo,
    IN ULONG            sendLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    PAFD_BUFFER afdBuffer;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS status;

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = endpoint->Common.VcConnecting.Connection;

    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return FALSE;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // If the connection has been aborted, then we don't want to try
    // fast IO on it.
    //

    if ( connection->CleanupBegun || connection->AbortIndicated ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return FALSE;
    }


    //
    // Determine whether we can do fast IO with this send.  In order
    // to perform fast IO, there must be no other sends pended on this
    // connection and there must be enough space left for bufferring
    // the requested amount of data.
    //

    if ( AfdShouldSendBlock( endpoint, connection, sendLength ) ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        //

        if ( endpoint->NonBlocking && !( sendInfo->AfdFlags & AFD_OVERLAPPED ) ) {
            // Fast io can't handle error returns
            // if call is overlapped (completion port), but we know
            // that it is not overlapped
            IoStatus->Status = STATUS_DEVICE_NOT_READY;
            return TRUE;
        }

        return FALSE;
    }

    //
    // Add a reference to the connection object since the send
    // request will complete asynchronously.
    //

    REFERENCE_CONNECTION( connection );
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdFastConnectionSend: attempting fast IO on endp %p, conn %p\n",
                endpoint, connection));
    }

    //
    // Next get an AFD buffer structure that contains an IRP and a
    // buffer to hold the data.
    //

    afdBuffer = AfdGetBuffer( sendLength, 0, connection->OwningProcess );

    if ( afdBuffer == NULL) {
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        connection->VcBufferredSendBytes -= sendLength;
        connection->VcBufferredSendCount -= 1;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        DEREFERENCE_CONNECTION (connection);

        return FALSE;
    }


    //
    // We have to rebuild the MDL in the AFD buffer structure to
    // represent exactly the number of bytes we're going to be
    // sending.
    //

    afdBuffer->Mdl->ByteCount = sendLength;

    //
    // Remember the connection in the AFD buffer structure.  We need
    // this in order to access the connection in the restart routine.
    //

    afdBuffer->Context = connection;

    //
    // Copy the user's data into the AFD buffer.
    //

    if( sendLength > 0 ) {

        try {

            AfdCopyBufferArrayToBuffer(
                afdBuffer->Buffer,
                sendLength,
                sendInfo->BufferArray,
                sendInfo->BufferCount
                );

        } except( AFD_EXCEPTION_FILTER(NULL) ) {

            afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
            AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );
            AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
            connection->VcBufferredSendBytes -= sendLength;
            connection->VcBufferredSendCount -= 1;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            DEREFERENCE_CONNECTION (connection);
            // Fast io can't handle error returns
            // if call is overlapped (completion port)
            // IoStatus->Status = GetExceptionCode ();
            return FALSE;
        }
    }

    //
    // Use the IRP in the AFD buffer structure to give to the TDI
    // provider.  Build the TDI send request.
    //

    TdiBuildSend(
        afdBuffer->Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartBufferSend,
        afdBuffer,
        afdBuffer->Mdl,
        0,
        sendLength
        );


    //
    // Call the transport to actually perform the send.
    //

    status = IoCallDriver(
                 connection->DeviceObject,
                 afdBuffer->Irp
                 );

    //
    // Complete the user's IRP as appropriate.  Note that we change the
    // status code from what was returned by the TDI provider into
    // STATUS_SUCCESS.  This is because we don't want to complete
    // the IRP with STATUS_PENDING etc.
    //

    if ( NT_SUCCESS(status) ) {
        IoStatus->Information = sendLength;
        IoStatus->Status = STATUS_SUCCESS;
        return TRUE;
    }

    //
    // The call failed for some reason.  Fail fast IO.
    //

    return FALSE;
}



BOOLEAN
AfdFastConnectionReceive (
    IN PAFD_ENDPOINT    endpoint,
    IN PAFD_RECV_INFO   recvInfo,
    IN ULONG            recvLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    PLIST_ENTRY listEntry;
    ULONG totalOffset, partialLength;
    PAFD_BUFFER_HEADER  afdBuffer, partialAfdBuffer=NULL;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    LIST_ENTRY bufferListHead;
    BOOLEAN retryReceive = FALSE; // Retry receive if additional data
                                  // was indicated by the transport and buffered
                                  // while we were copying current batch.

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );
    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;

Retry:

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = endpoint->Common.VcConnecting.Connection;
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        //
        // If we have already copied something before retrying,
        // return success, next receive will report the error.
        //
        return retryReceive;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdFastConnectionReceive: attempting fast IO on endp %p, conn %p\n",
                endpoint, connection));
    }


    //
    // Determine whether we'll be able to perform fast IO.  In order
    // to do fast IO, there must be some bufferred data on the
    // connection, there must not be any pended receives on the
    // connection, and there must not be any bufferred expedited
    // data on the connection.  This last requirement is for
    // the sake of simplicity only.
    //

    if ( !IsListEmpty( &connection->VcReceiveIrpListHead ) ||
             connection->VcBufferredExpeditedCount != 0 ||
             connection->DisconnectIndicated ||
             connection->AbortIndicated) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        //
        // If we have already copied something before retrying,
        // return success, next receive will report the error.
        //
        return retryReceive;
    }

    if (connection->VcBufferredReceiveCount == 0) {
        ASSERT( IsListEmpty( &connection->VcReceiveBufferListHead ) );

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        if (!retryReceive &&
                endpoint->NonBlocking &&
                !(recvInfo->AfdFlags & AFD_OVERLAPPED)) {
            endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastConnectionReceive: Endp %p, Active %lx\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            IoStatus->Status = STATUS_DEVICE_NOT_READY;

            return TRUE;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        //
        // If we have already copied something before retrying,
        // return success, next receive will report the error.
        //
        return retryReceive;
    }

    ASSERT( !IsListEmpty( &connection->VcReceiveBufferListHead ) );

    //
    // Get a pointer to the first bufferred AFD buffer structure on
    // the connection.
    //

    afdBuffer = CONTAINING_RECORD(
                    connection->VcReceiveBufferListHead.Flink,
                    AFD_BUFFER_HEADER,
                    BufferListEntry
                    );

    ASSERT( !afdBuffer->ExpeditedData );

    //
    // For message endpoints if the buffer contains a partial message 
    // or doesn't fit into the buffer, bail out.  
    // We don't want the added complexity of handling
    // partial messages in the fast path.
    //

    if ( IS_MESSAGE_ENDPOINT(endpoint) &&
            (afdBuffer->PartialMessage || afdBuffer->DataLength>recvLength)) {
        //
        // We shouldn't be retry-ing for message oriented endpoint
        // since we only allow fast path if complete message is available.
        //
        ASSERT (retryReceive == FALSE);

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return FALSE;
    }

    //
    // Remeber current offset before we update
    // information field (it is not 0 if we are
    // re-trying).
    //
    totalOffset = (ULONG)IoStatus->Information;


    InitializeListHead( &bufferListHead );

    //
    // Reference the connection object so it doen't go away
    // until we return the buffer.
    //
    REFERENCE_CONNECTION (connection);

    //
    // Loop getting AFD buffers that will fill in the user's
    // buffer with as much data as will fit, or else with a
    // single buffer if this is not a stream endpoint.  We don't
    // actually do the copy within this loop because this loop
    // must occur while holding a lock, and we cannot hold a
    // lock while copying the data into the user's buffer
    // because the user's buffer is not locked and we cannot
    // take a page fault at raised IRQL.
    //

    while (IoStatus->Information<recvLength) {
        ASSERT( connection->VcBufferredReceiveBytes >= afdBuffer->DataLength );
        ASSERT( connection->VcBufferredReceiveCount > 0 );

        if (recvLength-IoStatus->Information>=afdBuffer->DataLength) {
            //
            // If we can copy the whole buffer, remove it from the connection's list of
            // buffers and place it on our local list of buffers.
            //

            RemoveEntryList( &afdBuffer->BufferListEntry );
            InsertTailList( &bufferListHead, &afdBuffer->BufferListEntry );
            
            //
            // Update the count of bytes on the connection.
            //

            connection->VcBufferredReceiveBytes -= afdBuffer->DataLength;
            connection->VcBufferredReceiveCount -= 1;
            IoStatus->Information += afdBuffer->DataLength;


            //
            // If this is a stream endpoint and more buffers are available,
            // try to fit the next one it as well..
            //

            if (!IS_MESSAGE_ENDPOINT(endpoint) &&
                    !IsListEmpty( &connection->VcReceiveBufferListHead ) ) {

                afdBuffer = CONTAINING_RECORD(
                            connection->VcReceiveBufferListHead.Flink,
                            AFD_BUFFER_HEADER,
                            BufferListEntry
                            );

                ASSERT( !afdBuffer->ExpeditedData );
                continue;
            }
        }
        else {
            //
            // Copy just a part of the buffer that fits and
            // increment its reference count so it doesn't get
            // destroyed until we done copying.
            //
            ASSERT (!IS_MESSAGE_ENDPOINT (endpoint));

            partialLength = recvLength-(ULONG)IoStatus->Information;
            partialAfdBuffer = afdBuffer;
            partialAfdBuffer->DataLength -= partialLength;
            partialAfdBuffer->DataOffset += partialLength;
            InterlockedIncrement (&partialAfdBuffer->RefCount);
            connection->VcBufferredReceiveBytes -= partialLength;
            IoStatus->Information = recvLength;
        }

        break;
    }


    endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

    if( !IsListEmpty( &connection->VcReceiveBufferListHead )) {

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

        retryReceive = FALSE;
    }
    else {
        //
        // We got all the data buffered. It is possible
        // that while we are copying data, more gets indicated
        // by the transport since we copy at passive level
        // and indication occur at DPC (or even on another processor).
        // We'll check again after copying, so we return as much data
        // as possible to the application (to improve performance).
        // For message oriented transports we can only
        // deliver one message at a time and we shouldn't be on the fast path
        // if we do not have a complete message.
        // If application has EventSelect/select/AsyncSelect outstanding.
        // we can't copy more data as well since it would receive a signal
        // to come back and we would already consumed the data.  We are not
        // concerned with the case when application calls some form of select
        // while we are in this routine because signaling is not guaranteed
        // to be multithread safe (e.g. if select comes right before we take 
        // the spinlock in the beginning of this routine, application will 
        // get false signal as well).
        //
        retryReceive = IoStatus->Information<recvLength && 
                        !IS_MESSAGE_ENDPOINT (endpoint) &&
                        (endpoint->EventsEnabled & AFD_POLL_RECEIVE)==0 &&
                        !endpoint->PollCalled;

        //
        // Disable fast IO path to avoid performance penalty
        // of unneccessarily going through it.
        //
        if (!endpoint->NonBlocking)
            endpoint->DisableFastIoRecv = TRUE;
    }

    //
    // If there is indicated but unreceived data in the TDI provider,
    // and we have available buffer space, fire off an IRP to receive
    // the data.
    //

    if ( connection->VcReceiveBytesInTransport > 0

         &&

         connection->VcBufferredReceiveBytes <
           connection->MaxBufferredReceiveBytes

           ) {

        ULONG bytesToReceive;
        PAFD_BUFFER newAfdBuffer;

        //
        // Remember the count of data that we're going to receive,
        // then reset the fields in the connection where we keep
        // track of how much data is available in the transport.
        // We reset it here before releasing the lock so that
        // another thread doesn't try to receive the data at the
        // same time as us.
        //

        if ( connection->VcReceiveBytesInTransport > AfdLargeBufferSize ) {
            bytesToReceive = connection->VcReceiveBytesInTransport;
        } else {
            bytesToReceive = AfdLargeBufferSize;
        }

        //
        // Get an AFD buffer structure to hold the data.
        //

        newAfdBuffer = AfdGetBuffer( bytesToReceive, 0,
                                connection->OwningProcess );
        if ( newAfdBuffer == NULL ) {
            //
            // If we were unable to get a buffer, just remember
            // that we still have data in transport
            //

            if (connection->VcBufferredReceiveBytes == 0 &&
                    !connection->OnLRList) {
                //
                // Since we do not have any data buffered, application
                // is not notified and will never call with recv.
                // We will have to put this on low resource list
                // and attempt to allocate memory and pull the data
                // later.
                //
                connection->OnLRList = TRUE;
                REFERENCE_CONNECTION (connection);
                AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
            }
            else {
                UPDATE_CONN (connection);
            }
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        } else {

            connection->VcReceiveBytesInTransport = 0;
            ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);

            //
            // We need to remember the connection in the AFD buffer
            // because we'll need to access it in the completion
            // routine.
            //

            newAfdBuffer->Context = connection;

            //
            // Acquire connection reference to be released in completion routine
            //

            REFERENCE_CONNECTION (connection);

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            //
            // Finish building the receive IRP to give to the TDI provider.
            //

            TdiBuildReceive(
                newAfdBuffer->Irp,
                connection->DeviceObject,
                connection->FileObject,
                AfdRestartBufferReceive,
                newAfdBuffer,
                newAfdBuffer->Mdl,
                TDI_RECEIVE_NORMAL,
                (CLONG)bytesToReceive
                );

            //
            // Hand off the IRP to the TDI provider.
            //

            (VOID)IoCallDriver(
                     connection->DeviceObject,
                     newAfdBuffer->Irp
                     );
        }

    } else {

       AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // We have in a local list all the data we'll use for this
    // IO.  Start copying data to the user buffer.
    //

    while ( !IsListEmpty( &bufferListHead ) ) {

        //
        // Take the first buffer from the list.
        //

        listEntry = RemoveHeadList( &bufferListHead );
        afdBuffer = CONTAINING_RECORD(
                        listEntry,
                        AFD_BUFFER_HEADER,
                        BufferListEntry
                        );
        DEBUG afdBuffer->BufferListEntry.Flink = NULL;

        if( afdBuffer->DataLength > 0 ) {

            ASSERTMSG (
                "NIC Driver freed the packet before it was returned!!!",
                !afdBuffer->NdisPacket ||
                    (MmIsAddressValid (afdBuffer->Context) &&
                     MmIsAddressValid (MmGetSystemAddressForMdl (afdBuffer->Mdl))) );
            try {

                //
                // Copy the data in the buffer to the user buffer.
                //

                AfdCopyMdlChainToBufferArray(
                    recvInfo->BufferArray,
                    totalOffset,
                    recvInfo->BufferCount,
                    afdBuffer->Mdl,
                    afdBuffer->DataOffset,
                    afdBuffer->DataLength
                    );

            } except( AFD_EXCEPTION_FILTER(NULL) ) {

                //
                // If an exception is hit, there is the possibility of
                // data corruption.  However, it is nearly impossible to
                // avoid this in all cases, so just throw out the
                // remainder of the data that we would have copied to
                // the user buffer.
                //

                if (afdBuffer->RefCount==1 || // Can't change once off the list
                        InterlockedDecrement (&afdBuffer->RefCount)==0) {
                    AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                }

                while ( !IsListEmpty( &bufferListHead ) ) {
                    listEntry = RemoveHeadList( &bufferListHead );
                    afdBuffer = CONTAINING_RECORD(
                                    listEntry,
                                    AFD_BUFFER_HEADER,
                                    BufferListEntry
                                    );
                    DEBUG afdBuffer->BufferListEntry.Flink = NULL;
                    if (afdBuffer->RefCount==1 || // Can't change once off the list
                            InterlockedDecrement (&afdBuffer->RefCount)==0) {
                        AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                    }
                }

                //
                // We'll have to abort since there is a possibility of data corruption.
                // Shame on application for giving us bogus buffers.
                // This also releases the reference that we needed to return the buffer.
                //
                AfdAbortConnection (connection);

                // Fast io can't handle error returns
                // if call is overlapped (completion port)
                // IoStatus->Status = GetExceptionCode ();
                return FALSE;
            }

            totalOffset += afdBuffer->DataLength;
        }

        //
        // We're done with the AFD buffer.
        //

        if (afdBuffer->RefCount==1 || // Can't change once off the list
                InterlockedDecrement (&afdBuffer->RefCount)==0) {
            AfdReturnBuffer( afdBuffer, connection->OwningProcess );
        }
    }

    //
    // Copy any partial buffers
    //
    if (partialAfdBuffer) {
        ASSERT (partialLength>0);
        ASSERTMSG (
            "NIC Driver freed the packet before it was returned!!!",
            !partialAfdBuffer->NdisPacket ||
                (MmIsAddressValid (partialAfdBuffer->Context) &&
                 MmIsAddressValid (MmGetSystemAddressForMdl (partialAfdBuffer->Mdl))) );
        try {

            //
            // Copy the data in the buffer to the user buffer.
            //

            AfdCopyMdlChainToBufferArray(
                recvInfo->BufferArray,
                totalOffset,
                recvInfo->BufferCount,
                partialAfdBuffer->Mdl,
                partialAfdBuffer->DataOffset-partialLength,
                partialLength
                );

        } except( AFD_EXCEPTION_FILTER(NULL) ) {
            if (InterlockedDecrement (&partialAfdBuffer->RefCount)==0) {
                ASSERT (partialAfdBuffer->BufferListEntry.Flink == NULL);
                AfdReturnBuffer( partialAfdBuffer, connection->OwningProcess );
            }
            //
            // We'll have to abort since there is a possibility of data corruption.
            // Shame on application for giving us bogus buffers.
            // This also releases the reference that we needed to return the buffer.
            //
            AfdAbortConnection (connection);

            // Fast io can't handle error returns
            // if call is overlapped (completion port)
            // IoStatus->Status = GetExceptionCode ();
            return FALSE;
        }

        if (InterlockedDecrement (&partialAfdBuffer->RefCount)==0) {
            ASSERT (partialAfdBuffer->BufferListEntry.Flink == NULL);
            AfdReturnBuffer( partialAfdBuffer, connection->OwningProcess );
        }

        totalOffset += partialLength;
    }

    ASSERT (IoStatus->Information==totalOffset);


    //
    // If more data is available, we need to retry and attempt to completely
    // fill application's buffer.
    //

    if (retryReceive && (endpoint->EventsActive & AFD_POLL_RECEIVE)) {
        ASSERT (IoStatus->Information<recvLength && !IS_MESSAGE_ENDPOINT (endpoint));
        DEREFERENCE_CONNECTION2 (connection, "Fast retry receive 0x%lX bytes", (ULONG)IoStatus->Information);
        goto Retry;
    }
    else {
        //
        // Release the reference needed to return the buffer(s).
        //
        DEREFERENCE_CONNECTION2 (connection, "Fast receive 0x%lX bytes", (ULONG)IoStatus->Information);
    }

    ASSERT( IoStatus->Information <= recvLength );
    ASSERT (IoStatus->Status == STATUS_SUCCESS);
    return TRUE;
}



BOOLEAN
AfdFastDatagramSend (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_SEND_DATAGRAM_INFO  sendInfo,
    IN ULONG                    sendLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    )
{
        
    PAFD_BUFFER afdBuffer = NULL;
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;


    //
    // If this is a send for more than the threshold number of
    // bytes, don't use the fast path.  We don't allow larger sends
    // in the fast path because of the extra data copy it entails,
    // which is more expensive for large buffers.  For smaller
    // buffers, however, the cost of the copy is small compared to
    // the IO system overhead of the slow path.
    //
    // We also copy and return for non-blocking endpoints regardless
    // of the size.  That's what we are supposed to do according
    // to the spec.
    //

    if ( !endpoint->NonBlocking && sendLength > AfdFastSendDatagramThreshold ) {
        return FALSE;
    }

    //
    // If we already buffered to many sends, go the long way.
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if ( endpoint->DgBufferredSendBytes >=
             endpoint->Common.Datagram.MaxBufferredSendBytes &&
         endpoint->DgBufferredSendBytes>0) {

        if ( endpoint->NonBlocking && !( sendInfo->AfdFlags & AFD_OVERLAPPED ) ) {
            endpoint->EventsActive &= ~AFD_POLL_SEND;
            endpoint->EnableSendEvent = TRUE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastIoDeviceControl: Endp %p, Active %lX\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        
        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.(check for non-blocking is
        // below, otherwise status code is ignored).
        //

        status = STATUS_DEVICE_NOT_READY;
        goto errorset;
    }

    endpoint->DgBufferredSendBytes += sendLength;

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastDatagramSend: attempting fast IO on endp %p\n",
                     endpoint));
    }


    //
    // Get an AFD buffer to use for the request.  We'll copy the
    // user's data to the AFD buffer then submit the IRP in the AFD
    // buffer to the TDI provider.

    if ((sendInfo->TdiConnInfo.RemoteAddressLength==0) &&
            !IS_TDI_DGRAM_CONNECTION(endpoint)) {
    retry:
        try {
            //
            // Get an AFD buffer to use for the request.  We'll copy the
            // user to the AFD buffer then submit the IRP in the AFD
            // buffer to the TDI provider.
            //

            afdBuffer = AfdGetBufferRaiseOnFailure(
                            sendLength,
                            endpoint->Common.Datagram.RemoteAddressLength,
                            endpoint->OwningProcess
                            );
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto exit;
        }

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // If the endpoint is not connected, fail.
        //

        if ( endpoint->State != AfdEndpointStateConnected ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
            status = STATUS_INVALID_CONNECTION;
            goto exit;
        }

        if (afdBuffer->AllocatedAddressLength <
               endpoint->Common.Datagram.RemoteAddressLength ) {
            //
            // Apparently connection address length has changed
            // on us while we were allocating the buffer.
            // This is extremely unlikely (even if endpoint got
            // connected to a different address, the length is unlikely
            // to change), but we must handle this, just try again.
            //
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);
            goto retry;
        }
        //
        // Copy the address to the AFD buffer.
        //

        RtlCopyMemory(
            afdBuffer->TdiInfo.RemoteAddress,
            endpoint->Common.Datagram.RemoteAddress,
            endpoint->Common.Datagram.RemoteAddressLength
            );

        afdBuffer->TdiInfo.RemoteAddressLength = endpoint->Common.Datagram.RemoteAddressLength;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }
    else {
        try {
            afdBuffer = AfdGetBufferRaiseOnFailure( sendLength, sendInfo->TdiConnInfo.RemoteAddressLength,
                                        endpoint->OwningProcess);
            //
            // Copy address if necessary.
            //
            if (sendInfo->TdiConnInfo.RemoteAddressLength!=0) {
                RtlCopyMemory(
                    afdBuffer->TdiInfo.RemoteAddress,
                    sendInfo->TdiConnInfo.RemoteAddress,
                    sendInfo->TdiConnInfo.RemoteAddressLength
                    );

                //
                // Validate internal consistency of the transport address structure.
                // Note that we HAVE to do this after copying since the malicious
                // application can change the content of the buffer on us any time
                // and our check will be bypassed.
                //
                if ((((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->TAAddressCount!=1) ||
                        (LONG)sendInfo->TdiConnInfo.RemoteAddressLength<
                            FIELD_OFFSET (TRANSPORT_ADDRESS,
                                Address[0].Address[((PTRANSPORT_ADDRESS)afdBuffer->TdiInfo.RemoteAddress)->Address[0].AddressLength])) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
            }
        } except( AFD_EXCEPTION_FILTER(&status) ) {
            if (afdBuffer!=NULL) {
                AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );
            }
            goto exit;
        }

        afdBuffer->TdiInfo.RemoteAddressLength = sendInfo->TdiConnInfo.RemoteAddressLength;
    }

    //
    // Copy the  output buffer to the AFD buffer.
    //

    try {

        AfdCopyBufferArrayToBuffer(
            afdBuffer->Buffer,
            sendLength,
            sendInfo->BufferArray,
            sendInfo->BufferCount
            );

        //
        // Store the length of the data and the address we're going to
        // send.
        //
        afdBuffer->DataLength = sendLength;

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );
        goto exit;
    }


    if (IS_TDI_DGRAM_CONNECTION(endpoint)
            && (afdBuffer->TdiInfo.RemoteAddressLength==0)) {
        TdiBuildSend(
                afdBuffer->Irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartFastDatagramSend,
                afdBuffer,
                afdBuffer->Irp->MdlAddress,
                0,
                sendLength
                );
    }
    else {
        //
        // Set up the input TDI information to point to the destination
        // address.
        //

        afdBuffer->TdiInfo.Options = NULL;
        afdBuffer->TdiInfo.OptionsLength = 0;
        afdBuffer->TdiInfo.UserData = NULL;
        afdBuffer->TdiInfo.UserDataLength = 0;


        //
        // Initialize the IRP in the AFD buffer to do a fast datagram send.
        //

        TdiBuildSendDatagram(
            afdBuffer->Irp,
            endpoint->AddressDeviceObject,
            endpoint->AddressFileObject,
            AfdRestartFastDatagramSend,
            afdBuffer,
            afdBuffer->Irp->MdlAddress,
            sendLength,
            &afdBuffer->TdiInfo
            );
    }

    //
    // Change the MDL in the AFD buffer to specify only the number
    // of bytes we're actually sending.  This is a requirement of TDI--
    // the MDL chain cannot describe a longer buffer than the send
    // request.
    //

    afdBuffer->Mdl->ByteCount = sendLength;

    //
    // Reference the endpoint so that it does not go away until the send
    // completes.  This is necessary to ensure that a send which takes a
    // very long time and lasts longer than the process will not cause a
    // crash when the send datragram finally completes.
    //

    REFERENCE_ENDPOINT2( endpoint, "AfdFastDatagramSend, length", sendLength );

    //
    // Set the context to NULL initially so that if the IRP is completed
    // by the stack before IoCallDriver returns, the completion routine
    // does not free the buffer (and IRP in it) and we can figure out
    // what the final status of the operation was and report it to the
    // application
    //

    afdBuffer->Context = NULL;

    //
    // Give the IRP to the TDI provider.  If the request fails
    // immediately, then fail fast IO.  If the request fails later on,
    // there's nothing we can do about it.
    //

    status = IoCallDriver(
                 endpoint->AddressDeviceObject,
                 afdBuffer->Irp
                 );

    //
    // Check if completion routine has already been called and we
    // can figure out what the final status is
    //
    if (InterlockedCompareExchangePointer (
            &afdBuffer->Context,
            endpoint,
            NULL)!=NULL) {
        BOOLEAN indicateSendEvent;
        //
        // Completion routine has been called, pick the final status
        // and dereference the endpoint and free the buffer
        //
        status = afdBuffer->Irp->IoStatus.Status;

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->DgBufferredSendBytes -= sendLength;
        if (endpoint->DgBufferredSendBytes <
                endpoint->Common.Datagram.MaxBufferredSendBytes ||
                endpoint->DgBufferredSendBytes==0) {
            indicateSendEvent = TRUE;
            AfdIndicateEventSelectEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
        }
        else {
            indicateSendEvent = FALSE;
        }
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        if (indicateSendEvent) {
            AfdIndicatePollEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
        }

        AfdReturnBuffer (&afdBuffer->Header, endpoint->OwningProcess);

        DEREFERENCE_ENDPOINT2 (endpoint, "AfdFastDatagramSend-inline completion, status", status );
    }
    //else Completion routine has not been called, we set the pointer
    // to the endpoint in the buffer context, so it can derefernce it
    // and knows to free the buffer
    //

    if ( NT_SUCCESS(status) ) {
        IoStatus->Information = sendLength;
        IoStatus->Status = STATUS_SUCCESS;
        return TRUE;
    } else {
        goto errorset;
    }

exit:
    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->DgBufferredSendBytes -= sendLength;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

errorset:
    // Fast io can't handle error returns
    // if call is overlapped (completion port), 
    if ( endpoint->NonBlocking && !( sendInfo->AfdFlags & AFD_OVERLAPPED ) ) {
        // We know that it is not overlapped
        IoStatus->Status = status;
        return TRUE;
    }
    else {
        return FALSE;
    }
} // AfdFastDatagramSend


NTSTATUS
AfdRestartFastDatagramSend (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_BUFFER afdBuffer;
    PAFD_ENDPOINT endpoint;
    ULONG   sendLength;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));

    //
    // Reset the AFD buffer structure.
    //

    ASSERT( afdBuffer->Irp == Irp );

    sendLength = afdBuffer->Mdl->ByteCount;
    ASSERT (afdBuffer->DataLength==sendLength);
    afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;


    //
    // If call succeeded, transport should have sent the number of bytes requested
    //
    ASSERT (Irp->IoStatus.Status!=STATUS_SUCCESS || 
                Irp->IoStatus.Information==sendLength);
    //
    // Find the endpoint used for this request if
    // the IoCallDriver call has completed already
    //

    endpoint = InterlockedCompareExchangePointer (&afdBuffer->Context,
                                            (PVOID)-1,
                                            NULL);
    if (endpoint!=NULL) {
        BOOLEAN     indicateSendEvent;
#if REFERENCE_DEBUG
        NTSTATUS    status;
#endif
        //
        // IoCallDriver has completed, free the buffer and
        // dereference endpoint here
        //
        ASSERT( IS_DGRAM_ENDPOINT(endpoint) );


        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->DgBufferredSendBytes -= sendLength;
        if (endpoint->DgBufferredSendBytes <
                endpoint->Common.Datagram.MaxBufferredSendBytes ||
                endpoint->DgBufferredSendBytes==0)  {
            AfdIndicateEventSelectEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
            indicateSendEvent = TRUE;
        }
        else
            indicateSendEvent = FALSE;
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        if (indicateSendEvent) {
            AfdIndicatePollEvent (endpoint, AFD_POLL_SEND, STATUS_SUCCESS);
        }
        //
        // Get rid of the reference we put on the endpoint when we started
        // this I/O.
        //

#if REFERENCE_DEBUG
        status = Irp->IoStatus.Status;
#endif
        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );

        DEREFERENCE_ENDPOINT2 (endpoint, "AfdRestartFastDatagramSend, status", status );

    }
    // else IoCallDriver is not done yet, it will free the buffer
    // and endpoint when done (it will look at final status and
    // report it to the application).

    //
    // Tell the IO system to stop processing this IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartFastSendDatagram



BOOLEAN
AfdFastDatagramReceive (
    IN PAFD_ENDPOINT            endpoint,
    IN PAFD_RECV_MESSAGE_INFO   msgInfo,
    IN ULONG                    recvLength,
    OUT PIO_STATUS_BLOCK        IoStatus
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PAFD_BUFFER_HEADER afdBuffer;
    PTRANSPORT_ADDRESS tdiAddress;
    ULONG length;



    IF_DEBUG(FAST_IO) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastDatagramReceive: attempting fast IO on endp %p\n",
                    endpoint));
    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );


    //
    // If there are no datagrams available to be received, don't
    // bother with the fast path.
    //
    if ( !ARE_DATAGRAMS_ON_ENDPOINT( endpoint ) ) {

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        //

        if ( endpoint->NonBlocking && !( msgInfo->dgi.AfdFlags & AFD_OVERLAPPED ) ) {
            endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastDatagramReceive: Endp %p, Active %lX\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            // Fast io can't handle error returns
            // if call is overlapped (completion port), but we know here
            // that call is not overlapped
            IoStatus->Status = STATUS_DEVICE_NOT_READY;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            return TRUE;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return FALSE;
    }

    //
    // There is at least one datagram bufferred on the endpoint.  Use it
    // for this receive.
    //

    listEntry = RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );
    afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

    //
    // If the datagram is too large or it is an error indication
    // fail fast IO.
    //

    if ( (afdBuffer->DataLength > recvLength) || 
            !NT_SUCCESS (afdBuffer->Status)) {
        InsertHeadList(
            &endpoint->ReceiveDatagramBufferListHead,
            &afdBuffer->BufferListEntry
            );
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        return FALSE;
    }

    //
    // Update counts of bufferred datagrams and bytes on the endpoint.
    //

    endpoint->DgBufferredReceiveCount--;
    endpoint->DgBufferredReceiveBytes -= afdBuffer->DataLength;

    //
    // Release the lock and copy the datagram into the user buffer.  We
    // can't continue to hold the lock, because it is not legal to take
    // an exception at raised IRQL.  Releasing the lock may result in a
    // misordered datagram if there is an exception in copying to the
    // user's buffer, but that is the application's fault for giving us a bogus
    // pointer.  Besides, datagram order is not guaranteed.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    try {

        if (afdBuffer->DataLength>0) {
            AfdCopyMdlChainToBufferArray(
                msgInfo->dgi.BufferArray,
                0,
                msgInfo->dgi.BufferCount,
                afdBuffer->Mdl,
                0,
                afdBuffer->DataLength
                );
        }

        //
        // If we need to return the source address, copy it to the
        // user's output buffer.
        //

        if ( msgInfo->dgi.Address != NULL ) {

            tdiAddress = afdBuffer->TdiInfo.RemoteAddress;

            length = tdiAddress->Address[0].AddressLength +
                sizeof(u_short);    // sa_family

            if( *msgInfo->dgi.AddressLength < length ) {

                ExRaiseAccessViolation();

            }

            if (ExGetPreviousMode ()!=KernelMode) {
                ProbeForWrite (msgInfo->dgi.Address,
                                length,
                                sizeof (UCHAR));
            }

            RtlCopyMemory(
                msgInfo->dgi.Address,
                &tdiAddress->Address[0].AddressType,
                length
                );

            *msgInfo->dgi.AddressLength = length;
        }

        if (msgInfo->ControlLength!=NULL) {
            if (afdBuffer->DatagramFlags & TDI_RECEIVE_CONTROL_INFO &&
                    afdBuffer->DataOffset>0) {
                PAFD_BUFFER buf = CONTAINING_RECORD (afdBuffer, AFD_BUFFER, Header);
                ASSERT (msgInfo->MsgFlags!=NULL);
                ASSERT (buf->BufferLength != AfdBufferTagSize);
                length = buf->DataOffset;
#ifdef _WIN64
                if (IoIs32bitProcess (NULL)) {
                    length = AfdComputeCMSGLength32 (
                                        (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                                        length);

                    if (length>*msgInfo->ControlLength) {
                        ExRaiseAccessViolation ();
                    }
                    if (ExGetPreviousMode ()!=KernelMode) {
                        ProbeForWrite (msgInfo->ControlBuffer,
                                        length,
                                        sizeof (UCHAR));
                    }
                    AfdCopyCMSGBuffer32 (
                                        msgInfo->ControlBuffer,
                                        (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                                        length);
                }
                else
#endif // _WIN64
                {
                    if (length>*msgInfo->ControlLength) {
                        ExRaiseAccessViolation ();
                    }

                    if (ExGetPreviousMode ()!=KernelMode) {
                        ProbeForWrite (msgInfo->ControlBuffer,
                                        length,
                                        sizeof (UCHAR));
                    }

                    RtlCopyMemory(
                        msgInfo->ControlBuffer,
                        (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                        length
                        );
                }

            }
            else {
                length = 0;
            }

            *msgInfo->ControlLength = length;
        }

        if (msgInfo->MsgFlags!=NULL) {
            ULONG flags =  0;
            if (afdBuffer->DatagramFlags & TDI_RECEIVE_BROADCAST)
                flags |= MSG_BCAST;
            if (afdBuffer->DatagramFlags & TDI_RECEIVE_MULTICAST)
                flags |= MSG_MCAST;
            *msgInfo->MsgFlags = flags;
        }

        IoStatus->Information = afdBuffer->DataLength;
        IoStatus->Status = STATUS_SUCCESS;

    } except( AFD_EXCEPTION_FILTER(NULL) ) {

        //
        // Put the buffer back on the endpoint's list.
        //

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        InsertHeadList(
            &endpoint->ReceiveDatagramBufferListHead,
            &afdBuffer->BufferListEntry
            );

        endpoint->DgBufferredReceiveCount++;
        endpoint->DgBufferredReceiveBytes += afdBuffer->DataLength;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        // Fast io can't handle error returns
        // if call is overlapped (completion port)
        // IoStatus->Status = GetExceptionCode ();
        return FALSE;
    }

    //
    // Clear the receive data active bit. If there's more data
    // available, set the corresponding event.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

    if( ARE_DATAGRAMS_ON_ENDPOINT( endpoint ) ) {

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

    }
    else {
        //
        // Disable fast IO path to avoid performance penalty
        // of going through it.
        //
        if (!endpoint->NonBlocking)
            endpoint->DisableFastIoRecv = TRUE;
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // The fast IO worked!  Clean up and return to the user.
    //

    AfdReturnBuffer( afdBuffer, endpoint->OwningProcess );

    ASSERT (IoStatus->Status == STATUS_SUCCESS);
    return TRUE;

} // AfdFastDatagramReceive


BOOLEAN
AfdShouldSendBlock (
    IN PAFD_ENDPOINT Endpoint,
    IN PAFD_CONNECTION Connection,
    IN ULONG SendLength
    )

/*++

Routine Description:

    Determines whether a nonblocking send can be performed on the
    connection, and if the send is possible, updates the connection's
    send tracking information.

Arguments:

    Endpoint - the AFD endpoint for the send.

    Connection - the AFD connection for the send.

    SendLength - the number of bytes that the caller wants to send.

Return Value:

    TRUE if the there is not too much data on the endpoint to perform
    the send; FALSE otherwise.

Note:
    This routine assumes that endpoint spinlock is held when calling it.

--*/

{

    //
    // Determine whether we can do fast IO with this send.  In order
    // to perform fast IO, there must be no other sends pended on this
    // connection and there must be enough space left for bufferring
    // the requested amount of data.
    //


    if ( !IsListEmpty( &Connection->VcSendIrpListHead )

         ||

         Connection->VcBufferredSendBytes >= Connection->MaxBufferredSendBytes
         ) {

        //
        // If this is a nonblocking endpoint, fail the request here and
        // save going through the regular path.
        //

        if ( Endpoint->NonBlocking ) {
            Endpoint->EventsActive &= ~AFD_POLL_SEND;
            Endpoint->EnableSendEvent = TRUE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastIoDeviceControl: Endp %p, Active %lX\n",
                    Endpoint,
                    Endpoint->EventsActive
                    ));
            }
        }

        return TRUE;
    }

    //
    // Update count of send bytes pending on the connection.
    //

    Connection->VcBufferredSendBytes += SendLength;
    Connection->VcBufferredSendCount += 1;

    //
    // Indicate to the caller that it is OK to proceed with the send.
    //

    return FALSE;

} // AfdShouldSendBlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module performs initialization for the AFD device driver.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:

--*/

#include "afdp.h"

#define REGISTRY_PARAMETERS         L"Parameters"
#define REGISTRY_AFD_INFORMATION    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Afd"
#define REGISTRY_IRP_STACK_SIZE     L"IrpStackSize"
#define REGISTRY_PRIORITY_BOOST     L"PriorityBoost"
#define REGISTRY_IGNORE_PUSH_BIT    L"IgnorePushBitOnReceives"
#define REGISTRY_NO_RAW_SECURITY    L"DisableRawSecurity"
#define REGISTRY_NO_SHARED_ADDRESSES L"DisableAddressSharing"
#define REGISTRY_NO_DIRECT_ACCEPTEX L"DisableDirectAcceptEx"
#define REGISTRY_MAX_ACTIVE_TRANSMIT_FILE_COUNT L"MaxActiveTransmitFileCount"
#define REGISTRY_ENABLE_DYNAMIC_BACKLOG L"EnableDynamicBacklog"
#define REGISTRY_DISABLE_CHAINED_RECV L"DisableChainedReceive"
#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
#define REGISTRY_USE_TDI_SEND_AND_DISCONNECT L"UseTdiSendAndDisconnect"
#endif // TDI_SERVICE_SEND_AND_DISCONNECT
#define REGISTRY_BUFFER_ALIGNMENT   L"BufferAlignment"
#define REGISTRY_VOLATILE_PARAMETERS    L"VolatileParameters"


#if DBG
#define REGISTRY_DEBUG_FLAGS        L"DebugFlags"
#define REGISTRY_BREAK_ON_STARTUP   L"BreakOnStartup"
#define REGISTRY_USE_PRIVATE_ASSERT L"UsePrivateAssert"
#endif

#if AFD_PERF_DBG
#define REGISTRY_DISABLE_FAST_IO    L"DisableFastIO"
#define REGISTRY_DISABLE_CONN_REUSE L"DisableConnectionReuse"
#endif

//
// A list of longwords that are configured by the registry.
//

struct _AfdConfigInfo {
    PWCHAR RegistryValueName;
    PULONG Variable;
} AfdConfigInfo[] = {
    { L"LargeBufferSize", (PULONG)&AfdLargeBufferSize },
    { L"LargeBufferListDepth", &AfdLargeBufferListDepth },
    { L"MediumBufferSize", &AfdMediumBufferSize },
    { L"MediumBufferListDepth", &AfdMediumBufferListDepth },
    { L"SmallBufferSize", &AfdSmallBufferSize },
    { L"SmallBufferListDepth", &AfdSmallBufferListDepth },
    { L"BufferTagListDepth", &AfdBufferTagListDepth },
    { L"FastSendDatagramThreshold", &AfdFastSendDatagramThreshold },
    { L"PacketFragmentCopyThreshold", &AfdTPacketsCopyThreshold },
    { L"StandardAddressLength", &AfdStandardAddressLength },
    { L"DefaultReceiveWindow", &AfdReceiveWindowSize },
    { L"DefaultSendWindow", &AfdSendWindowSize },
    { L"TransmitIoLength", &AfdTransmitIoLength },
    { L"MaxFastTransmit", &AfdMaxFastTransmit },
    { L"MaxFastCopyTransmit", &AfdMaxFastCopyTransmit },
    { L"MinimumDynamicBacklog", &AfdMinimumDynamicBacklog },
    { L"MaximumDynamicBacklog", &AfdMaximumDynamicBacklog },
    { L"DynamicBacklogGrowthDelta", &AfdDynamicBacklogGrowthDelta },
    { L"DefaultPacketElementCount", &AfdDefaultTpInfoElementCount },
    { L"TransmitWorker", &AfdDefaultTransmitWorker}
},

AfdVolatileConfigInfo []= {
    { L"FastSendDatagramThreshold", &AfdFastSendDatagramThreshold },
    { L"PacketFragmentCopyThreshold", &AfdTPacketsCopyThreshold },
    { L"TransmitIoLength", &AfdTransmitIoLength },
    { L"MaxFastTransmit", &AfdMaxFastTransmit },
    { L"MaxFastCopyTransmit", &AfdMaxFastCopyTransmit }
};


#define AFD_CONFIG_VAR_COUNT (sizeof(AfdConfigInfo) / sizeof(AfdConfigInfo[0]))
#define AFD_VOLATILE_CONFIG_VAR_COUNT (sizeof(AfdVolatileConfigInfo) / sizeof(AfdVolatileConfigInfo[0]))

VOID
AfdReadVolatileParameters (
    PVOID   Parameter
    );

VOID
AfdReleaseRegistryHandleWait (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

ULONG
AfdReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

NTSTATUS
AfdOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

VOID
AfdReadRegistry (
    VOID
    );

VOID
AfdUnload (
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
AfdCreateSecurityDescriptor(
    VOID
    );

NTSTATUS
AfdBuildDeviceAcl(
    OUT PACL *DeviceAcl
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, AfdReadSingleParameter )
#pragma alloc_text( INIT, AfdOpenRegistry )
#pragma alloc_text( INIT, AfdReadRegistry )
#pragma alloc_text( INIT, AfdCreateSecurityDescriptor )
#pragma alloc_text( INIT, AfdBuildDeviceAcl )
#pragma alloc_text( PAGE, AfdUnload )
#pragma alloc_text( PAGE, AfdReadVolatileParameters )
#pragma alloc_text( PAGE, AfdReleaseRegistryHandleWait )
#endif


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the AFD device driver.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    CLONG i;
    BOOLEAN success;
    ULONG   size;

    PAGED_CODE( );

    //
    // Create the device object.  (IoCreateDevice zeroes the memory
    // occupied by the object.)
    //
    // !!! Apply an ACL to the device object.
    //

    RtlInitUnicodeString( &deviceName, AFD_DEVICE_NAME );

    status = IoCreateDevice(
                 DriverObject,                   // DriverObject
                 0,                              // DeviceExtension
                 &deviceName,                    // DeviceName
                 FILE_DEVICE_NAMED_PIPE,         // DeviceType
                 0,                              // DeviceCharacteristics
                 FALSE,                          // Exclusive
                 &AfdDeviceObject                // DeviceObject
                 );


    if ( !NT_SUCCESS(status) ) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD DriverEntry: unable to create device object: %lx\n",
                    status ));
        goto error_exit;
    }

    AfdWorkQueueItem = IoAllocateWorkItem (AfdDeviceObject);
    if (AfdWorkQueueItem==NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AFD DriverEntry: unable to allocate work queue item\n" ));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    KeInitializeEvent (&AfdContextWaitEvent, NotificationEvent, FALSE);

    //
    // Create the security descriptor used for socket access checks.
    //
    status = AfdCreateSecurityDescriptor();

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }


    //
    // Initialize global data.
    //
    AfdInitializeData( );

    //
    // Read registry information.
    // This may override hard-coded global
    // initialization above.
    //

    AfdReadRegistry( );

#ifdef AFD_CHECK_ALIGNMENT
    AfdGlobalData = AFD_ALLOCATE_POOL_PRIORITY(
                      NonPagedPool,
                      FIELD_OFFSET (AFD_GLOBAL_DATA, BufferAlignmentTable[AfdAlignmentTableSize])
                      // Note that although we have an array of UCHARs above
                      // we do not need to align the array of ULONGs 
                      // since the UCHAR array size is aligned
                      // to processor requirement.
                        + AfdAlignmentTableSize*sizeof(LONG),
                      AFD_RESOURCE_POOL_TAG,
                      HighPoolPriority
                      );
#else
    AfdGlobalData = AFD_ALLOCATE_POOL_PRIORITY(
                      NonPagedPool,
                      FIELD_OFFSET (AFD_GLOBAL_DATA, BufferAlignmentTable[AfdAlignmentTableSize]),
                      AFD_RESOURCE_POOL_TAG,
                      HighPoolPriority
                      );
#endif

    if ( AfdGlobalData == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    ExInitializeResourceLite( AfdResource );

    AfdInitializeBufferManager();

    //
    // Initialize the AFD buffer lookaside lists.  These must be
    // initialized *after* the registry data has been read.
    //

    size = AfdCalculateBufferSize (AfdLargeBufferSize, AfdStandardAddressLength);
    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->LargeBufferList,
        AfdAllocateBuffer,
        AfdFreeBuffer,
        0,
        size,
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdLargeBufferListDepth
        );

    //
    // Make sure that if as the result of alignment the allocation size is adjusted
    // to equal to the larger one, the actual buffer sizes are adjusted as well.
    // This is necessary to avoid confusing block allocator which determines
    // buffer size based on the allocation size passed by the lookaside list
    // code.
    //
    size = AfdCalculateBufferSize (AfdMediumBufferSize, AfdStandardAddressLength);
    if (size==AfdLookasideLists->LargeBufferList.L.Size) {
        AfdMediumBufferSize = AfdLargeBufferSize;
    }
    else {
        ASSERT (size<AfdLookasideLists->LargeBufferList.L.Size);
    }
    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->MediumBufferList,
        AfdAllocateBuffer,
        AfdFreeBuffer,
        0,
        size,
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdMediumBufferListDepth
        );

    size = AfdCalculateBufferSize (AfdSmallBufferSize, AfdStandardAddressLength);
    if (size==AfdLookasideLists->MediumBufferList.L.Size) {
        AfdSmallBufferSize = AfdMediumBufferSize;
    }
    else {
        ASSERT (size<AfdLookasideLists->MediumBufferList.L.Size);
    }
    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->SmallBufferList,
        AfdAllocateBuffer,
        AfdFreeBuffer,
        0,
        size,
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdSmallBufferListDepth
        );

    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->BufferTagList,
        AfdAllocateBufferTag,
        AfdFreeBufferTag,
        0,
        sizeof (AFD_BUFFER_TAG),
        AFD_DATA_BUFFER_POOL_TAG,
        (USHORT)AfdBufferTagListDepth
        );

    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->TpInfoList,
        AfdAllocateTpInfo,
        AfdFreeTpInfo,
        0,
        AfdComputeTpInfoSize (AfdDefaultTpInfoElementCount,
                                AFD_TP_MIN_SEND_IRPS,
                                AfdIrpStackSize-1),
        AFD_TRANSMIT_INFO_POOL_TAG,
        0
        );

    ExInitializeNPagedLookasideList(
        &AfdLookasideLists->RemoteAddrList,
        AfdAllocateRemoteAddress,
        AfdFreeRemoteAddress,
        0,
        AfdStandardAddressLength,
        AFD_REMOTE_ADDRESS_POOL_TAG,
        (USHORT)AfdBufferTagListDepth
        );

    AfdLookasideLists->TrimFlags = 0;

    //
    // Initialize group ID manager.
    //

    success = AfdInitializeGroup();
    if ( !success ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }



    //
    // Initialize the driver object for this file system driver.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = AfdDispatch;
    }
    //
    // Special case for IRP_MJ_DEVICE_CONTROL since it is
    // the most often used function in AFD.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
            AfdDispatchDeviceControl;

    DriverObject->FastIoDispatch = &AfdFastIoDispatch;
    DriverObject->DriverUnload = AfdUnload;

    //
    // Initialize our device object.
    //

    AfdDeviceObject->Flags |= DO_DIRECT_IO;
    AfdDeviceObject->StackSize = AfdIrpStackSize;

    //
    // Remember a pointer to the system process.  We'll use this pointer
    // for KeAttachProcess() calls so that we can open handles in the
    // context of the system process.
    //

    AfdSystemProcess = (PKPROCESS)IoGetCurrentProcess();

    //
    // Start notification for volatile parameters if necessary.
    //
    if (AfdParametersNotifyHandle) {
        AfdReadVolatileParameters (NULL);
    }

    //
    // Tell MM that it can page all of AFD it is desires.  We will reset
    // to normal paging of AFD code as soon as an AFD endpoint is
    // opened.
    //

    AfdLoaded = NULL;

    MmPageEntireDriver( DriverEntry );

    return (status);

error_exit:


    //
    // Terminate the group ID manager.
    //

    AfdTerminateGroup();

    if (AfdAdminSecurityDescriptor!=NULL) {
        ExFreePool (AfdAdminSecurityDescriptor);
        AfdAdminSecurityDescriptor = NULL;
    }

    if( AfdGlobalData != NULL ) {

        ExDeleteNPagedLookasideList( &AfdLookasideLists->LargeBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->MediumBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->SmallBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->BufferTagList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->TpInfoList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->RemoteAddrList );

        ExDeleteResourceLite( AfdResource );

        AFD_FREE_POOL(
            AfdGlobalData,
            AFD_RESOURCE_POOL_TAG
            );
        AfdGlobalData = NULL;

    }

    if (AfdWorkQueueItem!=NULL) {
        IoFreeWorkItem (AfdWorkQueueItem);
        AfdWorkQueueItem = NULL;
    }

    if (AfdDeviceObject!=NULL) {
        IoDeleteDevice(AfdDeviceObject);
        AfdDeviceObject = NULL;
    }

    return status;

} // DriverEntry


VOID
AfdUnload (
    IN PDRIVER_OBJECT DriverObject
    )
{

    PLIST_ENTRY listEntry;
    KEVENT      event;
    BOOLEAN     wait;

    UNREFERENCED_PARAMETER( DriverObject );

    PAGED_CODE( );

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdUnload called.\n" ));

    if (AfdParametersNotifyHandle!=NULL) {
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE );
        ZwClose (AfdParametersNotifyHandle);
        AfdParametersNotifyHandle = NULL;
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        AfdParametersUnloadEvent = &event;
        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();
    }
    //
    // Check if AFD has already cleaned up all endpoints and
    // is ready to get unloaded.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    if (AfdLoaded!=NULL) {
        //
        // Some work still needs to be done. Setup the wait.
        //
        ASSERT (AfdLoaded==(PKEVENT)1);
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        AfdLoaded = &event;
        wait = TRUE;
    }
    else
        wait = FALSE;

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    if (wait) {
        NTSTATUS    status;
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL, 
                    "AfdUnload: Waiting for endpoints to cleanup...\n"));
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (NT_SUCCESS (status));
    }

    //
    // Kill the transport info list.
    //

    while( !IsListEmpty( &AfdTransportInfoListHead ) ) {
        PAFD_TRANSPORT_INFO transportInfo;

        listEntry = RemoveHeadList( &AfdTransportInfoListHead );

        transportInfo = CONTAINING_RECORD(
                            listEntry,
                            AFD_TRANSPORT_INFO,
                            TransportInfoListEntry
                            );

        ASSERT (transportInfo->ReferenceCount == 1);


        AFD_FREE_POOL(
            transportInfo,
            AFD_TRANSPORT_INFO_POOL_TAG
            );

    }

    //
    // Free address list and associated structures
    //
    AfdDeregisterPnPHandlers (NULL);

    if (AfdAddressListLock) {

        ExDeleteResourceLite( AfdAddressListLock );

        AFD_FREE_POOL(
            AfdAddressListLock,
            AFD_RESOURCE_POOL_TAG
            );
    }

	//
	// Do some cleanup for SAN
	//
    if (IoCompletionObjectType!=NULL) {
        ObDereferenceObject (IoCompletionObjectType);
        IoCompletionObjectType = NULL;
    }

    if (AfdAdminSecurityDescriptor!=NULL) {
        ExFreePool (AfdAdminSecurityDescriptor);
        AfdAdminSecurityDescriptor = NULL;
    }

    //
    // Terminate the group ID manager.
    //

    AfdTerminateGroup();
#if DBG || REFERENCE_DEBUG
    AfdFreeDebugData ();
#endif

    //
    // Kill the lookaside lists and resouce in the global data
    //

    if( AfdGlobalData != NULL ) {

        ExDeleteNPagedLookasideList( &AfdLookasideLists->LargeBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->MediumBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->SmallBufferList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->BufferTagList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->TpInfoList );
        ExDeleteNPagedLookasideList( &AfdLookasideLists->RemoteAddrList );

        ExDeleteResourceLite( AfdResource );

        AFD_FREE_POOL(
            AfdGlobalData,
            AFD_RESOURCE_POOL_TAG
            );

    }

    //
    // Delete our device object.
    //

    IoDeleteDevice( AfdDeviceObject );

} // AfdUnload


VOID
AfdReadRegistry (
    VOID
    )

/*++

Routine Description:

    Reads the AFD section of the registry.  Any values listed in the
    registry override defaults.

Arguments:

    None.

Return Value:

    None -- if anything fails, the default value is used.

--*/
{
    HANDLE parametersHandle;
    NTSTATUS status;
    ULONG stackSize;
    ULONG priorityBoost;
    ULONG bufferAlignment;
    UNICODE_STRING registryPath;
    ULONG i;

    PAGED_CODE( );

    RtlInitUnicodeString( &registryPath, REGISTRY_AFD_INFORMATION );

    status = AfdOpenRegistry( &registryPath, &parametersHandle );

    if (status != STATUS_SUCCESS) {
        return;
    }

#if DBG
    //
    // Read the debug flags from the registry.
    //

    AfdDebug = AfdReadSingleParameter(
                   parametersHandle,
                   REGISTRY_DEBUG_FLAGS,
                   AfdDebug
                   );

    //
    // Force a breakpoint if so requested.
    //

    if( AfdReadSingleParameter(
            parametersHandle,
            REGISTRY_BREAK_ON_STARTUP,
            0 ) != 0 ) {
        DbgBreakPoint();
    }

    //
    // Enable private assert function if requested.
    //

    AfdUsePrivateAssert = AfdReadSingleParameter(
                              parametersHandle,
                              REGISTRY_USE_PRIVATE_ASSERT,
                              (LONG)AfdUsePrivateAssert
                              ) != 0;
#endif

#if AFD_PERF_DBG
    //
    // Read a flag from the registry that allows us to disable Fast IO.
    //

    AfdDisableFastIo = AfdReadSingleParameter(
                           parametersHandle,
                           REGISTRY_DISABLE_FAST_IO,
                           (LONG)AfdDisableFastIo
                           ) != 0;

    if( AfdDisableFastIo ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Fast IO disabled\n" ));

    }

    //
    // Read a flag from the registry that allows us to disable connection
    // reuse.
    //

    AfdDisableConnectionReuse = AfdReadSingleParameter(
                                    parametersHandle,
                                    REGISTRY_DISABLE_CONN_REUSE,
                                    (LONG)AfdDisableConnectionReuse
                                    ) != 0;

    if( AfdDisableConnectionReuse ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Connection Reuse disabled\n" ));

    }
#endif

    //
    // Read the stack size and priority boost values from the registry.
    //

    stackSize = AfdReadSingleParameter(
                    parametersHandle,
                    REGISTRY_IRP_STACK_SIZE,
                    (ULONG)AfdIrpStackSize
                    );

    //
    // We do not support more than 63 layers below us.
    // (The system allows for 127, but some can be sitting above us
    // as well.
    //
    if ( stackSize > 64 ) {
        stackSize = 64;
    }

    if (stackSize<2) {
        //
        // Can't be less than two since we have to call
        // at least one driver below us.
        //
        stackSize = 2;
    }

    AfdIrpStackSize = (CCHAR)stackSize;

    priorityBoost = AfdReadSingleParameter(
                        parametersHandle,
                        REGISTRY_PRIORITY_BOOST,
                        (ULONG)AfdPriorityBoost
                        );

    if ( priorityBoost > 16 ) {
        priorityBoost = AFD_DEFAULT_PRIORITY_BOOST;
    }

    AfdPriorityBoost = (CCHAR)priorityBoost;

    //
    // Read other config variables from the registry.
    //

    for ( i = 0; i < AFD_CONFIG_VAR_COUNT; i++ ) {

        *AfdConfigInfo[i].Variable =
            AfdReadSingleParameter(
                parametersHandle,
                AfdConfigInfo[i].RegistryValueName,
                *AfdConfigInfo[i].Variable
                );
    }

    //
    // Validate standard buffer sizes.
    // (we use buffer for KAPC or WORK_QUEUE_ITEM storage
    // in fast transmit file processing).
    //
    if (AfdSmallBufferSize<max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM)))
        AfdSmallBufferSize = max (sizeof(KAPC),sizeof (WORK_QUEUE_ITEM));
    if (AfdMediumBufferSize<AfdSmallBufferSize)
        AfdMediumBufferSize = AfdSmallBufferSize;
    if (AfdLargeBufferSize<AfdMediumBufferSize)
        AfdLargeBufferSize = AfdMediumBufferSize;

    AfdIgnorePushBitOnReceives = AfdReadSingleParameter(
                        parametersHandle,
                        REGISTRY_IGNORE_PUSH_BIT,
                        (LONG)AfdIgnorePushBitOnReceives
                        )!=0;


    AfdDisableRawSecurity = AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_NO_RAW_SECURITY,
                             (LONG)AfdDisableRawSecurity
                             )!=0;

    AfdDontShareAddresses = AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_NO_SHARED_ADDRESSES,
                             (LONG)AfdDontShareAddresses
                             )!=0;

    AfdDisableDirectSuperAccept = AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_NO_DIRECT_ACCEPTEX,
                             (LONG)AfdDisableDirectSuperAccept
                             )!=0;

    AfdDisableChainedReceive = AfdReadSingleParameter(
                                     parametersHandle,
                                     REGISTRY_DISABLE_CHAINED_RECV,
                                     (LONG)AfdDisableChainedReceive
                                     ) != 0;

#ifdef TDI_SERVICE_SEND_AND_DISCONNECT
    AfdUseTdiSendAndDisconnect = AfdReadSingleParameter(
                                     parametersHandle,
                                     REGISTRY_USE_TDI_SEND_AND_DISCONNECT,
                                     (LONG)AfdUseTdiSendAndDisconnect
                                     ) != 0;
#endif //TDI_SERVICE_SEND_AND_DISCONNECT
    if( MmIsThisAnNtAsSystem() ) {

        //
        // On the NT Server product, make the maximum active TransmitFile
        // count configurable. This value is fixed (not configurable) on
        // the NT Workstation product.
        //

        AfdMaxActiveTransmitFileCount = AfdReadSingleParameter(
                                            parametersHandle,
                                            REGISTRY_MAX_ACTIVE_TRANSMIT_FILE_COUNT,
                                            (LONG)AfdMaxActiveTransmitFileCount
                                            );

        //
        // Dynamic backlog is only possible on NT Server.
        //

        AfdEnableDynamicBacklog = AfdReadSingleParameter(
                                         parametersHandle,
                                         REGISTRY_ENABLE_DYNAMIC_BACKLOG,
                                         (LONG)AfdEnableDynamicBacklog
                                         ) != 0;

    } else {

        AfdEnableDynamicBacklog = FALSE;

    }

    switch (AfdDefaultTransmitWorker) {
    case AFD_TF_USE_SYSTEM_THREAD:
    case AFD_TF_USE_KERNEL_APC:
        break;
    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: Invalid TransmitWorker registry parameter value: %ld\n"
                    "AFD; Using default - %ld\n",
                    AfdDefaultTransmitWorker,
                    AFD_DEFAULT_TRANSMIT_WORKER));
        AfdDefaultTransmitWorker = AFD_DEFAULT_TRANSMIT_WORKER;
        break;

    }

    bufferAlignment = AfdReadSingleParameter(
                             parametersHandle,
                             REGISTRY_BUFFER_ALIGNMENT,
                             (LONG)AfdBufferAlignment
                             );
    if (bufferAlignment!=AfdBufferAlignment) {
        if (bufferAlignment<AFD_MINIMUM_BUFFER_ALIGNMENT ||
            bufferAlignment>PAGE_SIZE ||
            (bufferAlignment & (bufferAlignment-1))!=0) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                        "AFD: Invalid %ls registry parameter value: %ld\n"
                        "AFD; Using default - %ld\n",
                        REGISTRY_BUFFER_ALIGNMENT,
                        bufferAlignment,
                        AfdBufferAlignment));
        }
        else {
            AfdBufferAlignment = bufferAlignment;
            AfdAlignmentTableSize = AfdBufferAlignment/AFD_MINIMUM_BUFFER_ALIGNMENT;
        }
    }

    AfdVolatileConfig = AfdReadSingleParameter (
                                parametersHandle,
                                REGISTRY_VOLATILE_PARAMETERS,
                                (LONG)AfdVolatileConfig)!=0;
    if (AfdVolatileConfig) {
        AfdParametersNotifyHandle = parametersHandle;
        ExInitializeWorkItem (&AfdParametersNotifyWorker, AfdReadVolatileParameters, NULL);
    }
    else {
        ZwClose( parametersHandle );
    }

    //
    // Need to recalculate size of the page-long buffer if standard
    // address length has changed
    //
    if (AfdStandardAddressLength!=AFD_DEFAULT_STD_ADDRESS_LENGTH) {
        CLONG   oldBufferLengthForOnePage = AfdBufferLengthForOnePage;

        AfdBufferOverhead = AfdCalculateBufferSize( PAGE_SIZE, AfdStandardAddressLength) - PAGE_SIZE;
        AfdBufferLengthForOnePage = ALIGN_DOWN_A(
                                        PAGE_SIZE-AfdBufferOverhead,
                                        AFD_MINIMUM_BUFFER_ALIGNMENT);
        if (AfdLargeBufferSize==oldBufferLengthForOnePage) {
            AfdLargeBufferSize = AfdBufferLengthForOnePage;
        }
    }

    return;

} // AfdReadRegistry


NTSTATUS
AfdOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    )

/*++

Routine Description:

    This routine is called by AFD to open the registry. If the registry
    tree exists, then it opens it and returns an error. If not, it
    creates the appropriate keys in the registry, opens it, and
    returns STATUS_SUCCESS.

Arguments:

    BaseName - Where in the registry to start looking for the information.

    LinkageHandle - Returns the handle used to read linkage information.

    ParametersHandle - Returns the handle used to read other
        parameters.

Return Value:

    The status of the request.

--*/
{

    HANDLE configHandle;
    NTSTATUS status;
    PWSTR parametersString = REGISTRY_PARAMETERS;
    UNICODE_STRING parametersKeyName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE( );

    //
    // Open the registry for the initial string.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        BaseName,                   // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    status = ZwCreateKey(
                 &configHandle,
                 KEY_WRITE,
                 &objectAttributes,
                 0,                 // title index
                 NULL,              // class
                 0,                 // create options
                 &disposition       // disposition
                 );

    if (!NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Now open the parameters key.
    //

    RtlInitUnicodeString (&parametersKeyName, parametersString);

    InitializeObjectAttributes(
        &objectAttributes,
        &parametersKeyName,         // name
        OBJ_CASE_INSENSITIVE,       // attributes
        configHandle,               // root
        NULL                        // security descriptor
        );

    status = ZwOpenKey(
                 ParametersHandle,
                 KEY_READ,
                 &objectAttributes
                 );
    if (!NT_SUCCESS(status)) {

        ZwClose( configHandle );
        return status;
    }

    //
    // All keys successfully opened or created.
    //

    ZwClose( configHandle );
    return STATUS_SUCCESS;

} // AfdOpenRegistry


ULONG
AfdReadSingleParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    )

/*++

Routine Description:

    This routine is called by AFD to read a single parameter
    from the registry. If the parameter is found it is stored
    in Data.

Arguments:

    ParametersHandle - A pointer to the open registry.

    ValueName - The name of the value to search for.

    DefaultValue - The default value.

Return Value:

    The value to use; will be the default if the value is not
    found or is not in the correct range.

--*/

{
    static ULONG informationBuffer[32];   // declare ULONG to get it aligned
    PKEY_VALUE_FULL_INFORMATION information =
        (PKEY_VALUE_FULL_INFORMATION)informationBuffer;
    UNICODE_STRING valueKeyName;
    ULONG informationLength;
    LONG returnValue;
    NTSTATUS status;

    PAGED_CODE( );

    RtlInitUnicodeString( &valueKeyName, ValueName );

    status = ZwQueryValueKey(
                 ParametersHandle,
                 &valueKeyName,
                 KeyValueFullInformation,
                 (PVOID)information,
                 sizeof (informationBuffer),
                 &informationLength
                 );

    if ((status == STATUS_SUCCESS) && (information->DataLength == sizeof(ULONG))) {

        RtlMoveMemory(
            (PVOID)&returnValue,
            ((PUCHAR)information) + information->DataOffset,
            sizeof(ULONG)
            );

        if (returnValue < 0) {

            returnValue = DefaultValue;

        }
        else if (returnValue!=DefaultValue) {
            DbgPrint ("AFD: Read %ls from the registry, value: 0x%lx (%s: 0x%lx))\n",
                ValueName, returnValue, 
                AfdVolatileConfig ? "previous" : "default",
                DefaultValue);

        }

    } else {

        returnValue = DefaultValue;
    }

    return returnValue;

} // AfdReadSingleParameter


NTSTATUS
AfdBuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators, LocalSystem,
    and NetworkService principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );

    AclLength = sizeof( ACL )                    +
                3 * FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                RtlLengthSid( SeExports->SeAliasAdminsSid ) +
                RtlLengthSid( SeExports->SeLocalSystemSid ) +
                RtlLengthSid( SeExports->SeNetworkServiceSid );

    NewAcl = AFD_ALLOCATE_POOL_PRIORITY (
                 PagedPool,
                 AclLength,
                 AFD_SECURITY_POOL_TAG,
                 HighPoolPriority
                 );

    if (NewAcl == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status = RtlCreateAcl (NewAcl, AclLength, ACL_REVISION );

    if (!NT_SUCCESS( Status )) {
        AFD_FREE_POOL(
            NewAcl,
            AFD_SECURITY_POOL_TAG
            );
        return( Status );
    }

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SeExports->SeAliasAdminsSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SeExports->SeLocalSystemSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SeExports->SeNetworkServiceSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    *DeviceAcl = NewAcl;

    return( STATUS_SUCCESS );

} // AfdBuildDeviceAcl


NTSTATUS
AfdCreateSecurityDescriptor(
    VOID
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to certain priviliged accounts. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  devAcl = NULL;
    NTSTATUS              status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  afdSecurityDescriptor;
    ULONG                 afdSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR) &buffer;
    PSECURITY_DESCRIPTOR  localAfdAdminSecurityDescriptor;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;


    //
    // Get a pointer to the security descriptor from the AFD device object.
    //
    status = ObGetObjectSecurity(
                 AfdDeviceObject,
                 &afdSecurityDescriptor,
                 &memoryAllocated
                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
            "AFD: Unable to get security descriptor, error: %x\n",
            status
            ));
        ASSERT(memoryAllocated == FALSE);
        return(status);
    }

    //
    // Build a local security descriptor with an ACL giving only
    // certain priviliged accounts.
    //
    status = AfdBuildDeviceAcl(&devAcl);

    if (!NT_SUCCESS(status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: Unable to create Raw ACL, error: %x\n", status));
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
                localSecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );

    (VOID) RtlSetDaclSecurityDescriptor(
                localSecurityDescriptor,
                TRUE,
                devAcl,
                FALSE
                );

    //
    // Make a copy of the AFD descriptor. This copy will be the raw descriptor.
    //
    afdSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                      afdSecurityDescriptor
                                      );

    localAfdAdminSecurityDescriptor = ExAllocatePoolWithTag (
                                        PagedPool,
                                        afdSecurityDescriptorLength,
                                        AFD_SECURITY_POOL_TAG
                                        );

    if (localAfdAdminSecurityDescriptor == NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: couldn't allocate security descriptor\n"));
        goto error_exit;
    }

    RtlMoveMemory(
        localAfdAdminSecurityDescriptor,
        afdSecurityDescriptor,
        afdSecurityDescriptorLength
        );

    AfdAdminSecurityDescriptor = localAfdAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                 NULL,
                 &securityInformation,
                 localSecurityDescriptor,
                 &AfdAdminSecurityDescriptor,
                 PagedPool,
                 IoGetFileObjectGenericMapping()
                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AFD: SeSetSecurity failed, %lx\n",
                    status));
        ASSERT (AfdAdminSecurityDescriptor==localAfdAdminSecurityDescriptor);
        ExFreePool (AfdAdminSecurityDescriptor);
        AfdAdminSecurityDescriptor = NULL;
        goto error_exit;
    }

    if (AfdAdminSecurityDescriptor!=localAfdAdminSecurityDescriptor) {
        ExFreePool (localAfdAdminSecurityDescriptor);
    }

    status = STATUS_SUCCESS;

error_exit:

    ObReleaseObjectSecurity(
        afdSecurityDescriptor,
        memoryAllocated
        );

    if (devAcl!=NULL) {
        AFD_FREE_POOL(
            devAcl,
            AFD_SECURITY_POOL_TAG
            );
    }

    return(status);
}



VOID
AfdReadVolatileParameters (
    PVOID   Parameter
    )
{
    PAGED_CODE ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    if (AfdParametersNotifyHandle!=NULL) {
        ULONG   i;
        NTSTATUS status;
        status = ZwNotifyChangeKey (
                        AfdParametersNotifyHandle,
                        NULL,
                        (PIO_APC_ROUTINE)&AfdParametersNotifyWorker,
                        (PVOID)(UINT_PTR)(unsigned int)DelayedWorkQueue,
                        &AfdDontCareIoStatus,
                        REG_NOTIFY_CHANGE_LAST_SET,
                        FALSE,
                        NULL, 0,
                        TRUE);

        if (NT_SUCCESS (status)) {
            for ( i = 0; i < AFD_VOLATILE_CONFIG_VAR_COUNT; i++ ) {

                *AfdVolatileConfigInfo[i].Variable =
                    AfdReadSingleParameter(
                        AfdParametersNotifyHandle,
                        AfdVolatileConfigInfo[i].RegistryValueName,
                        *AfdVolatileConfigInfo[i].Variable
                        );
            }
        }
        else {
            DbgPrint (
                "AFD: Failed to start notification for volatile parameter changes, status: %lx\n",
                        status);
            ZwClose (AfdParametersNotifyHandle);
            AfdParametersNotifyHandle = NULL;
        }
    }
    else {
        ASSERT (AfdParametersUnloadEvent!=NULL);
        IoQueueWorkItem (AfdWorkQueueItem,
                            AfdReleaseRegistryHandleWait,
                            DelayedWorkQueue,
                            NULL);

    }
    ExReleaseResourceLite( AfdResource );
}


VOID
AfdReleaseRegistryHandleWait (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    ASSERT (AfdParametersUnloadEvent!=NULL);
    KeSetEvent (AfdParametersUnloadEvent, AfdPriorityBoost, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\listen.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    listen.c

Abstract:

    This module contains the handling for IOCTL_AFD_START_LISTEN
    and IOCTL_AFD_WAIT_FOR_LISTEN.

Author:

    David Treadwell (davidtr)    21-Feb-1992

Revision History:
    Vadim Eydelman (vadime)
            1998-1999 Delayed accept support, SuperAccept optimizations

--*/

#include "afdp.h"

VOID
AfdCancelWaitForListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
AfdRestartAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PAFD_CONNECT_DATA_BUFFERS
CopyConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS OriginalConnectDataBuffers
    );

BOOLEAN
CopySingleConnectDataBuffer (
    IN PAFD_CONNECT_DATA_INFO InConnectDataInfo,
    OUT PAFD_CONNECT_DATA_INFO OutConnectDataInfo
    );


NTSTATUS
AfdRestartDelayedAcceptListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdServiceWaitForListen (
    PIRP            Irp,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdStartListen )
#pragma alloc_text( PAGEAFD, AfdWaitForListen )
#pragma alloc_text( PAGEAFD, AfdServiceWaitForListen )
#pragma alloc_text( PAGEAFD, AfdCancelWaitForListen )
#pragma alloc_text( PAGEAFD, AfdConnectEventHandler )
#pragma alloc_text( PAGEAFD, AfdRestartAccept )
#pragma alloc_text( PAGEAFD, CopyConnectDataBuffers )
#pragma alloc_text( PAGEAFD, CopySingleConnectDataBuffer )
#pragma alloc_text( PAGEAFD, AfdDelayedAcceptListen )
#pragma alloc_text( PAGEAFD, AfdRestartDelayedAcceptListen )
#endif


//
// Macros to make the super accept restart code more maintainable.
//

#define AfdRestartSuperAcceptInfo   DeviceIoControl
#define AfdMdlAddress               Type3InputBuffer
#define AfdAcceptFileObject         Type3InputBuffer
#define AfdReceiveDataLength        OutputBufferLength
#define AfdRemoteAddressLength      InputBufferLength
#define AfdLocalAddressLength       IoControlCode



NTSTATUS
AfdStartListen (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )

/*++

Routine Description:

    This routine handles the IOCTL_AFD_START_LISTEN IRP, which starts
    listening for connections on an AFD endpoint.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    ULONG i;
    NTSTATUS status;
    AFD_LISTEN_INFO afdListenInfo;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Nothing to return.
    //

    *Information = 0;
    status = STATUS_SUCCESS;

    //
    // Set up local variables.
    //

    endpoint = FileObject->FsContext;

    if (InputBufferLength< sizeof (afdListenInfo)) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    try {
        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForRead (InputBuffer,
                            sizeof (afdListenInfo),
                            PROBE_ALIGNMENT(AFD_LISTEN_INFO));
        }

        //
        // Make local copies of the embeded pointer and parameters
        // that we will be using more than once in case malicios
        // application attempts to change them while we are
        // validating
        //

        afdListenInfo = *((PAFD_LISTEN_INFO)InputBuffer);

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto error_exit;
    }

    //
    // Check for if the caller is unaware of the SAN
    // provider activation and report the error.
    //
    if (!afdListenInfo.SanActive && AfdSanServiceHelper!=NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Process %p is being told to enable SAN on listen\n",
                    PsGetCurrentProcessId ()));
        status = STATUS_INVALID_PARAMETER_12;
        goto error_exit;
    }

    //
    //
    // Make sure that the backlog argument is within the legal range.
    // If it is out of range, just set it to the closest in-range
    // value--this duplicates BSD 4.3 behavior.  Note that NT Workstation
    // is tuned to have a lower backlog limit in order to conserve
    // resources on that product type.
    // (moved here from msafd.dll)
    //

    if (MmIsThisAnNtAsSystem ()) {
        if (afdListenInfo.MaximumConnectionQueue>AFD_MAXIMUM_BACKLOG_NTS)
            afdListenInfo.MaximumConnectionQueue = AFD_MAXIMUM_BACKLOG_NTS;
    }
    else {
        if (afdListenInfo.MaximumConnectionQueue>AFD_MAXIMUM_BACKLOG_NTW)
            afdListenInfo.MaximumConnectionQueue = AFD_MAXIMUM_BACKLOG_NTW;
    }

    if (afdListenInfo.MaximumConnectionQueue<AFD_MINIMUM_BACKLOG)
        afdListenInfo.MaximumConnectionQueue = AFD_MINIMUM_BACKLOG;

    if ( endpoint->Type != AfdBlockTypeEndpoint &&
        endpoint->Type != AfdBlockTypeVcConnecting) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Verify the type of the structure we are dealing with
    //
    if (!AFD_START_STATE_CHANGE (endpoint, endpoint->State)) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // Make sure that the endpoint is in the correct state.
    //

    if ( ((endpoint->State != AfdEndpointStateBound) &&
                (endpoint->State != AfdEndpointStateConnected ||
                    !endpoint->afdC_Root)) ||
            endpoint->Listening ||
            (afdListenInfo.UseDelayedAcceptance &&
                !IS_TDI_DELAYED_ACCEPTANCE(endpoint))) {
        status = STATUS_INVALID_PARAMETER;
        goto error_exit_state_change;
    }

    //
    // Initialize lists which are specific to listening endpoints.
    //

    InitializeListHead( &endpoint->Common.VcListening.UnacceptedConnectionListHead );
    InitializeListHead( &endpoint->Common.VcListening.ReturnedConnectionListHead );
    InitializeListHead( &endpoint->Common.VcListening.ListeningIrpListHead );


    ExInitializeSListHead (&endpoint->Common.VcListening.PreacceptedConnectionsListHead );

    endpoint->Common.VcListening.FailedConnectionAdds = 0;
    endpoint->Common.VcListening.Sequence = 0;
    endpoint->Common.VcListening.BacklogReplenishActive = FALSE;


    //
    // Initialize extra connection limit to that of backlog
    // We will adjust if more AcceptEx requests are enqueued.
    //
    endpoint->Common.VcListening.MaxExtraConnections = (USHORT)afdListenInfo.MaximumConnectionQueue;

    //
    // Initialize the tracking data for implementing dynamic backlog.
    //

    endpoint->Common.VcListening.TdiAcceptPendingCount = 0;

    if( AfdEnableDynamicBacklog &&
        (LONG)afdListenInfo.MaximumConnectionQueue > AfdMinimumDynamicBacklog ) {
        endpoint->Common.VcListening.EnableDynamicBacklog = TRUE;
    } else {
        endpoint->Common.VcListening.EnableDynamicBacklog = FALSE;
    }

    //
    // Set the type and state of the endpoint to listening.
    //
    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if (afdListenInfo.UseDelayedAcceptance) {
        endpoint->DelayedAcceptance = TRUE;
        InitializeListHead (&endpoint->Common.VcListening.ListenConnectionListHead);
    }
    else {
        ExInitializeSListHead (&endpoint->Common.VcListening.FreeConnectionListHead );
    }
    endpoint->Listening = TRUE;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Type |= AfdBlockTypeVcListening;

    //
    // Open a pool of connections on the specified endpoint.  The
    // connect indication handler will use these connections when
    // connect indications come in.
    //

    for ( i = 0; i < afdListenInfo.MaximumConnectionQueue; i++ ) {

        status = AfdAddFreeConnection( endpoint );

        if ( !NT_SUCCESS(status) ) {
            goto error_exit_deinit;
        }
    }

    if (!IS_DELAYED_ACCEPTANCE_ENDPOINT(endpoint)) {
        //
        // Set up a connect indication handler on the specified endpoint.
        //

        status = AfdSetEventHandler(
                     endpoint->AddressFileObject,
                     TDI_EVENT_CONNECT,
                     AfdConnectEventHandler,
                     endpoint
                     );

        if ( !NT_SUCCESS(status) ) {
            goto error_exit_deinit;
        }
    }

    AFD_END_STATE_CHANGE (endpoint);

    //
    // We're done, return to the app.
    //

    return STATUS_SUCCESS;

error_exit_deinit:

    AfdFreeQueuedConnections (endpoint);

    //
    // Reset the type and state of the endpoint.
    //

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Listening = FALSE;
    endpoint->DelayedAcceptance = FALSE;
    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    endpoint->Type &= (~(AfdBlockTypeVcListening&(~AfdBlockTypeEndpoint)));

error_exit_state_change:
    AFD_END_STATE_CHANGE (endpoint);

error_exit:
    return status;

} // AfdStartListen


NTSTATUS
FASTCALL
AfdWaitForListen (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine handles the IOCTL_AFD_WAIT_FOR_LISTEN IRP, which either
    immediately passes back to the caller a completed connection or
    waits for a connection attempt.

Arguments:

    Irp - Pointer to I/O request packet

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_LISTEN_RESPONSE_INFO listenResponse;
    NTSTATUS status;

    //
    // Set up local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;

    //
    // If the IRP comes from the app, check input data
    // (our internal super accept IRP sets MajorFunction to
    // internal device control - app can never do this)
    //
    if (IrpSp->MajorFunction!=IRP_MJ_INTERNAL_DEVICE_CONTROL) {
        //
        // Irp should at least be able to hold the header of trasport address
        //
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                (ULONG)FIELD_OFFSET (AFD_LISTEN_RESPONSE_INFO, RemoteAddress.Address[0].Address)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        listenResponse = Irp->AssociatedIrp.SystemBuffer;

        //
        // Make sure that the endpoint is in the correct state.
        //

        if ( !endpoint->Listening) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }

    //
    // Check if there is already an unaccepted connection on the
    // endpoint.  If there isn't, then we must wait until a connect
    // attempt arrives before completing this IRP.
    //
    // Note that we hold the AfdSpinLock withe doing this checking--
    // this is necessary to synchronize with our indication handler.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AfdGetUnacceptedConnection( endpoint );

    if (connection==NULL) {

        //
        // Check if endpoint was cleaned-up and cancel the request.
        //
        if (endpoint->EndpointCleanedUp) {
            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            status = STATUS_CANCELLED;
            if (IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
                AfdCleanupSuperAccept (Irp, status);
                if (Irp->Cancel) {
                    KIRQL cancelIrql;
                    //
                    // Need to sycn with cancel routine which may
                    // have been called from AfdCleanup for accepting
                    // endpoint
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }
            }
            goto complete;
        }

        //
        // There were no outstanding unaccepted connections.  Set up the
        // cancel routine in the IRP.  
        //

        IoSetCancelRoutine( Irp, AfdCancelWaitForListen );

        //
        // If the IRP has already been canceled, just complete the request.
        //

        if ( Irp->Cancel ) {

            //
            // Indicate to cancel routine that IRP is not on the list
            //
            Irp->Tail.Overlay.ListEntry.Flink = NULL;

            //
            // The IRP has already been canceled.  Just return
            // STATUS_CANCELLED.
            //

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
         
            status = STATUS_CANCELLED;
            
            if (IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
                AfdCleanupSuperAccept (Irp, status);
            }

            if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
                KIRQL cancelIrql;

                //
                // If the cancel routine was NULL then cancel routine
                // may be running.  Wait on the cancel spinlock until
                // the cancel routine is done.
                //
                // Note: The cancel routine will not find the IRP
                // since it is not in the list.
                //
                
                IoAcquireCancelSpinLock( &cancelIrql );
                IoReleaseCancelSpinLock( cancelIrql );

            }

            goto complete;
        }

        //
        // Put this IRP on the endpoint's list of listening IRPs and
        // return pending.  Note the irp may be canceled after this;
        // however, the cancel routine will be called and will cancel
        // the irp after the AfdSpinLock is released. 
        //

        IoMarkIrpPending( Irp );

        if( IrpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL ||
                IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                    IOCTL_AFD_WAIT_FOR_LISTEN_LIFO ) {

            InsertHeadList(
                &endpoint->Common.VcListening.ListeningIrpListHead,
                &Irp->Tail.Overlay.ListEntry
                );

        } else {

            InsertTailList(
                &endpoint->Common.VcListening.ListeningIrpListHead,
                &Irp->Tail.Overlay.ListEntry
                );

        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        return STATUS_PENDING;
    }

    //
    // Call the routine to service the request.
    //
    ASSERT( connection->Type == AfdBlockTypeConnection );
    status = AfdServiceWaitForListen (Irp, connection, &lockHandle);
    if (NT_SUCCESS (status)) {
        //
        // In case of success, this routine completes the Irp
        // and releases the listening endpoint spinlock.
        //
        return status;
    }

    //
    // Failure (remote address buffer to small or endpoint cleaned up)
    //
    ASSERT (status!=STATUS_PENDING);

    //
    // Put connection back to the unaccepted queue.
    //
    InsertHeadList(
        &endpoint->Common.VcListening.UnacceptedConnectionListHead,
        &connection->ListEntry
        );


    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (Irp->Cancel) {
        KIRQL cancelIrql;
        //
        // Need to sycn with cancel routine which may
        // have been called from AfdCleanup for accepting
        // endpoint
        //
        IoAcquireCancelSpinLock (&cancelIrql);
        IoReleaseCancelSpinLock (cancelIrql);
    }



complete:
    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdWaitForListen


VOID
AfdCancelWaitForListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancels a wait for listen IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/
{
    PAFD_ENDPOINT       endpoint;
    PIO_STACK_LOCATION  irpSp;
    AFD_LOCK_QUEUE_HANDLE  lockHandle;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT ( endpoint->Type==AfdBlockTypeVcListening ||
                endpoint->Type==AfdBlockTypeVcBoth );

    IF_DEBUG(LISTEN) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelWaitForListen: called on IRP %p, endpoint %p\n",
                    Irp, endpoint ));
    }

    //
    // While holding the AFD spin lock, search all listening endpoints
    // for this IRP.
    //

    ASSERT (KeGetCurrentIrql ()==DISPATCH_LEVEL);
    AfdAcquireSpinLockAtDpcLevel( &endpoint->SpinLock, &lockHandle );
    if (Irp->Tail.Overlay.ListEntry.Flink!=NULL) {
        //
        // The Irp is still in the list, remove it
        //
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        //
        // Complete the IRP with STATUS_CANCELLED and return.
        //
        if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
            //
            // Special case for super accept IRP in the listening queue.
            //
            AfdCleanupSuperAccept (Irp, STATUS_CANCELLED);
        }
        else {
            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
        }
        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
        IoReleaseCancelSpinLock( Irp->CancelIrql );



        IoCompleteRequest( Irp, AfdPriorityBoost );
    }
    else {
        //
        // The Irp was not in the list, bail
        //
        AfdReleaseSpinLockFromDpcLevel( &endpoint->SpinLock, &lockHandle );
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    }

    return;

} // AfdCancelWaitForListen


NTSTATUS
AfdConnectEventHandler (
    IN PVOID TdiEventContext,
    IN int RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN int UserDataLength,
    IN PVOID UserData,
    IN int OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    )

/*++

Routine Description:

    This is the connect event handler for listening AFD endpoints.
    It attempts to get a connection, and if successful checks whether
    there are outstanding IOCTL_WAIT_FOR_LISTEN IRPs.  If so, the
    first one is completed; if not, the connection is queued in a list of
    available, unaccepted but connected connection objects.

Arguments:

    TdiEventContext - the endpoint on which the connect attempt occurred.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    PIRP irp;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PTDI_CONNECTION_INFORMATION requestConnectionInformation;
    NTSTATUS status;
    BOOLEAN result;


    AfdRecordConnectionIndications ();

    IF_DEBUG(LISTEN) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdConnectEventHandler: called on endpoint %p\n",
                    TdiEventContext ));
    }

    //
    // Reference the endpoint so that it doesn't go away beneath us.
    //

    endpoint = TdiEventContext;
    ASSERT( endpoint != NULL );

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result) {
        AfdRecordConnectionsDropped ();
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    //
    // If the endpoint is closing, refuse to accept the connection.
    //

    if ( endpoint->State == AfdEndpointStateClosing ||
         endpoint->EndpointCleanedUp ) {

        DEREFERENCE_ENDPOINT (endpoint);
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdConnectEventHandler: Rejecting because endpoint %p is closing.\n",
                    endpoint));

        AfdRecordConnectionsDropped ();
        return STATUS_INSUFFICIENT_RESOURCES;

    }


    //
    // If there are connect data buffers on the listening endpoint,
    // create equivalent buffers that we'll use for the connection.
    //

    connectDataBuffers = NULL;

    if( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Recheck under the lock to avoid taking it in most
        // common case.
        //

        if( endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {
            connectDataBuffers = CopyConnectDataBuffers(
                                     endpoint->Common.VirtualCircuit.ConnectDataBuffers
                                     );

            if( connectDataBuffers == NULL ) {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                DEREFERENCE_ENDPOINT( endpoint );
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdConnectEventHandler:"
                            "Rejecting because connect data buffer could not be allocated (endp %p).\n",
                            endpoint));

                AfdRecordConnectionsDropped ();
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    }

    //
    // If we got connect data and/or options, save them on the connection.
    //

    if( UserData != NULL && UserDataLength > 0 ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_DATA,
                     UserData,
                     UserDataLength
                     );

        if( !NT_SUCCESS(status) ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            DEREFERENCE_ENDPOINT( endpoint );
            if ( connectDataBuffers != NULL ) {
                AfdFreeConnectDataBuffers( connectDataBuffers );
            }
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdConnectEventHandler:"
                        "Rejecting because user data buffer could not be allocated (endp %p).\n",
                        endpoint));

            AfdRecordConnectionsDropped ();
            return status;

        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    }

    if( Options != NULL && OptionsLength > 0 ) {

        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_OPTIONS,
                     Options,
                     OptionsLength
                     );

        if( !NT_SUCCESS(status) ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            DEREFERENCE_ENDPOINT( endpoint );
            if ( connectDataBuffers != NULL ) {
                AfdFreeConnectDataBuffers( connectDataBuffers );
            }
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                        "AfdConnectEventHandler:"
                        "Rejecting because option buffer could not be allocated (endp %p).\n",
                        endpoint));

            AfdRecordConnectionsDropped ();
            return status;

        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    }

    if( connectDataBuffers != NULL ) {

        //
        // We allocated extra space at the end of the connect data
        // buffers structure.  We'll use this for the
        // TDI_CONNECTION_INFORMATION structure that holds response
        // connect data and options.  Not pretty, but the fastest
        // and easiest way to accomplish this.
        //

        requestConnectionInformation =
            &connectDataBuffers->RequestConnectionInfo;

        RtlZeroMemory(
            requestConnectionInformation,
            sizeof(*requestConnectionInformation)
            );

        requestConnectionInformation->UserData =
            connectDataBuffers->SendConnectData.Buffer;
        requestConnectionInformation->UserDataLength =
            connectDataBuffers->SendConnectData.BufferLength;
        requestConnectionInformation->Options =
            connectDataBuffers->SendConnectOptions.Buffer;
        requestConnectionInformation->OptionsLength =
            connectDataBuffers->SendConnectOptions.BufferLength;

    } else {

        requestConnectionInformation = NULL;

    }

    //
    // Enforce dynamic backlog if enabled.
    //

    if( endpoint->Common.VcListening.EnableDynamicBacklog ) {

        LONG freeCount;
        LONG acceptCount;
        LONG failedCount;

        //
        // If the free connection count has dropped below the configured
        // minimum, the number of "quasi-free" connections is less than
        // the configured maximum, and we haven't already queued enough
        // requests to take us past the maximum, then add new free
        // connections to the endpoint. "Quasi-free" is defined as the
        // sum of the free connection count and the count of pending TDI
        // accepts.
        //

        freeCount = (ULONG)ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead);
        acceptCount = endpoint->Common.VcListening.TdiAcceptPendingCount;
        failedCount = endpoint->Common.VcListening.FailedConnectionAdds;

        if( freeCount < AfdMinimumDynamicBacklog &&
            ( freeCount + acceptCount ) < AfdMaximumDynamicBacklog &&
            failedCount < AfdMaximumDynamicBacklog ) {

            InterlockedExchangeAdd(
                &endpoint->Common.VcListening.FailedConnectionAdds,
                AfdMaximumDynamicBacklog
                );

            AfdInitiateListenBacklogReplenish( endpoint );

        }

    }

    //
    // Attempt to get a pre-allocated connection object to handle the
    // connection.
    //

    while ((connection = AfdGetFreeConnection( endpoint, &irp ))!=NULL) {

        IF_DEBUG(LISTEN) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdConnectEventHandler: using connection %p\n",
                        connection ));
        }

        ASSERT( connection->Type == AfdBlockTypeConnection );
        ASSERT( connection->Endpoint==NULL);

        //
        // Get the address of the target device object.
        //

        fileObject = connection->FileObject;
        ASSERT( fileObject != NULL );
        deviceObject = connection->DeviceObject;

        // We will need to store the remote address in the connection.  If the
        // connection object already has a remote address block that is
        // sufficient, use it.  Otherwise, allocate a new one.
        //

        if ( connection->RemoteAddress != NULL &&
                 connection->RemoteAddressLength < (ULONG)RemoteAddressLength ) {

            AFD_RETURN_REMOTE_ADDRESS(
                connection->RemoteAddress,
                connection->RemoteAddressLength
                );
            connection->RemoteAddress = NULL;
        }

        if ( connection->RemoteAddress == NULL ) {

            connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS(RemoteAddressLength);
            if (connection->RemoteAddress==NULL) {
                //
                // Out of memory, free the connection (to make more available memory
                // for the next allocation attempt) and continue searching.
                //
                //
                if (irp!=NULL) {
                    //
                    // Clean-up and complete the IRP.
                    //
                    AfdCleanupSuperAccept (irp, STATUS_CANCELLED);
                    if (irp->Cancel) {
                        KIRQL cancelIrql;
                        //
                        // Need to sycn with cancel routine which may
                        // have been called from AfdCleanup for accepting
                        // endpoint
                        //
                        IoAcquireCancelSpinLock (&cancelIrql);
                        IoReleaseCancelSpinLock (cancelIrql);
                    }
                    IoCompleteRequest (irp, AfdPriorityBoost);
                }
                //
                // We will need to replace the connection
                // we freed to maintain the backlog
                //
                InterlockedIncrement (
                    &endpoint->Common.VcListening.FailedConnectionAdds);
                DEREFERENCE_CONNECTION (connection);
                continue;
            }
        }

        connection->RemoteAddressLength = RemoteAddressLength;
        //
        // Check if this is a "preaccepted connection for which
        // we already have an associated endpoint and super
        // accept irp
        //
        if (irp!=NULL) {
            PIO_STACK_LOCATION irpSp;
            PAFD_ENDPOINT   acceptEndpoint;
            PFILE_OBJECT    acceptFileObject;

            irpSp = IoGetCurrentIrpStackLocation (irp);
            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;
            ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));
            ASSERT (irp->Tail.Overlay.DriverContext[0] == connection);

            //
            // Check if super accept Irp has enough space for
            // the remote address
            //
            if( (ULONG)RemoteAddressLength <=
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength ) {
                //
                // Check if we have enough system PTE's to map
                // the buffer.
                //
                status = AfdMapMdlChain (irp->MdlAddress);
                if( NT_SUCCESS (status) ) {
                    //
                    // Allocate MDL for local address query if requested
                    //
                    if ((irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength==0) ||
                            (IoAllocateMdl ((PUCHAR)irp->UserBuffer+irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength,
                                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                        TRUE,
                                        FALSE,
                                        irp)!=NULL)){
                        //
                        // Copy the remote address to user buffer
                        //
#ifndef i386
                        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                            USHORT addressLength = 
                                    ((PTRANSPORT_ADDRESS)RemoteAddress)->Address[0].AddressLength
                                    + sizeof (USHORT);
                            USHORT UNALIGNED *pAddrLength = (PVOID)
                                        ((PUCHAR)MmGetSystemAddressForMdl (irp->MdlAddress)
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                                         - sizeof (USHORT));
                            RtlMoveMemory (
                                        (PUCHAR)MmGetSystemAddressForMdl (irp->MdlAddress)
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                         &((PTRANSPORT_ADDRESS)RemoteAddress)->Address[0].AddressType,
                                         addressLength);
                            *pAddrLength = addressLength;
                        }
                        else
#endif
                        {
                            RtlMoveMemory (
                                        (PUCHAR)MmGetSystemAddressForMdl (irp->MdlAddress)
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                         + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                         RemoteAddress,
                                         RemoteAddressLength);
                        }
                        AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

                        ASSERT (acceptEndpoint->Irp==irp);

                        //
                        // Save the reference we added in the beginning of this
                        // routine
                        //
                        connection->Endpoint = endpoint;

                        //
                        // Setup the accept endpoint to match parameters
                        // of the listening endpoint from which connection
                        // is accepted (also check if accept endpoint
                        // has not been cleaned up).
                        //
                        status = AfdSetupAcceptEndpoint (endpoint, acceptEndpoint, connection);
                        if (status==STATUS_SUCCESS) {

                            //
                            // Should have been cleaned up.
                            //
                            ASSERT (acceptEndpoint->Irp == NULL);

                            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);

                            irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress =
                                    irp->MdlAddress;
                            irp->MdlAddress = NULL;

                            TdiBuildAccept(
                                irp,
                                deviceObject,
                                fileObject,
                                AfdRestartSuperAccept,
                                acceptFileObject,
                                requestConnectionInformation,
                                NULL
                                );

                            AfdRecordConnectionsPreaccepted ();
                            break;
                        }
                        else { // if (AfdSetupAcceptEndpoint==STATUS_SUCCESS)
                            AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                            connection->Endpoint = NULL;
                        }
                    } // if (IoAllocateMdl!=NULL)
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } // if (NT_SUCCESS (AfdMapMdlChain (irp->MdlAddress))
            }
            else { // if (RemoteAddressLength <= irpSp->...AfdRemoteAddressLength)
                status = STATUS_BUFFER_TOO_SMALL;
            }

            //
            // Clean-up and complete the IRP.
            //
            AfdCleanupSuperAccept (irp, status);
            if (irp->Cancel) {
                KIRQL cancelIrql;
                //
                // Need to sycn with cancel routine which may
                // have been called from AfdCleanup for accepting
                // endpoint
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            IoCompleteRequest (irp, AfdPriorityBoost);
            
            //
            // This connection has already been diassociated from endpoint.
            // If backlog is below the level we need, put it on the free
            // list, otherwise, get rid of it.
            //

            ASSERT (connection->Endpoint==NULL);
            if (endpoint->Common.VcListening.FailedConnectionAdds>=0 &&
                    status!=STATUS_INSUFFICIENT_RESOURCES &&
                    ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead)<AFD_MAXIMUM_FREE_CONNECTIONS) {
                InterlockedPushEntrySList (
                                &endpoint->Common.VcListening.FreeConnectionListHead,
                                &connection->SListEntry);
            }
            else {
                InterlockedIncrement (&endpoint->Common.VcListening.FailedConnectionAdds);
                DEREFERENCE_CONNECTION (connection);
            }

        }
        else {

            //
            // Allocate an IRP. 
            //

            irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize), FALSE );

            if ( irp != NULL ) {

                //
                // Save the address endpoint pointer in the connection.
                //

                connection->Endpoint = endpoint;

                //
                // Initialize the IRP for an accept operation.
                //

                irp->RequestorMode = KernelMode;
                irp->Tail.Overlay.Thread = PsGetCurrentThread();
                irp->Tail.Overlay.OriginalFileObject = fileObject;

                TdiBuildAccept(
                    irp,
                    deviceObject,
                    fileObject,
                    AfdRestartAccept,
                    connection,
                    requestConnectionInformation,
                    NULL
                    );
                AfdRecordConnectionsAccepted ();
                break;
            }
            else {
                //
                // Free the connection in attempt to release some
                // memory for the system.
                //
                ASSERT (connection->Endpoint==NULL);
                DEREFERENCE_CONNECTION (connection);

                //
                // We will need to replace the connection
                // we freed to maintain the backlog
                //

                InterlockedIncrement (
                    &endpoint->Common.VcListening.FailedConnectionAdds);
            }
        }
    }

    //
    // If we found connection to use for accept
    //
    if (connection!=NULL) {

        //
        // Complete IRP setup.
        //

        IoSetNextIrpStackLocation( irp );

        //
        // Set the return IRP so the transport processes this accept IRP.
        //

        *AcceptIrp = irp;

        //
        // Set up the connection context as a pointer to the connection block
        // we're going to use for this connect request.  This allows the
        // TDI provider to which connection object to use.
        //

        *ConnectionContext = (CONNECTION_CONTEXT)connection;

        //
        // Save a pointer to the connect data buffers, if any.
        //

        connection->ConnectDataBuffers = connectDataBuffers;

        //
        // Set the block state of this connection.
        //

        connection->State = AfdConnectionStateUnaccepted;

        RtlMoveMemory(
            connection->RemoteAddress,
            RemoteAddress,
            RemoteAddressLength
            );


        AFD_VERIFY_ADDRESS (connection, RemoteAddress);

        //
        // Add an additional reference to the connection.  This prevents
        // the connection from being closed until the disconnect event
        // handler is called.
        //

        AfdAddConnectedReference( connection );

        //
        // Remember that we have another TDI accept pending on this endpoint.
        //

        InterlockedIncrement(
            &endpoint->Common.VcListening.TdiAcceptPendingCount
            );


        //
        // Indicate to the TDI provider that we allocated a connection to
        // service this connect attempt.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;
    }
    else {


        if ( connectDataBuffers != NULL ) {
            AfdFreeConnectDataBuffers( connectDataBuffers );
        }

        //
        // If there have been failed connection additions, kick off
        // a request to an executive worker thread to attempt to add
        // some additional free connections.
        //

        if ( endpoint->Common.VcListening.FailedConnectionAdds > 0 ) {
            AfdInitiateListenBacklogReplenish( endpoint );
        }

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                  "AfdConnectEventHandler:"
                  "Rejecting because there are no free connection objects on endp %p.\n"
                  "                       "
                  "free %ld, pending %ld, failed %ld\n",
                  endpoint,
                  ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead),
                  endpoint->Common.VcListening.TdiAcceptPendingCount,
                  endpoint->Common.VcListening.FailedConnectionAdds));
        AfdRecordConnectionsDropped ();

        DEREFERENCE_ENDPOINT( endpoint );

        return STATUS_INSUFFICIENT_RESOURCES;
    }

} // AfdConnectEventHandler


NTSTATUS
AfdDelayedAcceptListen (
    PAFD_ENDPOINT   Endpoint,
    PAFD_CONNECTION Connection
    )
/*++

Routine Description:
    
    Posts a listen IRP on Endpoints that support delayed acceptance
    and thus cannot use connect event handler.
Arguments:

    Endpoint - listen endpoint
    Connection - connection object to accept connection on
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/
{
    PIRP irp;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PTDI_CONNECTION_INFORMATION returnConnectionInformation;
    PTDI_CONNECTION_INFORMATION requestConnectionInformation;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Allocate listen IRP
    //
    irp = IoAllocateIrp ((CCHAR)Connection->DeviceObject->StackSize, FALSE);
    if (irp==NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( Connection->RemoteAddress == NULL ) {

        Connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS(Endpoint->LocalAddressLength);
        if (Connection->RemoteAddress==NULL) {
            IoFreeIrp (irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        Connection->RemoteAddressLength = Endpoint->LocalAddressLength;
    }


    //
    // Copy connect data buffers to accept connect data in
    //

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
    if( Endpoint->Common.VirtualCircuit.ConnectDataBuffers != NULL ) {

        connectDataBuffers = CopyConnectDataBuffers(
                                 Endpoint->Common.VirtualCircuit.ConnectDataBuffers
                                 );

        if( connectDataBuffers == NULL ) {
            AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
            IoFreeIrp (irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        connectDataBuffers = AFD_ALLOCATE_POOL(
                         NonPagedPool,
                         sizeof(*connectDataBuffers),
                         AFD_CONNECT_DATA_POOL_TAG
                         );

        if ( connectDataBuffers == NULL ) {
            //
            // If listening endpoint did not have connect data buffers,
            // we cannot handle delayed connection acceptance
            //
            AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
            IoFreeIrp (irp);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlZeroMemory(
            connectDataBuffers,
            sizeof(*connectDataBuffers)
            );

    }

    Connection->ConnectDataBuffers = connectDataBuffers;

    //
    // Setup listen request parameters and sumbit it.
    // From this point on the cleanup will be handled by the
    // IRP's completion routine.
    //

    requestConnectionInformation =
        &connectDataBuffers->RequestConnectionInfo;
    
    RtlZeroMemory(
        requestConnectionInformation,
        sizeof(*requestConnectionInformation)
        );

    requestConnectionInformation->Options = &connectDataBuffers->Flags;
    connectDataBuffers->Flags = TDI_QUERY_ACCEPT;
    requestConnectionInformation->OptionsLength = sizeof (ULONG);

    
    returnConnectionInformation =
        &connectDataBuffers->ReturnConnectionInfo;

    RtlZeroMemory(
        returnConnectionInformation,
        sizeof(*returnConnectionInformation)
        );

    returnConnectionInformation->RemoteAddress = 
        Connection->RemoteAddress;
    returnConnectionInformation->RemoteAddressLength = 
        Connection->RemoteAddressLength;

    returnConnectionInformation->UserData =
        connectDataBuffers->ReceiveConnectData.Buffer;
    returnConnectionInformation->UserDataLength =
        connectDataBuffers->ReceiveConnectData.BufferLength;
    returnConnectionInformation->Options =
        connectDataBuffers->ReceiveConnectOptions.Buffer;
    returnConnectionInformation->OptionsLength =
        connectDataBuffers->ReceiveConnectOptions.BufferLength;

    //
    // Assign connection to listening endpoint and insert it
    // in the list of listen connecitons
    //
    REFERENCE_ENDPOINT (Endpoint);
    Connection->Endpoint = Endpoint;
    Connection->ListenIrp = irp;

    InsertTailList (&Endpoint->Common.VcListening.ListenConnectionListHead,
                        &Connection->ListEntry);

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );


    TdiBuildListen (
            irp, 
            Connection->DeviceObject,
            Connection->FileObject,
            AfdRestartDelayedAcceptListen,
            Connection,
            TDI_QUERY_ACCEPT,
            requestConnectionInformation,
            returnConnectionInformation
            );


    IoCallDriver (Connection->DeviceObject, irp);

    return STATUS_PENDING;
}




NTSTATUS
AfdRestartDelayedAcceptListen (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the restart routine for listening AFD endpoints on transports
    that implement delayed connection acceptance.

Arguments:

    
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    NTSTATUS    status;

    AfdRecordConnectionIndications ();

    connection = Context;

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );


    IF_DEBUG(LISTEN) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartListen: called on endpoint %p, status-%lx\n",
                    endpoint, Irp->IoStatus.Status ));
    }

    if (InterlockedExchangePointer ((PVOID *)&connection->ListenIrp, NULL)==NULL) {
        KIRQL cancelIrql;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        IoAcquireCancelSpinLock (&cancelIrql);
        IoReleaseCancelSpinLock (cancelIrql);
    }
    else {
        //
        // Remove connection from listen list.
        //
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        RemoveEntryList (&connection->ListEntry);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    status = Irp->IoStatus.Status;
    IoFreeIrp (Irp);


    if (!NT_SUCCESS (status)) {
        DEREFERENCE_CONNECTION (connection);
        //
        // We will need to replace the connection
        // we freed to maintain the backlog
        //
        InterlockedIncrement (
            &endpoint->Common.VcListening.FailedConnectionAdds);
        goto Exit;
    }
    
    //
    // Add an additional reference to the connection.  This prevents
    // the connection from being closed until the disconnect event
    // handler is called.
    //

    AfdAddConnectedReference( connection );


    //
    // If the endpoint is closing, refuse to accept the connection.
    //

    if (endpoint->State == AfdEndpointStateClosing ||
            endpoint->EndpointCleanedUp ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdRestartListen:"
                    "Rejecting because endpoint %p is closing.\n",
                    endpoint));
        goto ErrorExit;
    }



    //
    // Enforce dynamic backlog if enabled.
    //

    if( endpoint->Common.VcListening.EnableDynamicBacklog ) {

        LONG freeCount;
        LONG acceptCount;
        LONG failedCount;

        //
        // If the free connection count has dropped below the configured
        // minimum, the number of "quasi-free" connections is less than
        // the configured maximum, and we haven't already queued enough
        // requests to take us past the maximum, then add new free
        // connections to the endpoint. "Quasi-free" is defined as the
        // sum of the free connection count and the count of pending TDI
        // accepts.
        //

        freeCount = (ULONG)ExQueryDepthSList (&endpoint->Common.VcListening.FreeConnectionListHead);
        acceptCount = endpoint->Common.VcListening.TdiAcceptPendingCount;
        failedCount = endpoint->Common.VcListening.FailedConnectionAdds;

        if( freeCount < AfdMinimumDynamicBacklog &&
            ( freeCount + acceptCount ) < AfdMaximumDynamicBacklog &&
            failedCount < AfdMaximumDynamicBacklog ) {

            InterlockedExchangeAdd(
                &endpoint->Common.VcListening.FailedConnectionAdds,
                AfdMaximumDynamicBacklog
                );

            AfdInitiateListenBacklogReplenish( endpoint );

        }

    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connectDataBuffers = connection->ConnectDataBuffers;
    ASSERT (connectDataBuffers!=NULL);

    //
    // Save the remote address
    //
    if (connection->RemoteAddress != 
            connectDataBuffers->ReturnConnectionInfo.RemoteAddress) {
        //
        // Transport did not use buffer in our request but allocated
        // one of its own, we will need to copy it.
        //

        //
        // Allocate buffer is not already done or unsufficient space.
        //
        if ( connection->RemoteAddress != NULL &&
                 connection->RemoteAddressLength < (ULONG)connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength ) {

            AFD_RETURN_REMOTE_ADDRESS(
                connection->RemoteAddress,
                connection->RemoteAddressLength
                );
            connection->RemoteAddress = NULL;
        }

        if ( connection->RemoteAddress == NULL ) {

            connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS(
                        connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength);
            if (connection->RemoteAddress==NULL) {
                connection->RemoteAddressLength = 0;

                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AfdRestartListen:"
                            "Rejecting because not enough resources for remote address.\n",
                            endpoint));
                goto ErrorExit;
            }
        }

        connection->RemoteAddressLength = connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength;

        RtlMoveMemory(
            connection->RemoteAddress,
            connectDataBuffers->ReturnConnectionInfo.RemoteAddress,
            connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength
            );

    }
    else {
        //
        // They used our buffer which is the one in the connection object
        //
        ASSERT (connection->RemoteAddressLength>=(ULONG)connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength);
        connection->RemoteAddressLength = connectDataBuffers->ReturnConnectionInfo.RemoteAddressLength;
    }


    //
    // If we got connect data and/or options, save them on the connection.
    //

    if( connectDataBuffers->ReturnConnectionInfo.UserData != NULL && 
            connectDataBuffers->ReturnConnectionInfo.UserDataLength > 0 ) {


        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_DATA,
                     connectDataBuffers->ReturnConnectionInfo.UserData,
                     connectDataBuffers->ReturnConnectionInfo.UserDataLength
                     );
        if (!NT_SUCCESS (status)) {
            goto ErrorExit;
        }
    }

    if( connectDataBuffers->ReturnConnectionInfo.Options != NULL &&
            connectDataBuffers->ReturnConnectionInfo.OptionsLength > 0 ) {

        status = AfdSaveReceivedConnectData(
                     &connectDataBuffers,
                     IOCTL_AFD_SET_CONNECT_OPTIONS,
                     connectDataBuffers->ReturnConnectionInfo.Options,
                     connectDataBuffers->ReturnConnectionInfo.OptionsLength
                     );

        if (!NT_SUCCESS (status)) {
            goto ErrorExit;
        }
    }


    //
    // Set the block state of this connection.
    //

    connection->State = AfdConnectionStateUnaccepted;

    //
    // Complete IRPs until we find the one that has enough space
    // for the remote address.
    //

    while (!IsListEmpty( &endpoint->Common.VcListening.ListeningIrpListHead ) ) {
        PIRP waitForListenIrp;
        //
        // Take the first IRP off the listening list.
        //

        listEntry = RemoveHeadList(
                        &endpoint->Common.VcListening.ListeningIrpListHead
                        );

        listEntry->Flink = NULL;

        //
        // Get a pointer to the current IRP, and get a pointer to the
        // current stack lockation.
        //

        waitForListenIrp = CONTAINING_RECORD(
                               listEntry,
                               IRP,
                               Tail.Overlay.ListEntry
                               );

        IF_DEBUG(LISTEN) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartAccept: completing IRP %p\n",
                        waitForListenIrp ));
        }

        //
        // Call routine to service the IRP
        //
        status = AfdServiceWaitForListen (waitForListenIrp, connection, &lockHandle);
        if (NT_SUCCESS (status)) {
            //
            // On success this routine completes the IRP and releases
            // the endpoint spinlock
            // Return STATUS_MORE_PROCESSING_REQUIRED since we
            // already freed the IRP
            //
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        //
        // Failure (unsufficient space for remote address buffer)
        //

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        //
        // Synchronize with cancel routine if it is running
        //
        if (IoSetCancelRoutine (waitForListenIrp, NULL)==NULL) {
            KIRQL cancelIrql;
            //
            // The cancel routine won't find the IRP on the list
            // Just make sure it completes before we complete the IRP.
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        IoCompleteRequest (waitForListenIrp, AfdPriorityBoost);
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // At this point, we still hold the AFD spinlock.
    // and we could find matching listen request.
    // Put the connection on unaccepted list.
    //


    InsertTailList(
        &endpoint->Common.VcListening.UnacceptedConnectionListHead,
        &connection->ListEntry
        );

    AfdIndicateEventSelectEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there are outstanding polls waiting for a connection on this
    // endpoint, complete them.
    //

    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );

    //
    // If there have been failed connection additions, kick off
    // a request to an executive worker thread to attempt to add
    // some additional free connections.
    //

    if ( endpoint->Common.VcListening.FailedConnectionAdds > 0 ) {
        AfdInitiateListenBacklogReplenish( endpoint );
    }

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP (we already freed it above).
    //

    goto Exit;;

ErrorExit:

    AfdRecordConnectionsDropped ();

    AfdAbortConnection (connection);
    //
    // We will need to replace the connection
    // we aborted to maintain the backlog
    //
    InterlockedIncrement (
        &endpoint->Common.VcListening.FailedConnectionAdds);
Exit:
    

    return STATUS_MORE_PROCESSING_REQUIRED;
} // AfdRestartListen


NTSTATUS
AfdRestartAccept (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This is the restart routine for accept IRP that we passed back
    to the transport in connection indication handler.
    Super accept IRPs use a different restart routine.

Arguments:

    
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/


{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;
    LIST_ENTRY  irpList;
    NTSTATUS    status;

    connection = Context;
    ASSERT( connection != NULL );
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );
    ASSERT( endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    UPDATE_CONN2( connection, "Restart accept, status: %lx", Irp->IoStatus.Status );


    IF_DEBUG(ACCEPT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartAccept: accept completed, status = %X, "
                    "endpoint = %p, connection = %p\n",
                    Irp->IoStatus.Status, endpoint,
                    connection ));
    }

    //
    // Remember that a TDI accept has completed on this endpoint.
    //

    InterlockedDecrement(
        &endpoint->Common.VcListening.TdiAcceptPendingCount
        );

    //
    // If the accept failed, treat it like an abortive disconnect.
    // This way the application still gets a new endpoint, but it gets
    // told about the reset.
    //

    if ( !NT_SUCCESS(Irp->IoStatus.Status) ) {
        AfdDisconnectEventHandler(
            NULL,
            connection,
            0,
            NULL,
            0,
            NULL,
            TDI_DISCONNECT_ABORT
            );
    }


    //
    // Free the IRP now since it is no longer needed.
    //

    IoFreeIrp( Irp );

    //
    // Remember the time that the connection started.
    //

    connection->ConnectTime = KeQueryInterruptTime();

    //
    // Check whether the endpoint has been cleaned up yet.  If so, just
    // throw out this connection, since it cannot be accepted any more.
    // Also, this closes a hole between the endpoint being cleaned up
    // and all the connections that reference it being deleted.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if ( endpoint->EndpointCleanedUp ) {

        //
        // First release the locks.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Abort the connection.
        //

        AfdAbortConnection( connection );

        //
        // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
        // will stop working on the IRP.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    InitializeListHead (&irpList);

    while (1) {
        PIRP waitForListenIrp;

        //
        // First try to service an AcceptEx request
        //

        if (AfdServiceSuperAccept (endpoint, connection, &lockHandle, &irpList)) {
            //
            // This routine releases the spinlock and completes the
            // IRP
            goto CompleteIrps;
        
        }

        //
        // Complete IRPs until we find the one that has enough space
        // for the remote address.
        //
        if (IsListEmpty( &endpoint->Common.VcListening.ListeningIrpListHead ) ) {
            break;
        }



        //
        // Take the first IRP off the listening list.
        //

        listEntry = RemoveHeadList(
                        &endpoint->Common.VcListening.ListeningIrpListHead
                        );

        listEntry->Flink = NULL;

        //
        // Get a pointer to the current IRP, and get a pointer to the
        // current stack lockation.
        //

        waitForListenIrp = CONTAINING_RECORD(
                               listEntry,
                               IRP,
                               Tail.Overlay.ListEntry
                               );

        IF_DEBUG(LISTEN) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartAccept: completing IRP %p\n",
                        waitForListenIrp ));
        }

        status = AfdServiceWaitForListen (waitForListenIrp, connection, &lockHandle);
        if (NT_SUCCESS (status)) {
            //
            // On Success service routine completes the IRP and
            // releases endpoint spinlock
            //
            goto CompleteIrps;
        }
        //
        // Could not use the IRP, complete it with error
        //

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        //
        // Reset cancel routine
        //
        if (IoSetCancelRoutine (waitForListenIrp, NULL)==NULL) {
            KIRQL cancelIrql;
            //
            // It is running already, it won't find the IRP in the
            // list, just let it complete
            //
            IoAcquireCancelSpinLock (&cancelIrql);
            IoReleaseCancelSpinLock (cancelIrql);
        }
        IoCompleteRequest (waitForListenIrp, AfdPriorityBoost);

        //
        // Continue searching for IRP
        //
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // At this point, we still hold the AFD spinlock.
    // and we could find matching listen request.
    // Put the connection on unaccepted list.
    //


    InsertTailList(
        &endpoint->Common.VcListening.UnacceptedConnectionListHead,
        &connection->ListEntry
        );

    AfdIndicateEventSelectEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );
    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there are outstanding polls waiting for a connection on this
    // endpoint, complete them.
    //

    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_ACCEPT,
        STATUS_SUCCESS
        );

CompleteIrps:
    //
    // Complete previously failed accept irps if any.
    //
    while (!IsListEmpty (&irpList)) {
        PIRP    irp;
        irp = CONTAINING_RECORD (irpList.Flink, IRP, Tail.Overlay.ListEntry);
        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
        IoCompleteRequest (irp, AfdPriorityBoost);
    }

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartAccept


PAFD_CONNECT_DATA_BUFFERS
CopyConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS OriginalConnectDataBuffers
    )
{
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;

    connectDataBuffers = AFD_ALLOCATE_POOL(
                             NonPagedPool,
                             sizeof(*connectDataBuffers),
                             AFD_CONNECT_DATA_POOL_TAG
                             );

    if ( connectDataBuffers == NULL ) {
        return NULL;
    }

    RtlZeroMemory( connectDataBuffers, sizeof(*connectDataBuffers) );

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendConnectData,
              &connectDataBuffers->SendConnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendConnectOptions,
              &connectDataBuffers->SendConnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveConnectData,
              &connectDataBuffers->ReceiveConnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveConnectOptions,
              &connectDataBuffers->ReceiveConnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendDisconnectData,
              &connectDataBuffers->SendDisconnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->SendDisconnectOptions,
              &connectDataBuffers->SendDisconnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveDisconnectData,
              &connectDataBuffers->ReceiveDisconnectData ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    if ( !CopySingleConnectDataBuffer(
              &OriginalConnectDataBuffers->ReceiveDisconnectOptions,
              &connectDataBuffers->ReceiveDisconnectOptions ) ) {
        AfdFreeConnectDataBuffers( connectDataBuffers );
        return NULL;
    }

    return connectDataBuffers;

} // CopyConnectDataBuffers


BOOLEAN
CopySingleConnectDataBuffer (
    IN PAFD_CONNECT_DATA_INFO InConnectDataInfo,
    OUT PAFD_CONNECT_DATA_INFO OutConnectDataInfo
    )
{

    if ( InConnectDataInfo->Buffer != NULL &&
             InConnectDataInfo->BufferLength != 0 ) {

        OutConnectDataInfo->BufferLength = InConnectDataInfo->BufferLength;

        OutConnectDataInfo->Buffer = AFD_ALLOCATE_POOL(
                                         NonPagedPool,
                                         OutConnectDataInfo->BufferLength,
                                         AFD_CONNECT_DATA_POOL_TAG
                                         );

        if ( OutConnectDataInfo->Buffer == NULL ) {
            return FALSE;
        }

        RtlCopyMemory(
            OutConnectDataInfo->Buffer,
            InConnectDataInfo->Buffer,
            InConnectDataInfo->BufferLength
            );

    } else {

        OutConnectDataInfo->Buffer = NULL;
        OutConnectDataInfo->BufferLength = 0;
    }

    return TRUE;

} // CopySingleConnectDataBuffer


VOID
AfdEnableDynamicBacklogOnEndpoint(
    IN PAFD_ENDPOINT Endpoint,
    IN LONG ListenBacklog
    )

/*++

Routine Description:

    Determine if dynamic backlog should be enabled for the given
    endpoint using the specified listen() backlog.

Arguments:

    Endpoint - The endpoint to manipulate.

    ListenBacklog - The backlog passed into the listen() API.

Return Value:

    None.

--*/

{

    //
    // CODEWORK: For IP endpoints we could conditionally enable
    // dynamic backlog by looking up the IP Port number in a
    // database read from the registry.
    //


}   // AfdEnableDynamicBacklogOnEndpoint


NTSTATUS
AfdServiceWaitForListen (
    PIRP            Irp,
    PAFD_CONNECTION Connection,
    PAFD_LOCK_QUEUE_HANDLE LockHandle
    )
/*++

Routine Description:

    This routine verifies and completes the wait for listen
    or super accept IRP in wait for listen queue.
Arguments:

    Irp - wait for listen or super accept IRP
    Connection - connection to be accepted
    LockHandle - IRQL at which endpoint spinlock was taken
    
Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS    status;
    PAFD_ENDPOINT   listenEndpoint;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    listenEndpoint = irpSp->FileObject->FsContext;

    ASSERT( Connection->State == AfdConnectionStateUnaccepted );

    if (irpSp->MajorFunction==IRP_MJ_INTERNAL_DEVICE_CONTROL) {
        //
        // This is super accept IRP
        //
        PFILE_OBJECT  acceptFileObject;
        PAFD_ENDPOINT acceptEndpoint;

        //
        // Verify the lengh of the remote address buffer
        // and map it.
        //
        if (Connection->RemoteAddressLength>
                irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength) {
        
            status = STATUS_BUFFER_TOO_SMALL;

        }
        //
        // Check if we have enough system PTE's to map
        // the buffer.
        //
        else if ((status = AfdMapMdlChain (Irp->MdlAddress)),
                    !NT_SUCCESS (status)) {
            NOTHING;
        }
        else if (Connection->SanConnection) {
            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;

            status = AfdSanAcceptCore (Irp, acceptFileObject, Connection, LockHandle);
            if (status==STATUS_PENDING) {
                //
                // Accept IRP is pending waiting for Switch
                // completion notification
                //
                return STATUS_SUCCESS;
            }

            //
            // Continue to cleanup code
            //
            ASSERT (NT_ERROR (status));

        }
        //
        // Allocate MDL for local address query if requested
        //
        else if ((irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) &&
            (IoAllocateMdl ((PUCHAR)Irp->UserBuffer+irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength,
                            irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                            TRUE,
                            FALSE,
                            Irp)==NULL)){
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else {

            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;

            //
            // Copy over the address information to the user's buffer.
            //
#ifndef i386
            if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                USHORT addressLength = 
                        Connection->RemoteAddress->Address[0].AddressLength
                        + sizeof (USHORT);
                USHORT UNALIGNED *pAddrLength = (PVOID)
                            ((PUCHAR)MmGetSystemAddressForMdl (Irp->MdlAddress)
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                             - sizeof (USHORT));
                RtlMoveMemory (
                            (PUCHAR)MmGetSystemAddressForMdl (Irp->MdlAddress)
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                             &Connection->RemoteAddress->Address[0].AddressType,
                             addressLength);
                *pAddrLength = addressLength;
            }
            else
#endif
            {
                RtlMoveMemory (
                            (PUCHAR)MmGetSystemAddressForMdl (Irp->MdlAddress)
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                             + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                             Connection->RemoteAddress,
                             Connection->RemoteAddressLength);
            }

            //
            // Perform core accept operations
            //
            status = AfdAcceptCore (Irp, acceptEndpoint, Connection);
            if (NT_SUCCESS (status)) {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);
                //
                // Synchronize with cancel routine.
                //
                if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                    KIRQL cancelIrql;
                    //
                    // Cancel routine is running. Let it complete
                    // before doing anything else to the IRP.
                    // Note that we may end up passing cancelled IRP
                    // to the transport which should cancel it right away
                    // and destroy the connection.
                    // (we could potentially do the same in-line without
                    // calling the transport, but why - transport has
                    // to handle this anyway if it needs to pend
                    // the IRP)
                    //
                    IoAcquireCancelSpinLock (&cancelIrql);
                    IoReleaseCancelSpinLock (cancelIrql);
                }

                if (status!=STATUS_PENDING) {
                    //
                    // Make irp look like it is completed by the
                    // transport.
                    //
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress = Irp->MdlAddress;
                    Irp->MdlAddress = NULL;
                    irpSp->FileObject = acceptFileObject;

                    //
                    // Restart super accept
                    //
                    AfdRestartSuperAcceptListen (Irp, Connection);

                    status = STATUS_SUCCESS;
                }
                else {
                    //
                    // Status pending is only returned for endpoint
                    // with delayed acceptance enabled.
                    // As this is a super accept IRP, we automatically
                    // accept this connection.
                    //
                    ASSERT (IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint));
                    //
                    // Remember that a TDI accept has started on this endpoint.
                    //
                    InterlockedIncrement(
                        &listenEndpoint->Common.VcListening.TdiAcceptPendingCount
                        );
                    irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdMdlAddress = Irp->MdlAddress;
                    Irp->MdlAddress = NULL;
                    IoSetCompletionRoutine(
                            Irp,
                            AfdRestartDelayedSuperAccept,
                            acceptFileObject,
                            TRUE,
                            TRUE,
                            TRUE
                            );

                    AfdIoCallDriver (
                            acceptEndpoint,
                            Connection->DeviceObject,
                            Irp
                            );

                    status = STATUS_PENDING;
                }

                return status;
            }
        }
        //
        // Some kind of failure, cleanup super accept IRP
        //

        AfdCleanupSuperAccept (Irp, status);

    }
    else {
        //
        // Regular wait for listen IRP
        //
        PAFD_LISTEN_RESPONSE_INFO listenResponse;

        listenResponse = Irp->AssociatedIrp.SystemBuffer;

        //
        // There was a connection to use.  Set up the return buffer.
        //

        listenResponse->Sequence = Connection->Sequence;


        if( (ULONG)FIELD_OFFSET (AFD_LISTEN_RESPONSE_INFO, RemoteAddress)+
                        Connection->RemoteAddressLength >
                irpSp->Parameters.DeviceIoControl.OutputBufferLength ) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Status = status;
        }
        else {

            RtlMoveMemory(
                &listenResponse->RemoteAddress,
                Connection->RemoteAddress,
                Connection->RemoteAddressLength
                );

            Irp->IoStatus.Information =
                sizeof(*listenResponse) - sizeof(TRANSPORT_ADDRESS) +
                    Connection->RemoteAddressLength;

            //
            // Place the connection we're going to use on the endpoint's list of
            // returned connections.
            //

            InsertTailList(
                &listenEndpoint->Common.VcListening.ReturnedConnectionListHead,
                &Connection->ListEntry
                );

            //
            // Indicate in the state of this connection that it has been
            // returned to the user.
            //

            Connection->State = AfdConnectionStateReturned;
            status = STATUS_SUCCESS;
            AfdReleaseSpinLock (&listenEndpoint->SpinLock, LockHandle);
            //
            // Synchronize with cancel routine.
            //
            if ((IoSetCancelRoutine (Irp, NULL)==NULL) && Irp->Cancel) {
                KIRQL cancelIrql;
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest (Irp, AfdPriorityBoost);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\poll.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    poll.c

Abstract:

    Contains AfdPoll to handle IOCTL_AFD_POLL and code to process
    and signal poll events.

Author:

    David Treadwell (davidtr)    4-Apr-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999 NT5.0 Optimizations and 32/64 support

--*/

#include "afdp.h"

VOID
AfdCancelPoll (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdFreePollInfo (
    IN PAFD_POLL_INFO_INTERNAL PollInfoInternal
    );

VOID
AfdTimeoutPoll (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#ifdef _WIN64
NTSTATUS
AfdPoll32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
AfdSanPollApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    );

VOID
AfdSanPollApcRundownRoutine (
    IN struct _KAPC *Apc
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdPoll )
#ifdef _WIN64
#pragma alloc_text( PAGEAFD, AfdPoll32 )
#endif
#pragma alloc_text( PAGEAFD, AfdCancelPoll )
#pragma alloc_text( PAGEAFD, AfdFreePollInfo )
#pragma alloc_text( PAGEAFD, AfdTimeoutPoll )
#pragma alloc_text( PAGE, AfdSanPollApcKernelRoutine )
#pragma alloc_text( PAGE, AfdSanPollApcRundownRoutine )
#endif


NTSTATUS
FASTCALL
AfdPoll (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_POLL_INFO pollInfo;
    PAFD_POLL_HANDLE_INFO pollHandleInfo;
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    PAFD_POLL_INFO_INTERNAL freePollInfo = NULL;
    PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;
    ULONG i;
    AFD_LOCK_QUEUE_HANDLE pollLockHandle, endpointLockHandle;
    PIRP oldIrp = NULL;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        return AfdPoll32 (Irp, IrpSp);
    }
#endif
    //
    // Set up locals.
    //

    pollInfo = Irp->AssociatedIrp.SystemBuffer;
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET (AFD_POLL_INFO, Handles[0])) ||
            ((IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET (AFD_POLL_INFO, Handles[0]))/
                sizeof(pollInfo->Handles[0]) < pollInfo->NumberOfHandles) ||
            (IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                IrpSp->Parameters.DeviceIoControl.InputBufferLength)) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }


    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPoll: poll IRP %p, IrpSp %p, handles %ld, "
                    "TO %lx,%lx\n",
                      Irp, IrpSp,
                      pollInfo->NumberOfHandles,
                      pollInfo->Timeout.HighPart, pollInfo->Timeout.LowPart ));
    }

    Irp->IoStatus.Information = 0;

    //
    // Determine how large the internal poll information structure will
    // be and allocate space for it from nonpaged pool.  It must be
    // nonpaged since this will be accesses in event handlers.
    //

    try {
        pollInfoInternal = AFD_ALLOCATE_POOL_WITH_QUOTA (
                           NonPagedPool,
                           FIELD_OFFSET (AFD_POLL_INFO_INTERNAL,
                                    EndpointInfo[pollInfo->NumberOfHandles]),
                           AFD_POLL_POOL_TAG
                           );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        pollInfoInternal = NULL;
        goto complete;
    }

    //
    // Initialize the internal information buffer.
    //

    pollInfoInternal->Irp = Irp;
    pollInfoInternal->NumberOfEndpoints = 0;
    pollInfoInternal->Unique = pollInfo->Unique;
    pollInfoInternal->SanPoll = FALSE;
    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfo->NumberOfHandles; i++ ) {

        status = ObReferenceObjectByHandle(
                    pollHandleInfo->Handle,
					(IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
												// DesiredAccess
                    *IoFileObjectType,
                    Irp->RequestorMode,
                    (PVOID *)&pollEndpointInfo->FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }

        //
        // Make sure that this is an AFD endpoint and not some other
        // random file handle.
        //

        if ( pollEndpointInfo->FileObject->DeviceObject != AfdDeviceObject ) {

			//
			// Dereference last referenced object
			// The rest will be dereferenced in AfdFreePollInfo
			// as determined by NumberOfEndpoints counter which
			// is incremented below.
			//
            ObDereferenceObject( pollEndpointInfo->FileObject );
            status = STATUS_INVALID_HANDLE;
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }


        pollEndpointInfo->PollEvents = pollHandleInfo->PollEvents;
        pollEndpointInfo->Handle = pollHandleInfo->Handle;
        pollEndpointInfo->Endpoint = pollEndpointInfo->FileObject->FsContext;

        if (IS_SAN_ENDPOINT (pollEndpointInfo->Endpoint)) {
			ASSERT (pollEndpointInfo->Endpoint->State==AfdEndpointStateConnected);
            status = AfdSanPollBegin (pollEndpointInfo->Endpoint,
                                            pollEndpointInfo->PollEvents);
            if (!NT_SUCCESS (status)) {
                AfdFreePollInfo (pollInfoInternal);
                goto complete;
            }
			
            pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
            pollInfoInternal->SanPoll = TRUE;
        }

        ASSERT( InterlockedIncrement( &pollEndpointInfo->Endpoint->ObReferenceBias ) > 0 );

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll: event %lx, endp %p, conn %p, handle %p, "
                        "info %p\n",
                        pollEndpointInfo->PollEvents,
                        pollEndpointInfo->Endpoint,
                        AFD_CONNECTION_FROM_ENDPOINT( pollEndpointInfo->Endpoint ),
                        pollEndpointInfo->Handle,
                        pollEndpointInfo ));
        }

        REFERENCE_ENDPOINT( pollEndpointInfo->Endpoint );

        //
        // Increment pointers in the poll info structures.
        //

        pollHandleInfo++;
        pollEndpointInfo++;
        pollInfoInternal->NumberOfEndpoints++;
    }

restart_poll:

    //
    // Hold the AFD spin lock while we check for endpoints that already
    // satisfy a condition to synchronize between this operation and
    // a call to AfdIndicatePollEvent.  We release the spin lock
    // after all the endpoints have been checked and the internal
    // poll info structure is on the global list so AfdIndicatePollEvent
    // can find it if necessary.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    // Set up a cancel routine in the IRP so that the IRP will be
    // completed correctly if it gets canceled.  Also check whether the
    // IRP has already been canceled.
    //

    IoSetCancelRoutine( Irp, AfdCancelPoll );

    if ( Irp->Cancel ) {

        //
        // The IRP has already been canceled.  Free the internal
        // poll information structure and complete the IRP.
        //

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

        if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
            KIRQL cancelIrql;

            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            IoReleaseCancelSpinLock( cancelIrql );

        }

        AfdFreePollInfo( pollInfoInternal );

        status = STATUS_CANCELLED;
        goto complete;

    }

    //
    // If this is a unique poll, determine whether there is another
    // unique poll on this endpoint.  If there is an existing unique
    // poll, cancel it.  This request will supercede the existing
    // request.
    //

    if ( pollInfo->Unique ) {

        PLIST_ENTRY listEntry;

        for ( listEntry = AfdPollListHead.Flink;
              listEntry != &AfdPollListHead;
              listEntry = listEntry->Flink ) {

            PAFD_POLL_INFO_INTERNAL testInfo;
            BOOLEAN timerCancelSucceeded;

            testInfo = CONTAINING_RECORD(
                           listEntry,
                           AFD_POLL_INFO_INTERNAL,
                           PollListEntry
                           );

            if ( testInfo->Unique &&
                 testInfo->EndpointInfo[0].FileObject ==
                     pollInfoInternal->EndpointInfo[0].FileObject ) {

                IF_DEBUG(POLL) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdPoll: found existing unique poll IRP %p "
                                "for file object %p, context %p, cancelling.\n",
                                testInfo->Irp,
                                testInfo->EndpointInfo[0].FileObject,
                                testInfo ));
                }

                //
                // Cancel the IRP manually rather than calling
                // AfdCancelPoll because we already hold the
                // AfdSpinLock, we can't acquire it recursively, and we
                // don't want to release it.  Remove the poll structure
                // from the global list.
                //

                RemoveEntryList( &testInfo->PollListEntry );

                //
                // Cancel the timer.
                //

                if ( testInfo->TimerStarted ) {
                    timerCancelSucceeded = KeCancelTimer( &testInfo->Timer );
                } else {
                    timerCancelSucceeded = TRUE;
                }

                //
                // Complete the IRP with STATUS_CANCELLED as the status.
                //

                testInfo->Irp->IoStatus.Information = 0;
                testInfo->Irp->IoStatus.Status = STATUS_CANCELLED;

                oldIrp = testInfo->Irp;

                //
                // Remember the poll info structure so that we'll free
                // before we exit.  We cannot free it now because we're
                // holding the AfdSpinLock.  Note that if cancelling the
                // timer failed, then the timer is already running and
                // it will free the poll info structure, but not
                // complete the IRP since we complete it and NULL it
                // here.
                //

                if ( timerCancelSucceeded ) {
                    freePollInfo = testInfo;
                } else {
                    pollInfoInternal->Irp = NULL;
                }

                //
                // There should be only one outstanding unique poll IRP
                // on any given file object, so quit looking for another
                // now that we've found one.
                //

                break;
            }
        }
    }

    //
    // We're done with the input structure provided by the caller.  Now
    // walk through the internal structure and determine whether any of
    // the specified endpoints are ready for the specified condition.
    //

    pollInfo->NumberOfHandles = 0;

    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfoInternal->NumberOfEndpoints; i++ ) {

        BOOLEAN found;
        PAFD_ENDPOINT endpoint;
        PAFD_CONNECTION connection;

        found = FALSE;
        endpoint = pollEndpointInfo->Endpoint;
        ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

        AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

        //
        // Remember that there has been a poll on this endpoint.  This flag
        // allows us to optimize AfdIndicatePollEvent() for endpoints that have
        // never been polled, which is a common case.
        //

        endpoint->PollCalled = TRUE;

        connection = AFD_CONNECTION_FROM_ENDPOINT( endpoint );
        ASSERT( connection == NULL || connection->Type == AfdBlockTypeConnection );

        pollHandleInfo->PollEvents = 0;
        pollHandleInfo->Status = STATUS_SUCCESS;

        if (IS_SAN_ENDPOINT (endpoint)) {
            if (endpoint->Common.SanEndp.SelectEventsActive & pollEndpointInfo->PollEvents) {

                pollHandleInfo->Handle = pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents = pollEndpointInfo->PollEvents
                                             & endpoint->Common.SanEndp.SelectEventsActive;
                found = TRUE;

            }
            else if (!found &&
                        (pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED)==0) {
                //
                // OOPS, endpoint has been converted too SAN while we were looping,
                // need to release the spinlock, update switch counts, and restart
                // the loop.  We don't do this is we are about to return anyway.
                //

                AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
                AfdReleaseSpinLock (&AfdPollListLock, &pollLockHandle);
                //
                // First see if IRP was cancelled.
                //
                if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
                    KIRQL cancelIrql;

                    //
                    // If the cancel routine was NULL then cancel routine
                    // may be running.  Wait on the cancel spinlock until
                    // the cancel routine is done.
                    //
                    // Note: The cancel routine will not find the IRP
                    // since it is not in the list.
                    //
            
                    IoAcquireCancelSpinLock( &cancelIrql );
                    IoReleaseCancelSpinLock( cancelIrql );

                    AfdFreePollInfo( pollInfoInternal );

                    status = STATUS_CANCELLED;
                    goto complete;
                }

			    ASSERT (endpoint->State==AfdEndpointStateConnected);
                status = AfdSanPollBegin (endpoint,
                                                pollEndpointInfo->PollEvents);
                if (!NT_SUCCESS (status)) {
                    AfdFreePollInfo (pollInfoInternal);
                    goto complete;
                }
			    
                pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
                pollInfoInternal->SanPoll = TRUE;

                //
                //  Complete any old poll irps.
                //

                if ( oldIrp != NULL ) {

                    if (IoSetCancelRoutine( oldIrp, NULL ) == NULL) {
                        KIRQL cancelIrql;
    
                        //
                        // If the cancel routine was NULL then cancel routine
                        // may be running.  Wait on the cancel spinlock until
                        // the cancel routine is done.
                        //
                        // Note: The cancel routine will not find the IRP
                        // since it is not in the list.
                        //
            
                        IoAcquireCancelSpinLock( &cancelIrql );
                        ASSERT( oldIrp->Cancel );
                        IoReleaseCancelSpinLock( cancelIrql );
    
                    }

                    if (freePollInfo->SanPoll && 
                            (oldIrp->Tail.Overlay.Thread!=PsGetCurrentThread ())) {
                        KeInitializeApc (&freePollInfo->Apc,
                                            PsGetThreadTcb (oldIrp->Tail.Overlay.Thread),
                                            oldIrp->ApcEnvironment,
                                            AfdSanPollApcKernelRoutine,
                                            AfdSanPollApcRundownRoutine,
                                            (PKNORMAL_ROUTINE)-1,
                                            KernelMode,
                                            NULL);
                        if (KeInsertQueueApc (&freePollInfo->Apc,
                                                freePollInfo,
                                                oldIrp,
                                                AfdPriorityBoost)) {
                            return STATUS_PENDING;
                        }
                        else {
                            freePollInfo->SanPoll = FALSE;
                        }
                    }
                    //
                    // If we need to free a cancelled poll info structure, do it now.
                    //
    
                    if ( freePollInfo != NULL ) {
                        AfdFreePollInfo( freePollInfo );
                    }
    
                    IoCompleteRequest( oldIrp, AfdPriorityBoost );
                    oldIrp = NULL;
                }
                goto restart_poll;
            }
        }
        else {

			//
			// Check each possible event and, if it is being polled, whether
			// the endpoint is ready for that event.  If the endpoint is
			// ready, write information about the endpoint into the output
			// buffer.
			//

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_RECEIVE) != 0 ) {

				//
				// For most endpoints, a receive poll is completed when
				// data arrived that does not have a posted receive.
				// For listening endpoints, however, a receive poll
				// completes when there is a connection available to be
				// accepted.
				//

				if ( !endpoint->Listening ) {

					if ( (connection != NULL &&
							 IS_DATA_ON_CONNECTION( connection )) ||

						 (IS_DGRAM_ENDPOINT(endpoint) &&
							 ARE_DATAGRAMS_ON_ENDPOINT( endpoint )) ) {

						pollHandleInfo->Handle = pollEndpointInfo->Handle;
						pollHandleInfo->PollEvents |= AFD_POLL_RECEIVE;
						found = TRUE;
					}

					//
					// If the endpoint is set up for inline reception of
					// expedited data, then any expedited data should
					// be indicated as normal data.
					//

					if ( connection != NULL && endpoint->InLine &&
							 IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
						pollHandleInfo->Handle = pollEndpointInfo->Handle;
						pollHandleInfo->PollEvents |= AFD_POLL_RECEIVE;
						found = TRUE;
					}

				} else {

					if (!pollInfo->Unique) {
						//
						// This is really a poll to see whether a connection is
						// available for an immediate accept.  Convert the events
						// and do the check below in the accept poll handling.
						//

						pollEndpointInfo->PollEvents &= ~AFD_POLL_RECEIVE;
						pollEndpointInfo->PollEvents |= AFD_POLL_ACCEPT;
					}
					//
					// Unique polls (e.g. WSAAsyncSelect) set poll necessary
					// bits themselves.
					//
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_RECEIVE_EXPEDITED) != 0 ) {

				//
				// If the endpoint is set up for inline reception of
				// expedited data, do not indicate as expedited data.
				//

				if ( connection != NULL && !endpoint->InLine &&
						 IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
					pollHandleInfo->Handle = pollEndpointInfo->Handle;
					pollHandleInfo->PollEvents |= AFD_POLL_RECEIVE_EXPEDITED;
					found = TRUE;
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_SEND) != 0 ) {

				//
				// For unconnected non-datagram endpoints, a send poll
				// should complete when a connect operation completes.
				// Therefore, if this is an non-datagram endpoint which is
				// not connected, do not complete the poll until the connect
				// completes.
				//

				if ( endpoint->State == AfdEndpointStateConnected ||
						 IS_DGRAM_ENDPOINT(endpoint) ) {

					//
					// For nonbufferring VC
					// endpoints, check whether a blocking error has
					// occurred.  If so, it will not be possible to do a
					// nonblocking send until a send possible indication
					// arrives.
					//
					// For bufferring endpoints (TDI provider does not
					// buffer), check whether we have too much send data
					// outstanding.
					//

					if ( (IS_DGRAM_ENDPOINT(endpoint) &&
							   (endpoint->DgBufferredSendBytes <
								   endpoint->Common.Datagram.MaxBufferredSendBytes ||
                                endpoint->DgBufferredSendBytes == 0))

						 ||

						 ((connection!=NULL) &&

							 (( IS_TDI_BUFFERRING(endpoint) &&
								   connection->VcNonBlockingSendPossible )

							 ||

							 ( !IS_TDI_BUFFERRING(endpoint) &&
								   (connection->VcBufferredSendBytes <
									   connection->MaxBufferredSendBytes ||
                                    connection->VcBufferredSendBytes == 0))

							 ||

							 connection->AbortIndicated )) ){

						pollHandleInfo->Handle = pollEndpointInfo->Handle;
						pollHandleInfo->PollEvents |= AFD_POLL_SEND;
						found = TRUE;

					}
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_ACCEPT) != 0 ) {

				if ( (endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening &&
						 !IsListEmpty( &endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
					pollHandleInfo->Handle = pollEndpointInfo->Handle;
					pollHandleInfo->PollEvents |= AFD_POLL_ACCEPT;
					found = TRUE;
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_CONNECT) != 0 ) {

				//
				// If the endpoint is now connected, complete this event.
				//

				if ( endpoint->State == AfdEndpointStateConnected ) {

					ASSERT( NT_SUCCESS(endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT]) );
					pollHandleInfo->Handle = pollEndpointInfo->Handle;
					pollHandleInfo->PollEvents |= AFD_POLL_CONNECT;
					found = TRUE;
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_CONNECT_FAIL) != 0 ) {

				//
				// This is a poll to see whether a connect has failed
				// recently.  The connect status must indicate an error.
				//

				if ( endpoint->State == AfdEndpointStateBound &&
						!NT_SUCCESS(endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT]) ) {

					pollHandleInfo->Handle = pollEndpointInfo->Handle;
					pollHandleInfo->PollEvents |= AFD_POLL_CONNECT_FAIL;
					pollHandleInfo->Status =
						endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT];
					found = TRUE;
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_DISCONNECT) != 0 ) {

				if ( connection != NULL && connection->DisconnectIndicated ) {
					pollHandleInfo->Handle = pollEndpointInfo->Handle;
					pollHandleInfo->PollEvents |= AFD_POLL_DISCONNECT;
					found = TRUE;
				}
			}

			if ( (pollEndpointInfo->PollEvents & AFD_POLL_ABORT) != 0 ) {

				if ( connection != NULL && connection->AbortIndicated ) {
					pollHandleInfo->Handle = pollEndpointInfo->Handle;
					pollHandleInfo->PollEvents |= AFD_POLL_ABORT;
					found = TRUE;
				}
			}

        }

        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

        //
        // If the handle had a current event that was requested, update
        // the count of handles in the output buffer and increment the
        // pointer to the output buffer.
        //

        if ( found ) {
            pollInfo->NumberOfHandles++;
            pollHandleInfo++;
        }

        pollEndpointInfo++;
    }

    //
    // If we found any endpoints that are ready, free the poll information
    // structure and complete the request.
    //

    if ( pollInfo->NumberOfHandles > 0 ) {

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    //
    // None of the endpoints are in the correct state.  If a timeout was
    // specified, place the poll information on the global list and set
    // up a DPC and timer so that we know when to complete the IRP.
    //

    if ( pollInfo->Timeout.LowPart != 0 && pollInfo->Timeout.HighPart != 0 ) {

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll: no current events for poll IRP %p, "
                        "info %p\n", Irp, pollInfoInternal ));
        }

        //
        // Set up the information field of the IO status block to indicate
        // that an output buffer with no handles should be returned.
        // AfdIndicatePollEvent will modify this if necessary.
        //

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;

        //
        // Put a pointer to the internal poll info struct into the IRP
        // so that the cancel routine can find it.
        //

        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pollInfoInternal;

        //
        // Place the internal poll info struct on the global list.
        //

        InsertTailList( &AfdPollListHead, &pollInfoInternal->PollListEntry );

        //
        // If the timeout is infinite, then don't set up a timer and
        // DPC.  Otherwise, set up a timer so we can timeout the poll
        // request if appropriate.
        //

        if ( pollInfo->Timeout.HighPart != 0x7FFFFFFF ) {

            pollInfoInternal->TimerStarted = TRUE;

            KeInitializeDpc(
                &pollInfoInternal->Dpc,
                AfdTimeoutPoll,
                pollInfoInternal
                );

            KeInitializeTimer( &pollInfoInternal->Timer );

            KeSetTimer(
                &pollInfoInternal->Timer,
                pollInfo->Timeout,
                &pollInfoInternal->Dpc
                );

        } else {

            pollInfoInternal->TimerStarted = FALSE;
        }

    } else {

        //
        // A timeout equal to 0 was specified; free the internal
        // structure and complete the request with no endpoints in the
        // output buffer.
        //

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll: zero timeout on poll IRP %p and no "
                        "current events--completing.\n", Irp ));
        }

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    //
    // Mark the IRP pending and release the spin locks.  At this
    // point the IRP may get completed or cancelled.
    //

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        if (IoSetCancelRoutine( oldIrp, NULL ) == NULL) {
            KIRQL cancelIrql;
    
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( oldIrp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
    
        }

        if (freePollInfo->SanPoll && 
                (oldIrp->Tail.Overlay.Thread!=PsGetCurrentThread ())) {
            KeInitializeApc (&freePollInfo->Apc,
                                PsGetThreadTcb (oldIrp->Tail.Overlay.Thread),
                                oldIrp->ApcEnvironment,
                                AfdSanPollApcKernelRoutine,
                                AfdSanPollApcRundownRoutine,
                                (PKNORMAL_ROUTINE)-1,
                                KernelMode,
                                NULL);
            if (KeInsertQueueApc (&freePollInfo->Apc,
                                    freePollInfo,
                                    oldIrp,
                                    AfdPriorityBoost)) {
                return STATUS_PENDING;
            }
            else {
                freePollInfo->SanPoll = FALSE;
            }
        }

        //
        // If we need to free a cancelled poll info structure, do it now.
        //
    
        if ( freePollInfo != NULL ) {
            AfdFreePollInfo( freePollInfo );
        }
    
        IoCompleteRequest( oldIrp, AfdPriorityBoost );
    
    }

    //
    // Return pending.  The IRP will be completed when an appropriate
    // event is indicated by the TDI provider, when the timeout is hit,
    // or when the IRP is cancelled.
    //

    return STATUS_PENDING;

complete:

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        if (IoSetCancelRoutine( oldIrp, NULL ) == NULL) {
            KIRQL cancelIrql;
    
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( oldIrp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
    
        }
    
        if (freePollInfo->SanPoll && 
                (oldIrp->Tail.Overlay.Thread!=PsGetCurrentThread ())) {
            KeInitializeApc (&freePollInfo->Apc,
                                PsGetThreadTcb (oldIrp->Tail.Overlay.Thread),
                                oldIrp->ApcEnvironment,
                                AfdSanPollApcKernelRoutine,
                                AfdSanPollApcRundownRoutine,
                                (PKNORMAL_ROUTINE)-1,
                                KernelMode,
                                NULL);
            if (KeInsertQueueApc (&freePollInfo->Apc,
                                    freePollInfo,
                                    oldIrp,
                                    AfdPriorityBoost)) {
                goto continue_complete;
            }
            else {
                freePollInfo->SanPoll = FALSE;
            }
        }

        //
        // If we need to free a cancelled poll info structure, do it now.
        //
    
        if ( freePollInfo != NULL ) {
            AfdFreePollInfo( freePollInfo );
        }
    
        IoCompleteRequest( oldIrp, AfdPriorityBoost );
    
    }

continue_complete:

    Irp->IoStatus.Status = status;

    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
        KIRQL cancelIrql;

        //
        // If the cancel routine was NULL then cancel routine
        // may be running.  Wait on the cancel spinlock until
        // the cancel routine is done.
        //
        // Note: The cancel routine will not find the IRP
        // since it is not in the list.
        //
        
        IoAcquireCancelSpinLock( &cancelIrql );
        // ASSERT( Irp->Cancel ); the cancel routine may have not been set
        IoReleaseCancelSpinLock( cancelIrql );

    }

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdPoll

#ifdef _WIN64

NTSTATUS
AfdPoll32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PAFD_POLL_INFO32 pollInfo;
    PAFD_POLL_HANDLE_INFO32 pollHandleInfo;
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    PAFD_POLL_INFO_INTERNAL freePollInfo = NULL;
    PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;
    ULONG i;
    AFD_LOCK_QUEUE_HANDLE pollLockHandle, endpointLockHandle;
    PIRP oldIrp = NULL;

    //
    // Set up locals.
    //

    pollInfo = Irp->AssociatedIrp.SystemBuffer;
    if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength<
                (ULONG)FIELD_OFFSET (AFD_POLL_INFO32, Handles[0])) ||
            ((IrpSp->Parameters.DeviceIoControl.InputBufferLength -
                        FIELD_OFFSET (AFD_POLL_INFO32, Handles[0]))/
                sizeof(pollInfo->Handles[0]) < pollInfo->NumberOfHandles) ||
            (IrpSp->Parameters.DeviceIoControl.OutputBufferLength<
                IrpSp->Parameters.DeviceIoControl.InputBufferLength)) {

        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }


    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdPoll32: poll IRP %p, IrpSp %p, handles %ld, "
                    "TO %lx,%lx\n",
                    Irp, IrpSp,
                    pollInfo->NumberOfHandles,
                    pollInfo->Timeout.HighPart, pollInfo->Timeout.LowPart ));
    }

    Irp->IoStatus.Information = 0;

    //
    // Determine how large the internal poll information structure will
    // be and allocate space for it from nonpaged pool.  It must be
    // nonpaged since this will be accesses in event handlers.
    //

    try {
        pollInfoInternal = AFD_ALLOCATE_POOL_WITH_QUOTA(
                           NonPagedPool,
                           FIELD_OFFSET (AFD_POLL_INFO_INTERNAL,
                                EndpointInfo[pollInfo->NumberOfHandles]),
                           AFD_POLL_POOL_TAG
                           );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        pollInfoInternal = NULL;
        goto complete;
    }

    //
    // Initialize the internal information buffer.
    //

    pollInfoInternal->Irp = Irp;
    pollInfoInternal->NumberOfEndpoints = 0;
    pollInfoInternal->Unique = pollInfo->Unique;
    pollInfoInternal->SanPoll = FALSE;

    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfo->NumberOfHandles; i++ ) {

        status = ObReferenceObjectByHandle(
                    pollHandleInfo->Handle,
					(IrpSp->Parameters.DeviceIoControl.IoControlCode>>14) & 3,
												// DesiredAccess
                    *IoFileObjectType,
                    Irp->RequestorMode,
                    (PVOID *)&pollEndpointInfo->FileObject,
                    NULL
                    );

        if ( !NT_SUCCESS(status) ) {
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }

        //
        // Make sure that this is an AFD endpoint and not some other
        // random file handle.
        //

        if ( pollEndpointInfo->FileObject->DeviceObject != AfdDeviceObject ) {

			//
			// Dereference last referenced object
			// The rest will be dereferenced in AfdFreePollInfo
			// as determined by NumberOfEndpoints counter which
			// is incremented below.
			//
            ObDereferenceObject( pollEndpointInfo->FileObject );
            status = STATUS_INVALID_HANDLE;
            AfdFreePollInfo( pollInfoInternal );
            goto complete;
        }

        pollEndpointInfo->PollEvents = pollHandleInfo->PollEvents;
        pollEndpointInfo->Handle = pollHandleInfo->Handle;
        pollEndpointInfo->Endpoint = pollEndpointInfo->FileObject->FsContext;

        ASSERT( InterlockedIncrement( &pollEndpointInfo->Endpoint->ObReferenceBias ) > 0 );

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll32: event %lx, endp %p, conn %p, handle %p, "
                        "info %p\n",
                        pollEndpointInfo->PollEvents,
                        pollEndpointInfo->Endpoint,
                        AFD_CONNECTION_FROM_ENDPOINT( pollEndpointInfo->Endpoint ),
                        pollEndpointInfo->Handle,
                        pollEndpointInfo ));
        }

        REFERENCE_ENDPOINT( pollEndpointInfo->Endpoint );

        //
        // Increment pointers in the poll info structures.
        //

        pollHandleInfo++;
        pollEndpointInfo++;
        pollInfoInternal->NumberOfEndpoints++;
    }

    //
    // Hold the AFD spin lock while we check for endpoints that already
    // satisfy a condition to synchronize between this operation and
    // a call to AfdIndicatePollEvent.  We release the spin lock
    // after all the endpoints have been checked and the internal
    // poll info structure is on the global list so AfdIndicatePollEvent
    // can find it if necessary.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    // Set up a cancel routine in the IRP so that the IRP will be
    // completed correctly if it gets canceled.  Also check whether the
    // IRP has already been canceled.
    //

    IoSetCancelRoutine( Irp, AfdCancelPoll );

    if ( Irp->Cancel ) {

        //
        // The IRP has already been canceled.  Free the internal
        // poll information structure and complete the IRP.
        //

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

        if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
            KIRQL cancelIrql;

            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            IoReleaseCancelSpinLock( cancelIrql );

        }

        AfdFreePollInfo( pollInfoInternal );

        status = STATUS_CANCELLED;
        goto complete;

    }

    //
    // If this is a unique poll, determine whether there is another
    // unique poll on this endpoint.  If there is an existing unique
    // poll, cancel it.  This request will supercede the existing
    // request.
    //

    if ( pollInfo->Unique ) {

        PLIST_ENTRY listEntry;

        for ( listEntry = AfdPollListHead.Flink;
              listEntry != &AfdPollListHead;
              listEntry = listEntry->Flink ) {

            PAFD_POLL_INFO_INTERNAL testInfo;
            BOOLEAN timerCancelSucceeded;

            testInfo = CONTAINING_RECORD(
                           listEntry,
                           AFD_POLL_INFO_INTERNAL,
                           PollListEntry
                           );

            if ( testInfo->Unique &&
                 testInfo->EndpointInfo[0].FileObject ==
                     pollInfoInternal->EndpointInfo[0].FileObject ) {

                IF_DEBUG(POLL) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdPoll32: found existing unique poll IRP %p "
                                "for file object %p, context %p, cancelling.\n",
                                testInfo->Irp,
                                testInfo->EndpointInfo[0].FileObject,
                                testInfo ));
                }

                //
                // Cancel the IRP manually rather than calling
                // AfdCancelPoll because we already hold the
                // AfdSpinLock, we can't acquire it recursively, and we
                // don't want to release it.  Remove the poll structure
                // from the global list.
                //

                RemoveEntryList( &testInfo->PollListEntry );

                //
                // Cancel the timer.
                //

                if ( testInfo->TimerStarted ) {
                    timerCancelSucceeded = KeCancelTimer( &testInfo->Timer );
                } else {
                    timerCancelSucceeded = TRUE;
                }

                //
                // Complete the IRP with STATUS_CANCELLED as the status.
                //

                testInfo->Irp->IoStatus.Information = 0;
                testInfo->Irp->IoStatus.Status = STATUS_CANCELLED;

                oldIrp = testInfo->Irp;

                //
                // Remember the poll info structure so that we'll free
                // before we exit.  We cannot free it now because we're
                // holding the AfdSpinLock.  Note that if cancelling the
                // timer failed, then the timer is already running and
                // it will free the poll info structure, but not
                // complete the IRP since we complete it and NULL it
                // here.
                //

                if ( timerCancelSucceeded ) {
                    freePollInfo = testInfo;
                } else {
                    pollInfoInternal->Irp = NULL;
                }

                //
                // There should be only one outstanding unique poll IRP
                // on any given file object, so quit looking for another
                // now that we've found one.
                //

                break;
            }
        }
    }

    //
    // We're done with the input structure provided by the caller.  Now
    // walk through the internal structure and determine whether any of
    // the specified endpoints are ready for the specified condition.
    //

    pollInfo->NumberOfHandles = 0;

    pollHandleInfo = pollInfo->Handles;
    pollEndpointInfo = pollInfoInternal->EndpointInfo;

    for ( i = 0; i < pollInfoInternal->NumberOfEndpoints; i++ ) {

        BOOLEAN found;
        PAFD_ENDPOINT endpoint;
        PAFD_CONNECTION connection;

        found = FALSE;
        endpoint = pollEndpointInfo->Endpoint;
        ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

        AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

        //
        // Remember that there has been a poll on this endpoint.  This flag
        // allows us to optimize AfdIndicatePollEvent() for endpoints that have
        // never been polled, which is a common case.
        //

        endpoint->PollCalled = TRUE;

        connection = AFD_CONNECTION_FROM_ENDPOINT( endpoint );
        ASSERT( connection == NULL || connection->Type == AfdBlockTypeConnection );

        pollHandleInfo->PollEvents = 0;
        pollHandleInfo->Status = STATUS_SUCCESS;

        //
        // Check each possible event and, if it is being polled, whether
        // the endpoint is ready for that event.  If the endpoint is
        // ready, write information about the endpoint into the output
        // buffer.
        //

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_RECEIVE) != 0 ) {

            //
            // For most endpoints, a receive poll is completed when
            // data arrived that does not have a posted receive.
            // For listening endpoints, however, a receive poll
            // completes when there is a connection available to be
            // accepted.
            //

            if ( !endpoint->Listening ) {

                if ( (connection != NULL &&
                         IS_DATA_ON_CONNECTION( connection )) ||

                     (IS_DGRAM_ENDPOINT(endpoint) &&
                         ARE_DATAGRAMS_ON_ENDPOINT( endpoint )) ) {

                    pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                    pollHandleInfo->PollEvents |= AFD_POLL_RECEIVE;
                    found = TRUE;
                }

                //
                // If the endpoint is set up for inline reception of
                // expedited data, then any expedited data should
                // be indicated as normal data.
                //

                if ( connection != NULL && endpoint->InLine &&
                         IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
                    pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                    pollHandleInfo->PollEvents |= AFD_POLL_RECEIVE;
                    found = TRUE;
                }

            } else {

                if (!pollInfo->Unique) {
                    //
                    // This is really a poll to see whether a connection is
                    // available for an immediate accept.  Convert the events
                    // and do the check below in the accept poll handling.
                    //

                    pollEndpointInfo->PollEvents &= ~AFD_POLL_RECEIVE;
                    pollEndpointInfo->PollEvents |= AFD_POLL_ACCEPT;
                }
                //
                // Unique polls (e.g. WSAAsyncSelect) set poll necessary
                // bits themselves.
                //
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_RECEIVE_EXPEDITED) != 0 ) {

            //
            // If the endpoint is set up for inline reception of
            // expedited data, do not indicate as expedited data.
            //

            if ( connection != NULL && !endpoint->InLine &&
                     IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {
                pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents |= AFD_POLL_RECEIVE_EXPEDITED;
                found = TRUE;
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_SEND) != 0 ) {

            //
            // For unconnected non-datagram endpoints, a send poll
            // should complete when a connect operation completes.
            // Therefore, if this is an non-datagram endpoint which is
            // not connected, do not complete the poll until the connect
            // completes.
            //

            if ( endpoint->State == AfdEndpointStateConnected ||
                     IS_DGRAM_ENDPOINT(endpoint) ) {

                //
                // It should always be possible to do a nonblocking send
                // on a datagram endpoint.  For nonbufferring VC
                // endpoints, check whether a blocking error has
                // occurred.  If so, it will not be possible to do a
                // nonblocking send until a send possible indication
                // arrives.
                //
                // For bufferring endpoints (TDI provider does not
                // buffer), check whether we have too much send data
                // outstanding.
                //

                if ( (IS_DGRAM_ENDPOINT(endpoint) &&
                           (endpoint->DgBufferredSendBytes <
                               endpoint->Common.Datagram.MaxBufferredSendBytes ||
                            endpoint->DgBufferredSendBytes == 0))

                     ||

                     ((connection!=NULL) &&

                         (( IS_TDI_BUFFERRING(endpoint) &&
                               connection->VcNonBlockingSendPossible )

                         ||

                         ( !IS_TDI_BUFFERRING(endpoint) &&
                               (connection->VcBufferredSendBytes <
                                   connection->MaxBufferredSendBytes ||
                                connection->VcBufferredSendBytes == 0))

                         ||

                         connection->AbortIndicated )) ){

                    pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                    pollHandleInfo->PollEvents |= AFD_POLL_SEND;
                    found = TRUE;

                }
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_ACCEPT) != 0 ) {

            if ( (endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening &&
                     !IsListEmpty( &endpoint->Common.VcListening.UnacceptedConnectionListHead ) ) {
                pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents |= AFD_POLL_ACCEPT;
                found = TRUE;
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_CONNECT) != 0 ) {

            //
            // If the endpoint is now connected, complete this event.
            //

            if ( endpoint->State == AfdEndpointStateConnected ) {

                ASSERT( NT_SUCCESS(endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT]) );
                pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents |= AFD_POLL_CONNECT;
                found = TRUE;
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_CONNECT_FAIL) != 0 ) {

            //
            // This is a poll to see whether a connect has failed
            // recently.  The connect status must indicate an error.
            //

            if ( endpoint->State == AfdEndpointStateBound &&
                    !NT_SUCCESS(endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT]) ) {

                pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents |= AFD_POLL_CONNECT_FAIL;
                pollHandleInfo->Status =
                    endpoint->EventStatus[AFD_POLL_CONNECT_FAIL_BIT];
                found = TRUE;
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_DISCONNECT) != 0 ) {

            if ( connection != NULL && connection->DisconnectIndicated ) {
                pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents |= AFD_POLL_DISCONNECT;
                found = TRUE;
            }
        }

        if ( (pollEndpointInfo->PollEvents & AFD_POLL_ABORT) != 0 ) {

            if ( connection != NULL && connection->AbortIndicated ) {
                pollHandleInfo->Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                pollHandleInfo->PollEvents |= AFD_POLL_ABORT;
                found = TRUE;
            }
        }

        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

        //
        // If the handle had a current event that was requested, update
        // the count of handles in the output buffer and increment the
        // pointer to the output buffer.
        //

        if ( found ) {
            pollInfo->NumberOfHandles++;
            pollHandleInfo++;
        }

        pollEndpointInfo++;
    }

    //
    // If we found any endpoints that are ready, free the poll information
    // structure and complete the request.
    //

    if ( pollInfo->NumberOfHandles > 0 ) {

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    //
    // None of the endpoints are in the correct state.  If a timeout was
    // specified, place the poll information on the global list and set
    // up a DPC and timer so that we know when to complete the IRP.
    //

    if ( pollInfo->Timeout.LowPart != 0 && pollInfo->Timeout.HighPart != 0 ) {

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll32: no current events for poll IRP %p, "
                        "info %p\n", Irp, pollInfoInternal ));
        }

        //
        // Set up the information field of the IO status block to indicate
        // that an output buffer with no handles should be returned.
        // AfdIndicatePollEvent will modify this if necessary.
        //

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;

        //
        // Put a pointer to the internal poll info struct into the IRP
        // so that the cancel routine can find it.
        //

        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pollInfoInternal;

        //
        // Place the internal poll info struct on the global list.
        //

        InsertTailList( &AfdPollListHead, &pollInfoInternal->PollListEntry );

        //
        // If the timeout is infinite, then don't set up a timer and
        // DPC.  Otherwise, set up a timer so we can timeout the poll
        // request if appropriate.
        //

        if ( pollInfo->Timeout.HighPart != 0x7FFFFFFF ) {

            pollInfoInternal->TimerStarted = TRUE;

            KeInitializeDpc(
                &pollInfoInternal->Dpc,
                AfdTimeoutPoll,
                pollInfoInternal
                );

            KeInitializeTimer( &pollInfoInternal->Timer );

            KeSetTimer(
                &pollInfoInternal->Timer,
                pollInfo->Timeout,
                &pollInfoInternal->Dpc
                );

        } else {

            pollInfoInternal->TimerStarted = FALSE;
        }

    } else {

        //
        // A timeout equal to 0 was specified; free the internal
        // structure and complete the request with no endpoints in the
        // output buffer.
        //

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdPoll32: zero timeout on poll IRP %p and no "
                        "current events--completing.\n", Irp ));
        }

        AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );
        AfdFreePollInfo( pollInfoInternal );

        Irp->IoStatus.Information = (PUCHAR)pollHandleInfo - (PUCHAR)pollInfo;
        status = STATUS_SUCCESS;
        goto complete;
    }

    //
    // Mark the IRP pending and release the spin locks.  At this
    // point the IRP may get completed or cancelled.
    //

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &AfdPollListLock, &pollLockHandle );

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        //
        // If we need to free a cancelled poll info structure, do it now.
        //
    
        if ( freePollInfo != NULL ) {
            AfdFreePollInfo( freePollInfo );
        }
    
        if (IoSetCancelRoutine( oldIrp, NULL ) == NULL) {
            KIRQL cancelIrql;
    
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( oldIrp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
    
        }
    
        IoCompleteRequest( oldIrp, AfdPriorityBoost );
    
    }

    //
    // Return pending.  The IRP will be completed when an appropriate
    // event is indicated by the TDI provider, when the timeout is hit,
    // or when the IRP is cancelled.
    //

    return STATUS_PENDING;

complete:

    //
    //  Complete any old poll irps.
    //

    if ( oldIrp != NULL ) {

        //
        // If we need to free a cancelled poll info structure, do it now.
        //
    
        if ( freePollInfo != NULL ) {
            AfdFreePollInfo( freePollInfo );
        }
    
        if (IoSetCancelRoutine( oldIrp, NULL ) == NULL) {
            KIRQL cancelIrql;
    
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( oldIrp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
    
        }
    
        IoCompleteRequest( oldIrp, AfdPriorityBoost );
    
    }

    Irp->IoStatus.Status = status;

    if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
        KIRQL cancelIrql;

        //
        // If the cancel routine was NULL then cancel routine
        // may be running.  Wait on the cancel spinlock until
        // the cancel routine is done.
        //
        // Note: The cancel routine will not find the IRP
        // since it is not in the list.
        //
        
        IoAcquireCancelSpinLock( &cancelIrql );
        // ASSERT( Irp->Cancel ); the cancel routine may have not been set
        IoReleaseCancelSpinLock( cancelIrql );

    }

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdPoll32
#endif //_WIN64


VOID
AfdCancelPoll (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    PLIST_ENTRY listEntry;
    BOOLEAN found = FALSE;
    BOOLEAN timerCancelSucceeded;
    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    pollInfoInternal =
        (PAFD_POLL_INFO_INTERNAL)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelPoll called for IRP %p\n", Irp ));
    }

    //
    // Get the AFD spin lock and attempt to find the poll structure on
    // the list of outstanding polls.
    // Note the afdspinlock must be acquired befor the cancel spinlock
    // is released so that the pollInfoInternal does not get reused
    // before we have had a chance to look at the queue.
    //

    AfdAcquireSpinLockAtDpcLevel( &AfdPollListLock, &lockHandle);

    for ( listEntry = AfdPollListHead.Flink;
          listEntry != &AfdPollListHead;
          listEntry = listEntry->Flink ) {

        PAFD_POLL_INFO_INTERNAL testInfo;

        testInfo = CONTAINING_RECORD(
                       listEntry,
                       AFD_POLL_INFO_INTERNAL,
                       PollListEntry
                       );

        if ( testInfo == pollInfoInternal ) {
            found = TRUE;
            break;
        }
    }

    //
    // If we didn't find the poll structure on the list, then the
    // indication handler got called prior to the spinlock acquisition
    // above and it is already off the list.  Just return and do
    // nothing, as the indication handler completed the IRP.
    //

    if ( !found ) {
        AfdReleaseSpinLockFromDpcLevel( &AfdPollListLock, &lockHandle);
        IoReleaseCancelSpinLock( Irp->CancelIrql );
    
        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdCancelPoll: poll info %p not found on list.\n",
                        pollInfoInternal ));
        }
        return;
    }

    //
    // Remove the poll structure from the global list.
    //

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelPoll: poll info %p found on list, completing.\n",
                    pollInfoInternal ));
    }

    RemoveEntryList( &pollInfoInternal->PollListEntry );

    //
    // Cancel the timer and reset the IRP pointer in the internal
    // poll information structure.  NULLing the IRP field
    // prevents the timer routine from completing the IRP.
    //

    if ( pollInfoInternal->TimerStarted ) {
        timerCancelSucceeded = KeCancelTimer( &pollInfoInternal->Timer );
    } else {
        timerCancelSucceeded = TRUE;
    }

    //
    // Complete the IRP with STATUS_CANCELLED as the status.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    AfdReleaseSpinLockFromDpcLevel( &AfdPollListLock, &lockHandle);
    IoReleaseCancelSpinLock( Irp->CancelIrql );
    
    if (timerCancelSucceeded) {
        if (pollInfoInternal->SanPoll && 
                (Irp->CancelIrql>APC_LEVEL ||
                    (Irp->Tail.Overlay.Thread!=PsGetCurrentThread ()))) {
            KeInitializeApc (&pollInfoInternal->Apc,
                                PsGetThreadTcb (Irp->Tail.Overlay.Thread),
                                Irp->ApcEnvironment,
                                AfdSanPollApcKernelRoutine,
                                AfdSanPollApcRundownRoutine,
                                (PKNORMAL_ROUTINE)-1,
                                KernelMode,
                                NULL);
            if (KeInsertQueueApc (&pollInfoInternal->Apc,
                                    pollInfoInternal,
                                    Irp,
                                    AfdPriorityBoost)) {
                return ;
            }
            else {
                pollInfoInternal->SanPoll = FALSE;
            }
        }

        //
        // Free the poll information structure if the cancel succeeded.  If
        // the cancel of the timer did not succeed, then the timer is
        // already running and the timer DPC will free the internal
        // poll info.
        //

        AfdFreePollInfo( pollInfoInternal );
        IoCompleteRequest( Irp, AfdPriorityBoost );
    }

    return;

} // AfdCancelPoll


VOID
AfdFreePollInfo (
    IN PAFD_POLL_INFO_INTERNAL PollInfoInternal
    )
{
    ULONG i;
    PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFreePollInfo: freeing info struct at %p\n",
                    PollInfoInternal ));
    }

    // *** Note that this routine does not remove the poll information
    //     structure from the global list--that is the responsibility
    //     of the caller!

    //
    // Walk the list of endpoints in the poll information structure and
    // dereference each one.
    //

    pollEndpointInfo = PollInfoInternal->EndpointInfo;

    for ( i = 0; i < PollInfoInternal->NumberOfEndpoints; i++ ) {
        ASSERT( InterlockedDecrement( &pollEndpointInfo->Endpoint->ObReferenceBias ) >= 0 );

        if (PollInfoInternal->SanPoll) {
            ASSERT (PollInfoInternal->Irp!=NULL);
            ASSERT (PsGetCurrentThread ()==PollInfoInternal->Irp->Tail.Overlay.Thread);
            if (pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED) {
                ASSERT (IS_SAN_ENDPOINT (pollEndpointInfo->Endpoint));
                AfdSanPollEnd (pollEndpointInfo->Endpoint,
                                    pollEndpointInfo->PollEvents);
            }
        }

        DEREFERENCE_ENDPOINT( pollEndpointInfo->Endpoint );
        ObDereferenceObject( pollEndpointInfo->FileObject );
        pollEndpointInfo++;
    }

    //
    // Free the structure itself and return.
    //

    AFD_FREE_POOL(
        PollInfoInternal,
        AFD_POLL_POOL_TAG
        );

    return;

} // AfdFreePollInfo


VOID
AfdIndicatePollEventReal (
    IN PAFD_ENDPOINT Endpoint,
    IN ULONG PollEventMask,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    Called to complete polls with a specific event or events.

Arguments:

    Endpoint - the endpoint on which the action occurred.

    PollEventMask - the mask of the events which occurred.

    Status - the status of the event, if any.

Return Value:

    None.

--*/

{
    LIST_ENTRY completePollListHead;
    PLIST_ENTRY listEntry;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_POLL_INFO_INTERNAL pollInfoInternal;
    union {
        PAFD_POLL_INFO PollInfo;
        PAFD_POLL_INFO32 PollInfo32;
    } u;
#define pollInfo    u.PollInfo
#define pollInfo32  u.PollInfo32
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    ASSERT (PollEventMask!=0);
    ASSERT (((~((1<<AFD_NUM_POLL_EVENTS)-1)) & PollEventMask)==0);

    //
    // Note that AFD_POLL_ABORT implies AFD_POLL_SEND.
    //
    if( PollEventMask & AFD_POLL_ABORT ) {
        PollEventMask |= AFD_POLL_SEND;
    }

    //
    // Initialize the list of poll info structures that we'll be
    // completing for this event.
    //

    InitializeListHead( &completePollListHead );

    //
    // Walk the global list of polls, searching for any the are waiting
    // for the specified event on the specified endpoint.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &lockHandle );

    for ( listEntry = AfdPollListHead.Flink;
          listEntry != &AfdPollListHead;
          listEntry = listEntry->Flink ) {

        PAFD_POLL_ENDPOINT_INFO pollEndpointInfo;
        ULONG i;
        ULONG foundCount = 0;

        pollInfoInternal = CONTAINING_RECORD(
                               listEntry,
                               AFD_POLL_INFO_INTERNAL,
                               PollListEntry
                               );

        pollInfo = pollInfoInternal->Irp->AssociatedIrp.SystemBuffer;

        irp = pollInfoInternal->Irp;
        irpSp = IoGetCurrentIrpStackLocation( irp );

        IF_DEBUG(POLL) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdIndicatePollEvent: pollInfoInt %p "
                        "IRP %p pollInfo %p event mask %lx status %lx\n",
                        pollInfoInternal, irp, pollInfo,
                        PollEventMask, Status ));
        }

        //
        // Walk the poll structure looking for matching endpoints.
        //

        pollEndpointInfo = pollInfoInternal->EndpointInfo;

        for ( i = 0; i < pollInfoInternal->NumberOfEndpoints; i++ ) {

            IF_DEBUG(POLL) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdIndicatePollEvent: pollEndpointInfo = %p, "
                            "comparing %p, %p\n",
                            pollEndpointInfo, pollEndpointInfo->Endpoint,
                            Endpoint ));
            }

            //
            // Update the counts for the polls that were issued before
            // the endpoint was converted to SAN.
            //
            if (Endpoint==pollEndpointInfo->Endpoint &&
                    IS_SAN_ENDPOINT (Endpoint) && 
                    !(pollEndpointInfo->PollEvents & AFD_POLL_SANCOUNTS_UPDATED) &&
                    Endpoint->Common.SanEndp.LocalContext!=NULL) {
                AfdSanPollUpdate (Endpoint, pollEndpointInfo->PollEvents);
                pollEndpointInfo->PollEvents |= AFD_POLL_SANCOUNTS_UPDATED;
            }

            //
            // Regardless of whether the caller requested to be told about
            // local closes, we'll complete the IRP if an endpoint
            // is being closed.  When they close an endpoint, all IO on
            // the endpoint must be completed.
            //

            if ( Endpoint == pollEndpointInfo->Endpoint &&
                     ( (PollEventMask & pollEndpointInfo->PollEvents) != 0
                       ||
                       (PollEventMask & AFD_POLL_LOCAL_CLOSE) ) ) {

#ifdef _WIN64
                if (IoIs32bitProcess (irp)) {
                    ASSERT( pollInfo32->NumberOfHandles == foundCount );

                    IF_DEBUG(POLL) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdIndicatePollEvent32: endpoint %p found "
                                    " for event %lx\n",
                                    pollEndpointInfo->Endpoint, PollEventMask ));
                    }

                    pollInfo32->NumberOfHandles++;

                    pollInfo32->Handles[foundCount].Handle = (VOID *  POINTER_32)pollEndpointInfo->Handle;
                    pollInfo32->Handles[foundCount].PollEvents =
                        (PollEventMask &
                            (pollEndpointInfo->PollEvents | AFD_POLL_LOCAL_CLOSE));
                    pollInfo32->Handles[foundCount].Status = Status;

                }
                else
#endif // _WIN64
                {
                    ASSERT( pollInfo->NumberOfHandles == foundCount );

                    IF_DEBUG(POLL) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdIndicatePollEvent: endpoint %p found "
                                    " for event %lx\n",
                                      pollEndpointInfo->Endpoint, PollEventMask ));
                    }

                    pollInfo->NumberOfHandles++;

                    pollInfo->Handles[foundCount].Handle = pollEndpointInfo->Handle;
                    pollInfo->Handles[foundCount].PollEvents =
                        (PollEventMask &
                            (pollEndpointInfo->PollEvents | AFD_POLL_LOCAL_CLOSE));
                    pollInfo->Handles[foundCount].Status = Status;

                }
                foundCount++;
            }

            pollEndpointInfo++;
        }

        //
        // If we found any matching endpoints, remove the poll information
        // structure from the global list, complete the IRP, and free the
        // poll information structure.
        //

        if ( foundCount != 0 ) {

            BOOLEAN timerCancelSucceeded;

            //
            // We need to release the spin lock to call AfdFreePollInfo,
            // since it calls AfdDereferenceEndpoint which in turn needs
            // to acquire the spin lock, and recursive spin lock
            // acquisitions result in deadlock.  However, we can't
            // release the lock of else the state of the poll list could
            // change, e.g.  the next entry could get freed.  Remove
            // this entry from the global list and place it on a local
            // list.  We'll complete all the poll IRPs after walking
            // the entire list.
            //

            RemoveEntryList( &pollInfoInternal->PollListEntry );

            //
            // Set up the IRP for completion now, since we have all needed
            // information here.
            //

#ifdef _WIN64
            if (IoIs32bitProcess (irp)) {
                irp->IoStatus.Information =
                    (PUCHAR)&pollInfo32->Handles[foundCount] - (PUCHAR)pollInfo32;
            }
            else
#endif 
            {
                irp->IoStatus.Information =
                    (PUCHAR)&pollInfo->Handles[foundCount] - (PUCHAR)pollInfo;
            }

            irp->IoStatus.Status = STATUS_SUCCESS;
            //
            // Cancel the timer on the poll so that it does not fire.
            //

            if ( pollInfoInternal->TimerStarted ) {
                timerCancelSucceeded = KeCancelTimer( &pollInfoInternal->Timer );
            } else {
                timerCancelSucceeded = TRUE;
            }

            //
            // If the cancel of the timer failed, then we don't want to
            // free this structure since the timer routine is running.
            // Let the timer routine free the structure.
            //

            if ( timerCancelSucceeded ) {
                InsertTailList(
                    &completePollListHead,
                    &irp->Tail.Overlay.ListEntry
                    );

            }

        }
    }

    AfdReleaseSpinLock( &AfdPollListLock, &lockHandle );

    //
    // Now walk the list of polls we need to actually complete.  Free
    // the poll info structures as we go.
    //

    while ( !IsListEmpty( &completePollListHead ) ) {

        listEntry = RemoveHeadList( &completePollListHead );
        ASSERT( listEntry != &completePollListHead );

        irp = CONTAINING_RECORD(
                  listEntry,
                  IRP,
                  Tail.Overlay.ListEntry
                  );
        irpSp = IoGetCurrentIrpStackLocation( irp );

        pollInfoInternal =
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;


        if (IoSetCancelRoutine( irp, NULL ) == NULL) {
            KIRQL cancelIrql;
    
            //
            // If the cancel routine was NULL then cancel routine
            // may be running.  Wait on the cancel spinlock until
            // the cancel routine is done.
            //
            // Note: The cancel routine will not find the IRP
            // since it is not in the list.
            //
            
            IoAcquireCancelSpinLock( &cancelIrql );
            ASSERT( irp->Cancel );
            IoReleaseCancelSpinLock( cancelIrql );
    
        }
    
        if (pollInfoInternal->SanPoll && 
                ((irp->Tail.Overlay.Thread!=PsGetCurrentThread ()) ||
                        (KeGetCurrentIrql() > APC_LEVEL)) ) {
            KeInitializeApc (&pollInfoInternal->Apc,
                                PsGetThreadTcb (irp->Tail.Overlay.Thread),
                                irp->ApcEnvironment,
                                AfdSanPollApcKernelRoutine,
                                AfdSanPollApcRundownRoutine,
                                (PKNORMAL_ROUTINE)-1,
                                KernelMode,
                                NULL);
            if (KeInsertQueueApc (&pollInfoInternal->Apc,
                                    pollInfoInternal,
                                    irp,
                                    AfdPriorityBoost)) {
                continue ;
            }
            else {
                pollInfoInternal->SanPoll = FALSE;
            }
        }

    
        //
        // Free the poll info structure.
        //

        AfdFreePollInfo( pollInfoInternal );

        IoCompleteRequest( irp, AfdPriorityBoost );

    }

    return;

} // AfdIndicatePollEvent


VOID
AfdTimeoutPoll (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    PAFD_POLL_INFO_INTERNAL pollInfoInternal = DeferredContext;
    PIRP irp;
    PLIST_ENTRY listEntry;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Get the AFD spin lock and attempt to find the poll structure on
    // the list of outstanding polls.
    //

    AfdAcquireSpinLock( &AfdPollListLock, &lockHandle );

    for ( listEntry = AfdPollListHead.Flink;
          listEntry != &AfdPollListHead;
          listEntry = listEntry->Flink ) {

        PAFD_POLL_INFO_INTERNAL testInfo;

        testInfo = CONTAINING_RECORD(
                       listEntry,
                       AFD_POLL_INFO_INTERNAL,
                       PollListEntry
                       );

        if ( testInfo == pollInfoInternal ) {
            //
            // Remove the poll structure from the global list.
            //

            IF_DEBUG(POLL) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,                            "AfdTimeoutPoll: poll info %p found on list, completing.\n",
                            pollInfoInternal ));
            }

            RemoveEntryList( &pollInfoInternal->PollListEntry );
            break;
        }
    }

    ASSERT( pollInfoInternal->TimerStarted );

    //
    // If we didn't find the poll structure on the list, then the
    // indication handler got called prior to the spinlock acquisition
    // above and it is already off the list.  It must have setup
    // the IRP completion code already.
    //
    // We must free the internal information structure in this case,
    // since the indication handler will not free it.  The indication
    // handler cannot free the structure because the structure contains
    // the timer object, which must remain intact until this routine
    // is entered.
    //

    //
    // The IRP should not have been completed at this point.
    //

    ASSERT( pollInfoInternal->Irp != NULL );
    irp = pollInfoInternal->Irp;

    //
    // Remove the poll structure from the global list.
    //

    IF_DEBUG(POLL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTimeoutPoll: poll info %p found on list, completing.\n",
                    pollInfoInternal ));
    }

    AfdReleaseSpinLock( &AfdPollListLock, &lockHandle );

    //
    // Complete the IRP pointed to in the poll structure.  The
    // Information field has already been set up by AfdPoll, as well as
    // the output buffer.
    //

    if (IoSetCancelRoutine( irp, NULL ) == NULL) {
        KIRQL cancelIrql;

        //
        // If the cancel routine was NULL then cancel routine
        // may be running.  Wait on the cancel spinlock until
        // the cancel routine is done.
        //
        // Note: The cancel routine will not find the IRP
        // since it is not in the list.
        //
        
        IoAcquireCancelSpinLock( &cancelIrql );
        ASSERT( irp->Cancel );
        IoReleaseCancelSpinLock( cancelIrql );

    }

    if (pollInfoInternal->SanPoll) {
        KeInitializeApc (&pollInfoInternal->Apc,
                            PsGetThreadTcb (irp->Tail.Overlay.Thread),
                            irp->ApcEnvironment,
                            AfdSanPollApcKernelRoutine,
                            AfdSanPollApcRundownRoutine,
                            (PKNORMAL_ROUTINE)-1,
                            KernelMode,
                            NULL);
        if (KeInsertQueueApc (&pollInfoInternal->Apc,
                                pollInfoInternal,
                                irp,
                                AfdPriorityBoost)) {
            return;
        }
        else {
            pollInfoInternal->SanPoll = FALSE;
        }
    }

    IoCompleteRequest( irp, AfdPriorityBoost );

    //
    // Free the poll information structure.
    //

    AfdFreePollInfo( pollInfoInternal );

    return;

} // AfdTimeoutPoll

VOID
AfdSanPollApcKernelRoutine (
    IN struct _KAPC         *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID            *NormalContext,
    IN OUT PVOID            *SystemArgument1,
    IN OUT PVOID            *SystemArgument2
    )
/*++

Routine Description:

  Special kernel apc routine. Executed in the context of
  the target thread at APC_LEVEL

Arguments:
    NormalRoutine  - pointer containing address of normal routine (it will
                    be NULL for special kernel APC and not NULL for normal
                    kernel APC)

    SystemArgument1 - pointer to the address of worker routine to execute
    SyetemArgument2 - pointer to the argument to pass to worker routine

Return Value:

    None.

--*/
{
    PAFD_POLL_INFO_INTERNAL     pollInfoInternal;
    PIRP                        irp;
    
    PAGED_CODE ();

    pollInfoInternal = *SystemArgument1;
    irp =  *SystemArgument2;
    ASSERT (pollInfoInternal->Irp==irp);

    //
    // Normal APC, but we are requested to run in its special
    // routine which avoids raising and lowering IRQL
    //

    ASSERT (*NormalRoutine==(PKNORMAL_ROUTINE)-1);
    *NormalRoutine = NULL;
    AfdFreePollInfo (pollInfoInternal);
    IoCompleteRequest (irp, IO_NO_INCREMENT);
}

VOID
AfdSanPollApcRundownRoutine (
    IN struct _KAPC *Apc
    )
/*++

Routine Description:

  APC rundown routine. Executed if APC cannot be delivered for
  some reason (thread exiting).

Arguments:

    Apc     - APC structure

Return Value:

    None.

--*/
{
    PAFD_POLL_INFO_INTERNAL     pollInfoInternal;
    PIRP                        irp;

    PAGED_CODE ();

    pollInfoInternal = Apc->SystemArgument1;
    irp =  Apc->SystemArgument2;
    ASSERT (pollInfoInternal->Irp==irp);

    AfdFreePollInfo (pollInfoInternal);
    IoCompleteRequest (irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\group.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    group.c

Abstract:

    This module contains Group ID managment routines.

    Group IDs identify an AFD_GROUP_ENTRY structure in a lookup table.
    Each AFD_GROUP_ENTRY contains a reference count and a type (either
    GroupTypeConstrained or GroupTypeUnconstrained). Free group IDs are
    linked together in a doubly-linked list. As group IDs are allocated,
    they are removed from this list. Once the free list becomes empty,
    the lookup table is grown appropriately.

Author:

    Keith Moore (keithmo)        06-Jun-1996

Revision History:

--*/

#include "afdp.h"


//
// Private constants.
//

#define AFD_GROUP_TABLE_GROWTH  32  // entries


//
// Private types.
//

typedef struct _AFD_GROUP_ENTRY {
    union {
        LIST_ENTRY ListEntry;
        struct {
            AFD_GROUP_TYPE GroupType;
            LONG ReferenceCount;
        };
    };
} AFD_GROUP_ENTRY, *PAFD_GROUP_ENTRY;


//
// Private globals.
//

PERESOURCE AfdGroupTableResource;
PAFD_GROUP_ENTRY AfdGroupTable;
LIST_ENTRY AfdFreeGroupList;
LONG AfdGroupTableSize;


//
// Private functions.
//

PAFD_GROUP_ENTRY
AfdMapGroupToEntry(
    IN LONG Group
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, AfdInitializeGroup )
#pragma alloc_text( PAGE, AfdTerminateGroup )
#pragma alloc_text( PAGE, AfdReferenceGroup )
#pragma alloc_text( PAGE, AfdDereferenceGroup )
#pragma alloc_text( PAGE, AfdGetGroup )
#endif


BOOLEAN
AfdInitializeGroup(
    VOID
    )

/*++

Routine Description:

    Initializes any globals necessary for the group ID package.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    //
    // Initialize the group globals.
    //

    AfdGroupTableResource = AFD_ALLOCATE_POOL_PRIORITY(
                                NonPagedPool,
                                sizeof(*AfdGroupTableResource),
                                AFD_RESOURCE_POOL_TAG,
                                HighPoolPriority
                                );

    if( AfdGroupTableResource == NULL ) {

        return FALSE;

    }

    ExInitializeResourceLite( AfdGroupTableResource );

    AfdGroupTable = NULL;
    InitializeListHead( &AfdFreeGroupList );
    AfdGroupTableSize = 0;

    return TRUE;

}   // AfdInitializeGroup


VOID
AfdTerminateGroup(
    VOID
    )

/*++

Routine Description:

    Destroys any globals created for the group ID package.

--*/

{

    if( AfdGroupTableResource != NULL ) {

        ExDeleteResourceLite( AfdGroupTableResource );

        AFD_FREE_POOL(
            AfdGroupTableResource,
            AFD_RESOURCE_POOL_TAG
            );

        AfdGroupTableResource = NULL;

    }

    if( AfdGroupTable != NULL ) {

        AFD_FREE_POOL(
            AfdGroupTable,
            AFD_GROUP_POOL_TAG
            );

        AfdGroupTable = NULL;

    }

    InitializeListHead( &AfdFreeGroupList );
    AfdGroupTableSize = 0;

}   // AfdTerminateGroup


BOOLEAN
AfdReferenceGroup(
    IN LONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    )

/*++

Routine Description:

    Bumps the reference count associated with the given group ID.

Arguments:

    Group - The group ID to reference.

    GroupType - Returns the type of the group.

Returns:

    BOOLEAN - TRUE if the group ID was valid, FALSE otherwise.

--*/

{

    PAFD_GROUP_ENTRY groupEntry;
    AFD_GROUP_TYPE groupType;

    groupEntry = AfdMapGroupToEntry( Group );

    if( groupEntry != NULL ) {

        groupType = groupEntry->GroupType;

        if( groupType == GroupTypeConstrained ||
            groupType == GroupTypeUnconstrained ) {

            groupEntry->ReferenceCount++;
            *GroupType = groupType;

        } else {

            groupEntry = NULL;

        }

        ExReleaseResourceLite( AfdGroupTableResource );
        KeLeaveCriticalRegion ();

    }

    return (BOOLEAN)( groupEntry != NULL );

}   // AfdReferenceGroup


BOOLEAN
AfdDereferenceGroup(
    IN LONG Group
    )

/*++

Routine Description:

    Decrements the reference count associated with the given group ID.
    If the ref count drops to zero, the group ID is freed.

Arguments:

    Group - The group ID to dereference.

Returns:

    BOOLEAN - TRUE if the group ID was valid, FALSE otherwise.

--*/

{

    PAFD_GROUP_ENTRY groupEntry;
    AFD_GROUP_TYPE groupType;

    groupEntry = AfdMapGroupToEntry( Group );

    if( groupEntry != NULL ) {

        groupType = groupEntry->GroupType;

        if( groupType == GroupTypeConstrained ||
            groupType == GroupTypeUnconstrained ) {

            ASSERT( groupEntry->ReferenceCount > 0 );
            groupEntry->ReferenceCount--;

            if( groupEntry->ReferenceCount == 0 ) {

                InsertTailList(
                    &AfdFreeGroupList,
                    &groupEntry->ListEntry
                    );

            }

        } else {

            groupEntry = NULL;

        }

        ExReleaseResourceLite( AfdGroupTableResource );
        KeLeaveCriticalRegion ();

    }

    return (BOOLEAN)( groupEntry != NULL );

}   // AfdDereferenceGroup


BOOLEAN
AfdGetGroup(
    IN OUT PLONG Group,
    OUT PAFD_GROUP_TYPE GroupType
    )

/*++

Routine Description:

    Examines the incoming group. If is zero, then nothing is done. If it
    is SG_CONSTRAINED_GROUP, then a new constrained group ID is created.
    If it is SG_UNCONSTRAINED_GROUP, then a new unconstrained group ID is
    created. Otherwise, it must identify an existing group, so that group
    is referenced.

Arguments:

    Group - Points to the group ID to examine/modify.

    GroupType - Returns the type of the group.

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{

    LONG groupValue;
    PAFD_GROUP_ENTRY groupEntry;
    PAFD_GROUP_ENTRY newGroupTable;
    LONG newGroupTableSize;
    LONG i;
    PLIST_ENTRY listEntry;

    groupValue = *Group;

    //
    // Zero means "no group", so just ignore it.
    //

    if( groupValue == 0 ) {

        *GroupType = GroupTypeNeither;
        return TRUE;

    }

    //
    // If we're being asked to create a new group, do it.
    //

    if( groupValue == SG_CONSTRAINED_GROUP ||
        groupValue == SG_UNCONSTRAINED_GROUP ) {

        //
        // Lock the table.
        //

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdGroupTableResource, TRUE );

        //
        // See if there's room at the inn.
        //

        if( IsListEmpty( &AfdFreeGroupList ) ) {

            //
            // No room, we'll need to create/expand the table.
            //

            newGroupTableSize = AfdGroupTableSize + AFD_GROUP_TABLE_GROWTH;

            newGroupTable = AFD_ALLOCATE_POOL(
                                PagedPool,
                                newGroupTableSize * sizeof(AFD_GROUP_ENTRY),
                                AFD_GROUP_POOL_TAG
                                );

            if( newGroupTable == NULL ) {

                ExReleaseResourceLite( AfdGroupTableResource );
                KeLeaveCriticalRegion ();
                return FALSE;

            }

            if( AfdGroupTable == NULL ) {

                //
                // This is the initial table allocation, so reserve the
                // first three entries (0, SG_UNCONSTRAINED_GROUP, and
                // SG_CONSTRAINED_GROUP).
                //

                for( ;
                     AfdGroupTableSize <= SG_CONSTRAINED_GROUP ||
                     AfdGroupTableSize <= SG_UNCONSTRAINED_GROUP ;
                     AfdGroupTableSize++ ) {

                    newGroupTable[AfdGroupTableSize].ReferenceCount = 0;
                    newGroupTable[AfdGroupTableSize].GroupType = GroupTypeNeither;

                }

            } else {

                //
                // Copy the old table into the new table, then free the
                // old table.
                //

                RtlCopyMemory(
                    newGroupTable,
                    AfdGroupTable,
                    AfdGroupTableSize * sizeof(AFD_GROUP_ENTRY)
                    );

                AFD_FREE_POOL(
                    AfdGroupTable,
                    AFD_GROUP_POOL_TAG
                    );

            }

            //
            // Add the new entries to the free list.
            //

            for( i = newGroupTableSize - 1 ; i >= AfdGroupTableSize ; i-- ) {

                InsertHeadList(
                    &AfdFreeGroupList,
                    &newGroupTable[i].ListEntry
                    );

            }

            AfdGroupTable = newGroupTable;
            AfdGroupTableSize = newGroupTableSize;

        }

        //
        // Pull the next free entry off the list.
        //

        ASSERT( !IsListEmpty( &AfdFreeGroupList ) );

        listEntry = RemoveHeadList( &AfdFreeGroupList );

        groupEntry = CONTAINING_RECORD(
                         listEntry,
                         AFD_GROUP_ENTRY,
                         ListEntry
                         );

        groupEntry->ReferenceCount = 1;
        groupEntry->GroupType = (AFD_GROUP_TYPE)groupValue;

        *Group = (LONG)( groupEntry - AfdGroupTable );
        *GroupType = groupEntry->GroupType;

        ExReleaseResourceLite( AfdGroupTableResource );
        KeLeaveCriticalRegion ();
        return TRUE;

    }

    //
    // Otherwise, just reference the group.
    //

    return AfdReferenceGroup( groupValue, GroupType );

}   // AfdGetGroup


PAFD_GROUP_ENTRY
AfdMapGroupToEntry(
    IN LONG Group
    )

/*++

Routine Description:

    Maps the given group ID to the corresponding AFD_GROUP_ENTRY structure.

    N.B. This routine returns with AfdGroupTableResource held if successful.

Arguments:

    Group - The group ID to map.

Return Value:

    PAFD_GROUP_ENTRY - The entry corresponding to the group ID if successful,
        NULL otherwise.

--*/

{

    PAFD_GROUP_ENTRY groupEntry;

    //
    // Lock the table.
    //

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdGroupTableResource, TRUE );

    //
    // Validate the group ID.
    //

    if( Group > 0 && Group < AfdGroupTableSize ) {

        groupEntry = AfdGroupTable + Group;

        //
        // The group ID is within legal range. Ensure it's in use.
        // In the AFD_GROUP_ENTRY structure, the GroupType field is
        // overlayed with ListEntry.Flink due to the internal union.
        // We can use this knowledge to quickly validate that this
        // entry is in use.
        //

        if( groupEntry->GroupType == GroupTypeConstrained ||
            groupEntry->GroupType == GroupTypeUnconstrained ) {

            return groupEntry;

        }

    }

    //
    // Invalid group ID, fail it.
    //

    ExReleaseResourceLite( AfdGroupTableResource );
    KeLeaveCriticalRegion ();
    return NULL;

}   // AfdMapGroupToEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\misc.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the miscellaneous AFD routines.

Author:

    David Treadwell (davidtr)    13-Nov-1992

Revision History:

    Vadim Eydelman (vadime) 1998-1999 Misc changes

--*/

#include "afdp.h"
#define TL_INSTANCE 0
#include <ipexport.h>
#include <tdiinfo.h>
#include <tcpinfo.h>
#include <ntddtcp.h>


VOID
AfdDoWork (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

NTSTATUS
AfdRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
AfdUnlockDriver (
    IN PVOID Context
    );


BOOLEAN
AfdCompareAddresses(
    IN PTRANSPORT_ADDRESS Address1,
    IN ULONG Address1Length,
    IN PTRANSPORT_ADDRESS Address2,
    IN ULONG Address2Length
    );

NTSTATUS
AfdCompleteTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdCompleteNBTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
AfdCleanupTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    );

BOOLEAN
AfdCleanupNBTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    );

#ifdef _WIN64
NTSTATUS
AfdQueryHandles32 (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
NTSTATUS
AfdSetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
NTSTATUS
AfdGetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
AfdNoOperation32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    );
#endif

VOID
AfdLRListTimeout (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
AfdProcessLRList (
    PVOID   Param
    );

VOID
AfdLRStartTimer (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdCalcBufferArrayByteLength )
#pragma alloc_text( PAGE, AfdCopyBufferArrayToBuffer )
#pragma alloc_text( PAGE, AfdCopyBufferToBufferArray )
#pragma alloc_text( PAGE, AfdCopyMdlChainToBufferArray )
#pragma alloc_text( PAGEAFD, AfdMapMdlChain )
#pragma alloc_text( PAGEAFD, AfdCopyMdlChainToMdlChain )
#pragma alloc_text( PAGEAFD, AfdAdvanceMdlChain )
#pragma alloc_text( PAGEAFD, AfdAllocateMdlChain )
#pragma alloc_text( PAGE, AfdQueryHandles )
#pragma alloc_text( PAGE, AfdGetInformation )
#pragma alloc_text( PAGEAFD, AfdSetInformation )
#pragma alloc_text( PAGE, AfdSetInLineMode )
#pragma alloc_text( PAGE, AfdGetContext )
#pragma alloc_text( PAGE, AfdGetRemoteAddress )
#pragma alloc_text( PAGE, AfdSetContext )
#pragma alloc_text( PAGE, AfdIssueDeviceControl )
#pragma alloc_text( PAGE, AfdSetEventHandler )
#pragma alloc_text( PAGE, AfdInsertNewEndpointInList )
#pragma alloc_text( PAGE, AfdRemoveEndpointFromList )
#pragma alloc_text( PAGE, AfdQueryProviderInfo )
#pragma alloc_text( PAGE, AfdLockEndpointContext )
#pragma alloc_text( PAGE, AfdUnlockEndpointContext )
#pragma alloc_text( PAGEAFD, AfdCompleteIrpList )
#pragma alloc_text( PAGEAFD, AfdErrorEventHandler )
#pragma alloc_text( PAGEAFD, AfdErrorExEventHandler )
//#pragma alloc_text( PAGEAFD, AfdRestartDeviceControl ) // can't ever be paged!
#pragma alloc_text( PAGEAFD, AfdGetConnectData )
#pragma alloc_text( PAGEAFD, AfdSetConnectData )
#pragma alloc_text( PAGEAFD, AfdFreeConnectDataBuffers )
#pragma alloc_text( PAGEAFD, AfdSaveReceivedConnectData )
// The routines below can be called when no endpoints are in the list
//#pragma alloc_text( PAGEAFD, AfdDoWork )
//#pragma alloc_text( PAGEAFD, AfdQueueWorkItem )
#pragma alloc_text( PAGEAFD, AfdGetWorkerByRoutine )

#pragma alloc_text( PAGE, AfdProcessLRList)
#pragma alloc_text( PAGEAFD, AfdLRListTimeout)
#pragma alloc_text( PAGEAFD, AfdLRStartTimer)
#pragma alloc_text( PAGEAFD, AfdLRListAddItem)

// Re-enable paging of the routines below when
// KeFlushQueuedDpcs is exported from kernel.
//#pragma alloc_text( PAGEAFD, AfdTrimLookaside)
//#pragma alloc_text( PAGEAFD, AfdCheckLookasideLists)

#if DBG
#pragma alloc_text( PAGEAFD, AfdRecordOutstandingIrpDebug )
#endif
#pragma alloc_text( PAGE, AfdExceptionFilter )
#pragma alloc_text( PAGEAFD, AfdSetQos )
#pragma alloc_text( PAGE, AfdGetQos )
#pragma alloc_text( PAGE, AfdNoOperation )
#pragma alloc_text (PAGE, AfdValidateStatus)
#pragma alloc_text( PAGEAFD, AfdValidateGroup )
#pragma alloc_text( PAGEAFD, AfdCompareAddresses )
#pragma alloc_text( PAGEAFD, AfdGetUnacceptedConnectData )
#pragma alloc_text( PAGE, AfdDoTransportIoctl )
#pragma alloc_text( PAGEAFD, AfdCancelIrp )
#ifdef _WIN64
#pragma alloc_text( PAGEAFD, AfdAllocateMdlChain32 )
#pragma alloc_text( PAGEAFD, AfdSetQos32 )
#pragma alloc_text( PAGE, AfdGetQos32 )
#pragma alloc_text( PAGE, AfdNoOperation32 )
#endif
#endif


VOID
AfdCompleteIrpList (
    IN PLIST_ENTRY IrpListHead,
    IN PAFD_ENDPOINT Endpoint,
    IN NTSTATUS Status,
    IN PAFD_IRP_CLEANUP_ROUTINE CleanupRoutine OPTIONAL
    )

/*++

Routine Description:

    Completes a list of IRPs with the specified status.

Arguments:

    IrpListHead - the head of the list of IRPs to complete.

    Endpoint - an endpoint which lock which protects the list of IRPs.

    Status - the status to use for completing the IRPs.

    CleanupRoutine - a pointer to an optional IRP cleanup routine called
        before the IRP is completed.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listEntry;
    PIRP irp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    while ( !IsListEmpty( IrpListHead ) ) {

        //
        // Remove the first IRP from the list, get a pointer to
        // the IRP and reset the cancel routine in the IRP.  The
        // IRP is no longer cancellable.
        //

        listEntry = RemoveHeadList( IrpListHead );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            irp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }

        //
        // If we have a cleanup routine, call it.
        //

        if( CleanupRoutine != NULL ) {

            if (!(CleanupRoutine)( irp )) {
                //
                // Cleanup routine indicated that IRP should not
                // be completed.
                //
                continue;
            }

        }

        //
        // We must release the locks in order to actually
        // complete the IRP.  It is OK to release these locks
        // because we don't maintain any absolute pointer into
        // the list; the loop termination condition is just
        // whether the list is completely empty.
        //

        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

        //
        // Complete the IRP.
        //

        irp->IoStatus.Status = Status;
        irp->IoStatus.Information = 0;

        IoCompleteRequest( irp, AfdPriorityBoost );

        //
        // Reacquire the locks and continue completing IRPs.
        //

        AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
    }

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    return;

} // AfdCompleteIrpList


NTSTATUS
AfdErrorEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status
    )
{
    PAFD_ENDPOINT   endpoint = TdiEventContext;
    BOOLEAN result;

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result)
        return STATUS_SUCCESS;

    switch (Status) {
    case STATUS_PORT_UNREACHABLE:
        AfdErrorExEventHandler (TdiEventContext, Status, NULL);
        break;
    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdErrorEventHandler called for endpoint %p\n",
                    endpoint ));

    }

    DEREFERENCE_ENDPOINT (endpoint);
    return STATUS_SUCCESS;
}


NTSTATUS
AfdErrorExEventHandler (
    IN PVOID TdiEventContext,
    IN NTSTATUS Status,
    IN PVOID Context
    )
{
    PAFD_ENDPOINT   endpoint = TdiEventContext;
    BOOLEAN result;

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result)
        return STATUS_SUCCESS;

    switch (Status) {
    case STATUS_PORT_UNREACHABLE:
        //
        // UDP uses error ex handler to report ICMP rejects
        //
        if (IS_DGRAM_ENDPOINT (endpoint) && 
                !endpoint->Common.Datagram.DisablePUError) {
            AFD_LOCK_QUEUE_HANDLE lockHandle;
            PLIST_ENTRY     listEntry;
            PIRP            irp = NULL;
            PTRANSPORT_ADDRESS  sourceAddress = Context;
            int             sourceAddressLength;
            PAFD_BUFFER_TAG afdBuffer;

            if (sourceAddress!=NULL) {
                sourceAddressLength =
                    FIELD_OFFSET(TRANSPORT_ADDRESS,
                                 Address[0].Address[sourceAddress->Address[0].AddressLength]);
            }
            else
                sourceAddressLength = 0;

            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
            //
            // First try to fail any of the receive IRPs
            //
            while (!IsListEmpty (&endpoint->ReceiveDatagramIrpListHead)) {
                listEntry = RemoveHeadList( &endpoint->ReceiveDatagramIrpListHead );

                //
                // Get a pointer to the IRP and reset the cancel routine in
                // the IRP.  The IRP is no longer cancellable.
                //

                irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
    
                if ( IoSetCancelRoutine( irp, NULL ) != NULL ) {
                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                    irp->IoStatus.Status = Status;
                    irp->IoStatus.Information = 0;
                    AfdSetupReceiveDatagramIrp (irp, NULL, 0, NULL, 0,
                                    sourceAddress,
                                    sourceAddressLength,
                                    0
                                    );

                    IoCompleteRequest( irp, AfdPriorityBoost );
                    goto Exit;
                }
                else {

                    //
                    // This IRP is about to be canceled.  Look for another in the
                    // list.  Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    irp->Tail.Overlay.ListEntry.Flink = NULL;
                    irp = NULL;
                }
            }

            ASSERT (irp==NULL);
            //
            // See if there are any PEEK IRPs
            //
            while (!IsListEmpty (&endpoint->PeekDatagramIrpListHead)) {
                listEntry = RemoveHeadList( &endpoint->PeekDatagramIrpListHead );

                //
                // Get a pointer to the IRP and reset the cancel routine in
                // the IRP.  The IRP is no longer cancellable.
                //

                irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
    
                if ( IoSetCancelRoutine( irp, NULL ) != NULL ) {
                    break;
                }
                else {

                    //
                    // This IRP is about to be canceled.  Look for another in the
                    // list.  Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    irp->Tail.Overlay.ListEntry.Flink = NULL;
                    irp = NULL;
                }

            }

            //
            // If we can buffer this indication, do it
            //

            if (endpoint->DgBufferredReceiveBytes <
                    endpoint->Common.Datagram.MaxBufferredReceiveBytes &&
                    (endpoint->DgBufferredReceiveBytes>0 ||
                        (endpoint->DgBufferredReceiveCount*sizeof (AFD_BUFFER_TAG)) <
                            endpoint->Common.Datagram.MaxBufferredReceiveBytes) ) {
                afdBuffer = AfdGetBufferTag( sourceAddressLength, endpoint->OwningProcess );
                if ( afdBuffer != NULL) {

                    //
                    // Save the status do distinguish this from
                    // normal datagram IRP
                    //
                    afdBuffer->Status = Status;
                    afdBuffer->DataLength = 0;
                    afdBuffer->DatagramFlags = 0;
                    afdBuffer->DataOffset = 0;
                    RtlCopyMemory(
                        afdBuffer->TdiInfo.RemoteAddress,
                        sourceAddress,
                        sourceAddressLength
                        );
                    afdBuffer->TdiInfo.RemoteAddressLength = sourceAddressLength;

                    //
                    // Place the buffer on this endpoint's list of bufferred datagrams
                    // and update the counts of datagrams and datagram bytes on the
                    // endpoint.
                    //

                    InsertTailList(
                        &endpoint->ReceiveDatagramBufferListHead,
                        &afdBuffer->BufferListEntry
                        );

                    endpoint->DgBufferredReceiveCount++;

                    //
                    // All done.  Release the lock and tell the provider that we
                    // took all the data.
                    //
                    AfdIndicateEventSelectEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    //
                    // Indicate that it is possible to receive on the endpoint now.
                    //

                    AfdIndicatePollEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                }
                else {
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                }
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }

            //
            // If there was a peek IRP on the endpoint, complete it now.
            //

            if ( irp != NULL ) {
                irp->IoStatus.Status = Status;
                irp->IoStatus.Information = 0;
                AfdSetupReceiveDatagramIrp (irp, NULL, 0, NULL, 0,
                                sourceAddress,
                                sourceAddressLength,
                                0
                                );
                IoCompleteRequest( irp, AfdPriorityBoost  );
            }
        }
        break;
    }

Exit:
    DEREFERENCE_ENDPOINT (endpoint);
    return STATUS_SUCCESS;

} // AfdErrorEventHandler


VOID
AfdInsertNewEndpointInList (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Inserts a new endpoint in the global list of AFD endpoints.  If this
    is the first endpoint, then this routine does various allocations to
    prepare AFD for usage.

Arguments:

    Endpoint - the endpoint being added.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Acquire a lock which prevents other threads from performing this
    // operation.
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    InterlockedIncrement(
        &AfdEndpointsOpened
        );

    //
    // If the list of endpoints is empty, do some allocations.
    //

    if ( IsListEmpty( &AfdEndpointListHead ) ) {

        //
        // Tell MM to revert to normal paging semantics.
        //

        if (!AfdLoaded) {
            MmResetDriverPaging( DriverEntry );
            AfdLoaded = (PKEVENT)1;
        }

        //
        // Lock down the AFD section that cannot be pagable if any
        // sockets are open.
        //

        ASSERT( AfdDiscardableCodeHandle == NULL );

        AfdDiscardableCodeHandle = MmLockPagableCodeSection( AfdGetBuffer );
        ASSERT( AfdDiscardableCodeHandle != NULL );

        //
        // Add extra reference to afd device object so that the
        // driver cannot be unloaded while at least one endpoint
        // is in the list.
        //
        ObReferenceObject (AfdDeviceObject);

        //
        // Setup 30 sec timer to flush lookaside lists
        // if too many items are there for too long.
        //
        KeInitializeTimer (&AfdLookasideLists->Timer);
        KeInitializeDpc (&AfdLookasideLists->Dpc, AfdCheckLookasideLists, AfdLookasideLists);
        {
            LARGE_INTEGER   dueTime;
            dueTime.QuadPart = -(30*1000*1000*10);
            KeSetTimerEx (&AfdLookasideLists->Timer,
                            dueTime,
                            30*1000,
                            &AfdLookasideLists->Dpc);
        }

    }
    ASSERT (AfdLoaded==(PKEVENT)1);

    //
    // Add the endpoint to the list(s).
    //

    InsertHeadList(
        &AfdEndpointListHead,
        &Endpoint->GlobalEndpointListEntry
        );

    if( Endpoint->GroupType == GroupTypeConstrained ) {
        InsertHeadList(
            &AfdConstrainedEndpointListHead,
            &Endpoint->ConstrainedEndpointListEntry
            );
    }

    //
    // Release the lock and return.
    //

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    return;

} // AfdInsertNewEndpointInList


VOID
AfdRemoveEndpointFromList (
    IN PAFD_ENDPOINT Endpoint
    )

/*++

Routine Description:

    Removes a new endpoint from the global list of AFD endpoints.  If
    this is the last endpoint in the list, then this routine does
    various deallocations to save resource utilization.

Arguments:

    Endpoint - the endpoint being removed.

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Acquire a lock which prevents other threads from performing this
    // operation.
    //

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    InterlockedIncrement(
        &AfdEndpointsClosed
        );

    //
    // Remove the endpoint from the list(s).
    //

    RemoveEntryList(
        &Endpoint->GlobalEndpointListEntry
        );

    if( Endpoint->GroupType == GroupTypeConstrained ) {
        RemoveEntryList(
            &Endpoint->ConstrainedEndpointListEntry
            );
    }

    //
    // If the list of endpoints is now empty, do some deallocations.
    //

    if ( IsListEmpty( &AfdEndpointListHead ) ) {

        //
        // Stop the timer that scans lookaside lists.
        //
        KeCancelTimer (&AfdLookasideLists->Timer);

        //
        // Make sure DPC is completed since we may need to reinitialize
        // it after we exit this routine and new endpoint is created again.
        //
        KeRemoveQueueDpc (&AfdLookasideLists->Dpc);

        //
        // Make sure that DPC routine has actually completed before
        // unlocking code section where this routine resides.
        //
        // Not exported from kernel - so don't put the routine
        // into the discardable code section until it is.
        //
        // KeFlushQueuedDpcs ();

        //
        // Unlock the AFD section that can be pagable when no sockets
        // are open.
        //

        ASSERT( IsListEmpty( &AfdConstrainedEndpointListHead ) );
        ASSERT( AfdDiscardableCodeHandle != NULL );

        MmUnlockPagableImageSection( AfdDiscardableCodeHandle );

        AfdDiscardableCodeHandle = NULL;

        //
        // Queue off an executive worker thread to unlock AFD.  We do
        // this using special hacks in the AFD worker thread code so
        // that we don't need to acuire a spin lock after the unlock.
        //

        AfdQueueWorkItem( AfdUnlockDriver, &AfdUnloadWorker );
    }

    //
    // Release the lock and return.
    //

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

    return;

} // AfdRemoveEndpointFromList


VOID
AfdUnlockDriver (
    IN PVOID Context
    )
{
    //
    // Acquire a lock which prevents other threads from performing this
    // operation.
    //
    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );

    //
    // Test whether the endpoint list remains empty.  If it is still
    // empty, we can proceed with unlocking the driver.  If a new
    // endpoint has been placed on the list, then do not make AFD
    // pagable.
    //

    if ( IsListEmpty( &AfdEndpointListHead ) ) {

        //
        // Tell MM that it can page all of AFD as it desires.
        //
        if (AfdLoaded!=NULL && AfdLoaded!=(PKEVENT)1) {
            KeSetEvent (AfdLoaded, AfdPriorityBoost, FALSE);
        }
        else {
            MmPageEntireDriver( DriverEntry );
        }

        AfdLoaded = NULL;

    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();

} // AfdUnlockDriver


NTSTATUS
AfdQueryHandles (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )

/*++

Routine Description:

    Returns information about the TDI handles corresponding to an AFD
    endpoint.  NULL is returned for either the connection handle or the
    address handle (or both) if the endpoint does not have that particular
    object.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_HANDLE_INFO handleInfo;
    ULONG getHandleInfo;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    status = STATUS_SUCCESS;
    *Information = 0;
    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Make sure that the input and output buffers are large enough.
    //

#ifdef _WIN64
    if (IoIs32bitProcess (NULL)) {
        if ( InputBufferLength < sizeof(getHandleInfo) ||
                OutputBufferLength < sizeof(AFD_HANDLE_INFO32) ) {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }
    else
#endif
    {
        if ( InputBufferLength < sizeof(getHandleInfo) ||
                OutputBufferLength < sizeof(handleInfo) ) {
            return STATUS_BUFFER_TOO_SMALL;
        }
    }

    try {
        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForRead (InputBuffer,
                            sizeof (getHandleInfo),
                            PROBE_ALIGNMENT(ULONG));
        }

        //
        // Make local copies of the embeded pointer and parameters
        // that we will be using more than once in case malicios
        // application attempts to change them while we are
        // validating
        //

        getHandleInfo = *((PULONG)InputBuffer);

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        return status;
    }

    //
    // If no handle information or invalid handle information was
    // requested, fail.
    //

    if ( (getHandleInfo &
             ~(AFD_QUERY_ADDRESS_HANDLE | AFD_QUERY_CONNECTION_HANDLE)) != 0 ||
         getHandleInfo == 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the output buffer.
    //

    handleInfo.TdiAddressHandle = NULL;
    handleInfo.TdiConnectionHandle = NULL;

    //
    // If the caller requested a TDI address handle and we have an
    // address handle for this endpoint, dupe the address handle to the
    // user process.
    //

    if ( (getHandleInfo & AFD_QUERY_ADDRESS_HANDLE) != 0 &&
             (endpoint->State == AfdEndpointStateBound ||
                endpoint->State == AfdEndpointStateConnected) &&
             endpoint->AddressFileObject != NULL ) {

        // If transport does not support new TDI_SERVICE_FORCE_ACCESS_CHECK_FLAG
        // we get the maximum possible access for the handle so that helper
        // DLL can do what it wants with it.  Of course this compromises the
        // security, but we can't enforce it without the transport cooperation.
        status = ObOpenObjectByPointer(
                     endpoint->AddressFileObject,
                     OBJ_CASE_INSENSITIVE,
                     NULL,
                     MAXIMUM_ALLOWED,
                     *IoFileObjectType,
                     (KPROCESSOR_MODE)((endpoint->TdiServiceFlags&TDI_SERVICE_FORCE_ACCESS_CHECK)
                        ? RequestorMode
                        : KernelMode),
                     &handleInfo.TdiAddressHandle
                     );
        if ( !NT_SUCCESS(status) ) {
            return status;
        }
    }

    //
    // If the caller requested a TDI connection handle and we have a
    // connection handle for this endpoint, dupe the connection handle
    // to the user process.  Note that we can have a connection and
    // TDI handle when endpoint is in process of being connected.
    // We should not return the connection handle until enpoint is
    // fully connected or it may go away while we are trying to
    // reference it if connection fails (bug 93096)
    //

    if ( (getHandleInfo & AFD_QUERY_CONNECTION_HANDLE) != 0 &&
             (endpoint->Type & AfdBlockTypeVcConnecting) == AfdBlockTypeVcConnecting &&
             endpoint->State == AfdEndpointStateConnected &&
             ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint))!=NULL)) {

        ASSERT( connection->Type == AfdBlockTypeConnection );
        ASSERT( connection->FileObject != NULL );

        // If transport does not support new TDI_SERVICE_FORCE_ACCESS_CHECK_FLAG
        // we get the maximum possible access for the handle so that helper
        // DLL can do what it wants with it.  Of course this compromises the
        // security, but we can't enforce it without the transport cooperation.

        status = ObOpenObjectByPointer(
                     connection->FileObject,
                     OBJ_CASE_INSENSITIVE,
                     NULL,
                     MAXIMUM_ALLOWED,
                     *IoFileObjectType,
                     (KPROCESSOR_MODE)((endpoint->TdiServiceFlags & TDI_SERVICE_FORCE_ACCESS_CHECK)
                        ? RequestorMode
                        : KernelMode),
                     &handleInfo.TdiConnectionHandle
                     );

        DEREFERENCE_CONNECTION (connection);

        if ( !NT_SUCCESS(status) ) {
            if ( handleInfo.TdiAddressHandle != NULL ) {
                ZwClose( handleInfo.TdiAddressHandle );
            }
            return status;
        }
    }

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            if (RequestorMode!=KernelMode) {
                ProbeForWrite (OutputBuffer,
                                sizeof (AFD_HANDLE_INFO32),
                                PROBE_ALIGNMENT32 (AFD_HANDLE_INFO32));
            }
            ((PAFD_HANDLE_INFO32)OutputBuffer)->TdiAddressHandle = 
                (VOID *  POINTER_32)HandleToUlong(handleInfo.TdiAddressHandle);
            ((PAFD_HANDLE_INFO32)OutputBuffer)->TdiConnectionHandle = 
                (VOID *  POINTER_32)HandleToUlong(handleInfo.TdiConnectionHandle);
            *Information = sizeof (AFD_HANDLE_INFO32);
        }
        else
#endif
        {
            if (RequestorMode!=KernelMode) {
                ProbeForWrite (OutputBuffer,
                                sizeof (handleInfo),
                                PROBE_ALIGNMENT (AFD_HANDLE_INFO));
            }
            *((PAFD_HANDLE_INFO)OutputBuffer) = handleInfo;
            *Information = sizeof (handleInfo);
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        if ( handleInfo.TdiAddressHandle != NULL ) {
            ZwClose( handleInfo.TdiAddressHandle );
        }
        if ( handleInfo.TdiConnectionHandle != NULL ) {
            ZwClose( handleInfo.TdiConnectionHandle );
        }
        return status;
    }

    return STATUS_SUCCESS;

} // AfdQueryHandles


NTSTATUS
AfdGetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )

/*++

Routine Description:

    Gets information in the endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_INFORMATION afdInfo;
    NTSTATUS status;
    LONGLONG currentTime;
    LONGLONG connectTime;

    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    status = STATUS_SUCCESS;
    *Information = 0;

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    if (endpoint->Type==AfdBlockTypeHelper ||
            endpoint->Type==AfdBlockTypeSanHelper)
        return STATUS_INVALID_PARAMETER;


    //
    // Make sure that the input and output buffers are large enough.
    //
#ifdef _WIN64
    {
        C_ASSERT (sizeof (AFD_INFORMATION)==sizeof (AFD_INFORMATION32));
    }
#endif
    if ( InputBufferLength < sizeof(afdInfo.InformationType)  ||
            OutputBufferLength < sizeof(afdInfo) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (InputBufferLength),
                                PROBE_ALIGNMENT32(AFD_INFORMATION32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            afdInfo.InformationType = ((PAFD_INFORMATION32)InputBuffer)->InformationType;
        }
        else
#endif _WIN64 
        {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (InputBufferLength),
                                PROBE_ALIGNMENT(AFD_INFORMATION));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            afdInfo.InformationType = ((PAFD_INFORMATION)InputBuffer)->InformationType;
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        return status;
    }

    //
    // Set up appropriate information in the endpoint.
    //

    switch ( afdInfo.InformationType ) {

    case AFD_MAX_PATH_SEND_SIZE:
        if (InputBufferLength>sizeof (afdInfo) &&
                (endpoint->State==AfdEndpointStateBound || endpoint->State==AfdEndpointStateConnected)) {
            TDI_REQUEST_KERNEL_QUERY_INFORMATION kernelQueryInfo;
            TDI_CONNECTION_INFORMATION connectionInfo;
            PMDL    mdl;
            InputBuffer = (PUCHAR)InputBuffer+sizeof (afdInfo);
            InputBufferLength -= sizeof (afdInfo);
            mdl = IoAllocateMdl(
                            InputBuffer,        // VirtualAddress
                            InputBufferLength,  // Length
                            FALSE,              // SecondaryBuffer
                            TRUE,               // ChargeQuota
                            NULL                // Irp
                            );
            if (mdl!=NULL) {

                try {
                    MmProbeAndLockPages(
                        mdl,                        // MemoryDescriptorList
                        RequestorMode,              // AccessMode
                        IoWriteAccess              // Operation
                        );
                    status = STATUS_SUCCESS;
                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                }
                if (NT_SUCCESS (status)) {
                    connectionInfo.RemoteAddress = MmGetSystemAddressForMdlSafe (mdl, LowPagePriority);
                    if (connectionInfo.RemoteAddress!=NULL) {
                        connectionInfo.RemoteAddressLength = InputBufferLength;
                        //
                        // Set up a query to the TDI provider to obtain the largest
                        // datagram that can be sent to a particular address.
                        //

                        kernelQueryInfo.QueryType = TDI_QUERY_MAX_DATAGRAM_INFO;
                        kernelQueryInfo.RequestConnectionInformation = &connectionInfo;

                        connectionInfo.UserDataLength = 0;
                        connectionInfo.UserData = NULL;
                        connectionInfo.OptionsLength = 0;
                        connectionInfo.Options = NULL;

                        //
                        // Ask the TDI provider for the information.
                        //

                        status = AfdIssueDeviceControl(
                                     endpoint->AddressFileObject,
                                     &kernelQueryInfo,
                                     sizeof(kernelQueryInfo),
                                     &afdInfo.Information.Ulong,
                                     sizeof(afdInfo.Information.Ulong),
                                     TDI_QUERY_INFORMATION
                                     );
                    }
                    else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    MmUnlockPages (mdl);
                }
                IoFreeMdl (mdl);
            }
            else
                status = STATUS_INSUFFICIENT_RESOURCES;
            //
            // If the request succeeds, use this information.  Otherwise,
            // fall through and use the transport's global information.
            // This is done because not all transports support this
            // particular TDI request, and for those which do not the
            // global information is a reasonable approximation.
            //

            if ( NT_SUCCESS(status) ) {
                break;
            }
        }


    case AFD_MAX_SEND_SIZE:
        {
            //
            // With PnP some provider info fields can change over time.
            // so we query them each time we are asked.
            //
            TDI_PROVIDER_INFO   providerInfo;
            status = AfdQueryProviderInfo (
                        &endpoint->TransportInfo->TransportDeviceName,
                        &providerInfo);

            if (NT_SUCCESS (status)) {
                //
                // Return the MaxSendSize or MaxDatagramSendSize from the
                // TDI_PROVIDER_INFO based on whether or not this is a datagram
                // endpoint.
                //

                if ( IS_DGRAM_ENDPOINT(endpoint) ) {
                    afdInfo.Information.Ulong = providerInfo.MaxDatagramSize;
                } else {
                    afdInfo.Information.Ulong = providerInfo.MaxSendSize;
                }
            }

        }
        break;

    case AFD_SENDS_PENDING:

        //
        // If this is an endpoint on a bufferring transport, no sends
        // are pending in AFD.  If it is on a nonbufferring transport,
        // return the count of sends pended in AFD.
        //

        if ( IS_TDI_BUFFERRING(endpoint) || 
                (endpoint->Type & AfdBlockTypeVcConnecting) != AfdBlockTypeVcConnecting ||
                endpoint->State != AfdEndpointStateConnected ||
                ((connection=AfdGetConnectionReferenceFromEndpoint (endpoint))==NULL)) {
            afdInfo.Information.Ulong = 0;
        } else {
            afdInfo.Information.Ulong = connection->VcBufferredSendCount;
            DEREFERENCE_CONNECTION (connection);
        }

        break;

    case AFD_RECEIVE_WINDOW_SIZE:

        //
        // Return the default receive window.
        //

        afdInfo.Information.Ulong = AfdReceiveWindowSize;
        break;

    case AFD_SEND_WINDOW_SIZE:

        //
        // Return the default send window.
        //

        afdInfo.Information.Ulong = AfdSendWindowSize;
        break;

    case AFD_CONNECT_TIME:

        //
        // If the endpoint is not yet connected, return -1.  Otherwise,
        // calculate the number of seconds that the connection has been
        // active.
        //

        if ( endpoint->State != AfdEndpointStateConnected ||
                 IS_DGRAM_ENDPOINT (endpoint) ||
                 (connection=AfdGetConnectionReferenceFromEndpoint( endpoint ))==NULL) {

            afdInfo.Information.Ulong = 0xFFFFFFFF;

        } else {

            ASSERT( connection->Type == AfdBlockTypeConnection );

            //
            // Calculate how long the connection has been active by
            // subtracting the time at which the connection started from
            // the current time.  Note that we convert the units of the
            // time value from 100s of nanoseconds to seconds.
            //

            currentTime = KeQueryInterruptTime ();

            connectTime = (currentTime - connection->ConnectTime);
            connectTime /= 10*1000*1000;

            //
            // We can safely convert this to a ULONG because it takes
            // 127 years to overflow a ULONG counting seconds.  The
            // bizarre conversion to a LARGE_INTEGER is required to
            // prevent the compiler from optimizing out the full 64-bit
            // division above.  Without this, the compiler would do only
            // a 32-bit division and lose some information.
            //

            //afdInfo->Information.Ulong = (ULONG)connectTime;
            afdInfo.Information.Ulong = ((PLARGE_INTEGER)&connectTime)->LowPart;

            DEREFERENCE_CONNECTION (connection);
        }

        break;

    case AFD_GROUP_ID_AND_TYPE : {

            PAFD_GROUP_INFO groupInfo;

            groupInfo = (PAFD_GROUP_INFO)&afdInfo.Information.LargeInteger;

            //
            // Return the endpoint's group ID and group type.
            //

            groupInfo->GroupID = endpoint->GroupID;
            groupInfo->GroupType = endpoint->GroupType;

        }
        break;

    default:

        return STATUS_INVALID_PARAMETER;
    }


    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT32(AFD_INFORMATION32));
            }

            //
            // Copy parameters back to application's memory
            //

            RtlMoveMemory(InputBuffer,
                            &afdInfo,
                            sizeof (afdInfo));
        }
        else
#endif _WIN64 
        {
            //
            // Validate the output structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT (AFD_INFORMATION));
            }

            //
            // Copy parameters back to application's memory
            //

            *((PAFD_INFORMATION)OutputBuffer) = afdInfo;
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        return status;
    }

    *Information = sizeof(afdInfo);

    return STATUS_SUCCESS;

} // AfdGetInformation


NTSTATUS
AfdSetInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )

/*++

Routine Description:

    Sets information in the endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    AFD_INFORMATION afdInfo;
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;


    //
    // Nothing to return.
    //

    *Information = 0;

    //
    // Initialize locals for cleanup.
    //

    connection = NULL;
    status = STATUS_SUCCESS;

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    if (endpoint->Type==AfdBlockTypeHelper ||
            endpoint->Type==AfdBlockTypeSanHelper)
        return STATUS_INVALID_PARAMETER;

    //
    // Make sure that the input buffer is large enough.
    //

#ifdef _WIN64
    {
        C_ASSERT (sizeof (AFD_INFORMATION)==sizeof (AFD_INFORMATION32));
    }
#endif

    if ( InputBufferLength < sizeof(afdInfo) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (InputBufferLength),
                                PROBE_ALIGNMENT32(AFD_INFORMATION32));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            RtlMoveMemory (&afdInfo, InputBuffer, sizeof (afdInfo));
        }
        else
#endif _WIN64 
        {
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (afdInfo),
                                PROBE_ALIGNMENT(AFD_INFORMATION));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            afdInfo = *((PAFD_INFORMATION)InputBuffer);
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        return status;
    }

    //
    // Set up appropriate information in the endpoint.
    //

    switch ( afdInfo.InformationType ) {

    case AFD_NONBLOCKING_MODE:

        //
        // Set the blocking mode of the endpoint.  If TRUE, send and receive
        // calls on the endpoint will fail if they cannot be completed
        // immediately.
        //

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->NonBlocking = (afdInfo.Information.Boolean!=FALSE);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        break;

    case AFD_CIRCULAR_QUEUEING:

        //
        // Enables circular queuing on the endpoint.
        //

        if( !IS_DGRAM_ENDPOINT( endpoint ) ) {

            status =  STATUS_INVALID_PARAMETER;
            goto Cleanup;

        }

        endpoint->Common.Datagram.CircularQueueing = (afdInfo.Information.Boolean!=FALSE);
        break;

     case AFD_REPORT_PORT_UNREACHABLE:

        //
        // Enables reporting PORT_UNREACHABLE to the app.
        //

        if( !IS_DGRAM_ENDPOINT( endpoint ) ) {

            status =  STATUS_INVALID_PARAMETER;
            goto Cleanup;

        }

        endpoint->Common.Datagram.DisablePUError = (afdInfo.Information.Boolean==FALSE);
        break;

    case AFD_INLINE_MODE:

        //
        // Set the inline mode of the endpoint.  If TRUE, a receive for
        // normal data will be completed with either normal data or
        // expedited data.  If the endpoint is connected, we need to
        // tell the TDI provider that the endpoint is inline so that it
        // delivers data to us in order.  If the endpoint is not yet
        // connected, then we will set the inline mode when we create
        // the TDI connection object.
        //

        if ( (endpoint->Type & AfdBlockTypeVcConnecting) == AfdBlockTypeVcConnecting ) {
            connection = AfdGetConnectionReferenceFromEndpoint( endpoint );
            if (connection!=NULL) {
                status = AfdSetInLineMode(
                             connection,
                             afdInfo.Information.Boolean
                             );
                if ( !NT_SUCCESS(status) ) {
                    goto Cleanup;
                }
            }
        }

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        endpoint->InLine = (afdInfo.Information.Boolean!=FALSE);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        break;

    case AFD_RECEIVE_WINDOW_SIZE:
    case AFD_SEND_WINDOW_SIZE: {

        PCLONG maxBytes;
#ifdef AFDDBG_QUOTA
        PVOID chargeBlock;
        PSZ chargeType;
#endif

        //
        // First determine where the appropriate limits are stored in the
        // connection or endpoint.  We do this so that we can use common
        // code to charge quota and set the new counters.
        //

        if ( (endpoint->Type & AfdBlockTypeVcConnecting) == AfdBlockTypeVcConnecting &&
                endpoint->State == AfdEndpointStateConnected &&
                ((connection = AfdGetConnectionReferenceFromEndpoint (endpoint))!=NULL) ) {

            if ( afdInfo.InformationType == AFD_SEND_WINDOW_SIZE ) {
                maxBytes = &connection->MaxBufferredSendBytes;
            } else {
                maxBytes = &connection->MaxBufferredReceiveBytes;
            }

#ifdef AFDDBG_QUOTA
            chargeBlock = connection;
            chargeType = "SetInfo vcnb";
#endif
        } else if ( IS_DGRAM_ENDPOINT(endpoint) ) {

            if ( afdInfo.InformationType == AFD_SEND_WINDOW_SIZE ) {
                maxBytes = &endpoint->Common.Datagram.MaxBufferredSendBytes;
            } else {
                maxBytes = &endpoint->Common.Datagram.MaxBufferredReceiveBytes;
            }

#ifdef AFDDBG_QUOTA
            chargeBlock = endpoint;
            chargeType = "SetInfo dgrm";
#endif

        } else if (IS_SAN_ENDPOINT (endpoint) ) {
            status = STATUS_SUCCESS;
            goto Cleanup;
        }
        else {

            status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Make sure that we always allow at least one message to be
        // bufferred on an endpoint.
        //


        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        if ( afdInfo.Information.Ulong == 0 ) {

            //
            // Don't allow the max receive bytes to go to zero, but
            // max send bytes IS allowed to go to zero because it has
            // special meaning: specifically, do not buffer sends.
            //

            if ( afdInfo.InformationType == AFD_RECEIVE_WINDOW_SIZE ) {
                afdInfo.Information.Ulong = 1;
            }
            else {
                ASSERT (afdInfo.InformationType == AFD_SEND_WINDOW_SIZE);
                endpoint->DisableFastIoSend = TRUE;
            }
        }
        else {
            if( afdInfo.InformationType == AFD_SEND_WINDOW_SIZE ) {
                endpoint->DisableFastIoSend = FALSE;
            }
        }

        //
        // Set up the new information in the AFD internal structure.
        //

        *maxBytes = (CLONG)afdInfo.Information.Ulong;
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        break;
    }

    default:

        status = STATUS_INVALID_PARAMETER;
    }

Cleanup:
    if (connection!=NULL) {
        DEREFERENCE_CONNECTION (connection);
    }

    return status;

} // AfdSetInformation


NTSTATUS
AfdSetInLineMode (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN InLine
    )

/*++

Routine Description:

    Sets a connection to be in inline mode.  In inline mode, urgent data
    is delivered in the order in which it is received.  We must tell the
    TDI provider about this so that it indicates data in the proper
    order.

Arguments:

    Connection - the AFD connection to set as inline.

    InLine - TRUE to enable inline mode, FALSE to disable inline mode.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully
        performed.

--*/

{
    //
    // Since TCP does not implement this correctly, do everything in AFD!!!
    // Background:
    //  When this options is enabled, TCP indicates all the data as normal
    //  data, so we end up mixing it together which is against the spec.
    //  Also, since TCP stops reporting expedited data, SIOATMARK fails
    //  to report presence of OOB data altogether.
    //  When handling OOB data completely inside AFD we can only run into
    //  one problem:  if AFD runs out of its receive buffer for the socket
    //  and refuses to accept more data from TCP so that TCP buffers it
    //  within itself, any OOB data arriving at this point can be indicated
    //  out of order (not inline).
    //
    // Well, this appears to be even worse. Some apps (SQL) send more than
    // one byte of OOB data, TCP can only send one, so it sends everything
    // but the last byte as normal and the last one as OOB.  It then turns
    // around and indicates the OOB (last byte) first which breaks the
    // ordering required by OOBINLINE.
    // In the end, we are broken one way or the other, so keep the things
    // the way they were for number of years and wait for TCP to fix. 
    NTSTATUS status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    TCPSocketOption *option;
    UCHAR buffer[sizeof(*setInfoEx) + sizeof(*option)];
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE( );

    //
    // Initialize the TDI information buffers.
    //

    setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)buffer;

    setInfoEx->ID.toi_entity.tei_entity = CO_TL_ENTITY;
    setInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    setInfoEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    setInfoEx->ID.toi_type = INFO_TYPE_CONNECTION;
    setInfoEx->ID.toi_id = TCP_SOCKET_OOBINLINE;
    setInfoEx->BufferSize = sizeof(*option);

    option = (TCPSocketOption *)&setInfoEx->Buffer;
    option->tso_value = InLine;



    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Build TDI set information IRP.
    //

    irp = IoBuildDeviceIoControlRequest (
                    IOCTL_TCP_SET_INFORMATION_EX,
                    Connection->DeviceObject,
                    setInfoEx,
                    sizeof(*setInfoEx) + setInfoEx->BufferSize,
                    NULL,
                    0,
                    FALSE,  // InternalDeviceIoControl
                    &event,
                    &ioStatusBlock);
    if (irp==NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = Connection->FileObject;

    //
    // Call the driver.
    //
    status = IoCallDriver (Connection->DeviceObject, irp);

    //
    // Must be at below APC level or this IRP will never get fully completed.
    //
    ASSERT (KeGetCurrentIrql ()<APC_LEVEL);

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (status==STATUS_SUCCESS);
    }
    else {
        //
        // The IRP must have been completed then and event set.
        //
        if (NT_ERROR (status) || KeReadStateEvent (&event))
            ;
        else {
            DbgPrint ("************************************************\n");
            DbgPrint ("*AFD: IoCallDriver returned STATUS_SUCCESS,"
                        " but event in the IRP (%p) is NOT signalled!!!\n",
                        irp);
            DbgPrint ("************************************************\n");
            DbgBreakPoint ();
        }
    }

    //
    // If the request was successfully completed, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }


    //
    // Since this option is only supported for TCP/IP, always return success.
    //

    return STATUS_SUCCESS;

} // AfdSetInLineMode

//
// The locking mechanism idea below is stolen from ntos\ex\handle.c
//

PVOID
AfdLockEndpointContext (
    PAFD_ENDPOINT   Endpoint
    )
{
    PVOID   context;
    PAGED_CODE ();


    //
    // We now use this lock in APC, protect from being
    // interrupted by the APC by disallowing them when we
    // are holding the lock.
    //
    KeEnterCriticalRegion ();
    while (1) {
        context = Endpoint->Context;
        //
        // See if someone else is manipulating the context.
        //
        if ((context==AFD_CONTEXT_BUSY) ||
                (context==AFD_CONTEXT_WAITING)) {
            //
            // If this has not changed while we were checking,
            // tell the current owner that we are waiting (if not
            // already told) and wait for a few miliseconds.
            //
            if (InterlockedCompareExchangePointer (
                    (PVOID *)&Endpoint->Context,
                    AFD_CONTEXT_WAITING,
                    context)==context) {
                NTSTATUS        status;
                LARGE_INTEGER afd10Milliseconds = {(ULONG)(-10 * 1000 * 10), -1};
                
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                            "AfdLockEndpointContext: Waiting for endp %p\n",
                            Endpoint));

                KeLeaveCriticalRegion ();

                status = KeWaitForSingleObject( (PVOID)&AfdContextWaitEvent,
                                                        Executive,
                                                        KernelMode,  
                                                        FALSE,
                                                        &afd10Milliseconds);
                KeEnterCriticalRegion ();
            }
            else {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                            "AfdLockEndpointContext: ICEP contention on %p\n",
                            Endpoint));
            }
            //
            // Try again.
            //
        }
        else {
            //
            // Context is not owned, try to get the ownership
            //
            if (InterlockedCompareExchangePointer (
                    (PVOID *)&Endpoint->Context,
                    AFD_CONTEXT_BUSY,
                    context)==context) {
                //
                // We now own the context, return it.
                //
                break;
            }
            //
            // Try again.
            //
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdLockEndpointContext: ICEP contention on %p\n",
                        Endpoint));
            
        }
    }

    return context;
}

VOID
AfdUnlockEndpointContext (
    PAFD_ENDPOINT   Endpoint,
    PVOID           Context
    )
{
    PAGED_CODE ();

    ASSERT ((Context!=AFD_CONTEXT_BUSY) && (Context!=AFD_CONTEXT_WAITING));

    //
    // Set the new context pointer and see what the old value was.
    //
    Context = InterlockedExchangePointer ((PVOID)&Endpoint->Context, Context);
    if (Context==AFD_CONTEXT_WAITING) {
        LONG    prevState;
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdUnlockEndpointContext: Unwaiting endp %p\n", Endpoint));
        //
        // Someone was waiting, tell them to go get it now.
        //
        prevState = KePulseEvent (&AfdContextWaitEvent, 
                                    AfdPriorityBoost,
                                    FALSE
                                    );
        ASSERT (prevState==0);
    }
    else {
        //
        // Better be busy or someone has changed it on us.
        //
        ASSERT (Context==AFD_CONTEXT_BUSY);
    }
    KeLeaveCriticalRegion ();

}

    

NTSTATUS
AfdGetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    PAFD_ENDPOINT endpoint;
    PVOID         context;
    NTSTATUS      status;

    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    *Information = 0;



    context = AfdLockEndpointContext (endpoint);

    //
    // Make sure that the output buffer is large enough to hold all the
    // context information for this socket.
    //

    //
    // If there is no context, return nothing.
    //

    if ( context == NULL ) {
        status = STATUS_INVALID_PARAMETER;
    }

    //
    // Return the context information we have stored for this endpoint.
    //

    else {
        //
        // If application buffer is too small, just
        // copy whatever fits in and return the error code.
        //
        if ( OutputBufferLength < endpoint->ContextLength ) {
            status = STATUS_BUFFER_OVERFLOW;
        }
        else {
            OutputBufferLength = endpoint->ContextLength;
            if (IS_SAN_ENDPOINT (endpoint)) {
                //
                // Indicate to the caller that it may also need to
                // acqiure the control of the endpoint and
                // fetch san specific information.
                //
                status = STATUS_MORE_ENTRIES;
            }
            else {
                status = STATUS_SUCCESS;
            }
        }

        try {


            //
            // Validate the output structure if it comes from the user mode
            // application
            //
            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                OutputBufferLength,
                                sizeof (UCHAR));
            }



            //
            // Copy parameters back to application's memory
            //

            RtlCopyMemory(
                OutputBuffer,
                context,
                OutputBufferLength
                );

            *Information = endpoint->ContextLength;

        } except( AFD_EXCEPTION_FILTER(&status) ) {
        }
    }

    AfdUnlockEndpointContext (endpoint, context);

    return status;

} // AfdGetContext


NTSTATUS
AfdGetRemoteAddress (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    PAFD_ENDPOINT endpoint;
    PVOID       context;
    NTSTATUS    status;

    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    *Information = 0;

    context = AfdLockEndpointContext (endpoint);
    //
    // If there is no context or endpoint is of wrong type state or
    // context information has been changed below the original size,
    // return error.
    //

    if ( context == NULL ||
            endpoint->Type!=AfdBlockTypeVcConnecting ||
            endpoint->State!= AfdEndpointStateConnected ||
            ((CLONG)(endpoint->Common.VcConnecting.RemoteSocketAddressOffset+
                endpoint->Common.VcConnecting.RemoteSocketAddressLength)) >
                    endpoint->ContextLength
            ) {
        status = STATUS_INVALID_CONNECTION;
    }
    else {

        if (OutputBufferLength<endpoint->Common.VcConnecting.RemoteSocketAddressLength) {
            status = STATUS_BUFFER_OVERFLOW;
        }
        else {
            OutputBufferLength = endpoint->Common.VcConnecting.RemoteSocketAddressLength;
            status = STATUS_SUCCESS;
        }

        try {

            //
            // Validate the output structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForWrite (OutputBuffer,
                                OutputBufferLength,
                                sizeof (UCHAR));
            }

            //
            // Copy parameters to application's memory
            //

            RtlCopyMemory(
                OutputBuffer,
                (PUCHAR)context+endpoint->Common.VcConnecting.RemoteSocketAddressOffset,
                endpoint->Common.VcConnecting.RemoteSocketAddressLength
                );

            *Information = endpoint->ContextLength;


        } except( AFD_EXCEPTION_FILTER(&status) ) {
        }
    }

    AfdUnlockEndpointContext (endpoint, context);

    return status;

} // AfdGetRemoteAddress


NTSTATUS
AfdSetContext (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    PAFD_ENDPOINT endpoint;
    PVOID context;
    NTSTATUS status;

    PAGED_CODE( );

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    status = STATUS_SUCCESS;
    *Information = 0;

    context = AfdLockEndpointContext (endpoint);
    try {

        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForRead (InputBuffer,
                            InputBufferLength,
                            sizeof (UCHAR));

            if (OutputBuffer!=NULL) {
                //
                // Validate that output buffer is completely inside
                // of the input buffer and offsets are inside of supported ranges.
                //
                if ((PUCHAR)OutputBuffer<(PUCHAR)InputBuffer ||
                        (PUCHAR)OutputBuffer-(PUCHAR)InputBuffer>MAXUSHORT ||
                        OutputBufferLength>MAXUSHORT ||
                        OutputBufferLength>InputBufferLength ||
                        (ULONG)((PUCHAR)OutputBuffer-(PUCHAR)InputBuffer)>
                            InputBufferLength-OutputBufferLength) {
                    ExRaiseStatus (STATUS_INVALID_PARAMETER);
                }
            }
        }

        //
        // If the context buffer is too small, allocate a new context 
        // buffer from paged pool.
        //

        if ( endpoint->ContextLength < InputBufferLength ) {

            PVOID newContext;


            //
            // Allocate a new context buffer.
            // Note since the socket context usually gets
            // populated on socket creation during boot and not used 
            // right away (untill socket state is chaged), we
            // make it a "cold" allocation.  The flag has no effect
            // after system is booted.

            newContext = AFD_ALLOCATE_POOL_WITH_QUOTA(
                                 PagedPool|POOL_COLD_ALLOCATION,
                                 InputBufferLength,
                                 AFD_CONTEXT_POOL_TAG
                                 );

            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
            ASSERT ( newContext != NULL );

            //
            // Free the old context buffer, if there was one.
            //

            if ( context != NULL ) {

                AFD_FREE_POOL(
                    context,
                    AFD_CONTEXT_POOL_TAG
                    );

            }

            context = newContext;
        }

        //
        // Store the passed-in context buffer.
        //

        endpoint->ContextLength = InputBufferLength;

        RtlCopyMemory(
            context,
            InputBuffer,
            InputBufferLength
            );
        status = STATUS_SUCCESS;
        //
        // Save pointer to remote socket address which we fill
        // at the time of AcceptEx processing.
        //
        if (OutputBuffer!=NULL) {
            if (AFD_START_STATE_CHANGE (endpoint, AfdEndpointStateOpen)) {
                if (endpoint->Type==AfdBlockTypeEndpoint &&
                        endpoint->State==AfdEndpointStateOpen) {
                    endpoint->Common.VcConnecting.RemoteSocketAddressOffset =
                                (USHORT) ((PUCHAR)OutputBuffer-(PUCHAR)InputBuffer);
                    endpoint->Common.VcConnecting.RemoteSocketAddressLength =
                                (USHORT) OutputBufferLength;
                }
                AFD_END_STATE_CHANGE (endpoint);
            }
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
    }

    AfdUnlockEndpointContext (endpoint, context);
    return status;

} // AfdSetContext


NTSTATUS
AfdSetEventHandler (
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID EventContext
    )

/*++

Routine Description:

    Sets up a TDI indication handler on a connection or address object
    (depending on the file handle).  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT parameters;

    PAGED_CODE( );

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;

    return AfdIssueDeviceControl(
               FileObject,
               &parameters,
               sizeof(parameters),
               NULL,
               0,
               TDI_SET_EVENT_HANDLER
               );

} // AfdSetEventHandler


NTSTATUS
AfdIssueDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN PVOID IrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID MdlBuffer,
    IN ULONG MdlBufferLength,
    IN UCHAR MinorFunction
    )

/*++

Routine Description:

    Issues a device control returst to a TDI provider and waits for the
    request to complete.


Arguments:

    FileObject - a pointer to the file object corresponding to a TDI
        handle

    IrpParameters - information to write to the parameters section of the
        stack location of the IRP.

    IrpParametersLength - length of the parameter information.  Cannot be
        greater than 16.

    MdlBuffer - if non-NULL, a buffer of nonpaged pool to be mapped
        into an MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - the size of the buffer pointed to by MdlBuffer.

    MinorFunction - the minor function code for the request.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    PDEVICE_OBJECT deviceObject;
    PMDL mdl;

    PAGED_CODE( );

    //
    // Initialize the kernel event that will signal I/O completion.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Attempt to allocate and initialize the I/O Request Packet (IRP)
    // for this operation.
    //

    deviceObject = IoGetRelatedDeviceObject ( FileObject );

    DEBUG ioStatusBlock.Status = STATUS_UNSUCCESSFUL;
    DEBUG ioStatusBlock.Information = (ULONG)-1;

    //
    // If an MDL buffer was specified, get an MDL, and map the buffer
    //

    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  NULL
                  );
        if ( mdl == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        mdl = NULL;
    }

    irp = TdiBuildInternalDeviceControlIrp (
                MinorFunction,
                deviceObject,
                FileObject,
                &event,
                &ioStatusBlock
                );

    if ( irp == NULL ) {
        if (mdl!=NULL) {
            IoFreeMdl (mdl);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Install MDL (if any) in the IRP.
    //
    irp->MdlAddress = mdl;

    //
    // Put the file object pointer in the stack location.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    ASSERT (irpSp->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL);
    irpSp->MinorFunction = MinorFunction;
    irpSp->FileObject = FileObject;

    //
    // Fill in the service-dependent parameters for the request.
    //

    ASSERT( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );


    //
    // Set up a completion routine which we'll use to free the MDL
    // allocated previously.
    //

    IoSetCompletionRoutine( irp, AfdRestartDeviceControl, NULL, TRUE, TRUE, TRUE );

    status = IoCallDriver( deviceObject, irp );

    //
    // Must be at below APC level or this IRP will never get fully completed.
    //
    ASSERT (KeGetCurrentIrql ()<APC_LEVEL);

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        status = KeWaitForSingleObject( (PVOID)&event, Executive, KernelMode,  FALSE, NULL );
        ASSERT (status==STATUS_SUCCESS);
    }
    else {
        //
        // The IRP must have been completed then and event set.
        //
        if (NT_ERROR (status) || KeReadStateEvent (&event))
            ;
        else {
            DbgPrint ("************************************************\n");
            DbgPrint ("*AFD: IoCallDriver returned STATUS_SUCCESS,"
                        " but event in the IRP (%p) is NOT signalled!!!\n",
                        irp);
            DbgPrint ("************************************************\n");
            DbgBreakPoint ();
        }
    }

    //
    // If the request was successfully completed, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    return status;

} // AfdIssueDeviceControl


NTSTATUS
AfdRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    //
    // N.B.  This routine can never be demand paged because it can be
    // called before any endpoints have been placed on the global
    // list--see AfdAllocateEndpoint() and it's call to
    // AfdGetTransportInfo().
    //

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    return STATUS_SUCCESS;

} // AfdRestartDeviceControl


NTSTATUS
AfdGetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECT_DATA_INFO connectDataInfo;
    AFD_UNACCEPTED_CONNECT_DATA_INFO connectInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PMDL    mdl;
    NTSTATUS status;
    UCHAR   localBuffer[AFD_FAST_CONNECT_DATA_SIZE];

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    mdl = NULL;
    status = STATUS_SUCCESS;
    *Information = 0;

    try {
        if (InputBufferLength>0) {
            if (InputBufferLength<sizeof(connectInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (connectInfo),
                                PROBE_ALIGNMENT(AFD_UNACCEPTED_CONNECT_DATA_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            connectInfo = *((PAFD_UNACCEPTED_CONNECT_DATA_INFO)InputBuffer);
  
            if (connectInfo.LengthOnly &&
                    OutputBufferLength<sizeof (connectInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
        }

        if (OutputBufferLength>0) {
            if (OutputBufferLength>sizeof (localBuffer)) {
                mdl = IoAllocateMdl(
                                OutputBuffer,       // VirtualAddress
                                OutputBufferLength, // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                MmProbeAndLockPages(
                    mdl,                        // MemoryDescriptorList
                    RequestorMode,              // AccessMode
                    IoWriteAccess               // Operation
                    );
                OutputBuffer = MmGetSystemAddressForMdlSafe(mdl, LowPagePriority);
                if (OutputBuffer==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }
            else {
                if (RequestorMode!=KernelMode) {
                    ProbeForWrite (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (UCHAR));
                }
            }
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto exit;
    }

    //
    // If there is a connection on this endpoint, use the data buffers
    // on the connection.  Otherwise, use the data buffers from the
    // endpoint.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );


    if (InputBufferLength>0) {
        if ((endpoint->Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
            connection = AfdFindReturnedConnection(
                         endpoint,
                         connectInfo.Sequence
                         );
        }
        else
            connection = NULL;

        if( connection == NULL ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
        connectDataBuffers = connection->ConnectDataBuffers;
    }
    else if ( (connection= AFD_CONNECTION_FROM_ENDPOINT (endpoint)) != NULL ) {
        connectDataBuffers = connection->ConnectDataBuffers;
    } else if (IS_VC_ENDPOINT (endpoint)) {
        connectDataBuffers = endpoint->Common.VirtualCircuit.ConnectDataBuffers;
    }
    else {
        connectDataBuffers = NULL;
    }

    //
    // If there are no connect data buffers on the endpoint, complete
    // the IRP with no bytes.
    //

    if ( connectDataBuffers == NULL ) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // Determine what sort of data we're handling and where it should
    // come from.
    //

    switch ( IoctlCode ) {

    case IOCTL_AFD_GET_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveConnectData;
        break;

    case IOCTL_AFD_GET_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveConnectOptions;
        break;

    case IOCTL_AFD_GET_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectData;
        break;

    case IOCTL_AFD_GET_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectOptions;
        break;

    default:
        ASSERT(!"Unknown GET_CONNECT_DATA IOCTL!");
        __assume (0);
    }

    if ((InputBufferLength>0) && connectInfo.LengthOnly) {

        connectInfo.ConnectDataLength = connectDataInfo->BufferLength;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        try {
            RtlCopyMemory (OutputBuffer,
                            &connectInfo,
                            sizeof (connectInfo));
            *Information = sizeof (connectInfo);
            status = STATUS_SUCCESS;
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
        }
        goto exit;
    }

    //
    // If there is none of the requested data type, again complete
    // the IRP with no bytes.
    //

    if ( connectDataInfo->Buffer == NULL ||
             connectDataInfo->BufferLength == 0 ) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        *Information = 0;
        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // If the output buffer is too small, fail.
    //

    if ( OutputBufferLength < connectDataInfo->BufferLength ) {
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_BUFFER_TOO_SMALL;
        goto exit;
    }

    
    //
    // Copy over the buffer and return the number of bytes copied.
    //

    RtlCopyMemory(
        mdl ? OutputBuffer : localBuffer,
        connectDataInfo->Buffer,
        connectDataInfo->BufferLength
        );

    *Information = connectDataInfo->BufferLength;

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (mdl==NULL) {
        try {
            RtlCopyMemory (OutputBuffer,
                            localBuffer,
                            *Information);
        }
        except (AFD_EXCEPTION_FILTER(&status)) {
            *Information = 0;
        }
    }

exit:

    if (mdl!=NULL) {
        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    return status;

} // AfdGetConnectData


NTSTATUS
AfdSetConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECT_DATA_BUFFERS * connectDataBuffersTarget;
    PAFD_CONNECT_DATA_INFO connectDataInfo;
    AFD_UNACCEPTED_CONNECT_DATA_INFO connectInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN size = FALSE;
    PMDL    mdl;
    NTSTATUS status;
    UCHAR   localBuffer[AFD_FAST_CONNECT_DATA_SIZE];

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    mdl = NULL;
    status = STATUS_SUCCESS;
    *Information = 0;

    if (!IS_VC_ENDPOINT (endpoint)) {
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    try {
        if (InputBufferLength>0) {
            if (InputBufferLength<sizeof(connectInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto exit;
            }
            //
            // Validate the input structure if it comes from the user mode
            // application
            //

            if (RequestorMode != KernelMode ) {
                ProbeForRead (InputBuffer,
                                sizeof (connectInfo),
                                PROBE_ALIGNMENT(AFD_UNACCEPTED_CONNECT_DATA_INFO));
            }

            //
            // Make local copies of the embeded pointer and parameters
            // that we will be using more than once in case malicios
            // application attempts to change them while we are
            // validating
            //

            connectInfo = *((PAFD_UNACCEPTED_CONNECT_DATA_INFO)InputBuffer);

        }

        if (OutputBufferLength>0) {
            if (OutputBufferLength>sizeof (localBuffer)) {
                mdl = IoAllocateMdl(
                                OutputBuffer,       // VirtualAddress
                                OutputBufferLength, // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                MmProbeAndLockPages(
                    mdl,                        // MemoryDescriptorList
                    RequestorMode,              // AccessMode
                    IoReadAccess               // Operation
                    );
                OutputBuffer = MmGetSystemAddressForMdlSafe(mdl, LowPagePriority);
                if (OutputBuffer==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }
            else {
                if (RequestorMode!=KernelMode) {
                    ProbeForRead (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (UCHAR));
                    RtlCopyMemory (localBuffer,
                                        OutputBuffer,
                                        OutputBufferLength);
                    OutputBuffer = localBuffer;
                }
            }
        }
    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto exit;
    }


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there is a connect outstanding on this endpoint or if it
    // has already been shut down, fail this request.  This prevents
    // the connect code from accessing buffers which may be freed soon.
    //

    if( endpoint->StateChangeInProgress ||
        ((endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 )) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto exit;
    }

    if (InputBufferLength>0) {
        if ((endpoint->Type & AfdBlockTypeVcListening)==AfdBlockTypeVcListening) {
            connection = AfdFindReturnedConnection(
                         endpoint,
                         connectInfo.Sequence
                         );
        }
        else
            connection = NULL;

        if( connection == NULL ) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
        connectDataBuffersTarget = &connection->ConnectDataBuffers;
    }
    else if ( (connection= AFD_CONNECTION_FROM_ENDPOINT (endpoint)) != NULL ) {
        connectDataBuffersTarget = &connection->ConnectDataBuffers;
    } else {
        connectDataBuffersTarget = &endpoint->Common.VirtualCircuit.ConnectDataBuffers;
    }


    connectDataBuffers = *connectDataBuffersTarget;

    if( connectDataBuffers == NULL ) {

        try {

            connectDataBuffers = AFD_ALLOCATE_POOL_WITH_QUOTA(
                                     NonPagedPool,
                                     sizeof(*connectDataBuffers),
                                     AFD_CONNECT_DATA_POOL_TAG
                                     );

            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
            ASSERT ( connectDataBuffers != NULL );
            *connectDataBuffersTarget = connectDataBuffers;

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            status = GetExceptionCode ();
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            goto exit;
        }


        RtlZeroMemory(
            connectDataBuffers,
            sizeof(*connectDataBuffers)
            );

    }

    //
    // Determine what sort of data we're handling and where it should
    // go.
    //

    switch( IoctlCode ) {

    case IOCTL_AFD_SET_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->SendConnectData;
        break;

    case IOCTL_AFD_SET_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->SendConnectOptions;
        break;

    case IOCTL_AFD_SET_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->SendDisconnectData;
        break;

    case IOCTL_AFD_SET_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->SendDisconnectOptions;
        break;

    case IOCTL_AFD_SIZE_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveConnectData;
        size = TRUE;
        break;

    case IOCTL_AFD_SIZE_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveConnectOptions;
        size = TRUE;
        break;

    case IOCTL_AFD_SIZE_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectData;
        size = TRUE;
        break;

    case IOCTL_AFD_SIZE_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectOptions;
        size = TRUE;
        break;

    default:
        ASSERT(FALSE);
    }


    //
    // Determine the buffer size based on whether we're setting a buffer
    // into which data will be received, in which case the size is
    // in the four bytes of input buffer, or setting a buffer which we're
    // going to send, in which case the size is the length of the input
    // buffer.
    //

    if( size ) {

        if( OutputBufferLength < sizeof(ULONG) ) {
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }
        OutputBufferLength = *(ULONG UNALIGNED *)OutputBuffer;
    }

    //
    // If there's not currently a buffer of the requested type, or there is
    // such a buffer and it's smaller than the requested size, free it
    // and allocate a new one.
    //

    if( connectDataInfo->Buffer == NULL ||
        connectDataInfo->BufferLength < OutputBufferLength ) {

        if( connectDataInfo->Buffer != NULL ) {

            AFD_FREE_POOL(
                connectDataInfo->Buffer,
                AFD_CONNECT_DATA_POOL_TAG
                );

        }

        connectDataInfo->Buffer = NULL;
        connectDataInfo->BufferLength = 0;

        if (OutputBufferLength>0) {
            try {

                connectDataInfo->Buffer = AFD_ALLOCATE_POOL_WITH_QUOTA(
                                              NonPagedPool,
                                              OutputBufferLength,
                                              AFD_CONNECT_DATA_POOL_TAG
                                              );

                // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
                ASSERT ( connectDataInfo->Buffer != NULL );
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                status = GetExceptionCode ();
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                goto exit;

            }


            RtlZeroMemory(
                connectDataInfo->Buffer,
                OutputBufferLength
                );
        }
    }

    //
    // If this wasn't simply a "size" request, copy the data into the buffer.
    //

    if( !size ) {

        RtlCopyMemory(
            connectDataInfo->Buffer,
            OutputBuffer,
            OutputBufferLength
            );

    }

    connectDataInfo->BufferLength = OutputBufferLength;

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

exit:
    if (mdl!=NULL) {
        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    return status;

} // AfdSetConnectData


NTSTATUS
AfdSaveReceivedConnectData (
    IN OUT PAFD_CONNECT_DATA_BUFFERS * DataBuffers,
    IN ULONG IoControlCode,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This helper routine stores the specified *received* connect/disconnect
    data/options on the specified endpoint/connection.

    N.B. This routine MUST be called with endpoint SpinLock held!

    N.B. Unlike AfdSetConnectData(), this routine cannot allocate the
         AFD_CONNECT_DATA_BUFFERS structure with quota, as it may be
         called from AfdDisconnectEventHandler() in an unknown thread
         context.

Arguments:

    DataBuffers -Points to a pointer to the connect data buffers structure.
        If the value pointed to by DataBuffers is NULL, then a new structure
        is allocated, otherwise the existing structure is used.

    IoControlCode - Specifies the type of data to save.

    Buffer - Points to the buffer containing the data.

    BufferLength - The length of Buffer.

Return Value:

    NTSTATUS - The completion status.

--*/

{
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    PAFD_CONNECT_DATA_INFO connectDataInfo;

    ASSERT( KeGetCurrentIrql() >= DISPATCH_LEVEL );

    //
    // If there's no connect data buffer structure, allocate one now.
    //

    connectDataBuffers = *DataBuffers;

    if( connectDataBuffers == NULL ) {

        connectDataBuffers = AFD_ALLOCATE_POOL(
                                 NonPagedPool,
                                 sizeof(*connectDataBuffers),
                                 AFD_CONNECT_DATA_POOL_TAG
                                 );

        if( connectDataBuffers == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        RtlZeroMemory(
            connectDataBuffers,
            sizeof(*connectDataBuffers)
            );

        *DataBuffers = connectDataBuffers;

    }

    //
    // Determine what sort of data we're handling and where it should
    // go.
    //

    switch( IoControlCode ) {

    case IOCTL_AFD_SET_CONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveConnectData;
        break;

    case IOCTL_AFD_SET_CONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveConnectOptions;
        break;

    case IOCTL_AFD_SET_DISCONNECT_DATA:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectData;
        break;

    case IOCTL_AFD_SET_DISCONNECT_OPTIONS:
        connectDataInfo = &connectDataBuffers->ReceiveDisconnectOptions;
        break;

    default:
        ASSERT(FALSE);
    }

    //
    // If the buffer in the connect structure matches the one
    // passed in, must be the same buffer we passed in the request.
    // Just adjust the length.
    //

    if (connectDataInfo->Buffer==Buffer) {
        ASSERT (connectDataInfo->BufferLength>=BufferLength);
        connectDataInfo->BufferLength = BufferLength;
        return STATUS_SUCCESS;
    }

    //
    // If there was previously a buffer of the requested type, free it.
    //

    if( connectDataInfo->Buffer != NULL ) {

        AFD_FREE_POOL(
            connectDataInfo->Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );

        connectDataInfo->Buffer = NULL;

    }

    //
    // Allocate a new buffer for the data and copy in the data we're to
    // send.
    //

    connectDataInfo->Buffer = AFD_ALLOCATE_POOL(
                                  NonPagedPool,
                                  BufferLength,
                                  AFD_CONNECT_DATA_POOL_TAG
                                  );

    if( connectDataInfo->Buffer == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlCopyMemory(
        connectDataInfo->Buffer,
        Buffer,
        BufferLength
        );

    connectDataInfo->BufferLength = BufferLength;
    return STATUS_SUCCESS;

} // AfdSaveReceivedConnectData


VOID
AfdFreeConnectDataBuffers (
    IN PAFD_CONNECT_DATA_BUFFERS ConnectDataBuffers
    )
{
    if ( ConnectDataBuffers->SendConnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendConnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveConnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveConnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->SendConnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendConnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveConnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveConnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->SendDisconnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendDisconnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveDisconnectData.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveDisconnectData.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->SendDisconnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->SendDisconnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    if ( ConnectDataBuffers->ReceiveDisconnectOptions.Buffer != NULL ) {
        AFD_FREE_POOL(
            ConnectDataBuffers->ReceiveDisconnectOptions.Buffer,
            AFD_CONNECT_DATA_POOL_TAG
            );
    }

    AFD_FREE_POOL(
        ConnectDataBuffers,
        AFD_CONNECT_DATA_POOL_TAG
        );

    return;

} // AfdFreeConnectDataBuffers



VOID
AfdQueueWorkItem (
    IN PWORKER_THREAD_ROUTINE AfdWorkerRoutine,
    IN PAFD_WORK_ITEM AfdWorkItem
    )
{
    KIRQL oldIrql;

    ASSERT( AfdWorkerRoutine != NULL );
    ASSERT( AfdWorkItem != NULL );

    AfdWorkItem->AfdWorkerRoutine = AfdWorkerRoutine;

    //
    // Insert the work item at the tail of AFD's list of work itrems.
    //

    oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );

    InsertTailList( &AfdWorkQueueListHead, &AfdWorkItem->WorkItemListEntry );

    AfdRecordAfdWorkItemsQueued();

    //
    // If there is no executive worker thread working on AFD work, fire
    // off an executive worker thread to start servicing the list.
    //

    if ( !AfdWorkThreadRunning ) {

        //
        // Remember that the work thread is running and release the
        // lock.  Note that we must release the lock before queuing the
        // work because the worker thread may unlock AFD and we can't
        // hold a lock when AFD is unlocked.
        //

        AfdRecordExWorkItemsQueued();

        AfdWorkThreadRunning = TRUE;
        KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );

        IoQueueWorkItem (AfdWorkQueueItem,
                            AfdDoWork,
                            DelayedWorkQueue,
                            NULL);

    } else {

        KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );
    }

    return;

} // AfdQueueWorkItem


VOID
AfdDoWork (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
{
    PAFD_WORK_ITEM afdWorkItem;
    PLIST_ENTRY listEntry;
    KIRQL oldIrql;
    PWORKER_THREAD_ROUTINE workerRoutine;

    ASSERT( AfdWorkThreadRunning );

    //
    // Empty the queue of AFD work items.
    //

    oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );

    AfdRecordWorkerEnter();
    AfdRecordAfdWorkerThread( PsGetCurrentThread() );

    while ( !IsListEmpty( &AfdWorkQueueListHead ) ) {

        //
        // Take the first item from the queue and find the address
        // of the AFD work item structure.
        //

        listEntry = RemoveHeadList( &AfdWorkQueueListHead );
        afdWorkItem = CONTAINING_RECORD(
                          listEntry,
                          AFD_WORK_ITEM,
                          WorkItemListEntry
                          );

        AfdRecordAfdWorkItemsProcessed();

        //
        // Capture the worker thread routine from the item.
        //

        workerRoutine = afdWorkItem->AfdWorkerRoutine;

        //
        // If this work item is going to unlock AFD, then remember that
        // the worker thread is no longer running.  This closes the
        // window where AFD gets unloaded at the same time as new work
        // comes in and gets put on the work queue.  Note that we
        // must reset this boolean BEFORE releasing the spin lock.
        //

        if( workerRoutine == AfdUnlockDriver ) {

            AfdWorkThreadRunning = FALSE;

            AfdRecordAfdWorkerThread( NULL );
            AfdRecordWorkerLeave();

        }

        //
        // Release the lock and then call the AFD worker routine.
        //

        KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );

        workerRoutine( afdWorkItem );

        //
        // If the purpose of this work item was to unload AFD, then
        // we know that there is no more work to do and we CANNOT
        // acquire a spin lock.  Quit servicing the list and return.

        if( workerRoutine == AfdUnlockDriver ) {
            return;
        }

        //
        // Reacquire the spin lock and continue servicing the list.
        //

        oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );
    }

    //
    // Remember that we're no longer servicing the list and release the
    // spin lock.
    //

    AfdRecordAfdWorkerThread( NULL );
    AfdRecordWorkerLeave();

    AfdWorkThreadRunning = FALSE;
    KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );

} // AfdDoWork




PAFD_WORK_ITEM
AfdGetWorkerByRoutine (
    PWORKER_THREAD_ROUTINE  Routine
    ) {
    KIRQL       oldIrql;
    PLIST_ENTRY listEntry;

    oldIrql = KeAcquireQueuedSpinLock( LockQueueAfdWorkQueueLock );
    listEntry = AfdWorkQueueListHead.Flink;
    while (listEntry!=&AfdWorkQueueListHead) {
        PAFD_WORK_ITEM afdWorkItem = CONTAINING_RECORD(
                                          listEntry,
                                          AFD_WORK_ITEM,
                                          WorkItemListEntry
                                          );
        if (afdWorkItem->AfdWorkerRoutine==Routine) {
            RemoveEntryList (&afdWorkItem->WorkItemListEntry);
            KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );
            return afdWorkItem;
        }
        else
            listEntry = listEntry->Flink;
    }
    KeReleaseQueuedSpinLock( LockQueueAfdWorkQueueLock, oldIrql );
    return NULL;
} // AfdGetWorkerByRoutine


#if DBG

typedef struct _AFD_OUTSTANDING_IRP {
    LIST_ENTRY OutstandingIrpListEntry;
    PIRP OutstandingIrp;
    PCHAR FileName;
    ULONG LineNumber;
} AFD_OUTSTANDING_IRP, *PAFD_OUTSTANDING_IRP;


BOOLEAN
AfdRecordOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )
{
    PAFD_OUTSTANDING_IRP outstandingIrp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Get an outstanding IRP structure to hold the IRP.
    //

    outstandingIrp = AFD_ALLOCATE_POOL_PRIORITY (
                         NonPagedPool,
                         sizeof(AFD_OUTSTANDING_IRP),
                         AFD_DEBUG_POOL_TAG,
                         NormalPoolPriority
                         );

    if ( outstandingIrp == NULL ) {
        //
        // Because our completion routine will try to
        // find this IRP anyway and check for completion
        // we use the stack space to put it in the list.
        // The completion routine will just remove this
        // element from the list without attempting to free it.
        //
        AFD_OUTSTANDING_IRP OutstandingIrp;

        OutstandingIrp.OutstandingIrp = Irp;
        OutstandingIrp.FileName = NULL; // To let completion
                                        // routine know that this
                                        // is not an allocated element
        OutstandingIrp.LineNumber = 0;

        AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
        InsertTailList(
            &Endpoint->OutstandingIrpListHead,
            &OutstandingIrp.OutstandingIrpListEntry
            );
        Endpoint->OutstandingIrpCount++;
        AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
        
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdRecordOutstandingIrp: Could not track Irp %p on endpoint %p, failing it.\n",
                    Irp, Endpoint));
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoSetNextIrpStackLocation( Irp );
        IoCompleteRequest( Irp, AfdPriorityBoost );
        return FALSE;
    }

    //
    // Initialize the structure and place it on the endpoint's list of
    // outstanding IRPs.
    //

    outstandingIrp->OutstandingIrp = Irp;
    outstandingIrp->FileName = FileName;
    outstandingIrp->LineNumber = LineNumber;

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );
    InsertHeadList(
        &Endpoint->OutstandingIrpListHead,
        &outstandingIrp->OutstandingIrpListEntry
        );
    Endpoint->OutstandingIrpCount++;
    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    return TRUE;
} // AfdRecordOutstandingIrpDebug


VOID
AfdCompleteOutstandingIrpDebug (
    IN PAFD_ENDPOINT Endpoint,
    IN PIRP Irp
    )
{
    PAFD_OUTSTANDING_IRP outstandingIrp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY listEntry;

    //
    // First find the IRP on the endpoint's list of outstanding IRPs.
    //

    AfdAcquireSpinLock( &Endpoint->SpinLock, &lockHandle );

    for ( listEntry = Endpoint->OutstandingIrpListHead.Flink;
          listEntry != &Endpoint->OutstandingIrpListHead;
          listEntry = listEntry->Flink ) {

        outstandingIrp = CONTAINING_RECORD(
                             listEntry,
                             AFD_OUTSTANDING_IRP,
                             OutstandingIrpListEntry
                             );
        if ( outstandingIrp->OutstandingIrp == Irp ) {
            RemoveEntryList( listEntry );
            ASSERT( Endpoint->OutstandingIrpCount != 0 );
            Endpoint->OutstandingIrpCount--;
            AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );
            if (outstandingIrp->FileName!=NULL) {
                AFD_FREE_POOL(
                    outstandingIrp,
                    AFD_DEBUG_POOL_TAG
                    );
            }
            return;
        }
    }

    //
    // The corresponding outstanding IRP structure was not found.  This
    // should never happen unless an allocate for an outstanding IRP
    // structure failed above.
    //

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AfdCompleteOutstandingIrp: Irp %p not found on endpoint %p\n",
                Irp, Endpoint ));

    ASSERT( Endpoint->OutstandingIrpCount != 0 );

    Endpoint->OutstandingIrpCount--;

    AfdReleaseSpinLock( &Endpoint->SpinLock, &lockHandle );

    return;

} // AfdCompleteOutstandingIrpDebug
#endif




#if REFERENCE_DEBUG
AFD_QSPIN_LOCK          AfdLocationTableLock;
PAFD_REFERENCE_LOCATION AfdLocationTable;
SIZE_T                  AfdLocationTableSize;
LONG                    AfdLocationId;

LONG
AfdFindReferenceLocation (
    IN  PCHAR   Format,
    OUT PLONG   LocationId
    )
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PVOID   ignore;

    AfdAcquireSpinLock (&AfdLocationTableLock, &lockHandle);
    if (*LocationId==0) {
        if (AfdLocationId >= (LONG)(AfdLocationTableSize/sizeof(AfdLocationTable[0]))) {
            PAFD_REFERENCE_LOCATION newTable;
            newTable = ExAllocatePoolWithTag (NonPagedPool,
                                AfdLocationTableSize+PAGE_SIZE,
                                AFD_DEBUG_POOL_TAG);
            if (newTable!=NULL) {
                if (AfdLocationTable!=NULL) {
                    RtlCopyMemory (newTable, AfdLocationTable, AfdLocationTableSize);
                    ExFreePoolWithTag (AfdLocationTable, AFD_DEBUG_POOL_TAG);
                }
                AfdLocationTable = newTable;
                AfdLocationTableSize += PAGE_SIZE;
            }
            else {
                goto Unlock;
            }
        }

        AfdLocationTable[AfdLocationId].Format = Format;
        RtlGetCallersAddress (&AfdLocationTable[AfdLocationId].Address, &ignore);

        *LocationId = ++AfdLocationId;
    }
Unlock:
    AfdReleaseSpinLock (&AfdLocationTableLock, &lockHandle);
    return *LocationId;
}

#endif


#if DBG || REFERENCE_DEBUG

VOID
AfdInitializeDebugData (
    VOID
    )
{
    AfdInitializeSpinLock (&AfdLocationTableLock);

} // AfdInitializeDebugData

VOID
AfdFreeDebugData (
    VOID
    )
{
    if (AfdLocationTable!=NULL) {
        ExFreePoolWithTag (AfdLocationTable, AFD_DEBUG_POOL_TAG);
        AfdLocationTable = NULL;
    }

} // AfdFreeDebugData
#endif

#if DBG

ULONG AfdTotalAllocations = 0;
ULONG AfdTotalFrees = 0;
LARGE_INTEGER AfdTotalBytesAllocated;
LARGE_INTEGER AfdTotalBytesFreed;



PVOID
AfdAllocatePool (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag,
    IN PCHAR FileName,
    IN ULONG LineNumber,
    IN BOOLEAN WithQuota,
    IN EX_POOL_PRIORITY Priority
    )
{

    PVOID            memBlock;
    PAFD_POOL_HEADER header;
    SIZE_T           allocBytes;

    //
    // Check for overflow first.
    //
    if (NumberOfBytes+sizeof (*header)<=NumberOfBytes) {
        if (WithQuota) {
            ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
        }
        return NULL;
    }

    if (NumberOfBytes+sizeof (*header)>=PAGE_SIZE) {
        allocBytes = NumberOfBytes;
        if (allocBytes<PAGE_SIZE)
            allocBytes = PAGE_SIZE;
    }
    else {
        allocBytes = NumberOfBytes+sizeof (*header);
    }


    if ( WithQuota ) {
        ASSERT (PoolType == (NonPagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                    PoolType == (PagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                    PoolType == (PagedPool|POOL_RAISE_IF_ALLOCATION_FAILURE|POOL_COLD_ALLOCATION));
        memBlock = ExAllocatePoolWithQuotaTag(
                     PoolType,
                     allocBytes,
                     Tag
                     );
        ASSERT (memBlock!=NULL);
    } else {
        ASSERT( PoolType == NonPagedPool ||
                PoolType == NonPagedPoolMustSucceed ||
                PoolType == PagedPool ||
                PoolType == (PagedPool|POOL_COLD_ALLOCATION));
        memBlock = ExAllocatePoolWithTagPriority(
                 PoolType,
                 allocBytes,
                 Tag,
                 Priority
                 );
        if ( memBlock == NULL ) {
            return NULL;
        }
    }


    if (allocBytes<PAGE_SIZE) {
        header = memBlock;
        memBlock = header+1;
        header->FileName = FileName;
        header->LineNumber = LineNumber;
        header->Size = NumberOfBytes;
        header->InUse = PoolType;

    }
    else {
        NumberOfBytes = PAGE_SIZE;
        ASSERT (PAGE_ALIGN(memBlock)==memBlock);
    }

    ExInterlockedAddLargeStatistic(
        &AfdTotalBytesAllocated,
        (CLONG)NumberOfBytes
        );
    InterlockedIncrement(
        &AfdTotalAllocations
        );

    return memBlock;

} // AfdAllocatePool

#define AFD_POOL_DEBUG  0
#if AFD_POOL_DEBUG
#define MAX_LRU_POOL_BLOCKS 256
PVOID   AfdLRUPoolBlocks[MAX_LRU_POOL_BLOCKS];
LONG    AfdLRUPoolIndex = -1;
#endif  // AFD_POOL_DEBUG


VOID
AfdFreePool (
    IN PVOID Pointer,
    IN ULONG Tag
    )
{

    ULONG   PoolType;
    ULONG   numberOfBytes;

    if (PAGE_ALIGN (Pointer)==Pointer) {
        numberOfBytes = PAGE_SIZE;
    }
    else {
        PAFD_POOL_HEADER header;
        Pointer = header = (PAFD_POOL_HEADER)Pointer - 1;
        ASSERT (header->Size>0);
        PoolType = InterlockedExchange (&header->InUse, -1);
        ASSERT( PoolType == NonPagedPool ||
                PoolType == NonPagedPoolMustSucceed ||
                PoolType == PagedPool ||
                PoolType == (NonPagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                PoolType == (PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE) ||
                PoolType == (PagedPool | POOL_COLD_ALLOCATION) ||
                PoolType == (PagedPool | POOL_RAISE_IF_ALLOCATION_FAILURE | POOL_COLD_ALLOCATION));
        numberOfBytes = (CLONG)header->Size;
    }

    ExInterlockedAddLargeStatistic(
        &AfdTotalBytesFreed,
        numberOfBytes
        );

    InterlockedIncrement(
        &AfdTotalFrees
        );

#if AFD_POOL_DEBUG
    {
        LONG idx = InterlockedIncrement (&AfdLRUPoolIndex)%MAX_LRU_POOL_BLOCKS;
        RtlFillMemoryUlong (
                    Pointer,
                    (numberOfBytes+3)&(~3),
                    Tag);
        if (PoolType!=PagedPool) {
            ULONG  size;
            Pointer = InterlockedExchangePointer (
                                &AfdLRUPoolBlocks[idx],
                                Pointer);
            if (Pointer==NULL)
                return;

            if (PAGE_ALIGN(Pointer)==Pointer)
                numberOfBytes = PAGE_SIZE;
            else {
                PAFD_HEADER header;
                header = (PAFD_POOL_HEADER)Pointer - 1;
                Tag = *((PULONG)Pointer);
                numberOfBytes = (CLONG)(header->Size+3)&(~3);
            }
            size = RtlCompareMemoryUlong (Pointer, numberOfBytes, Tag);
            if (size!=numberOfBytes) {
                DbgPrint ("Block %p is modified at %p after it was freed.\n",
                            Pointer, (PUCHAR)Pointer+size);
                DbgBreakPoint ();
            }

        }
    }
#endif AFD_POOL_DEBUG

    MyFreePoolWithTag(
        (PVOID)Pointer,
        Tag
        );

} // AfdFreePool

#ifdef AFDDBG_QUOTA

typedef struct _AFD_QUOTA_HASH {
    PSZ    Type;
    LONG   TotalAmount;
} AFD_QUOTA_HASH, *PAFD_QUOTA_HASH;

#define AFD_QUOTA_HASH_SIZE 31
AFD_QUOTA_HASH  AfdQuotaHash[AFD_QUOTA_HASH_SIZE];
PEPROCESS   AfdQuotaProcess;



typedef struct {
    union {
        ULONG Bytes;
        struct {
            UCHAR Reserved[3];
            UCHAR Sign;
        } ;
    } ;
    UCHAR Location[12];
    PVOID Block;
    PVOID Process;
    PVOID Reserved2[2];
} QUOTA_HISTORY, *PQUOTA_HISTORY;
#define QUOTA_HISTORY_LENGTH 512
QUOTA_HISTORY AfdQuotaHistory[QUOTA_HISTORY_LENGTH];
LONG AfdQuotaHistoryIndex = 0;

VOID
AfdRecordQuotaHistory(
    IN PEPROCESS Process,
    IN LONG Bytes,
    IN PSZ Type,
    IN PVOID Block
    )
{

    LONG index;
    PQUOTA_HISTORY history;

    index = InterlockedIncrement( &AfdQuotaHistoryIndex );
    index &= QUOTA_HISTORY_LENGTH - 1;
    history = &AfdQuotaHistory[index];

    history->Bytes = Bytes;
    history->Sign = Bytes < 0 ? '-' : '+';
    RtlCopyMemory( history->Location, Type, 12 );
    history->Block = Block;
    history->Process = Process;

    index = (ULONG_PTR)Type % AFD_QUOTA_HASH_SIZE;
    if (AfdQuotaHash[index].Type!=Type) {
        if (InterlockedCompareExchangePointer (
                        (PVOID *)&AfdQuotaHash[index].Type,
                        Type,
                        NULL)!=NULL) {
            AfdQuotaHash[index].Type = (PVOID)-1;
        }
    }
    InterlockedExchangeAdd (&AfdQuotaHash[index].TotalAmount, Bytes);
} // AfdRecordQuotaHistory
#endif
#endif


PMDL
AfdAdvanceMdlChain(
    IN PMDL Mdl,
    IN ULONG Offset
    )

/*++

Routine Description:

    Accepts a pointer to an existing MDL chain and offsets that chain
    by a specified number of bytes.  This may involve the creation
    of a partial MDL for the first entry in the new chain.

Arguments:

    Mdl - Pointer to the MDL chain to advance.

    Offset - The number of bytes to offset the chain.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    //
    // Sanity check.
    //

    ASSERT( Mdl != NULL );
    ASSERT( Offset > 0 );

    //
    // Scan past any fully completed MDLs.
    //

    while ( Offset > MmGetMdlByteCount( Mdl ) ) {
        PMDL    prev = Mdl;

        Offset -= MmGetMdlByteCount( Mdl );
        ASSERT( Mdl->Next != NULL );
        Mdl = Mdl->Next;
        prev->Next = NULL;
        MmUnlockPages (prev);
        IoFreeMdl (prev);

    }

    //
    // Tautology of the day: Offset will either be zero (meaning that
    // we've advanced to a clean boundary between MDLs) or non-zero
    // (meaning we need to now build a partial MDL).
    //

    if ( Offset > 0 ) {

        NTSTATUS status;

        //
        // Use new MM routine.
        // This saves us use of MustSucceed pool since the routine
        // below is guaranteed to succeed (as it should because
        // we already have the whole range locked and possibly mapped
        // and there should be no problem extracting part of it within
        // the same MDL).
        //

        status = MmAdvanceMdl (Mdl, Offset);
        ASSERT (status==STATUS_SUCCESS);
    }

    return Mdl;

} // AfdAdvanceMdlChain


NTSTATUS
AfdAllocateMdlChain(
    IN PIRP Irp,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    )

/*++

Routine Description:

    Allocates a MDL chain describing the WSABUF array and attaches
    the chain to the specified IRP.

Arguments:

    Irp - The IRP that will receive the MDL chain.

    BufferArray - Points to an array of WSABUF structures describing
        the user's buffers.

    BufferCount - Contains the number of WSABUF structures in the
        array.

    Operation - Specifies the type of operation being performed (either
        IoReadAccess or IoWriteAccess).

    TotalByteCount - Will receive the total number of BYTEs described
        by the WSABUF array.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    PMDL currentMdl;
    PMDL * chainTarget;
    KPROCESSOR_MODE previousMode;
    ULONG totalLength;
    PVOID bufferPointer;
    ULONG bufferLength;

    //
    //  Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( Irp->MdlAddress == NULL );
    ASSERT( ( Operation == IoReadAccess ) || ( Operation == IoWriteAccess ) );
    ASSERT( TotalByteCount != NULL );

    //
    //  Get the previous processor mode.
    //

    previousMode = Irp->RequestorMode;

    //
    //  Get into a known state.
    //

    status = STATUS_SUCCESS;
    currentMdl = NULL;
    chainTarget = &Irp->MdlAddress;
    totalLength = 0;

    //
    //  Walk the array of WSABUF structures, creating the MDLs and
    //  probing & locking the pages.
    //

    try {

        if( previousMode != KernelMode ) {

            if ((BufferArray==NULL) || 
                    (BufferCount==0) ||
                    (BufferCount>(MAXULONG/sizeof (WSABUF)))) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            //
            //  Probe the WSABUF array.
            //

            ProbeForRead(
                BufferArray,                            // Address
                BufferCount * sizeof(WSABUF),           // Length
                PROBE_ALIGNMENT(WSABUF)                 // Alignment
                );

        }
        else {
            ASSERT( BufferArray != NULL );
            ASSERT( BufferCount > 0 );
        }

        //
        //  Scan the array.
        //

        for ( ; BufferCount>0; BufferCount--, BufferArray++) {

            bufferPointer = BufferArray->buf;
            bufferLength = BufferArray->len;

            if( bufferLength > 0 ) {

                //
                //  Update the total byte counter.
                //

                totalLength += bufferLength;

                //
                //  Create a new MDL.
                //

                currentMdl = IoAllocateMdl(
                                bufferPointer,      // VirtualAddress
                                bufferLength,       // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );

                if( currentMdl != NULL ) {

                    //
                    //  Lock the pages.  This will raise an exception
                    //  if the operation fails.
                    //

                    MmProbeAndLockPages(
                        currentMdl,                 // MemoryDescriptorList
                        previousMode,               // AccessMode
                        Operation                   // Operation
                        );

                    //
                    //  Chain the MDL onto the IRP.  In theory, we could
                    //  do this by passing the IRP into IoAllocateMdl(),
                    //  but IoAllocateMdl() does a linear scan on the MDL
                    //  chain to find the last one in the chain.
                    //
                    //  We can do much better.
                    //

                    *chainTarget = currentMdl;
                    chainTarget = &currentMdl->Next;


                } else {

                    //
                    //  Cannot allocate new MDL, return appropriate error.
                    //

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

            }

        }
        //
        //  Ensure the MDL chain is NULL terminated.
        //

        ASSERT( *chainTarget == NULL );

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        //
        //  currentMdl will only be non-NULL at this point if an MDL
        //  has been created, but MmProbeAndLockPages() raised an
        //  exception.  If this is true, then free the MDL.
        //  Also account for the case when currentMdl has been linked
        //  onto the chain and exception occured when accesing next user
        //  buffer.
        //

        if( currentMdl != NULL && chainTarget!=&currentMdl->Next) {

            IoFreeMdl( currentMdl );

        }

    }

    //
    //  Return the total buffer count.
    //

    *TotalByteCount = totalLength;

    return status;

} // AfdAllocateMdlChain


#ifdef _WIN64
NTSTATUS
AfdAllocateMdlChain32(
    IN PIRP Irp,
    IN LPWSABUF32 BufferArray,
    IN ULONG BufferCount,
    IN LOCK_OPERATION Operation,
    OUT PULONG TotalByteCount
    )

/*++

Routine Description:

    Allocates a MDL chain describing the WSABUF array and attaches
    the chain to the specified IRP.

Arguments:

    Irp - The IRP that will receive the MDL chain.

    BufferArray - Points to an array of WSABUF structures describing
        the user's buffers.

    BufferCount - Contains the number of WSABUF structures in the
        array.

    Operation - Specifies the type of operation being performed (either
        IoReadAccess or IoWriteAccess).

    TotalByteCount - Will receive the total number of BYTEs described
        by the WSABUF array.

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS status;
    PMDL currentMdl;
    PMDL * chainTarget;
    KPROCESSOR_MODE previousMode;
    ULONG totalLength;
    PVOID bufferPointer;
    ULONG bufferLength;

    //
    //  Sanity check.
    //

    ASSERT( Irp != NULL );
    ASSERT( Irp->MdlAddress == NULL );
    ASSERT( ( Operation == IoReadAccess ) || ( Operation == IoWriteAccess ) );
    ASSERT( TotalByteCount != NULL );

    //
    //  Get the previous processor mode.
    //

    previousMode = Irp->RequestorMode;

    //
    //  Get into a known state.
    //

    status = STATUS_SUCCESS;
    currentMdl = NULL;
    chainTarget = &Irp->MdlAddress;
    totalLength = 0;

    //
    //  Walk the array of WSABUF structures, creating the MDLs and
    //  probing & locking the pages.
    //

    try {

        if( previousMode != KernelMode ) {

            if ((BufferArray==NULL) || 
                    (BufferCount==0) ||
                    (BufferCount>(MAXULONG/sizeof (WSABUF32)))) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            //
            //  Probe the WSABUF array.
            //

            ProbeForRead(
                BufferArray,                            // Address
                BufferCount * sizeof(WSABUF32),         // Length
                PROBE_ALIGNMENT32(WSABUF32)             // Alignment
                );

        }
        else {
            ASSERT( BufferArray != NULL );
            ASSERT( BufferCount > 0 );
        }

        //
        //  Scan the array.
        //

        for ( ; BufferCount>0; BufferCount--, BufferArray++) {

            bufferPointer = BufferArray->buf;
            bufferLength = BufferArray->len;

            if( bufferLength > 0 ) {

                //
                //  Update the total byte counter.
                //

                totalLength += bufferLength;

                //
                //  Create a new MDL.
                //

                currentMdl = IoAllocateMdl(
                                bufferPointer,      // VirtualAddress
                                bufferLength,       // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );

                if( currentMdl != NULL ) {

                    //
                    //  Lock the pages.  This will raise an exception
                    //  if the operation fails.
                    //

                    MmProbeAndLockPages(
                        currentMdl,                 // MemoryDescriptorList
                        previousMode,               // AccessMode
                        Operation                   // Operation
                        );

                    //
                    //  Chain the MDL onto the IRP.  In theory, we could
                    //  do this by passing the IRP into IoAllocateMdl(),
                    //  but IoAllocateMdl() does a linear scan on the MDL
                    //  chain to find the last one in the chain.
                    //
                    //  We can do much better.
                    //

                    *chainTarget = currentMdl;
                    chainTarget = &currentMdl->Next;


                } else {

                    //
                    //  Cannot allocate new MDL, return appropriate error.
                    //

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                }

            }

        }
        //
        //  Ensure the MDL chain is NULL terminated.
        //

        ASSERT( *chainTarget == NULL );

    } except( AFD_EXCEPTION_FILTER(&status) ) {


        //
        //  currentMdl will only be non-NULL at this point if an MDL
        //  has been created, but MmProbeAndLockPages() raised an
        //  exception.  If this is true, then free the MDL.
        //  Also account for the case when currentMdl has been linked
        //  onto the chain and exception occured when accesing next user
        //  buffer.
        //

        if( currentMdl != NULL && chainTarget!=&currentMdl->Next) {

            IoFreeMdl( currentMdl );

        }

    }

    //
    //  Return the total buffer count.
    //

    *TotalByteCount = totalLength;

    return status;

} // AfdAllocateMdlChain32
#endif //_WIN64


VOID
AfdDestroyMdlChain (
    IN PIRP Irp
    )

/*++

Routine Description:

    Unlocks & frees the MDLs in the MDL chain attached to the given IRP.

Arguments:

    Irp - The IRP that owns the MDL chain to destroy.

Return Value:

    None.

--*/

{

    PMDL mdl;
    PMDL nextMdl;

    mdl = Irp->MdlAddress;
    Irp->MdlAddress = NULL;

    while( mdl != NULL ) {

        nextMdl = mdl->Next;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
        mdl = nextMdl;

    }

} // AfdDestroyMdlChain


ULONG
AfdCalcBufferArrayByteLength(
    IN LPWSABUF         BufferArray,
    IN ULONG            BufferCount
    )

/*++

Routine Description:

    Calculates the total size (in bytes) of the buffers described by the
    specified WSABUF array.

Arguments:

    BufferArray - Points to an array of WSABUF structures.

    BufferCount - The number of entries in BufferArray.

Return Value:

    ULONG - The total size (in bytes) of the buffers described by the
        WSABUF array. Will raise an exception & return -1 if the total
        size is obviously too large.

--*/

{

    LARGE_INTEGER totalLength;

    PAGED_CODE( );

    //
    // Sanity check.
    //

    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( BufferCount <= (MAXULONG/sizeof (WSABUF)));


    //
    // Scan the array & sum the lengths.
    //

    totalLength.QuadPart = 0;

    while( BufferCount-- ) {

        totalLength.QuadPart += (LONGLONG)BufferArray->len;
        BufferArray++;

    }

    if( totalLength.HighPart != 0 ||
        ( totalLength.LowPart & 0x80000000 ) != 0 ) {
        ExRaiseAccessViolation();
    }

    return totalLength.LowPart;

} // AfdCalcBufferArrayByteLength


ULONG
AfdCopyBufferArrayToBuffer(
    IN PVOID Destination,
    IN ULONG DestinationLength,
    IN LPWSABUF BufferArray,
    IN ULONG BufferCount
    )

/*++

Routine Description:

    Copies data from a WSABUF array to a linear buffer.

Arguments:

    Destination - Points to the linear destination of the data.

    DestinationLength - The length of Destination.

    BufferArray - Points to an array of WSABUF structures describing the
        source for the copy.

    BufferCount - The number of entries in BufferArray.

Return Value:

    ULONG - The number of bytes copied.

--*/

{

    PVOID destinationStart;
    ULONG bytesToCopy;

    PAGED_CODE( );

    //
    // Sanity check.
    //

    ASSERT( Destination != NULL );
    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );

    //
    // Remember this so we can calc number of bytes copied.
    //

    destinationStart = Destination;

    //
    // Scan the array & copy to the linear buffer.
    //

    while( BufferCount-- && DestinationLength > 0 ) {
        WSABUF  Buffer = *BufferArray++;

        bytesToCopy = min( DestinationLength, Buffer.len );

        if( ExGetPreviousMode() != KernelMode ) {

            ProbeForRead(
                Buffer.buf,                             // Address
                bytesToCopy,                            // Length
                sizeof(UCHAR)                           // Alignment
                );

        }

        RtlCopyMemory(
            Destination,
            Buffer.buf,
            bytesToCopy
            );

        Destination = (PCHAR)Destination + bytesToCopy;
        DestinationLength -= bytesToCopy;

    }

    //
    // Return number of bytes copied.
    //

    return (ULONG)((PUCHAR)Destination - (PUCHAR)destinationStart);

} // AfdCopyBufferArrayToBuffer


ULONG
AfdCopyBufferToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG Offset,
    IN ULONG BufferCount,
    IN PVOID Source,
    IN ULONG SourceLength
    )

/*++

Routine Description:

    Copies data from a linear buffer to a WSABUF array.

Arguments:

    BufferArray - Points to an array of WSABUF structures describing the
        destination for the copy.

    Offset - An offset within the buffer array at which the data should
        be copied.

    BufferCount - The number of entries in BufferArray.

    Source - Points to the linear source of the data.

    SourceLength - The length of Source.

Return Value:

    ULONG - The number of bytes copied.

--*/

{

    PVOID sourceStart;
    ULONG bytesToCopy;
    WSABUF buffer;

    PAGED_CODE( );

    //
    // Sanity check.
    //

    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( Source != NULL );
    ASSERT( SourceLength > 0 );

    //
    // Remember this so we can return the number of bytes copied.
    //

    sourceStart = Source;

    //
    // Handle the offset if one was specified.
    //

    if( Offset > 0 ) {

        //
        // Skip whole entries if necessary.
        //

        while( BufferCount > 0 &&
                (buffer=*BufferArray++, Offset >= buffer.len) ) {

            Offset -= buffer.len;
            BufferCount--;

        }

        if( BufferCount > 0 ) {
            //
            // If we have buffers left, fix up the buffer pointer
            // and length to keep the loop below fast.
            //

            ASSERT( Offset < buffer.len );

            buffer.buf += Offset;
            buffer.len -= Offset;

            //
            // We have already copied buffer array element, so jump
            // to the body of the loop to avoid doing this again (this
            // is not a mere optimization, but protection from application
            // that plays tricks on us by changing content of the buffer
            // array while we are looking at it).
            //
            goto DoCopy;
        }

    }

    //
    // Scan the array & copy from the linear buffer.
    //

    while( BufferCount-->0 && SourceLength > 0 ) {
        buffer = *BufferArray++;

    DoCopy:

        bytesToCopy = min( SourceLength, buffer.len );

        if( ExGetPreviousMode() != KernelMode ) {

            ProbeForWrite(
                buffer.buf,                             // Address
                bytesToCopy,                            // Length
                sizeof(UCHAR)                           // Alignment
                );

        }

        RtlCopyMemory(
            buffer.buf,
            Source,
            bytesToCopy
            );

        Source = (PCHAR)Source + bytesToCopy;
        SourceLength -= bytesToCopy;

    }

    //
    // Return number of bytes copied.
    //

    return (ULONG)((PUCHAR)Source - (PUCHAR)sourceStart);

} // AfdCopyBufferToBufferArray


ULONG
AfdCopyMdlChainToBufferArray(
    IN LPWSABUF BufferArray,
    IN ULONG BufferOffset,
    IN ULONG BufferCount,
    IN PMDL  SourceMdl,
    IN ULONG SourceOffset,
    IN ULONG SourceLength
    )

/*++

Routine Description:

    Copies data from a MDL chain to a WSABUF array.

Arguments:

    BufferArray - Points to an array of WSABUF structures describing the
        destination for the copy.

    BufferOffset - An offset within the buffer array at which the data should
        be copied.

    BufferCount - The number of entries in BufferArray.

    Source - Points to the MDL chain with data

    SourceOffset - An offset within the MDL chain from which the data should
        be copied.

    SourceLength - The length of Source.

Return Value:

    ULONG - The number of bytes copied.

--*/

{

    ULONG bytesCopied;
    ULONG bytesToCopy, len;
    WSABUF buffer;

    PAGED_CODE( );

    //
    // Assume we can copy everything.
    //

    bytesCopied = SourceLength;

    //
    // Sanity check.
    //

    ASSERT( BufferArray != NULL );
    ASSERT( BufferCount > 0 );
    ASSERT( SourceMdl != NULL );
    ASSERT( SourceLength>0 );

    //
    // Skip offset into the MDL chain
    //
    while (SourceOffset>=MmGetMdlByteCount (SourceMdl)) {
        SourceOffset -= MmGetMdlByteCount (SourceMdl);
        SourceMdl = SourceMdl->Next;
    }

    //
    // Handle buffer array offset if specified
    //
    if (BufferOffset>0) {
        //
        // Skip whole entries.
        //

        while( BufferCount > 0 &&
                (buffer=*BufferArray++,BufferOffset >= buffer.len) ) {
            BufferOffset -= buffer.len;
            BufferCount--;
        }

        if( BufferCount>0 ) {
            //
            // If we have buffers left, fix up the buffer pointer
            // and length to keep the loop below fast.
            //

            ASSERT (BufferOffset < buffer.len);
            buffer.buf += BufferOffset;
            buffer.len -= BufferOffset;

            //
            // We have already copied buffer array element, so jump
            // to the body of the loop to avoid doing this again (this
            // is not a mere optimization, but protection from application
            // that plays tricks on us by changing content of the buffer
            // array while we are looking at it).
            //

            goto DoCopy;
        }
    }


    //
    // Scan the array & copy from the mdl chain.
    //

    while (SourceLength>0 && BufferCount-->0) {
        buffer = *BufferArray++;

    DoCopy:
        bytesToCopy = min( SourceLength, buffer.len );

        if( ExGetPreviousMode() != KernelMode ) {

            ProbeForWrite(
                buffer.buf,                             // Address
                bytesToCopy,                            // Length
                sizeof(UCHAR)                           // Alignment
                );

        }

        //
        // Update source length for data we are going to copy
        //
        SourceLength -= bytesToCopy;

        //
        // Copy full source MDLs
        //
        while (bytesToCopy>0 &&
                (bytesToCopy>=(len=MmGetMdlByteCount (SourceMdl)-SourceOffset))) {
            ASSERT (SourceMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (buffer.buf,
                            (PUCHAR)MmGetSystemAddressForMdl(SourceMdl)+SourceOffset,
                            len);
            bytesToCopy -= len;
            buffer.buf += len;
            SourceMdl = SourceMdl->Next;
            SourceOffset = 0;
        }

        //
        // Copy partial source MDL if space remains.
        //
        if (bytesToCopy>0) {
            ASSERT (bytesToCopy<MmGetMdlByteCount (SourceMdl)-SourceOffset);
            ASSERT (SourceMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (buffer.buf,
                            (PUCHAR)MmGetSystemAddressForMdl (SourceMdl)+SourceOffset,
                            bytesToCopy
                            );
            SourceOffset += bytesToCopy;
        }

    }

    //
    // Return number of bytes copied except for those we couldn't.
    //

    return bytesCopied-SourceLength;

} // AfdCopyMdlChainToBufferArray


NTSTATUS
AfdCopyMdlChainToBufferAvoidMapping(
    IN PMDL     SrcMdl,
    IN ULONG    SrcOffset,
    IN ULONG    SrcLength,
    IN PUCHAR   Dst,
    IN ULONG    DstSize
    )

/*++

Routine Description:

    Copies data from a MDL chain to a buffer and avoids mapping
    MDLs to system space if possible.

Arguments:

    Dst - Points to destination for the copy.

    DstSize - Size of the buffer

    Source - Points to the MDL chain with data

    SourceOffset - An offset within the MDL chain from which the data should
        be copied.

    SourceLength - The length of Source.

Return Value:

    NTSTATUS - success if everything was copied OK
    STATUS_INSUFFICIENT_RESOURCES - mapping failed

--*/

{

    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       bytesToCopy;
    PUCHAR      DstEnd = Dst+DstSize;

    PAGED_CODE( );


    //
    // Sanity check.
    //

    ASSERT( Dst != NULL );
    ASSERT( DstSize > 0 );
    ASSERT( SrcMdl != NULL );
    ASSERT( SrcLength>0 );

    //
    // Skip offset into the MDL chain
    //
    while (SrcOffset>=MmGetMdlByteCount (SrcMdl)) {
        SrcOffset -= MmGetMdlByteCount (SrcMdl);
        SrcMdl = SrcMdl->Next;
    }

    while (Dst<DstEnd) {
        //
        // Determine how much we can copy and m
        // ake sure not to exceed limits.
        //
        bytesToCopy = MmGetMdlByteCount(SrcMdl)-SrcOffset;
        ASSERT (bytesToCopy<=(ULONG)(DstEnd-Dst));
        if (bytesToCopy>SrcLength) {
            bytesToCopy = SrcLength;
        }

        if (SrcMdl->Process==IoGetCurrentProcess ()) {
            //
            // If we are in the context of the same process that
            // MDL was created for, copy using VAs.
            //
            try {
                RtlCopyMemory (
                    Dst,
                    (PUCHAR)MmGetMdlVirtualAddress (SrcMdl)+SrcOffset,
                    bytesToCopy
                    );
            }
            except (AFD_EXCEPTION_FILTER (&status)) {
                return status;
            }
        }
        else {
            //
            // Otherwise, map MDL into the system space.
            //
            PCHAR src = MmGetSystemAddressForMdlSafe (SrcMdl, LowPagePriority);
            if (!src)
                return STATUS_INSUFFICIENT_RESOURCES;

            RtlCopyMemory (
                    Dst,
                    src+SrcOffset,
                    bytesToCopy
                    );

        }

        //
        // Update source length for data we are going to copy
        //
        SrcLength -= bytesToCopy;
        if (SrcLength==0)
            return STATUS_SUCCESS;
        SrcMdl = SrcMdl->Next;
        SrcOffset = 0;

        Dst += bytesToCopy;
    }

    return STATUS_BUFFER_OVERFLOW;

} // AfdCopyMdlChainToBufferAvoidMapping

NTSTATUS
AfdMapMdlChain (
    PMDL    MdlChain
    )
/*++

Routine Description:

    Makes sure that eveyr MDL in the chains is mapped into
    the system address space.

Arguments:

    MdlChain - Destination MDL.


Return Value:
    STATUS_SUCCESS - MDL chain is fully mapped
    STATUS_INSUFFICIENT_RESOURCES - at least one MDL could not be mapped

--*/
{
    while (MdlChain!=NULL) {
        if (MmGetSystemAddressForMdlSafe(MdlChain, LowPagePriority)==NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        MdlChain = MdlChain->Next;
    }
    return STATUS_SUCCESS;
} // AfdMapMdlChain


NTSTATUS
AfdCopyMdlChainToMdlChain (
    PMDL    DstMdl,
    ULONG   DstOffset,
    PMDL    SrcMdl,
    ULONG   SrcOffset,
    ULONG   SrcLength,
    PULONG  BytesCopied
    )
/*++

Routine Description:

    Copies data from an MDL chain to an MDL chain.

Arguments:

    DstMdl - Destination MDL.

    DstOffset - Offset withih the destination MDL.

    SrcMdl - Source MDL.

    SrcOffset - Offset within the source.

    SrcLength - lenght of the data in the source chain

    BytesCopied - points to variable that received total number
                    of bytes actually copied

Return Value:
    STATUS_SUCCESS - all of the source data was copied
    STATUS_BUFFER_OVERFLOW - destination MDL was not long enough
                    to hold all of the source data.

--*/
{
    ULONG   bytesToCopy = 0, len;
    PUCHAR  dst;

    ASSERT( SrcMdl != NULL );
    ASSERT( DstMdl != NULL );

    //
    // Assume we can copy everything.
    //
    *BytesCopied = SrcLength;

    //
    // Skip full MDLs in source.
    //
    while ((SrcMdl!=NULL) && (SrcOffset>=MmGetMdlByteCount (SrcMdl))) {
        SrcOffset -= MmGetMdlByteCount (SrcMdl);
        SrcMdl = SrcMdl->Next;
    }

    //
    // Skip full MDLs in destination
    //
    while ((DstMdl!=NULL) && (DstOffset>=MmGetMdlByteCount (DstMdl))) {
        DstOffset -= MmGetMdlByteCount (DstMdl);
        DstMdl = DstMdl->Next;
    }

    //
    // Handle remaining destination offset separately to simplify the main loop.
    //
    if (DstOffset>0) {
        dst = MmGetSystemAddressForMdlSafe (DstMdl, LowPagePriority);
        if (dst==NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
        dst += DstOffset;
        bytesToCopy = MmGetMdlByteCount(DstMdl)-DstOffset;
        goto DoCopy;
    }

    //
    // For each MDL in destination copy source MDLs
    // while source data and free space in destination remain
    //
    while ((SrcLength>0) && (DstMdl!=NULL)) {
        dst = MmGetSystemAddressForMdlSafe (DstMdl, LowPagePriority);
        if (dst==NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
        bytesToCopy = MmGetMdlByteCount(DstMdl);
    DoCopy:

        bytesToCopy = min (SrcLength, bytesToCopy);

        //
        // Adjust source length
        //
        SrcLength -= bytesToCopy;

        //
        // Copy full source MDLs
        //
        while (bytesToCopy>0 &&
                (bytesToCopy>=(len=MmGetMdlByteCount (SrcMdl)-SrcOffset))) {
            ASSERT (SrcMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (dst,
                            (PUCHAR)MmGetSystemAddressForMdl(SrcMdl)+SrcOffset,
                            len);
            bytesToCopy -= len;
            dst += len;
            SrcMdl = SrcMdl->Next;
            SrcOffset = 0;
        }


        //
        // Copy partial source MDL if space remains
        //
        if (bytesToCopy>0) {
            ASSERT (bytesToCopy<MmGetMdlByteCount (SrcMdl)-SrcOffset);
            ASSERT (SrcMdl->MdlFlags & (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));
            RtlCopyMemory (dst,
                            (PUCHAR)MmGetSystemAddressForMdl (SrcMdl)+SrcOffset,
                            bytesToCopy
                            );
            SrcOffset += bytesToCopy;
        }


        //
        // Advance to next MDL in destination
        //
        DstMdl = DstMdl->Next;
        
    }

    //
    // If we copied everything, return success
    //
    if (SrcLength==0) {
        return STATUS_SUCCESS;
    }
    else {
        //
        // Otherwise, adjust for number of bytes not copied
        // and return destination overflow
        //
        *BytesCopied -= SrcLength;
        return STATUS_BUFFER_OVERFLOW;
    }

}



#if DBG

VOID
AfdAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    if( AfdUsePrivateAssert ) {

        DbgPrint(
            "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
            Message
                ? Message
                : "",
            FailedAssertion,
            FileName,
            LineNumber
            );

        DbgBreakPoint();

    } else {

        RtlAssert(
            FailedAssertion,
            FileName,
            LineNumber,
            Message
            );

    }

}   // AfdAssert
#endif  // DBG


NTSTATUS
FASTCALL
AfdSetQos(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine sets the QOS for the given endpoint. Note that, since
    we don't really (yet) support QOS, we just ignore the incoming
    data and issue a AFD_POLL_QOS or AFD_POLL_GROUP_QOS event as
    appropriate.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO qosInfo;
    NTSTATUS    status = STATUS_SUCCESS;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdSetQos32 (Irp, IrpSp);
        goto Complete;
    }
#endif
    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the input buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*qosInfo) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    //
    // If the incoming data doesn't match the default QOS,
    // indicate the appropriate event.
    //

    if( !RtlEqualMemory(
            &qosInfo->Qos,
            &AfdDefaultQos,
            sizeof(QOS)
            ) ) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );

    }

Complete:
    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

}   // AfdSetQos


NTSTATUS
FASTCALL
AfdGetQos(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine gets the QOS for the given endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO qosInfo;
    NTSTATUS    status = STATUS_SUCCESS;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdGetQos32 (Irp, IrpSp);
        goto Complete;
    }
#endif

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the output buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(*qosInfo) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    //
    // Just return the default data.
    //

    RtlCopyMemory(
        &qosInfo->Qos,
        &AfdDefaultQos,
        sizeof(QOS)
        );
    Irp->IoStatus.Information = sizeof(*qosInfo);

Complete:
    //
    // Complete the IRP.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );
    return status;

}   // AfdGetQos


#ifdef _WIN64
NTSTATUS
AfdSetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine sets the QOS for the given endpoint. Note that, since
    we don't really (yet) support QOS, we just ignore the incoming
    data and issue a AFD_POLL_QOS or AFD_POLL_GROUP_QOS event as
    appropriate.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO32 qosInfo;

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the input buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*qosInfo) ) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // If the incoming data doesn't match the default QOS,
    // indicate the appropriate event.
    //

    if( !RtlEqualMemory(
            &qosInfo->Qos,
            &AfdDefaultQos32,
            sizeof(QOS32)
            ) ) {

        AFD_LOCK_QUEUE_HANDLE lockHandle;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent(
            endpoint,
            qosInfo->GroupQos
                ? AFD_POLL_GROUP_QOS
                : AFD_POLL_QOS,
            STATUS_SUCCESS
            );

    }

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = 0;
    return STATUS_SUCCESS;

}   // AfdSetQos


NTSTATUS
AfdGetQos32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine gets the QOS for the given endpoint.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_QOS_INFO32 qosInfo;

    PAGED_CODE();

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    qosInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the output buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(*qosInfo) ) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Just return the default data.
    //

    RtlCopyMemory(
        &qosInfo->Qos,
        &AfdDefaultQos32,
        sizeof(QOS32)
        );

    //
    // Complete the IRP.
    //

    Irp->IoStatus.Information = sizeof(*qosInfo);
    return STATUS_SUCCESS;

}   // AfdGetQos32
#endif // _WIN64

NTSTATUS
AfdValidateStatus (
    NTSTATUS    Status
    )
{
    PAGED_CODE ();
    //
    // Validate the status code.
    // It must match the status code conversion algorithm in msafd.
    //
    switch (Status) {
    case STATUS_SUCCESS:
        // return NO_ERROR;

    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        // return WSAENOTSOCK;

    case STATUS_INSUFFICIENT_RESOURCES:
    case STATUS_PAGEFILE_QUOTA:
    case STATUS_COMMITMENT_LIMIT:
    case STATUS_WORKING_SET_QUOTA:
    case STATUS_NO_MEMORY:
    case STATUS_CONFLICTING_ADDRESSES:
    case STATUS_QUOTA_EXCEEDED:
    case STATUS_TOO_MANY_PAGING_FILES:
    case STATUS_REMOTE_RESOURCES:
    case STATUS_TOO_MANY_ADDRESSES:
        // return WSAENOBUFS;

    case STATUS_SHARING_VIOLATION:
    case STATUS_ADDRESS_ALREADY_EXISTS:
        // return WSAEADDRINUSE;

    case STATUS_LINK_TIMEOUT:
    case STATUS_IO_TIMEOUT:
    case STATUS_TIMEOUT:
        // return WSAETIMEDOUT;

    case STATUS_GRACEFUL_DISCONNECT:
        // return WSAEDISCON;

    case STATUS_REMOTE_DISCONNECT:
    case STATUS_CONNECTION_RESET:
    case STATUS_LINK_FAILED:
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_PORT_UNREACHABLE:
        // return WSAECONNRESET;

    case STATUS_LOCAL_DISCONNECT:
    case STATUS_TRANSACTION_ABORTED:
    case STATUS_CONNECTION_ABORTED:
        // return WSAECONNABORTED;

    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_PROTOCOL_UNREACHABLE:
        // return WSAENETUNREACH;

    case STATUS_HOST_UNREACHABLE:
        // return WSAEHOSTUNREACH;
    case STATUS_HOST_DOWN:
        // return WSAEHOSTDOWN;

    case STATUS_CANCELLED:
    case STATUS_REQUEST_ABORTED:
        // return WSAEINTR;

    case STATUS_BUFFER_OVERFLOW:
    case STATUS_INVALID_BUFFER_SIZE:
        // return WSAEMSGSIZE;

    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_ACCESS_VIOLATION:
        // return WSAEFAULT;

    // case STATUS_DEVICE_NOT_READY:
    // case STATUS_REQUEST_NOT_ACCEPTED:
        // return WSAEWOULDBLOCK;

    case STATUS_INVALID_NETWORK_RESPONSE:
    case STATUS_NETWORK_BUSY:
    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_PATH_NOT_FOUND:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_UNEXPECTED_NETWORK_ERROR:
        // return WSAENETDOWN;

    case STATUS_INVALID_CONNECTION:
        // return WSAENOTCONN;

    case STATUS_REMOTE_NOT_LISTENING:
    case STATUS_CONNECTION_REFUSED:
        // return WSAECONNREFUSED;

    case STATUS_PIPE_DISCONNECTED:
        // return WSAESHUTDOWN;

    case STATUS_INVALID_ADDRESS:
    case STATUS_INVALID_ADDRESS_COMPONENT:
        // return WSAEADDRNOTAVAIL;

    case STATUS_NOT_SUPPORTED:
    case STATUS_NOT_IMPLEMENTED:
        // return WSAEOPNOTSUPP;

    case STATUS_ACCESS_DENIED:
        // return WSAEACCES;
    case STATUS_CONNECTION_ACTIVE:
        // return WSAEISCONN;
        break;
    case STATUS_UNSUCCESSFUL:
    case STATUS_INVALID_PARAMETER:
    case STATUS_ADDRESS_CLOSED:
    case STATUS_CONNECTION_INVALID:
    case STATUS_ADDRESS_ALREADY_ASSOCIATED:
    case STATUS_ADDRESS_NOT_ASSOCIATED:
    case STATUS_INVALID_DEVICE_STATE:
    case STATUS_INVALID_DEVICE_REQUEST:
        // return WSAEINVAL;
        break;
    default:
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdValidateStatus: Unsupported status code %lx, converting to %lx(INVALID_PARAMETER)\n",
                    Status,
                    STATUS_INVALID_PARAMETER));
        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return Status;
}


NTSTATUS
FASTCALL
AfdNoOperation(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine does nothing but complete the IRP.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    NTSTATUS      status;

    PAGED_CODE();

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        status = AfdNoOperation32 (Irp, IrpSp);
        goto Complete;
    }
#endif
    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Assume success
    //

    status = STATUS_SUCCESS;

    if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength
            >= sizeof (IO_STATUS_BLOCK)) {
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (IO_STATUS_BLOCK),
                                PROBE_ALIGNMENT(IO_STATUS_BLOCK))
            }

            //
            // Copy the status block
            //
            Irp->IoStatus
                = *((PIO_STATUS_BLOCK)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            Irp->IoStatus.Status = AfdValidateStatus (Irp->IoStatus.Status);
        }
        except (AFD_EXCEPTION_FILTER(&status)) {
            //
            // Fail the call, no completion notification
            // should be delivered via async IO.
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
        }
    }
    else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
    }

#ifdef _WIN64
Complete:
#endif
        
    if (status==STATUS_SUCCESS && Irp->IoStatus.Status!=STATUS_SUCCESS) {
        //
        // Make sure we deliver error via async IO
        // operation instead of just failing this call itself.
        //
        IoMarkIrpPending (Irp);
        status = STATUS_PENDING;
    }
    else {
        ASSERT (status==Irp->IoStatus.Status);
    }

    IoCompleteRequest( Irp, AfdPriorityBoost );
    return status;

}   // AfdNoOperation


#ifdef _WIN64
NTSTATUS
AfdNoOperation32(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine does nothing but complete the IRP.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    NTSTATUS      status;

    PAGED_CODE();

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Assume success
    //
    status = STATUS_SUCCESS;
    if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength
            >= sizeof (IO_STATUS_BLOCK32)) {
        try {
            if (Irp->RequestorMode!=KernelMode) {
                ProbeForRead (IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                sizeof (IO_STATUS_BLOCK32),
                                PROBE_ALIGNMENT32(IO_STATUS_BLOCK32))
            }

            Irp->IoStatus.Status 
                = ((PIO_STATUS_BLOCK32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->Status;
            Irp->IoStatus.Information 
                = ((PIO_STATUS_BLOCK32)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->Information;
            //
            // Validate the status code.
            // It must match the status code conversion algorithm in msafd.
            //
            Irp->IoStatus.Status = AfdValidateStatus (Irp->IoStatus.Status);
        }
        except (AFD_EXCEPTION_FILTER(&status)) {
            //
            // Fail the call, no completion notification
            // should be delivered via async IO.
            //
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;
        }
    }
    else {
        Irp->IoStatus.Status  = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
    }

    return status;

}   // AfdNoOperation32
#endif //_WIN64

NTSTATUS
FASTCALL
AfdValidateGroup(
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine examines a group ID. If the ID is for a "constrained"
    group, then all endpoints are scanned to validate the given address
    is consistent with the constrained group.


Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{

    PAFD_ENDPOINT endpoint;
    PAFD_ENDPOINT compareEndpoint;
    PAFD_CONNECTION connection;
    PLIST_ENTRY listEntry;
    PAFD_VALIDATE_GROUP_INFO validateInfo;
    AFD_GROUP_TYPE groupType;
    PTRANSPORT_ADDRESS requestAddress;
    ULONG requestAddressLength;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN result;
    LONG groupId;
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Set up local pointers.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    validateInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Make sure that the input buffer is large enough.
    //

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(*validateInfo) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    if( validateInfo->RemoteAddress.TAAddressCount != 1 ) {

        status = STATUS_INVALID_PARAMETER;
        goto Complete;

    }

    if( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
            ( sizeof(*validateInfo) -
                  sizeof(TRANSPORT_ADDRESS) +
                  validateInfo->RemoteAddress.Address[0].AddressLength ) ) {

        status = STATUS_BUFFER_TOO_SMALL;
        goto Complete;

    }

    //
    // Start by referencing the group so it doesn't go away unexpectedly.
    // This will also validate the group ID, and give us the group type.
    //

    groupId = validateInfo->GroupID;

    if( !AfdReferenceGroup( groupId, &groupType ) ) {

        status = STATUS_INVALID_PARAMETER;
        goto Complete;

    }

    //
    // If it's not a constrained group ID, we can just complete the IRP
    // successfully right now.
    //

    if( groupType != GroupTypeConstrained ) {

        AfdDereferenceGroup( validateInfo->GroupID );

        Irp->IoStatus.Information = 0;
        status = STATUS_SUCCESS;
        goto Complete;

    }

    //
    // Calculate the size of the incoming TDI address.
    //

    requestAddress = &validateInfo->RemoteAddress;

    requestAddressLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength -
        sizeof(AFD_VALIDATE_GROUP_INFO) +
        sizeof(TRANSPORT_ADDRESS);

    //
    // OK, it's a constrained group. Scan the list of constrained endpoints,
    // find those that are either datagram endpoints or have associated
    // connections, and validate the remote addresses.
    //

    result = TRUE;

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    for( listEntry = AfdConstrainedEndpointListHead.Flink ;
         listEntry != &AfdConstrainedEndpointListHead ;
         listEntry = listEntry->Flink ) {

        compareEndpoint = CONTAINING_RECORD(
                              listEntry,
                              AFD_ENDPOINT,
                              ConstrainedEndpointListEntry
                              );

        ASSERT( IS_AFD_ENDPOINT_TYPE( compareEndpoint ) );
        ASSERT( compareEndpoint->GroupType == GroupTypeConstrained );

        //
        // Skip this endpoint if the group IDs don't match.
        //

        if( groupId != compareEndpoint->GroupID ) {

            continue;

        }

        //
        // If this is a datagram endpoint, check it's remote address.
        //

        if( IS_DGRAM_ENDPOINT( compareEndpoint ) ) {

            AfdAcquireSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            if( compareEndpoint->Common.Datagram.RemoteAddress != NULL ) {

                result = AfdCompareAddresses(
                             compareEndpoint->Common.Datagram.RemoteAddress,
                             compareEndpoint->Common.Datagram.RemoteAddressLength,
                             requestAddress,
                             requestAddressLength
                             );

            }

            AfdReleaseSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            if( !result ) {
                break;
            }

        } else {

            //
            // Not a datagram. If it's a connected endpoint, still has
            // a connection object, and that object has a remote address,
            // then compare the addresses.
            //

            AfdAcquireSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            connection = AFD_CONNECTION_FROM_ENDPOINT( compareEndpoint );

            if( compareEndpoint->State == AfdEndpointStateConnected &&
                connection != NULL ) {

                REFERENCE_CONNECTION( connection );

                if( connection->RemoteAddress != NULL ) {

                    result = AfdCompareAddresses(
                                 connection->RemoteAddress,
                                 connection->RemoteAddressLength,
                                 requestAddress,
                                 requestAddressLength
                                 );

                }

                AfdReleaseSpinLock( &compareEndpoint->SpinLock, &lockHandle );

                DEREFERENCE_CONNECTION( connection );

                if( !result ) {
                    break;
                }

            } else {

                AfdReleaseSpinLock( &compareEndpoint->SpinLock, &lockHandle );

            }

        }

    }

    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    AfdDereferenceGroup( validateInfo->GroupID );

    if( !result ) {
        status = STATUS_INVALID_PARAMETER;
    }

Complete:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

}   // AfdValidateGroup

BOOLEAN
AfdCompareAddresses(
    IN PTRANSPORT_ADDRESS Address1,
    IN ULONG Address1Length,
    IN PTRANSPORT_ADDRESS Address2,
    IN ULONG Address2Length
    )

/*++

Routine Description:

    This routine compares two addresses in a special way to support
    constrained socket groups. This routine will return TRUE if the
    two addresses represent the same "interface". By "interface", I
    mean something like an IP address or an IPX address. Note that for
    some address types (such as IP) certain portions of the address
    should be ignored (such as the port).

    I really hate hard-coded knowledge of "select" address types, but
    there's no easy way around it. Ideally, this should be the protocol
    driver's responsibility. We could really use a standard "compare
    these addresses" IOCTL in TDI.

Arguments:

    Address1 - The first address.

    Address1Length - The length of Address1.

    Address2 - The second address.

    Address2Length - The length of Address2.

Return Value:

    BOOLEAN - TRUE if the addresses reference the same interface, FALSE
        otherwise.

--*/

{

    USHORT addressType;

    if (Address1Length!=Address2Length)
        return FALSE;

    if (Address1Length<(ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,Address[0].Address)) {
        return FALSE;
    }
    addressType = Address1->Address[0].AddressType;

    if( addressType != Address2->Address[0].AddressType ) {

        //
        // If they're not the same address type, they can't be the
        // same address...
        //

        return FALSE;

    }

    //
    // Special case a few addresses.
    //

    switch( addressType ) {

    case TDI_ADDRESS_TYPE_IP : {

            TDI_ADDRESS_IP UNALIGNED * ip1;
            TDI_ADDRESS_IP UNALIGNED * ip2;

            ip1 = (PVOID)&Address1->Address[0].Address[0];
            ip2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // IP addresses. Compare the address portion (ignoring
            // the port).
            //

            if( (Address1Length>=(ULONG)FIELD_OFFSET (TA_IP_ADDRESS, Address[0].Address[0].sin_zero)) &&
                (ip1->in_addr == ip2->in_addr) ) {
                return TRUE;
            }

        }
        return FALSE;

    case TDI_ADDRESS_TYPE_IP6 : {

            TDI_ADDRESS_IP6 UNALIGNED * ip1;
            TDI_ADDRESS_IP6 UNALIGNED * ip2;

            ip1 = (PVOID)&Address1->Address[0].Address;
            ip2 = (PVOID)&Address2->Address[0].Address;

            //
            // IPv6 addresses. Compare the address portion (ignoring
            // the port and flow info).
            //

            if( (Address1Length>=sizeof (TA_IP6_ADDRESS)) &&
                RtlEqualMemory(ip1->sin6_addr,
                               ip2->sin6_addr,
                               sizeof (ip1->sin6_addr)) ) {
                return TRUE;
            }

        }
        return FALSE;
    case TDI_ADDRESS_TYPE_IPX : {

            TDI_ADDRESS_IPX UNALIGNED * ipx1;
            TDI_ADDRESS_IPX UNALIGNED * ipx2;

            ipx1 = (PVOID)&Address1->Address[0].Address[0];
            ipx2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // IPX addresses. Compare the network and node addresses.
            //

            if( (Address1Length>=sizeof (TA_IPX_ADDRESS)) &&
                ipx1->NetworkAddress == ipx2->NetworkAddress &&
                RtlEqualMemory(
                    ipx1->NodeAddress,
                    ipx2->NodeAddress,
                    sizeof(ipx1->NodeAddress)
                    ) ) {
                return TRUE;
            }

        }
        return FALSE;

    case TDI_ADDRESS_TYPE_APPLETALK : {

            TDI_ADDRESS_APPLETALK UNALIGNED * atalk1;
            TDI_ADDRESS_APPLETALK UNALIGNED * atalk2;

            atalk1 = (PVOID)&Address1->Address[0].Address[0];
            atalk2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // APPLETALK address. Compare the network and node
            // addresses.
            //

            if( (Address1Length>=sizeof (TA_APPLETALK_ADDRESS)) &&
                (atalk1->Network == atalk2->Network) &&
                (atalk1->Node == atalk2->Node) ) {
                return TRUE;
            }

        }
        return FALSE;

    case TDI_ADDRESS_TYPE_VNS : {

            TDI_ADDRESS_VNS UNALIGNED * vns1;
            TDI_ADDRESS_VNS UNALIGNED * vns2;

            vns1 = (PVOID)&Address1->Address[0].Address[0];
            vns2 = (PVOID)&Address2->Address[0].Address[0];

            //
            // VNS addresses. Compare the network and subnet addresses.
            //

            if( (Address1Length>=sizeof (TA_VNS_ADDRESS)) &&
                RtlEqualMemory(
                    vns1->net_address,
                    vns2->net_address,
                    sizeof(vns1->net_address)
                    ) &&
                RtlEqualMemory(
                    vns1->subnet_addr,
                    vns2->subnet_addr,
                    sizeof(vns1->subnet_addr)
                    ) ) {
                return TRUE;
            }

        }
        return FALSE;

    default :

        //
        // Unknown address type. Do a simple memory compare.
        //

        return (BOOLEAN)RtlEqualMemory(
                            Address1,
                            Address2,
                            Address2Length
                            );

    }

}   // AfdCompareAddresses

NTSTATUS
AfdGetUnacceptedConnectData (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{

    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PAFD_CONNECT_DATA_BUFFERS connectDataBuffers;
    AFD_UNACCEPTED_CONNECT_DATA_INFO connectInfo;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG dataLength;
    PMDL  mdl;
    NTSTATUS status;
    UCHAR   localBuffer[AFD_FAST_CONNECT_DATA_SIZE];

    //
    // Set up local pointers.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    status = STATUS_SUCCESS;
    mdl = NULL;
    *Information = 0;

    //
    // Validate the request.
    //

    if( !endpoint->Listening ||
            InputBufferLength < sizeof(connectInfo) ) {

        return STATUS_INVALID_PARAMETER;

    }

    try {
        //
        // Validate the input structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForRead (InputBuffer,
                            sizeof (connectInfo),
                            PROBE_ALIGNMENT(AFD_UNACCEPTED_CONNECT_DATA_INFO));
        }

        //
        // Make local copies of the embeded pointer and parameters
        // that we will be using more than once in case malicios
        // application attempts to change them while we are
        // validating
        //

        connectInfo = *((PAFD_UNACCEPTED_CONNECT_DATA_INFO)InputBuffer);

        if (connectInfo.LengthOnly &&
                OutputBufferLength<sizeof (connectInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto exit;
        }

        if (OutputBufferLength>0) {
            if (OutputBufferLength>sizeof (localBuffer)) {
                mdl = IoAllocateMdl(
                                OutputBuffer,       // VirtualAddress
                                OutputBufferLength, // Length
                                FALSE,              // SecondaryBuffer
                                TRUE,               // ChargeQuota
                                NULL                // Irp
                                );
                if (mdl==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }

                MmProbeAndLockPages(
                    mdl,                        // MemoryDescriptorList
                    RequestorMode,              // AccessMode
                    IoWriteAccess               // Operation
                    );
                OutputBuffer = MmGetSystemAddressForMdlSafe(mdl, LowPagePriority);
                if (OutputBuffer==NULL) {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto exit;
                }
            }
            else {
                if (RequestorMode!=KernelMode) {
                    ProbeForWrite (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (UCHAR));
                }
            }
        }

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        goto exit;
    }

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Find the specified connection.
    //

    connection = AfdFindReturnedConnection(
                     endpoint,
                     connectInfo.Sequence
                     );

    if( connection == NULL ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_INVALID_PARAMETER;
        goto exit;

    }

    //
    // Determine the length of any received connect data.
    //

    dataLength = 0;
    connectDataBuffers = connection->ConnectDataBuffers;

    if( connectDataBuffers != NULL &&
        connectDataBuffers->ReceiveConnectData.Buffer != NULL ) {

        dataLength = connectDataBuffers->ReceiveConnectData.BufferLength;

    }

    //
    // If the caller is just interested in the data length, return it.
    //

    if( connectInfo.LengthOnly ) {

        connectInfo.ConnectDataLength = dataLength;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        try {
            RtlCopyMemory (OutputBuffer,
                            &connectInfo,
                            sizeof (connectInfo));
            *Information = sizeof (connectInfo);
            status = STATUS_SUCCESS;
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
        }
        goto exit;
    }

    //
    // If there is no connect data, complete the IRP with no bytes.
    //

    if( dataLength == 0 ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_SUCCESS;
        goto exit;
    }

    //
    // If the output buffer is too small, fail.
    //

    if( OutputBufferLength < dataLength ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_BUFFER_TOO_SMALL;
        goto exit;
    }

    RtlCopyMemory(
        mdl ? OutputBuffer : localBuffer,
        connectDataBuffers->ReceiveConnectData.Buffer,
        dataLength
        );

    *Information = dataLength;

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    if (mdl==NULL) {
        try {
            RtlCopyMemory (OutputBuffer,
                            localBuffer,
                            *Information);
        }
        except (AFD_EXCEPTION_FILTER(&status)) {
            *Information = 0;
        }
    }

exit:

    if (mdl!=NULL) {
        if (mdl->MdlFlags & MDL_PAGES_LOCKED) {
            MmUnlockPages (mdl);
        }
        IoFreeMdl (mdl);
    }

    return status;

}   // AfdGetUnacceptedConnectData

#ifdef _WIN64
ULONG
AfdComputeCMSGLength32 (
    PVOID   ControlBuffer,
    ULONG   ControlLength
    )
{
    ULONG   length = 0;

    ASSERT (ControlLength>=sizeof (TDI_CMSGHDR));

    while (ControlLength>=sizeof (TDI_CMSGHDR)) {
        PTDI_CMSGHDR    hdr;

        hdr = ControlBuffer;
        
        //
        // Data comes from the trusted kernel mode driver source.
        //
        ASSERT (ControlLength >= TDI_CMSGHDR_ALIGN((hdr)->cmsg_len));
        ControlLength -= (ULONG)TDI_CMSGHDR_ALIGN((hdr)->cmsg_len);
        ControlBuffer = (PUCHAR)ControlBuffer +
                        TDI_CMSGHDR_ALIGN((hdr)->cmsg_len);

        length += (ULONG)TDI_CMSGHDR_ALIGN32(
                            (hdr)->cmsg_len -
                                TDI_CMSGDATA_ALIGN (sizeof (TDI_CMSGHDR)) +
                                TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)) );

    }

    ASSERT (ControlLength==0);

    return length;
}

VOID
AfdCopyCMSGBuffer32 (
    PVOID   Dst,
    PVOID   ControlBuffer,
    ULONG   CopyLength
    )
{
    while (CopyLength>=sizeof (TDI_CMSGHDR32)) {
        PTDI_CMSGHDR    hdr;
        PTDI_CMSGHDR32  hdr32;

        hdr = ControlBuffer;
        hdr32 = Dst;

        hdr32->cmsg_len = (ULONG)( (hdr)->cmsg_len -
                                TDI_CMSGDATA_ALIGN (sizeof (TDI_CMSGHDR)) +
                                TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)) );
        hdr32->cmsg_level = hdr->cmsg_level;
        hdr32->cmsg_type = hdr->cmsg_type;

        if (CopyLength<(ULONG)TDI_CMSGHDR_ALIGN32(hdr32->cmsg_len))
            break;

        CopyLength -= (ULONG)TDI_CMSGHDR_ALIGN32(hdr32->cmsg_len);

        RtlMoveMemory ((PUCHAR)hdr32+TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)),
                            (PUCHAR)hdr+TDI_CMSGDATA_ALIGN(sizeof(TDI_CMSGHDR)),
                            hdr32->cmsg_len-TDI_CMSGDATA_ALIGN32(sizeof(TDI_CMSGHDR32)));
        
        ControlBuffer = (PUCHAR)ControlBuffer +
                        TDI_CMSGHDR_ALIGN((hdr)->cmsg_len);

        Dst = (PUCHAR)Dst + TDI_CMSGHDR_ALIGN32((hdr32)->cmsg_len);
    }

}
#endif //_WIN64

//
// This is currently not used by helper dlls.
// Commented out because of security concerns
//
#if 0
//
// Context structure allocated for non-blocking IOCTLs
//

typedef struct _AFD_NBIOCTL_CONTEXT {
    AFD_REQUEST_CONTEXT Context;        // Context to keep track of request
    ULONG               PollEvent;      // Poll event to signal upon completion
    // IRP              Irp;            // Irp to queue transport
    // PCHAR            SystemBuffer;   // Input buffer if method!=3
} AFD_NBIOCTL_CONTEXT, *PAFD_NBIOCTL_CONTEXT;



NTSTATUS
FASTCALL
AfdDoTransportIoctl (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Passes the request from the helper DLL to the TDI transport
    driver.  In oreder to let the IO system properly complete asynchronous
    IOCTL issued by the helper DLL, it should come on the socket handle
    (afd endpoint object), and then afd redirects it to the transport
    driver on the handle that herlper DLL specifies (normally address,
    connection, or control channel handle)

Arguments:
    
    Irp

    IrpSp

Return Value:

    NTSTATUS

--*/

{
    PAFD_ENDPOINT               endpoint;
    AFD_TRANSPORT_IOCTL_INFO    ioctlInfo;
    PFILE_OBJECT                fileObject;
    PDEVICE_OBJECT              deviceObject;
    ULONG                       method;
    PIRP                        newIrp;
    PIO_STACK_LOCATION          nextSp;
    PAFD_REQUEST_CONTEXT        requestCtx;
    NTSTATUS                    status;

    PAGED_CODE ();

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    method = IrpSp->Parameters.DeviceIoControl.IoControlCode & 3;

    if (method==METHOD_NEITHER) {

        //
        // We have to manually verify input buffer
        //

        try {
#ifdef _WIN64
            if (IoIs32bitProcess (Irp)) {
                PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
                    status = STATUS_INVALID_PARAMETER;
                    goto Complete;
                }
                ioctlInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                if( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(
                        ioctlInfo32,
                        sizeof(*ioctlInfo32),
                        PROBE_ALIGNEMENT(AFD_TRANSPORT_IOCTL_INFO32)
                        );
                }
                ioctlInfo.Handle = ioctlInfo32->Handle;
                ioctlInfo.InputBuffer = ioctlInfo32->InputBuffer;
                ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
                ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
                ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
                ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
            }
            else
#endif // _WIN64
            {
                if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
                    status = STATUS_INVALID_PARAMETER;
                    goto Complete;
                }

                if( Irp->RequestorMode != KernelMode ) {
                    ProbeForRead(
                        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                        sizeof(ioctlInfo),
                        PROBE_ALIGNMENT(AFD_TRANSPORT_IOCTL_INFO)
                        );
                }
                ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)
                                    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer);
            }
        } except( AFD_EXCEPTION_FILTER(&status) ) {

            //
            //  Exception accessing input structure.
            //

            goto Complete;
        }
    }
    else {

#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;

            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
                status = STATUS_INVALID_PARAMETER;
                goto Complete;
            }

            ioctlInfo32 = Irp->AssociatedIrp.SystemBuffer;
            ioctlInfo.Handle = ioctlInfo32->Handle;
            ioctlInfo.InputBuffer = ioctlInfo32->InputBuffer;
            ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
            ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
            ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
            ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
        }
        else
#endif // _WIN64
        {
            if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
                status = STATUS_INVALID_PARAMETER;
                goto Complete;
            }

            //
            // Just copy the buffer verified by the IO system
            //

            ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)
                            Irp->AssociatedIrp.SystemBuffer);
        }

    }


    //
    // We rely as much as we can on the IO system to process
    // IOCTL parameters for us. For this we have to make
    // sure that method of AFD and helper DLL IOCTLs
    // are the same, otherwise, someone can play tricks with
    // buffer verification on us.
    //
    // If endpoint is non-blocking and request is not overlapped
    // helper DLL MUST specify an event to check before queueing
    // the request/signal upon its completion
    //

    if ((method!=(ioctlInfo.IoControlCode & 3))
            || (endpoint->NonBlocking 
                && !(ioctlInfo.AfdFlags & AFD_OVERLAPPED)
                && !ioctlInfo.PollEvent)
                ) {
        status = STATUS_INVALID_PARAMETER;
        goto Complete;
    }


    //
    // Make sure application has access to handle
    // and get object reference
    //

    status = ObReferenceObjectByHandle(
         ioctlInfo.Handle,
         (ioctlInfo.IoControlCode >> 14) & 3,   // DesiredAccess
         *IoFileObjectType,                     // Must be a file object
         Irp->RequestorMode,
         (PVOID *)&fileObject,
         NULL
         );

    if (NT_SUCCESS(status)) {
        
        //
        // Get the device object of the driver to which we send the IRP
        //

        deviceObject = IoGetRelatedDeviceObject (fileObject);

        //
        // If this is a non-blocking endpoint and IO is not overlapped
        // and the specified event is not signalled,
        // we'll have complete the helper DLL IRP with
        // STATUS_DEVICE_NOT_READY (translates to WSAEWOUDLBLOCK)
        // and queue another IRP to the transport so that
        // the specified event can be completed when IRP is completed
        //

        if (endpoint->NonBlocking 
                && !(ioctlInfo.AfdFlags & AFD_OVERLAPPED)
                && !(ioctlInfo.PollEvent & endpoint->EventsActive)) {

            PAFD_NBIOCTL_CONTEXT    nbIoctlCtx;
            USHORT                  irpSize;
            ULONG                   allocSize;

            irpSize = IoSizeOfIrp (deviceObject->StackSize);
            
            //
            // Compute the block size and check for overflow
            //
            allocSize = sizeof (*nbIoctlCtx) + irpSize + ioctlInfo.InputBufferLength;
            if (allocSize < ioctlInfo.InputBufferLength ||
                    allocSize < irpSize) {
                status = STATUS_INVALID_PARAMETER;
                ObDereferenceObject (fileObject);
                goto Complete;
            }

            //
            // Allocate an IRP and associated strucutures
            // 

            try {
                nbIoctlCtx = AFD_ALLOCATE_POOL_WITH_QUOTA (
                                NonPagedPool,
                                allocSize,
                                AFD_TRANSPORT_IRP_POOL_TAG
                                );
                            
                // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE flag
                ASSERT (nbIoctlCtx!=NULL);
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode ();
                ObDereferenceObject (fileObject);
                goto Complete;
            }

            //
            // Initialize context structures
            //

            requestCtx = &nbIoctlCtx->Context;
            requestCtx->CleanupRoutine = AfdCleanupNBTransportIoctl;
            nbIoctlCtx->PollEvent = ioctlInfo.PollEvent;

            //
            // Initialize IRP itself
            //

            newIrp = (PIRP)(nbIoctlCtx+1);
            IoInitializeIrp( newIrp, irpSize, deviceObject->StackSize);
            newIrp->RequestorMode = KernelMode;
            newIrp->Tail.Overlay.AuxiliaryBuffer = NULL;
            newIrp->Tail.Overlay.OriginalFileObject = IrpSp->FileObject;

            nextSp = IoGetNextIrpStackLocation (newIrp);

            if ((ioctlInfo.InputBuffer!=NULL)
                    &&  (ioctlInfo.InputBufferLength>0)) {

                //
                // If helper DLL specified input buffer
                // we'll have to make a copy of it in case
                // driver really pends the IRP while we complete the
                // helper DLL IRP an system frees the input buffer
                //

                PVOID   newBuffer;

                newBuffer = (PUCHAR)newIrp+IoSizeOfIrp(deviceObject->StackSize);
                try {
                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForRead(
                            ioctlInfo.InputBuffer,
                            ioctlInfo.InputBufferLength,
                            sizeof(UCHAR)
                            );
                    }
                    RtlCopyMemory (newBuffer,
                                    ioctlInfo.InputBuffer,
                                    ioctlInfo.InputBufferLength);
                } except( AFD_EXCEPTION_FILTER(&status) ) {

                    //
                    //  Exception accessing input structure.
                    //

                    AFD_FREE_POOL (nbIoctlCtx, AFD_TRANSPORT_IRP_POOL_TAG);
                    ObDereferenceObject (fileObject);
                    goto Complete;

                }

                //
                // Store new buffer parameters in appropriate places
                // in the IRP depending on the method
                //

                if (method==METHOD_NEITHER) {
                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = newBuffer;
                    newIrp->AssociatedIrp.SystemBuffer = NULL;
                }
                else {
                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
                    newIrp->AssociatedIrp.SystemBuffer = newBuffer;
                }
                nextSp->Parameters.DeviceIoControl.InputBufferLength =
                        ioctlInfo.InputBufferLength;
            }
            else {

                //
                // No input buffer, clear correspoinding entries
                //

                nextSp->Parameters.DeviceIoControl.InputBufferLength = 0;
                nextSp->Parameters.DeviceIoControl.Type3InputBuffer =  NULL;
                newIrp->AssociatedIrp.SystemBuffer = NULL;

            }

            //
            // NOTE: We do not allow output buffer parameters on 
            // non-blocking calls because the output buffer is deallocated 
            // when we complete helper DLL IRP
            //
            //      Done during IRP initialization (IoInitializeIrp)
            // newIrp->MdlAddress = NULL;
            // newIrp->UserBuffer = NULL;
            // nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0;

            IoSetCompletionRoutine( newIrp, AfdCompleteNBTransportIoctl,
                                        nbIoctlCtx,
                                        TRUE, TRUE, TRUE );
        }
        else {

            //
            // Blocking call, reuse the application's IRP
            //

            newIrp = Irp;
            nextSp = IoGetNextIrpStackLocation (Irp);
            nextSp->Parameters.DeviceIoControl.OutputBufferLength = 
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength;


            if ((ioctlInfo.InputBuffer!=NULL)
                    && (ioctlInfo.InputBufferLength>0)) {

                //
                // If application wants to pass input buffer to transport,
                // we'll have to copy it to the system buffer allocated with
                // Irp
                //

                if (method!=METHOD_NEITHER) {
                    ULONG   sysBufferLength;
                    if (method==METHOD_BUFFERED) {
                        sysBufferLength = max (
                                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength);
                    }
                    else {
                        sysBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
                    }


                    //
                    // Methods 0-2 use system buffer to pass input 
                    // parameters and we need to reuse original system buffer
                    // Make sure it has enough space for this purpose
                    //

                    try {
                        if (Irp->RequestorMode != KernelMode) {
                            ProbeForRead(
                                ioctlInfo.InputBuffer,
                                ioctlInfo.InputBufferLength,
                                sizeof(UCHAR)
                                );
                        }

                        if (ioctlInfo.InputBufferLength>sysBufferLength){
                            PVOID   newSystemBuffer;
                            newSystemBuffer = ExAllocatePoolWithQuotaTag (
                                                    NonPagedPoolCacheAligned,
                                                    ioctlInfo.InputBufferLength,
                                                    AFD_TRANSPORT_IRP_POOL_TAG
                                                    );
                            if (newSystemBuffer==NULL) {
                                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
                            }
                            ExFreePool (Irp->AssociatedIrp.SystemBuffer);
                            Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
                        }

                        //
                        // Copy application data to the system buffer
                        //

                        RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                                        ioctlInfo.InputBuffer,
                                        ioctlInfo.InputBufferLength);

                    }
                    except( AFD_EXCEPTION_FILTER(&status) ) {
                        ObDereferenceObject (fileObject);
                        goto Complete;

                    }
                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer =  NULL;
                }
                else {

                    //
                    // METHOD_NEITHER, just pass whatever application
                    // passed to use, the driver should handle it
                    // appropriately.
                    //
                    // This is of course a potentialy security breach
                    // if transport driver is buggy
                    //

                    nextSp->Parameters.DeviceIoControl.Type3InputBuffer
                                    = ioctlInfo.InputBuffer;
                }
                nextSp->Parameters.DeviceIoControl.InputBufferLength
                                            = ioctlInfo.InputBufferLength;

            }
            else {

                //
                // No input buffer, clear correspoiding parameters
                // Note that we can't clean system buffer as
                // it has to be deallocated on completion
                //

                nextSp->Parameters.DeviceIoControl.Type3InputBuffer =  NULL;
                nextSp->Parameters.DeviceIoControl.InputBufferLength = 0;
            }



            //
            // We reuse our stack location parameters area for context
            //

            requestCtx = (PAFD_REQUEST_CONTEXT)&IrpSp->Parameters.DeviceIoControl;
            requestCtx->CleanupRoutine = AfdCleanupTransportIoctl;

            IoSetCompletionRoutine( newIrp, AfdCompleteTransportIoctl,
                                            requestCtx, TRUE, TRUE, TRUE );
        }

        //
        // Set the rest of IRP fields.
        //

        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->FileObject = fileObject;
        nextSp->Parameters.DeviceIoControl.IoControlCode = ioctlInfo.IoControlCode;


        //
        // Insert context into the endpoint list so we can cancel
        // the IRP when endpoint is being closed and reference endpoint
        // so it does not go away until this IRP is completed
        //

        requestCtx->Context = newIrp;
        REFERENCE_ENDPOINT (endpoint);
        AfdEnqueueRequest(endpoint,requestCtx);

        //
        // Finally call the transport driver
        // 

        status = IoCallDriver (deviceObject, newIrp);

        //
        // We no longer need our private reference to the file object
        // IO system will take care of keeping this reference while our IRP
        // is there
        //

        ObDereferenceObject (fileObject);

        //
        // If we used helper DLL IRP, just return whatever transport
        // driver returned to us
        //

        if (newIrp==Irp)
            return status;

        //
        // If driver pended or immediately completed non-blocking call,
        // make sure helper DLL gets WSAEWOULDBLOCK. It will have to
        // call again whenever the driver completes the IRP and corresponding
        // event is set (if driver completed the IRP, event is set already).
        //

        if (NT_SUCCESS (status))
            status = STATUS_DEVICE_NOT_READY;
    }

    //
    // Complete the application request in case of processing failure or
    // non-blocking call
    //
Complete:

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;
}

NTSTATUS
AfdCompleteTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Called to complete transport driver IOCTL for blocking endpoints

Arguments:
    

Return Value:

    STATUS_SUCCESS - IO system should finish IRP processing
    STATUS_MORE_PROCESSING_REQUIRED - we are not yet done (we are actually
                                    in the middle of cancelling)

--*/
{
    PAFD_ENDPOINT       endpoint = Irp->Tail.Overlay.OriginalFileObject->FsContext;
    PAFD_REQUEST_CONTEXT requestCtx = Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS        status = STATUS_SUCCESS;

    //
    // We used Parameters structure in our stack location for context
    //
    ASSERT (&(IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl)
                    ==Context);

    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // We use list entry fields to synchronize with cleanup/cancel
    // routine assuming that as long as the entry is in the list
    // both Flink and Blink fields cannot be NULL. (using these
    // fields for synchronization allows us to cut down on
    // cancel spinlock usage)
    //

    if (AfdIsRequestInQueue(requestCtx)) {

        //
        // Context is still in the list, just remove it so
        // noone can see it anymore
        //

        RemoveEntryList (&requestCtx->EndpointListLink);
    }
    else if (AfdIsRequestCompleted(requestCtx)) {

        //
        // During endpoint cleanup, this context was removed from the
        // list and cancel routine is about to be called, don't let
        // IO system free this IRP until cancel routine is called
        // Also, indicate to the cancel routine that we are done
        // with this IRP and it can complete it.
        //

        AfdMarkRequestCompleted (requestCtx);
        status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Release reference added when we posted this IRP
    //
    DEREFERENCE_ENDPOINT (endpoint);

    return status;
}
    
NTSTATUS
AfdCompleteNBTransportIoctl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Called to complete transport driver IOCTL for non-blocking endpoints

Arguments:
    

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED - we handle releasing resources
                                    for this IRP ourselves

--*/
{
    PAFD_ENDPOINT        endpoint = Irp->Tail.Overlay.OriginalFileObject->FsContext;
    PAFD_NBIOCTL_CONTEXT nbIoctlCtx = Context;
    PAFD_REQUEST_CONTEXT requestCtx = &nbIoctlCtx->Context;
    AFD_LOCK_QUEUE_HANDLE   lockHandle;


    //
    // The irp should be a part of our notify structure
    //

    ASSERT (Irp==(PIRP)(nbIoctlCtx+1));
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));



    //
    // First indicate the event reported by the driver
    //

    ASSERT (nbIoctlCtx->PollEvent!=0);
    AfdIndicatePollEvent (endpoint, 1<<nbIoctlCtx->PollEvent, Irp->IoStatus.Status);

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
    AfdIndicateEventSelectEvent (endpoint, 1<<nbIoctlCtx->PollEvent, Irp->IoStatus.Status);

    //
    // We use list entry fields to synchronize with cleanup/cancel
    // routine assuming that as long as the entry is in the list
    // both Flink and Blink fields cannot be NULL. (using these
    // fields for synchronization allows us to cut down on
    // cancel spinlock usage)
    //

    if (AfdIsRequestInQueue(requestCtx)) {
        //
        // Context is still in the list, just remove it so
        // noone can see it anymore and free the structure
        //

        RemoveEntryList (&requestCtx->EndpointListLink);
        AFD_FREE_POOL (nbIoctlCtx, AFD_TRANSPORT_IRP_POOL_TAG);
    }
    else if (AfdIsRequestCompleted (requestCtx)) {

        //
        // During endpoint cleanup, this context was removed from the
        // list and cancel routine is about to be called, don't
        // free this IRP until cancel routine is called
        // Also, indicate to the cancel routine that we are done
        // with this IRP and it can free it.
        //

        AfdMarkRequestCompleted (requestCtx);
    }
    else {
        //
        // Cancel routine has completed processing this request, free it
        //
        AFD_FREE_POOL (nbIoctlCtx, AFD_TRANSPORT_IRP_POOL_TAG);
    }
    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Release reference added when we posted this IRP
    //

    DEREFERENCE_ENDPOINT (endpoint);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


BOOLEAN
AfdCleanupTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    )
/*++

Routine Description:

    Cancels outstanding transport IOCTL during endpoint cleanup
    Used for blocking requests.

Arguments:
    
    Endpoint    -   endpoint on which IOCTL was issued

    RequestCtx   -  context associated with the request

Return Value:

    TRUE    - request has been completed
    FALSE   - request is still in driver's queue

--*/
{
    PIRP    Irp = RequestCtx->Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // First attempt to cancel the IRP, if it is already completed
    // this is just a no-op.  In no case IRP and request structure
    // could have been freed until we mark it as completed as
    // the caller of this routine should have marked the request
    // as being cancelled
    //

    ASSERT (RequestCtx->EndpointListLink.Flink==NULL);

    IoCancelIrp (Irp);

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (AfdIsRequestCompleted (RequestCtx)) {
        //
        // Driver has initiated the completion of the request 
        // as we were cancelling it.
        // "Complete the completion"
        //
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        IoCompleteRequest (Irp, IO_NO_INCREMENT);

        return TRUE;
    }
    else {

        //
        // Driver has not completed the request before returning
        // from cancel routine, mark the request to indicate
        // that we are done with it and completion routine
        // can free it
        //

        AfdMarkRequestCompleted (RequestCtx);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        return FALSE;
    }

}

BOOLEAN
AfdCleanupNBTransportIoctl (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    ) 
/*++

Routine Description:

    Cancels outstanding transport IOCTL during endpoint cleanup
    Used for non-blocking requests

Arguments:
    
    Endpoint    -   endpoint on which IOCTL was issued

    RequestCtx   -  context associated with the request

Return Value:

    TRUE    - request has been completed
    FALSE   - request is still in driver's queue

--*/
{
    PIRP    Irp = RequestCtx->Context;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // The IRP should be a part of the context block, verify.
    //
    ASSERT (Irp==(PIRP)(CONTAINING_RECORD (RequestCtx, AFD_NBIOCTL_CONTEXT, Context)+1));

    //
    // First attempt to cancel the IRP, if it is already completed
    // this is just a no-op.  In no case IRP and request structure
    // could have been freed until we mark it as completed as
    // the caller of this routine should have marked the request
    // as being cancelled
    //

    ASSERT (RequestCtx->EndpointListLink.Flink==NULL);

    IoCancelIrp (Irp);
    

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    if (AfdIsRequestCompleted (RequestCtx)) {
        //
        // Driver has initiated the completion of the request 
        // as we were cancelling it.
        // Free the context structure.
        //
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        AFD_FREE_POOL (
            CONTAINING_RECORD (RequestCtx, AFD_NBIOCTL_CONTEXT, Context),
            AFD_TRANSPORT_IRP_POOL_TAG);

        return TRUE;
    }
    else {

        //
        // Driver has not completed the request before returning
        // from cancel routine, mark the request to indicate
        // that we are done with it and completion routine
        // can free it
        //

        AfdMarkRequestCompleted (RequestCtx);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        return FALSE;
    }

}
#endif // NOT_YET


NTSTATUS
AfdQueryProviderInfo (
    IN  PUNICODE_STRING TransportDeviceName,
    OUT PTDI_PROVIDER_INFO ProviderInfo
    )

/*++

Routine Description:

    Returns a provider information structure corresponding to the
    specified TDI transport provider.

Arguments:

    TransportDeviceName - the name of the TDI transport provider.
    ProviderInfo    - buffer to place provider info into

Return Value:

    STATUS_SUCCESS  - returned transport info is valid.
    STATUS_OBJECT_NAME_NOT_FOUND - transport's device is not available yet

--*/
{
    NTSTATUS status;
    HANDLE controlChannel;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION kernelQueryInfo;


    PAGED_CODE ();

    //
    // Set up the IRP stack location information to query the TDI
    // provider information.
    //

    kernelQueryInfo.QueryType = TDI_QUERY_PROVIDER_INFORMATION;
    kernelQueryInfo.RequestConnectionInformation = NULL;

    //
    // Open a control channel to the TDI provider.
    // We ask to create a kernel handle which is 
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        TransportDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );

    status = IoCreateFile(
                 &controlChannel,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,							 // eaInfo
                 0,								 // eaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 IO_FORCE_ACCESS_CHECK           // Options
					| IO_NO_PARAMETER_CHECKING
                 );
    if ( NT_SUCCESS(status) ) {

        PFILE_OBJECT    controlObject;

        status = ObReferenceObjectByHandle (
                 controlChannel,                            // Handle
                 MAXIMUM_ALLOWED,                           // DesiredAccess
                 *IoFileObjectType,                         // ObjectType
                 KernelMode,                                // AccessMode
                 (PVOID *)&controlObject,                   // Object,
                 NULL                                       // HandleInformation
                 );

        if (NT_SUCCESS (status)) {

            //
            // Get the TDI provider information for the transport.
            //

            status = AfdIssueDeviceControl(
                         controlObject,
                         &kernelQueryInfo,
                         sizeof(kernelQueryInfo),
                         ProviderInfo,
                         sizeof(*ProviderInfo),
                         TDI_QUERY_INFORMATION
                         );

            ObDereferenceObject (controlObject);
        }

        ZwClose( controlChannel );
    }

    if (!NT_SUCCESS (status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdQueryProviderInfo:"
                    "Transport %*ls failed provider info query with status %lx.\n",
                    TransportDeviceName->Length/2, TransportDeviceName->Buffer, status));
    }

    return status;
}



BOOLEAN
AfdCancelIrp (
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to cancel an individual I/O Request Packet.
    It is similiar to IoCancelIrp() except that it *must* be called with
    the cancel spin lock held.  This routine exists because of the
    synchronization requirements of the cancellation/completion of
    transmit IRPs.

Arguments:

    Irp - Supplies a pointer to the IRP to be cancelled.  The CancelIrql
        field of the IRP must have been correctly initialized with the
        IRQL from the cancel spin lock acquisition.


Return Value:

    The function value is TRUE if the IRP was in a cancellable state (it
    had a cancel routine), else FALSE is returned.

Notes:

    It is assumed that the caller has taken the necessary action to ensure
    that the packet cannot be fully completed before invoking this routine.

--*/

{
    PDRIVER_CANCEL cancelRoutine;

    //
    // Make sure that the cancel spin lock is held.
    //

    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Set the cancel flag in the IRP.
    //

    Irp->Cancel = TRUE;

    //
    // Obtain the address of the cancel routine, and if one was specified,
    // invoke it.
    //

    cancelRoutine = IoSetCancelRoutine( Irp, NULL );
    if (cancelRoutine) {
        if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1)) {
            KeBugCheckEx( CANCEL_STATE_IN_COMPLETED_IRP, (ULONG_PTR) Irp, 0, 0, 0 );
        }
        cancelRoutine( Irp->Tail.Overlay.CurrentStackLocation->DeviceObject,
                       Irp );
        //
        // The cancel spinlock should have been released by the cancel routine.
        //

        return(TRUE);

    } else {

        //
        // There was no cancel routine, so release the cancel spinlock and
        // return indicating the Irp was not currently cancelable.
        //

        IoReleaseCancelSpinLock( Irp->CancelIrql );

        return(FALSE);
    }

} // AfdCancelIrp


VOID
AfdTrimLookaside (
    PNPAGED_LOOKASIDE_LIST  Lookaside
    )
{
    PVOID   entry;
#if DBG
    LONG count = 0;
#endif

    while (ExQueryDepthSList (&(Lookaside->L.ListHead))>Lookaside->L.Depth*2) {
        entry = InterlockedPopEntrySList(
                                &Lookaside->L.ListHead);
        if (entry) {
#if DBG
            count++;
#endif
            (Lookaside->L.Free)(entry);
        }
        else {
            break;
        }
    }
#if DBG
    if (count>0) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AFD: Flushed %d items from lookaside list @ %p\n",
                     count, Lookaside));
    }
#endif
}


VOID
AfdCheckLookasideLists (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    LONG i;
    ASSERT (Dpc==&AfdLookasideLists->Dpc);
    ASSERT (DeferredContext==AfdLookasideLists);
    for (i=0; i<AFD_NUM_LOOKASIDE_LISTS; i++) {
        if (ExQueryDepthSList (&(AfdLookasideLists->List[i].L.ListHead)) >
                                AfdLookasideLists->List[i].L.Depth*2) {
            if (AfdLookasideLists->TrimFlags & (1<<i)) {
                AfdTrimLookaside (&AfdLookasideLists->List[i]);
                AfdLookasideLists->TrimFlags &= (~(1<<i));
            }
            else {
                AfdLookasideLists->TrimFlags |= (1<<i);
            }
        }
        else if (AfdLookasideLists->TrimFlags & (1<<i)) {
            AfdLookasideLists->TrimFlags &= (~(1<<i));
        }
    }
}



VOID
AfdLRListAddItem (
    PAFD_LR_LIST_ITEM  Item,
    PAFD_LR_LIST_ROUTINE Routine
    )
/*++

    Adds item to low resource list and starts low resource timer if not already
    started.
Arguments:

    Item   - item to add
    Routine  - routine to execute when timeout expires.

Return Value:
    None

Notes:

--*/

{
    LONG    count;
    Item->Routine = Routine;
    InterlockedPushEntrySList (
                &AfdLRList,
                &Item->SListLink);

    count = InterlockedIncrement (&AfdLRListCount);
    ASSERT (count>0);
    if (count==1) {
        AfdLRStartTimer ();
    }
}


VOID
AfdLRListTimeout (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

    DPC routine for low resource list timer
    Simply schedules worker thread - do not want to do low resource processing at DPC
--*/
{
    AfdQueueWorkItem (AfdProcessLRList, &AfdLRListWorker);
}

VOID
AfdProcessLRList (
    PVOID   Param
    )
/*++

Routine Description:

    Processeses  items on low resource list and reschedules processing
    if unprocessed items remain (still failing to buffer data due to 
    low resource condition)

Arguments:

    None
Return Value:

    None
Notes:

--*/
{
    PSINGLE_LIST_ENTRY  localList, entry;
    LONG    count = 0;

    PAGED_CODE ();

    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                "AFD: Processing low resource list: %ld entries\n",
                AfdLRListCount));

    //
    // Flush the list
    //
    localList = InterlockedFlushSList (&AfdLRList);


    //
    // Reverse it to preserve order of processing (FIFO).
    //
    entry = NULL;
    while (localList!=NULL) {
        PSINGLE_LIST_ENTRY  next;
        next = localList->Next;
        localList->Next = entry;
        entry = localList;
        localList = next;
    }

    localList = entry; 
    while (localList!=NULL) {
        PAFD_LR_LIST_ITEM   item;
        entry = localList;
        localList = localList->Next;
        item = CONTAINING_RECORD (entry, AFD_LR_LIST_ITEM, SListLink);

        //
        // Try to restart receive processing on connection where buffer allocation failed
        //
        if (item->Routine (item)) {
            //
            // Success, decrement number of items outstanding,
            // and note current number of items.  If we did not empty
            // the list, we'll have to restart the timer.
            //
            count = InterlockedDecrement (&AfdLRListCount);
            ASSERT (count>=0);
        }
        else {
            //
            // Failure, put it back on the list.  Note, that we have at list one
            // item there and thus have to restart the timer again.
            //
            InterlockedPushEntrySList (&AfdLRList, &item->SListLink);
            count = 1;
        }
    }

    if (count!=0) {
        //
        // We did not empty the list, so restart the timer.
        //
        AfdLRStartTimer ();
    }
}


VOID
AfdLRStartTimer (
    VOID
    )
/*++

Routine Description:

    Start low resource timer to retry receive operation on connections
    that could not buffer data due to low reaource condition.
Arguments:

    None
Return Value:

    None
Notes:

--*/

{
    LARGE_INTEGER   timeout;
    BOOLEAN         res;
    timeout.QuadPart = -50000000i64;     // 5 seconds

#if DBG
    {
        TIME_FIELDS timeFields;
        LARGE_INTEGER currentTime;
        LARGE_INTEGER localTime;

        KeQuerySystemTime (&currentTime);
        currentTime.QuadPart -= timeout.QuadPart;
        ExSystemTimeToLocalTime (&currentTime, &localTime);
        RtlTimeToTimeFields (&localTime, &timeFields);
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AFD: Scheduling low resource timer for %2.2d:%2.2d:%2.2d\n",
                    timeFields.Hour,
                    timeFields.Minute,
                    timeFields.Second));
    }
#endif

    KeInitializeDpc(
        &AfdLRListDpc,
        AfdLRListTimeout,
        &AfdLRList
        );

    KeInitializeTimer( &AfdLRListTimer );

    res = KeSetTimer(
                &AfdLRListTimer,
                timeout,
                &AfdLRListDpc
                );
    ASSERT (res==FALSE);

}


#ifdef _AFD_VERIFY_DATA_

VOID
AfdVerifyBuffer (
    PAFD_CONNECTION Connection,
    PVOID           Buffer,
    ULONG           Length
    )
{

    if (Connection->VerifySequenceNumber!=0) {
        PUCHAR  start, end;
        ULONGLONG   seq;

        for (start=Buffer,
                end = (PUCHAR)Buffer+Length,
                seq = Connection->VerifySequenceNumber-1;
                            start<end;
                            seq++, start++) {
            ULONG num = (ULONG)(seq/4);
            ULONG byte = (ULONG)(seq%4);

            if (*start!=(UCHAR)(num>>(byte*8))) {
                DbgPrint ("AfdVerifyBuffer: Data sequence number mismatch on connection %p:\n"
                          "     data buffer-%p, offset-%lx, expected-%2.2lx, got-%2.2lx.\n",
                          Connection,
                          Buffer,
                          start-(PUCHAR)Buffer,
                          (UCHAR)(num>>(byte*8)),
                          *start);

                DbgBreakPoint ();
                //
                // Disable verification to continue.
                //
                Connection->VerifySequenceNumber = 0;
                return;
            }
        }
        Connection->VerifySequenceNumber = seq+1;
    }
}

VOID
AfdVerifyMdl (
    PAFD_CONNECTION Connection,
    PMDL            Mdl,
    ULONG           Offset,
    ULONG           Length
    ) {
    if (Connection->VerifySequenceNumber!=0) {
        while (Mdl!=NULL) {
            if (Offset>=MmGetMdlByteCount (Mdl)) {
                Offset-=MmGetMdlByteCount (Mdl);
            }
            else if (Length<=MmGetMdlByteCount (Mdl)-Offset) {
                AfdVerifyBuffer (Connection,
                    (PUCHAR)MmGetSystemAddressForMdl (Mdl)+Offset,
                    Length);
                break;
            }
            else {
                AfdVerifyBuffer (Connection,
                    (PUCHAR)MmGetSystemAddressForMdl (Mdl)+Offset,
                    MmGetMdlByteCount (Mdl)-Offset
                    );
                Length-=(MmGetMdlByteCount (Mdl)-Offset);
                Offset = 0;
            }
            Mdl = Mdl->Next;
        }
    }
}

ULONG   AfdVerifyType = 0;
ULONG   AfdVerifyPort = 0;
PEPROCESS AfdVerifyProcess = NULL;

VOID
AfdVerifyAddress (
    PAFD_CONNECTION Connection,
    PTRANSPORT_ADDRESS Address
    )
{
    Connection->VerifySequenceNumber = 0;

    if ((AfdVerifyPort==0) ||
            ((AfdVerifyProcess!=NULL) &&
                (AfdVerifyProcess!=Connection->OwningProcess)) ||
            ((AfdVerifyType!=0) &&
                (AfdVerifyType!=(USHORT)Address->Address[0].AddressType))
                ) {
        return;
    }

    switch (Address->Address[0].AddressType) {
    case TDI_ADDRESS_TYPE_IP : {

            TDI_ADDRESS_IP UNALIGNED * ip;

            ip = (PVOID)&Address->Address[0].Address[0];
            if (ip->sin_port!=(USHORT)AfdVerifyPort) {
                return;
            }
        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

            TDI_ADDRESS_IPX UNALIGNED * ipx;

            ipx = (PVOID)&Address->Address[0].Address[0];
            if (ipx->Socket!=(USHORT)AfdVerifyPort) {
                return;
            }
        }
        break;

    case TDI_ADDRESS_TYPE_APPLETALK : {

            TDI_ADDRESS_APPLETALK UNALIGNED * atalk;

            atalk = (PVOID)&Address->Address[0].Address[0];
            if (atalk->Socket!=(UCHAR)AfdVerifyPort) {
                return;
            }
        }
        break;

    default:
        if (AfdVerifyType==0)
            return;
        DbgPrint ("AfdVerifyAddress: connection-%8.8lx, addres-%8.8lx\n",
                    Connection, Address);
        DbgBreakPoint ();

    }

    Connection->VerifySequenceNumber = 1;
}
#endif // _AFD_VERIFY_DATA_

LONG
AfdExceptionFilter(
#if DBG
    PCHAR SourceFile,
    LONG LineNumber,
#endif
    PEXCEPTION_POINTERS ExceptionPointers,
    PNTSTATUS           ExceptionCode
    )
{


    PAGED_CODE ();

    //
    // Return exception code and translate alignment warnings into 
    // alignment errors if requested.
    //

    if (ExceptionCode) {
        *ExceptionCode = ExceptionPointers->ExceptionRecord->ExceptionCode;
        if (*ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {
            *ExceptionCode = STATUS_DATATYPE_MISALIGNMENT_ERROR;
        }
    }

#if DBG
    //
    // Protect ourselves in case the process is totally messed up.
    //

    try {

        PCHAR fileName;
        //
        // Strip off the path from the source file.
        //

        fileName = strrchr( SourceFile, '\\' );

        if( fileName == NULL ) {
            fileName = SourceFile;
        } else {
            fileName++;
        }

        //
        // Whine about the exception.
        //

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
            "AfdExceptionFilter: exception %08lx @ %08lx, caught in %s:%d\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers->ExceptionRecord->ExceptionAddress,
            fileName,
            LineNumber
            ));

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        NOTHING;

    }
#endif //DBG

    return EXCEPTION_EXECUTE_HANDLER;

}   // AfdExceptionFilter

#if DBG
LONG
AfdApcExceptionFilter(
    PEXCEPTION_POINTERS ExceptionPointers,
    PCHAR SourceFile,
    LONG LineNumber
    )
{

    PCHAR fileName;

    PAGED_CODE ();

    //
    // Protect ourselves in case the process is totally messed up.
    //

    try {

        //
        // Strip off the path from the source file.
        //

        fileName = strrchr( SourceFile, '\\' );

        if( fileName == NULL ) {
            fileName = SourceFile;
        } else {
            fileName++;
        }

        //
        // Whine about the exception.
        //

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
            "AfdApcExceptionFilter: exception %08lx, exr:%p cxr:%p, caught in %s:%d\n",
            ExceptionPointers->ExceptionRecord->ExceptionCode,
            ExceptionPointers->ExceptionRecord,
            ExceptionPointers->ContextRecord,
            fileName,
            LineNumber
            ));
        DbgBreakPoint ();

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // Not much we can do here...
        //

        NOTHING;

    }

    return EXCEPTION_CONTINUE_SEARCH;

}   // AfdApcExceptionFilter
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\pnp.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the PnP and PM routines

Author:

    Vadim Eydelman (vadime)    Apr-1997

Revision History:

--*/

#include "afdp.h"

NTSTATUS
AfdPassQueryDeviceRelation (
    IN PFILE_OBJECT         FileObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    );

NTSTATUS
AfdRestartQueryDeviceRelation (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AfdPnpPower )
#pragma alloc_text( PAGE, AfdPassQueryDeviceRelation )
#pragma alloc_text( PAGEAFD, AfdRestartQueryDeviceRelation )
#endif

NTSTATUS
FASTCALL
AfdPnpPower (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This is the dispatch routine for PNP_POWER irp

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PAGED_CODE( );


    switch (IrpSp->MinorFunction) {

        //
        // We only support target device relation query
        //

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        if (IrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation) {

            NTSTATUS status;
            PAFD_ENDPOINT   endpoint;
            PAFD_CONNECTION connection;
            //
            // Set up local variables.
            //

            endpoint = IrpSp->FileObject->FsContext;
            ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
                //
                // Dispatch to correct TDI object of underlying transport
                // driver depedning on endpoint type
                //

            switch (endpoint->Type) {
            case AfdBlockTypeVcConnecting:
            case AfdBlockTypeVcBoth:
                connection = AfdGetConnectionReferenceFromEndpoint (endpoint);
                if  (connection!=NULL) {
                    status = AfdPassQueryDeviceRelation (connection->FileObject,
                                                Irp, IrpSp);
                    DEREFERENCE_CONNECTION (connection);
                    return status;
                }
                // fall through to try address handle if we have one.
            case AfdBlockTypeVcListening:
            case AfdBlockTypeDatagram:
                if (endpoint->State==AfdEndpointStateBound ||
                        endpoint->State==AfdEndpointStateConnected) {
                    return AfdPassQueryDeviceRelation (endpoint->AddressFileObject, 
                                                    Irp, IrpSp);
                }
                // fall through to fail
            case AfdBlockTypeHelper:
            case AfdBlockTypeEndpoint:
            case AfdBlockTypeSanHelper:
            case AfdBlockTypeSanEndpoint:
                break;
            default:
                ASSERT (!"Unknown endpoint type!");
                __assume (0);
                break;
            }
        }
    default:
        break;
    }
    
    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    //
    // We do not support the rest
    //

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
AfdPassQueryDeviceRelation (
    IN PFILE_OBJECT         FileObject,
    IN PIRP                 Irp,
    IN PIO_STACK_LOCATION   IrpSp
    )

/*++

Routine Description:

    This is the dispatch routine for PNP_POWER irp

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION  nextIrpSp;

    PAGED_CODE ();

    nextIrpSp = IoGetNextIrpStackLocation( Irp );

    *nextIrpSp = *IrpSp;

    //
    // Reference file object so it does not go away until this 
    // IRP completes
    //

    ObReferenceObject (FileObject);
    nextIrpSp->FileObject = FileObject;
    

    IoSetCompletionRoutine(
        Irp,
        AfdRestartQueryDeviceRelation,
        FileObject,
        TRUE,
        TRUE,
        TRUE
        );


    return IoCallDriver( IoGetRelatedDeviceObject( FileObject ), Irp );

}

NTSTATUS
AfdRestartQueryDeviceRelation (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    ) 
{
    PFILE_OBJECT    fileObject = Context;

    //
    // Dereference file object that we referenced when calling the
    // lower driver
    //

    ObDereferenceObject (fileObject);

    //
    // Tell IO system to continue with IRP completion
    //
    return STATUS_SUCCESS;
}


#include <tdiinfo.h>
#include <ntddip.h>
#include <ntddip6.h>
#include <ntddtcp.h>
#include <ipinfo.h>

typedef struct _AFD_PROTOCOL {
    USHORT       AddressType;
    USHORT       AddressLength;
    LPWSTR       NetworkLayerDeviceName;
    LPWSTR       TransportLayerDeviceName;
    ULONG        RtChangeIoctl;
    ULONG        RtChangeDataSize;
    LONG         RoutingQueryRefCount;
    HANDLE       DeviceHandle;
    PFILE_OBJECT FileObject;
} AFD_PROTOCOL, *PAFD_PROTOCOL;


NTSTATUS
AfdOpenDevice (
    LPWSTR      DeviceNameStr,
    HANDLE      *Handle,
    PFILE_OBJECT *FileObject
    );


NTSTATUS
AfdGetRoutingQueryReference (
    IN PAFD_PROTOCOL    Protocol
    );

NTSTATUS
AfdTcpQueueRoutingChangeRequest (
    IN PAFD_ENDPOINT        Endpoint,
    IN PIRP                 Irp,
    IN BOOLEAN              Overlapped
    );

NTSTATUS
AfdTcpRestartRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    );

NTSTATUS
AfdTcpSignalRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    );

NTSTATUS
AfdTcpRoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    );

NTSTATUS
AfdTcp6RoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    );

VOID
AfdDereferenceRoutingQueryEx (
    PAFD_PROTOCOL Protocol
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE,    AfdOpenDevice )
#pragma alloc_text( PAGE,    AfdRoutingInterfaceQuery )
#pragma alloc_text( PAGE,    AfdTcpRoutingQuery )
#pragma alloc_text( PAGE,    AfdTcp6RoutingQuery )
#pragma alloc_text( PAGE,    AfdGetRoutingQueryReference )
#pragma alloc_text( PAGE,    AfdDereferenceRoutingQuery )
#pragma alloc_text( PAGE,    AfdDereferenceRoutingQueryEx )
#pragma alloc_text( PAGEAFD, AfdTcpQueueRoutingChangeRequest )
#pragma alloc_text( PAGEAFD, AfdTcpRestartRoutingChange )
#pragma alloc_text( PAGEAFD, AfdTcpSignalRoutingChange )
#endif

AFD_PROTOCOL Ip = { TDI_ADDRESS_TYPE_IP,  TDI_ADDRESS_LENGTH_IP,  
                    DD_IP_DEVICE_NAME, DD_TCP_DEVICE_NAME, 
                    IOCTL_IP_RTCHANGE_NOTIFY_REQUEST, 
                    sizeof(IPNotifyData), 0, NULL, NULL };
AFD_PROTOCOL Ip6= { TDI_ADDRESS_TYPE_IP6, TDI_ADDRESS_LENGTH_IP6, 
                    DD_IPV6_DEVICE_NAME, DD_TCPV6_DEVICE_NAME, 
                    IOCTL_IPV6_RTCHANGE_NOTIFY_REQUEST, 
                    sizeof(IPV6_RTCHANGE_NOTIFY_REQUEST), 0, NULL, NULL };

const char ZeroString[16] = { 0 };

#define TaAddressesEqual(a1,a2) \
    (RtlEqualMemory (a1,a2,FIELD_OFFSET (TA_ADDRESS,Address[(a1)->AddressLength])))


NTSTATUS
AfdRoutingInterfaceQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Processes routing query request.  Protocol independent portion.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    CHAR                   addrBuffer[AFD_MAX_FAST_TRANSPORT_ADDRESS];
    PTRANSPORT_ADDRESS     tempAddr;
    NTSTATUS               status;

    PAGED_CODE ();

    //
    // Initialize locals for proper cleanup.
    //

    *Information = 0;
    tempAddr = (PTRANSPORT_ADDRESS)addrBuffer;

    //
    // Validate input parameters
    //

    if( InputBufferLength < sizeof(*tempAddr) ) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdRoutingInterfaceQuery: Endp: %p - invalid input buffer (%p-%d).\n",
                    FileObject->FsContext, InputBuffer, InputBufferLength));
        status = STATUS_INVALID_PARAMETER;
        goto Complete;
    }


    try {
        //
        // Copy input address into the local (or allocated from pool) buffer
        //
        if (InputBufferLength>sizeof (addrBuffer)) {
            tempAddr = AFD_ALLOCATE_POOL_WITH_QUOTA (PagedPool,
                                InputBufferLength,
                                AFD_ROUTING_QUERY_POOL_TAG);
            
            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
        }

        //
        // Validate user mode pointers
        //
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            InputBufferLength,
                            sizeof (CHAR));
        }
        RtlCopyMemory (tempAddr,
                        InputBuffer,
                        InputBufferLength);

        //
        // Validate the internal consistency of the transport address AFTER
        // copying it into the internal buffer to prevent malicious app from
        // changing it on the fly while we are checking.
        //
        if (tempAddr->TAAddressCount!=1 ||
                InputBufferLength <
                    (ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,
                        Address[0].Address[tempAddr->Address[0].AddressLength])) {
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        goto Complete;
    }

    //
    // PROBLEM.  We only support IP for now
    //

    switch (tempAddr->Address[0].AddressType) {
    case TDI_ADDRESS_TYPE_IP:
        status = AfdTcpRoutingQuery (&tempAddr->Address[0], &tempAddr->Address[0]);
        break;
    case TDI_ADDRESS_TYPE_IP6:
        status = AfdTcp6RoutingQuery (&tempAddr->Address[0], &tempAddr->Address[0]);
        break;
    default:
        status = STATUS_NOT_SUPPORTED;
        goto Complete;
    }


    //
    // Convert output to socket address if we succeeded.
    //
    if (NT_SUCCESS (status)) {
        //
        // Conversion to sockaddr requires extra bytes for address family
        // in addition to TDI_ADDRESS
        //
        if ((tempAddr->Address[0].AddressLength+sizeof(u_short)
                                             <= OutputBufferLength)) {
            try {
                //
                // Validate user mode pointers
                //
                if (RequestorMode!=KernelMode) {
                    ProbeForWrite (OutputBuffer,
                                    OutputBufferLength,
                                    sizeof (CHAR));
                }
                //
                // Copy the data from the type on which corresponds
                // to the socket address.
                //
                RtlCopyMemory (
                    OutputBuffer,
                    &tempAddr->Address[0].AddressType,
                    tempAddr->Address[0].AddressLength+sizeof(u_short));
            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode ();
                goto Complete;
            }
        }
        else {
            //
            // Output buffer is not big enough, return warning
            // and the required buffer size.
            //
            status = STATUS_BUFFER_OVERFLOW;
        }
        *Information = tempAddr->Address[0].AddressLength+sizeof(u_short);
    }


Complete:

    //
    // Free address buffer if we allocated one.
    //
    if (tempAddr!=(PTRANSPORT_ADDRESS)addrBuffer) {
        AFD_FREE_POOL (tempAddr, AFD_ROUTING_QUERY_POOL_TAG);
    }

    return status;
} //AfdRoutingInterfaceQuery

NTSTATUS
FASTCALL
AfdRoutingInterfaceChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Processes routing change IRP

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    PTRANSPORT_ADDRESS     destAddr;
    NTSTATUS        status;
    PAFD_ENDPOINT   endpoint;
    BOOLEAN         overlapped;
    AFD_TRANSPORT_IOCTL_INFO    ioctlInfo;

    PAGED_CODE ();

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRoutingInterfaceChange: Endp: %p, buf: %p, inlen: %ld, outlen: %ld.\n",
                    IrpSp->FileObject->FsContext,
                    Irp->AssociatedIrp.SystemBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength));
    }
    

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;
        ioctlInfo32 = Irp->AssociatedIrp.SystemBuffer;
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        ioctlInfo.Handle = ioctlInfo32->Handle;
        ioctlInfo.InputBuffer = ioctlInfo32->InputBuffer;
        ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
        ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
        ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
        ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
    }
    else
#endif // _WIN64
    {
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)Irp->AssociatedIrp.SystemBuffer);
    }
    
    //
    // Setup locals
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );
    
    //
    // Check if request is overlapped
    //

    overlapped = ((ioctlInfo.AfdFlags & AFD_OVERLAPPED)!=0);

    //
    // Validate input parameters
    //
    try {
        ULONG   sysBufferLength;
        sysBufferLength = max (
                            IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                            IrpSp->Parameters.DeviceIoControl.OutputBufferLength);

        if (Irp->RequestorMode != KernelMode) {
            ProbeForRead(
                ioctlInfo.InputBuffer,
                ioctlInfo.InputBufferLength,
                sizeof(UCHAR)
                );
        }

        if (ioctlInfo.InputBufferLength>sysBufferLength){
            PVOID   newSystemBuffer;
            //
            // Don't use AFD tags on this as we are substituting
            // system buffer
            //
            newSystemBuffer = ExAllocatePoolWithQuota (
                                    NonPagedPoolCacheAligned,
                                    ioctlInfo.InputBufferLength
                                    );
            if (newSystemBuffer==NULL) {
                ExRaiseStatus (STATUS_INSUFFICIENT_RESOURCES);
            }
            ExFreePool (Irp->AssociatedIrp.SystemBuffer);
            Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
        }

        //
        // Copy application data to the system buffer
        //

        RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                        ioctlInfo.InputBuffer,
                        ioctlInfo.InputBufferLength);

    }
    except( AFD_EXCEPTION_FILTER(&status) ) {
        goto complete;
    }

    destAddr = Irp->AssociatedIrp.SystemBuffer;

    if(ioctlInfo.InputBufferLength <
                sizeof(*destAddr) ||
            ioctlInfo.InputBufferLength <
                (ULONG)FIELD_OFFSET (TRANSPORT_ADDRESS,
                            Address[0].Address[destAddr->Address[0].AddressLength])
            ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdRoutingInterfaceChange: Endp: %p - invalid parameter.\n",
                    IrpSp->FileObject->FsContext));
        status = STATUS_INVALID_PARAMETER;
        goto complete;

    }

    //
    // PROBLEM We only support IP for now
    //

    if (destAddr->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP &&
        destAddr->Address[0].AddressType!=TDI_ADDRESS_TYPE_IP6) {
        status = STATUS_NOT_SUPPORTED;
        goto complete;
    }


    //
    // Reset the poll bit
    //

    endpoint->EventsActive &= ~AFD_POLL_ROUTING_IF_CHANGE;

    return AfdTcpQueueRoutingChangeRequest (endpoint, Irp, overlapped);

complete:
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;

} // AfdRoutingInterfaceChange


NTSTATUS
AfdOpenDevice (
    LPWSTR      DeviceNameStr,
    HANDLE      *Handle,
    PFILE_OBJECT *FileObject
    )
/*++

Routine Description:

    Opens specified device driver (control channel) and returns handle and
    file object

Arguments:

    DeviceNameStr - device to open.

    Handle - returned handle.

    FileObject - returned file object.
Return Value:

    NTSTATUS -- Indicates whether the device was opened OK

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      DeviceName;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     iosb;

    PAGED_CODE( );


    RtlInitUnicodeString(&DeviceName, DeviceNameStr);

    //
    // We ask to create a kernel handle which is 
    // the handle in the context of the system process
    // so that application cannot close it on us while
    // we are creating and referencing it.
    //

    InitializeObjectAttributes(
        &objectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
        NULL,
        NULL
        );


    status = IoCreateFile(
                 Handle,
                 MAXIMUM_ALLOWED,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 NULL,                           // eaInfo
                 0,                              // eaLength
                 CreateFileTypeNone,             // CreateFileType
                 NULL,                           // ExtraCreateParameters
                 IO_NO_PARAMETER_CHECKING        // Options
                    | IO_FORCE_ACCESS_CHECK
                 );

    if (NT_SUCCESS (status)) {
        status = ObReferenceObjectByHandle (
                     *Handle,
                     0L,
                     *IoFileObjectType,
                     KernelMode,
                     (PVOID *)FileObject,
                     NULL
                     );
        if (!NT_SUCCESS (status)) {
            ZwClose (*Handle);
            *Handle = NULL;
        }
    }


    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdOpenDevice: Opened %ls, handle: %p, file: %p, status: %lx.\n",
                    DeviceNameStr, *Handle, *FileObject, status));
    }
    return status;
} //AfdOpenDevice


VOID
AfdDereferenceRoutingQueryEx (
    PAFD_PROTOCOL Protocol
    )
{

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    ASSERT (Protocol->RoutingQueryRefCount>0);
    ASSERT (Protocol->DeviceHandle!=NULL);
    if (InterlockedDecrement (&Protocol->RoutingQueryRefCount)==0) {
        HANDLE              DeviceHandle = Protocol->DeviceHandle;
        PFILE_OBJECT        FileObject = Protocol->FileObject;

        Protocol->DeviceHandle = NULL;
        Protocol->FileObject = NULL;

        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();

        ObDereferenceObject (FileObject);

        //
        // Do this in the context of system process so that it does not
        // get closed when applications exit
        //
        ZwClose (DeviceHandle);
    }
    else {
        ExReleaseResourceLite( AfdResource );
        KeLeaveCriticalRegion ();
    }
}

PAFD_PROTOCOL
AfdGetProtocolInfo(
    IN  USHORT AddressType
    )
{
    switch (AddressType) {
    case TDI_ADDRESS_TYPE_IP:  return &Ip;
    case TDI_ADDRESS_TYPE_IP6: return &Ip6;
    default:                   return NULL;
    }
}

VOID
AfdDereferenceRoutingQuery (
    USHORT AddressType
    )
{
    PAFD_PROTOCOL Protocol;

    Protocol = AfdGetProtocolInfo(AddressType);
    ASSERT (Protocol!=NULL);
    AfdDereferenceRoutingQueryEx(Protocol);
}

NTSTATUS
AfdTcp6RoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    )
/*++

Routine Description:

    Submits routing query request to TCP6

Arguments:

    Dest      - destination to query

    Intf      - interface through which destination can be reached.

Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{
    NTSTATUS            status;
    TDIObjectID         *lpObject;
    CHAR                byBuffer[FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX,
                                  Context) + sizeof(TDI_ADDRESS_IP6)];
    TCP_REQUEST_QUERY_INFORMATION_EX *ptrqiBuffer = (TCP_REQUEST_QUERY_INFORMATION_EX *) byBuffer;
    IP6RouteEntry       routeEntry;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    HANDLE              tcpDeviceHandle;
    PFILE_OBJECT        tcpFileObject;
    PDEVICE_OBJECT      tcpDeviceObject;

    PAGED_CODE ();

    //
    // Initialize for cleanup.
    //
    tcpDeviceHandle = NULL;

    if (Dest->AddressLength<TDI_ADDRESS_LENGTH_IP6) {
        KdPrintEx ((DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcp6RoutingQuery: Destination address buffer too small.\n"));
        status = STATUS_BUFFER_TOO_SMALL;
        goto complete;
    }

    //
    // Open TCP6 driver.
    //

    status = AfdOpenDevice (DD_TCPV6_DEVICE_NAME, &tcpDeviceHandle, &tcpFileObject);
    if (!NT_SUCCESS (status)) {
        goto complete;
    }
    tcpDeviceObject = IoGetRelatedDeviceObject ( tcpFileObject );


    //
    // Setup the query
    //

    RtlCopyMemory( (PVOID)ptrqiBuffer->Context, Dest->Address, 
                   TDI_ADDRESS_LENGTH_IP6);

    lpObject = &ptrqiBuffer->ID;
    lpObject->toi_id =  IP6_GET_BEST_ROUTE_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;


    KeInitializeEvent (&event, NotificationEvent, FALSE);

    //
    // Build and setup the IRP and call the driver
    //

    irp = IoBuildDeviceIoControlRequest (
                       IOCTL_TCP_QUERY_INFORMATION_EX, //Control
                       tcpDeviceObject,         // Device
                       ptrqiBuffer,             // Input buffer
                       sizeof(byBuffer),        // Input buffer size
                       &routeEntry,             // Output buffer
                       sizeof(routeEntry),      // Output buffer size
                       FALSE,                   // Internal ?
                       &event,                  // Event
                       &iosb                    // Status block
                       );
    if (irp==NULL) {
        IF_DEBUG(ROUTING_QUERY) {
            KdPrintEx ((DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcp6RoutingQuery: Could not allocate IRP.\n"));
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = tcpFileObject;

    status = IoCallDriver (tcpDeviceObject, irp);

    if (status==STATUS_PENDING) {
        status = KeWaitForSingleObject(
                   &event,
                   Executive,
                   KernelMode,
                   FALSE,       // Alertable
                   NULL);       // Timeout
    }

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx ((DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcp6RoutingQuery: IP6_GET_BEST_ROUTE_ID - status: %lx.\n",
                    status));
    }

    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (!NT_SUCCESS (iosb.Status)) {
        status = iosb.Status;
        goto complete;
    }

    // Fill in IPv6 address
    Intf->AddressType = TDI_ADDRESS_TYPE_IP6;
    Intf->AddressLength = TDI_ADDRESS_LENGTH_IP6;
    RtlCopyMemory( ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_addr,
                   &routeEntry.ire_Source,
                   sizeof(routeEntry.ire_Source) );
    ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_flowinfo = 0;
    ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_port = 0;
    ((PTDI_ADDRESS_IP6)Intf->Address)->sin6_scope_id = routeEntry.ire_ScopeId;
    status = STATUS_SUCCESS;

complete:
    if (tcpDeviceHandle!=NULL) {
        ObDereferenceObject (tcpFileObject);
        ZwClose (tcpDeviceHandle);
        tcpDeviceHandle = NULL;
    }

    return status;
}

#define AFD_IP_ADDRESS_QUERY_SIZE   PAGE_SIZE
NTSTATUS
AfdTcpRoutingQuery (
    PTA_ADDRESS Dest,
    PTA_ADDRESS Intf
    )
/*++

Routine Description:

    Submits routing query request to TCP

Arguments:

    Dest      - destination to query
    
    Intf      - interface through which destination can be reached.

Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{
    NTSTATUS            status;
    TDIObjectID         *lpObject;
    IPRouteLookupData   *pRtLookupData;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;
    IPRouteEntry        routeEntry;
    IPAddrEntry         *pAddrEntry;
    USHORT              *pNTEContext;
    PVOID               addrEntryBuf;
    IO_STATUS_BLOCK     iosb;
    KEVENT              event;
    PIRP                irp;
    PIO_STACK_LOCATION  irpSp;
    HANDLE              tcpDeviceHandle;
    PFILE_OBJECT        tcpFileObject;
    PDEVICE_OBJECT      tcpDeviceObject;

    PAGED_CODE ();

    //
    // Initialize for cleanup.
    //
    tcpDeviceHandle = NULL;

    if (Dest->AddressLength<TDI_ADDRESS_LENGTH_IP) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcpRoutingQuery: Destination address buffer too small.\n"));
        status = STATUS_BUFFER_TOO_SMALL;
        goto complete;
    }

    //
    // Open TCP driver.
    //

    status = AfdOpenDevice (DD_TCP_DEVICE_NAME, &tcpDeviceHandle, &tcpFileObject);
    if (!NT_SUCCESS (status)) {
        goto complete;
    }
    tcpDeviceObject = IoGetRelatedDeviceObject ( tcpFileObject );


    //
    // Setup the query
    //

    RtlZeroMemory (&trqiBuffer, sizeof (trqiBuffer));

    pRtLookupData = (IPRouteLookupData *)trqiBuffer.Context;
    pRtLookupData->DestAdd = ((PTDI_ADDRESS_IP)Dest->Address)->in_addr;
    pRtLookupData->SrcAdd  = 0;

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = IP_MIB_SINGLE_RT_ENTRY_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;


    KeInitializeEvent (&event, NotificationEvent, FALSE);

    //
    // Build and setup the IRP and call the driver
    //

    irp = IoBuildDeviceIoControlRequest (
                       IOCTL_TCP_QUERY_INFORMATION_EX, //Control
                       tcpDeviceObject,         // Device
                       &trqiBuffer,             // Input buffer
                       sizeof(trqiBuffer),      // Input buffer size
                       &routeEntry,             // Output buffer
                       sizeof(routeEntry),      // Output buffer size
                       FALSE,                   // Internal ?
                       &event,                  // Event
                       &iosb                   // Status block
                       );
    if (irp==NULL) {
        IF_DEBUG (ROUTING_QUERY) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdTcpRoutingQuery: Could not allocate IRP.\n"));
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto complete;
    }

    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->FileObject = tcpFileObject;

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRoutingQuery: Quering for route to %lx.\n",
                    ((PTDI_ADDRESS_IP)Dest->Address)->in_addr));
    }
    
    status = IoCallDriver (tcpDeviceObject, irp);

    if (status==STATUS_PENDING) {
        status = KeWaitForSingleObject(
                   &event,
                   Executive,
                   KernelMode,
                   FALSE,       // Alertable
                   NULL);       // Timeout
    }

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRoutingQuery: IP_MIB_SINGLE_RT_ENTRY_ID - status: %lx.\n",
                    status));
    }

    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (!NT_SUCCESS (iosb.Status)) {
        status = iosb.Status;
        goto complete;
    }



    //
    // Allocate buffer for address table
    //

    try {
        addrEntryBuf = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool, 
                AFD_IP_ADDRESS_QUERY_SIZE, AFD_ROUTING_QUERY_POOL_TAG);
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        addrEntryBuf = NULL;
        IF_DEBUG (ROUTING_QUERY) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdTcpRoutingQuery: Could not allocate address buffer.\n"));
        }
        goto complete;
    }

    //
    // Setup the query
    //

    RtlZeroMemory (&trqiBuffer, sizeof (trqiBuffer));

    //
    // Initialize the context to 0, TCP should update it 
    // if we don't have enough space to get all the interfaces.
    //
    pNTEContext = (USHORT *)trqiBuffer.Context;
    *pNTEContext = 0;

    lpObject->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    //
    // Keep quering until we find an entry or TCP returns
    // STATUS_BUFFER_OVERFLOW.
    //

    do {
        KeInitializeEvent (&event, NotificationEvent, FALSE);

        //
        // Build, setup and submit the request.
        //

        irp = IoBuildDeviceIoControlRequest (
                           IOCTL_TCP_QUERY_INFORMATION_EX, //Control
                           tcpDeviceObject,            // Device
                           &trqiBuffer,             // Input buffer
                           sizeof(trqiBuffer),      // Input buffer size
                           addrEntryBuf,            // Output buffer
                           AFD_IP_ADDRESS_QUERY_SIZE, // Output buffer size
                           FALSE,                   // Internal ?
                           &event,                  // Event
                           &iosb                   // Status block
                           );
        if (irp==NULL) {
            IF_DEBUG (ROUTING_QUERY) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdTcpRoutingQuery: Could not allocate IRP.\n"));
            }
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete_free_pool;
        }
    
        irpSp = IoGetNextIrpStackLocation (irp);
        irpSp->FileObject = tcpFileObject;

        status = IoCallDriver (tcpDeviceObject, irp);

        if (status==STATUS_PENDING) {
            status = KeWaitForSingleObject(
                       &event,
                       Executive,
                       KernelMode,
                       FALSE,       // Alertable
                       NULL);       // Timeout
        }

        IF_DEBUG (ROUTING_QUERY) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdTcpRoutingQuery: IP_MIB_ADDRTABLE_ENTRY_ID - status: %lx.\n",
                        status));
        }

        if (!NT_SUCCESS (status) && status!=STATUS_BUFFER_OVERFLOW) {
            goto complete_free_pool;
        }

        status = iosb.Status;
        if (!NT_SUCCESS (status) && status!=STATUS_BUFFER_OVERFLOW) {
            goto complete_free_pool;
        }


        //
        // Look for matching interface index in the address table
        //
    
        IF_DEBUG (ROUTING_QUERY) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdTcpRoutingQuery: Looking for interface %ld.\n",
                        routeEntry.ire_index));
        }

        for (pAddrEntry = addrEntryBuf;
                pAddrEntry<(IPAddrEntry *)((PUCHAR)addrEntryBuf+iosb.Information);
                pAddrEntry++) {
            if (pAddrEntry->iae_index==routeEntry.ire_index) {
                Intf->AddressType = TDI_ADDRESS_TYPE_IP;
                Intf->AddressLength = TDI_ADDRESS_LENGTH_IP;
                ((PTDI_ADDRESS_IP)Intf->Address)->in_addr = pAddrEntry->iae_addr;
                ((PTDI_ADDRESS_IP)Intf->Address)->sin_port = 0;
                RtlFillMemory (((PTDI_ADDRESS_IP)Intf->Address)->sin_zero,
                            sizeof (((PTDI_ADDRESS_IP)Intf->Address)->sin_zero), 0);
                IF_DEBUG (ROUTING_QUERY) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdTcpRoutingQuery: Found interface %lx.\n",
                                ((PTDI_ADDRESS_IP)Intf->Address)->in_addr));
                }
                status = STATUS_SUCCESS;
                goto complete_free_pool;
            }
        }
    }
    while (status==STATUS_BUFFER_OVERFLOW);

    //
    // We should always be able to find a match or TCP lied to us
    // when it returned the interface index
    //

    ASSERT (!"TCP must have failed routing query or return valid interface index!!!");
    status = STATUS_HOST_UNREACHABLE;

complete_free_pool:
    AFD_FREE_POOL (addrEntryBuf, AFD_ROUTING_QUERY_POOL_TAG);

complete:
    if (tcpDeviceHandle!=NULL) {
        ObDereferenceObject (tcpFileObject);
        ZwClose (tcpDeviceHandle);
        tcpDeviceHandle = NULL;
    }

    return status;
} // AfdTcpRoutingQuery


NTSTATUS
AfdGetRoutingQueryReference (
    PAFD_PROTOCOL Protocol
    )
/*++

Routine Description:

    Initializes routing query if necessary and references it

Arguments:

    None

Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{

//    KAPC_STATE          apcState;
    HANDLE              DeviceHandle;
    PFILE_OBJECT        FileObject;
    NTSTATUS            status;


    status = AfdOpenDevice (Protocol->NetworkLayerDeviceName, &DeviceHandle, &FileObject);
    if (NT_SUCCESS (status)) {

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite ( AfdResource, TRUE);
        if (Protocol->DeviceHandle==NULL) {
            Protocol->DeviceHandle = DeviceHandle;
            Protocol->FileObject = FileObject;
            ASSERT (Protocol->RoutingQueryRefCount==0);
            Protocol->RoutingQueryRefCount = 1;
            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();
        }
        else {
            ASSERT (Protocol->RoutingQueryRefCount>0);
            InterlockedIncrement (&Protocol->RoutingQueryRefCount);

            ExReleaseResourceLite( AfdResource );
            KeLeaveCriticalRegion ();

            ObDereferenceObject (FileObject);
            status = ZwClose (DeviceHandle);
            ASSERT (status==STATUS_SUCCESS);
        }
    }
    else {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdGetRoutingQueryReference: Network layer device open failed, status: %lx.\n",
                    status));
    }

    return status;
} // AfdGetRoutingQueryReference

NTSTATUS
AfdTcpQueueRoutingChangeRequest (
    IN PAFD_ENDPOINT        Endpoint,
    IN PIRP                 Irp,
    BOOLEAN                 Overlapped
    )
/*++

Routine Description:

    Submits routing change request to TCP

Arguments:
    
    Endpoint    - endpoint on which request is issued

    Irp         - the request

    Overlapped  - whether request is overlapped (and thus should be
                    pended event on non-blocking socket)


Return Value:

    NTSTATUS -- Indicates whether operation succeded

--*/
{
    PTRANSPORT_ADDRESS    destAddr;
    NTSTATUS        status;
    PFILE_OBJECT    fileObject;
    PDEVICE_OBJECT  deviceObject;
    PIO_STACK_LOCATION irpSp;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    struct Notify {
        ROUTING_NOTIFY Ctx;
        char           Data[0];
    } * notify;
    PIRP            irp;
    PIO_COMPLETION_ROUTINE compRoutine;
    PAFD_PROTOCOL   Protocol;

    //
    // Set locals for easy cleanup.
    //
    notify = NULL;
    irp = NULL;

    destAddr = Irp->AssociatedIrp.SystemBuffer;

    Protocol = AfdGetProtocolInfo(destAddr->Address[0].AddressType);
    if (Protocol == NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (destAddr->Address[0].AddressLength < Protocol->AddressLength) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdTcpQueueRoutingChangeRequest: Destination buffer too small.\n"));
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Allocate context structures to keep IRP in the endpoint list in
    // case the latter gets closed and we need to cancel the IRP.
    // Also allocate buffer for passing data to IP
    //

    try {
        notify = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                FIELD_OFFSET(struct Notify, Data[Protocol->RtChangeDataSize]),
                AFD_ROUTING_QUERY_POOL_TAG);
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        notify = NULL;
        goto complete;
    }

    //
    // Open IP driver if necessary
    //

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    
    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (Endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    if (Endpoint->RoutingQueryReferenced) {
        ASSERT (Protocol->DeviceHandle != NULL);
        ASSERT (Protocol->FileObject != NULL);
        ASSERT (Protocol->RoutingQueryRefCount>0);
        InterlockedIncrement (&Protocol->RoutingQueryRefCount);
    }
    else {

        if (Protocol->DeviceHandle!=NULL) {
            Endpoint->RoutingQueryReferenced = TRUE;
            InterlockedIncrement (&Protocol->RoutingQueryRefCount);
            if (Protocol->AddressType == TDI_ADDRESS_TYPE_IP6) {
                Endpoint->RoutingQueryIPv6 = TRUE;
            }
        }
        else {
            AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

            status = AfdGetRoutingQueryReference (Protocol);
            if (!NT_SUCCESS (status)) {
                goto complete;
            }
            ASSERT (Protocol->DeviceHandle!=NULL);

            AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
            if (Endpoint->EndpointCleanedUp) {
                //
                // Endpoint was cleaned-up while we were
                // referencing routing query. Release the reference.
                //
                AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
                AfdDereferenceRoutingQueryEx (Protocol);
                status = STATUS_CANCELLED;
                goto complete;
            }

            if (Endpoint->RoutingQueryReferenced) {
                LONG    result;
                //
                // Another thread referenced routing query for this endpoint.
                // Since we know that that other's thread reference cannot
                // go away while we are holding spinlock, we can simply
                // decrement the reference count and be sure that it
                // won't go all the way to 0.
                //
                result = InterlockedDecrement (&Protocol->RoutingQueryRefCount);
                ASSERT (result>0);
            }
            else {
                Endpoint->RoutingQueryReferenced = TRUE;
                if (Protocol->AddressType == TDI_ADDRESS_TYPE_IP6) {
                    Endpoint->RoutingQueryIPv6 = TRUE;
                }
            }
        }

    }

    fileObject = Protocol->FileObject;
    deviceObject = IoGetRelatedDeviceObject ( fileObject );

    if (Endpoint->NonBlocking && !Overlapped) {

        //
        // For non-blocking socket and non-overlapped requests
        // we shall post the query using new IRP,
        // so even if thread in which rhe request
        // is originated by user exits, our request to IP does not get
        // cancelled and we will still signal the event.
        //

        irp = IoAllocateIrp (deviceObject->StackSize, TRUE);
        if (irp==NULL) {
            AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto complete;
        }


        //
        // Save the endpoint reference in notify context.
        //
        REFERENCE_ENDPOINT (Endpoint);
        notify->Ctx.NotifyContext = Endpoint;

        //
        // Setup completion routine so we can remove the IRP
        // from the endpoint list and free it.
        //
        compRoutine = AfdTcpSignalRoutingChange;

    }
    else {

        //
        // Blocking endpoint: just pass the original request on to the IP
        //
        irp = Irp;

        //
        // Save the original system buffer of the IRP, so we can restore
        // it when TCP completes it
        //

        notify->Ctx.NotifyContext = Irp->AssociatedIrp.SystemBuffer;

        //
        // Setup completion routine so we can restore the IRP and remove it
        // from the endpoint list
        //

        compRoutine = AfdTcpRestartRoutingChange;

    }

    //
    // Insert notification into the endpoint list
    //

    InsertTailList (&Endpoint->RoutingNotifications,
                                    &notify->Ctx.NotifyListLink);

    AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

    //
    // Save pointer to IRP in notify structure
    //
    notify->Ctx.NotifyIrp = irp;

    //
    // Setup IP notification request
    //

    switch(Protocol->AddressType) {
    case TDI_ADDRESS_TYPE_IP:
        {
            IPNotifyData *data = (IPNotifyData *)notify->Data;
            data->Version = 0;
            data->Add = ((PTDI_ADDRESS_IP)destAddr->Address[0].Address)->in_addr;
            break;
        }
    case TDI_ADDRESS_TYPE_IP6:
        {
            IPV6_RTCHANGE_NOTIFY_REQUEST *data = (IPV6_RTCHANGE_NOTIFY_REQUEST *)notify->Data;
            data->Flags = 0;
            data->ScopeId = ((PTDI_ADDRESS_IP6)destAddr->Address[0].Address)->sin6_scope_id;
            if (RtlEqualMemory(((PTDI_ADDRESS_IP6)destAddr->Address[0].Address)->sin6_addr, ZeroString, 16)) {
                data->PrefixLength = 0;
            } 
            else {
                data->PrefixLength = 128;
            }
            RtlCopyMemory(
                &data->Prefix, 
                ((PTDI_ADDRESS_IP6)destAddr->Address[0].Address)->sin6_addr,
                16);
            break;
        }
    }

    //
    // Setup IRP stack location to forward IRP to IP
    // Must be METHOD_BUFFERED or we are not setting it up correctly
    //

    ASSERT ( (Protocol->RtChangeIoctl & 0x03)==METHOD_BUFFERED );
    irp->AssociatedIrp.SystemBuffer = notify->Data;

    irpSp = IoGetNextIrpStackLocation (irp);
    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = 0;
    irpSp->Flags = 0;
    irpSp->Control = 0;
    irpSp->FileObject = fileObject;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = Protocol->RtChangeDataSize;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.IoControlCode = Protocol->RtChangeIoctl;
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    IoSetCompletionRoutine( irp, compRoutine, notify, TRUE, TRUE, TRUE );


    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpQueueRoutingChangeRequest: Passing Irp %p to IP\n",
                    irp));
    }

    if (irp==Irp) {
        //
        // Just pass the request through to the driver and return what it
        // returns
        //
        return AfdIoCallDriver (Endpoint, deviceObject, irp);
    }

    IoCallDriver (deviceObject, irp);

    status = STATUS_DEVICE_NOT_READY; // To be converted to WSAEWOULDBLOCK



    //
    // Error cases
    //

complete:
    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpQueueRoutingChangeRequest: completing with status: %lx\n",
                    status));
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;
} //AfdTcpQueueRoutingChangeRequest

NTSTATUS
AfdTcpRestartRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    )
/*++

Routine Description:

    Completion routing for routing change IRP forwarded to IP

Arguments:
    
    DeviceObject    - must be our device object

    Irp             - the request to be completed

    Context         - completion context


Return Value:

    NTSTATUS -- Indicates to the system what to do next with the IRP

--*/
{
    PROUTING_NOTIFY notifyCtx = Context;
    PAFD_ENDPOINT   endpoint = IoGetCurrentIrpStackLocation (Irp)->FileObject->FsContext;

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpRestartRoutingChange: Irp: %p, status: %lx, info: %ld.\n",
                    Irp, Irp->IoStatus.Status, Irp->IoStatus.Information));
    }


    //
    // Check if IRP is still on the endpoint's list and remove if it is
    //

    if (InterlockedExchangePointer ((PVOID *)&notifyCtx->NotifyIrp, NULL)!=NULL) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;
        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        RemoveEntryList (&notifyCtx->NotifyListLink);
        AfdIndicateEventSelectEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Indicate event as the endpoint is still active
        //

        AfdIndicatePollEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
    }

    //
    // If pending has be returned for this IRP then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }

    //
    // Restore the IRP to its previous glory and free allocated context structure
    //

    Irp->AssociatedIrp.SystemBuffer = notifyCtx->NotifyContext;
    AfdCompleteOutstandingIrp (endpoint, Irp);

    AFD_FREE_POOL (notifyCtx, AFD_ROUTING_QUERY_POOL_TAG);
    return STATUS_SUCCESS;
}


NTSTATUS
AfdTcpSignalRoutingChange (
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp, 
    IN PVOID Context 
    )
/*++

Routine Description:

    Completion routing for routing change IRP submitted to IP

Arguments:
    
    DeviceObject    - must be our device object

    Irp             - the request to be completed

    Context         - completion context


Return Value:

    NTSTATUS -- Indicates to the system what to do next with the IRP

--*/
{
    PROUTING_NOTIFY notifyCtx = Context;
    PAFD_ENDPOINT   endpoint = notifyCtx->NotifyContext;

    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    IF_DEBUG (ROUTING_QUERY) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdTcpSignalRoutingChange: Irp: %p, status: %lx, info: %ld.\n",
                    Irp, Irp->IoStatus.Status, Irp->IoStatus.Information));
    }


    //
    // Check if IRP is still on the endpoint's list and remove if it is
    //

    if (InterlockedExchangePointer ((PVOID *)&notifyCtx->NotifyIrp, NULL)!=NULL) {
        AFD_LOCK_QUEUE_HANDLE lockHandle;

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
        RemoveEntryList (&notifyCtx->NotifyListLink);
        AfdIndicateEventSelectEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Indicate event as the endpoint is still active
        //

        AfdIndicatePollEvent (endpoint, 
                            AFD_POLL_ROUTING_IF_CHANGE, 
                            Irp->IoStatus.Status);
    }

    //
    // Release previously acquired endpoint reference
    //

    DEREFERENCE_ENDPOINT (endpoint);

    //
    // Free allocated irp and context structure
    //

    IoFreeIrp (Irp);
    AFD_FREE_POOL (notifyCtx, AFD_ROUTING_QUERY_POOL_TAG);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
AfdCancelAddressListChange (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
AfdCleanupAddressListChange (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    );

NTSTATUS
AfdInitializeAddressList (VOID);

VOID
AfdAddAddressHandler ( 
	IN PTA_ADDRESS NetworkAddress,
	IN PUNICODE_STRING  DeviceName,
	IN PTDI_PNP_CONTEXT Context
    );

VOID
AfdDelAddressHandler ( 
	IN PTA_ADDRESS NetworkAddress,
	IN PUNICODE_STRING  DeviceName,
	IN PTDI_PNP_CONTEXT Context
    );

VOID
AfdProcessAddressChangeList (
    USHORT              AddressType,
    PUNICODE_STRING     DeviceName
    );

NTSTATUS
AfdPnPPowerChange(
    IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    );

VOID
AfdReturnNicsPackets (
    PVOID   Pdo
    );

BOOLEAN
AfdHasHeldPacketsFromNic (
    PAFD_CONNECTION Connection,
    PVOID           Pdo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE,    AfdAddressListQuery )
#pragma alloc_text( PAGEAFD, AfdAddressListChange )
#pragma alloc_text( PAGEAFD, AfdCancelAddressListChange )
#pragma alloc_text( PAGE,    AfdInitializeAddressList )
#pragma alloc_text( PAGE,    AfdDeregisterPnPHandlers )
#pragma alloc_text( PAGE,    AfdAddAddressHandler )
#pragma alloc_text( PAGE,    AfdDelAddressHandler )
#pragma alloc_text( PAGEAFD, AfdProcessAddressChangeList )
#pragma alloc_text( PAGE,    AfdPnPPowerChange )
#pragma alloc_text( PAGEAFD, AfdReturnNicsPackets )
#pragma alloc_text( PAGEAFD, AfdHasHeldPacketsFromNic )
#endif

//
// Cache the device being brought down as a result of
// removal or power down event, so we do not scan our endpoints
// unnecessarily when more than one transport propagates device down
// event for the same device to us.
//
PVOID     AfdLastRemovedPdo = NULL;
ULONGLONG AfdLastRemoveTime = 0i64;

NTSTATUS
AfdAddressListQuery (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Processes address list query IRP

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    NTSTATUS            status;
    PLIST_ENTRY         listEntry;
    PTRANSPORT_ADDRESS  addressList;
    PAFD_ENDPOINT       endpoint;
    PUCHAR              addressBuf;
    ULONG               dataLen;
    PAFD_ADDRESS_ENTRY  addressEntry;
    USHORT              addressType;

    PAGED_CODE ();

    *Information = 0;
    status = STATUS_SUCCESS;

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListQuery: Endp: %p, buf: %p, inlen: %ld, outlen: %ld.\n",
                    FileObject->FsContext,
                    OutputBuffer,
                    InputBufferLength,
                    OutputBufferLength));
    }

    //
    // Validate input parameters
    //

    if( InputBufferLength < sizeof(USHORT) ||
            OutputBufferLength < FIELD_OFFSET (TRANSPORT_ADDRESS, Address)
            ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdAddressListQuery: Endp: %p - invalid parameter.\n",
                    FileObject->FsContext));
        return STATUS_INVALID_PARAMETER;
    }

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    try {
        if (RequestorMode!=KernelMode) {
            ProbeForRead (InputBuffer,
                            sizeof (addressType),
                            sizeof (USHORT));
            ProbeForWrite (OutputBuffer,
                            OutputBufferLength,
                            sizeof (ULONG));
        }

        addressType = *((PUSHORT)InputBuffer);

        addressList = OutputBuffer;
        addressBuf = (PUCHAR)OutputBuffer;
        dataLen = FIELD_OFFSET (TRANSPORT_ADDRESS, Address);
        addressList->TAAddressCount = 0;
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    ExAcquireResourceSharedLite( AfdResource, TRUE );

    //
    // Setup address handlers with TDI if not already done
    //
    if (AfdBindingHandle==NULL) {
        ExReleaseResourceLite( AfdResource );

        ExAcquireResourceExclusiveLite( AfdResource, TRUE );

        if (AfdBindingHandle==NULL) {
            status = AfdInitializeAddressList ();
            if (!NT_SUCCESS (status)) {
                ExReleaseResourceLite (AfdResource);
                KeLeaveCriticalRegion ();
                return status;
            }
        }
        else
            status = STATUS_SUCCESS;
        
        ASSERT (AfdBindingHandle!=NULL);
    }

    ExAcquireResourceSharedLite( AfdAddressListLock, TRUE );
    ExReleaseResourceLite( AfdResource );

    //
    // Walk the address list and pick up the addresses of matching protocol
    // family
    //

    listEntry = AfdAddressEntryList.Flink;
    while (listEntry!=&AfdAddressEntryList) {
        addressEntry = CONTAINING_RECORD (listEntry, AFD_ADDRESS_ENTRY, AddressListLink);
        listEntry = listEntry->Flink;

        //
        // Found a match ?
        //

        if ((addressEntry->Address.AddressType==addressType)
                    //
                    // Special check for Netbios addresses because
                    // we have separate protocols for each lana/device
                    //
                 && ((addressType!=TDI_ADDRESS_TYPE_NETBIOS)
                        || endpoint->TransportInfo==NULL
                        || RtlEqualUnicodeString (
                                &addressEntry->DeviceName,
                                &endpoint->TransportInfo->TransportDeviceName,
                                TRUE))) {
            ULONG   addressLength = FIELD_OFFSET (TA_ADDRESS,
                        Address[addressEntry->Address.AddressLength]);
            try {

                //
                // Copy address to the output buffer if it is not full
                //

                if (status==STATUS_SUCCESS) {
                    if (dataLen+addressLength<OutputBufferLength) {
                        RtlCopyMemory (&addressBuf[dataLen], 
                                            &addressEntry->Address, 
                                            addressLength);
                        IF_DEBUG (ADDRESS_LIST) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdAddressListQuery: Adding address of type: %d, length: %d.\n",
                                addressEntry->Address.AddressType,
                                addressEntry->Address.AddressLength));
                        }
                    }
                    else {
                        //
                        // End of buffer reached.  Set error code so we do not
                        // attempt to copy more data
                        //
                        IF_DEBUG (ADDRESS_LIST) {
                            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                        "AfdAddressListQuery: Buffer is full.\n"));
                        }
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }

                //
                // Count the addresses and total buffer length whether we copied
                // them or not to the output buffer
                //

                addressList->TAAddressCount += 1;
                dataLen += addressLength;
            }
            except (AFD_EXCEPTION_FILTER (&status)) {
                dataLen = 0;
                break;
            }
        }
    }
    ExReleaseResourceLite (AfdAddressListLock);
    KeLeaveCriticalRegion ();

    //
    // Return total number of copied/required bytes in the buffer and status
    //

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListQuery: Address count: %ld, total buffer size: %ld.\n",
                    addressList->TAAddressCount, dataLen));
    }
    *Information = dataLen;

    return status;
} //AfdAddressListQuery



//
// Context structure allocated for non-blocking address list change IOCTLs
//

typedef struct _AFD_NBCHANGE_CONTEXT {
    AFD_REQUEST_CONTEXT Context;        // Context to keep track of request
    AFD_ADDRESS_CHANGE  Change;         // Address change parameters
} AFD_NBCHANGE_CONTEXT, *PAFD_NBCHANGE_CONTEXT;


NTSTATUS
FASTCALL
AfdAddressListChange (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
/*++

Routine Description:

    Processes address list change IRP

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the stack location to use for this request.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
    NTSTATUS                    status = STATUS_PENDING;
    USHORT                      addressType;
    PAFD_ADDRESS_CHANGE         change;
    PAFD_REQUEST_CONTEXT        requestCtx;
    PAFD_ENDPOINT               endpoint;
    AFD_LOCK_QUEUE_HANDLE          addressLockHandle, endpointLockHandle;
    KIRQL                       oldIrql;
    BOOLEAN                     overlapped;
    AFD_TRANSPORT_IOCTL_INFO    ioctlInfo;

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListChange: Endp: %p, buf: %p, inlen: %ld, outlen: %ld.\n",
                    IrpSp->FileObject->FsContext,
                    Irp->AssociatedIrp.SystemBuffer,
                    IrpSp->Parameters.DeviceIoControl.InputBufferLength,
                    IrpSp->Parameters.DeviceIoControl.OutputBufferLength));
    }

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Validate input parameters
    //

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_TRANSPORT_IOCTL_INFO32 ioctlInfo32;
        ioctlInfo32 = Irp->AssociatedIrp.SystemBuffer;
        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (*ioctlInfo32)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
        ioctlInfo.Handle = ioctlInfo32->Handle;
        ioctlInfo.InputBuffer = ioctlInfo32->InputBuffer;
        ioctlInfo.InputBufferLength = ioctlInfo32->InputBufferLength;
        ioctlInfo.IoControlCode = ioctlInfo32->IoControlCode;
        ioctlInfo.AfdFlags = ioctlInfo32->AfdFlags;
        ioctlInfo.PollEvent = ioctlInfo32->PollEvent;
    }
    else
#endif // _WIN64
    {

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength<sizeof (ioctlInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        //
        // Just copy the buffer verified by the IO system
        //

        ioctlInfo = *((PAFD_TRANSPORT_IOCTL_INFO)
                        Irp->AssociatedIrp.SystemBuffer);
    }

    if( ioctlInfo.InputBufferLength < sizeof(USHORT)) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdAddressListChange: Endp: %p - invalid parameter.\n",
                    IrpSp->FileObject->FsContext));
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    try {
        if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(
                    ioctlInfo.InputBuffer,
                    ioctlInfo.InputBufferLength,
                    sizeof (USHORT)
                    );
            }

        addressType = *((PUSHORT)ioctlInfo.InputBuffer);
    }
    except( AFD_EXCEPTION_FILTER(&status) ) {
        goto complete;
    }

    //
    // Check if request is overlapped
    //

    overlapped = ((ioctlInfo.AfdFlags & AFD_OVERLAPPED)!=0);

    //
    // Reset the poll bit
    //

    endpoint->EventsActive &= ~AFD_POLL_ADDRESS_LIST_CHANGE;

    //
    // Setup address handlers with TDI if not already done
    //

    if (AfdBindingHandle==NULL) {
        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite( AfdResource, TRUE );

        if (AfdBindingHandle==NULL)
            status = AfdInitializeAddressList ();
        else
            status = STATUS_SUCCESS;

        ExReleaseResourceLite (AfdResource);
        KeLeaveCriticalRegion ();

        if (!NT_SUCCESS (status)) {
            goto complete;
        }
    }

    //
    // Setup locals
    //

    if (endpoint->NonBlocking && !overlapped) {
        PAFD_NBCHANGE_CONTEXT   nbCtx;
        //
        // If endpoint is non-blocking and request is not overlapped,
        // we'll have to complete it right away and remeber that we
        // need to set event when address list changes
        //


        //
        // Allocate context to keep track of this request
        //

        try {
            nbCtx = AFD_ALLOCATE_POOL_WITH_QUOTA (NonPagedPool,
                            sizeof(AFD_NBCHANGE_CONTEXT),
                            AFD_ADDRESS_CHANGE_POOL_TAG);
            // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            nbCtx = NULL;
            IF_DEBUG(ROUTING_QUERY) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdAddressListChange: Endp: %p - can't allocate change strucure.\n",
                        IrpSp->FileObject->FsContext));
            }
            goto complete;
        }

        requestCtx = &nbCtx->Context;
        change = &nbCtx->Change;

        change->Endpoint = endpoint;
        change->NonBlocking = TRUE;
        status = STATUS_DEVICE_NOT_READY;
    }
    else {

        C_ASSERT (sizeof (IrpSp->Parameters.Others)>=sizeof (*requestCtx));
        C_ASSERT (sizeof (Irp->Tail.Overlay.DriverContext)>=sizeof (*change));

        requestCtx = (PAFD_REQUEST_CONTEXT)&IrpSp->Parameters.Others;

        change = (PAFD_ADDRESS_CHANGE)Irp->Tail.Overlay.DriverContext;
        change->NonBlocking = FALSE;
        change->Irp = Irp;

    }

    //
    // Remeber the endpoint and address type for the request
    //

    change->AddressType = addressType;
    requestCtx->CleanupRoutine = AfdCleanupAddressListChange;
    requestCtx->Context = change;

    //
    // Insert change notification into the list
    //
    KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);
    AfdAcquireSpinLockAtDpcLevel (&AfdAddressChangeLock, &addressLockHandle);

    //
    // While holding the address change spinlock acquire endpoint
    // spinlock so if notification occurs, neither structure can
    // be deallocated or IRP completed while we are queuing
    // it to endpoint list
    //
    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &endpointLockHandle);

    //
    // If request is non-blocking, check if we have another non-blocking
    // request on the same endpoint. If so, we do not need to have
    // two request structures in the list waiting to signal.
    //
    if (change->NonBlocking) {
        PLIST_ENTRY listEntry = endpoint->RequestList.Flink;
        while (listEntry!=&endpoint->RequestList) {
            PAFD_REQUEST_CONTEXT    req = CONTAINING_RECORD (
                                            listEntry,
                                            AFD_REQUEST_CONTEXT,
                                            EndpointListLink);
            listEntry = listEntry->Flink;
            if (req->CleanupRoutine==AfdCleanupAddressListChange) {
                PAFD_ADDRESS_CHANGE chg = req->Context;
                if (chg->NonBlocking) {
                    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
                    AfdReleaseSpinLockFromDpcLevel (&AfdAddressChangeLock, &addressLockHandle);
                    KeLowerIrql (oldIrql);
                    AFD_FREE_POOL (CONTAINING_RECORD (
                                            requestCtx,
                                            AFD_NBCHANGE_CONTEXT,
                                            Context),
                                    AFD_ADDRESS_CHANGE_POOL_TAG);
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                                "AfdAddressListChange: Endp: %p - non-blocking request already pending.\n",
                                IrpSp->FileObject->FsContext));
                    ASSERT (status == STATUS_DEVICE_NOT_READY);
                    goto complete;
                }
            }
        }
    }

    InsertTailList (&AfdAddressChangeList, &change->ChangeListLink);
    AfdReleaseSpinLockFromDpcLevel (&AfdAddressChangeLock, &addressLockHandle);
    InsertTailList (&endpoint->RequestList, &requestCtx->EndpointListLink);
    if (!change->NonBlocking) {

        //
        // Set cancel routine
        //

        IoSetCancelRoutine( Irp, AfdCancelAddressListChange );
        if ( !Irp->Cancel || IoSetCancelRoutine( Irp, NULL ) == NULL) {
            IoMarkIrpPending (Irp);
            //
            // Either there was no cancel or cancel routine has
            // been invoked already
            //
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            KeLowerIrql (oldIrql);

            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdAddressListChange: Queued change IRP: %p on endp: %p .\n",
                            Irp, endpoint));
            }

            return STATUS_PENDING;
        }
        else {
            RemoveEntryList (&requestCtx->EndpointListLink);
            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
            KeLowerIrql (oldIrql);
            goto complete;
        }
    }
    else {
        ASSERT (status==STATUS_DEVICE_NOT_READY);
    }
    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &endpointLockHandle);
    KeLowerIrql (oldIrql);

complete:

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddressListChange: Completing IRP: %ld on endp: %p with status: %lx .\n",
                    Irp, IrpSp->FileObject->FsContext, status));
    }
    IoCompleteRequest( Irp, 0 );

    return status;
}

VOID
AfdCancelAddressListChange (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Cancel routine for pending address list change IRP

Arguments:
    
    DeviceObject    - must be our device object

    Irp             - the request to be cancelled


Return Value:

    None

--*/
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PAFD_ADDRESS_CHANGE     change;
    PAFD_REQUEST_CONTEXT    requestCtx;
    PAFD_ENDPOINT           endpoint;
    PIO_STACK_LOCATION      irpSp;

    //
    // We do not use cancel spinlock to manage address list queue, so
    // we can release it right away
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    // Get the request context and remove it from the queue if not
    // already removed.
    //

    irpSp = IoGetCurrentIrpStackLocation (Irp);
    endpoint = irpSp->FileObject->FsContext;
    ASSERT (IS_AFD_ENDPOINT_TYPE (endpoint));

    requestCtx = (PAFD_REQUEST_CONTEXT)&irpSp->Parameters.DeviceIoControl;
    change = requestCtx->Context;
    ASSERT (change==(PAFD_ADDRESS_CHANGE)Irp->Tail.Overlay.DriverContext);
    ASSERT (change->NonBlocking==FALSE);

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);
    if (change->ChangeListLink.Flink!=NULL) {
        RemoveEntryList (&change->ChangeListLink);
        change->ChangeListLink.Flink = NULL;
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    if (AfdIsRequestInQueue (requestCtx)) {
        //
        // Context is still in the list, just remove it so
        // noone can see it anymore and complete the IRP
        //
        RemoveEntryList (&requestCtx->EndpointListLink);
    }
    else if (!AfdIsRequestCompleted (requestCtx)) {
        //
        // During endpoint cleanup, this context was removed from the
        // list and cleanup routine is about to be called, don't
        // free this IRP until cleanup routine is called
        // Also, indicate to the cleanup routine that we are done
        // with this IRP and it can free it.
        //
        AfdMarkRequestCompleted (requestCtx);
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        return;
    }

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdCancelAddressListChange: Cancelled IRP: %p on endp: %p .\n",
                    Irp, endpoint));
    }
}

BOOLEAN
AfdCleanupAddressListChange (
    PAFD_ENDPOINT           Endpoint,
    PAFD_REQUEST_CONTEXT    RequestCtx
    )
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PAFD_ADDRESS_CHANGE     change;

    change = RequestCtx->Context;

    //
    // In no case IRP and request structure
    // could have been freed until we mark it as completed as
    // the caller of this routine should have marked the request
    // as being cancelled
    //
    ASSERT (RequestCtx->EndpointListLink.Flink==NULL);

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);
    if (change->ChangeListLink.Flink!=NULL) {
        RemoveEntryList (&change->ChangeListLink);
        change->ChangeListLink.Flink = NULL;
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    AfdAcquireSpinLock (&Endpoint->SpinLock, &lockHandle);
    //
    // The processing routine has either already initiated completion
    // of this request and marked it as completed what it saw that the request is
    // no longer on the endpoint queue, or the processing routine will
    // never see the request since we removed it from the processing list.
    // However, it is possible that blocking request is being cancelled in another
    // thread as we cleaning up, so we need to sync with the cancel routine.
    //
    if (AfdIsRequestCompleted (RequestCtx) ||   
            change->NonBlocking ||              
            IoSetCancelRoutine (change->Irp, NULL)!=NULL) {
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);
        if (change->NonBlocking) {
			ASSERT (CONTAINING_RECORD (RequestCtx,
										AFD_NBCHANGE_CONTEXT,
										Context)
						==CONTAINING_RECORD (change,
										AFD_NBCHANGE_CONTEXT,
										Change));
            ASSERT (Endpoint == change->Endpoint);
            AFD_FREE_POOL (CONTAINING_RECORD (RequestCtx,
                                                AFD_NBCHANGE_CONTEXT,
                                                Context),
                            AFD_ADDRESS_CHANGE_POOL_TAG);
        }
        else {
            PIRP    irp = change->Irp;
            ASSERT (change==(PAFD_ADDRESS_CHANGE)irp->Tail.Overlay.DriverContext);
            ASSERT (Endpoint == IoGetCurrentIrpStackLocation (irp)->FileObject->FsContext);
            ASSERT (RequestCtx == (PAFD_REQUEST_CONTEXT)
                &IoGetCurrentIrpStackLocation (irp)->Parameters.DeviceIoControl);
            irp->IoStatus.Status = STATUS_CANCELLED;
            irp->IoStatus.Information = 0;
            IoCompleteRequest (irp, IO_NO_INCREMENT);
        }
        return TRUE;
    }
    else {

        //
        // AFD has not completed the request before returning
        // from cancel routine, mark the request to indicate
        // that we are done with it and cancel routine
        // can free it
        //

        AfdMarkRequestCompleted (RequestCtx);
        AfdReleaseSpinLock (&Endpoint->SpinLock, &lockHandle);

        return FALSE;
    }

}


NTSTATUS
AfdInitializeAddressList (VOID)
/*++

Routine Description:

    Register address handler routinges with TDI

Arguments:
    
    None


Return Value:

    NTSTATUS -- Indicates whether registration succeded

--*/

{
    NTSTATUS                    status;
    TDI_CLIENT_INTERFACE_INFO   info;
    UNICODE_STRING              afdName;
    
    PAGED_CODE ();

    //
    // Do basic initialization if we haven't done this before.
    //
    if (AfdAddressListLock==NULL) {

        //
        // Initialize spinlock that protects address change list.
        //
        AfdInitializeSpinLock (&AfdAddressChangeLock);

        //
        // Allocate and initialize resource that protects address list
        //

        AfdAddressListLock = AFD_ALLOCATE_POOL_PRIORITY(
                          NonPagedPool,
                          sizeof(*AfdAddressListLock),
                          AFD_RESOURCE_POOL_TAG,
                          HighPoolPriority
                          );

        if ( AfdAddressListLock == NULL ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ExInitializeResourceLite( AfdAddressListLock );

        //
        // Initialize our lists
        //

        InitializeListHead (&AfdAddressEntryList);
        InitializeListHead (&AfdAddressChangeList);
    }

    //
    // Setup the TDI request structure
    //

    RtlZeroMemory (&info, sizeof (info));
    RtlInitUnicodeString(&afdName, L"AFD");
#ifdef TDI_CURRENT_VERSION
    info.TdiVersion = TDI_CURRENT_VERSION;
#else
    info.MajorTdiVersion = 2;
    info.MinorTdiVersion = 0;
#endif
    info.Unused = 0;
    info.ClientName = &afdName;
    info.BindingHandler = NULL;
    info.AddAddressHandlerV2 = AfdAddAddressHandler;
    info.DelAddressHandlerV2 = AfdDelAddressHandler;
    info.PnPPowerHandler = AfdPnPPowerChange;

    //
    // Register handlers with TDI
    //

    status = TdiRegisterPnPHandlers (&info, sizeof (info), &AfdBindingHandle);
    if (!NT_SUCCESS (status)) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdInitializeAddressList: Failed to register PnP handlers: %lx .\n",
                    status));
        return status;
    }

    return STATUS_SUCCESS;
}


VOID
AfdDeregisterPnPHandlers (
    PVOID   Param
    )
{

    ASSERT ( ExIsResourceAcquiredSharedLite ( AfdAddressListLock )==0
              || ExIsResourceAcquiredExclusiveLite( AfdAddressListLock ));

    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite (AfdResource, TRUE);

    //
    // Free address list and associated structures
    //
    if (AfdBindingHandle) {
        ExAcquireResourceExclusiveLite( AfdAddressListLock, TRUE );

        TdiDeregisterPnPHandlers (AfdBindingHandle);
        AfdBindingHandle = NULL;

        ASSERT (AfdAddressListLock!=NULL);
        while( !IsListEmpty( &AfdAddressEntryList ) ) {
            PAFD_ADDRESS_ENTRY  addressEntry;
            PLIST_ENTRY listEntry;
            listEntry = RemoveHeadList( &AfdAddressEntryList );

            addressEntry = CONTAINING_RECORD(
                                listEntry,
                                AFD_ADDRESS_ENTRY,
                                AddressListLink
                                );

            AFD_FREE_POOL(
                addressEntry,
                AFD_TRANSPORT_ADDRESS_POOL_TAG
                );

        }


        if (!IsListEmpty (&AfdEndpointListHead)) {
            //
            // Call routine to notify all the clietns
            //

            ASSERT (!IsListEmpty (&AfdTransportInfoListHead));
            ASSERT (AfdLoaded);

            AfdProcessAddressChangeList (TDI_ADDRESS_TYPE_UNSPEC, NULL);
        }

        ExReleaseResourceLite (AfdAddressListLock);
    }

    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
}

VOID
AfdAddAddressHandler ( 
	IN PTA_ADDRESS NetworkAddress,
	IN PUNICODE_STRING  DeviceName,
	IN PTDI_PNP_CONTEXT Context
    )
/*++

Routine Description:

    TDI add address handler

Arguments:
    
    NetworkAddress  - new network address available on the system

    Context1        - name of the device to which address belongs

    Context2        - PDO to which address belongs


Return Value:

    None

--*/
{
    PAFD_ADDRESS_ENTRY addrEntry;
    PAGED_CODE ();

    //
    // Clear the cached last removed PDO when we get address add notification
    // since PDO can now be reused for something else.
    //
    AfdLastRemovedPdo = NULL;

    if (DeviceName==NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                  "AfdAddAddressHandler: "
                  "NO DEVICE NAME SUPPLIED when adding address of type %d., IGNORING IT!!!\n",
                  NetworkAddress->AddressType));
        return;
    }

    //
    // Allocate memory to keep address in our list
    // Note since the address information usually gets
    // populated during boot and not used right away, we
    // make it a "cold" allocation.  The flag has no effect
    // after system is booted.
    //

    addrEntry = AFD_ALLOCATE_POOL_PRIORITY (PagedPool|POOL_COLD_ALLOCATION,
                        ALIGN_UP(FIELD_OFFSET (AFD_ADDRESS_ENTRY,
                                Address.Address[NetworkAddress->AddressLength]),
                                WCHAR)
                            +DeviceName->MaximumLength,
                        AFD_TRANSPORT_ADDRESS_POOL_TAG,
                        HighPoolPriority);

    if (addrEntry!=NULL) {
        //
        // Insert new address in the list
        //

        RtlCopyMemory (&addrEntry->Address, NetworkAddress, 
                        FIELD_OFFSET (TA_ADDRESS,
                            Address[NetworkAddress->AddressLength]));

        addrEntry->DeviceName.MaximumLength = DeviceName->MaximumLength;
        addrEntry->DeviceName.Buffer = 
            ALIGN_UP_POINTER(&addrEntry->Address.Address[NetworkAddress->AddressLength],
                           WCHAR);
        RtlCopyUnicodeString (&addrEntry->DeviceName, DeviceName);


        //
        // We shouldn't be calling into TDI while having resource
        // acquired in shared mode because it can cause a deadloclk
        // rigth here as TDI reenters us and we need to acquire the
        // resource exclusive
        //

        ASSERT ( ExIsResourceAcquiredSharedLite ( AfdAddressListLock )==0
                  || ExIsResourceAcquiredExclusiveLite( AfdAddressListLock ));

        //
        // Make sure the thread in which we execute cannot get
        // suspeneded in APC while we own the global resource.
        //
        KeEnterCriticalRegion ();

        //
        // Acquire AfdResource since we will be checking if there are endpoints in
        // the list to decide whether to call non-pageable routine.
        //
        ExAcquireResourceSharedLite (AfdResource, TRUE);
        ExAcquireResourceExclusiveLite( AfdAddressListLock, TRUE );

        InsertTailList (&AfdAddressEntryList, &addrEntry->AddressListLink);

        //
        // Don't call if endpoint list is empty, since the driver
        // may be paged out.  There should be no-one to notify anyway
        // if there are no sockets there.
        //
        if (!IsListEmpty (&AfdEndpointListHead)) {
            //
            // Call routine to notify all the clietns
            //

            ASSERT (!IsListEmpty (&AfdTransportInfoListHead));
            ASSERT (AfdLoaded);

            AfdProcessAddressChangeList (NetworkAddress->AddressType, DeviceName);
        }

        ExReleaseResourceLite (AfdAddressListLock);
        ExReleaseResourceLite (AfdResource);
        KeLeaveCriticalRegion ();
    }
    else {
        //
        // Failed allocation - queue work item to deregister PnP
        // handlers and notify all apps.
        // When apps come back will re-register and our list will
        // get re-populated, or we'll fail the app's call(s);
        //
        AfdQueueWorkItem (&AfdDeregisterPnPHandlers, &AfdPnPDeregisterWorker);
    }

    IF_DEBUG (ADDRESS_LIST) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdAddAddressHandler: Type: %d, length: %d, device: %*ls .\n",
                    NetworkAddress->AddressType,
                    NetworkAddress->AddressLength,
                    DeviceName->Length/2,
                    DeviceName->Buffer));
    }
}

VOID
AfdDelAddressHandler ( 
	IN PTA_ADDRESS NetworkAddress,
	IN PUNICODE_STRING DeviceName,
	IN PTDI_PNP_CONTEXT Context
    )
/*++

Routine Description:

    TDI delete address handler

Arguments:
    
    NetworkAddress  - network address that is no longer available on the system

    Context1        - name of the device to which address belongs

    Context2        - PDO to which address belongs


Return Value:

    None

--*/
{
    PAFD_ADDRESS_ENTRY  addrEntry;
    PLIST_ENTRY         listEntry;

    PAGED_CODE ();

    if (DeviceName==NULL) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_ERROR_LEVEL,
                    "AfdDelAddressHandler: "
                    "NO DEVICE NAME SUPPLIED when deleting address of type %d.\n",
                    NetworkAddress->AddressType));
        return;
    }


    //
    // We shouldn't be calling into TDI while having resource
    // acquired in shared mode because it can cause a deadloclk
    // rigth here as TDI reenters us and we need to acquire the
    // resource exclusive
    //

    ASSERT ( ExIsResourceAcquiredSharedLite ( AfdAddressListLock )==0
                || ExIsResourceAcquiredExclusiveLite( AfdAddressListLock ));
    
    //
    // Find address in our list
    //

    //
    // Make sure the thread in which we execute cannot get
    // suspeneded in APC while we own the global resource.
    //
    KeEnterCriticalRegion ();
    //
    // Acquire AfdResource since we will be checking if there are endpoints in
    // the list to decide whether to call non-pageable routine.
    //
    ExAcquireResourceSharedLite (AfdResource, TRUE);
    ExAcquireResourceExclusiveLite( AfdAddressListLock, TRUE );
    listEntry = AfdAddressEntryList.Flink;
    while (listEntry!=&AfdAddressEntryList) {
        addrEntry = CONTAINING_RECORD (listEntry, AFD_ADDRESS_ENTRY, AddressListLink);
        listEntry = listEntry->Flink;
        if (RtlEqualMemory (&addrEntry->Address, NetworkAddress,
                    FIELD_OFFSET (TA_ADDRESS,
                    Address[NetworkAddress->AddressLength]))
                && RtlEqualUnicodeString (&addrEntry->DeviceName,
                                            DeviceName,
                                            TRUE)) {

            //
            // Remove it and notify the clients
            //

            RemoveEntryList (&addrEntry->AddressListLink);
            //
            // Don't call if endpoint list is empty, since the driver
            // may be paged out.  There should be no-one to notify anyway
            // if there are no sockets there.
            //
            if (!IsListEmpty (&AfdEndpointListHead)) {

                ASSERT (!IsListEmpty (&AfdTransportInfoListHead));
                ASSERT (AfdLoaded);

                AfdProcessAddressChangeList (NetworkAddress->AddressType, DeviceName);
            }

            ExReleaseResourceLite (AfdAddressListLock);
            ExReleaseResourceLite (AfdResource);
            KeLeaveCriticalRegion ();
            AFD_FREE_POOL (addrEntry, AFD_TRANSPORT_ADDRESS_POOL_TAG);
            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdDelAddressHandler: Type: %d, length: %d, device: %*ls .\n",
                            NetworkAddress->AddressType,
                            NetworkAddress->AddressLength,
                            DeviceName->Length/2,
                            DeviceName->Buffer));
            }
            return;
        }
    }
    ExReleaseResourceLite (AfdAddressListLock);
    ExReleaseResourceLite (AfdResource);
    KeLeaveCriticalRegion ();
    ASSERT (!"AfdDelAddressHandler: Could not find matching entry");
}

VOID
AfdProcessAddressChangeList (
    USHORT          AddressType,
    PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    Notifuis all interested clients of address arrival/deletion

Arguments:
    
    AddressType     - type of the address that arrived/ was deleted

    DeviceName      - name of the device to which address belongs

Return Value:

    None

--*/
{
    AFD_LOCK_QUEUE_HANDLE      lockHandle;
    PLIST_ENTRY             listEntry;
    LIST_ENTRY              completedChangeList;
    PAFD_ADDRESS_CHANGE     change;
    PAFD_REQUEST_CONTEXT    requestCtx;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpSp;
    PAFD_ENDPOINT           endpoint;
    PAFD_TRANSPORT_INFO     transportInfo;

    // ASSERT ((AddressType!=TDI_ADDRESS_TYPE_NETBIOS) || (DeviceName!=NULL));
    //
    // Special check for Netbios addresses because
    // we have separate protocols for each lana/device
    //
    transportInfo = NULL;
    if ((AddressType==TDI_ADDRESS_TYPE_NETBIOS) && (DeviceName!=NULL)) {
        BOOLEAN found = FALSE;
        for ( listEntry = AfdTransportInfoListHead.Flink;
              listEntry != &AfdTransportInfoListHead;
              listEntry = listEntry->Flink ) {
            transportInfo = CONTAINING_RECORD(
                                listEntry,
                                AFD_TRANSPORT_INFO,
                                TransportInfoListEntry
                                );
            if (RtlEqualUnicodeString (
                                    DeviceName,                           
                                    &transportInfo->TransportDeviceName,
                                    TRUE)) {
                found = TRUE;
                break;
            }
        }
        if (!found)
            return;
    }

    //
    // Create local list to process notifications after spinlock is released
    //

    InitializeListHead (&completedChangeList);

    //
    // Walk the list and move matching notifications to the local list
    //

    AfdAcquireSpinLock (&AfdAddressChangeLock, &lockHandle);
    listEntry = AfdAddressChangeList.Flink;
    while (listEntry!=&AfdAddressChangeList) {
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        if (change->NonBlocking) {
            endpoint = change->Endpoint;
            requestCtx = &CONTAINING_RECORD (change,
                                AFD_NBCHANGE_CONTEXT,
                                Change)->Context;
            ASSERT (requestCtx->Context==change);
        }
        else {
            irp = change->Irp;
            irpSp = IoGetCurrentIrpStackLocation (irp);
            requestCtx = (PAFD_REQUEST_CONTEXT)&irpSp->Parameters.DeviceIoControl;
            endpoint = irpSp->FileObject->FsContext;
            ASSERT (change==(PAFD_ADDRESS_CHANGE)irp->Tail.Overlay.DriverContext);
        }

        listEntry = listEntry->Flink;
        if (((change->AddressType==AddressType) || (AddressType==TDI_ADDRESS_TYPE_UNSPEC))
                //
                // Special check for Netbios addresses because
                // we have separate protocols for each lana/device
                //
                && ((transportInfo==NULL)
                             || (transportInfo==endpoint->TransportInfo)) ) {
            AFD_LOCK_QUEUE_HANDLE lockHandle2;

            RemoveEntryList (&change->ChangeListLink);
            change->ChangeListLink.Flink = NULL;
            //
            // If request is already canceled, let cancel routine complete it
            //
            if (!change->NonBlocking && IoSetCancelRoutine (irp, NULL)==NULL) {
                continue;
            }

            AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle2);
            if (AfdIsRequestInQueue (requestCtx)) {
                //
                // Context is still in the list, just remove it so
                // no-one can see it anymore and complete
                //
                RemoveEntryList (&requestCtx->EndpointListLink);
                InsertTailList (&completedChangeList,
                                    &change->ChangeListLink);
                if (change->NonBlocking) {
                    AfdIndicateEventSelectEvent (change->Endpoint, 
                                        AFD_POLL_ADDRESS_LIST_CHANGE, 
                                        STATUS_SUCCESS);
                }
            }
            else if (!AfdIsRequestCompleted (requestCtx)) {
                //
                // During endpoint cleanup, this context was removed from the
                // list and cleanup routine is about to be called, don't
                // free this IRP until cleanup routine is called
                // Also, indicate to the cleanup routine that we are done
                // with this IRP and it can free it.
                //
                AfdMarkRequestCompleted (requestCtx);
            }

            AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle2);
        }
    }
    AfdReleaseSpinLock (&AfdAddressChangeLock, &lockHandle);

    //
    // Signal interested clients and complete IRPs as necessary
    //

    while (!IsListEmpty (&completedChangeList)) {
        listEntry = RemoveHeadList (&completedChangeList);
        change = CONTAINING_RECORD (listEntry, 
                                AFD_ADDRESS_CHANGE,
                                ChangeListLink);
        if (change->NonBlocking) {
            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdProcessAddressChangeList: Signalling address list change on endpoint %p .\n",
                            change->Endpoint));
            }
            AfdIndicatePollEvent (change->Endpoint, 
                                AFD_POLL_ADDRESS_LIST_CHANGE, 
                                STATUS_SUCCESS);
            AFD_FREE_POOL (CONTAINING_RECORD (change,
                                                AFD_NBCHANGE_CONTEXT,
                                                Change),
                            AFD_ADDRESS_CHANGE_POOL_TAG);
        }
        else {
            irp = change->Irp;
            irp->IoStatus.Status = STATUS_SUCCESS;
            irp->IoStatus.Information = 0;
            IF_DEBUG (ADDRESS_LIST) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdProcessAddressChangeList: Completing change IRP: %p  with status: 0 .\n",
                            irp));
            }
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
    }
}


BOOLEAN
AfdHasHeldPacketsFromNic (
    PAFD_CONNECTION Connection,
    PVOID           Pdo
    )
{
    PLIST_ENTRY le;
    //
    // Scan the list of buffers and check with TDI/NDIS
    // if packet belongs to a given card
    //
    if (!IsListEmpty( &Connection->VcReceiveBufferListHead ) ) {
        le = Connection->VcReceiveBufferListHead.Flink;
        while ( le!=&Connection->VcReceiveBufferListHead ) {
            PAFD_BUFFER afdBuffer;
            afdBuffer = CONTAINING_RECORD( le, AFD_BUFFER, BufferListEntry );
            if ((afdBuffer->BufferLength==AfdBufferTagSize) &&
                    TdiMatchPdoWithChainedReceiveContext (afdBuffer->Context, Pdo)) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                            "AFD: Aborting connection %p due to held packet %p at power down on nic %p\n",
                            Connection,
                            afdBuffer->Context,
                            Pdo));
                return TRUE;
            }
            le = le->Flink;
        }
    }
    return FALSE;
}

VOID
AfdReturnNicsPackets (
    PVOID   Pdo
    )
{
    KIRQL           oldIrql;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PLIST_ENTRY     listEntry, le;
    LIST_ENTRY      connList;

    //
    // Don't scan twice for the same PDO if this event
    // is less than 3 sec apart from previous.
    // Several transports bound to the same NIC may indicate
    // the set power event to us
    //
    if ((AfdLastRemovedPdo!=Pdo) || 
        ((KeQueryInterruptTime()-AfdLastRemoveTime)>30000000i64)) {

        //
        // Scan the list of endpoints and find packets
        // that belong to the NIC.
        //
        KeEnterCriticalRegion ();
        ExAcquireResourceExclusiveLite (AfdResource, TRUE);

        if (!IsListEmpty (&AfdEndpointListHead)) {
            KeRaiseIrql (DISPATCH_LEVEL, &oldIrql);

            listEntry = AfdEndpointListHead.Flink;
            while (listEntry!=&AfdEndpointListHead) {
                PAFD_CONNECTION connection;
                PAFD_ENDPOINT   endpoint = CONTAINING_RECORD (
                                                listEntry,
                                                AFD_ENDPOINT,
                                                GlobalEndpointListEntry);
                listEntry = listEntry->Flink;
                switch (endpoint->Type) {
                case AfdBlockTypeDatagram:
                    //
                    // Afd currently does not support buffer
                    // ownership on datagram sockets.
                    //
                    // If such support is added, we will need to
                    // add code here to return all the buffers
                    // owned by the netcards.
                    //
                    break;
            
                case AfdBlockTypeVcConnecting:
                    //
                    // Drop all of the connections that have unreturned packets.
                    //
                    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                    connection = endpoint->Common.VcConnecting.Connection;
                    if (endpoint->State==AfdEndpointStateConnected && 
                            !IS_TDI_BUFFERRING(endpoint) &&
                            connection!=NULL &&
                            AfdHasHeldPacketsFromNic (connection, Pdo)) {
                        REFERENCE_CONNECTION (connection);
                        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                        AfdBeginAbort (connection);
                        AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                        //
                        // Make sure we do not have any buffered data
                        // (could have just checked for netcard owned
                        // buffers, but connection is going down anyway
                        // - save memory).
                        //
                        connection->VcBufferredReceiveBytes = 0;
                        connection->VcBufferredReceiveCount = 0;
                        connection->VcBufferredExpeditedBytes = 0;
                        connection->VcBufferredExpeditedCount = 0;
                        connection->VcReceiveBytesInTransport = 0;
                        while ( !IsListEmpty( &connection->VcReceiveBufferListHead ) ) {
                            PAFD_BUFFER_HEADER afdBuffer;
                            le = RemoveHeadList( &connection->VcReceiveBufferListHead );
                            afdBuffer = CONTAINING_RECORD( le, AFD_BUFFER_HEADER, BufferListEntry );

                            DEBUG afdBuffer->BufferListEntry.Flink = NULL;
                            if (afdBuffer->RefCount==1 || // Can't change once off the list
                                    InterlockedDecrement (&afdBuffer->RefCount)==0) {
                                afdBuffer->ExpeditedData = FALSE;
                                AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                            }
                        }
                        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                        DEREFERENCE_CONNECTION (connection);
                    }
                    else {
                        AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                    }
                    break;
                case AfdBlockTypeVcBoth:
                case AfdBlockTypeVcListening:
                    if (IS_TDI_BUFFERRING (endpoint))
                        break;

                    //
                    // Drop all unaccepted and/or returned connections that have
                    // unreturned packets.
                    //
                    InitializeListHead (&connList);
                    AfdAcquireSpinLockAtDpcLevel (&endpoint->SpinLock, &lockHandle);
                    le = endpoint->Common.VcListening.UnacceptedConnectionListHead.Flink;
                    while ( le!=&endpoint->Common.VcListening.UnacceptedConnectionListHead ) {
                        connection = CONTAINING_RECORD (le, AFD_CONNECTION, ListEntry);
                        ASSERT( connection->Endpoint == endpoint );
                        le = le->Flink;
                        if (AfdHasHeldPacketsFromNic (connection, Pdo)) {
                            RemoveEntryList (&connection->ListEntry);
                            InsertTailList (&connList, &connection->ListEntry);
                            InterlockedIncrement (&endpoint->Common.VcListening.FailedConnectionAdds);
                        }
                    }

                    le = endpoint->Common.VcListening.ReturnedConnectionListHead.Flink;
                    while ( le!=&endpoint->Common.VcListening.ReturnedConnectionListHead ) {
                        connection = CONTAINING_RECORD (le, AFD_CONNECTION, ListEntry);
                        ASSERT( connection->Endpoint == endpoint );
                        le = le->Flink;
                        if (AfdHasHeldPacketsFromNic (connection, Pdo)) {
                            RemoveEntryList (&connection->ListEntry);
                            InsertTailList (&connList, &connection->ListEntry);
                            InterlockedIncrement (&endpoint->Common.VcListening.FailedConnectionAdds);
                        }
                    }
                    AfdReleaseSpinLockFromDpcLevel (&endpoint->SpinLock, &lockHandle);
                    while (!IsListEmpty (&connList)) {
                        le = RemoveHeadList (&connList);
                        connection = CONTAINING_RECORD (le, AFD_CONNECTION, ListEntry);
                        AfdAbortConnection( connection );
                    }

                    if ( endpoint->Common.VcListening.FailedConnectionAdds > 0 ) {
                        AfdInitiateListenBacklogReplenish( endpoint );
                    }

                    break;
                }
            }
            KeLowerIrql (oldIrql);
        }

        ExReleaseResourceLite (AfdResource);
        KeLeaveCriticalRegion ();
    }
    AfdLastRemovedPdo = Pdo;
    AfdLastRemoveTime = KeQueryInterruptTime ();
}


NTSTATUS
AfdPnPPowerChange(
    IN PUNICODE_STRING DeviceName,
    IN PNET_PNP_EVENT PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
    )
{
    PAGED_CODE ();
    switch (PowerEvent->NetEvent) {
    case NetEventSetPower: {
        NET_DEVICE_POWER_STATE powerState = 
                *((PNET_DEVICE_POWER_STATE)PowerEvent->Buffer);
        ASSERT (PowerEvent->BufferLength>=sizeof (NET_DEVICE_POWER_STATE));

        switch (powerState) {
        case NetDeviceStateD0:
            //
            // Clear the cached last removed PDO when we get Power UP notification
            // since PDO can now be reused for something else.
            //
            AfdLastRemovedPdo = NULL;
            goto DoNothing;
        default:
            ASSERTMSG ("NIC enters unknown power state", FALSE);
        case NetDeviceStateD1:
        case NetDeviceStateD2:
        case NetDeviceStateD3:
        case NetDeviceStateUnspecified:
            //
            // Break to execute PDO matching code
            //
            break;
        }
        break;
    }
    case NetEventQueryRemoveDevice:
        //
        // Break to execute PDO matching code
        //
        break;
    case NetEventCancelRemoveDevice:
        //
        // Clear the cached last removed PDO when we get Power UP notification
        // since PDO can now be removed again.
        //
        AfdLastRemovedPdo = NULL;
        goto DoNothing;
    default:
        goto DoNothing;
    }

    //
    // When power is removed or device is disabled, we need to release all
    // packets that we may own.
    // We can only do this for transports that give us
    // PDO, so NDIS can match the packet to the device.
    // Note that PDO is usually the second context argument (first one is
    // usually the device name), but we check the first one too since
    // the TDI spec isn't crystal clear on this (it just says: for example TCP
    // usually <does the above>).
    //
    if ((Context2!=NULL) &&
            (Context2->ContextType==TDI_PNP_CONTEXT_TYPE_PDO) &&
            (Context2->ContextSize==sizeof (PVOID)) ){
        AfdReturnNicsPackets (*((PVOID UNALIGNED *)&Context2->ContextData));
    }
    else if ((Context1!=NULL) &&
            (Context1->ContextType==TDI_PNP_CONTEXT_TYPE_PDO) &&
            (Context1->ContextSize==sizeof (PVOID)) ) {
        AfdReturnNicsPackets (*((PVOID UNALIGNED *)&Context1->ContextData));
    }

DoNothing:

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\recvdg.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    recvdg.c

Abstract:

    This module contains routines for handling data receive for datagram
    endpoints.

Author:

    David Treadwell (davidtr)    7-Oct-1993

Revision History:

--*/

#include "afdp.h"

NTSTATUS
AfdRestartReceiveDatagramWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
AfdRestartBufferReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdReceiveDatagram )
#pragma alloc_text( PAGEAFD, AfdReceiveDatagramEventHandler )
#pragma alloc_text( PAGEAFD, AfdSetupReceiveDatagramIrp )
#pragma alloc_text( PAGEAFD, AfdRestartBufferReceiveDatagram )
#pragma alloc_text( PAGEAFD, AfdRestartReceiveDatagramWithUserIrp )
#pragma alloc_text( PAGEAFD, AfdCancelReceiveDatagram )
#pragma alloc_text( PAGEAFD, AfdCleanupReceiveDatagramIrp )
#endif

//
// Macros to make the receive datagram code more maintainable.
//

#define AfdRecvDatagramInfo         Others

#define AfdRecvAddressMdl           Argument1
#define AfdRecvAddressLenMdl        Argument2
#define AfdRecvControlLenMdl        Argument3
#define AfdRecvFlagsMdl             Argument4
#define AfdRecvMsgControlMdl        Tail.Overlay.DriverContext[0]
#define AfdRecvLength               Tail.Overlay.DriverContext[1]
#define AfdRecvDgIndStatus          DeviceIoControl.OutputBufferLength


NTSTATUS
FASTCALL
AfdReceiveDatagram (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PLIST_ENTRY listEntry;
    BOOLEAN peek;
    PAFD_BUFFER_HEADER afdBuffer;
    ULONG recvFlags;
    ULONG afdFlags;
    ULONG recvLength;
    PVOID addressPointer;
    PMDL addressMdl;
    PULONG addressLengthPointer;
    ULONG addressLength;
    PMDL lengthMdl;
    PVOID controlPointer;
    PMDL controlMdl;
    ULONG controlLength;
    PULONG controlLengthPointer;
    PMDL controlLengthMdl;
    PULONG flagsPointer;
    PMDL flagsMdl;
    ULONG   bufferCount;

    //
    // Set up some local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );


    Irp->IoStatus.Information = 0;

    addressMdl = NULL;
    lengthMdl = NULL;
    controlMdl = NULL;
    flagsMdl = NULL;
    controlLengthMdl = NULL;

    if (!IS_DGRAM_ENDPOINT(endpoint)) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }
    //
    // If receive has been shut down or the endpoint aborted, fail.
    //
    // !!! Do we care if datagram endpoints get aborted?
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) ) {
        status = STATUS_PIPE_DISCONNECTED;
        goto complete;
    }


    //
    // Make sure that the endpoint is in the correct state.
    //

    if ( endpoint->State != AfdEndpointStateBound &&
         endpoint->State != AfdEndpointStateConnected) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    //
    // Do some special processing based on whether this is a receive
    // datagram IRP, a receive IRP, or a read IRP.
    //

    if ( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL ) {
        if ( IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                                    IOCTL_AFD_RECEIVE_MESSAGE) {
#ifdef _WIN64
            if (IoIs32bitProcess (Irp)) {
                PAFD_RECV_MESSAGE_INFO32 msgInfo32;
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                        sizeof(*msgInfo32) ) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }
                try {
                    msgInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForRead(
                            msgInfo32,
                            sizeof(*msgInfo32),
                            PROBE_ALIGNMENT32 (AFD_RECV_MESSAGE_INFO32)
                            );
                    }

                    controlPointer = msgInfo32->ControlBuffer;
                    controlLengthPointer = msgInfo32->ControlLength;
                    flagsPointer = msgInfo32->MsgFlags;

                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                    goto complete;
                }
            }
            else 
#endif _WIN64
            {
                PAFD_RECV_MESSAGE_INFO msgInfo;
                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                        sizeof(*msgInfo) ) {
                    status = STATUS_INVALID_PARAMETER;
                    goto complete;
                }
                try {
                    msgInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {

                        ProbeForRead(
                            msgInfo,
                            sizeof(*msgInfo),
                            PROBE_ALIGNMENT (AFD_RECV_MESSAGE_INFO)
                            );

                    }
                    controlPointer = msgInfo->ControlBuffer;
                    controlLengthPointer = msgInfo->ControlLength;
                    flagsPointer = msgInfo->MsgFlags;
                }
                except (AFD_EXCEPTION_FILTER (&status)) {
                    goto complete;
                }
            }

            try {
                //
                // Create a MDL describing the length buffer, then probe it
                // for write access.
                //

                flagsMdl = IoAllocateMdl(
                                 flagsPointer,              // VirtualAddress
                                 sizeof(*flagsPointer),     // Length
                                 FALSE,                     // SecondaryBuffer
                                 TRUE,                      // ChargeQuota
                                 NULL                       // Irp
                                 );

                if( flagsMdl == NULL ) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;

                }

                MmProbeAndLockPages(
                    flagsMdl,                               // MemoryDescriptorList
                    Irp->RequestorMode,                     // AccessMode
                    IoWriteAccess                           // Operation
                    );


                controlLengthMdl = IoAllocateMdl(
                                 controlLengthPointer,      // VirtualAddress
                                 sizeof(*controlLengthPointer),// Length
                                 FALSE,                     // SecondaryBuffer
                                 TRUE,                      // ChargeQuota
                                 NULL                       // Irp
                                 );

                if( controlLengthMdl == NULL ) {

                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto complete;

                }

                MmProbeAndLockPages(
                    controlLengthMdl,                       // MemoryDescriptorList
                    Irp->RequestorMode,                     // AccessMode
                    IoWriteAccess                           // Operation
                    );


                controlLength = *controlLengthPointer;
                if (controlLength!=0) {
                    //
                    // Create a MDL describing the control buffer, then probe
                    // it for write access.
                    //

                    controlMdl = IoAllocateMdl(
                                     controlPointer,            // VirtualAddress
                                     controlLength,             // Length
                                     FALSE,                     // SecondaryBuffer
                                     TRUE,                      // ChargeQuota
                                     NULL                       // Irp
                                     );

                    if( controlMdl == NULL ) {

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto complete;

                    }

                    MmProbeAndLockPages(
                        controlMdl,                             // MemoryDescriptorList
                        Irp->RequestorMode,                     // AccessMode
                        IoWriteAccess                           // Operation
                        );
                }

            } except( AFD_EXCEPTION_FILTER(&status) ) {

                goto complete;

            }
            //
            // Change the control code to continue processing of the regular
            // RecvFrom parameters.
            //
            IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_AFD_RECEIVE_DATAGRAM;
        }

        if ( IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                                    IOCTL_AFD_RECEIVE_DATAGRAM) {
#ifdef _WIN64
            if (IoIs32bitProcess (Irp)) {
                PAFD_RECV_DATAGRAM_INFO32 recvInfo32;
                LPWSABUF32 bufferArray32;

                //
                // Grab the parameters from the input structure.
                //

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                        sizeof(*recvInfo32) ) {

                    try {

                        //
                        // Validate the input structure if it comes from the user mode 
                        // application
                        //

                        recvInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        if( Irp->RequestorMode != KernelMode ) {

                            ProbeForRead(
                                recvInfo32,
                                sizeof(*recvInfo32),
                                PROBE_ALIGNMENT32(AFD_RECV_DATAGRAM_INFO32)
                                );

                        }

                        //
                        // Make local copies of the embeded pointer and parameters
                        // that we will be using more than once in case malicios
                        // application attempts to change them while we are
                        // validating
                        //

                        recvFlags = recvInfo32->TdiFlags;
                        afdFlags = recvInfo32->AfdFlags;
                        bufferArray32 = recvInfo32->BufferArray;
                        bufferCount = recvInfo32->BufferCount;
                        addressPointer = recvInfo32->Address;
                        addressLengthPointer = recvInfo32->AddressLength;


                        //
                        // Validate the WSABUF parameters.
                        //

                        if ( bufferArray32 != NULL &&
                            bufferCount > 0 ) {

                            //
                            // Create the MDL chain describing the WSABUF array.
                            // This will also validate the buffer array and individual
                            // buffers
                            //

                            status = AfdAllocateMdlChain32(
                                         Irp,       // Requestor mode passed along
                                         bufferArray32,
                                         bufferCount,
                                         IoWriteAccess,
                                         &recvLength
                                         );

                        } else {

                            //
                            // Zero-length input buffer. This is OK for datagrams.
                            //

                            ASSERT( Irp->MdlAddress == NULL );
                            status = STATUS_SUCCESS;
                            recvLength = 0;

                        }

                    } except ( AFD_EXCEPTION_FILTER(&status) ) {

                        //
                        // Exception accessing input structure.
                        //


                    }

                } else {

                    //
                    // Invalid input buffer length.
                    //

                    status = STATUS_INVALID_PARAMETER;

                }
            }
            else
#endif _WIN64
            {
                PAFD_RECV_DATAGRAM_INFO recvInfo;
                LPWSABUF bufferArray;

                //
                // Grab the parameters from the input structure.
                //

                if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                        sizeof(*recvInfo) ) {

                    try {

                        //
                        // Validate the input structure if it comes from the user mode 
                        // application
                        //

                        recvInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        if( Irp->RequestorMode != KernelMode ) {

                            ProbeForRead(
                                recvInfo,
                                sizeof(*recvInfo),
                                PROBE_ALIGNMENT(AFD_RECV_DATAGRAM_INFO)
                                );

                        }

                        //
                        // Make local copies of the embeded pointer and parameters
                        // that we will be using more than once in case malicios
                        // application attempts to change them while we are
                        // validating
                        //

                        recvFlags = recvInfo->TdiFlags;
                        afdFlags = recvInfo->AfdFlags;
                        bufferArray = recvInfo->BufferArray;
                        bufferCount = recvInfo->BufferCount;
                        addressPointer = recvInfo->Address;
                        addressLengthPointer = recvInfo->AddressLength;


                        //
                        // Validate the WSABUF parameters.
                        //

                        if ( bufferArray != NULL &&
                            bufferCount > 0 ) {

                            //
                            // Create the MDL chain describing the WSABUF array.
                            // This will also validate the buffer array and individual
                            // buffers
                            //

                            status = AfdAllocateMdlChain(
                                         Irp,       // Requestor mode passed along
                                         bufferArray,
                                         bufferCount,
                                         IoWriteAccess,
                                         &recvLength
                                         );

                        } else {

                            //
                            // Zero-length input buffer. This is OK for datagrams.
                            //

                            ASSERT( Irp->MdlAddress == NULL );
                            recvLength = 0;
                            status = STATUS_SUCCESS;

                        }

                    } except ( AFD_EXCEPTION_FILTER(&status) ) {

                        //
                        // Exception accessing input structure.
                        //


                    }

                } else {

                    //
                    // Invalid input buffer length.
                    //

                    status = STATUS_INVALID_PARAMETER;

                }
            }


            if( !NT_SUCCESS(status) ) {

                goto complete;

            }

            //
            // Validate the receive flags.
            //

            if( ( recvFlags & TDI_RECEIVE_EITHER ) != TDI_RECEIVE_NORMAL ) {
                status = STATUS_NOT_SUPPORTED;
                goto complete;
            }

            peek = (BOOLEAN)( (recvFlags & TDI_RECEIVE_PEEK) != 0 );
            //
            // If only one of addressPointer or addressLength are NULL, then
            // fail the request.
            //

            if( (addressPointer == NULL) ^ (addressLengthPointer == NULL) ) {

                status = STATUS_INVALID_PARAMETER;
                goto complete;

            }
            //
            // If the user wants the source address from the receive datagram,
            // then create MDLs for the address & address length, then probe
            // and lock the MDLs.
            //

            if( addressPointer != NULL ) {

                ASSERT( addressLengthPointer != NULL );

                try {

                    //
                    // Create a MDL describing the length buffer, then probe it
                    // for write access.
                    //

                    lengthMdl = IoAllocateMdl(
                                     addressLengthPointer,      // VirtualAddress
                                     sizeof(*addressLengthPointer),// Length
                                     FALSE,                     // SecondaryBuffer
                                     TRUE,                      // ChargeQuota
                                     NULL                       // Irp
                                     );

                    if( lengthMdl == NULL ) {

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto complete;

                    }

                    MmProbeAndLockPages(
                        lengthMdl,                              // MemoryDescriptorList
                        Irp->RequestorMode,                     // AccessMode
                        IoWriteAccess                           // Operation
                        );

                    //
                    // Save length to a local so that malicious app
                    // cannot break us by modifying the value in the middle of
                    // us processing it below here. Also, we can use this pointer now
                    // since we probed it above.
                    //
                    addressLength = *addressLengthPointer;


                    //
                    // Bomb off if the user is trying to do something bad, like
                    // specify a zero-length address, or one that's unreasonably
                    // huge. Here, we define "unreasonably huge" as MAXUSHORT
                    // or greater because TDI address length field is USHORT.
                    //

                    if( addressLength == 0 ||
                        addressLength >= MAXUSHORT ) {

                        status = STATUS_INVALID_PARAMETER;
                        goto complete;

                    }

                    //
                    // Create a MDL describing the address buffer, then probe
                    // it for write access.
                    //

                    addressMdl = IoAllocateMdl(
                                     addressPointer,            // VirtualAddress
                                     addressLength,             // Length
                                     FALSE,                     // SecondaryBuffer
                                     TRUE,                      // ChargeQuota
                                     NULL                       // Irp
                                     );

                    if( addressMdl == NULL ) {

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        goto complete;

                    }

                    MmProbeAndLockPages(
                        addressMdl,                             // MemoryDescriptorList
                        Irp->RequestorMode,                     // AccessMode
                        IoWriteAccess                           // Operation
                        );

                } except( AFD_EXCEPTION_FILTER(&status) ) {

                    goto complete;

                }

                ASSERT( addressMdl != NULL );
                ASSERT( lengthMdl != NULL );

            } else {

                ASSERT( addressMdl == NULL );
                ASSERT( lengthMdl == NULL );

            }


        } else {

            ASSERT( (Irp->Flags & IRP_INPUT_OPERATION) == 0 );


            //
            // Grab the input parameters from the IRP.
            //

            ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode ==
                        IOCTL_AFD_RECEIVE );

            recvFlags = ((PAFD_RECV_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->TdiFlags;
            afdFlags = ((PAFD_RECV_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer)->AfdFlags;
            recvLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

            //
            // It is illegal to attempt to receive expedited data on a
            // datagram endpoint.
            //

            if ( (recvFlags & TDI_RECEIVE_EXPEDITED) != 0 ) {
                status = STATUS_NOT_SUPPORTED;
                goto complete;
            }

            ASSERT( ( recvFlags & TDI_RECEIVE_EITHER ) == TDI_RECEIVE_NORMAL );

            peek = (BOOLEAN)( (recvFlags & TDI_RECEIVE_PEEK) != 0 );

        }
    } else {

        //
        // This must be a read IRP.  There are no special options
        // for a read IRP.
        //

        ASSERT( IrpSp->MajorFunction == IRP_MJ_READ );

        recvFlags = TDI_RECEIVE_NORMAL;
        afdFlags = AFD_OVERLAPPED;
        recvLength = IrpSp->Parameters.Read.Length;
        peek = FALSE;
    }

    //
    // Save the address & length MDLs in the current IRP stack location.
    // These will be used later in SetupReceiveDatagramIrp().  Note that
    // they should either both be NULL or both be non-NULL.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    ASSERT( !( ( addressMdl == NULL ) ^ ( lengthMdl == NULL ) ) );

    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl = addressMdl;
    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl = lengthMdl;
    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl = controlLengthMdl;
    IrpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl = flagsMdl;
    Irp->AfdRecvMsgControlMdl = controlMdl;
    Irp->AfdRecvLength = UlongToPtr (recvLength);


    //
    // Determine whether there are any datagrams already bufferred on
    // this endpoint.  If there is a bufferred datagram, we'll use it to
    // complete the IRP.
    //
    if ( ARE_DATAGRAMS_ON_ENDPOINT(endpoint) ) {


        //
        // There is at least one datagram bufferred on the endpoint.
        // Use it for this receive.
        //

        ASSERT( !IsListEmpty( &endpoint->ReceiveDatagramBufferListHead ) );

        listEntry = endpoint->ReceiveDatagramBufferListHead.Flink;
        afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

        //
        // Prepare the user's IRP for completion.
        //

        if (NT_SUCCESS(afdBuffer->Status)) {
            PAFD_BUFFER buf = CONTAINING_RECORD (afdBuffer, AFD_BUFFER, Header);
            ASSERT (afdBuffer->BufferLength!=AfdBufferTagSize);
            status = AfdSetupReceiveDatagramIrp (
                         Irp,
                         buf->Buffer,
                         buf->DataLength,
                         (PUCHAR)buf->Buffer+afdBuffer->DataLength,
                         buf->DataOffset,
                         buf->TdiInfo.RemoteAddress,
                         buf->TdiInfo.RemoteAddressLength,
                         buf->DatagramFlags
                         );
        }
        else {
            //
            // This is error report from the transport
            // (ICMP_PORT_UNREACHEABLE)
            //
            Irp->IoStatus.Status = afdBuffer->Status;
            ASSERT (afdBuffer->DataLength==0);
            Irp->IoStatus.Information = 0;
            status = AfdSetupReceiveDatagramIrp (
                         Irp,
                         NULL, 0,
                         NULL, 0,
                         afdBuffer->TdiInfo.RemoteAddress,
                         afdBuffer->TdiInfo.RemoteAddressLength,
                         0
                         );
        }

        //
        // If this wasn't a peek IRP, remove the buffer from the endpoint's
        // list of bufferred datagrams.
        //

        if ( !peek ) {

            RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );

            //
            // Update the counts of bytes and datagrams on the endpoint.
            //

            endpoint->DgBufferredReceiveCount--;
            endpoint->DgBufferredReceiveBytes -= afdBuffer->DataLength;
            endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

            IF_DEBUG(EVENT_SELECT) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReceiveDatagram: Endp %p, Active %lx\n",
                    endpoint,
                    endpoint->EventsActive
                    ));
            }

            if( ARE_DATAGRAMS_ON_ENDPOINT(endpoint)) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );

            }
            else {
                //
                // Disable fast IO path to avoid performance penalty
                // of unneccessarily going through it.
                //
                if (!endpoint->NonBlocking)
                    endpoint->DisableFastIoRecv = TRUE;
            }
        }

        //
        // We've set up all return information.  Clean up and complete
        // the IRP.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        if ( !peek ) {
            AfdReturnBuffer( afdBuffer, endpoint->OwningProcess );
        }

        UPDATE_ENDPOINT2 (endpoint,
            "AfdReceiveDatagram, completing with error/bytes: 0x%lX",
                NT_SUCCESS (Irp->IoStatus.Status)
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status);

        IoCompleteRequest( Irp, 0 );

        return status;
    }

    //
    // There were no datagrams bufferred on the endpoint.  If this is a
    // nonblocking endpoint and the request was a normal receive (as
    // opposed to a read IRP), fail the request.  We don't fail reads
    // under the asumption that if the application is doing reads they
    // don't want nonblocking behavior.
    //

    if ( endpoint->NonBlocking && !ARE_DATAGRAMS_ON_ENDPOINT( endpoint ) &&
             !( afdFlags & AFD_OVERLAPPED ) ) {

        endpoint->EventsActive &= ~AFD_POLL_RECEIVE;

        IF_DEBUG(EVENT_SELECT) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdReceiveDatagram: Endp %p, Active %lx\n",
                endpoint,
                endpoint->EventsActive
                ));
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        status = STATUS_DEVICE_NOT_READY;
        goto complete;
    }

    //
    // We'll have to pend the IRP.  Place the IRP on the appropriate IRP
    // list in the endpoint.
    //

    if ( peek ) {
        InsertTailList(
            &endpoint->PeekDatagramIrpListHead,
            &Irp->Tail.Overlay.ListEntry
            );
    } else {
        InsertTailList(
            &endpoint->ReceiveDatagramIrpListHead,
            &Irp->Tail.Overlay.ListEntry
            );
    }

    //
    // Set up the cancellation routine in the IRP.  If the IRP has already
    // been cancelled, just call the cancellation routine here.
    //

    IoSetCancelRoutine( Irp, AfdCancelReceiveDatagram );

    if ( Irp->Cancel ) {

        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
        if (IoSetCancelRoutine( Irp, NULL ) != NULL) {
    
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        
            status = STATUS_CANCELLED;
            goto complete;
        }
        //
        // The cancel routine will run and complete the irp.
        // Set Flink to NULL so it knows that IRP is not on the list.
        //
        Irp->Tail.Overlay.ListEntry.Flink = NULL;
    
    }

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    return STATUS_PENDING;

complete:

    ASSERT( !NT_SUCCESS(status) );

    if( addressMdl != NULL ) {
        if( (addressMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( addressMdl );
        }
        IoFreeMdl( addressMdl );
    }

    if( lengthMdl != NULL ) {
        if( (lengthMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( lengthMdl );
        }
        IoFreeMdl( lengthMdl );
    }

    if (controlMdl != NULL) {
        if( (controlMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( controlMdl );
        }
        IoFreeMdl( controlMdl );
    }

    if (controlLengthMdl != NULL) {
        if( (controlLengthMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( controlLengthMdl );
        }
        IoFreeMdl( controlLengthMdl );
    }

    if (flagsMdl != NULL) {
        if( (flagsMdl->MdlFlags & MDL_PAGES_LOCKED) != 0 ) {
            MmUnlockPages( flagsMdl );
        }
        IoFreeMdl( flagsMdl );
    }

    UPDATE_ENDPOINT2 (endpoint,
        "AfdReceiveDatagram, completing with error 0x%lX",
         (ULONG)Irp->IoStatus.Status);

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, 0 );

    return status;

} // AfdReceiveDatagram



NTSTATUS
AfdReceiveDatagramEventHandler (
    IN PVOID TdiEventContext,
    IN int SourceAddressLength,
    IN PVOID SourceAddress,
    IN int OptionsLength,
    IN PVOID Options,
    IN ULONG ReceiveDatagramFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    Handles receive datagram events for nonbufferring transports.

Arguments:


Return Value:


--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_BUFFER afdBuffer;
    BOOLEAN result;

    //
    // Reference the endpoint so that it doesn't go away beneath us.
    //

    endpoint = TdiEventContext;
    ASSERT( endpoint != NULL );

    CHECK_REFERENCE_ENDPOINT (endpoint, result);
    if (!result)
        return STATUS_INSUFFICIENT_RESOURCES;
    
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

#if AFD_PERF_DBG
    if ( BytesAvailable == BytesIndicated ) {
        AfdFullReceiveDatagramIndications++;
    } else {
        AfdPartialReceiveDatagramIndications++;
    }
#endif

    //
    // If this endpoint is connected and the datagram is for a different
    // address than the one the endpoint is connected to, drop the
    // datagram.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if ( (endpoint->State == AfdEndpointStateConnected &&
            !endpoint->Common.Datagram.HalfConnect &&
            !AfdAreTransportAddressesEqual(
               endpoint->Common.Datagram.RemoteAddress,
               endpoint->Common.Datagram.RemoteAddressLength,
               SourceAddress,
               SourceAddressLength,
               TRUE ))) {
        endpoint->Common.Datagram.AddressDrop = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        *BytesTaken = BytesAvailable;
        DEREFERENCE_ENDPOINT (endpoint);
        return STATUS_SUCCESS;
    }

    //
    // Check whether there are any IRPs waiting on the endpoint.  If
    // there is such an IRP, use it to receive the datagram.
    //

    while ( !IsListEmpty( &endpoint->ReceiveDatagramIrpListHead ) ) {
        PLIST_ENTRY listEntry;
        PIRP    irp;

        ASSERT( *BytesTaken == 0 );
        ASSERT( endpoint->DgBufferredReceiveCount == 0 );
        ASSERT( endpoint->DgBufferredReceiveBytes == 0 );

        listEntry = RemoveHeadList( &endpoint->ReceiveDatagramIrpListHead );

        //
        // Get a pointer to the IRP and reset the cancel routine in
        // the IRP.  The IRP is no longer cancellable.
        //

        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        
        if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            irp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Copy the datagram and source address to the IRP.  This
        // prepares the IRP to be completed.
        //
        // !!! do we need a special version of this routine to
        //     handle special RtlCopyMemory, like for
        //     TdiCopyLookaheadBuffer?
        //

        if( BytesIndicated == BytesAvailable ||
            irp->MdlAddress == NULL ) {

            //
            // Set BytesTaken to indicate that we've taken all the
            // data.  We do it here because we already have
            // BytesAvailable in a register, which probably won't
            // be true after making function calls.
            //

            *BytesTaken = BytesAvailable;

            //
            // If the entire datagram is being indicated to us here, just
            // copy the information to the MDL in the IRP and return.
            //
            // Note that we'll also take the entire datagram if the user
            // has pended a zero-byte datagram receive (detectable as a
            // NULL Irp->MdlAddress). We'll eat the datagram and fall
            // through to AfdSetupReceiveDatagramIrp(), which will store
            // an error status in the IRP since the user's buffer is
            // insufficient to hold the datagram.
            //
            (VOID)AfdSetupReceiveDatagramIrp (
                      irp,
                      Tsdu,
                      BytesAvailable,
                      Options,
                      OptionsLength,
                      SourceAddress,
                      SourceAddressLength,
                      ReceiveDatagramFlags
                      );

            DEREFERENCE_ENDPOINT2 (endpoint,
                "AfdReceiveDatagramEventHandler, completing with error/bytes: 0x%lX",
                    NT_SUCCESS (irp->IoStatus.Status)
                        ? (ULONG)irp->IoStatus.Information
                        : (ULONG)irp->IoStatus.Status);
            //
            // Complete the IRP.  We've already set BytesTaken
            // to tell the provider that we have taken all the data.
            //

            IoCompleteRequest( irp, AfdPriorityBoost );

            return STATUS_SUCCESS;
        }
        else {
            PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (irp);
            //
            // Otherwise, just copy the address and options.
            // and remember the error code if any.
            //
            irpSp->Parameters.AfdRecvDgIndStatus = 
                AfdSetupReceiveDatagramIrp (
                      irp,
                      NULL,
                      BytesAvailable,
                      Options,
                      OptionsLength,
                      SourceAddress,
                      SourceAddressLength,
                      ReceiveDatagramFlags
                      );

            TdiBuildReceiveDatagram(
                irp,
                endpoint->AddressDeviceObject,
                endpoint->AddressFileObject,
                AfdRestartReceiveDatagramWithUserIrp,
                endpoint,
                irp->MdlAddress,
                BytesAvailable,
                NULL,
                NULL,
                0
                );


            //
            // Make the next stack location current.  Normally IoCallDriver would
            // do this, but since we're bypassing that, we do it directly.
            //

            IoSetNextIrpStackLocation( irp );

            *IoRequestPacket = irp;
            *BytesTaken = 0;

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    } 

    //
    // There were no IRPs available to take the datagram, so we'll have
    // to buffer it.  First make sure that we're not over the limit
    // of bufferring that we can do.  If we're over the limit, toss
    // this datagram.
    //

    if (( (endpoint->DgBufferredReceiveBytes >=
             endpoint->Common.Datagram.MaxBufferredReceiveBytes) ||
          (endpoint->DgBufferredReceiveBytes==0 &&                        
                (endpoint->DgBufferredReceiveCount*sizeof (AFD_BUFFER_TAG)) >=
                            endpoint->Common.Datagram.MaxBufferredReceiveBytes) )
                            ) {

        //
        // If circular queueing is not enabled, then just drop the
        // datagram on the floor.
        //


        if( !endpoint->Common.Datagram.CircularQueueing ) {
            endpoint->Common.Datagram.BufferDrop = TRUE;
            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            *BytesTaken = BytesAvailable;
            DEREFERENCE_ENDPOINT (endpoint);
            return STATUS_SUCCESS;

        }

        //
        // Circular queueing is enabled, so drop packets at the head of
        // the receive queue until we're below the receive limit.
        //

        while( endpoint->DgBufferredReceiveBytes >=
             endpoint->Common.Datagram.MaxBufferredReceiveBytes ||
            (endpoint->DgBufferredReceiveBytes==0 &&                        
                (endpoint->DgBufferredReceiveCount*sizeof (AFD_BUFFER_TAG)) >=
                            endpoint->Common.Datagram.MaxBufferredReceiveBytes) ) {
            PLIST_ENTRY listEntry;
            PAFD_BUFFER_HEADER afdBufferHdr;
            endpoint->DgBufferredReceiveCount--;
            listEntry = RemoveHeadList( &endpoint->ReceiveDatagramBufferListHead );

            afdBufferHdr = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
            endpoint->DgBufferredReceiveBytes -= afdBufferHdr->DataLength;
            AfdReturnBuffer( afdBufferHdr, endpoint->OwningProcess );

        }

        //
        // Proceed to accept the incoming packet.
        //

    }

    //
    // We're able to buffer the datagram.  Now acquire a buffer of
    // appropriate size.
    //

    afdBuffer = AfdGetBuffer (
                    BytesAvailable
                    + ((ReceiveDatagramFlags & TDI_RECEIVE_CONTROL_INFO) 
                        ? OptionsLength 
                        : 0),
                    SourceAddressLength,
                    endpoint->OwningProcess );

    if (afdBuffer==NULL) {
        endpoint->Common.Datagram.ResourceDrop = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        *BytesTaken = BytesAvailable;
        DEREFERENCE_ENDPOINT (endpoint);
        return STATUS_SUCCESS;
    }

    //
    // Store the address of the sender of the datagram.
    //

    RtlCopyMemory(
        afdBuffer->TdiInfo.RemoteAddress,
        SourceAddress,
        SourceAddressLength
        );

    afdBuffer->TdiInfo.RemoteAddressLength = SourceAddressLength;


    //
    // Store what transport is supposed to return to us.
    //
    afdBuffer->DataLength = BytesAvailable;

    //
    // Note the receive flags.
    afdBuffer->DatagramFlags = ReceiveDatagramFlags;

    //
    // Copy control info into the buffer after the data and
    // store the length as data offset
    //
    if (ReceiveDatagramFlags & TDI_RECEIVE_CONTROL_INFO) {
        RtlMoveMemory (
                (PUCHAR)afdBuffer->Buffer+BytesAvailable, 
                Options,
                OptionsLength);
        afdBuffer->DataOffset = OptionsLength;
    }
    else {
        afdBuffer->DataOffset = 0;
    }

    //
    // If the entire datagram is being indicated to us, just copy it
    // here.
    //

    if ( BytesIndicated == BytesAvailable ) {
        PIRP    irp;
        //
        // If there is a peek IRP on the endpoint, remove it from the
        // list and prepare to complete it.  We can't complete it now
        // because we hold a spin lock.
        //

        irp = NULL;

        while ( !IsListEmpty( &endpoint->PeekDatagramIrpListHead ) ) {
            PLIST_ENTRY listEntry;

            //
            // Remove the first peek IRP from the list and get a pointer
            // to it.
            //

            listEntry = RemoveHeadList( &endpoint->PeekDatagramIrpListHead );
            irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

            //
            // Reset the cancel routine in the IRP.  The IRP is no
            // longer cancellable, since we're about to complete it.
            //

            if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

                //
                // This IRP is about to be canceled.  Look for another in the
                // list.  Set the Flink to NULL so the cancel routine knows
                // it is not on the list.
                //
    
                irp->Tail.Overlay.ListEntry.Flink = NULL;
                irp = NULL;
                continue;
            }

            break;
        }

        //
        // Use the special function to copy the data instead of
        // RtlCopyMemory in case the data is coming from a special place
        // (DMA, etc.) which cannot work with RtlCopyMemory.
        //


        TdiCopyLookaheadData(
            afdBuffer->Buffer,
            Tsdu,
            BytesAvailable,
            ReceiveDatagramFlags
            );


        //
        // Store the results in the IRP as though it is completed
        // by the transport.
        //

        afdBuffer->Irp->IoStatus.Status = STATUS_SUCCESS;
        afdBuffer->Irp->IoStatus.Information = BytesAvailable;


        //
        // Store success status do distinguish this from
        // ICMP rejects reported by ErrorEventHandler(Ex).
        //

        afdBuffer->Status = STATUS_SUCCESS;


        //
        // Place the buffer on this endpoint's list of bufferred datagrams
        // and update the counts of datagrams and datagram bytes on the
        // endpoint.
        //

        InsertTailList(
            &endpoint->ReceiveDatagramBufferListHead,
            &afdBuffer->BufferListEntry
            );

        endpoint->DgBufferredReceiveCount++;
        endpoint->DgBufferredReceiveBytes += BytesAvailable;

        //
        // Reenable FAST IO on the endpoint to allow quick
        // copying of buffered data.
        //
        endpoint->DisableFastIoRecv = FALSE;

        //
        // All done.  Release the lock and tell the provider that we
        // took all the data.
        //

        AfdIndicateEventSelectEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Indicate that it is possible to receive on the endpoint now.
        //

        AfdIndicatePollEvent(
            endpoint,
            AFD_POLL_RECEIVE,
            STATUS_SUCCESS
            );

        //
        // If there was a peek IRP on the endpoint, complete it now.
        //

        if ( irp != NULL ) {
            //
            // Copy the datagram and source address to the IRP.  This
            // prepares the IRP to be completed.
            //

            (VOID)AfdSetupReceiveDatagramIrp (
                      irp,
                      Tsdu,
                      BytesAvailable,
                      Options,
                      OptionsLength,
                      SourceAddress,
                      SourceAddressLength,
                      ReceiveDatagramFlags
                      );

            IoCompleteRequest( irp, AfdPriorityBoost  );
        }

        *BytesTaken = BytesAvailable;

        DEREFERENCE_ENDPOINT (endpoint);
        return STATUS_SUCCESS;
    }
    else {

        //
        // We'll have to format up an IRP and give it to the provider to
        // handle.  We don't need any locks to do this--the restart routine
        // will check whether new receive datagram IRPs were pended on the
        // endpoint.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );


        //
        // We need to remember the endpoint in the AFD buffer because we'll
        // need to access it in the completion routine.
        //

        afdBuffer->Context = endpoint;

        ASSERT (afdBuffer->Irp->MdlAddress==afdBuffer->Mdl);
        TdiBuildReceiveDatagram(
            afdBuffer->Irp,
            endpoint->AddressDeviceObject,
            endpoint->AddressFileObject,
            AfdRestartBufferReceiveDatagram,
            afdBuffer,
            afdBuffer->Irp->MdlAddress,
            BytesAvailable,
            NULL,
            NULL,
            0
            );


        //
        // Make the next stack location current.  Normally IoCallDriver would
        // do this, but since we're bypassing that, we do it directly.
        //

        IoSetNextIrpStackLocation( afdBuffer->Irp );

        *IoRequestPacket = afdBuffer->Irp;
        *BytesTaken = 0;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

} // AfdReceiveDatagramEventHandler

NTSTATUS
AfdRestartReceiveDatagramWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of datagram receives that were started
    in the datagram indication handler and application IRP was
    available for direct transfer.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - referenced endpoint pointer.

Return Value:

    STATUS_SUCCESS to indicate that IO completion should continue.

--*/

{
    PAFD_ENDPOINT   endpoint = Context;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation (Irp);
    NTSTATUS    indStatus = irpSp->Parameters.AfdRecvDgIndStatus;

    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );
    //
    // Pick the worst status
    //
    if ((Irp->IoStatus.Status==STATUS_SUCCESS) ||
        (!NT_ERROR (Irp->IoStatus.Status) && NT_ERROR(indStatus)) ||
        (NT_SUCCESS (Irp->IoStatus.Status) && !NT_SUCCESS (indStatus)) ) {
        Irp->IoStatus.Status = indStatus;
    }

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    DEREFERENCE_ENDPOINT2 (endpoint, 
                "AfdRestartReceiveDatagramWithUserIrp, error/bytes 0x%lX",
                NT_SUCCESS (Irp->IoStatus.Status) 
                    ? (ULONG)Irp->IoStatus.Information
                    : (ULONG)Irp->IoStatus.Status);
    return STATUS_SUCCESS;
    
}


NTSTATUS
AfdRestartBufferReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of bufferred datagram receives that were started
    in the datagram indication handler.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - AfdBuffer structure.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED to indicate to the IO system that we
    own the IRP and the IO system should stop processing the it.

--*/

{
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_BUFFER afdBuffer;
    PIRP pendedIrp;

    ASSERT( NT_SUCCESS(Irp->IoStatus.Status) );

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));
    ASSERT (afdBuffer->DataOffset==0 ||
                (afdBuffer->DatagramFlags & TDI_RECEIVE_CONTROL_INFO));

    endpoint = afdBuffer->Context;
    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );



    //
    // If the IO failed, then just return the AFD buffer to our buffer
    // pool.
    //

    if ( !NT_SUCCESS(Irp->IoStatus.Status) ) {
        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );
        AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );
        endpoint->Common.Datagram.ErrorDrop = TRUE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_ENDPOINT2 (endpoint, 
            "AfdRestartBufferReceiveDatagram, status: 0x%lX",
            Irp->IoStatus.Status);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Make sure transport did not lie to us in indication handler.
    //
    ASSERT (afdBuffer->DataLength == (ULONG)Irp->IoStatus.Information);



    //
    // If there are any pended IRPs on the endpoint, complete as
    // appropriate with the new information.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    while ( !IsListEmpty( &endpoint->ReceiveDatagramIrpListHead ) ) {
        PLIST_ENTRY listEntry;

        //
        // There was a pended receive datagram IRP.  Remove it from the
        // head of the list.
        //

        listEntry = RemoveHeadList( &endpoint->ReceiveDatagramIrpListHead );

        //
        // Get a pointer to the IRP and reset the cancel routine in
        // the IRP.  The IRP is no longer cancellable.
        //

        pendedIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Reset the cancel routine in the IRP.  The IRP is no
        // longer cancellable, since we're about to complete it.
        //

        if ( IoSetCancelRoutine( pendedIrp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            pendedIrp->Tail.Overlay.ListEntry.Flink = NULL;
            pendedIrp = NULL;
            continue;
        }

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Set up the user's IRP for completion.
        //

        (VOID)AfdSetupReceiveDatagramIrp (
                  pendedIrp,
                  afdBuffer->Buffer,
                  afdBuffer->DataLength,
                  (PUCHAR)afdBuffer->Buffer+afdBuffer->DataLength, 
                  afdBuffer->DataOffset,
                  afdBuffer->TdiInfo.RemoteAddress,
                  afdBuffer->TdiInfo.RemoteAddressLength,
                  afdBuffer->DatagramFlags
                  );

        //
        // Complete the user's IRP, free the AFD buffer we used for
        // the request, and tell the IO system that we're done
        // processing this request.
        //

        AfdReturnBuffer( &afdBuffer->Header, endpoint->OwningProcess );

        DEREFERENCE_ENDPOINT2 (endpoint, 
            "AfdRestartBufferReceiveDatagram, completing IRP with 0x%lX bytes",
            (ULONG)pendedIrp->IoStatus.Information);

        IoCompleteRequest( pendedIrp, AfdPriorityBoost );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // If there are any pended peek IRPs on the endpoint, complete
    // one with this datagram.
    //

    pendedIrp = NULL;

    while ( !IsListEmpty( &endpoint->PeekDatagramIrpListHead ) ) {
        PLIST_ENTRY listEntry;

        //
        // There was a pended peek receive datagram IRP.  Remove it from
        // the head of the list.
        //

        listEntry = RemoveHeadList( &endpoint->PeekDatagramIrpListHead );

        //
        // Get a pointer to the IRP and reset the cancel routine in
        // the IRP.  The IRP is no longer cancellable.
        //

        pendedIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        //
        // Reset the cancel routine in the IRP.  The IRP is no
        // longer cancellable, since we're about to complete it.
        //

        if ( IoSetCancelRoutine( pendedIrp, NULL ) == NULL ) {


            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            pendedIrp->Tail.Overlay.ListEntry.Flink = NULL;
            pendedIrp = NULL;
            continue;
        }

        //
        // Set up the user's IRP for completion.
        //

        (VOID)AfdSetupReceiveDatagramIrp (
                  pendedIrp,
                  afdBuffer->Buffer,
                  afdBuffer->DataLength,
                  (PUCHAR)afdBuffer->Buffer+afdBuffer->DataLength, 
                  afdBuffer->DataOffset,
                  afdBuffer->TdiInfo.RemoteAddress,
                  afdBuffer->TdiInfo.RemoteAddressLength,
                  afdBuffer->DatagramFlags
                  );

        //
        // Don't complete the pended peek IRP yet, since we still hold
        // locks.  Wait until it is safe to release the locks.
        //

        break;
    }

    //
    // Store success status do distinguish this from
    // ICMP rejects reported by ErrorEventHandler(Ex).
    //

    afdBuffer->Status = STATUS_SUCCESS;

    //
    // Place the datagram at the end of the endpoint's list of bufferred
    // datagrams, and update counts of datagrams on the endpoint.
    //

    InsertTailList(
        &endpoint->ReceiveDatagramBufferListHead,
        &afdBuffer->BufferListEntry
        );

    endpoint->DgBufferredReceiveCount++;
    endpoint->DgBufferredReceiveBytes += afdBuffer->DataLength;

    //
    // Reenable FAST IO on the endpoint to allow quick
    // copying of buffered data.
    //
    endpoint->DisableFastIoRecv = FALSE;

    //
    // Release locks and indicate that there are bufferred datagrams
    // on the endpoint.
    //

    AfdIndicateEventSelectEvent(
        endpoint,
        AFD_POLL_RECEIVE,
        STATUS_SUCCESS
        );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    AfdIndicatePollEvent(
        endpoint,
        AFD_POLL_RECEIVE,
        STATUS_SUCCESS
        );

    //
    // If there was a pended peek IRP to complete, complete it now.
    //

    if ( pendedIrp != NULL ) {
        IoCompleteRequest( pendedIrp, 2 );
    }

    //
    // Tell the IO system to stop processing this IRP, since we now own
    // it as part of the AFD buffer.
    //

    DEREFERENCE_ENDPOINT (endpoint,);

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartBufferReceiveDatagram


VOID
AfdCancelReceiveDatagram (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Cancels a receive datagram IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Get the endpoint pointer from our IRP stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    endpoint = irpSp->FileObject->FsContext;

    ASSERT( IS_DGRAM_ENDPOINT(endpoint) );

    //
    // Remove the IRP from the endpoint's IRP list, synchronizing with
    // the endpoint lock which protects the lists.  Note that the
    // IRP *must* be on one of the endpoint's lists or the Flink is NULL
    // if we are getting called here--anybody that removes the IRP from
    // the list must reset the cancel routine to NULL and set the
    // Flink to NULL before releasing the endpoint spin lock.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if (Irp->Tail.Overlay.ListEntry.Flink != NULL) {

        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Free any MDL chains attached to the IRP stack location.
    //

    AfdCleanupReceiveDatagramIrp( Irp );

    //
    // Release the cancel spin lock and complete the IRP with a
    // cancellation status code.
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return;

} // AfdCancelReceiveDatagram


BOOLEAN
AfdCleanupReceiveDatagramIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    Performs any cleanup specific to receive datagram IRPs.

Arguments:

    Irp - the IRP to cleanup.

Return Value:

    TRUE - complete IRP, FALSE - leave alone.

Notes:

    This routine may be called at raised IRQL from AfdCompleteIrpList().

--*/

{
    PIO_STACK_LOCATION irpSp;
    PMDL mdl;

    //
    // Get the endpoint pointer from our IRP stack location.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Free any MDL chains attached to the IRP stack location.
    //

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl;

    if( mdl != NULL ) {
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }

    mdl = (PMDL)Irp->AfdRecvMsgControlMdl;

    if( mdl != NULL ) {
        Irp->AfdRecvMsgControlMdl = NULL;
        MmUnlockPages( mdl );
        IoFreeMdl( mdl );
    }
    return TRUE;

} // AfdCleanupReceiveDatagramIrp


NTSTATUS
AfdSetupReceiveDatagramIrp (
    IN PIRP Irp,
    IN PVOID DatagramBuffer OPTIONAL,
    IN ULONG DatagramLength,
    IN PVOID ControlBuffer OPTIONAL,
    IN ULONG ControlLength,
    IN PVOID SourceAddress OPTIONAL,
    IN ULONG SourceAddressLength,
    IN ULONG TdiReceiveFlags
    )

/*++

Routine Description:

    Copies the datagram to the MDL in the IRP and the datagram sender's
    address to the appropriate place in the system buffer.

Arguments:

    Irp - the IRP to prepare for completion.

    DatagramBuffer - datagram to copy into the IRP.  If NULL, then
        there is no need to copy the datagram to the IRP's MDL, the
        datagram has already been copied there.

    DatagramLength - the length of the datagram to copy.

    SourceAddress - address of the sender of the datagram.

    SourceAddressLength - length of the source address.

Return Value:

    NTSTATUS - The status code placed into the IRP.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN dataOverflow = FALSE;
    BOOLEAN controlOverflow = FALSE;

    //
    // To determine how to complete setting up the IRP for completion,
    // figure out whether this IRP was for regular datagram information,
    // in which case we need to return an address, or for data only, in
    // which case we will not return the source address.  NtReadFile()
    // and recv() on connected datagram sockets will result in the
    // latter type of IRP.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // If necessary, copy the datagram in the buffer to the MDL in the
    // user's IRP.  If there is no MDL in the buffer, then fail if the
    // datagram is larger than 0 bytes.
    //

    if ( ARGUMENT_PRESENT( DatagramBuffer ) ) {
        ULONG bytesCopied = 0;

        if ( Irp->MdlAddress == NULL ) {

            if ( DatagramLength != 0 ) {
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                status = STATUS_SUCCESS;
            }

        } else {

            status = AfdMapMdlChain (Irp->MdlAddress);
            if (NT_SUCCESS (status)) {
                status = TdiCopyBufferToMdl(
                         DatagramBuffer,
                         0,
                         DatagramLength,
                         Irp->MdlAddress,
                         0,
                         &bytesCopied
                         );
            }
        }

        Irp->IoStatus.Information = bytesCopied;

    } else {

        //
        // The information was already copied to the MDL chain in the
        // IRP.  Just remember the IO status block so we can do the
        // right thing with it later.
        //

        status = Irp->IoStatus.Status;
        if (DatagramLength>PtrToUlong (Irp->AfdRecvLength)) {
            status = STATUS_BUFFER_OVERFLOW;
        }
    }

    if (status==STATUS_BUFFER_OVERFLOW) {
        dataOverflow = TRUE;
    }


    if( irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl != NULL ) {
        PMDL    addressMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl;
        PMDL    addressLenMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl;

        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressMdl = NULL;
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl = NULL;

        ASSERT( addressMdl->Next == NULL );
        ASSERT( ( addressMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (addressMdl) > 0 );

        ASSERT( addressLenMdl != NULL );
        ASSERT( addressLenMdl->Next == NULL );
        ASSERT( ( addressLenMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (addressLenMdl)==sizeof (ULONG) );

        if ((NT_SUCCESS (status) || 
                    status==STATUS_BUFFER_OVERFLOW || 
                    status==STATUS_PORT_UNREACHABLE) &&
                ARGUMENT_PRESENT (SourceAddress)) {
            PVOID   dst;
            PTRANSPORT_ADDRESS tdiAddress;

            //
            // Extract the real SOCKADDR structure from the TDI address.
            // This duplicates MSAFD.DLL's SockBuildSockaddr() function.
            //

            C_ASSERT( sizeof(tdiAddress->Address[0].AddressType) == sizeof(u_short) );
            C_ASSERT( FIELD_OFFSET( TA_ADDRESS, AddressLength ) == 0 );
            C_ASSERT( FIELD_OFFSET( TA_ADDRESS, AddressType ) == sizeof(USHORT) );
            ASSERT( FIELD_OFFSET( TRANSPORT_ADDRESS, Address[0] ) == sizeof(int) );

            tdiAddress = SourceAddress;

            ASSERT( SourceAddressLength >=
                        (tdiAddress->Address[0].AddressLength + sizeof(u_short)) );

            SourceAddressLength = tdiAddress->Address[0].AddressLength +
                                      sizeof(u_short);  // sa_family
            SourceAddress = &tdiAddress->Address[0].AddressType;

            //
            // Copy the address to the user's buffer, then unlock and
            // free the MDL describing the user's buffer.
            //

            if (SourceAddressLength>MmGetMdlByteCount (addressMdl)) {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            else {
                dst = MmGetSystemAddressForMdlSafe (addressMdl, LowPagePriority);
                if (dst!=NULL) {
                    PULONG   dstU;
                    RtlMoveMemory (dst, SourceAddress, SourceAddressLength);

                    //
                    // Copy succeeded, return the length as well.
                    //

                    dstU = MmGetSystemAddressForMdlSafe (addressLenMdl, LowPagePriority);
                    if (dstU!=NULL) {
                        *dstU = SourceAddressLength;
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        MmUnlockPages( addressMdl );
        IoFreeMdl( addressMdl );

        MmUnlockPages( addressLenMdl );
        IoFreeMdl( addressLenMdl );

    } else {

        ASSERT( irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvAddressLenMdl == NULL );

    }

    if (irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl!=NULL) {
        PMDL controlMdl = Irp->AfdRecvMsgControlMdl;
        PMDL controlLenMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl;

        Irp->AfdRecvMsgControlMdl = NULL;
        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvControlLenMdl = NULL;

        ASSERT( irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl != NULL );
        ASSERT( ( controlLenMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (controlLenMdl) == sizeof (ULONG) );

        //
        // We still need to NULL the length even if no control data was delivered.
        //
        if (!NT_ERROR (status)) {
            PULONG  dstU;
            dstU = MmGetSystemAddressForMdlSafe (controlLenMdl, LowPagePriority);
            if (dstU!=NULL) {
                if ((TdiReceiveFlags & TDI_RECEIVE_CONTROL_INFO)==0) {
                    ControlLength = 0;
                }
#ifdef _WIN64
                else if (IoIs32bitProcess (Irp)) {
                    ControlLength = AfdComputeCMSGLength32 (
                                        ControlBuffer,
                                        ControlLength);
                }
#endif //_WIN64

                *dstU = ControlLength;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        //
        // Ignore control data in case of error or if flag indicating
        // that data is in proper format is not set.
        //
        if (!NT_ERROR (status) && ControlLength!=0) {

            if (controlMdl==NULL) {
                controlOverflow = TRUE;
                status = STATUS_BUFFER_OVERFLOW;
            }
            else {
                PVOID dst;
                //
                // Copy control info if app needs them (WSARecvMsg).
                //
                if (ControlLength>MmGetMdlByteCount (controlMdl)) {
                    ControlLength = MmGetMdlByteCount (controlMdl);
                    controlOverflow = TRUE;
                    status = STATUS_BUFFER_OVERFLOW;
                }

                dst = MmGetSystemAddressForMdlSafe (controlMdl, LowPagePriority);
                if (dst!=NULL) {
#ifdef _WIN64
                    if (IoIs32bitProcess (Irp)) {
                        AfdCopyCMSGBuffer32 (dst, ControlBuffer, ControlLength);
                    }
                    else
#endif //_WIN64
                    {
                        RtlMoveMemory (dst, ControlBuffer, ControlLength);
                    }

                }
                else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }


        if (controlMdl!=NULL) {
            ASSERT( controlMdl->Next == NULL );
            ASSERT( ( controlMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
            ASSERT( MmGetMdlByteCount (controlMdl) > 0 );
            MmUnlockPages (controlMdl);
            IoFreeMdl (controlMdl);
        }

        MmUnlockPages (controlLenMdl);
        IoFreeMdl (controlLenMdl);
    }
    else {
        ASSERT (Irp->AfdRecvMsgControlMdl==NULL);
    }

    if (irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl!=NULL) {
        PMDL flagsMdl = irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl;

        irpSp->Parameters.AfdRecvDatagramInfo.AfdRecvFlagsMdl = NULL;

        ASSERT( flagsMdl->Next == NULL );
        ASSERT( ( flagsMdl->MdlFlags & MDL_PAGES_LOCKED ) != 0 );
        ASSERT( MmGetMdlByteCount (flagsMdl)==sizeof (ULONG) );

        if (!NT_ERROR (status)) {
            PULONG   dst;

            dst = MmGetSystemAddressForMdlSafe (flagsMdl, LowPagePriority);
            if (dst!=NULL) {
                ULONG flags = 0;
                if (TdiReceiveFlags & TDI_RECEIVE_BROADCAST)
                    flags |= MSG_BCAST;
                if (TdiReceiveFlags & TDI_RECEIVE_MULTICAST)
                    flags |= MSG_MCAST;
                if (dataOverflow)
                    flags |= MSG_TRUNC;
                if (controlOverflow)
                    flags |= MSG_CTRUNC;

                *dst = flags;
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        MmUnlockPages (flagsMdl);
        IoFreeMdl (flagsMdl);
    }

    //
    // Set up the IRP for completion.
    //

    Irp->IoStatus.Status = status;

    return status;

} // AfdSetupReceiveDatagramIrp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\receive.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    receive.c

Abstract:

    This module contains the code for passing on receive IRPs to
    TDI providers.

Author:

    David Treadwell (davidtr)    13-Mar-1992

Revision History:
    Vadim Eydelman (vadime)
        1998-1999 Minimal NT5.0 changes (keep in sync with rest)

--*/

#include "afdp.h"

NTSTATUS
AfdRestartReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdReceive )
#pragma alloc_text( PAGEAFD, AfdRestartReceive )
#pragma alloc_text( PAGEAFD, AfdReceiveEventHandler )
#pragma alloc_text( PAGEAFD, AfdReceiveExpeditedEventHandler )
#pragma alloc_text( PAGEAFD, AfdQueryReceiveInformation )
#endif


NTSTATUS
FASTCALL
AfdReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PTDI_REQUEST_RECEIVE receiveRequest;
    BOOLEAN allocatedReceiveRequest = FALSE;
    BOOLEAN peek;
    LARGE_INTEGER bytesExpected;
    BOOLEAN isDataOnConnection;
    BOOLEAN isExpeditedDataOnConnection;
    ULONG recvFlags;
    ULONG afdFlags;
    ULONG recvLength;
    ULONG   bufferCount;

    //
    // Make sure that the endpoint is in the correct state.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    //
    // Datagram endpoints can be received on event if they are just bound
    // Connection oriented endpoints must be connected.
    //
    if ( (endpoint->State != AfdEndpointStateConnected ) &&
        (!IS_DGRAM_ENDPOINT(endpoint) || (endpoint->State!= AfdEndpointStateBound))) {
        if (IS_DGRAM_ENDPOINT(endpoint))
            status = STATUS_INVALID_PARAMETER;
        else
            status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    //
    // If receive has been shut down or the endpoint aborted, fail.
    //

    if ( (endpoint->DisconnectMode & AFD_ABORTIVE_DISCONNECT) ) {
        status = STATUS_LOCAL_DISCONNECT;
        goto complete;
    }

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) ) {
        status = STATUS_PIPE_DISCONNECTED;
        goto complete;
    }

    //
    // If this is an IOCTL_AFD_RECEIVE, then grab the parameters from the
    // supplied AFD_RECV_INFO structure, build an MDL chain describing
    // the WSABUF array, and attach the MDL chain to the IRP.
    //
    // If this is an IRP_MJ_READ IRP, just grab the length from the IRP
    // and set the flags to zero.
    //

    if ( IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL ) {

#ifdef _WIN64
        if (IoIs32bitProcess (Irp)) {
            PAFD_RECV_INFO32 recvInfo32;
            LPWSABUF32 bufferArray32;

           if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*recvInfo32) ) {

                try {

                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    recvInfo32 = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {
                        ProbeForRead(
                            recvInfo32,
                            sizeof(*recvInfo32),
                            PROBE_ALIGNMENT32(AFD_RECV_INFO32)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    recvFlags = recvInfo32->TdiFlags;
                    afdFlags = recvInfo32->AfdFlags;
                    bufferArray32 = recvInfo32->BufferArray;
                    bufferCount = recvInfo32->BufferCount;

                    //
                    // Validate the receive flags & WSABUF parameters.
                    // Note that either TDI_RECEIVE_NORMAL or
                    // TDI_RECEIVE_EXPEDITED (but not both) must be set
                    // in the receive flags. And expedited can only
                    // be set if transport supports expedited data and
                    // endpoint is not set to inline mode.
                    //

                    if ( ( recvFlags & TDI_RECEIVE_EITHER ) == 0 ||
                         ( recvFlags & TDI_RECEIVE_EITHER ) == TDI_RECEIVE_EITHER
                         ) {

                        //
                        // Invalid receive flags
                        //

                        status = STATUS_INVALID_PARAMETER;
                    }
                    else if (( recvFlags & TDI_RECEIVE_EXPEDITED) != 0 &&
                                (!IS_TDI_EXPEDITED( endpoint )
                                || endpoint->InLine )) {

                        if (endpoint->InLine) {
                            //
                            // Endpoint set inline, OOB data is reported as
                            // normal.
                            //
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else {
                            //
                            // Transport does not support expedited data
                            //

                            status = STATUS_NOT_SUPPORTED;
                        }

                    }
                    else {

                        //
                        // Create the MDL chain describing the WSABUF array.
                        // This will also validate the buffer array and individual
                        // buffers
                        //

                        status = AfdAllocateMdlChain32(
                                     Irp,       // Requestor mode passed along
                                     bufferArray32,
                                     bufferCount,
                                     IoWriteAccess,
                                     &recvLength
                                     );

                    }

                } except ( AFD_EXCEPTION_FILTER(&status) ) {

                    //
                    // Exception accessing input structure.
                    //


                }

            } else {

                //
                // Invalid input buffer length.
                //

                status = STATUS_INVALID_PARAMETER;

            }
        }
        else
#endif // _WIN64
        {
            PAFD_RECV_INFO recvInfo;
            LPWSABUF bufferArray;

            //
            // Sanity check.
            //

            ASSERT( IrpSp->Parameters.DeviceIoControl.IoControlCode==IOCTL_AFD_RECEIVE );

            if ( IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
                    sizeof(*recvInfo) ) {


                try {

                    //
                    // Validate the input structure if it comes from the user mode 
                    // application
                    //

                    recvInfo = IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    if( Irp->RequestorMode != KernelMode ) {
                        ProbeForRead(
                            recvInfo,
                            sizeof(*recvInfo),
                            PROBE_ALIGNMENT(AFD_RECV_INFO)
                            );

                    }

                    //
                    // Make local copies of the embeded pointer and parameters
                    // that we will be using more than once in case malicios
                    // application attempts to change them while we are
                    // validating
                    //

                    recvFlags = recvInfo->TdiFlags;
                    afdFlags = recvInfo->AfdFlags;
                    bufferArray = recvInfo->BufferArray;
                    bufferCount = recvInfo->BufferCount;

                    //
                    // Validate the receive flags & WSABUF parameters.
                    // Note that either TDI_RECEIVE_NORMAL or
                    // TDI_RECEIVE_EXPEDITED (but not both) must be set
                    // in the receive flags. And expedited can only
                    // be set if transport supports expedited data and
                    // endpoint is not set to inline mode.
                    //

                    if ( ( recvFlags & TDI_RECEIVE_EITHER ) == 0 ||
                         ( recvFlags & TDI_RECEIVE_EITHER ) == TDI_RECEIVE_EITHER
                         ) {

                        //
                        // Invalid receive flags
                        //

                        status = STATUS_INVALID_PARAMETER;
                    }
                    else if (( recvFlags & TDI_RECEIVE_EXPEDITED) != 0 &&
                                (!IS_TDI_EXPEDITED( endpoint )
                                || endpoint->InLine )) {

                        if (endpoint->InLine) {
                            //
                            // Endpoint set inline, OOB data is reported as
                            // normal.
                            //
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else {
                            //
                            // Transport does not support expedited data
                            //

                            status = STATUS_NOT_SUPPORTED;
                        }

                    }
                    else {

                        //
                        // Create the MDL chain describing the WSABUF array.
                        // This will also validate the buffer array and individual
                        // buffers
                        //

                        status = AfdAllocateMdlChain(
                                     Irp,       // Requestor mode passed along
                                     bufferArray,
                                     bufferCount,
                                     IoWriteAccess,
                                     &recvLength
                                     );

                    }

                } except ( AFD_EXCEPTION_FILTER(&status) ) {

                    //
                    // Exception accessing input structure.
                    //


                }

            } else {

                //
                // Invalid input buffer length.
                //

                status = STATUS_INVALID_PARAMETER;

            }
        }
        if( !NT_SUCCESS(status) ) {

            goto complete;

        }

        if (IS_SAN_ENDPOINT(endpoint)) {
            IrpSp->MajorFunction = IRP_MJ_READ;
            IrpSp->Parameters.Read.Length = recvLength;
            return AfdSanRedirectRequest (Irp, IrpSp);
        }

    } else {

        ASSERT( IrpSp->MajorFunction == IRP_MJ_READ );

        recvFlags = TDI_RECEIVE_NORMAL;
        afdFlags = AFD_OVERLAPPED;
        recvLength = IrpSp->Parameters.Read.Length;

        ASSERT( FIELD_OFFSET( IO_STACK_LOCATION, Parameters.Read.Length ) ==
                FIELD_OFFSET( IO_STACK_LOCATION, Parameters.DeviceIoControl.OutputBufferLength ) );

    }

    //
    // If this is a datagram endpoint, format up a receive datagram request
    // and pass it on to the TDI provider.
    //

    if ( IS_DGRAM_ENDPOINT(endpoint) ) {
        AFD_RECV_INFO recvInfo;
        recvInfo.TdiFlags = recvFlags;
        recvInfo.AfdFlags = afdFlags;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = recvLength;
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = &recvInfo;
        return AfdReceiveDatagram( Irp, IrpSp);
    }

    //
    // If this is an endpoint on a nonbufferring transport, use another
    // routine to handle the request.
    //

    if ( !IS_TDI_BUFFERRING(endpoint) ) {
        return AfdBReceive( Irp, IrpSp, recvFlags, afdFlags, recvLength );
    }

    //
    // Allocate a buffer for the receive request structure.
    //

    try {
        receiveRequest = AFD_ALLOCATE_POOL_WITH_QUOTA (
                         NonPagedPool,
                         sizeof(TDI_REQUEST_RECEIVE),
                         AFD_TDI_POOL_TAG
                         );
        // AFD_ALLOCATE_POOL_WITH_QUOTA macro sets POOL_RAISE_IF_ALLOCATION_FAILURE
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode ();
        receiveRequest = NULL;
        goto complete;
    }

    allocatedReceiveRequest = TRUE;

    //
    // Set up the receive request structure.
    //

    RtlZeroMemory(
        receiveRequest,
        sizeof(*receiveRequest)
        );

    receiveRequest->ReceiveFlags = (USHORT)recvFlags;

    //
    // If this endpoint is set up for inline reception of expedited data,
    // change the receive flags to use either normal or expedited data.
    //

    if ( endpoint->InLine ) {
        receiveRequest->ReceiveFlags |= TDI_RECEIVE_EITHER;
    }

    //
    // Determine whether this is a request to just peek at the data.
    //

    peek = (BOOLEAN)( (receiveRequest->ReceiveFlags & TDI_RECEIVE_PEEK) != 0 );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    connection = endpoint->Common.VcConnecting.Connection;
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    if ( endpoint->NonBlocking ) {
        isDataOnConnection = IS_DATA_ON_CONNECTION( connection );
        isExpeditedDataOnConnection = IS_EXPEDITED_DATA_ON_CONNECTION( connection );
    }

    if ( endpoint->InLine ) {

        //
        // If the endpoint is nonblocking, check whether the receive can
        // be performed immediately.  Note that if the endpoint is set
        // up for inline reception of expedited data we don't fail just
        // yet--there may be expedited data available to be read.
        //

        if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) ) {

            if ( !isDataOnConnection &&
                     !isExpeditedDataOnConnection &&
                     !connection->AbortIndicated &&
                     !connection->DisconnectIndicated ) {

                IF_DEBUG(RECEIVE) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdReceive: failing nonblocking IL receive, ind %ld, "
                                "taken %ld, out %ld\n",
                                connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                                connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                                connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart ));
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "    EXP ind %ld, taken %ld, out %ld\n",
                                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                                connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
                }

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                status = STATUS_DEVICE_NOT_READY;
                goto complete;
            }
        }

        //
        // If this is a nonblocking endpoint for a message-oriented
        // transport, limit the number of bytes that can be received to the
        // amount that has been indicated.  This prevents the receive
        // from blocking in the case where only part of a message has been
        // received.
        //

        if ( IS_MESSAGE_ENDPOINT(endpoint) && endpoint->NonBlocking ) {

            LARGE_INTEGER expBytesExpected;

            bytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart);
            ASSERT( bytesExpected.HighPart == 0 );

            expBytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart);
            ASSERT( expBytesExpected.HighPart == 0 );

            IF_DEBUG(RECEIVE) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdReceive: %lx normal bytes expected, %ld exp bytes expected",
                            bytesExpected.LowPart, expBytesExpected.LowPart ));
            }

            //
            // If expedited data exists on the connection, use the lower
            // count between the available expedited and normal receive
            // data.
            //

            if ( (isExpeditedDataOnConnection &&
                     bytesExpected.LowPart > expBytesExpected.LowPart) ||
                 !isDataOnConnection ) {
                bytesExpected = expBytesExpected;
            }

            //
            // If the request is for more bytes than are available, cut back
            // the number of bytes requested to what we know is actually
            // available.
            //

            if ( recvLength > bytesExpected.LowPart ) {
                recvLength = bytesExpected.LowPart;
            }
        }

        //
        // Increment the count of posted receive bytes outstanding.
        // This count is used for polling and nonblocking receives.
        // Note that we do not increment this count if this is only
        // a PEEK receive, since peeks do not actually take any data
        // they should not affect whether data is available to be read
        // on the endpoint.
        //

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceive: conn %p for %ld bytes, ind %ld, "
                        "taken %ld, out %ld %s\n",
                        connection,
                        recvLength,
                        connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart,
                        peek ? "PEEK" : "" ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    EXP ind %ld, taken %ld, out %ld\n",
                        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
        }

        if ( !peek ) {

            connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart +
                    recvLength;

            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart +
                    recvLength;
        }
    }

    if ( !endpoint->InLine &&
             (receiveRequest->ReceiveFlags & TDI_RECEIVE_NORMAL) != 0 ) {

        //
        // If the endpoint is nonblocking, check whether the receive can
        // be performed immediately.
        //

        if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) ) {

            if ( !isDataOnConnection &&
                     !connection->AbortIndicated &&
                     !connection->DisconnectIndicated ) {

                IF_DEBUG(RECEIVE) {
                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                "AfdReceive: failing nonblocking receive, ind %ld, "
                                "taken %ld, out %ld\n",
                                connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                                connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                                connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart ));
                }

                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                status = STATUS_DEVICE_NOT_READY;
                goto complete;
            }
        }

        //
        // If this is a nonblocking endpoint for a message-oriented
        // transport, limit the number of bytes that can be received to the
        // amount that has been indicated.  This prevents the receive
        // from blocking in the case where only part of a message has been
        // received.
        //

        if ( IS_MESSAGE_ENDPOINT(endpoint) && endpoint->NonBlocking ) {

            bytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart);

            ASSERT( bytesExpected.HighPart == 0 );

            //
            // If the request is for more bytes than are available, cut back
            // the number of bytes requested to what we know is actually
            // available.
            //

            if ( recvLength > bytesExpected.LowPart ) {
                recvLength = bytesExpected.LowPart;
            }
        }

        //
        // Increment the count of posted receive bytes outstanding.
        // This count is used for polling and nonblocking receives.
        // Note that we do not increment this count if this is only
        // a PEEK receive, since peeks do not actually take any data
        // they should not affect whether data is available to be read
        // on the endpoint.
        //

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceive: conn %p for %ld bytes, ind %ld, "
                        "taken %ld, out %ld %s\n",
                        connection,
                        recvLength,
                        connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart,
                        peek ? "PEEK" : "" ));
        }

        if ( !peek ) {

            connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart +
                    recvLength;
        }
    }

    if ( !endpoint->InLine &&
             (receiveRequest->ReceiveFlags & TDI_RECEIVE_EXPEDITED) != 0 ) {

        if ( endpoint->NonBlocking && !( afdFlags & AFD_OVERLAPPED ) &&
                 !isExpeditedDataOnConnection &&
                 !connection->AbortIndicated &&
                 !connection->DisconnectIndicated ) {

            IF_DEBUG(RECEIVE) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdReceive: failing nonblocking EXP receive, ind %ld, "
                            "taken %ld, out %ld\n",
                            connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                            connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            status = STATUS_DEVICE_NOT_READY;
            goto complete;
        }

        //
        // If this is a nonblocking endpoint for a message-oriented
        // transport, limit the number of bytes that can be received to the
        // amount that has been indicated.  This prevents the receive
        // from blocking in the case where only part of a message has been
        // received.
        //

        if ( IS_MESSAGE_ENDPOINT(endpoint) &&
                 endpoint->NonBlocking &&
                 IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {

            bytesExpected.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart);

            ASSERT( bytesExpected.HighPart == 0 );
            ASSERT( bytesExpected.LowPart != 0 );

            //
            // If the request is for more bytes than are available, cut back
            // the number of bytes requested to what we know is actually
            // available.
            //

            if ( recvLength > bytesExpected.LowPart ) {
                recvLength = bytesExpected.LowPart;
            }
        }

        //
        // Increment the count of posted expedited receive bytes
        // outstanding.  This count is used for polling and nonblocking
        // receives.  Note that we do not increment this count if this
        // is only a PEEK receive.
        //

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceive: conn %p for %ld bytes, ind %ld, "
                        "taken %ld, out %ld EXP %s\n",
                        connection,
                        recvLength,
                        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart,
                        peek ? "PEEK" : "" ));
        }

        if ( !peek ) {

            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart +
                    recvLength;
        }
    }

    //
    // Reference the connection so it can't go away
    // even if transmit file tries to clean it up
    //
    REFERENCE_CONNECTION (connection);

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Build the TDI receive request.
    //

    TdiBuildReceive(
        Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartReceive,
        connection,
        Irp->MdlAddress,
        receiveRequest->ReceiveFlags,
        recvLength
        );

    //
    // Save a pointer to the receive request structure so that we
    // can free it in our restart routine.
    //

    IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = receiveRequest;
    IrpSp->Parameters.DeviceIoControl.OutputBufferLength = recvLength;


    //
    // Call the transport to actually perform the connect operation.
    //

    return AfdIoCallDriver( endpoint, connection->DeviceObject, Irp );

complete:

    if ( allocatedReceiveRequest ) {
        AFD_FREE_POOL(
            receiveRequest,
            AFD_TDI_POOL_TAG
            );
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdReceive


NTSTATUS
AfdRestartReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    PIO_STACK_LOCATION irpSp;
    LARGE_INTEGER actualBytes;
    LARGE_INTEGER requestedBytes;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    ULONG receiveFlags;
    ULONG eventMask;
    BOOLEAN expedited;
    PTDI_REQUEST_RECEIVE receiveRequest;

    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( IS_TDI_BUFFERRING(endpoint) );

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    AfdCompleteOutstandingIrp( endpoint, Irp );

    actualBytes.QuadPart = Irp->IoStatus.Information;
    requestedBytes.QuadPart = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Determine whether we received normal or expedited data.
    //

    receiveRequest = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
    receiveFlags = receiveRequest->ReceiveFlags;

    if ( Irp->IoStatus.Status == STATUS_RECEIVE_EXPEDITED ||
         Irp->IoStatus.Status == STATUS_RECEIVE_PARTIAL_EXPEDITED ) {
        expedited = TRUE;
    } else {
        expedited = FALSE;
    }

    //
    // Free the receive request structure.
    //

    AFD_FREE_POOL(
        receiveRequest,
        AFD_TDI_POOL_TAG
        );

    //
    // If this was a PEEK receive, don't update the counts of received
    // data, just return.
    //

    if ( (receiveFlags & TDI_RECEIVE_PEEK) != 0 ) {

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartReceive: IRP %p, endpoint %p, conn %p, "
                        "status %X\n",
                        Irp, endpoint, endpoint->Common.VcConnecting.Connection,
                        Irp->IoStatus.Status ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    %s data, PEEKed only.\n",
                        expedited ? "expedited" : "normal" ));
        }

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    //
    // Update the count of bytes actually received on the connection.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if( expedited ) {
        eventMask = endpoint->InLine
                        ? (ULONG)~AFD_POLL_RECEIVE
                        : (ULONG)~AFD_POLL_RECEIVE_EXPEDITED;
    } else {
        eventMask = (ULONG)~AFD_POLL_RECEIVE;
    }

    endpoint->EventsActive &= eventMask;

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdReceive: Endp %p, Active %lx\n",
            endpoint,
            endpoint->EventsActive
            ));
    }


    if ( !expedited ) {

        if ( actualBytes.LowPart == 0 ) {
            ASSERT( actualBytes.HighPart == 0 );
            connection->VcZeroByteReceiveIndicated = FALSE;
        } else {
            connection->Common.Bufferring.ReceiveBytesTaken.QuadPart =
                actualBytes.QuadPart +
                connection->Common.Bufferring.ReceiveBytesTaken.QuadPart;
        }

        //
        // If the number taken exceeds the number indicated, then this
        // receive got some unindicated bytes because the receive was
        // posted when the indication arrived.  If this is the case, set
        // the amount indicated equal to the amount received.
        //

        if ( connection->Common.Bufferring.ReceiveBytesTaken.QuadPart >
                 connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart ) {

            connection->Common.Bufferring.ReceiveBytesIndicated =
                connection->Common.Bufferring.ReceiveBytesTaken;
        }

        //
        // Decrement the count of outstanding receive bytes on this connection
        // by the receive size that was requested.
        //

        connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart -
                requestedBytes.QuadPart;

        //
        // If the endpoint is inline, decrement the count of outstanding
        // expedited bytes.
        //

        if ( endpoint->InLine ) {
            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart -
                requestedBytes.QuadPart;
        }

        if( connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart > 0 ||
            ( endpoint->InLine &&
              connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart > 0 ) ) {

            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_RECEIVE,
                STATUS_SUCCESS
                );

        }

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartReceive: IRP %p, endpoint %p, conn %p, "
                        "status %lx\n",
                        Irp, endpoint, connection,
                        Irp->IoStatus.Status ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    req. bytes %ld, actual %ld, ind %ld, "
                        " taken %ld, out %ld\n",
                        requestedBytes.LowPart, actualBytes.LowPart,
                        connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart
                        ));
        }

    } else {

        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart =
            actualBytes.QuadPart +
            connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart;

        //
        // If the number taken exceeds the number indicated, then this
        // receive got some unindicated bytes because the receive was
        // posted when the indication arrived.  If this is the case, set
        // the amount indicated equal to the amount received.
        //

        if ( connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart >
                 connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart ) {

            connection->Common.Bufferring.ReceiveExpeditedBytesIndicated =
                connection->Common.Bufferring.ReceiveExpeditedBytesTaken;
        }

        //
        // Decrement the count of outstanding receive bytes on this connection
        // by the receive size that was requested.
        //

        ASSERT( connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart > 0 ||
                    connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.HighPart > 0 ||
                    requestedBytes.LowPart == 0 );

        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart =
            connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart -
            requestedBytes.QuadPart;

        //
        // If the endpoint is inline, decrement the count of outstanding
        // normal bytes.
        //

        if ( endpoint->InLine ) {

            connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart =
                connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart -
                requestedBytes.QuadPart;

            if( connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart > 0 ||
                connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart > 0 ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );

            }

        } else {

            if( connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart > 0 ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            }

        }

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartReceive: (exp) IRP %p, endpoint %p, conn %p, "
                        "status %X\n",
                        Irp, endpoint, connection,
                        Irp->IoStatus.Status ));
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "    req. bytes %ld, actual %ld, ind %ld, "
                        " taken %ld, out %ld\n",
                        requestedBytes.LowPart, actualBytes.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                        connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart
                        ));
        }

    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    DEREFERENCE_CONNECTION (connection);

    //
    // If pending has be returned for this irp then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending(Irp);
    }

    return STATUS_SUCCESS;

} // AfdRestartReceive


NTSTATUS
AfdReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN result;

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION (connection,result);
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth);
    ASSERT( !connection->DisconnectIndicated );
    ASSERT( !connection->AbortIndicated );
    ASSERT( IS_TDI_BUFFERRING(endpoint) );

    //
    // Bump the count of bytes indicated on the connection to account for
    // the bytes indicated by this event.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  !IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    if ( BytesAvailable == 0 ) {

        connection->VcZeroByteReceiveIndicated = TRUE;

    } else {

        connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart =
            connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart +
                BytesAvailable;
    }

    IF_DEBUG(RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReceiveEventHandler: conn %p, bytes %ld, "
                    "ind %ld, taken %ld, out %ld\n",
                    connection, BytesAvailable,
                    connection->Common.Bufferring.ReceiveBytesIndicated.LowPart,
                    connection->Common.Bufferring.ReceiveBytesTaken.LowPart,
                    connection->Common.Bufferring.ReceiveBytesOutstanding.LowPart ));
    }

    //
    // If the receive side of the endpoint has been shut down, tell the
    // provider that we took all the data and reset the connection.
    // Also, account for these bytes in our count of bytes taken from
    // the transport.
    //

    if (  (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ) {

#if DBG
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdReceiveEventHandler: receive shutdown, "
                    "%ld bytes, aborting endp %p\n",
                    BytesAvailable, endpoint ));
#endif

        connection->Common.Bufferring.ReceiveBytesTaken.QuadPart =
            connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                BytesAvailable;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        *BytesTaken = BytesAvailable;

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        (VOID)AfdBeginAbort( connection );

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;

    } else {

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicateEventSelectEvent(
                endpoint,
                AFD_POLL_RECEIVE,
                STATUS_SUCCESS
                );
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Note to the TDI provider that we didn't take any of the data here.
        //
        // !!! needs bufferring for non-bufferring transports!

        *BytesTaken = 0;

        //
        // If there are any outstanding poll IRPs for this endpoint/
        // event, complete them.
        //
        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicatePollEvent(
                endpoint,
                AFD_POLL_RECEIVE,
                STATUS_SUCCESS
                );
        }

        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;
    }

} // AfdReceiveEventHandler


NTSTATUS
AfdReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )
{
    PAFD_CONNECTION connection;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    BOOLEAN result;

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION (connection, result);
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );


    //
    // Bump the count of bytes indicated on the connection to account for
    // the expedited bytes indicated by this event.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  !IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart =
        connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart +
            BytesAvailable;

    IF_DEBUG(RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdReceiveExpeditedEventHandler: conn %p, bytes %ld, "
                    "ind %ld, taken %ld, out %ld, offset %ld\n",
                    connection, BytesAvailable,
                    connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.LowPart,
                    connection->Common.Bufferring.ReceiveExpeditedBytesTaken.LowPart,
                    connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.LowPart ));
    }

    //
    // If the receive side of the endpoint has been shut down, tell
    // the provider that we took all the data.  Also, account for these
    // bytes in our count of bytes taken from the transport.
    //
    //

    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ) {

        IF_DEBUG(RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdReceiveExpeditedEventHandler: receive shutdown, "
                        "%ld bytes dropped.\n", BytesAvailable ));
        }

        connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart =
            connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                BytesAvailable;

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        *BytesTaken = BytesAvailable;

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        (VOID)AfdBeginAbort( connection );

    } else {

        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicateEventSelectEvent(
                endpoint,
                endpoint->InLine
                    ? AFD_POLL_RECEIVE
                    : AFD_POLL_RECEIVE_EXPEDITED,
                STATUS_SUCCESS
                );
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Note to the TDI provider that we didn't take any of the data here.
        //
        // !!! needs bufferring for non-bufferring transports!

        *BytesTaken = 0;

        //
        // If there are any outstanding poll IRPs for this endpoint/
        // event, complete them.  Indicate this data as normal data if
        // this endpoint is set up for inline reception of expedited
        // data.
        //

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            AfdIndicatePollEvent(
                endpoint,
                endpoint->InLine
                    ? AFD_POLL_RECEIVE
                    : AFD_POLL_RECEIVE_EXPEDITED,
                STATUS_SUCCESS
                );
        }
    }

    DEREFERENCE_CONNECTION (connection);
    return STATUS_DATA_NOT_ACCEPTED;

} // AfdReceiveExpeditedEventHandler


NTSTATUS
AfdQueryReceiveInformation (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
{
    AFD_RECEIVE_INFORMATION receiveInformation;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    LARGE_INTEGER result;
    PAFD_CONNECTION connection;
    NTSTATUS status;

    *Information = 0;

    //
    // Make sure that the output buffer is large enough.
    //

    if ( OutputBufferLength < sizeof(receiveInformation) ) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // If this endpoint has a connection block, use the connection block's
    // information, else use the information from the endpoint itself.
    //

    endpoint = FileObject->FsContext;
    ASSERT( IS_AFD_ENDPOINT_TYPE( endpoint ) );

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    connection = AFD_CONNECTION_FROM_ENDPOINT( endpoint );

    if ( connection != NULL ) {

        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
                endpoint->Type == AfdBlockTypeVcBoth );
        ASSERT( connection->Type == AfdBlockTypeConnection );

        if ( !IS_TDI_BUFFERRING(endpoint) ) {

            receiveInformation.BytesAvailable =
                connection->VcBufferredReceiveBytes;
            receiveInformation.ExpeditedBytesAvailable =
                connection->VcBufferredExpeditedBytes;

        } else {

            //
            // Determine the number of bytes available to be read.
            //

            result.QuadPart =
                connection->Common.Bufferring.ReceiveBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveBytesOutstanding.QuadPart);

            ASSERT( result.HighPart == 0 );

            receiveInformation.BytesAvailable = result.LowPart;

            //
            // Determine the number of expedited bytes available to be read.
            //

            result.QuadPart =
                connection->Common.Bufferring.ReceiveExpeditedBytesIndicated.QuadPart -
                    (connection->Common.Bufferring.ReceiveExpeditedBytesTaken.QuadPart +
                     connection->Common.Bufferring.ReceiveExpeditedBytesOutstanding.QuadPart);

            ASSERT( result.HighPart == 0 );

            receiveInformation.ExpeditedBytesAvailable = result.LowPart;
        }

    } else {

        //
        // Determine the number of bytes available to be read.
        //

        if ( IS_DGRAM_ENDPOINT(endpoint) ) {

            //
            // Return the amount of bytes of datagrams that are
            // bufferred on the endpoint.
            //

            if (endpoint->DgBufferredReceiveBytes>0) {
                receiveInformation.BytesAvailable = endpoint->DgBufferredReceiveBytes;
            }
            else { // Report one byte to the application to prompt it to
                   // read the data if zero-sized datagrams are available.
                receiveInformation.BytesAvailable = endpoint->DgBufferredReceiveCount>0 ? 1 : 0;
            }

        } else {

            //
            // This is an unconnected endpoint, hence no bytes are
            // available to be read.
            //

            receiveInformation.BytesAvailable = 0;
        }

        //
        // Whether this is a datagram endpoint or just unconnected,
        // there are no expedited bytes available.
        //

        receiveInformation.ExpeditedBytesAvailable = 0;
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    try {
        //
        // Validate the output structure if it comes from the user mode
        // application
        //

        if (RequestorMode != KernelMode ) {
            ProbeForWrite (OutputBuffer,
                            sizeof (receiveInformation),
                            PROBE_ALIGNMENT (AFD_RECEIVE_INFORMATION));
        }

        //
        // Copy parameters back to application's memory
        //

        *((PAFD_RECEIVE_INFORMATION)OutputBuffer) = receiveInformation;

    } except( AFD_EXCEPTION_FILTER(&status) ) {

        return status;
    }

    *Information = sizeof(AFD_RECEIVE_INFORMATION);
    return STATUS_SUCCESS;

} // AfdQueryReceiveInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\sources.inc ===
TARGETNAME=afd
TARGETPATH=obj
TARGETTYPE=DRIVER

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_
SOURCES_USED=..\sources.inc

PRECOMPILED_INCLUDE=..\afdp.h
PRECOMPILED_PCH=afdp.pch
PRECOMPILED_OBJ=afdp.obj

TARGETLIBS=$(DDK_LIB_PATH)\tdi.lib

INCLUDES=..\;$(BASE_INC_PATH)

SOURCES=\
    ..\accept.c     \
    ..\afd.rc       \
    ..\afddata.c    \
    ..\bind.c       \
    ..\blkconn.c    \
    ..\blkendp.c    \
    ..\buffer.c     \
    ..\close.c      \
    ..\connect.c    \
    ..\create.c     \
    ..\disconn.c    \
    ..\dispatch.c   \
    ..\eventsel.c   \
    ..\fastio.c     \
    ..\group.c      \
    ..\init.c       \
    ..\listen.c     \
    ..\misc.c       \
    ..\pnp.c        \
    ..\poll.c       \
    ..\receive.c    \
    ..\recvdg.c     \
    ..\recvvc.c     \
    ..\send.c       \
    ..\tpackets.c	\
	..\san.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\recvvc.c ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    recvvc.c

Abstract:

    This module contains routines for handling data receive for connection-
    oriented endpoints on non-buffering TDI transports.

Author:

    David Treadwell (davidtr)    21-Oct-1993

Revision History:
    Vadim Eydelman (vadime)
        1998-1999 NT5.0 low-memory tolerance and perf changes

--*/

#include "afdp.h"

VOID
AfdCancelReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PIRP
AfdGetPendedReceiveIrp (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN Expedited
    );

NTSTATUS
AfdRestartBufferReceiveWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


ULONG
AfdBFillPendingIrps (
    PAFD_CONNECTION     Connection,
    PMDL                Mdl,
    ULONG               DataOffset,
    ULONG               DataLength,
    ULONG               Flags,
    PLIST_ENTRY         CompleteIrpListHead
    );

#define AFD_RECEIVE_STREAM  0x80000000
C_ASSERT (AFD_RECEIVE_STREAM!=TDI_RECEIVE_ENTIRE_MESSAGE);
C_ASSERT (AFD_RECEIVE_STREAM!=TDI_RECEIVE_EXPEDITED);

#define AFD_RECEIVE_CHAINED 0x40000000
C_ASSERT (AFD_RECEIVE_CHAINED!=TDI_RECEIVE_ENTIRE_MESSAGE);
C_ASSERT (AFD_RECEIVE_CHAINED!=TDI_RECEIVE_EXPEDITED);


PAFD_BUFFER_HEADER
AfdGetReceiveBuffer (
    IN PAFD_CONNECTION Connection,
    IN ULONG ReceiveFlags,
    IN PAFD_BUFFER_HEADER StartingAfdBuffer OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGEAFD, AfdBReceive )
#pragma alloc_text( PAGEAFD, AfdBReceiveEventHandler )
#pragma alloc_text( PAGEAFD, AfdBReceiveExpeditedEventHandler )
#pragma alloc_text( PAGEAFD, AfdCancelReceive )
#pragma alloc_text( PAGEAFD, AfdGetPendedReceiveIrp )
#pragma alloc_text( PAGEAFD, AfdGetReceiveBuffer )
#pragma alloc_text( PAGEAFD, AfdRestartBufferReceive )
#pragma alloc_text( PAGEAFD, AfdRestartBufferReceiveWithUserIrp )
#pragma alloc_text( PAGEAFD, AfdLRRepostReceive)
#pragma alloc_text( PAGEAFD, AfdBChainedReceiveEventHandler )
#pragma alloc_text( PAGEAFD, AfdBFillPendingIrps )
#endif


//
// Macros to make the send restart code more maintainable.
//

#define AfdRestartRecvInfo  DeviceIoControl
#define AfdRecvFlags        IoControlCode
#define AfdOriginalLength   OutputBufferLength
#define AfdCurrentLength    InputBufferLength
#define AfdAdjustedLength   Type3InputBuffer



NTSTATUS
AfdBReceive (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG RecvFlags,
    IN ULONG AfdFlags,
    IN ULONG RecvLength
    )
{
    NTSTATUS status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT endpoint;
    PAFD_CONNECTION connection;
    ULONG bytesReceived;
    BOOLEAN peek;
    PAFD_BUFFER_HEADER afdBuffer;
    BOOLEAN completeMessage;
    BOOLEAN partialReceivePossible;
    PAFD_BUFFER newAfdBuffer;

    //
    // Set up some local variables.
    //

    endpoint = IrpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );
    connection = NULL;

    //
    // Determine if this is a peek operation.
    //

    ASSERT( ( RecvFlags & TDI_RECEIVE_EITHER ) != 0 );
    ASSERT( ( RecvFlags & TDI_RECEIVE_EITHER ) != TDI_RECEIVE_EITHER );

    peek = ( RecvFlags & TDI_RECEIVE_PEEK ) != 0;

    //
    // Determine whether it is legal to complete this receive with a
    // partial message.
    //

    if ( !IS_MESSAGE_ENDPOINT(endpoint)) {

        partialReceivePossible = TRUE;

    } else {

        if ( (RecvFlags & TDI_RECEIVE_PARTIAL) != 0 ) {
            partialReceivePossible = TRUE;
        } else {
            partialReceivePossible = FALSE;
        }
    }

    //
    // Reset the InputBufferLength field of our stack location.  We'll
    // use this to keep track of how much data we've placed into the IRP
    // so far.
    //

    IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength = 0;
    Irp->IoStatus.Information = 0;

    //
    // If this is an inline endpoint, then either type of receive data
    // can be used to satisfy this receive.
    //

    if ( endpoint->InLine ) {
        RecvFlags |= TDI_RECEIVE_EITHER;
    }

    newAfdBuffer = NULL;
    //
    // Try to get data already bufferred on the connection to satisfy
    // this receive.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if endpoint was cleaned-up and cancel the request.
    //
    if (endpoint->EndpointCleanedUp) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CANCELLED;
        goto complete;
    }

    connection = endpoint->Common.VcConnecting.Connection;
    if (connection==NULL) {
        //
        // connection might have been cleaned up by transmit file.
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_CONNECTION;
        goto complete;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    //
    // Check whether the remote end has aborted the connection, in which
    // case we should complete the receive.
    //

    if ( connection->AbortIndicated ) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = STATUS_CONNECTION_RESET;
        goto complete;
    }

    if( RecvFlags & TDI_RECEIVE_EXPEDITED ) {
        endpoint->EventsActive &= ~AFD_POLL_RECEIVE_EXPEDITED;
    }

    if( RecvFlags & TDI_RECEIVE_NORMAL ) {
        endpoint->EventsActive &= ~AFD_POLL_RECEIVE;
    }

    IF_DEBUG(EVENT_SELECT) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
            "AfdBReceive: Endp %p, Active %lx\n",
            endpoint,
            endpoint->EventsActive
            ));
    }

    afdBuffer = AfdGetReceiveBuffer( connection, RecvFlags, NULL);

    while ( afdBuffer != NULL ) {

        //
        // Copy the data to the MDL in the IRP.  
        //


        if ( Irp->MdlAddress != NULL ) {

            if (IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0) {
                //
                // First time through the loop - make sure we can map the 
                // entire buffer. We can't afford failing on second entry
                // to the loop as we may loose the data we copied on
                // the first path.
                //
                status = AfdMapMdlChain (Irp->MdlAddress);
                if (!NT_SUCCESS (status)) {
                    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
                    goto complete;
                }
            }

            ASSERTMSG (
                "NIC Driver freed the packet before it was returned!!!",
                !afdBuffer->NdisPacket ||
                    (MmIsAddressValid (afdBuffer->Context) &&
                     MmIsAddressValid (MmGetSystemAddressForMdl (afdBuffer->Mdl))) );

            status = AfdCopyMdlChainToMdlChain (
                        Irp->MdlAddress,
                        IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength,
                        afdBuffer->Mdl,
                        afdBuffer->DataOffset,
                        afdBuffer->DataLength,
                        &bytesReceived
                        );

        } else {

            if ( afdBuffer->DataLength == 0 ) {
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_OVERFLOW;
            }

            bytesReceived = 0;
        }

        ASSERT( status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW );

        ASSERT( afdBuffer->PartialMessage == TRUE || afdBuffer->PartialMessage == FALSE );

        completeMessage = !afdBuffer->PartialMessage;

        //
        // If this wasn't a peek IRP, update information on the
        // connection based on whether the entire buffer of data was
        // taken.
        //

        if ( !peek ) {

            //
            // If all the data in the buffer was taken, remove the buffer
            // from the connection's list and return it to the buffer pool.
            //

            if (status == STATUS_SUCCESS) {

                ASSERT(afdBuffer->DataLength == bytesReceived);

                //
                // Update the counts of bytes bufferred on the connection.
                //

                if ( afdBuffer->ExpeditedData ) {

                    ASSERT( connection->VcBufferredExpeditedBytes >= bytesReceived );
                    ASSERT( connection->VcBufferredExpeditedCount > 0 );

                    connection->VcBufferredExpeditedBytes -= bytesReceived;
                    connection->VcBufferredExpeditedCount -= 1;

                    afdBuffer->ExpeditedData = FALSE;

                } else {

                    ASSERT( connection->VcBufferredReceiveBytes >= bytesReceived );
                    ASSERT( connection->VcBufferredReceiveCount > 0 );

                    connection->VcBufferredReceiveBytes -= bytesReceived;
                    connection->VcBufferredReceiveCount -= 1;
                }

                RemoveEntryList( &afdBuffer->BufferListEntry );
                DEBUG afdBuffer->BufferListEntry.Flink = NULL;
                if (afdBuffer->RefCount==1 || // Can't change once off the list
                        InterlockedDecrement (&afdBuffer->RefCount)==0) {
                    AfdReturnBuffer( afdBuffer, connection->OwningProcess );
                }

                //
                // Reset the afdBuffer local so that we know that the
                // buffer is gone.
                //

                afdBuffer = NULL;

            } else {

                //
                // Update the counts of bytes bufferred on the connection.
                //

                if ( afdBuffer->ExpeditedData ) {
                    ASSERT( connection->VcBufferredExpeditedBytes >= bytesReceived );
                    connection->VcBufferredExpeditedBytes -= bytesReceived;
                } else {
                    ASSERT( connection->VcBufferredReceiveBytes >= bytesReceived );
                    connection->VcBufferredReceiveBytes -= bytesReceived;
                }

                //
                // Not all of the buffer's data was taken. Update the
                // counters in the AFD buffer structure to reflect the
                // amount of data that was actually received.
                //
                ASSERT(afdBuffer->DataLength > bytesReceived);

                afdBuffer->DataOffset += bytesReceived;
                afdBuffer->DataLength -= bytesReceived;

                ASSERT( afdBuffer->BufferLength==AfdBufferTagSize
                        || afdBuffer->DataOffset < afdBuffer->BufferLength );
            }

            //
            // If there is indicated but unreceived data in the TDI
            // provider, and we have available buffer space, fire off an
            // IRP to receive the data.
            //

            if ( connection->VcReceiveBytesInTransport > 0

                 &&

                 connection->VcBufferredReceiveBytes <
                   connection->MaxBufferredReceiveBytes

                     ) {

                ULONG bytesToReceive;

                //
                // Remember the count of data that we're going to
                // receive, then reset the fields in the connection
                // where we keep track of how much data is available in
                // the transport.  We reset it here before releasing the
                // lock so that another thread doesn't try to receive
                // the data at the same time as us.
                //

                if ( connection->VcReceiveBytesInTransport > AfdLargeBufferSize ) {
                    bytesToReceive = connection->VcReceiveBytesInTransport;
                } else {
                    bytesToReceive = AfdLargeBufferSize;
                }

                //
                // Get an AFD buffer structure to hold the data.
                //

                ASSERT (newAfdBuffer==NULL);
                newAfdBuffer = AfdGetBuffer( bytesToReceive, 0,
                                        connection->OwningProcess );
                if ( newAfdBuffer != NULL) {

                    connection->VcReceiveBytesInTransport = 0;
                    ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);

                    //
                    // We need to remember the connection in the AFD buffer
                    // because we'll need to access it in the completion
                    // routine.
                    //

                    newAfdBuffer->Context = connection;

                    //
                    // Acquire connection reference to be released in completion routine
                    //

                    REFERENCE_CONNECTION (connection);

                    //
                    // Finish building the receive IRP to give to the TDI
                    // provider.
                    //

                    TdiBuildReceive(
                        newAfdBuffer->Irp,
                        connection->DeviceObject,
                        connection->FileObject,
                        AfdRestartBufferReceive,
                        newAfdBuffer,
                        newAfdBuffer->Mdl,
                        TDI_RECEIVE_NORMAL,
                        bytesToReceive
                        );

                    //
                    // Wait to hand off the IRP until we can safely release
                    // the endpoint lock.
                    //
                }
                else {
                    if (connection->VcBufferredReceiveBytes == 0 &&
                            !connection->OnLRList) {
                        //
                        // Since we do not have any data buffered, application
                        // is not notified and will never call with recv.
                        // We will have to put this on low resource list
                        // and attempt to allocate memory and pull the data
                        // later.
                        //
                        connection->OnLRList = TRUE;
                        REFERENCE_CONNECTION (connection);
                        AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
                    }
                }
            }
        }


        //
        // Update the count of bytes we've received so far into the IRP,
        // and see if we can get another buffer of data to continue.
        //

        IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength += bytesReceived;
        afdBuffer = AfdGetReceiveBuffer( connection, RecvFlags, afdBuffer );

        //
        // We've set up all return information.  If we got a full
        // message OR if we can complete with a partial message OR if
        // the IRP is full of data, clean up and complete the IRP.
        //

        if ( IS_MESSAGE_ENDPOINT (endpoint) && completeMessage 

                    ||

                status == STATUS_BUFFER_OVERFLOW 

                    || 

                (partialReceivePossible 
                        && 
                    ((RecvLength==IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength)
                            ||
                        (afdBuffer==NULL))
                     )
                    ) {

            if( RecvFlags & TDI_RECEIVE_NORMAL ) {
                if (IS_DATA_ON_CONNECTION( connection )) {

                    ASSERT (endpoint->DisableFastIoRecv==FALSE);

                    AfdIndicateEventSelectEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );

                }
                else {
                    //
                    // Disable fast IO path to avoid performance penalty
                    // of unneccessarily going through it.
                    //
                    if (!endpoint->NonBlocking)
                        endpoint->DisableFastIoRecv = TRUE;
                }
            }

            if( ( RecvFlags & TDI_RECEIVE_EXPEDITED ) &&
                IS_EXPEDITED_DATA_ON_CONNECTION( connection ) ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    endpoint->InLine
                        ? AFD_POLL_RECEIVE
                        : AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            //
            // For stream type endpoints, it does not make sense to return
            // STATUS_BUFFER_OVERFLOW.  That status is only sensible for
            // message-oriented transports for which we convert it
            // to partial receive status to properly set the flags
            //

            if ( !IS_MESSAGE_ENDPOINT(endpoint) ) {
                status = STATUS_SUCCESS;
            }
            else if (status==STATUS_BUFFER_OVERFLOW || !completeMessage) {
                if (RecvFlags & TDI_RECEIVE_EXPEDITED)
                    status = STATUS_RECEIVE_PARTIAL_EXPEDITED;
                else
                    status = STATUS_RECEIVE_PARTIAL;
            }

            Irp->IoStatus.Information = IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;


            UPDATE_CONN2 (connection, "Irp receive, 0x%lX bytes", (ULONG)Irp->IoStatus.Information);
            goto complete;
        }
    }


    //
    // We should have copied all buffered data of appropriate type
    // to the apps's buffer.
    //
    ASSERT ((!(RecvFlags & TDI_RECEIVE_NORMAL) || (connection->VcBufferredReceiveBytes == 0)) &&
            (!(RecvFlags & TDI_RECEIVE_EXPEDITED) || (connection->VcBufferredExpeditedBytes == 0)));

    //
    // There must be some more space in the buffer if we are here
    // or it could also be a 0-byte recv.
    //
    ASSERT ((RecvLength>IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength)
                || (RecvLength==0));
    //
    // Also, if we could complete with partial data we should have done so.
    //
    ASSERT (IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0 ||
                !partialReceivePossible);
                
    
    //
    // We'll have to pend the IRP.  Remember the receive flags in the
    // IoControlCode field of our IO stack location and make sure
    // we have the length field set (it is no longer done by the IO
    // system because we use METHOD_NEITHER and WSABUFs to pass recv
    // parameters). Initialize adjusted length in case we need to advance
    // the MDL to receive next part of the message
    //

    IrpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags = RecvFlags;
    IrpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength = RecvLength;
    IrpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength = (PVOID)0;


    //
    // If there was no data bufferred on the endpoint and the connection
    // has been disconnected by the remote end, complete the receive
    // with 0 bytes read if this is a stream endpoint, or a failure
    // code if this is a message endpoint.
    //

    if ( IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength == 0 &&
             connection->DisconnectIndicated ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        ASSERT (newAfdBuffer==NULL);

        if ( !IS_MESSAGE_ENDPOINT(endpoint) ) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_GRACEFUL_DISCONNECT;
        }

        goto complete;
    }

    //
    // If this is a nonblocking endpoint and the request was a normal
    // receive (as opposed to a read IRP), fail the request.  We don't
    // fail reads under the asumption that if the application is doing
    // reads they don't want nonblocking behavior.
    //

    if ( IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength == 0 &&
             endpoint->NonBlocking && !( AfdFlags & AFD_OVERLAPPED ) ) {

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        ASSERT (newAfdBuffer==NULL);

        status = STATUS_DEVICE_NOT_READY;
        goto complete;
    }

    //
    // Place the IRP on the connection's list of pended receive IRPs and
    // mark the IRP ad pended.
    //

    InsertTailList(
        &connection->VcReceiveIrpListHead,
        &Irp->Tail.Overlay.ListEntry
        );

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Set up the cancellation routine in the IRP.  If the IRP has already
    // been cancelled, just call the cancellation routine here.
    //

    IoSetCancelRoutine( Irp, AfdCancelReceive );

    if ( Irp->Cancel ) {


        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
        if (IoSetCancelRoutine( Irp, NULL ) != NULL) {

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            if (IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength == 0 ||
                    endpoint->EndpointCleanedUp) {
                status = STATUS_CANCELLED;
                goto complete;
            }
            else {
                //
                // We cannot set STATUS_CANCELLED
                // since we loose data already placed in the IRP.
                //
                Irp->IoStatus.Information = IrpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                UPDATE_CONN2(connection, "Cancelled receive, 0x%lX bytes", (ULONG)Irp->IoStatus.Information);
                status = STATUS_SUCCESS;
                goto complete;
            }
        }
        else {

            //
            // This IRP is about to be canceled.  Set the Flink to NULL 
            // so the cancel routine knows it is not on the list.
            Irp->Tail.Overlay.ListEntry.Flink = NULL;
        }

        //
        // The cancel routine will run and complete the irp.
        //

    }

    IoMarkIrpPending( Irp );

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there was data bufferred in the transport, fire off the IRP to
    // receive it.  We have to wait until here because it is not legal
    // to do an IoCallDriver() while holding a spin lock.
    //

    if ( newAfdBuffer != NULL ) {
        (VOID)IoCallDriver( connection->DeviceObject, newAfdBuffer->Irp );
    }

    return STATUS_PENDING;

complete:
    //
    // If there was data bufferred in the transport, fire off
    // the IRP to receive it.
    //

    if ( newAfdBuffer != NULL ) {
        (VOID)IoCallDriver( connection->DeviceObject, newAfdBuffer->Irp );
    }


    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS (status)) {
        UPDATE_CONN2 (connection, "Receive failed, status: %lX", Irp->IoStatus.Status);
    }

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return status;

} // AfdBReceive




NTSTATUS
AfdBChainedReceiveEventHandler(
    IN PVOID  TdiEventContext,
    IN CONNECTION_CONTEXT  ConnectionContext,
    IN ULONG  ReceiveFlags,
    IN ULONG  ReceiveLength,
    IN ULONG  StartingOffset,
    IN PMDL   Tsdu,
    IN PVOID  TsduDescriptor
    )
/*++

Routine Description:

    Handles chained receive events for nonbufferring transports.

Arguments:


Return Value:


--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER_TAG afdBufferTag;
    LIST_ENTRY      completeIrpListHead;
    PIRP            irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS        status;
    ULONG           offset;
    BOOLEAN         result;

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION2 (connection,"AfdBChainedReceiveEventHandler, receive length:%lx", ReceiveLength, result );
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( !connection->DisconnectIndicated );

    ASSERT( !IS_TDI_BUFFERRING(endpoint) );

#if DBG
    {
        PMDL    tstMdl = Tsdu;
        ULONG   count = 0;
        while (tstMdl) {
            count += MmGetMdlByteCount (tstMdl);
            tstMdl = tstMdl->Next;
        }
        ASSERT (count>=StartingOffset+ReceiveLength);
    }
#endif


#if AFD_PERF_DBG
    AfdFullReceiveIndications++;
#endif
    IF_DEBUG (RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                "AfdBChainedReceiveEventHandler>>: Connection %p, TdsuDescr: %p, Length: %ld.\n",
                connection, TsduDescriptor, ReceiveLength));
    }


    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // If the receive side of the endpoint has been shut down, tell the
    // provider that we took all the data and reset the connection.
    // Same if we are shutting down.
    //

    if ((endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ||
         endpoint->EndpointCleanedUp ) {

        IF_DEBUG (RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBChainedReceiveEventHandler: receive shutdown, "
                    "%ld bytes, aborting endp %p\n",
                        ReceiveLength, endpoint ));
        }

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        (VOID)AfdBeginAbort( connection );

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    if (ReceiveFlags & TDI_RECEIVE_EXPEDITED) {
        //
        // We're being indicated with expedited data.  Buffer it and
        // complete any pended IRPs in the restart routine.  We always
        // buffer expedited data to save complexity and because expedited
        // data is not an important performance case.
        //
        // !!! do we need to perform flow control with expedited data?
        //
        PAFD_BUFFER afdBuffer;
        if (connection->VcBufferredExpeditedCount==MAXUSHORT ||
            (afdBuffer=AfdGetBuffer (ReceiveLength, 0, connection->OwningProcess))==NULL) {
            //
            // If we couldn't get a buffer, abort the connection.  This is
            // pretty brutal, but the only alternative is to attempt to
            // receive the data sometime later, which is very complicated to
            // implement.
            //

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            (VOID)AfdBeginAbort( connection );

            DEREFERENCE_CONNECTION (connection);
            return STATUS_SUCCESS;
        }

        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        status = TdiCopyMdlToBuffer (Tsdu,
                                    StartingOffset, 
                                    afdBuffer->Buffer,
                                    0,
                                    afdBuffer->BufferLength,
                                    &ReceiveLength);
        ASSERT (status==STATUS_SUCCESS);
        //
        // We need to remember the connection in the AFD buffer because
        // we'll need to access it in the completion routine.
        //

        afdBuffer->Context = connection;

        //
        // Remember the type of data that we're receiving.
        //

        afdBuffer->ExpeditedData = TRUE;
        afdBuffer->PartialMessage = (BOOLEAN)((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) == 0);

        afdBuffer->Irp->IoStatus.Status = status;
        afdBuffer->Irp->IoStatus.Information = ReceiveLength;
        status = AfdRestartBufferReceive (AfdDeviceObject, afdBuffer->Irp, afdBuffer);
        ASSERT (status==STATUS_MORE_PROCESSING_REQUIRED);

        return STATUS_SUCCESS;
    }
    //
    // If we are indicated data, we need to reset our record
    // of amount of data buffered by the transport.
    //
    connection->VcReceiveBytesInTransport = 0;

RetryReceive:
    InitializeListHead( &completeIrpListHead );
    offset = AfdBFillPendingIrps (
                                connection,
                                Tsdu,
                                StartingOffset,
                                ReceiveLength,
                                (ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) |
                                    AFD_RECEIVE_CHAINED |
                                    (!IS_MESSAGE_ENDPOINT(endpoint) ? 
                                        AFD_RECEIVE_STREAM : 0),
                                &completeIrpListHead
                                );

    if (offset==(ULONG)-1) {

        //
        // If the IRP had more space than in this packet and this
        // was not set a complete message, we will pass the IRP to
        // the transport and refuse the indicated data (the transport
        // can fill the rest of the IRP).
        //

        //
        // This receive indication cannot be expedited or a complete message
        // becuase it does not make sense to pass the IRP back in such
        // cases.
        //

        ASSERT (!IsListEmpty (&completeIrpListHead));
        ASSERT ((ReceiveFlags & 
            (TDI_RECEIVE_EXPEDITED|TDI_RECEIVE_ENTIRE_MESSAGE))==0);
        ASSERT (!AfdIgnorePushBitOnReceives);

        irp = CONTAINING_RECORD (completeIrpListHead.Flink,
                                            IRP,
                                            Tail.Overlay.ListEntry);
        irpSp = IoGetCurrentIrpStackLocation (irp);
        ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength >
                    ReceiveLength);

        //
        // Reference connection (to be released in restart routine).
        // Keep reference added in the beginning of this routine.
        // REFERENCE_CONNECTION (connection);

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        //
        // Note that we have outstanding user IRP in transport.
        //
        ASSERT (InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==1);

        //
        // IRP is already partially filled.
        //

        if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0) {


            irp->MdlAddress = AfdAdvanceMdlChain (
                            irp->MdlAddress,
                            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength)
                            );

            ASSERT (irp->MdlAddress!=NULL);
            //
            // Remeber the length by which we adjusted MDL, so we know where
            // to start next time.
            //
            irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength =
                    UlongToPtr(irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength);

        }
        //
        // Build the receive IRP to give to the TDI provider.
        //

        TdiBuildReceive(
            irp,
            connection->DeviceObject,
            connection->FileObject,
            AfdRestartBufferReceiveWithUserIrp,
            connection,
            irp->MdlAddress,
            irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags & TDI_RECEIVE_EITHER,
            irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength -
                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
            );

        if (AfdRecordOutstandingIrp (endpoint, connection->DeviceObject, irp)) {
            (VOID)IoCallDriver(connection->DeviceObject, irp );
        }
        else {
            //
            // On debug build, AFD might have complete this IRP if it could not allocate
            // tracking structure.  In this case the transport does not get a call
            // and as the result does not restart indications.  Also, the data already
            // placed in the IRP gets lost.
            //
            // To avoid this, we retry the indication ourselves.
            //
            CHECK_REFERENCE_CONNECTION (connection, result);
            if (result) {
                AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                goto RetryReceive;
            }
        }
        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT (offset-StartingOffset<=ReceiveLength);
    
    //
    // If there is any data left, place the buffer at the end of the
    // connection's list of bufferred data and update counts of data on
    // the connection.
    //
    if (ReceiveLength > offset-StartingOffset) {

        //
        // If offset is not zero we should not have had anything buffered.
        //
        ASSERT (offset==StartingOffset || connection->VcBufferredReceiveCount==0);

        if ( offset>StartingOffset ||
                (connection->VcBufferredReceiveBytes <=
                        connection->MaxBufferredReceiveBytes &&
                    connection->VcBufferredReceiveCount<MAXUSHORT) ){
            //
            // We should attempt to buffer the data.
            //
            afdBufferTag = AfdGetBufferTag (0, connection->OwningProcess);
        }
        else {
            ASSERT (offset==StartingOffset);
            //
            // We are over the limit, don't take the data.
            //
            afdBufferTag = NULL;
        }

        if (afdBufferTag!=NULL) {
            AFD_VERIFY_MDL (connection, Tsdu, StartingOffset, ReceiveLength);
            afdBufferTag->Mdl = Tsdu;
            afdBufferTag->DataLength = ReceiveLength - (offset-StartingOffset);
            afdBufferTag->DataOffset = offset;
            afdBufferTag->RefCount = 1;
            afdBufferTag->Context = TsduDescriptor;
            afdBufferTag->NdisPacket = TRUE;
            afdBufferTag->PartialMessage = (BOOLEAN)((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) == 0);
            InsertTailList(
                &connection->VcReceiveBufferListHead,
                &afdBufferTag->BufferListEntry
                );

            connection->VcBufferredReceiveBytes += afdBufferTag->DataLength;
            ASSERT (connection->VcBufferredReceiveCount<MAXUSHORT);
            connection->VcBufferredReceiveCount += 1;

            endpoint->DisableFastIoRecv = FALSE;
            // Make sure connection was accepted/connected to prevent
            // indication on listening endpoint
            //

            if (connection->State==AfdConnectionStateConnected) {
                ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
            }
            else {
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
            }
            status = STATUS_PENDING;
        }
        else {
            if (offset==StartingOffset) {
                //
                // If no IRPs were pending on the endpoint just remember the 
                // amount of data that is available.  When application
                // reposts the receive, we'll actually pull this data.
                //

                connection->VcReceiveBytesInTransport += ReceiveLength;

                if (connection->VcBufferredReceiveBytes == 0 &&
                        !connection->OnLRList) {
                    //
                    // Since we do not have any data buffered, application
                    // is not notified and will never call with recv.
                    // We will have to put this on low resource list
                    // and attempt to allocate memory and pull the data
                    // later.
                    //
                    connection->OnLRList = TRUE;
                    REFERENCE_CONNECTION (connection);
                    AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
                }
                else {
                    UPDATE_CONN (connection);
                }
            }
            else {
                PLIST_ENTRY listEntry;

                //
                // We need to put back the IRPs that we were going to complete
                //
                listEntry = completeIrpListHead.Blink;
                while ( listEntry!=&completeIrpListHead ) {
                    irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
                    listEntry = listEntry->Blink;

                    // Set up the cancellation routine back in the IRP. 
                    //

                    IoSetCancelRoutine( irp, AfdCancelReceive );

                    if ( !irp->Cancel ) {

                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
                        InsertHeadList (&connection->VcReceiveIrpListHead,
                                            &irp->Tail.Overlay.ListEntry);
                    }
                    else if (IoSetCancelRoutine( irp, NULL ) == NULL) {
                        //
                        // The cancel routine was never called.
                        // Have to handle cancellation here, just let the
                        // IRP remain in completed list and set the
                        // status appropriately keeping in mind that
                        // we cannot complete IRP as cancelled if it
                        // already has some data in it.
                        //
                        irpSp = IoGetCurrentIrpStackLocation (irp);
                        if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength!=0) {
                            ASSERT (!endpoint->EndpointCleanedUp); // checked above.
                            irp->IoStatus.Status = STATUS_SUCCESS;
                            irp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                        }
                        else {
                            irp->IoStatus.Status = STATUS_CANCELLED;
                        }

                    }
                    else {
                        RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            
                        //
                        // The cancel routine is about to be run.
                        // Set the Flink to NULL so the cancel routine knows
                        // it is not on the list 
                        //

                        irp->Tail.Overlay.ListEntry.Flink = NULL;
                    }
                }

                UPDATE_CONN (connection);
            }

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            status = STATUS_DATA_NOT_ACCEPTED;
        }
    }
    else {
        AFD_VERIFY_MDL (connection, Tsdu, StartingOffset, offset-StartingOffset);
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        status = STATUS_SUCCESS;
    }

    while ( !IsListEmpty( &completeIrpListHead ) ) {
        PLIST_ENTRY listEntry;
        listEntry = RemoveHeadList( &completeIrpListHead );
        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        irpSp = IoGetCurrentIrpStackLocation (irp);
        //
        // Copy the data into the IRP if it is not errored out and
        // we accepted the data.
        //
        if (status!=STATUS_DATA_NOT_ACCEPTED && !NT_ERROR (irp->IoStatus.Status)) {
            ULONG bytesCopied;
            if (irp->MdlAddress!=NULL) {
#if DBG
                NTSTATUS    status1 =
#endif
                AfdCopyMdlChainToMdlChain(
                             irp->MdlAddress,
                             irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                             Tsdu,
                             StartingOffset,
                             ReceiveLength,
                             &bytesCopied
                             );
                ASSERT (status1==STATUS_SUCCESS ||
                            status1==STATUS_BUFFER_OVERFLOW);

                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>=bytesCopied);
                irp->IoStatus.Information =
                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength + bytesCopied;
            }
            else {
                bytesCopied = 0;
                ASSERT (irp->IoStatus.Information == 0);
                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0);
                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength==0);
            }

            if ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags& TDI_RECEIVE_PEEK) == 0) {
                StartingOffset += bytesCopied;
                ReceiveLength -= bytesCopied;
            }
        }
        else {
            //
            // Either we failing the irp or we already filled in some data
            // or this irp was for 0 bytes to begin with in which case
            // we just succeed it.
            //
            ASSERT (NT_ERROR (irp->IoStatus.Status) ||
                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength!=0||
                    irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength==0);
        }

        IF_DEBUG (RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdBChainedReceiveEventHandler: endpoint: %p, completing IRP: %p, status %lx, info: %ld.\n",
                        endpoint,
                        irp, 
                        irp->IoStatus.Status,
                        irp->IoStatus.Information));
        }
        UPDATE_CONN2(connection, "Completing chained receive with error/bytes read: 0x%lX",
                            (!NT_ERROR(irp->IoStatus.Status)
                                    ? (ULONG)irp->IoStatus.Information
                                    : (ULONG)irp->IoStatus.Status));
        IoCompleteRequest( irp, AfdPriorityBoost );
    }


    DEREFERENCE_CONNECTION (connection);
    IF_DEBUG (RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdBChainedReceiveEventHandler<<: %ld\n", status));
    }

    return status;
}




NTSTATUS
AfdBReceiveEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    Handles receive events for nonbufferring transports.

Arguments:


Return Value:


--*/

{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER     afdBuffer;
    PIRP            irp;
    PLIST_ENTRY     listEntry;
    ULONG           requiredAfdBufferSize;
    NTSTATUS        status;
    ULONG           receiveLength;
    BOOLEAN         expedited;
    BOOLEAN         completeMessage, result;

    DEBUG receiveLength = 0xFFFFFFFF;

    connection = (PAFD_CONNECTION)ConnectionContext;
    ASSERT( connection != NULL );

    CHECK_REFERENCE_CONNECTION2 (connection,"AfdBReceiveEventHandler, bytes available: %lx", BytesAvailable, result );
    if (!result) {
        return STATUS_DATA_NOT_ACCEPTED;
    }

    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint != NULL );

    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );
    ASSERT( !connection->DisconnectIndicated );

    ASSERT( !IS_TDI_BUFFERRING(endpoint) );
    ASSERT( IS_VC_ENDPOINT (endpoint) );

    *BytesTaken = 0;

#if AFD_PERF_DBG
    if ( BytesAvailable == BytesIndicated ) {
        AfdFullReceiveIndications++;
    } else {
        AfdPartialReceiveIndications++;
    }
#endif

    //
    // Figure out whether this is a receive indication for normal
    // or expedited data, and whether this is a complete message.
    //

    expedited = (BOOLEAN)( (ReceiveFlags & TDI_RECEIVE_EXPEDITED) != 0 );

    completeMessage = (BOOLEAN)((ReceiveFlags & TDI_RECEIVE_ENTIRE_MESSAGE) != 0);

    //
    // If the receive side of the endpoint has been shut down, tell the
    // provider that we took all the data and reset the connection.
    // Also, account for these bytes in our count of bytes taken from
    // the transport.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connection is referenced, so it is safe to 
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }


    if ( (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ||
         endpoint->EndpointCleanedUp ) {

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                    "AfdBReceiveEventHandler: receive shutdown, "
                    "%ld bytes, aborting endp %p\n",
                    BytesAvailable, endpoint ));

        *BytesTaken = BytesAvailable;

        //
        // Abort the connection.  Note that if the abort attempt fails
        // we can't do anything about it.
        //

        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

        (VOID)AfdBeginAbort( connection );

        DEREFERENCE_CONNECTION (connection);
        return STATUS_SUCCESS;
    }

    //
    // If we are indicated data, we need to reset our record
    // of amount of data buffered by the transport.
    //
    connection->VcReceiveBytesInTransport = 0;

    //
    // Check whether there are any IRPs waiting on the connection.  If
    // there is such an IRP and normal data is being indicated, use the
    // IRP to receive the data.
    //


    if ( !expedited ) {

        while (!IsListEmpty( &connection->VcReceiveIrpListHead )) {
            PIO_STACK_LOCATION irpSp;

            ASSERT( *BytesTaken == 0 );

            listEntry = RemoveHeadList( &connection->VcReceiveIrpListHead );

            //
            // Get a pointer to the IRP and our stack location in it
            //

            irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

            irpSp = IoGetCurrentIrpStackLocation( irp );

            receiveLength = irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
            //
            // If the IRP is not large enough to hold the available data, or
            // if it is a peek or expedited (exclusively, not both normal and 
            // expedited) receive IRP,  then we'll just buffer the
            // data manually and complete the IRP in the receive completion
            // routine.
            //

            if ( (receiveLength>=BytesAvailable) &&
                ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                        & TDI_RECEIVE_PEEK) == 0) &&
                  ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags
                        & TDI_RECEIVE_NORMAL) != 0)) {

                if ( IoSetCancelRoutine( irp, NULL ) == NULL ) {

                    //
                    // This IRP is about to be canceled.  Look for another in the
                    // list.  Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    irp->Tail.Overlay.ListEntry.Flink = NULL;
                    continue;
                }

                 //
                // If all of the data was indicated to us here AND this is a
                // complete message in and of itself, then just copy the
                // data to the IRP and complete the IRP.
                //

                if ( completeMessage &&
                        (BytesIndicated == BytesAvailable)) {

                    AFD_VERIFY_BUFFER (connection, Tsdu, BytesAvailable);


                    //
                    // The IRP is off the endpoint's list and is no longer
                    // cancellable.  We can release the locks we hold.
                    //

                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                    //
                    // Copy the data to the IRP.
                    //

                    if ( irp->MdlAddress != NULL ) {

                        status = AfdMapMdlChain (irp->MdlAddress);
                        if (NT_SUCCESS (status)) {
                            status = TdiCopyBufferToMdl(
                                         Tsdu,
                                         0,
                                         BytesAvailable,
                                         irp->MdlAddress,
                                         irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                            - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                                         &receiveLength
                                         );
                            irp->IoStatus.Information =
                                receiveLength + irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                            ASSERT (status == STATUS_SUCCESS);
                        }
                        else {
                            irp->IoStatus.Status = status;
                            irp->IoStatus.Information = 0;

                            UPDATE_CONN(connection);
                            IoCompleteRequest (irp, AfdPriorityBoost);
                            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                            continue;
                        }
                    } else {
                        ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength==0);
                        ASSERT ( BytesAvailable == 0 );
                        irp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                    }

                    //
                    // We have already set up the status field of the IRP
                    // when we pended the IRP, so there's no need to
                    // set it again here.
                    //
                    ASSERT( irp->IoStatus.Status == STATUS_SUCCESS );

                    //
                    // Complete the IRP.
                    //

                    IF_DEBUG (RECEIVE) {
                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                    "AfdBReceiveEventHandler: endpoint: %p, completing IRP: %p, status %lx, info: %ld.\n",
                                    endpoint,
                                    irp, 
                                    irp->IoStatus.Status,
                                    irp->IoStatus.Information));
                    }
                    UPDATE_CONN2(connection, "Completing receive with error/bytes: 0x%lX",
                                            (!NT_ERROR(irp->IoStatus.Status)
                                                ? (ULONG)irp->IoStatus.Information
                                                : (ULONG)irp->IoStatus.Status));
                    IoCompleteRequest( irp, AfdPriorityBoost );

                    DEREFERENCE_CONNECTION (connection);
                    //
                    // Set BytesTaken  to tell the provider that we have taken all the data.
                    //

                    *BytesTaken = BytesAvailable;
                    return STATUS_SUCCESS;
                }

                //
                // Some of the data was not indicated, so remember that we
                // want to pass back this IRP to the TDI provider.  Passing
                // back this IRP directly is good because it avoids having
                // to copy the data from one of our buffers into the user's
                // buffer.
                //
                AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

                ASSERT (InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==1);

                requiredAfdBufferSize = 0;

                if (AfdIgnorePushBitOnReceives ||
                        IS_TDI_MESSAGE_MODE(endpoint)) {
                    receiveLength = BytesAvailable;
                }

                if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0) {
                    irp->MdlAddress = AfdAdvanceMdlChain (irp->MdlAddress,
                        irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                        -PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength)
                        );
                    ASSERT (irp->MdlAddress!=NULL);
                    irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength =
                            UlongToPtr(irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength);
                }

                TdiBuildReceive(
                    irp,
                    connection->DeviceObject,
                    connection->FileObject,
                    AfdRestartBufferReceiveWithUserIrp,
                    connection,
                    irp->MdlAddress,
                    ReceiveFlags & TDI_RECEIVE_EITHER,
                    receiveLength
                    );
                if (AfdRecordOutstandingIrp (endpoint, connection->DeviceObject, irp)) {
                    //
                    // Make the next stack location current.  Normally IoCallDriver would
                    // do this, but since we're bypassing that, we do it directly.
                    //

                    IoSetNextIrpStackLocation( irp );

                    *IoRequestPacket = irp;
                    ASSERT (*BytesTaken == 0);

                    //
                    // Keep connection reference to be released in IRP completion routine
                    //

                    return STATUS_MORE_PROCESSING_REQUIRED;
                }
                else {

                    //
                    // Could not allocate IRP tracking info (only in debug builds)
                    // The IRP has aready been completed, go and try another one.
                    // Add extra reference to the connection to compensate for
                    // the one released in the completion routine.
                    //

                    CHECK_REFERENCE_CONNECTION (connection,result);
                    if (result) {
                        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
                        continue;
                    }
                    else
                        return STATUS_DATA_NOT_ACCEPTED;
                }
            }


            //
            // The first pended IRP is too tiny to hold all the
            // available data or else it is a peek or expedited receive
            // IRP.  Put the IRP back on the head of the list and buffer
            // the data and complete the IRP in the restart routine.
            //


            InsertHeadList(
                &connection->VcReceiveIrpListHead,
                &irp->Tail.Overlay.ListEntry
                );
            break;
        }

        //
        // Check whether we've already bufferred the maximum amount of
        // data that we'll allow ourselves to buffer for this
        // connection.  If we're at the limit, then we need to exert
        // back pressure by not accepting this indicated data (flow
        // control).
        //
        // Note that we have no flow control mechanisms for expedited
        // data.  We always accept any expedited data that is indicated
        // to us.
        //

        if ( connection->VcBufferredReceiveBytes >=
               connection->MaxBufferredReceiveBytes ||
               connection->VcBufferredReceiveCount==MAXUSHORT
                 ) {

            //
            // Just remember the amount of data that is available.  When
            // buffer space frees up, we'll actually receive this data.
            //

            connection->VcReceiveBytesInTransport += BytesAvailable;

            AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

            DEREFERENCE_CONNECTION (connection);
            return STATUS_DATA_NOT_ACCEPTED;
        }

        // There were no prepended IRPs, we'll have to buffer the data
        // here in AFD.  If all of the available data is being indicated
        // to us AND this is a complete message, just copy the data
        // here.
        //


        if ( completeMessage && 
                BytesIndicated == BytesAvailable  && 
                IsListEmpty (&connection->VcReceiveIrpListHead)) {
            afdBuffer = AfdGetBuffer( BytesAvailable, 0,
                                        connection->OwningProcess );
            if (afdBuffer!=NULL) {

                AFD_VERIFY_BUFFER (connection, Tsdu, BytesAvailable);
                //
                // Use the special function to copy the data instead of
                // RtlCopyMemory in case the data is coming from a special
                // place (DMA, etc.) which cannot work with RtlCopyMemory.
                //

                TdiCopyLookaheadData(
                    afdBuffer->Buffer,
                    Tsdu,
                    BytesAvailable,
                    ReceiveFlags
                    );

                //
                // Store the data length and set the offset to 0.
                //

                afdBuffer->DataLength = BytesAvailable;
                afdBuffer->DataOffset = 0;
                afdBuffer->RefCount = 1;

                afdBuffer->PartialMessage = FALSE;

                //
                // Place the buffer on this connection's list of bufferred data
                // and update the count of data bytes on the connection.
                //

                InsertTailList(
                    &connection->VcReceiveBufferListHead,
                    &afdBuffer->BufferListEntry
                    );

                connection->VcBufferredReceiveBytes += BytesAvailable;
                ASSERT (connection->VcBufferredReceiveCount<MAXUSHORT);
                connection->VcBufferredReceiveCount += 1;

                //
                // All done.  Release the lock and tell the provider that we
                // took all the data.
                //

                *BytesTaken = BytesAvailable;

                //
                // Indicate that it is possible to receive on the endpoint now.
                //

                endpoint->DisableFastIoRecv = FALSE;

                // Make sure connection was accepted/connected to prevent
                // indication on listening endpoint
                //

                if (connection->State==AfdConnectionStateConnected) {
                    ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
                    AfdIndicateEventSelectEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                    AfdIndicatePollEvent(
                        endpoint,
                        AFD_POLL_RECEIVE,
                        STATUS_SUCCESS
                        );
                }
                else {
                    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
                }

                DEREFERENCE_CONNECTION (connection);
                return STATUS_SUCCESS;
            }
        }
        else {

            //
            // There were no prepended IRPs and not all of the data was
            // indicated to us.  We'll have to buffer it by handing an IRP
            // back to the TDI privider.
            //
            // Note that in this case we sometimes hand a large buffer to
            // the TDI provider.  We do this so that it can hold off
            // completion of our IRP until it gets EOM or the buffer is
            // filled.  This reduces the number of receive indications that
            // the TDI provider has to perform and also reduces the number
            // of kernel/user transitions the application will perform
            // because we'll tend to complete receives with larger amounts
            // of data.
            //
            // We do not hand back a "large" AFD buffer if the indicated data
            // is greater than the large buffer size or if the TDI provider
            // is message mode.  The reason for not giving big buffers back
            // to message providers is that they will hold on to the buffer
            // until a full message is received and this would be incorrect
            // behavior on a SOCK_STREAM.
            //


            if ( AfdLargeBufferSize >= BytesAvailable &&
                    !AfdIgnorePushBitOnReceives &&
                    !IS_TDI_MESSAGE_MODE(endpoint) ) {
                requiredAfdBufferSize = AfdLargeBufferSize;
                receiveLength = AfdLargeBufferSize;
            } else {
                requiredAfdBufferSize = BytesAvailable;
                receiveLength = BytesAvailable;
            }

            //
            // We're able to buffer the data.  First acquire a buffer of
            // appropriate size.
            //

            afdBuffer = AfdGetBuffer( requiredAfdBufferSize, 0,
                                            connection->OwningProcess );
            if ( afdBuffer != NULL ) {
                //
                // Note that we posted our own receive IRP to transport,
                // so that user IRPs do not get forwarded there
                //
                ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);
                goto FormatReceive;
            }
        }

        // We failed to allocate the buffer.
        // Just remember the amount of data that is available.  When
        // buffer space frees up, we'll actually receive this data.
        //

        connection->VcReceiveBytesInTransport += BytesAvailable;

        if (connection->VcBufferredReceiveBytes == 0 &&
                !connection->OnLRList) {
            //
            // Since we do not have any data buffered, application
            // is not notified and will never call with recv.
            // We will have to put this on low resource list
            // and attempt to allocate memory and pull the data
            // later.
            //
            connection->OnLRList = TRUE;
            REFERENCE_CONNECTION (connection);
            AfdLRListAddItem (&connection->LRListItem, AfdLRRepostReceive);
        }
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
    
        DEREFERENCE_CONNECTION (connection);
        return STATUS_DATA_NOT_ACCEPTED;

    } else {

        //
        // We're being indicated with expedited data.  Buffer it and
        // complete any pended IRPs in the restart routine.  We always
        // buffer expedited data to save complexity and because expedited
        // data is not an important performance case.
        //
        // !!! do we need to perform flow control with expedited data?
        //

        requiredAfdBufferSize = BytesAvailable;
        receiveLength = BytesAvailable;
        //
        // We're able to buffer the data.  First acquire a buffer of
        // appropriate size.
        //

        if ( connection->VcBufferredExpeditedCount==MAXUSHORT ||
                (afdBuffer=AfdGetBuffer (requiredAfdBufferSize, 0,
                                        connection->OwningProcess))== NULL ) {
            // If we couldn't get a buffer, abort the connection.  This is
            // pretty brutal, but the only alternative is to attempt to
            // receive the data sometime later, which is very complicated to
            // implement.
            //

            AfdBeginAbort( connection );

            *BytesTaken = BytesAvailable;
    
            DEREFERENCE_CONNECTION (connection);
            return STATUS_SUCCESS;
        }
    }

FormatReceive:

    //
    // We'll have to format up an IRP and give it to the provider to
    // handle.  We don't need any locks to do this--the restart routine
    // will check whether new receive IRPs were pended on the endpoint.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    ASSERT (afdBuffer!=NULL);

    //
    // Use the IRP in the AFD buffer if appropriate.  If userIrp is
    // TRUE, then the local variable irp will already point to the
    // user's IRP which we'll use for this IO.
    //

    irp = afdBuffer->Irp;
    ASSERT( afdBuffer->Mdl == irp->MdlAddress );

    //
    // We need to remember the connection in the AFD buffer because
    // we'll need to access it in the completion routine.
    //

    afdBuffer->Context = connection;

    //
    // Remember the type of data that we're receiving.
    //

    afdBuffer->ExpeditedData = expedited;
    afdBuffer->PartialMessage = !completeMessage;

    TdiBuildReceive(
        irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartBufferReceive,
        afdBuffer,
        irp->MdlAddress,
        ReceiveFlags & TDI_RECEIVE_EITHER,
        receiveLength
        );


    //
    // Finish building the receive IRP to give to the TDI provider.
    //

    ASSERT( receiveLength != 0xFFFFFFFF );


    //
    // Make the next stack location current.  Normally IoCallDriver would
    // do this, but since we're bypassing that, we do it directly.
    //

    IoSetNextIrpStackLocation( irp );

    *IoRequestPacket = irp;
    ASSERT (*BytesTaken == 0);

    //
    // Keep connection reference to be released in IRP completion routine
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdBReceiveEventHandler


NTSTATUS
AfdBReceiveExpeditedEventHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,
    OUT PIRP *IoRequestPacket
    )

/*++

Routine Description:

    Handles receive expedited events for nonbufferring transports.

Arguments:


Return Value:


--*/

{
    return AfdBReceiveEventHandler (
               TdiEventContext,
               ConnectionContext,
               ReceiveFlags | TDI_RECEIVE_EXPEDITED,
               BytesIndicated,
               BytesAvailable,
               BytesTaken,
               Tsdu,
               IoRequestPacket
               );

} // AfdBReceiveExpeditedEventHandler


NTSTATUS
AfdRestartBufferReceiveWithUserIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of bufferred receives that were started in the
    receive indication handler or receive routine with application
    IRP passed directly to the transport.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - connection on which we receive the data

Return Value:

    STATUS_SUCCESS if user IRP is completed,
    STATUS_MORE_PROCESSING_REQUIRED if we can't complete it.
--*/

{
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIO_STACK_LOCATION  irpSp;


    //
    // The IRP being completed is actually a user's IRP, set it up
    // for completion and allow IO completion to finish.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    connection = Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth);
    ASSERT( IS_VC_ENDPOINT(endpoint) );
    ASSERT( !IS_TDI_BUFFERRING(endpoint) );

    AfdCompleteOutstandingIrp (endpoint, Irp);

    //
    // We could not have any buffered data if we are completing user
    // IRP
    // Only true for expedited data.  We sometimes give user Irp
    // to only be filled with some of the available data.
    //
    // ASSERT( !(irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags&TDI_RECEIVE_NORMAL)
    //            || !IS_DATA_ON_CONNECTION( connection ));

    ASSERT( !(irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags&TDI_RECEIVE_EXPEDITED)
                || !IS_EXPEDITED_DATA_ON_CONNECTION( connection ));

    AFD_VERIFY_MDL (connection, Irp->MdlAddress, 0, Irp->IoStatus.Information);

    ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)>=0);


    //
    // If pending has be returned for this IRP then mark the current
    // stack as pending.
    //

    if ( Irp->PendingReturned ) {
        IoMarkIrpPending( Irp );
    }


    UPDATE_CONN2 (connection, "Completing user receive with error/bytes: 0x%lX", 
                 !NT_ERROR (Irp->IoStatus.Status)
                     ? (ULONG)Irp->IoStatus.Information
                     : (ULONG)Irp->IoStatus.Status);

    //
    // If transport cancelled the IRP and we already had some data
    // in it, do not complete with STATUS_CANCELLED since this will
    // result in data loss.
    //

    if (Irp->IoStatus.Status==STATUS_CANCELLED &&
            irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength>0 &&
            !endpoint->EndpointCleanedUp) {
        Irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
    }
    else if (!NT_ERROR (Irp->IoStatus.Status)) {
        Irp->IoStatus.Information += irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
    }

    if (Irp->IoStatus.Status==STATUS_BUFFER_OVERFLOW ||
            Irp->IoStatus.Status == STATUS_RECEIVE_PARTIAL ||
            Irp->IoStatus.Status == STATUS_RECEIVE_PARTIAL_EXPEDITED) {
        if (!IS_MESSAGE_ENDPOINT(endpoint)) {
            //
            // For stream endpoint partial message does not make
            // sense (unless this is the special hack for transports that
            // terminate the connection when we cancel IRPs), ignore it.
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        else if ((Irp->IoStatus.Information
                    <irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength) &&
                ((irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags & TDI_RECEIVE_PARTIAL) == 0 )) {
            NTSTATUS        status = STATUS_MORE_PROCESSING_REQUIRED;


            AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);


            //
            // Reset the status to success if we need to complete the IRP
            // This is not entirely correct for message endpoints since
            // we should not be completing the IRP unless we received the
            // entire message.  However, the only way this can happen is
            // when the part of the message was received as IRP is cancelled
            // and the only other this we possibly do is to try to copy data
            // in our own buffer and reinsert it back to the queue.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Set up the cancellation routine back in the IRP. 
            //

            IoSetCancelRoutine( Irp, AfdCancelReceive );

            if ( Irp->Cancel ) {

                if (IoSetCancelRoutine( Irp, NULL ) != NULL) {

                    //
                    // Completion routine has not been reset,
                    // let the system complete the IRP on return
                    //
                    status = STATUS_SUCCESS;

                }
                else {
                
                    //
                    // The cancel routine is about to be run.
                    // Set the Flink to NULL so the cancel routine knows
                    // it is not on the list and tell the system
                    // not to touch the irp
                    //

                    Irp->Tail.Overlay.ListEntry.Flink = NULL;
                }
            }
            else {
                //
                // Reinset IRP back in the list if partial completion 
                // is impossible and tell the system not to touch it
                //
                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength = (ULONG)Irp->IoStatus.Information;
        
                InsertHeadList (&connection->VcReceiveIrpListHead,
                                    &Irp->Tail.Overlay.ListEntry);
            }

            AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
            //
            // Release connection reference acquired when we handed IRP to transport
            //
            DEREFERENCE_CONNECTION (connection);

            return status;
        }
    }


    IF_DEBUG (RECEIVE) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdRestartBufferReceiveWithUserIrp: endpoint: %p, letting IRP: %p, status %lx, info: %ld.\n",
                    endpoint,
                    Irp, 
                    Irp->IoStatus.Status,
                    Irp->IoStatus.Information));
    }

    //
    // Release connection reference acquired when we handed IRP to transport
    //
    DEREFERENCE_CONNECTION (connection);

    //
    // Tell the IO system that it is OK to continue with IO
    // completion.
    //
    return STATUS_SUCCESS;
} //AfdRestartBufferReceiveWithUserIrp


NTSTATUS
AfdRestartBufferReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Handles completion of bufferred receives that were started in the
    receive indication handler or AfdBReceive using Afds buffer and 
    associated IRP.

Arguments:

    DeviceObject - not used.

    Irp - the IRP that is completing.

    Context - AfdBuffer in which we receive the data.

Return Value:

    NTSTATUS - this is our IRP, so we always return
    STATUS_MORE_PROCESSING_REQUIRED to indicate to the IO system that we
    own the IRP and the IO system should stop processing the it.

--*/

{
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_BUFFER     afdBuffer;
    PLIST_ENTRY     listEntry;
    LIST_ENTRY      completeIrpListHead;
    PIRP            userIrp;
    BOOLEAN         expedited;
    NTSTATUS        irpStatus;

    afdBuffer = Context;
    ASSERT (IS_VALID_AFD_BUFFER (afdBuffer));


    irpStatus = Irp->IoStatus.Status;

    //
    // We treat STATUS_BUFFER_OVERFLOW just like STATUS_RECEIVE_PARTIAL.
    //

    if ( irpStatus == STATUS_BUFFER_OVERFLOW )
        irpStatus = STATUS_RECEIVE_PARTIAL;

    connection = afdBuffer->Context;
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );

    ASSERT( !IS_TDI_BUFFERRING(endpoint) );
    ASSERT( IS_VC_ENDPOINT (endpoint) );


    if ( !NT_SUCCESS(irpStatus) ) {

        afdBuffer->Mdl->ByteCount = afdBuffer->BufferLength;
        AfdReturnBuffer( &afdBuffer->Header, connection->OwningProcess );

        //
        // !!! We can't abort the connection if the connection has
        //     not yet been accepted because we'll still be pointing
        //     at the listening endpoint.  We should do something,
        //     however.  How common is this failure?
        //

        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_WARNING_LEVEL,
                    "AfdRestartBufferReceive: IRP %p failed on endp %p\n",
                    irpStatus, endpoint ));

        DEREFERENCE_CONNECTION (connection);
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    AFD_VERIFY_MDL (connection, Irp->MdlAddress, 0, Irp->IoStatus.Information);

    //
    // Remember the length of the received data.
    //

    afdBuffer->DataLength = (ULONG)Irp->IoStatus.Information;


    //
    // Initialize the local list we'll use to complete any receive IRPs.
    // We use a list like this because we may need to complete multiple
    // IRPs and we usually cannot complete IRPs at any random point due
    // to any locks we might hold.
    //

    InitializeListHead( &completeIrpListHead );


    //
    // If there are any pended IRPs on the connection, complete as
    // appropriate with the new information.  Note that we'll try to
    // complete as many pended IRPs as possible with this new buffer of
    // data.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept and while connections is referenced, so it is safe to
    // release listening spinlock if we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    expedited = afdBuffer->ExpeditedData;

    //
    // Note that there are no more of our own receive IRPs in transport
    // and we can start forwarding application IRPs if necessary.
    //
    ASSERT (expedited || InterlockedIncrement (&connection->VcReceiveIrpsInTransport)==0);


    afdBuffer->DataOffset = AfdBFillPendingIrps (
                                connection,
                                afdBuffer->Mdl,
                                0,
                                afdBuffer->DataLength,
                                (expedited ? TDI_RECEIVE_EXPEDITED : 0) |
                                    ((irpStatus==STATUS_SUCCESS) ? TDI_RECEIVE_ENTIRE_MESSAGE : 0) |
                                    (!IS_MESSAGE_ENDPOINT(endpoint) ? AFD_RECEIVE_STREAM : 0),
                                &completeIrpListHead
                                );
    ASSERT (afdBuffer->DataOffset<=afdBuffer->DataLength);
    afdBuffer->DataLength -= afdBuffer->DataOffset;
    //
    // If there is any data left, place the buffer at the end of the
    // connection's list of bufferred data and update counts of data on
    // the connection.
    //
    if (afdBuffer->DataLength>0) {

        afdBuffer->RefCount = 1;
        InsertTailList(
            &connection->VcReceiveBufferListHead,
            &afdBuffer->BufferListEntry
            );

        if ( expedited ) {
            connection->VcBufferredExpeditedBytes += afdBuffer->DataLength;
            ASSERT (connection->VcBufferredExpeditedCount<MAXUSHORT);
            connection->VcBufferredExpeditedCount += 1;
        } else {
            connection->VcBufferredReceiveBytes += afdBuffer->DataLength;
            ASSERT (connection->VcBufferredReceiveCount<MAXUSHORT);
            connection->VcBufferredReceiveCount += 1;
        }

        //
        // Remember whether we got a full or partial receive in the
        // AFD buffer.
        //

        if ( irpStatus == STATUS_RECEIVE_PARTIAL ||
                 irpStatus == STATUS_RECEIVE_PARTIAL_EXPEDITED ) {
            afdBuffer->PartialMessage = TRUE;
        } else {
            afdBuffer->PartialMessage = FALSE;
        }
        
        //
        // We queued the buffer and thus we can't use it after releasing
        // the spinlock.  This will also signify the fact that we do not
        // need to free the buffer.
        //
        afdBuffer = NULL;

        if (connection->State==AfdConnectionStateConnected) {
            endpoint->DisableFastIoRecv = FALSE;
            if ( expedited && !endpoint->InLine ) {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            } else {

                AfdIndicateEventSelectEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
            }
        }
    }

    //
    // Release locks and indicate that there is bufferred data on the
    // endpoint.
    //

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // If there was leftover data (we queued the buffer), complete polls 
    // as necessary.  Indicate expedited data if the endpoint is not 
    // InLine and expedited data was received; otherwise, indicate normal data.
    //

    if ( afdBuffer==NULL ) {

        // Make sure connection was accepted/connected to prevent
        // indication on listening endpoint
        //
        
        if (connection->State==AfdConnectionStateConnected) {
            ASSERT (endpoint->Type & AfdBlockTypeVcConnecting);
            if ( expedited && !endpoint->InLine ) {

                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_RECEIVE_EXPEDITED,
                    STATUS_SUCCESS
                    );

            } else {

                AfdIndicatePollEvent(
                    endpoint,
                    AFD_POLL_RECEIVE,
                    STATUS_SUCCESS
                    );
            }
        }

    }
    else {
        ASSERT (afdBuffer->DataLength==0);
        afdBuffer->ExpeditedData = FALSE;
        AfdReturnBuffer (&afdBuffer->Header, connection->OwningProcess);
    }

    //
    // Complete IRPs as necessary.
    //

    while ( !IsListEmpty( &completeIrpListHead ) ) {
        listEntry = RemoveHeadList( &completeIrpListHead );
        userIrp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );

        IF_DEBUG (RECEIVE) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdRestartBufferReceive: endpoint: %p, completing IRP: %p, status %lx, info: %ld.\n",
                        endpoint,
                        userIrp, 
                        userIrp->IoStatus.Status,
                        userIrp->IoStatus.Information));
        }
        UPDATE_CONN2(connection, "Completing buffered receive with error/bytes: 0x%lX",
                            (!NT_ERROR(userIrp->IoStatus.Status)
                                    ? (ULONG)userIrp->IoStatus.Information
                                    : (ULONG)userIrp->IoStatus.Status));
        IoCompleteRequest( userIrp, AfdPriorityBoost );
    }

    //
    // Release connection reference acquired when we handed IRP to transport
    //

    DEREFERENCE_CONNECTION (connection);
    
    //
    // Tell the IO system to stop processing the AFD IRP, since we now
    // own it as part of the AFD buffer.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;

} // AfdRestartBufferReceive


ULONG
AfdBFillPendingIrps (
    PAFD_CONNECTION     Connection,
    PMDL                Mdl,
    ULONG               DataOffset,
    ULONG               DataLength,
    ULONG               Flags,
    PLIST_ENTRY         CompleteIrpListHead
    ) {
    PIRP            userIrp;
    NTSTATUS        status;
    BOOLEAN         expedited = ((Flags & TDI_RECEIVE_EXPEDITED)!=0);

    while ((DataLength>0)
            && (userIrp = AfdGetPendedReceiveIrp(
                               Connection,
                               expedited )) != NULL ) {
        PIO_STACK_LOCATION irpSp;
        ULONG receiveFlags;
        ULONG spaceInIrp;
        ULONG bytesCopied=(ULONG)-1;
        BOOLEAN peek;
        BOOLEAN partialReceivePossible;
        if ( IoSetCancelRoutine( userIrp, NULL ) == NULL ) {

            //
            // This IRP is about to be canceled.  Look for another in the
            // list.  Set the Flink to NULL so the cancel routine knows
            // it is not on the list.
            //

            userIrp->Tail.Overlay.ListEntry.Flink = NULL;
            continue;
        }
        //
        // Set up some locals.
        //

        irpSp = IoGetCurrentIrpStackLocation( userIrp );

        receiveFlags = (ULONG)irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags;
        spaceInIrp = irpSp->Parameters.AfdRestartRecvInfo.AfdOriginalLength-
                                    irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
        peek = (BOOLEAN)( (receiveFlags & TDI_RECEIVE_PEEK) != 0 );

        if ( (Flags & AFD_RECEIVE_STREAM) ||
                 (receiveFlags & TDI_RECEIVE_PARTIAL) != 0 ) {
            partialReceivePossible = TRUE;
        } else {
            partialReceivePossible = FALSE;
        }

        //
        // If we were not indicated a entire message and the first
        // IRP has more space, do not take the data, instead pass
        // it back to the transport to wait for a push bit and fill
        // as much as possible.  Non-chained receive handles this case
        // outside of this routine.
        // Note that endpoint must be of stream type or the IRP
        // should not allow partial receive.
        // Also, peek and expedited receive are not eligible for this
        // performance optimization.
        //

        if (!peek &&
                (Flags & AFD_RECEIVE_CHAINED) && 
                ((Flags & (TDI_RECEIVE_EXPEDITED|TDI_RECEIVE_ENTIRE_MESSAGE))==0) &&
                ((Flags & AFD_RECEIVE_STREAM) || ((receiveFlags & TDI_RECEIVE_PARTIAL)==0)) &&
                (DataLength<spaceInIrp) &&
                IsListEmpty (CompleteIrpListHead) &&
                !AfdIgnorePushBitOnReceives) {

            InsertTailList (CompleteIrpListHead, &userIrp->Tail.Overlay.ListEntry);
            return (ULONG)-1;
        }
        //
        // Copy data to the user's IRP.
        //

        if ( userIrp->MdlAddress != NULL ) {

            status = AfdMapMdlChain (userIrp->MdlAddress);
            if (NT_SUCCESS (status)) {
                if (Flags & AFD_RECEIVE_CHAINED) {
                    status = (DataLength<=spaceInIrp)
                            ? STATUS_SUCCESS
                            : STATUS_BUFFER_OVERFLOW;
                }
                else {
                    status = AfdCopyMdlChainToMdlChain(
                                 userIrp->MdlAddress,
                                 irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                    - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                                 Mdl,
                                 DataOffset,
                                 DataLength,
                                 &bytesCopied
                                 );
                    userIrp->IoStatus.Information =
                        irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength + bytesCopied;
                }
            }
            else {
                ASSERT (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0);
                userIrp->IoStatus.Status = status;
                userIrp->IoStatus.Information = 0;
                //
                // Add the IRP to the list of IRPs we'll need to complete once we
                // can release locks.
                //

                InsertTailList(
                    CompleteIrpListHead,
                    &userIrp->Tail.Overlay.ListEntry
                    );
                continue;
            }

        } else {

            status = STATUS_BUFFER_OVERFLOW;
            userIrp->IoStatus.Information = 0;
        }
        ASSERT( status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW );

        //
        // For stream type endpoints, it does not make sense to return
        // STATUS_BUFFER_OVERFLOW.  That status is only sensible for
        // message-oriented transports.  We have already set up the
        // status field of the IRP when we pended it, so we don't
        // need to do it again here.
        //

        if ( Flags & AFD_RECEIVE_STREAM ) {
            ASSERT( userIrp->IoStatus.Status == STATUS_SUCCESS );
        } else {
            userIrp->IoStatus.Status = status;
        }

        //
        // We can complete the IRP under any of the following
        // conditions:
        //
        //    - the buffer contains a complete message of data.
        //
        //    - it is OK to complete the IRP with a partial message.
        //
        //    - the IRP is already full of data.
        //

        if ( (Flags & TDI_RECEIVE_ENTIRE_MESSAGE)

                 ||

             partialReceivePossible

                 ||

             status == STATUS_BUFFER_OVERFLOW ) {

            //
            // Convert overflow status for message endpoints
            // (either we overflowed the buffer or transport
            // indicated us incomplete message. For the latter
            // we have already decided that we can complete the
            // receive - partialReceivePossible).
            //
            if (!(Flags & AFD_RECEIVE_STREAM) &&
                    ((status==STATUS_BUFFER_OVERFLOW) ||
                        ((Flags & TDI_RECEIVE_ENTIRE_MESSAGE)==0))) {
                userIrp->IoStatus.Status = 
                            (receiveFlags & TDI_RECEIVE_EXPEDITED) 
                                ? STATUS_RECEIVE_PARTIAL_EXPEDITED
                                : STATUS_RECEIVE_PARTIAL;

            }
            //
            // Add the IRP to the list of IRPs we'll need to complete once we
            // can release locks.
            //

            InsertTailList(
                CompleteIrpListHead,
                &userIrp->Tail.Overlay.ListEntry
                );

        } else {

            //
            // Set up the cancellation routine back in the IRP.  If the IRP 
            // has already been cancelled, continue with the next one.
            //

            IoSetCancelRoutine( userIrp, AfdCancelReceive );

            if ( userIrp->Cancel ) {


                if (IoSetCancelRoutine( userIrp, NULL ) != NULL) {

                    //
                    // Completion routine has not been reset,
                    // we have to complete it ourselves, so add it
                    // to our completion list.
                    //

                    if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0 ||
                            Connection->Endpoint->EndpointCleanedUp) {
                        userIrp->IoStatus.Status = STATUS_CANCELLED;
                    }
                    else {
                        //
                        // We cannot set STATUS_CANCELLED
                        // since we loose data already placed in the IRP.
                        //
                        userIrp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
                        userIrp->IoStatus.Status = STATUS_SUCCESS;
                    }

                    InsertTailList(
                        CompleteIrpListHead,
                        &userIrp->Tail.Overlay.ListEntry
                        );
                }
                else {
                    
                    //
                    // The cancel routine is about to be run.
                    // Set the Flink to NULL so the cancel routine knows
                    // it is not on the list.
                    //

                    userIrp->Tail.Overlay.ListEntry.Flink = NULL;
                }
                continue;
            }
            else {

                if (Flags & AFD_RECEIVE_CHAINED) {
                    status = AfdCopyMdlChainToMdlChain(
                                 userIrp->MdlAddress,
                                 irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength
                                    - PtrToUlong(irpSp->Parameters.AfdRestartRecvInfo.AfdAdjustedLength),
                                 Mdl,
                                 DataOffset,
                                 DataLength,
                                 &bytesCopied
                                 );

                }
                ASSERT (status==STATUS_SUCCESS);
                ASSERT (bytesCopied<=spaceInIrp);
            
                //
                // Update the count of data placed into the IRP thus far.
                //

                irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength += bytesCopied;

                //
                // Put the IRP back on the connection's list of pended IRPs.
                //

                InsertHeadList(
                    &Connection->VcReceiveIrpListHead,
                    &userIrp->Tail.Overlay.ListEntry
                    );
            }
        }
        //
        // If the IRP was not a peek IRP, update the AFD buffer
        // accordingly.  If it was a peek IRP then the data should be
        // reread, so keep it around.
        //

        if ( !peek ) {

            //
            // If we copied all of the data from the buffer to the IRP,
            // free the AFD buffer structure.
            //

            if ( status == STATUS_SUCCESS ) {

                DataOffset += DataLength;
                DataLength = 0;

            } else {

                //
                // There is more data left in the buffer.  Update counts in
                // the AFD buffer structure.
                //

                ASSERT(DataLength > spaceInIrp);

                DataOffset += spaceInIrp;
                DataLength -= spaceInIrp;

            }
        }
        if (Connection->VcReceiveIrpListHead.Flink
                    ==&userIrp->Tail.Overlay.ListEntry)

            //
            // We reinserted IRP back on pending list, so
            // stop processing this buffer for now.
            //
            // !!! This could cause a problem if there is a regular
            //     receive pended behind a peek IRP!  But that is a
            //     pretty unlikely scenario.
            //

            break;
    }

    return DataOffset;
}





VOID
AfdCancelReceive (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Cancels a receive IRP that is pended in AFD.

Arguments:

    DeviceObject - not used.

    Irp - the IRP to cancel.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PAFD_ENDPOINT endpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    //
    // Get the endpoint pointer from our IRP stack location and the
    // connection pointer from the endpoint.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    endpoint = irpSp->FileObject->FsContext;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcBoth );


    //
    // Remove the IRP from the endpoint's IRP list, synchronizing with
    // the endpoint lock which protects the lists.  Note that the
    // IRP *must* be on one of the endpoint's lists or the Flink is NULL
    // if we are getting called here--anybody that removes the IRP from
    // the list must reset the cancel routine to NULL and set the
    // Flink to NULL before releasing the endpoint spin lock.
    //

    AfdAcquireSpinLock( &endpoint->SpinLock, &lockHandle );

    if ( Irp->Tail.Overlay.ListEntry.Flink != NULL ) {
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    }

    AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );

    //
    // Release the cancel spin lock and complete the IRP with a
    // cancellation status code.
    //

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    if (irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength==0 ||
            endpoint->EndpointCleanedUp) {
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_CANCELLED;
        UPDATE_CONN(endpoint->Common.VcConnecting.Connection);
    }
    else {
        //
        // There was some data in the IRP, do not complete with
        // STATUS_CANCELLED, since this will result in data loss
        //
        Irp->IoStatus.Information = irpSp->Parameters.AfdRestartRecvInfo.AfdCurrentLength;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        UPDATE_CONN2 (endpoint->Common.VcConnecting.Connection, 
                            "Completing cancelled irp with 0x%lX bytes",
                            (ULONG)Irp->IoStatus.Information);
    }

    IoCompleteRequest( Irp, AfdPriorityBoost );

    return;

} // AfdCancelReceive


PAFD_BUFFER_HEADER
AfdGetReceiveBuffer (
    IN PAFD_CONNECTION Connection,
    IN ULONG ReceiveFlags,
    IN PAFD_BUFFER_HEADER StartingAfdBuffer OPTIONAL
    )

/*++

Routine Description:

    Returns a pointer to a receive data buffer that contains the
    appropriate type of data.  Note that this routine DOES NOT remove
    the buffer structure from the list it is on.

    This routine MUST be called with the connection's endpoint lock
    held!

Arguments:

    Connection - a pointer to the connection to search for data.

    ReceiveFlags - the type of receive data to look for.

    StartingAfdBuffer - if non-NULL, start looking for a buffer AFTER
        this buffer.

Return Value:

    PAFD_BUFFER - a pointer to an AFD buffer of the appropriate data type,
        or NULL if there was no appropriate buffer on the connection.

--*/

{
    PLIST_ENTRY listEntry;
    PAFD_BUFFER_HEADER afdBuffer;

    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Start with the first AFD buffer on the connection.
    //

    listEntry = Connection->VcReceiveBufferListHead.Flink;
    afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

    //
    // If a starting AFD buffer was specified, walk past that buffer in
    // the connection list.
    //

    if ( ARGUMENT_PRESENT( StartingAfdBuffer ) ) {

        while ( TRUE ) {

            if ( afdBuffer == StartingAfdBuffer ) {
                listEntry = listEntry->Flink;
                afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
                //
                // Don't mix expedited and non-expedited data.
                //
                if (afdBuffer->ExpeditedData!=StartingAfdBuffer->ExpeditedData)
                    return NULL;
                break;
            }

            listEntry = listEntry->Flink;
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );

            ASSERT( listEntry != &Connection->VcReceiveBufferListHead );
        }
    }

    //
    // Act based on the type of data we're trying to get.
    //

    switch ( ReceiveFlags & TDI_RECEIVE_EITHER ) {

    case TDI_RECEIVE_NORMAL:

        //
        // Walk the connection's list of data buffers until we find the
        // first data buffer that is of the appropriate type.
        //

        while ( listEntry != &Connection->VcReceiveBufferListHead &&
                    afdBuffer->ExpeditedData ) {

            listEntry = afdBuffer->BufferListEntry.Flink;
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
        }

        if ( listEntry != &Connection->VcReceiveBufferListHead ) {
            return afdBuffer;
        } else {
            return NULL;
        }

    case TDI_RECEIVE_EITHER :

        //
        // Just return the first buffer, if there is one.
        //

        if ( listEntry != &Connection->VcReceiveBufferListHead ) {
            return afdBuffer;
        } else {
            return NULL;
        }

    case TDI_RECEIVE_EXPEDITED:

        if ( Connection->VcBufferredExpeditedCount == 0 ) {
            return NULL;
        }

        //
        // Walk the connection's list of data buffers until we find the
        // first data buffer that is of the appropriate type.
        //

        while ( listEntry != &Connection->VcReceiveBufferListHead &&
                    !afdBuffer->ExpeditedData ) {

            listEntry = afdBuffer->BufferListEntry.Flink;
            afdBuffer = CONTAINING_RECORD( listEntry, AFD_BUFFER_HEADER, BufferListEntry );
        }

        if ( listEntry != &Connection->VcReceiveBufferListHead ) {
            return afdBuffer;
        } else {
            return NULL;
        }

    default:

        ASSERT( !"Invalid ReceiveFlags" );
        __assume (0);
        return NULL;
    }

} // AfdGetReceiveBuffer


PIRP
AfdGetPendedReceiveIrp (
    IN PAFD_CONNECTION Connection,
    IN BOOLEAN Expedited
    )

/*++

Routine Description:

    Removes a receive IRP from the connection's list of receive IRPs.
    Only returns an IRP which is valid for the specified type of
    data, normal or expedited.  If there are no IRPs pended or only
    IRPs of the wrong type, returns NULL.

    This routine MUST be called with the connection's endpoint lock
    held!

Arguments:

    Connection - a pointer to the connection to search for an IRP.

    Expedited - TRUE if this routine should return a receive IRP which
        can receive expedited data.

Return Value:

    PIRP - a pointer to an IRP which can receive data of the specified
        type.  The IRP IS removed from the connection's list of pended
        receive IRPs.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG receiveFlags;
    PLIST_ENTRY listEntry;

    ASSERT( KeGetCurrentIrql( ) == DISPATCH_LEVEL );

    //
    // Walk the list of pended receive IRPs looking for one which can
    // be completed with the specified type of data.
    //

    for ( listEntry = Connection->VcReceiveIrpListHead.Flink;
          listEntry != &Connection->VcReceiveIrpListHead;
          listEntry = listEntry->Flink ) {

        //
        // Get a pointer to the IRP and our stack location in the IRP.
        //

        irp = CONTAINING_RECORD( listEntry, IRP, Tail.Overlay.ListEntry );
        irpSp = IoGetCurrentIrpStackLocation( irp );

        //
        // Determine whether this IRP can receive the data type we need.
        //

        receiveFlags = irpSp->Parameters.AfdRestartRecvInfo.AfdRecvFlags;
        receiveFlags &= TDI_RECEIVE_EITHER;
        ASSERT( receiveFlags != 0 );

        if ( receiveFlags == TDI_RECEIVE_NORMAL && !Expedited ) {

            //
            // We have a normal receive and normal data.  Remove this
            // IRP from the connection's list and return it.
            //

            RemoveEntryList( listEntry );
            return irp;
        }

        if ( receiveFlags == TDI_RECEIVE_EITHER ) {

            //
            // This is an "either" receive.  It can take the data
            // regardless of the data type.
            //

            RemoveEntryList( listEntry );
            return irp;
        }

        if ( receiveFlags == TDI_RECEIVE_EXPEDITED && Expedited ) {

            //
            // We have an expedited receive and expedited data.  Remove
            // this IRP from the connection's list and return it.
            //

            RemoveEntryList( listEntry );
            return irp;
        }

        //
        // This IRP did not meet our criteria.  Continue scanning the
        // connection's list of pended IRPs for a good IRP.
        //
    }

    //
    // There were no IRPs which could be completed with the specified
    // type of data.
    //

    return NULL;

} // AfdGetPendedReceiveIrp



BOOLEAN
AfdLRRepostReceive (
    PAFD_LR_LIST_ITEM Item
    )
/*++

Routine Description:

    Attempts to restart receive on a connection where AFD returned
    STATUS_DATA_NO_ACCEPTED to the transport due to low resource condition.

Arguments:

    Connection - connection of interest

Return Value:
    TRUE    - was able to restart receives (or connection is gone)
    FALSE   - still problem with resources

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PAFD_ENDPOINT   endpoint;
    PAFD_CONNECTION connection;
    PAFD_BUFFER     afdBuffer;

    connection = CONTAINING_RECORD (Item, AFD_CONNECTION, LRListItem);
    ASSERT( connection->Type == AfdBlockTypeConnection );

    endpoint = connection->Endpoint;
    ASSERT( endpoint->Type == AfdBlockTypeVcConnecting ||
            endpoint->Type == AfdBlockTypeVcListening ||
            endpoint->Type == AfdBlockTypeVcBoth );


    AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);

    ASSERT (connection->OnLRList == TRUE);

    //
    // Check if connection was accepted and use accept endpoint instead
    // of the listening.  Note that accept cannot happen while we are
    // holding listening endpoint spinlock, nor can endpoint change after
    // the accept, so it is safe to release listening spinlock if
    // we discover that endpoint was accepted.
    //
    if (((endpoint->Type & AfdBlockTypeVcListening) == AfdBlockTypeVcListening)
            && (connection->Endpoint != endpoint)) {
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

        endpoint = connection->Endpoint;
        ASSERT( endpoint->Type == AfdBlockTypeVcConnecting );
        ASSERT( !IS_TDI_BUFFERRING(endpoint) );
        ASSERT(  IS_VC_ENDPOINT (endpoint) );

        AfdAcquireSpinLock (&endpoint->SpinLock, &lockHandle);
    }

    //
    // Check if connection is still alive.
    //
    if (connection->AbortIndicated || 
            connection->DisconnectIndicated ||
            connection->VcReceiveBytesInTransport==0 ||
            (endpoint->DisconnectMode & AFD_PARTIAL_DISCONNECT_RECEIVE) != 0 ||
            endpoint->EndpointCleanedUp ) {
        connection->OnLRList = FALSE;
        AfdReleaseSpinLock( &endpoint->SpinLock, &lockHandle );
        DEREFERENCE_CONNECTION (connection);
        return TRUE;
    }

    //
    // Attempt to allocate receive buffer for the amount that the
    // transport indicated to us last.
    //
    afdBuffer = AfdGetBuffer (connection->VcReceiveBytesInTransport, 0, connection->OwningProcess);
    if (afdBuffer==NULL) {
        //
        //  The caller will automatically put this connection back on LR list
        //
        AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);
        UPDATE_CONN (connection);
        return FALSE;
    }


    //
    // Finish building the receive IRP to give to the TDI
    // provider.
    //

    TdiBuildReceive(
        afdBuffer->Irp,
        connection->DeviceObject,
        connection->FileObject,
        AfdRestartBufferReceive,
        afdBuffer,
        afdBuffer->Mdl,
        TDI_RECEIVE_NORMAL,
        connection->VcReceiveBytesInTransport
        );

    //
    // Acquire connection reference to be released in completion routine
    // We already have one by virtue of being here

    // REFERENCE_CONNECTION (connection);
    UPDATE_CONN2 (connection, "Reposting LR receive for 0x%lX bytes",
                                connection->VcReceiveBytesInTransport);

    connection->VcReceiveBytesInTransport = 0;
    ASSERT (InterlockedDecrement (&connection->VcReceiveIrpsInTransport)==-1);

    //
    // We need to remember the connection in the AFD buffer
    // because we'll need to access it in the completion
    // routine.
    //

    afdBuffer->Context = connection;
    connection->OnLRList = FALSE;

    AfdReleaseSpinLock (&endpoint->SpinLock, &lockHandle);

    IoCallDriver (connection->DeviceObject, afdBuffer->Irp);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sockets\winsock2\wsp\afdsys\san.c ===
/*+

Copyright (c) 1989  Microsoft Corporation

Module Name:

    san.c

Abstract:

    Contains routines for SAN switch support

Author:

    Vadim Eydelman (VadimE)    1-Jul-1998

Revision History:

--*/

#include "afdp.h"

VOID
AfdSanCancelConnect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
AfdSanCancelRequest (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PIRP
AfdSanDequeueRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx
    );

VOID
AfdSanInitEndpoint (
    PAFD_ENDPOINT   SanHlprEndpoint,
    PFILE_OBJECT    SanFile,
    PAFD_SWITCH_CONTEXT SwitchContext
    );

BOOLEAN
AfdSanNotifyRequest (
    PAFD_ENDPOINT   SanEndpoint,
    PVOID           RequestCtx,
    NTSTATUS        Status,
    ULONG_PTR       Information
    );

VOID
AfdSanRestartRequestProcessing (
    PAFD_ENDPOINT   Endpoint,
    NTSTATUS        Status
    );

NTSTATUS
AfdSanReferenceSwitchSocketByHandle (
    IN HANDLE              SocketHandle,
    IN ACCESS_MASK         DesiredAccess,
    IN KPROCESSOR_MODE     RequestorMode,
    IN PAFD_ENDPOINT       SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT SwitchContext OPTIONAL,
    OUT PFILE_OBJECT       *FileObject
    );

NTSTATUS
AfdSanDupEndpointIntoServiceProcess (
    PFILE_OBJECT    SanFileObject,
    PVOID           SavedContext,
    ULONG           ContextLength
    );

VOID
AfdSanResetPendingRequests (
    PAFD_ENDPOINT   SanEndpoint
    );

BOOLEAN
AfdSanReferenceEndpointObject (
    PAFD_ENDPOINT   Endpoint
    );

NTSTATUS
AfdSanFindSwitchSocketByProcessContext (
    IN NTSTATUS             Status,
    IN PAFD_ENDPOINT        SanHlprEndpoint,
    IN PAFD_SWITCH_CONTEXT  SwitchContext,
    OUT PFILE_OBJECT        *FileObject
    );

VOID
AfdSanProcessAddrListForProviderChange (
    PAFD_ENDPOINT   SpecificEndpoint
    );

NTSTATUS
AfdSanGetCompletionObjectTypePointer (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE,AfdSanCreateHelper) 
#pragma alloc_text (PAGE,AfdSanCleanupHelper) 
#pragma alloc_text (PAGE,AfdSanCleanupEndpoint) 
#pragma alloc_text (PAGE,AfdSanReferenceSwitchSocketByHandle) 
#pragma alloc_text (PAGE,AfdSanFindSwitchSocketByProcessContext) 
#pragma alloc_text (PAGESAN,AfdSanReferenceEndpointObject) 
#pragma alloc_text (PAGE,AfdSanDupEndpointIntoServiceProcess) 
#pragma alloc_text (PAGESAN,AfdSanResetPendingRequests) 
#pragma alloc_text (PAGESAN,AfdSanFastCementEndpoint) 
#pragma alloc_text (PAGESAN,AfdSanFastSetEvents) 
#pragma alloc_text (PAGESAN,AfdSanFastResetEvents) 
#pragma alloc_text (PAGESAN,AfdSanAcceptCore)
#pragma alloc_text (PAGESAN,AfdSanConnectHandler)
#pragma alloc_text (PAGESAN,AfdSanReleaseConnection)
#pragma alloc_text (PAGESAN,AfdSanFastCompleteAccept) 
#pragma alloc_text (PAGESAN,AfdSanCancelAccept) 
#pragma alloc_text (PAGESAN,AfdSanCancelConnect) 
#pragma alloc_text (PAGESAN,AfdSanRedirectRequest)
#pragma alloc_text (PAGESAN,AfdSanFastCompleteRequest)
#pragma alloc_text (PAGE, AfdSanFastCompleteIo)
#pragma alloc_text (PAGESAN,AfdSanDequeueRequest)
#pragma alloc_text (PAGESAN,AfdSanCancelRequest)
#pragma alloc_text (PAGESAN,AfdSanFastRefreshEndpoint)
#pragma alloc_text (PAGE, AfdSanFastGetPhysicalAddr)
#pragma alloc_text (PAGE, AfdSanFastGetServicePid)
#pragma alloc_text (PAGE, AfdSanFastSetServiceProcess)
#pragma alloc_text (PAGE, AfdSanFastProviderChange)
#pragma alloc_text (PAGE, AfdSanAddrListChange)
#pragma alloc_text (PAGESAN, AfdSanProcessAddrListForProviderChange)
#pragma alloc_text (PAGE, AfdSanFastUnlockAll)
#pragma alloc_text (PAGE, AfdSanPollBegin)
#pragma alloc_text (PAGE, AfdSanPollEnd)
#pragma alloc_text (PAGESAN, AfdSanPollUpdate)
#pragma alloc_text (PAGE, AfdSanPollMerge)
#pragma alloc_text (PAGE, AfdSanFastTransferCtx)
#pragma alloc_text (PAGESAN, AfdSanAcquireContext)
#pragma alloc_text (PAGESAN, AfdSanInitEndpoint)
#pragma alloc_text (PAGE, AfdSanNotifyRequest)
#pragma alloc_text (PAGESAN, AfdSanRestartRequestProcessing)
#pragma alloc_text (PAGE, AfdSanGetCompletionObjectTypePointer)
#pragma alloc_text (PAGESAN, AfdSanAbortConnection)
#endif

//
// Dispatch level routines - external SAN entry points.
//

NTSTATUS
AfdSanCreateHelper (
    PIRP                        Irp,
    PFILE_FULL_EA_INFORMATION   EaBuffer,
    PAFD_ENDPOINT               *Endpoint
    )
/*++

Routine Description:

    Allocates and initializes SAN helper endpoint for communication between switch
    and AFD.

Arguments:
    Irp     - Create IRP
    EaBuffer - Create IRP Ea buffer (AFD_SWITCH_OPEN_PACKET structure)
                    CompletionPort  - completion port to reflect kernel calls to switch
                    CompletionEvent - event to identify overlapped IO triggered by the
                                        switch as opposed to the application
    Endpoint - buffer to place created endpoint pointer.

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_ACCESS_VIOLATION - incorrect input buffer size.
    other - failed to access port/event object or allocation failure..
--*/
{
    NTSTATUS    status;
    HANDLE      port, event;
    PVOID       ioCompletionPort;
    PVOID       ioCompletionEvent;

    if ( !MmIsThisAnNtAsSystem () ) {
#ifndef DONT_CHECK_FOR_DTC
        return STATUS_NOT_SUPPORTED;
#else
        DbgPrint ("AFD: Temporarily allowing SAN support on non-server build\n");
#endif //DONT_CHECK_FOR_DTC
    }
#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SWITCH_OPEN_PACKET32   openPacket32;

        if (EaBuffer->EaValueLength<sizeof (*openPacket32)) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Invalid switch open packet size.\n"));
            }
            return STATUS_ACCESS_VIOLATION;
        }
        openPacket32 = (PAFD_SWITCH_OPEN_PACKET32)(EaBuffer->EaName +
                                        EaBuffer->EaNameLength + 1);
        event = openPacket32->CompletionEvent;
        port = openPacket32->CompletionPort;
    }
    else
#endif //_WIN64
    {
        PAFD_SWITCH_OPEN_PACKET   openPacket;
        if (EaBuffer->EaValueLength<sizeof (*openPacket)) {
            IF_DEBUG (SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Invalid switch open packet size.\n"));
            }
            return STATUS_ACCESS_VIOLATION;
        }
        openPacket = (PAFD_SWITCH_OPEN_PACKET)(EaBuffer->EaName +
                                    EaBuffer->EaNameLength + 1);
        event = openPacket->CompletionEvent;
        port = openPacket->CompletionPort;
    }


    if (IoCompletionObjectType==NULL) {
        status = AfdSanGetCompletionObjectTypePointer ();
        if (!NT_SUCCESS (status)) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_INFO_LEVEL,
                        "AfdSanCreateHelper: Could not get completion OT:%lx\n",
                        status));
            }
            return status;
        }
    }
    //
    // Get references to completion port and event
    //

    status = ObReferenceObjectByHandle (
                port,
                IO_COMPLETION_ALL_ACCESS,
                IoCompletionObjectType,
                Irp->RequestorMode,
                &ioCompletionPort,
                NULL
                );
    if (!NT_SUCCESS (status)) {
        IF_DEBUG (SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Could not reference completion port (%p).\n",
                        status));
        }
        return status;
    }

                    
    status = ObReferenceObjectByHandle (
                event,
                EVENT_ALL_ACCESS,
                *ExEventObjectType,
                Irp->RequestorMode,
                &ioCompletionEvent,
                NULL
                );
    if (!NT_SUCCESS (status)) {
        ObDereferenceObject (ioCompletionPort);
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanCreateHelper: Could not reference completion event (%p).\n",
                        status));
        }
        return status;
    }


    //
    // Allocate an AFD "helper" endpoint.
    //

    status = AfdAllocateEndpoint(
                 Endpoint,
                 NULL,
                 0
                 );

    if( !NT_SUCCESS(status) ) {
        ObDereferenceObject (ioCompletionPort);
        ObDereferenceObject (ioCompletionEvent);
        return status;
    }
    (*Endpoint)->Type = AfdBlockTypeSanHelper;
    (*Endpoint)->Common.SanHlpr.IoCompletionPort = ioCompletionPort;
    (*Endpoint)->Common.SanHlpr.IoCompletionEvent = ioCompletionEvent;
    (*Endpoint)->Common.SanHlpr.Plsn = 0;

    KeEnterCriticalRegion ();
    ExAcquireResourceExclusiveLite( AfdResource, TRUE );
    if (AfdSanCodeHandle==NULL) {
        AfdSanCodeHandle = MmLockPagableCodeSection( AfdSanFastCementEndpoint );
        ASSERT( AfdDiscardableCodeHandle != NULL );

        InitializeListHead (&AfdSanHelperList);
    }

    InsertTailList (&AfdSanHelperList, &(*Endpoint)->Common.SanHlpr.SanListLink);
    ExReleaseResourceLite( AfdResource );
    KeLeaveCriticalRegion ();
    return STATUS_SUCCESS;
}


NTSTATUS
AfdSanFastCementEndpoint (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Changes the endpoint type to SAN to indicate that
    it is used for support of user mode SAN providers
    Associates switch context with the endpoint.

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CEMENT_SAN)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size
    other - failed when attempting to access switch socket, input buffer, or switch context.
--*/

{
    NTSTATUS    status;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_CONTEXT_INFO contextInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    PVOID       context;

    *Information = 0;

    try {

#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_CONTEXT_INFO32  contextInfo32;
            if (InputBufferLength<sizeof (*contextInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*contextInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_CONTEXT_INFO32));
            }
            contextInfo32 = InputBuffer;
            contextInfo.SocketHandle = contextInfo32->SocketHandle;
            contextInfo.SwitchContext = contextInfo32->SwitchContext;
        }
        else
#endif _WIN64
        {

            if (InputBufferLength<sizeof (contextInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (contextInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT_INFO));
            }

            contextInfo = *((PAFD_SWITCH_CONTEXT_INFO)InputBuffer);
        }

        if (contextInfo.SwitchContext==NULL) {
            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AFD: Switch context is NULL in AfdSanFastCementEndpoint\n"));
            }
            ExRaiseStatus (STATUS_INVALID_PARAMETER);
        }

        if (RequestorMode!=KernelMode) {
            ProbeForWrite (contextInfo.SwitchContext,
                            sizeof (*contextInfo.SwitchContext),
                            PROBE_ALIGNMENT (AFD_SWITCH_CONTEXT));
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            contextInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            NULL,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }

    sanEndpoint = sanFileObject->FsContext;

    IF_DEBUG(SAN_SWITCH) {
        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                    "AfdFastCementSanEndpoint: endp-%p, hlpr-%p.\n",
                    sanEndpoint, sanHlprEndpoint));
    }

    //
    // Make sure that helper endpoint is really the one
    // and that san endpoint is in the state where it can
    // be given to the san provider.
    //
    context = AfdLockEndpointContext (sanEndpoint);
    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    if (!sanEndpoint->EndpointCleanedUp &&
         (sanEndpoint->Type==AfdBlockTypeEndpoint) &&
         (sanEndpoint->State==AfdEndpointStateBound) ) {
        AFD_SWITCH_CONTEXT  localContext = {0,0,0,0};

        AfdSanInitEndpoint (sanHlprEndpoint, sanFileObject, contextInfo.SwitchContext);

        sanEndpoint->DisableFastIoSend = TRUE;
        sanEndpoint->DisableFastIoRecv = TRUE;
        sanEndpoint->EnableSendEvent = TRUE;
        sanEndpoint->Common.SanEndp.SelectEventsActive = AFD_POLL_SEND;
        sanEndpoint->State = AfdEndpointStateConnected;
        sanEndpoint->Common.SanEndp.LocalContext = &localContext;
        AfdIndicateEventSelectEvent (sanEndpoint, AFD_POLL_CONNECT|AFD_POLL_SEND, STATUS_SUCCESS);
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent (sanEndpoint, AFD_POLL_CONNECT|AFD_POLL_SEND, STATUS_SUCCESS);
        status = AfdSanPollMerge (sanEndpoint, &localContext);
        sanEndpoint->Common.SanEndp.LocalContext = NULL;

    }
    else {
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        status = STATUS_INVALID_HANDLE;
    }

    AfdUnlockEndpointContext (sanEndpoint, context);

    UPDATE_ENDPOINT2 (sanEndpoint, "AfdSanFastCementEndpoint, status: %lx", status);
    ObDereferenceObject (sanFileObject);
    return status;
}

NTSTATUS
AfdSanFastSetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Sets the poll event on the san endpoint to report
    to the application via various forms of the select

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_SET_EVENTS)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            EventBit        - event bit to set
                            Status          - associated status (for AFD_POLL_EVENT_CONNECT_FAIL)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size, invalid event bit.
    other - failed when attempting to access switch socket, input buffer, or switch context.
--*/
{
    NTSTATUS status;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_EVENT_INFO eventInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;
    AFD_LOCK_QUEUE_HANDLE lockHandle;

    *Information = 0;

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_EVENT_INFO32  eventInfo32;
            if (InputBufferLength<sizeof (*eventInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*eventInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_EVENT_INFO32));
            }
            eventInfo32 = InputBuffer;
            eventInfo.SocketHandle = eventInfo32->SocketHandle;
            eventInfo.SwitchContext = eventInfo32->SwitchContext;
            eventInfo.EventBit = eventInfo32->EventBit;
            eventInfo.Status = eventInfo32->Status;
        }
        else
#endif _WIN64
        {
            if (InputBufferLength<sizeof (eventInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (eventInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_EVENT_INFO));
            }

            eventInfo = *((PAFD_SWITCH_EVENT_INFO)InputBuffer);
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    if (eventInfo.EventBit >= AFD_NUM_POLL_EVENTS) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AFD: Invalid EventBit=%d passed to AfdSanFastSetEvents\n", 
				        eventInfo.EventBit));
        }
        return STATUS_INVALID_PARAMETER;
    }

    eventInfo.Status = AfdValidateStatus (eventInfo.Status);

    //
    // If event is connect failure, then context should not exist.
    // If event is not connect failure, context should exist.
    //
    if ((eventInfo.EventBit==AFD_POLL_CONNECT_FAIL_BIT) ^
            (eventInfo.SwitchContext==NULL)) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AFD: AfdSanFastSetEvents-bit:%ld, context:%p inconsistent\n", 
				        eventInfo.EventBit,
                        eventInfo.SwitchContext));
        }
        return STATUS_INVALID_PARAMETER;
    }
        

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            eventInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            eventInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }

    sanEndpoint = sanFileObject->FsContext;

    if (sanEndpoint->State==AfdEndpointStateConnected ||
            (eventInfo.EventBit==AFD_POLL_CONNECT_FAIL_BIT &&
            sanEndpoint->State==AfdEndpointStateBound) ) {
            


        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFastSetSanEvents: endp-%p, bit-%lx, status-%lx.\n",
                        sanEndpoint, eventInfo.EventBit, eventInfo.Status));
        }

        try {
            LONG currentEvents, newEvents;

            //
            // Update our event record. Make sure endpoint is connected, otherwise
		    // sanEndpoint->Common.SanEndp.SwitchContext will not be valid
            //
		    if (sanEndpoint->State==AfdEndpointStateConnected) {
			    do {
				    currentEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SelectEventsActive);
				    newEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SwitchContext->EventsActive);
			    }
			    while (InterlockedCompareExchange (
						    (PLONG)&sanEndpoint->Common.SanEndp.SelectEventsActive,
						    newEvents,
						    currentEvents)!=currentEvents);
		    }
        }
        except (AFD_EXCEPTION_FILTER (&status)) {
            goto complete;
        }

        //
        // Signal the event.
        //
        AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        AfdIndicateEventSelectEvent (sanEndpoint, 1<<eventInfo.EventBit, eventInfo.Status);
        AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        AfdIndicatePollEvent (sanEndpoint, 1<<eventInfo.EventBit, eventInfo.Status);
        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_INVALID_HANDLE;
    }

complete:
    UPDATE_ENDPOINT2 (sanEndpoint, 
                        "AfdFastSetEvents, event/status: %lx",
                        NT_SUCCESS (status) ? eventInfo.EventBit : status);
    ObDereferenceObject (sanFileObject);
    return status;
}

NTSTATUS
AfdSanFastResetEvents (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Resets the poll event on the san endpoint so that it is no
    longer reported to the application via various forms of the select

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_RESET_EVENTS)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_EVENT_INFO)
                            SocketHandle    - handle of the endpoint being changed to SAN
                            EventBit        - event bit to reset
                            Status          - associated status (ignored)
    InputBufferLength - sizeof(AFD_SWITCH_EVENT_INFO)
    OutputBuffer    - unused
    OutputBufferLength - unused
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size, invalid event bit.
    other - failed when attempting to access switch socket, input buffer, or switch context.

--*/
{
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    NTSTATUS    status;
    PFILE_OBJECT    sanFileObject;
    AFD_SWITCH_EVENT_INFO eventInfo;
    PAFD_ENDPOINT   sanEndpoint, sanHlprEndpoint;

    *Information = 0;

    try {
#ifdef _WIN64
        if (IoIs32bitProcess (NULL)) {
            PAFD_SWITCH_EVENT_INFO32  eventInfo32;
            if (InputBufferLength<sizeof (*eventInfo32)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }
            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (*eventInfo32),
                                PROBE_ALIGNMENT32 (AFD_SWITCH_EVENT_INFO32));
            }
            eventInfo32 = InputBuffer;
            eventInfo.SocketHandle = eventInfo32->SocketHandle;
            eventInfo.SwitchContext = eventInfo32->SwitchContext;
            eventInfo.EventBit = eventInfo32->EventBit;
            eventInfo.Status = eventInfo32->Status;
        }
        else
#endif _WIN64
        {
            if (InputBufferLength<sizeof (eventInfo)) {
                ExRaiseStatus (STATUS_INVALID_PARAMETER);
            }

            if (RequestorMode!=KernelMode) {
                ProbeForRead (InputBuffer,
                                sizeof (eventInfo),
                                PROBE_ALIGNMENT (AFD_SWITCH_EVENT_INFO));
            }

            eventInfo = *((PAFD_SWITCH_EVENT_INFO)InputBuffer);
        }
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        return status;
    }

    if (eventInfo.EventBit >= AFD_NUM_POLL_EVENTS) {
        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AFD: Invalid EventBit=%d passed to AfdSanFastResetEvents\n", 
				        eventInfo.EventBit));
        }
        return STATUS_INVALID_PARAMETER;
    }

    if (eventInfo.SwitchContext==NULL) {
        KdPrint (("AFD: Switch context is NULL in AfdSanFastResetEvents\n"));
        return STATUS_INVALID_PARAMETER;
    }

    sanHlprEndpoint = FileObject->FsContext;
    ASSERT (IS_SAN_HELPER (sanHlprEndpoint));
    status = AfdSanReferenceSwitchSocketByHandle (
                            eventInfo.SocketHandle,
                            (IoctlCode>>14)&3,
                            RequestorMode,
                            sanHlprEndpoint,
                            eventInfo.SwitchContext,
                            &sanFileObject
                            );
    if (!NT_SUCCESS (status)) {
        return status;
    }
    sanEndpoint = sanFileObject->FsContext;

    IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdFastResetSanEvents: endp-%p, bit-%lx, status-%lx.\n",
                        sanEndpoint, eventInfo.EventBit, eventInfo.Status));
    }

    try {
        LONG currentEvents, newEvents;

        //
        // Update our event record.
        //
        do {
            currentEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SelectEventsActive);
            newEvents = *((LONG volatile *)&sanEndpoint->Common.SanEndp.SwitchContext->EventsActive);
        }
        while (InterlockedCompareExchange (
                    (PLONG)&sanEndpoint->Common.SanEndp.SelectEventsActive,
                    newEvents,
                    currentEvents)!=currentEvents);
    }
    except (AFD_EXCEPTION_FILTER (&status)) {
        goto complete;
    }

    AfdAcquireSpinLock (&sanEndpoint->SpinLock, &lockHandle);
        //
    // Reset EventSelect mask
    sanEndpoint->EventsActive &= (~ (1<<(eventInfo.EventBit)));
    if (eventInfo.EventBit == AFD_POLL_SEND_BIT)
        sanEndpoint->EnableSendEvent = TRUE;
    AfdReleaseSpinLock (&sanEndpoint->SpinLock, &lockHandle);
    status = STATUS_SUCCESS;

complete:
    UPDATE_ENDPOINT2 (sanEndpoint,
                        "AfdFastResetEvents, event/status: %lx",
                        NT_SUCCESS (status) ? eventInfo.EventBit : status);
    ObDereferenceObject (sanFileObject);
    return status;
}

//
// Macros to make the super accept restart code more maintainable.
//

#define AfdRestartSuperAcceptInfo   DeviceIoControl

// Used while IRP is in AFD queue (otherwise AfdAcceptFileObject
// is stored as completion routine context).
#define AfdAcceptFileObject         Type3InputBuffer
// Used when IRP is passed to the transport (otherwise MdlAddress
// is stored in the IRP itself).
#define AfdMdlAddress               Type3InputBuffer

#define AfdReceiveDataLength        OutputBufferLength
#define AfdRemoteAddressLength      InputBufferLength
#define AfdLocalAddressLength       IoControlCode

NTSTATUS
FASTCALL
AfdSanConnectHandler (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    Implements connect indication from SAN provider.
    Picks up the accept from the listening endpoint queue
    or queues the IRP an signals the application to come
    down with an accept.

Arguments:

    Irp  - SAN connect IRP
    IrpSp -  stack location

Return Value:
    NTSTATUS

--*/
{
    NTSTATUS    status;
    PAFD_SWITCH_CONNECT_INFO connectInfo;
    union {
#ifdef _WIN64
        PAFD_SWITCH_ACCEPT_INFO32 acceptInfo32;
#endif //_WIN64
        PAFD_SWITCH_ACCEPT_INFO acceptInfo;
    } u;
    PFILE_OBJECT  listenFileObject;
    PAFD_ENDPOINT sanHlprEndpoint;
    PAFD_ENDPOINT listenEndpoint;
    PAFD_CONNECTION connection;
    ULONG   RemoteAddressLength;
    AFD_LOCK_QUEUE_HANDLE lockHandle;
    PIRP    acceptIrp;
    PTA_ADDRESS localAddress;

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        PAFD_SWITCH_CONNECT_INFO      newSystemBuffer;
        PAFD_SWITCH_CONNECT_INFO32    oldSystemBuffer = Irp->AssociatedIrp.SystemBuffer;
        ULONG                         newLength;

        if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                     sizeof(*oldSystemBuffer) ) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }

        newLength = sizeof (*newSystemBuffer)
                      -sizeof(*oldSystemBuffer)
                      +IrpSp->Parameters.DeviceIoControl.InputBufferLength;
        try {
            newSystemBuffer = ExAllocatePoolWithQuota (NonPagedPool, newLength);
                                                
        }
        except (EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode ();
            goto complete;
        }

        newSystemBuffer->ListenHandle = oldSystemBuffer->ListenHandle;
        newSystemBuffer->SwitchContext = oldSystemBuffer->SwitchContext;
        RtlMoveMemory (&newSystemBuffer->RemoteAddress,
                        &oldSystemBuffer->RemoteAddress,
                        IrpSp->Parameters.DeviceIoControl.InputBufferLength-
                            FIELD_OFFSET (AFD_SWITCH_CONNECT_INFO32, RemoteAddress));

        ExFreePool (Irp->AssociatedIrp.SystemBuffer);
        Irp->AssociatedIrp.SystemBuffer = newSystemBuffer;
        IrpSp->Parameters.DeviceIoControl.InputBufferLength = newLength;
    }
#endif // _WIN64


    //
    // Set up local variables.
    //


    listenFileObject = NULL;
    sanHlprEndpoint = IrpSp->FileObject->FsContext;
    ASSERT( sanHlprEndpoint->Type == AfdBlockTypeSanHelper);
    Irp->IoStatus.Information = 0;
    connectInfo = Irp->AssociatedIrp.SystemBuffer;

    //
    // Verify input parameters
    //
    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                                    sizeof (*connectInfo) ||
            connectInfo->RemoteAddress.TAAddressCount!=2 ||    // Must have local and remote addresses
            (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                FIELD_OFFSET (AFD_SWITCH_CONNECT_INFO,
                    RemoteAddress.Address[0].Address[
                        connectInfo->RemoteAddress.Address[0].AddressLength])+sizeof(TA_ADDRESS))) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (*u.acceptInfo32)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }
    else
#endif // _WIN64
    {
        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                        sizeof (*u.acceptInfo)) {
            status = STATUS_INVALID_PARAMETER;
            goto complete;
        }
    }

    RemoteAddressLength = FIELD_OFFSET (TRANSPORT_ADDRESS, Address[0].Address[
                                connectInfo->RemoteAddress.Address[0].AddressLength]);
    localAddress = (PTA_ADDRESS)
            &(connectInfo->RemoteAddress.Address[0].Address[
                    connectInfo->RemoteAddress.Address[0].AddressLength]);
    if (&localAddress->Address[localAddress->AddressLength]-(PUCHAR)Irp->AssociatedIrp.SystemBuffer>
            (LONG)IrpSp->Parameters.DeviceIoControl.InputBufferLength) {
        status = STATUS_INVALID_PARAMETER;
        goto complete;
    }

    if (!IS_SAN_HELPER(sanHlprEndpoint) ||
          sanHlprEndpoint->OwningProcess!=IoGetCurrentProcess ()) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    //
    // We will separate addresses, so change the count
    //
    connectInfo->RemoteAddress.TAAddressCount = 1;
    
#ifdef _WIN64
    if (IoIs32bitProcess (Irp)) {
        u.acceptInfo32 = MmGetMdlVirtualAddress (Irp->MdlAddress);
        ASSERT (u.acceptInfo32!=NULL);
        ASSERT (MmGetMdlByteCount (Irp->MdlAddress)>=sizeof (*u.acceptInfo32));
    }
    else
#endif // _WIN64
    {   
        u.acceptInfo = MmGetMdlVirtualAddress (Irp->MdlAddress);
        ASSERT (u.acceptInfo!=NULL);
        ASSERT (MmGetMdlByteCount (Irp->MdlAddress)>=sizeof (*u.acceptInfo));
    }

    //
    // Get the listening file object and verify its type and state
    //
    status = ObReferenceObjectByHandle (
                connectInfo->ListenHandle,
                (IrpSp->Parameters.DeviceIoControl.IoControlCode >> 14) & 3,   // DesiredAccess
                *IoFileObjectType,
                Irp->RequestorMode,
                (PVOID)&listenFileObject,
                NULL);
    if (!NT_SUCCESS (status)) {
        goto complete;
    }

    if (IoGetRelatedDeviceObject (listenFileObject)!=AfdDeviceObject) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }

    listenEndpoint = listenFileObject->FsContext;
    if ( !listenEndpoint->Listening ||
            listenEndpoint->State == AfdEndpointStateClosing ||
            listenEndpoint->EndpointCleanedUp ) {
        status = STATUS_INVALID_HANDLE;
        goto complete;
    }


    IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanConnectHandler: endp-%p, irp-%p.\n", 
                        listenEndpoint,
                        Irp));
    }


    if (!IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint)) {
        //
        // Keep getting accept IRPs/connection structures till
        // we find one that can be used to satisfy connect indication
        // or queue it.
        //
        while ((connection = AfdGetFreeConnection( listenEndpoint, &acceptIrp ))!=NULL
                            && acceptIrp!=NULL) {
            PAFD_ENDPOINT           acceptEndpoint;
            PFILE_OBJECT            acceptFileObject;
            PIO_STACK_LOCATION      irpSp;

            IF_DEBUG(LISTEN) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdSanConnectHandler: using connection %lx\n",
                              connection ));
            }

            ASSERT( connection->Type == AfdBlockTypeConnection );


            irpSp = IoGetCurrentIrpStackLocation (acceptIrp);
            acceptFileObject = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdAcceptFileObject;
            acceptEndpoint = acceptFileObject->FsContext;
            ASSERT (IS_AFD_ENDPOINT_TYPE (acceptEndpoint));
            ASSERT (acceptIrp->Tail.Overlay.DriverContext[0] == connection);
            ASSERT (connection->Endpoint == NULL);

            InterlockedDecrement (
                &listenEndpoint->Common.VcListening.FailedConnectionAdds);
            InterlockedPushEntrySList (
                &listenEndpoint->Common.VcListening.FreeConnectionListHead,
                &connection->SListEntry
                );
            DEBUG   connection = NULL;

            //
            // Make sure connection indication comes from current process.
            // (we do check it indirectly up above when validating the request.
            // This check is explicit).
            //
            if (IoThreadToProcess (Irp->Tail.Overlay.Thread)==IoGetCurrentProcess ()) {
                //
                // Check if super accept Irp has enough space for
                // the remote address
                //
                if( (ULONG)RemoteAddressLength <=
                        irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength ) {
                    //
                    // Check if we have enough system PTE's to map
                    // the buffer.
                    //
                    status = AfdMapMdlChain (acceptIrp->MdlAddress);
                    if( NT_SUCCESS (status) ) {
                        HANDLE  acceptHandle;
                        BOOLEAN handleDuplicated;
                        if (IoThreadToProcess (Irp->Tail.Overlay.Thread)==
                                IoThreadToProcess (acceptIrp->Tail.Overlay.Thread)) {
                            acceptHandle = acceptIrp->Tail.Overlay.DriverContext[3];
                            status = STATUS_SUCCESS;
                            handleDuplicated = FALSE;
                        }
                        else {
                            //
                            // Listen process is different than the accepting one.
                            // We need to duplicate accepting handle into the listening
                            // process so that accept can take place there and the accepting
                            // socket will later get dup-ed into the accepting process when
                            // that process performs an IO operation on it.
                            //
                            status = ObOpenObjectByPointer (
                                                    acceptFileObject,
                                                    OBJ_CASE_INSENSITIVE,
                                                    NULL,
                                                    MAXIMUM_ALLOWED,
                                                    *IoFileObjectType,
                                                    KernelMode,
                                                    &acceptHandle);
                            handleDuplicated = TRUE; // If we fail duplication above,
                                                     // this variable is not used
                                                     // so setting it to TRUE won't
                                                        // have any effect.
                        }
                        if (NT_SUCCESS (status)) {
                            AfdAcquireSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                            if (!acceptEndpoint->EndpointCleanedUp) {
                                IoSetCancelRoutine (acceptIrp, AfdSanCancelAccept);
                                if (!acceptIrp->Cancel) {
                                    //
                                    // Copy the remote address from the connection object
                                    //
#ifndef i386
                                    if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                                        USHORT addressLength = 
                                                connectInfo->RemoteAddress.Address[0].AddressLength
                                                + sizeof (USHORT);
                                        USHORT UNALIGNED *pAddrLength = (PVOID)
                                                    ((PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdRemoteAddressLength
                                                     - sizeof (USHORT));
                                        RtlMoveMemory (
                                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                                     &connectInfo->RemoteAddress.Address[0].AddressType,
                                                     addressLength);
                                        *pAddrLength = addressLength;
                                    }
                                    else
#endif
                                    {
                                        RtlMoveMemory (
                                                    (PUCHAR)MmGetSystemAddressForMdl (acceptIrp->MdlAddress)
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength
                                                     + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength,
                                                     &connectInfo->RemoteAddress,
                                                     RemoteAddressLength);
                                    }

                                    if (irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength>0) {
                                        TDI_ADDRESS_INFO  UNALIGNED *addressInfo = (PVOID)
                                                ((PUCHAR)MmGetSystemAddressForMdl(acceptIrp->MdlAddress)
                                                    + irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength);
#ifndef i386
                                        if (acceptEndpoint->Common.VcConnecting.FixAddressAlignment) {
                                            USHORT UNALIGNED * pAddrLength = (PVOID)
                                                ((PUCHAR)addressInfo 
                                                +irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdLocalAddressLength
                                                -sizeof(USHORT));
                                            RtlMoveMemory (
                                                addressInfo,
                                                &localAddress->AddressType,
                                                localAddress->AddressLength+sizeof (USHORT));
                                            *pAddrLength = localAddress->AddressLength+sizeof (USHORT);
                                        }
                                        else
#endif
                                        {
                                            addressInfo->ActivityCount = 0;
                                            addressInfo->Address.TAAddressCount = 1;
                                            RtlMoveMemory (
                                                &addressInfo->Address.Address,
                                                localAddress,
                                                FIELD_OFFSET (TA_ADDRESS, Address[localAddress->AddressLength]));

                                        }
                                    }
    
                                    ASSERT (acceptEndpoint->Irp==acceptIrp);
                                    acceptEndpoint->Irp = NULL;

                                    //
                                    // Convert endpoint to SAN
                                    //
                                    AfdSanInitEndpoint (sanHlprEndpoint, acceptFileObject, connectInfo->SwitchContext);
                                    UPDATE_ENDPOINT (acceptEndpoint);
                                    InsertTailList (&acceptEndpoint->Common.SanEndp.IrpList,
                                                        &acceptIrp->Tail.Overlay.ListEntry);

        
        
                                    //
                                    // Setup output for switch and complete its IRP
                                    //
                                    // Do this under protection of exception handler since application
                                    // can change protection attributes of the virtual address range
                                    // or even deallocate it.
                                    try {
#ifdef _WIN64
                                        if (IoIs32bitProcess (Irp)) {
                                            u.acceptInfo32->AcceptHandle = (VOID * POINTER_32)acceptHandle;
                                            u.acceptInfo32->ReceiveLength = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;
                                            Irp->IoStatus.Information = sizeof (*u.acceptInfo32);
                                        }
                                        else
#endif //_WIN64
                                        {
                                            u.acceptInfo->AcceptHandle = acceptHandle;
                                            u.acceptInfo->ReceiveLength = irpSp->Parameters.AfdRestartSuperAcceptInfo.AfdReceiveDataLength;
                                            Irp->IoStatus.Information = sizeof (*u.acceptInfo);
                                        }
                                    }
                                    except (AFD_EXCEPTION_FILTER (&status)) {
                                        //
                                        // If the app is playing with switch's virtual addresses
                                        // we can't help much - it's accept IRP will probably
                                        // just hang since the switch is not going to follow
                                        // the failed connect IRP with accept completion.
                                        //
                                    }

                                    AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                    AfdRecordConnectionsPreaccepted ();

                                    Irp->IoStatus.Status = STATUS_SUCCESS;
                                    IoCompleteRequest (Irp, AfdPriorityBoost);

                                    ObDereferenceObject (listenFileObject);
                                    IF_DEBUG(SAN_SWITCH) {
                                        KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                                    "AfdSanConnectHandler: pre-accepted, endp-%p, SuperAccept irp-%p\n",
                                                    acceptEndpoint, acceptIrp));
                                    }

                                    return STATUS_SUCCESS;
                                }
                                else { //if (!acceptIrp->Cancel
                                    if (IoSetCancelRoutine (acceptIrp, NULL)==NULL) {
                                        KIRQL cancelIrql;
                                        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                        IoAcquireCancelSpinLock (&cancelIrql);
                                        IoReleaseCancelSpinLock (cancelIrql);
                                    }
                                    else {
                                        AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
                                    }
                                }
                            }
                            else { // if (!acceptEndpoint->EndpointCleanedUp)
                                AfdReleaseSpinLock (&acceptEndpoint->SpinLock, &lockHandle);
					            IF_DEBUG(SAN_SWITCH) {
                                    KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                                                "AfdSanConnectHandler: accept endpoint cleanedup. endp=%lx",
							                    acceptEndpoint));
                                }
                            }
                            if (handleDuplicated) {
#if DBG
                                status =
#endif
                                    NtClose (acceptHandle);
                            }
                            ASSERT (NT_SUCCESS (status));
                            status = STATUS_CANCELLED;

                        } // if (!accept handle duplication succeeded)

                    } // if (!MDL mapping succeeded).
                }
		        else {
		          status = STATUS_BUFFER_TOO_SMALL;
		        }
            }
            else {
                status = STATUS_INVALID_HANDLE;
            }
            UPDATE_ENDPOINT2 (acceptEndpoint, 
                            "AfdSanConnectHandler, Superaccept failed with status: %lx",
                            status);
            AfdCleanupSuperAccept (acceptIrp, status);
            IoCompleteRequest (acceptIrp, AfdPriorityBoost);
        }
    }
    else {
        //
        // We have little choice but create an extra connection
        // on the fly since regular connection are posted to
        // the transport as TDI_LISTENs.
        //

        status = AfdCreateConnection(
                     &listenEndpoint->TransportInfo->TransportDeviceName,
                     listenEndpoint->AddressHandle,
                     IS_TDI_BUFFERRING(listenEndpoint),
                     listenEndpoint->InLine,
                     listenEndpoint->OwningProcess,
                     &connection
                     );
        if (!NT_SUCCESS (status)) {
            goto complete;
        }

        InterlockedDecrement (
            &listenEndpoint->Common.VcListening.FailedConnectionAdds);
    }


    if (connection!=NULL) {
        LIST_ENTRY  irpList;

        ASSERT (connection->Endpoint == NULL);

        if ( connection->RemoteAddress != NULL &&
                 connection->RemoteAddressLength < (ULONG)RemoteAddressLength ) {

            AFD_RETURN_REMOTE_ADDRESS(
                connection->RemoteAddress,
                connection->RemoteAddressLength
                );
            connection->RemoteAddress = NULL;
        }

        if ( connection->RemoteAddress == NULL ) {

            connection->RemoteAddress = AFD_ALLOCATE_REMOTE_ADDRESS (RemoteAddressLength);
            if (connection->RemoteAddress==NULL) {
                AfdSanReleaseConnection (listenEndpoint, connection, TRUE);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto complete;
            }
        }

        connection->RemoteAddressLength = RemoteAddressLength;

        RtlMoveMemory(
            connection->RemoteAddress,
            &connectInfo->RemoteAddress,
            RemoteAddressLength
            );

        //
        // We just got a connection without AcceptEx IRP
        // We'll have to queue the IRP, setup cancel routine and pend it
        //

        AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
        //
        // Setup the connection, so cancel routine can 
        // operate on it properly.
        //
        connection->ConnectIrp = NULL;
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = connection;

        IoSetCancelRoutine (Irp, AfdSanCancelConnect);

        if (Irp->Cancel) {
            if (IoSetCancelRoutine (Irp, NULL)==NULL) {
                KIRQL cancelIrql;
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
                //
                // Cancel routine is running, let it complete
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            else {
                AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);
            }

            AfdSanReleaseConnection (listenEndpoint, connection, TRUE);
            status = STATUS_CANCELLED;
            goto complete;
        }

        IoMarkIrpPending (Irp);

        connection->Endpoint = listenEndpoint;
        REFERENCE_ENDPOINT (listenEndpoint);

        connection->ConnectIrp = Irp;
        connection->SanConnection = TRUE;


        connection->State = AfdConnectionStateUnaccepted;

        InitializeListHead (&irpList);

        //
        // Try to find AcceptEx or Listen IRP to complete.
        //
        while (1) {
            PIRP    waitForListenIrp;

            if (!IS_DELAYED_ACCEPTANCE_ENDPOINT (listenEndpoint)) {
                if (AfdServiceSuperAccept (listenEndpoint, connection, &lockHandle, &irpList)) {
                    goto CompleteIrps;
                }
            }
            

            //
            // Complete listen IRPs until we find the one that has enough space
            // for the remote address.
            //
            if (IsListEmpty( &listenEndpoint->Common.VcListening.ListeningIrpListHead ) )
                break;


            //
            // Get a pointer to the current IRP, and get a pointer to the
            // current stack lockation.
            //

            waitForListenIrp = CONTAINING_RECORD(
                                   listenEndpoint->Common.VcListening.ListeningIrpListHead.Flink,
                                   IRP,
                                   Tail.Overlay.ListEntry
                                   );

            //
            // Take the first IRP off the listening list.
            //

            RemoveEntryList(
                            &waitForListenIrp->Tail.Overlay.ListEntry
                            );

            waitForListenIrp->Tail.Overlay.ListEntry.Flink = NULL;

            IF_DEBUG(SAN_SWITCH) {
                KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                            "AfdSanConnectHandler: completing IRP %lx\n",
                            waitForListenIrp ));
            }

            status = AfdServiceWaitForListen (waitForListenIrp,
                                                connection,
                                                &lockHandle);
            if (NT_SUCCESS (status)) {
                ObDereferenceObject (listenFileObject);
                return STATUS_PENDING;
            }

            //
            // Synchronize with cancel routine if it is running
            //
            if (IoSetCancelRoutine (waitForListenIrp, NULL)==NULL) {
                KIRQL cancelIrql;
                //
                // The cancel routine won't find the IRP on the list
                // Just make sure it completes before we complete the IRP.
                //
                IoAcquireCancelSpinLock (&cancelIrql);
                IoReleaseCancelSpinLock (cancelIrql);
            }
            IoCompleteRequest (waitForListenIrp, AfdPriorityBoost);
            AfdAcquireSpinLock (&listenEndpoint->SpinLock, &lockHandle);
        }

        //
        // At this point, we still hold the AFD spinlock.
        // and we could find matching listen request.
        // Put the connection on unaccepted list.
        //


        InsertTailList(
            &listenEndpoint->Common.VcListening.UnacceptedConnectionListHead,
            &connection->ListEntry
            );

        IF_DEBUG(SAN_SWITCH) {
            KdPrintEx(( DPFLTR_WSOCKTRANSPORT_ID, DPFLTR_TRACE_LEVEL,
                        "AfdSanConnectHandler: unaccepted, conn-%p\n",
                        connection));
        }

        //
        // Listening endpoint is never a specifically SAN endpoint.
        // Poll/EventSelect events on it are handled like on a regular
        // TCP/IP endpoint - no need for special tricks like on connected/accepted
        // endpoints.
        //
        AfdIndicateEventSelectEvent(
            listenEndpoint,
            AFD_POLL_ACCEPT,
            STATUS_SUCCESS
            );
        AfdReleaseSpinLock (&listenEndpoint->SpinLock, &lockHandle);

        //
        // If there are outstanding polls waiting for a connection on this
        // endpoint, complete them.
        //

        AfdIndicatePollEvent(
            listenEndpoint,
            AFD_POLL_ACCEPT,
            STATUS_SUCCESS
                );

    CompleteIrps:
        //
        // Complete previously failed accept irps if any.
        //
        while (!IsListEmpty (&irpList)) {
            PIRP    irp;
            irp = CONTAINING_RECORD (irpList.Flink, IRP, Tail.Overlay.ListEntry);
            RemoveEntryList (&irp->Tail.Overlay.ListEntry);
            IoCompleteRequest (irp, AfdPriorityBoost);
        }
        ObDereferenceObject (listenFileObject);

        return STATUS_PENDING;
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    UPDATE_ENDPOINT2 (listenEndpoint, 
                        "AfdSanConnectHandler, accept failed with status: %lx",
                        status);

complete:
 
    if (listenFileObject!=NULL) {
        ObDereferenceObject (listenFileObject);
    }
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, AfdPriorityBoost);

    return status;
}


NTSTATUS
AfdSanFastCompleteAccept (
    IN  PFILE_OBJECT        FileObject,
    IN  ULONG               IoctlCode,
    IN  KPROCESSOR_MODE     RequestorMode,
    IN  PVOID               InputBuffer,
    IN  ULONG               InputBufferLength,
    IN  PVOID               OutputBuffer,
    IN  ULONG               OutputBufferLength,
    OUT PUINT_PTR           Information
    )
/*++

Routine Description:

    Completes the Accept operation initiated by the SAN provider

Arguments:
    FileObject      - SAN helper object - communication channel between the
                        switch and AFD in the process.
    IoctlCode       - operation IOCTL code (IOCTL_AFD_SWITCH_CMPL_ACCEPT)
    RequestorMode   - mode of the caller
    InputBuffer     - input parameters for the operation (AFD_SWITCH_CONTEXT_INFO)
                            SocketHandle    - handle of the accepting endpoint
                            SwitchContext   - switch context associated with the endpoint
    InputBufferLength - sizeof(AFD_SWITCH_CONTEXT_INFO)
    OutputBuffer    - data to copy into the AcceptEx receive buffer
    OutputBufferLength - size of received data
    Information     - pointer for buffer to place return information into, unused
                    

Return Value:
    STATUS_SUCCESS - operation succeeded
    STATUS_INVALID_HANDLE - helper endpoint or switch socket is of incorrect type
    STATUS_INVALID_PARAMETER - input buffer is of incorrect size.
    STATIS_LOCAL_DISCONNECT - accept was aborted by the application.
    other - failed when attempting to access accept socket, input buffer, or switch context.

--*/
{
    NTSTATUS status;
    PIRP    acceptIrp;
    AFD_LOC