XT("smmscrpt.dll"));
            if (hInst)
                FreeLibrary(hInst);
            else
                bRC = FALSE;
            hInst = NULL;
        }
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function    InstallScripter
//
//    Synopsis    Install scripting on win95 950.6 builds (not on OSR2)
//
//    Arguments    none
//
//    Returns        none
//
//    History        10/9/96    ChrisK    Copied from mt.cpp in \\trango sources
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//-----------------------------------------------------------------------------
void CICWSystemConfig::InstallScripter()
{
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                    msg ;
    DWORD                iWaitResult = 0;

    TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Install Scripter.\r\n"));

    //
    // check if scripting is already set up
    //
    if (!IsScriptingInstalled())
    {
        memset(&pi, 0, sizeof(pi));
        memset(&si, 0, sizeof(si));
        if(!CreateProcess(NULL, TEXT("icwscrpt.exe"), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
        {
            TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Cant find ICWSCRPT.EXE\r\n"));
        }
        else
        {
            TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Launched ICWSCRPT.EXE. Waiting for exit.\r\n"));
            //
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            //
            while((iWaitResult=MsgWaitForMultipleObjects(1, &pi.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
            {
                //
                // read all of the messages in this next loop
                   // removing each message as we read it
                //
                   while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                   {
                    TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Got msg\r\n"));
                    //
                    // how to handle quit message?
                    //
                    if (msg.message == WM_QUIT)
                    {
                        TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: Got quit msg\r\n"));
                        goto done;
                    }
                    else
                        DispatchMessage(&msg);
                }
            }
        done:
             CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            TraceMsg(TF_SYSTEMCONFIG, TEXT("ICWHELP: ICWSCRPT.EXE done\r\n"));
        }
    }
}

//+----------------------------------------------------------------------------
//    Function    ConfigSystem
//
//    Synopsis    Make sure that the system is configured for RAS operations
//
//    Arguments    none
//
//    Return        FALSE - if the is not configured.  Caller needs to
//              call NeedsReboot QuitWizard to get the proper action
//              to take.
//              NeedsReboot means that we installed stuff, but need the user
//              to reboot for the changes to take place
//              QuitWizard means just that, time to bail out
//              Neither set, means to ask the user user if they really want to
//              Quit.
//              TRUE  - The things are ready to go
//
//    History        10/16/96    ChrisK    Created
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
STDMETHODIMP CICWSystemConfig::ConfigSystem(BOOL *pbRetVal)
{
    HINSTANCE   hinetcfg;
    TCHAR       szBuff256[256+1];
    FARPROC     fp;
    HRESULT     hr;
    
    // Assume a failure below.
    *pbRetVal = FALSE;

    //
    // Locate installation entry point
    //
    hinetcfg = LoadLibrary(TEXT("INETCFG.DLL"));
    if (!hinetcfg)
    {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("INETCFG.DLL"));
        ::MessageBox(GetActiveWindow(),szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
        m_bQuitWizard = TRUE;
        return S_OK;
    }

    fp = GetProcAddress(hinetcfg,"InetConfigSystem");
    if (!fp)
    {
        MsgBox(IDS_CANTLOADCONFIGAPI, MB_MYERROR);
        m_bQuitWizard = TRUE;
        return S_OK;
    }

    // Disable the active window, since any UI the following function brings
    // up needs to be modal.
    HWND    hWnd = GetActiveWindow();
    
    // Install and configure TCP/IP and RNA
    hr = ((PFNCONFIGAPI)fp)(hWnd,
                            INETCFG_INSTALLRNA | 
                            INETCFG_INSTALLTCP | 
                            INETCFG_INSTALLMODEM |
                            (IsNT()?INETCFG_SHOWBUSYANIMATION:0) |
                            INETCFG_REMOVEIFSHARINGBOUND,
                            &m_bNeedsReboot);

    // Renable the window, and bring it back to the top of the Z-Order
    ::SetForegroundWindow(hWnd);
//    ::BringWindowToTop(hWnd);
//    ::SetWindowPos(hWnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
                                
    if (hinetcfg) 
        FreeLibrary(hinetcfg);
    hinetcfg = NULL;

    // See what happened during the config call
    if (hr == ERROR_CANCELLED) 
    {
        return S_OK;
    } 
    else if (hr != ERROR_SUCCESS) 
    {
        WORD wTemp = ( VER_PLATFORM_WIN32_WINDOWS == g_dwPlatform )
            ? IDS_CONFIGAPIFAILEDRETRY : IDS_CONFIGURENTFAILEDRETRY;

        //
        // No retry anymore as its not going to help, just
        // provide the user with  an OK message
        // MKarki (4/15/97) Fix for Bug #7004
        //
        ::MessageBox(GetActiveWindow(),GetSz(wTemp),GetSz(IDS_TITLE),
                        MB_MYERROR | MB_OK);
        m_bQuitWizard = TRUE;
        return hr;
    } 
    else
    {
        // ChrisK - added 10/9/96
        // BUGBUG can this fail, and if so is it a problem???
        // original ICW code does not handle failure case here
        InstallScripter();  
    }

    
    // See if we need to reboot.  If not, we need to see if the user is logged in
    if (!m_bNeedsReboot)
    {
        TCHAR   szUser[MAX_PATH];
        DWORD   cbUser = sizeof(szUser);
        
        // Verify the user is logged on.
        if (NO_ERROR != WNetGetUser(NULL,szUser, &cbUser))
        {
            // Failed to get user info, so we need to restart with a loggin
            m_bNeedsRestart = TRUE;
        }
        else
        {
            // User is logged in, so we are happy.
            *pbRetVal = TRUE;
        }
    }
    return S_OK;
}

STDMETHODIMP CICWSystemConfig::get_NeedsReboot(BOOL * pVal)
{
    *pVal = m_bNeedsReboot;
    return S_OK;
}

STDMETHODIMP CICWSystemConfig::get_NeedsRestart(BOOL * pVal)
{
    *pVal = m_bNeedsRestart;
    return S_OK;
}

STDMETHODIMP CICWSystemConfig::get_QuitWizard(BOOL * pVal)
{
    *pVal = m_bQuitWizard;
    return S_OK;
}

//+----------------------------------------------------------------------------
//    Function    VerifyRasServicesRunning
//
//    Synopsis    Make sure that the RAS services are enabled and running
//
//    Arguments    none
//
//    Return        FALSE - if the services couldn't be started
//
//    History        10/16/96    ChrisK    Created
//              1/13/98 DONALDM Copied from ICW \\drywall\slm
//
//-----------------------------------------------------------------------------
STDMETHODIMP CICWSystemConfig::VerifyRASIsRunning(BOOL *pbRetVal)
{
    HINSTANCE   hInst = NULL;
    FARPROC     fp = NULL;
    HRESULT     hr;

    *pbRetVal   = FALSE;        // Don't assume a positive result
    hInst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hInst)
    {
        fp = GetProcAddress(hInst, "InetStartServices");
        if (fp)
        {
            //
            // Check Services
            //
            hr = ((PFINETSTARTSERVICES)fp)();
            if (ERROR_SUCCESS == hr)
            {
                *pbRetVal = TRUE;   // Success.
            }
            else
            {
                // Report the error, using the Current Active Window
                ::MessageBox(GetActiveWindow(), GetSz(IDS_SERVICEDISABLED),
                    GetSz(IDS_TITLE),MB_MYERROR | MB_OK);
            }
        }
        FreeLibrary(hInst);
    }
    return S_OK;
}

const TCHAR szNetworkPolicies[] = REGSTR_PATH_POLICIES TEXT("\\") REGSTR_KEY_NETWORK;
const TCHAR szDisableCaching[] = REGSTR_VAL_DISABLEPWDCACHING;

//+----------------------------------------------------------------------------
//    Function    CheckPasswordCachingPolicy
//
//    Synopsis    check to see if a policy as been set against password caching
//
//    Arguments   none
//
//    Return      TRUE - if password caching is disabled
//
//    History        
//
//-----------------------------------------------------------------------------
STDMETHODIMP CICWSystemConfig::CheckPasswordCachingPolicy(BOOL *pbRetVal)
{
    CMcRegistry reg;

    *pbRetVal = FALSE;
        
    // Open the Network policies key    
    if (reg.OpenKey(HKEY_LOCAL_MACHINE, szNetworkPolicies))
    {
        DWORD  dwVal = 0;
        // Get the disableCaching value
        if (reg.GetValue(szDisableCaching, dwVal))
        {
            // if set, then set the return code to TRUE.
            if(dwVal)
            {
                *pbRetVal = TRUE;
                
                TCHAR szLongString[1024];
                TCHAR *pszSmallString1, *pszSmallString2;

                // 4/28/97 ChrisK
                // Fix build break, because string was too long for compiler.
                pszSmallString1 = GetSz(IDS_PWCACHE_DISABLED1);
                pszSmallString2 = GetSz(IDS_PWCACHE_DISABLED2);
                lstrcpy(szLongString,pszSmallString1);
                lstrcat(szLongString,pszSmallString2);
                
                ::MessageBox(GetActiveWindow(),szLongString,GetSz(IDS_TITLE), MB_MYERROR);
                
                // We are going to kill the app, so hide it now
                ::ShowWindow(GetActiveWindow(), SW_HIDE);
            }
        }
    }                                    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\enumodem.cpp ===
/*-----------------------------------------------------------------------------
	enumodem.cpp

	Holds code that deals with the "Choose a modem" dialog needed when user has
	multiple modems installed

	Copyright (C) 1996-1998 Microsoft Corporation
	All rights reserved

	Authors:
		jmazner Jeremy Mazner

	History:
		10/19/96        jmazner Created, cloned almost verbatim from 
							INETCFG's rnacall.cpp and export.cpp    
        1-9-98          donaldm Adapted from ICWCONN1
-----------------------------------------------------------------------------*/


#include "stdafx.h"
#include "enumodem.h"

#include <windowsx.h>

// from psheet.cpp
extern void ProcessDBCS(HWND hDlg, int ctlID);


/*******************************************************************

  NAME:    CEnumModem::CEnumModem

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
	this, due to how the enumerators function

********************************************************************/
CEnumModem::CEnumModem() :
  m_dwError(ERROR_SUCCESS),m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;
}


/*******************************************************************

  NAME:     CEnumModem::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD CEnumModem::ReInit()
{
  DWORD cbSize = 0;
  RNAAPI cRnaapi;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  m_dwError = cRnaapi.RasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new CHAR[cbSize];
  if (NULL == m_lpData)
  {
	  TraceMsg(TF_GENERAL, TEXT("ICWCONN1: CEnumModem: Failed to allocate device list buffer\n"));
	  m_dwError = ERROR_NOT_ENOUGH_MEMORY;
	  return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = cRnaapi.RasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

    if (ERROR_SUCCESS != m_dwError)
	return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;

	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
		if ((0 == lstrcmpi(RASDEVICETYPE_MODEM,m_lpData[idx].szDeviceType)) || 
            (0 == lstrcmpi(RASDEVICETYPE_ISDN,m_lpData[idx].szDeviceType)))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice ,&m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}


  return m_dwError;
}


/*******************************************************************

  NAME:    CEnumModem::~CEnumModem

  SYNOPSIS:  Destructor for class

********************************************************************/
CEnumModem::~CEnumModem()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     CEnumModem::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
	    NULL if no more modems or error occurred.  Call GetError
	    to determine if error occurred.

********************************************************************/
TCHAR * CEnumModem::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
	    device name that matches.  Returns
	    NULL if no device with specified name is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceTypeFromName(LPTSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
	    device type that matches.  Returns
	    NULL if no device with specified Type is found

********************************************************************/

TCHAR * CEnumModem::GetDeviceNameFromType(LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
        return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceName
            CEnumModem::GetDeviceType

  SYNOPSIS: Returns the device name or type for the selected device.

  REMARKS:
            ONLY call this function after calling ReInit to initialize
            the device list. The device index is relative to the 
            current copy of the device list.

  EXIT:     Returns a pointer to the device name or type. 

  donsc - 3/11/98 
      Added this function because we need to be able to select a device
      from the list.
********************************************************************/

TCHAR * CEnumModem::GetDeviceName(DWORD dwIndex)
{
    if(dwIndex>=m_dwNumEntries)
        return NULL;

    return m_lpData[dwIndex].szDeviceName;
}

TCHAR * CEnumModem::GetDeviceType(DWORD dwIndex)
{
    if(dwIndex>=m_dwNumEntries)
        return NULL;

    return m_lpData[dwIndex].szDeviceType;
}


/*******************************************************************

  NAME:     CEnumModem::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
	    and type given.

  EXIT:     Returns TRUE if the specified device was found, 
	    FALSE otherwise.

********************************************************************/

BOOL CEnumModem::VerifyDeviceNameAndType(LPTSTR szDeviceName, LPTSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmp(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmp(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}





/*******************************************************************

  NAME:     ChooseModemDlgProc

  SYNOPSIS: Dialog proc for choosing modem

********************************************************************/

INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
    BOOL fRet;

    switch (uMsg)
    {
        case WM_INITDIALOG:
          {
              // lParam contains pointer to CHOOSEMODEMDLGINFO struct, set it
              // in window data
              Assert(lParam);
              PCHOOSEMODEMDLGINFO pInfo = (PCHOOSEMODEMDLGINFO) lParam;
              pInfo->hr = ERROR_SUCCESS;
              SetWindowLongPtr(hDlg,DWLP_USER,lParam);
              fRet = ChooseModemDlgInit(hDlg,pInfo);
              if (!fRet)
              {
                  // An error occured.
                  EndDialog(hDlg,FALSE);
                  pInfo->hr = ERROR_INETCFG_UNKNOWN;
              }
              return fRet;
          }
          break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
            case IDC_CMDOK:
                {
                    // get data pointer from window data
                    PCHOOSEMODEMDLGINFO pChooseModemDlgInfo =
                        (PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
                    Assert(pChooseModemDlgInfo);

                    // pass the data to the OK handler
                    fRet=ChooseModemDlgOK(hDlg,pChooseModemDlgInfo);
                    if (fRet)
                    {
                        EndDialog(hDlg,TRUE);
                        pChooseModemDlgInfo->hr = ERROR_SUCCESS;
                    }
                }
                break;

            case IDC_CMDCANCEL:
            case IDCANCEL:
                {
                    PCHOOSEMODEMDLGINFO pInfo = (PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
                   EndDialog(hDlg,FALSE);
                   pInfo->hr = ERROR_CANCELLED;
                }
                break;                  
            }
            break;
    }

    return FALSE;
}


/*******************************************************************

  NAME:    ChooseModemDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
    Assert(pChooseModemDlgInfo);

    // put the dialog in the center of the screen
    //RECT rc;
    //GetWindowRect(hDlg, &rc);
    //SetWindowPos(hDlg, NULL,
    //      ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    //      ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    //      0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

    ProcessDBCS(hDlg, IDC_MODEM);
    // fill the combobox with available modems
    DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
    pChooseModemDlgInfo->hr = dwRet;
    if (ERROR_SUCCESS != dwRet)
    {
        TraceMsg(TF_GENERAL,TEXT("ICWCONN1: ChooseModemDlgInit: Error initializing modem list!\n"));
        return FALSE;
    }

    return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemDlgOK

  SYNOPSIS:  OK handler for dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
	Assert(pChooseModemDlgInfo);

	// should always have a selection in combo box if we get here
	Assert(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM)) >= 0);

	// get modem name out of combo box
	ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
		pChooseModemDlgInfo->szModemName,
		sizeof(pChooseModemDlgInfo->szModemName));
	Assert(lstrlen(pChooseModemDlgInfo->szModemName));
    
	// clear the modem list
	ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));
	
	return TRUE;
}


/*******************************************************************

  NAME:    InitModemList

  SYNOPSIS:  Fills a combo box window with installed modems

  ENTRY:    hCB - combo box window to fill
  
********************************************************************/
HRESULT InitModemList (HWND hCB)
{
	TraceMsg(TF_GENERAL,TEXT("ICWCONN1::enumodem.cpp  InitModemList()\n"));

	LPTSTR pNext;
	int   nIndex;
	Assert(hCB);

	CEnumModem cEnumModem;

    cEnumModem.ReInit();

	// clear out the combo box
	ComboBox_ResetContent(hCB);

	while ( pNext = cEnumModem.Next() )
	{
		// Add the device to the combo box
		nIndex = ComboBox_AddString(hCB, pNext);
		ComboBox_SetItemData(hCB, nIndex, NULL);
	}

	// Select the default device
	ComboBox_SetCurSel(hCB, nIndex);

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\icwhelp.cpp ===
// icwhelp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL,
//        run nmake -f icwhelpps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "icwhelp.h"

#include "icwhelp_i.c"
#include "RefDial.h"
#include "DialErr.h"
#include "SmStart.h"
#include "ICWCfg.h"
#include "tapiloc.h"
#include "UserInfo.h"
#include "webgate.h"
#include "INSHandler.h"

const TCHAR c_szICWDbgEXE[] = TEXT("ICWDEBUG.EXE");
const TCHAR c_szICWEXE[]    = TEXT("ICWCONN1.EXE");


CComModule _Module;

BOOL    g_fRasIsReady = FALSE;
BOOL    g_bProxy = FALSE;
DWORD   g_dwPlatform = 0xFFFFFFFF;
DWORD   g_dwBuild = 0xFFFFFFFF;
LPTSTR  g_pszAppDir = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_RefDial, CRefDial)
    OBJECT_ENTRY(CLSID_DialErr, CDialErr)
    OBJECT_ENTRY(CLSID_SmartStart, CSmartStart)
    OBJECT_ENTRY(CLSID_ICWSystemConfig, CICWSystemConfig)
    OBJECT_ENTRY(CLSID_TapiLocationInfo, CTapiLocationInfo)
    OBJECT_ENTRY(CLSID_UserInfo, CUserInfo)
    OBJECT_ENTRY(CLSID_WebGate, CWebGate)
    OBJECT_ENTRY(CLSID_INSHandler, CINSHandler)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TCHAR   szPath[MAX_PATH];
        BOOL    fBail = TRUE;

        // Make sure the attaching process is ICWCONN1.EXE. If not, we won't
        // load
        if (GetModuleFileName(NULL, szPath, sizeof(szPath)))
        {
            // See of the file name part of the path contains what we expect
            if ( (NULL != _tcsstr(_tcsupr(szPath), c_szICWEXE)) || (NULL != _tcsstr(_tcsupr(szPath), c_szICWDbgEXE)))
                fBail = FALSE;
        }

// Allow a debug override of the check
#ifdef DEBUG
        {
            // See if we should override the BAIL out for debug
            if (fBail)
            {
                HKEY    hkey;
                DWORD   dwSize = 0;
                DWORD   dwType = 0;
                DWORD   dwData = 0;
                if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
                                                TEXT("Software\\Microsoft\\ISignup\\Debug"),
                                                &hkey))
                {
                    dwSize = sizeof(dwData);
                    if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                                         TEXT("AllowICWHELPToRun"),
                                                         0,
                                                         &dwType,
                                                         (LPBYTE)&dwData,
                                                         &dwSize))
                    {
                        // Override the fBail if dwData is non-zero
                        fBail = (0 == dwData);
                    }
                }

                if (hkey)
                    RegCloseKey(hkey);
            }
        }
#endif
        if (fBail)
        {
            // We are outa here!!!
            return(FALSE);
        }

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        // Get the OS Version
        if (0xFFFFFFFF == g_dwPlatform)
        {
            OSVERSIONINFO osver;
            ZeroMemory(&osver,sizeof(osver));
            osver.dwOSVersionInfoSize = sizeof(osver);
            if (GetVersionEx(&osver))
            {
                g_dwPlatform = osver.dwPlatformId;
                g_dwBuild = osver.dwBuildNumber & 0xFFFF;
            }
        }

        // Get the AppDir
        LPTSTR   p;
        g_pszAppDir = (LPTSTR)GlobalAlloc(GPTR,MAX_PATH);
        if (GetModuleFileName(hInstance, g_pszAppDir, MAX_PATH))
        {
            p = &g_pszAppDir[lstrlen(g_pszAppDir)-1];
            while (*p != '\\' && p >= g_pszAppDir)
                p--;
            if (*p == '\\') *(p++) = '\0';
        }
        else
        {
            return FALSE;
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        GlobalFree(g_pszAppDir);
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

#define MAX_STRINGS     5
int     iSzTable=0;
TCHAR   szStrTable[MAX_STRINGS][512];


/////////////////////////////////////////////////////////////////////////////
// Utility Globals

//+----------------------------------------------------------------------------
// NAME: GetSz
//
//    Load strings from resources
//
//  Created 1/28/96,        Chris Kauffman
//+----------------------------------------------------------------------------
LPTSTR GetSz(WORD wszID)
{
    LPTSTR psz = szStrTable[iSzTable];

    iSzTable++;
    if (iSzTable >= MAX_STRINGS)
        iSzTable = 0;

    if (!LoadString(_Module.GetModuleInstance(), wszID, psz, 512))
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP:LoadString failed %d\n"), (DWORD) wszID);
        *psz = 0;
    }

    return (psz);
}

#ifdef UNICODE
int     iSzTableA=0;
CHAR    szStrTableA[MAX_STRINGS][512];

//+----------------------------------------------------------------------------
// NAME: GetSzA
//
//    Load ascii strings from resources
//
//  Created 3/10/99,        Wootaek Seo
//+----------------------------------------------------------------------------
LPSTR GetSzA(WORD wszID)
{
    LPSTR psz = szStrTableA[iSzTable];

    iSzTableA++;
    if (iSzTableA >= MAX_STRINGS)
        iSzTableA = 0;

    if (!LoadStringA(_Module.GetModuleInstance(), wszID, psz, 512))
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP:LoadStringA failed %d\n"), (DWORD) wszID);
        *psz = 0;
    }

    return (psz);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\import.cpp ===
// Import.cpp: implementation of the CISPImport class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "appdefs.h"
#include "icwhelp.h"

#ifdef _DEBUG
#undef THIS_FILE
static TCHAR THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#pragma data_seg(".rdata")

TCHAR cszEntrySection[] = TEXT("Entry");
TCHAR cszEntryName[]    = TEXT("Entry_Name");
TCHAR cszAlias[]        = TEXT("Import_Name");
TCHAR cszML[]           = TEXT("Multilink");

TCHAR cszPhoneSection[] = TEXT("Phone");
TCHAR cszDialAsIs[]     = TEXT("Dial_As_Is");
TCHAR cszPhone[]        = TEXT("Phone_Number");
TCHAR cszISDN[]         = TEXT("ISDN_Number");
TCHAR cszAreaCode[]     = TEXT("Area_Code");
TCHAR cszCountryCode[]  = TEXT("Country_Code");
TCHAR cszCountryID[]    = TEXT("Country_ID");

TCHAR cszDeviceSection[] = TEXT("Device");
TCHAR cszDeviceType[]    = TEXT("Type");
TCHAR cszDeviceName[]    = TEXT("Name");
TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
TCHAR cszDevCfg[]        = TEXT("Settings");

TCHAR cszServerSection[] = TEXT("Server");
TCHAR cszServerType[]    = TEXT("Type");
TCHAR cszSWCompress[]    = TEXT("SW_Compress");
TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
TCHAR cszNetLogon[]      = TEXT("Network_Logon");
TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");
TCHAR cszDisableLcp[]    = TEXT("Disable_LCP");

TCHAR cszIPSection[]     = TEXT("TCP/IP");
TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
TCHAR cszIPAddress[]     = TEXT("IP_address");
TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
TCHAR cszDNSAddress[]    = TEXT("DNS_address");
TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
TCHAR cszWINSAddress[]   = TEXT("WINS_address");
TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

TCHAR cszMLSection[]     = TEXT("Multilink");
TCHAR cszLinkIndex[]     = TEXT("Line_%s");

TCHAR cszScriptingSection[] = TEXT("Scripting");
TCHAR cszScriptName[]    = TEXT("Name");

TCHAR cszScriptSection[] = TEXT("Script_File");

TCHAR cszYes[]           = TEXT("yes");
TCHAR cszNo[]            = TEXT("no");

TCHAR cszUserSection[]   = TEXT("User");
TCHAR cszUserName[]      = TEXT("Name");
TCHAR cszPassword[]      = TEXT("Password");

TCHAR szNull[] = TEXT("");

TCHAR cszSupport[]       = TEXT("Support");
TCHAR cszSupportNumber[] = TEXT("SupportPhoneNumber");

SERVER_TYPES aServerTypes[] =
{ 
    {TEXT("PPP"),     RASFP_Ppp,  0},
    {TEXT("SLIP"),    RASFP_Slip, 0},
    {TEXT("CSLIP"),   RASFP_Slip, RASEO_IpHeaderCompression},
    {TEXT("RAS"),     RASFP_Ras,  0}
};


#pragma data_seg()


TCHAR g_szDeviceName[RAS_MaxDeviceName + 1] = TEXT("\0"); //holds the user's modem choice when multiple
TCHAR g_szDeviceType[RAS_MaxDeviceType + 1] = TEXT("\0"); // modems are installed
#define ISIGNUP_KEY   TEXT("Software\\Microsoft\\ISIGNUP")
#define DEVICENAMEKEY TEXT("DeviceName")
#define DEVICETYPEKEY TEXT("DeviceType")

static const TCHAR cszInetcfg[] = TEXT("Inetcfg.dll");
static const CHAR  cszSetAutoProxyConnectoid[] = "SetAutoProxyConnectoid"; // Proc name. Must be ansi.
typedef HRESULT (WINAPI * SETAUTOPROXYCONNECTOID) (IN BOOL bEnable);

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CISPImport::CISPImport()
{

    m_szDeviceName[0] = TEXT('\0'); 
    m_szDeviceType[0] = TEXT('\0');
    m_szConnectoidName[0] = TEXT('\0');
    m_bIsISDNDevice = FALSE;
}

CISPImport::~CISPImport()
{
    // Clean up the registry
    DeleteUserDeviceSelection(DEVICENAMEKEY);
    DeleteUserDeviceSelection(DEVICETYPEKEY);
}

//+----------------------------------------------------------------------------
// DWORD NEAR PASCAL StrToip (LPTSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// 
LPCTSTR NEAR PASCAL StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal)
{
  LPCTSTR pszIP = szIPAddress;

  *pVal = (BYTE)Sz2W(pszIP);
  // skip over digits
  while (FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  // skip over one or more separators
  while (*pszIP && !FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCTSTR szIPAddress, RASIPADDR FAR *ipAddr)
{
  LPCTSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName, BOOL bISDN)
{
  TCHAR   szYesNo[MAXNAME];

  if (!GetPrivateProfileString(cszPhoneSection,
                          (bISDN ? cszISDN : cszPhone),
                          szNull,
                          lpRasEntry->szLocalPhoneNumber,
                          sizeof(lpRasEntry->szLocalPhoneNumber),
                          szFileName))
  {
      // If the ISDN_Number is empty, we read from the Phone_Number
      GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              DUN_NOPHONENUMBER,
                              lpRasEntry->szLocalPhoneNumber,
                              sizeof(lpRasEntry->szLocalPhoneNumber),
                              szFileName);
  }

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszYes,
                          szYesNo,
                          sizeof(szYesNo),
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      if (GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              szNull,
                              lpRasEntry->szAreaCode,
                              sizeof(lpRasEntry->szAreaCode),
                              szFileName) != 0)
      {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
      }
    }
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPTSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szYesNo[MAXNAME];
  TCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          szNull,
                          szType,
                          sizeof(szType),
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < NUM_SERVER_TYPES; ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
        lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
    }
    else
    {
        lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
    }
  };
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPTSTR szEntryName, LPTSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
  TCHAR   szIPAddr[MAXIPADDRLEN];
  TCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  szNull,
                                  szIPAddr,
                                  sizeof(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  szNull,
                                  szIPAddr,
                                  sizeof(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  sizeof(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  szNull,
                                  szIPAddr,
                                  sizeof(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  sizeof(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              szNull,
                              szYesNo,
                              sizeof(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateUniqueFile(LPTSTR szPath, LPTSTR szFile)
//
// This function creates a unique file. If the file already exists, it will
// try to create a file with similar name and return the name.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateUniqueFile(LPTSTR szPath, LPTSTR szScript)
{
  HANDLE hFile; 

  LPTSTR  pszSuffix, lpsz;
  UINT   uSuffix;

  pszSuffix = szPath + lstrlen(szPath); 
  
  lpsz = CharPrev(szPath, pszSuffix);
  
  if (*lpsz != '\\')
  {
    *pszSuffix = '\\';
    pszSuffix++;
  };
  lstrcpy(pszSuffix, szScript);

  // Try the specified filename
  //
  hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL, NULL);
                     

  // If the file exists
  //
    if ((hFile == INVALID_HANDLE_VALUE) && (GetLastError() == ERROR_FILE_EXISTS))
  {
    TCHAR szNewName[MAX_PATH];

    // Need to copy it to another name in the same directory
    //
    if (LoadString(_Module.GetModuleInstance(), IDS_DEFAULT_SCP, szNewName, sizeof(szNewName)))
    {
      // Increment the file index until a non-duplicated file can be created
      //
      uSuffix = 0;
      do
      {
        wsprintf(pszSuffix, szNewName, uSuffix);
        uSuffix++;
        hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                               FILE_ATTRIBUTE_NORMAL, NULL);

      } 
      while ((hFile == INVALID_HANDLE_VALUE) &&
             (GetLastError() == ERROR_FILE_EXISTS) &&
             (uSuffix < 0x0000FFFF)); 
    };
  };

  // If we do not have the file, reserve the pathname
  //
  if (hFile == INVALID_HANDLE_VALUE)
  {
    *pszSuffix = '\0';
  };
  return hFile;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPTSTR szImportFile)
//
// This function creates the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateScriptFile(LPTSTR szScript, LPCTSTR szImportFile)
{
  LPTSTR pszDir;
  DWORD cb;
  HANDLE hFile;

  // Assume failure
  //
  hFile = INVALID_HANDLE_VALUE;

  // Allocate a buffer for pathname
  //
  TCHAR pszPath[MAX_PATH * 2];
  TCHAR pszShortName[MAX_PATH * 2]; //pszShortName = pszPath+MAX_PATH;

  // Get the default directory
  //
  if (GetWindowsDirectory(pszPath, MAX_PATH) != 0)
  {
    // Get the Windows drive
    //
    pszDir = pszPath;
    while((*pszDir != '\\') && (*pszDir != '\0'))
    {
      pszDir = CharNext(pszDir);
    };

    // Did we find Windows drive?
    //
    if (*pszDir != '\0')
    {
      // Prepare the drive
      //
      cb = (DWORD)(pszDir - pszPath);
      MyMemCpy((LPBYTE) szScript, (const LPBYTE) pszPath, (size_t) cb);
      pszDir = szScript + cb;

      // Get the script filename
      //
      if (GetPrivateProfileString(cszScriptingSection,
                                  cszScriptName,
                                  szNull,
                                  pszShortName,
                                  MAX_PATH,
                                  szImportFile) != 0)
      {
        // Try the favorite script directory
        //
        if (LoadString(_Module.GetModuleInstance(), IDS_INI_SCRIPT_DIR, pszDir,
                       (MAX_PATH - cb)) != 0)
        {
          // Try creating the file
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };

        // If we do not have the file yet, try the second favorite
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          if (LoadString(_Module.GetModuleInstance(), IDS_INI_SCRIPT_SHORTDIR, pszDir,
                       (MAX_PATH - cb)))
          {
            // Try creating the file
            //
            hFile = CreateUniqueFile(szScript, pszShortName);
          };
        };

        // If we do not have the file yet, try Windows directory
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          // Get original Windows directory
          //
          lstrcpy(szScript, pszPath);

          // Try one more time
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };
      };
    };
  };

  return hFile;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportScriptFile(LPTSTR szEntryName, LPTSTR szImportFile)
//
// This function imports the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportScriptFile(LPRASENTRY lpRasEntry, LPCTSTR szImportFile)
{
  HANDLE hfScript;
  LPTSTR  pszLine;
  LPTSTR  pszFile;
  int    i, iMaxLine;
  UINT   cbSize, cbRet;
  TCHAR   szTmp[4];
  DWORD  dwRet;

  dwRet=ERROR_SUCCESS;

  // If a script section does not exist, do nothing
  //
  if (GetPrivateProfileString(cszScriptingSection,
                              cszScriptName,
                              szNull,
                              szTmp,
                              4,
                              szImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  // Allocate a buffer for the script lines
  //
  pszLine = new TCHAR[SIZE_ReadBuf+MAX_PATH];
  if (pszLine == NULL)
  {
    TraceMsg(TF_GENERAL,TEXT("CONNECT:ImportScriptFile(): Local Alloc failed\n"));
    return ERROR_OUTOFMEMORY;
  }

  // Look for script
  //
  if (GetPrivateProfileString(cszScriptSection,
                              NULL,
                              szNull,
                              pszLine,
                              SIZE_ReadBuf,
                              szImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszFile = pszLine;
    iMaxLine = -1;
    while (*pszFile)
    {
      i = Sz2W(pszFile);
      iMaxLine = max(iMaxLine, i);
      pszFile += lstrlen(pszFile)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      pszFile = pszLine+SIZE_ReadBuf;

      // Create the script file
      //
      //DebugBreak();
      hfScript = CreateScriptFile(pszFile, szImportFile);
        TraceMsg(TF_GENERAL, TEXT("CONNECT:ImportScriptFile(): CreateScriptFile hfScript %d, %s, %s\n"),hfScript,pszFile,szImportFile);

      if (hfScript != INVALID_HANDLE_VALUE)
      {
        TCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, TEXT("%d"), i);
          if ((cbSize = GetPrivateProfileString(cszScriptSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                szImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, TEXT("\x0d\x0a"));
#ifdef UNICODE
            CHAR szTmp[SIZE_ReadBuf];
            size_t nSize = wcstombs(szTmp, pszLine, SIZE_ReadBuf);
            if (nSize > 0)
                WriteFile(hfScript, szTmp, nSize, (LPDWORD)&cbRet, NULL);
#else
            WriteFile(hfScript, pszLine, cbSize+2, (LPDWORD)&cbRet, NULL);
#endif 
          };
        };

        CloseHandle(hfScript);

        // Associate it with the phonebook entry
        //
        lstrcpyn(lpRasEntry->szScript, pszFile, RAS_MaxEntryName);

      }
      else
      {
        dwRet = GetLastError();
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  delete [] pszLine;

  return dwRet;
}

//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CISPImport::RnaValidateImportEntry (LPCTSTR szFileName)
{
  TCHAR  szTmp[4];

  // Get the alias entry name
  //
  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  szNull,
                                  szTmp,
                                  4,
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_CORRUPT_PHONEBOOK);
}

//****************************************************************************
// HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//  Sat 16-Mar-1996 10:01:00  -by-  Chris Kauffman [chrisk]
// Modified to return HRESULT and load DLL dynamically
//****************************************************************************

HRESULT CISPImport::ImportConnection (LPCTSTR szFileName, LPTSTR pszSupportNumber, LPTSTR pszEntryName, LPTSTR pszUserName, LPTSTR pszPassword, LPBOOL pfNeedsRestart)
{
    LPRASENTRY      lpRasEntry;
    DWORD           dwRet;
    DWORD           dwOptions;
    HINSTANCE       hinetcfg;
    FARPROC         fp, fpSetAutoProxy;
    
    // Get the size of device configuration
    // This also validates an exported file
    //
    if ((dwRet = RnaValidateImportEntry(szFileName)) != ERROR_SUCCESS)
    {
        return dwRet;
    };

    // Allocate a buffer for entry and device config
    //
    if ((lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY))) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    };
    
    // Get the entry name
    // Need to find a good name for it and remember it as an alias
    //
    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          szNull,
                          pszEntryName,
                          RAS_MaxEntryName+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          szNull,
                          pszUserName,
                          UNLEN+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          szNull,
                          pszPassword,
                          PWLEN+1,
                          szFileName);

    // Get ISP support number
    //
    GetPrivateProfileString(cszSupport,
                          cszSupportNumber,
                          szNull,
                          pszSupportNumber,
                          RAS_MaxAreaCode + RAS_MaxPhoneNumber +1,
                          szFileName);

    // Get device name, type and config
    //
    GetPrivateProfileString(cszDeviceSection,
                          cszDeviceType,
                          szNull,
                          lpRasEntry->szDeviceType,
                          sizeof(lpRasEntry->szDeviceType),
                          szFileName);

    // Get Server Type settings
    //
    ImportServerInfo(lpRasEntry, szFileName);

    // Get IP address
    //
    ImportIPInfo(lpRasEntry, szFileName);

    // Import the script file
    //
    if ((dwRet = ImportScriptFile(lpRasEntry, szFileName)) != ERROR_SUCCESS)
    {
        TraceMsg(TF_GENERAL,TEXT("CONNECT:ImportScriptFile Failed with the error %d,%s,%s"),dwRet,szFileName,lpRasEntry->szScript);
    }

    lpRasEntry->dwSize = sizeof(RASENTRY);

    // Load and Locate AutoRunSignUpWizard entry point
    //

    hinetcfg = LoadLibrary(TEXT("INETCFG.DLL"));
    AssertMsg(hinetcfg != NULL, TEXT("Cannot find INETCFG.DLL"));
    if (!hinetcfg) 
    {
        dwRet = GetLastError();
        goto ImportConnectionExit;
    }

    fpSetAutoProxy = GetProcAddress(hinetcfg,cszSetAutoProxyConnectoid);
    if (fpSetAutoProxy)
    {
        ((SETAUTOPROXYCONNECTOID)fpSetAutoProxy) (FALSE);
    }

    fp = GetProcAddress(hinetcfg,AUTORUNSIGNUPWIZARDAPI);
    AssertMsg(fp != NULL, TEXT("Cannot find AutoRunSignupWizard entry point"));
    if (!fp)
    {
        dwRet = GetLastError();
        goto ImportConnectionExit;
    }

    // 10/19/96    jmazner    Normandy #8462 -- multiple modems
    dwRet = ConfigRasEntryDevice(lpRasEntry);
    switch( dwRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_CANCELLED:
            if( IDYES != MessageBox(GetActiveWindow(),GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                            MB_APPLMODAL | MB_ICONQUESTION |
                            MB_YESNO | MB_DEFBUTTON2) )
            {
                dwRet = ERROR_RETRY;
            }
            goto ImportConnectionExit;

        default:
            goto ImportConnectionExit;
    }

    // See if this is a ISDN type device, and if so, then set the CFGFLAG_ISDN_OFFER
    if (lstrcmpi(g_szDeviceType, RASDT_Isdn) == 0)
        m_bIsISDNDevice = TRUE;
    
    ImportPhoneInfo(lpRasEntry, szFileName, m_bIsISDNDevice);

    //
    // ChrisK Olympus 4756 5/25/97
    // Do not display busy animation on Win95
    //
    dwOptions = INETCFG_INSTALLRNA |
                      INETCFG_INSTALLTCP |
                      INETCFG_OVERWRITEENTRY;

    dwRet =  ((PFNAUTORUNSIGNUPWIZARD)fp)(
                NULL,
                NULL,
                pszEntryName,
                lpRasEntry,
                pszUserName,
                pszPassword,
                NULL,
                NULL,
                dwOptions,
                pfNeedsRestart);

    if (fpSetAutoProxy)
    {
        ((SETAUTOPROXYCONNECTOID)fpSetAutoProxy) (TRUE);
    }
    LclSetEntryScriptPatch(lpRasEntry->szScript,pszEntryName);

    // now that we've made the connectoid in InetConfigClient (PFNAUTORUNSIGNUPWIZARD),
    // store its name in psheet's global so that we can delete it if user cancels
    lstrcpyn( m_szConnectoidName, pszEntryName, lstrlen(pszEntryName) + 1);

    TraceMsg(TF_GENERAL,TEXT("CONNECT:EntryName %s, User %s, Password (not shown), Number %s\n"),pszEntryName,pszUserName,lpRasEntry->szLocalPhoneNumber);
    //AssertMsg(!fNeedsRestart,TEXT("We have to reboot AGAIN!!"));

    // Exit and cleanup
    //

ImportConnectionExit:
    if (hinetcfg) FreeLibrary(hinetcfg);
    GlobalFree(lpRasEntry);
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had already picked
//
//    Arguements    szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,szKey,0,&dwType,
            (LPBYTE)szBuf,&dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    SetDeviceSelectedByUser
//
//    Synopsis    Write user's device selection to registry
//
//    Arguments    szKey - name of key
//                szBuf - data to write to key
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::SetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf)
{
    BOOL bRC = FALSE;
    HKEY hkey = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey,szKey,0,REG_SZ,
            (LPBYTE)szBuf,sizeof(TCHAR)*(lstrlen(szBuf)+1)))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Funciton    DeleteUserDeviceSelection
//
//    Synopsis    Remove registry keys with device selection
//
//    Arguments    szKey - name of value to remove
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::DeleteUserDeviceSelection(LPTSTR szKey)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,ISIGNUP_KEY,&hkey))
    {
        bRC = (ERROR_SUCCESS == RegDeleteValue(hkey,szKey));
        RegCloseKey(hkey);
    }
    return bRC;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConfigRasEntryDevice()
//
//  Synopsis:   Checks whether user has already specified a modem to use;
//                If so, verifies that modem is valid.
//                If not, or if modem is invalid, presents user a dialog
//                to choose which modem to use (if only one modem is installed,
//                it automaticaly selects that device and bypasses the dialog)
//
//  Arguments:  lpRasEntry - Pointer to the RasEntry whose szDeviceName and
//                             szDeviceType members you wish to verify/configure
//
//    Returns:    ERROR_CANCELLED - Had to bring up "Choose Modem" dialog, and
//                                  and user hit its "Cancel" button
//                Otherwise returns any error code encountered.
//                ERROR_SUCCESS indicates success.
//
//  History:    5/18/96     VetriV    Created
//              3/7/98      DonSc     Added the process-wide tracking of the previously
//                                    selected device.
//
//----------------------------------------------------------------------------
DWORD CISPImport::ConfigRasEntryDevice( LPRASENTRY lpRasEntry )
{
    DWORD        dwRet = ERROR_SUCCESS;
    CEnumModem  EnumModem;

    GetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName, sizeof(g_szDeviceName));
    GetDeviceSelectedByUser(DEVICETYPEKEY, g_szDeviceType, sizeof(g_szDeviceType));

    ASSERT(lpRasEntry);

    dwRet = EnumModem.GetError();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    // If there are no modems, we're horked
    if (0 == EnumModem.GetNumDevices())
    {
        TraceMsg(TF_GENERAL,TEXT("ICWHELP: import.cpp: ConfigRasEntryDevice: ERROR: No modems installed!\n"));
        return ERROR_CANCELLED;
    }


    // Validate the device if possible
    if ( lpRasEntry->szDeviceName[0] && lpRasEntry->szDeviceType[0] )
    {
        // Verify that there is a device with the given name and type
        if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
                                                lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so reset the strings and bring up the choose modem UI.
            lpRasEntry->szDeviceName[0] = '\0';
            lpRasEntry->szDeviceType[0] = '\0';
        }
    }
    else if ( lpRasEntry->szDeviceName[0] )
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceType =
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if ( lpRasEntry->szDeviceType[0] )
    {
        // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPTSTR szDeviceName = 
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }
    // If either name or type is missing, check whether the user has already made a choice.
    // if not, bring up choose modem UI if there
    // are multiple devices, else just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.
    if( !(lpRasEntry->szDeviceName[0]) ||
        !(lpRasEntry->szDeviceType[0]) )
    {
        TraceMsg(TF_GENERAL,TEXT("ICWHELP: ConfigRasEntryDevice: no valid device passed in\n"));
        if( g_szDeviceName[0] )
        {
            // it looks like we have already stored the user's choice.
            // store the DeviceName in lpRasEntry, then call GetDeviceTypeFromName
            // to confirm that the deviceName we saved actually exists on the system
            lstrcpy(lpRasEntry->szDeviceName, g_szDeviceName);
            
            if( 0 == lstrcmp(EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName),
                              g_szDeviceType) )
            {
                lstrcpy(lpRasEntry->szDeviceType, g_szDeviceType);
                return ERROR_SUCCESS;
            }
        }
        if (1 == EnumModem.GetNumDevices())
        {
            // There is just one device installed, so copy the name
            TraceMsg(TF_GENERAL,TEXT("ICWHELP: import.cpp: ConfigRasEntryDevice: only one modem installed, using it\n"));
            lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
        }
        else
        {
            TraceMsg(TF_GENERAL,TEXT("ICWHELP: import.cpp: ConfigRasEntryDevice: multiple modems detected\n"));
            if (IsNT4SP3Lower())
                lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next() );
            else
            {
                CHOOSEMODEMDLGINFO ChooseModemDlgInfo;
 

                BOOL fRet=(BOOL)DialogBoxParam(GetModuleHandle(TEXT("ICWHELP.DLL")), MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME), GetActiveWindow(),
                    ChooseModemDlgProc,(LPARAM) &ChooseModemDlgInfo);
                if (TRUE != fRet)
                {
                    // user cancelled or an error occurred.
                    dwRet = ChooseModemDlgInfo.hr;
                    /*
                    dwRet = GetLastError(); //This will NEVER be ERROR_SUCCESS
                
                    //BUBGUG -- If the user hits OK -> then ChooseModemDlgInfo.hr == ERROR_SUCCESS,
                    BUT if OK was hit then the function returns true and this can never be hit!
                    if (ERROR_SUCCESS == dwRet)
                    {
                        // Error occurred, but the error code was not set.
                        dwRet = ERROR_INETCFG_UNKNOWN;
                    }*/
                    return dwRet;
                }
    
                // Copy the modem name string
                lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
            }
        }

        // Now get the type string for this modem
        lstrcpy (lpRasEntry->szDeviceType,EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    }

    lstrcpy(g_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy(g_szDeviceType, lpRasEntry->szDeviceType);

    // Save device name and type
    lstrcpy( m_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy( m_szDeviceType, lpRasEntry->szDeviceType);

    // Save data in registry
    SetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName);
    SetDeviceSelectedByUser (DEVICETYPEKEY, g_szDeviceType);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\icwerr.cpp ===
#include "stdafx.h"

#define RAS_BOGUS_AUTHFAILCODE_1	84
#define RAS_BOGUS_AUTHFAILCODE_2	74389484

DWORD RasErrorToIDS(DWORD dwErr)
{
	//DWORD ev;

	if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
	{
		// DebugTrace(("RAS returned bogus AUTH error code %08x. Munging...\r\n", dwErr));
		return IDS_PPPRANDOMFAILURE;
	}

	if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
	{
		OutputDebugString(TEXT("Got random RAS MEDIA error!\r\n"));
		return IDS_MEDIAINIERROR;
	}

	switch(dwErr)
	{
	default:
		return IDS_PPPRANDOMFAILURE;

	case SUCCESS:
		return 0;

	case ERROR_DOWNLOAD_NOT_FOUND:
		return IDS_DOWNLOAD_NOT_FOUND;

	case ERROR_DOWNLOADIDNT:
		return IDS_CANTDOWNLOAD;
		
	case ERROR_LINE_BUSY:
		return IDS_PHONEBUSY;

	case ERROR_NO_ANSWER:
		return IDS_NOANSWER;
		
	case ERROR_VOICE_ANSWER:
	case ERROR_NO_CARRIER:
		return IDS_RASNOCARRIER;
		
	case ERROR_NO_DIALTONE:
		return IDS_NODIALTONE;

	case ERROR_HARDWARE_FAILURE:	// modem turned off
	case ERROR_PORT_ALREADY_OPEN:	// procomm/hypertrm/RAS has COM port
	case ERROR_PORT_OR_DEVICE:		// got this when hypertrm had the device open -- jmazner
		return IDS_NODEVICE;

	case ERROR_USER_DISCONNECTION:
		return IDS_USERCANCELEDDIAL;

	case ERROR_BUFFER_INVALID:				// bad/empty rasdilap struct
	case ERROR_BUFFER_TOO_SMALL:			// ditto?
	case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY:	// if connectoid name in registry is wrong
		return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:		// get this on actual CHAP reject
		return IDS_PPPRANDOMFAILURE;

	case ERROR_PPP_TIMEOUT:		// get this on CHAP timeout
		return IDS_TIMEOUT;

	case ERROR_REMOTE_DISCONNECTION:		// Ascend drops connection on auth-fail
		return IDS_PPPRANDOMFAILURE;

	case ERROR_AUTH_INTERNAL:				// got this on random POP failure
	case ERROR_PROTOCOL_NOT_CONFIGURED:		// get this if LCP fails
	case ERROR_PPP_NO_PROTOCOLS_CONFIGURED:	// get this if IPCP addr download gives garbage
		return IDS_PPPRANDOMFAILURE;

	case ERROR_USERCANCEL:
		return IDS_USERCANCELEDDIAL;


	}
	return (DWORD)(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\import.h ===
// Import.h: interface for the CISPImport class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMPORT_H__BF2F451A_8899_11D1_ADD9_0000F87734F0__INCLUDED_)
#define AFX_IMPORT_H__BF2F451A_8899_11D1_ADD9_0000F87734F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define IDS_DEFAULT_SCP         0
#define IDS_INI_SCRIPT_DIR      1
#define IDS_INI_SCRIPT_SHORTDIR 2

#define MAXLONGLEN      80
#define MAXNAME         80

#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#ifdef UNICODE
#define AUTORUNSIGNUPWIZARDAPI "InetConfigClientW" // Proc name. Must be ansi.
#else
#define AUTORUNSIGNUPWIZARDAPI "InetConfigClient" // Proc name. Must be ansi.
#endif

typedef HRESULT (WINAPI *PFNAUTORUNSIGNUPWIZARD) (HWND hwndParent,
													LPCTSTR lpszPhoneBook,
													 LPCTSTR lpszConnectoidName,
													 LPRASENTRY lpRasEntry,
													 LPCTSTR lpszUsername,
													 LPCTSTR lpszPassword,
													 LPCTSTR lpszProfileName,
													 LPINETCLIENTINFO lpINetClientInfo,
													 DWORD dwfOptions,
													 LPBOOL lpfNeedsRestart);


#define DUN_NOPHONENUMBER TEXT("000000000000")
#define DUN_NOPHONENUMBER_A "000000000000"

class CISPImport  
{
public:
	CISPImport();
	virtual ~CISPImport();
    void    set_hWndMain(HWND   hWnd)
    {
        m_hWndMain = hWnd;
    };

    DWORD RnaValidateImportEntry (LPCTSTR szFileName);
    HRESULT ImportConnection (LPCTSTR szFileName, LPTSTR pszEntryName, LPTSTR pszSupportNumber, LPTSTR pszUserName, LPTSTR pszPassword, LPBOOL pfNeedsRestart);
    BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize);
    BOOL SetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf);
    BOOL DeleteUserDeviceSelection(LPTSTR szKey);
    DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );

    TCHAR m_szDeviceName[RAS_MaxDeviceName + 1]; //holds the user's modem choice when multiple
    TCHAR m_szDeviceType[RAS_MaxDeviceType + 1]; // modems are installed
    TCHAR m_szConnectoidName[RAS_MaxEntryName+1];

    HWND m_hWndMain;
    
    BOOL m_bIsISDNDevice;
};

#endif // !defined(AFX_IMPORT_H__BF2F451A_8899_11D1_ADD9_0000F87734F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\icwglob.h ===
//--------------------------------------------------------------------------------
//    icwglob.h
//    The information contained in this file is the sole property of Microsoft Corporation.
//  Copywrite Microsoft 1998
//
//  Created 1/7/98,        DONALDM
//--------------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// INCLUDES

#include <wininet.h>
#include "enumodem.h"

#include "..\inc\debug.h"
#include "..\inc\inetcfg.h"
#include "..\inc\ras2.h"
#include "..\icwphbk\phbk.h"
// #include "..\icwdl\mydefs.h"
#include <rnaapi.h>

//-----------------------------------------------------------------------------
// DEFINES
#define ERROR_USERCANCEL 32767 // quit message value
#define ERROR_USERBACK 32766 // back message value
#define ERROR_USERNEXT 32765 // back message value
#define ERROR_DOWNLOADIDNT 32764 // Download failure

#define ERROR_READING_DUN        32768
#define ERROR_READING_ISP        32769
#define ERROR_PHBK_NOT_FOUND    32770
#define ERROR_DOWNLOAD_NOT_FOUND 32771

#define cMarvelBpsMin 2400 // minimum modem speed
#define INVALID_PORTID UINT_MAX
#define pcszDataModem TEXT("comm/datamodem")
//#define MsgBox(m,s) MessageBox(g_hwndBack,GetSz(m),GetSz(IDS_TITLE),s)
#if defined(WIN16)
#define MsgBox(m,s) MessageBox(g_hwndMessage,GetSz(m),GetSz(IDS_TITLE),s)
#endif
#define szLoginKey           TEXT("Software\\Microsoft\\MOS\\Connection")
#define szCurrentComDev      TEXT("CurrentCommDev")
#define szTollFree           TEXT("OlRegPhone")
#define CCD_BUFFER_SIZE 255
#define szSignupConnectoidName TEXT("MSN Signup Connection")
#define szSignupDeviceKey    TEXT("SignupCommDevice")
#define KEYVALUE_SIGNUPID    TEXT("iSignUp")
#define RASENTRYVALUENAME    TEXT("RasEntryName")
#define GATHERINFOVALUENAME  TEXT("UserInfo")
#define INFFILE_USER_SECTION TEXT("User")
#define INFFILE_PASSWORD     TEXT("Password")
#define NULLSZ               TEXT("")

#define cchMoreSpace 22000    // bytes needed to hold results of lineGetCountry(0,...). 
                            // Currently this function returns about 16K, docs say 20K,
                            // this should be enough.
#define DwFromSz(sz)         Sz2Dw(sz)            //make it inline, so this is faster.
#define DwFromSzFast(sz)     Sz2DwFast(sz)        
#define CONNECT_SIGNUPFIRST    1 // phonenumber constant for determining the firstcall phonenumber TO DO

#define CONNECTFLAGS_MASK_TOLLFREE     0x01
#define CONNECTFLAGS_MASK_TCP          0x02
#define CONNECTFLAGS_MASK_ISDN         0x04
#define CONNECTFLAGS_MASK_DIRECT    0x08
#define CONNECTFLAGS_MASK_OTHERDIALUP  0x10
#define CONNECTFLAGS_MASK_PROXY        0x20

#define CONNECTFLAGS_MASK_FIRST     CONNECTFLAGS_MASK_TCP
#define CONNECTFLAGS_MASK_LAST      CONNECTFLAGS_MASK_ISDN

#define CONNECTMSNDIALUP(dw) ((dw & (CONNECTFLAGS_MASK_TOLLFREE|CONNECTFLAGS_M
#define LANORSHUTTLE(dw) ((dw)==10 || (dw)==34)
#define IS_SHUTTLE(dw)   ((dw)==34)
#define IS_ISP(dw)       ((dw)==18)

#define CONNECTPROTOCOL_MSNDIALUPX25      0
#define CONNECTPROTOCOL_MSNDIALUPTCP      2
#define CONNECTPROTOCOL_MSNDIALUPTCPISDN  6
#define CONNECTPROTOCOL_LANDIRECT         10
#define CONNECTPROTOCOL_ISPDIALUPTCP      18
#define CONNECTPROTOCOL_LANSHUTTLE        34

#define clineMaxATT            16            //for 950 MNEMONIC
#define NXXMin 200
#define NXXMax 999
#define cbgrbitNXX ((NXXMax + 1 - NXXMin) / 8)
#define crgnpab (NPAMax + 1 - NPAMin)

#define    MAX_PROMO 64
#define MAX_OEMNAME 64
#define MAX_AREACODE RAS_MaxAreaCode
#define MAX_RELPROD    8
#define MAX_RELVER    30

#define MAX_STRING      256  //used by ErrorMsg1 in mt.cpp


#define PHONEBOOK_LIBRARY TEXT("icwphbk.DLL")
#ifdef WIN16
#define PHBK_LOADAPI "PhoneBookLoad"
#define PHBK_SUGGESTAPI "PhoneBookSuggestNumbers"
#define PHBK_DISPLAYAPI "PhoneBookDisplaySignUpNumbers"
#define PHBK_UNLOADAPI "PhoneBookUnload"
#define PHBK_GETCANONICAL "PhoneBookGetCanonical"
#else
#define PHBK_LOADAPI      "PhoneBookLoad"
#define PHBK_SUGGESTAPI   "PhoneBookSuggestNumbers"
#define PHBK_DISPLAYAPI   "PhoneBookDisplaySignUpNumbers"
#define PHBK_UNLOADAPI    "PhoneBookUnload"
#define PHBK_GETCANONICAL "PhoneBookGetCanonical"
#endif

#define NUM_PHBK_SUGGESTIONS    50

#define TYPE_SIGNUP_ANY            0x82
#define MASK_SIGNUP_ANY            0xB2

#define DOWNLOAD_LIBRARY   TEXT("icwdl.dll")
#if defined(WIN16)
#define DOWNLOADINIT       "DownLoadInit"
#define DOWNLOADEXECUTE    "DownLoadExecute"
#define DOWNLOADCLOSE      "DownLoadClose"
#define DOWNLOADSETSTATUS  "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS    "DownLoadProcess"
#define DOWNLOADCANCEL     "DownLoadCancel"
#else
#define DOWNLOADINIT       "DownLoadInit"
#define DOWNLOADEXECUTE    "DownLoadExecute"
#define DOWNLOADCLOSE      "DownLoadClose"
#define DOWNLOADSETSTATUS  "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS    "DownLoadProcess"
#define DOWNLOADCANCEL     "DownLoadCancel"
#endif

#if defined(WIN16)
extern "C" void CALLBACK __export DialCallback(UINT uiMsg, 
                                                RASCONNSTATE rasState, 
                                                DWORD dwErr);    
#endif

//#define RASENUMAPI       "RasEnumConnectionsA"
//#define RASHANGUP        "RasHangUpA"

#define INF_SUFFIX              TEXT(".ISP")
#define INF_PHONE_BOOK          TEXT("PhoneBookFile")
#define INF_DUN_FILE            TEXT("DUNFile")
#define INF_REFERAL_URL         TEXT("URLReferral")
#define INF_SIGNUPEXE           TEXT("Sign_Up_EXE")
#define INF_SIGNUPPARAMS        TEXT("Sign_Up_Params")
#define INF_WELCOME_LABEL       TEXT("Welcome_Label")
#define INF_ISP_MSNSU           TEXT("MSICW")
#define INF_SIGNUP_URL          TEXT("Signup")
#define INF_AUTOCONFIG_URL      TEXT("AutoConfig")
#define INF_ISDN_URL            TEXT("ISDNSignup")
#define INF_ISDN_AUTOCONFIG_URL TEXT("ISDNAutoConfig")
#define INF_SECTION_URL         TEXT("URL")
#define INF_SECTION_ISPINFO     TEXT("ISP INFO")

#define DUN_NOPHONENUMBER       TEXT("000000000000")
#define DUN_NOPHONENUMBER_A     "000000000000"

#define MAX_VERSION_LEN 40

#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

// 8/9/96 jmazner
// Added new macro to fix MOS Normandy Bug #4170
#define MB_MYINFORMATION (MB_APPLMODAL | MB_ICONINFORMATION | MB_SETFOREGROUND)

// 8/27/96 jmazner
#define MB_MYEXCLAMATION (MB_APPLMODAL | MB_ICONEXCLAMATION | MB_SETFOREGROUND)

#define WM_STATECHANGE            WM_USER
#define WM_DIENOW                WM_USER + 1
#define WM_DUMMY                WM_USER + 2
#define WM_DOWNLOAD_DONE        WM_USER + 3
#define WM_DOWNLOAD_PROGRESS    WM_USER + 4

#define WM_MYINITDIALOG        (WM_USER + 4)

#define MAX_REDIALS 2

#define REG_USER_INFO     TEXT("Software\\Microsoft\\User information")
#define REG_USER_NAME1    TEXT("Default First Name")
#define REG_USER_NAME2    TEXT("Default Last Name")
#define REG_USER_COMPANY  TEXT("Default Company")
#define REG_USER_ADDRESS1 TEXT("Mailing Address")
#define REG_USER_ADDRESS2 TEXT("Additional Address")
#define REG_USER_CITY     TEXT("City")
#define REG_USER_STATE    TEXT("State")
#define REG_USER_ZIP      TEXT("ZIP Code")
#define REG_USER_PHONE    TEXT("Daytime Phone")
#define REG_USER_COUNTRY  TEXT("Country")

#define SIGNUPKEY         TEXT("SOFTWARE\\MICROSOFT\\GETCONN")
#define DEVICENAMEKEY     TEXT("DeviceName")    // used to store user's choice among multiple modems
#define DEVICETYPEKEY     TEXT("DeviceType")

#define ICWSETTINGSPATH   TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICWBUSYMESSAGES   TEXT("Software\\Microsoft\\Internet Connection Wizard\\Busy Messages")
#define RELEASEPRODUCTKEY TEXT("Release Product")
#define RELEASEVERSIONKEY TEXT("Release Product Version")

#define SETUPPATH_NONE    TEXT("current")
#define SETUPPATH_MANUAL  TEXT("manual")
#define SETUPPATH_AUTO    TEXT("automatic")
#define MAX_SETUPPATH_TOKEN 200

// 12/3/96 jmazner superceded by definitions in ..\common\inc\semaphor.h
//#define SEMAPHORE_NAME "Internet Connection Wizard ICWCONN1.EXE"

//
// 5/24/97 ChrisK Olympus 4650
//
#define RASDEVICETYPE_VPN       TEXT("VPN")
#define RASDEVICETYPE_MODEM     TEXT("MODEM")
#define RASDEVICETYPE_ISDN      TEXT("ISDN")
//--------------------------------------------------------------------------------
// Type declarations

// NOTE: due to code in connmain, the order of these IS IMPORTANT.  They should be
// in the same order that they appear.
enum CState 
{
    STATE_WELCOME = 0,
    STATE_INITIAL,
    STATE_BEGINAUTO,
    STATE_CONTEXT1,
    STATE_NETWORK,
    STATE_AUTORUNSIGNUPWIZARD,
    STATE_GATHERINFO,
    STATE_DOWNLOADISPLIST,
    STATE_SHELLPARTTWO,
    STATE_MAX
};
    
typedef HINTERNET (WINAPI* PFNINTERNETOPEN) (LPCTSTR lpszCallerName, DWORD dwAccessType, LPCTSTR lpszProxyName, INTERNET_PORT nProxyPort, DWORD dwFlags);
typedef HINTERNET (CALLBACK* PFNINTERNETOPENURL) (HINSTANCE hInternetSession,
                                                  LPCTSTR lpszUrl, LPCTSTR    lpszHeaders,
                                                  DWORD    dwHeadersLength, DWORD    dwFlags,
                                                  DWORD    dwContext);
typedef INTERNET_STATUS_CALLBACK (CALLBACK *PFNINTERNETSETSTATUSCALLBACK)(HINTERNET hInternet, INTERNET_STATUS_CALLBACK lpfnInternetCallback);
typedef BOOL (CALLBACK *PFNINTERNETCLOSEHANDLE)(HINTERNET hInet); 

typedef HRESULT (CALLBACK* PFNPHONEBOOKLOAD)(LPCTSTR pszISPCode, DWORD_PTR *pdwPhoneID);
typedef HRESULT (CALLBACK* PFPHONEBOOKSUGGEST)(DWORD_PTR dwPhoneID, PSUGGESTINFO pSuggestInfo);
typedef HRESULT (CALLBACK* PFNPHONEDISPLAY)(DWORD_PTR dwPhoneID, LPTSTR *ppszPhoneNumbers,
                                            LPTSTR *ppszDunFiles, WORD *pwPhoneNumbers,
                                            DWORD *pdwCountry,WORD *pwRegion,BYTE fType,
                                            BYTE bMask,HWND hwndParent,DWORD dwFlags);
typedef HRESULT (CALLBACK *PFNPHONEBOOKUNLOAD) (DWORD_PTR dwPhoneID);
typedef HRESULT (CALLBACK *PFNPHONEBOOKGETCANONICAL)(DWORD_PTR dwPhoneID, PACCESSENTRY pAE, TCHAR *psOut);


typedef HRESULT (CALLBACK *PFNCONFIGAPI)(HWND hwndParent,DWORD dwfOptions,LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI *PFNINETCONFIGSYSTEM)(HWND,LPCTSTR,LPCTSTR,LPRASENTRY,LPCTSTR,LPCTSTR,LPCTSTR,LPVOID,DWORD,LPBOOL);
typedef HRESULT (WINAPI *PFINETSTARTSERVICES)(void);
typedef DWORD (WINAPI *PFNLAUNCHSIGNUPWIZARDEX)(LPTSTR,int, PBOOL);
typedef VOID (WINAPI *PFNFREESIGNUPWIZARD) (VOID);
typedef DWORD (WINAPI *PFNISSMARTSTART)(VOID);

typedef DWORD (WINAPI *PFNINETCONFIGCLIENT)(HWND hwndParent, LPCTSTR lpszPhoneBook,LPCTSTR lpszEntryName, LPRASENTRY lpRasEntry,LPCTSTR lpszUserName, LPCTSTR lpszPassword,LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo,DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef DWORD (WINAPI *PFNINETGETAUTODIAL)(LPBOOL lpfEnable, LPCTSTR lpszEntryName, DWORD cbEntryNameSize);
typedef DWORD (WINAPI *PFNINETSETAUTODIAL)(BOOL fEnable, LPCTSTR lpszEntryName);
typedef DWORD (WINAPI *PFNINETGETCLIENTINFO)(LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
typedef DWORD (WINAPI *PFNINETSETCLIENTINFO)(LPCTSTR lpszProfile, LPINETCLIENTINFO lpClientInfo);
typedef DWORD (WINAPI *PFNINETGETPROXY)(LPBOOL lpfEnable, LPCTSTR lpszServer, DWORD cbServer,LPCTSTR lpszOverride, DWORD cbOverride);
typedef DWORD (WINAPI *PFNINETSETPROXY)(BOOL fEnable, LPCTSTR lpszServer, LPCTSTR lpszOverride);

typedef BOOL (WINAPI *PFNBRANDICW)(LPCSTR pszIns, LPCSTR pszPath, DWORD dwFlags, LPCSTR pszConnectoid);

typedef DWORD (WINAPI *PFNRASSETAUTODIALADDRESS)(LPTSTR lpszAddress,DWORD dwReserved,LPRASAUTODIALENTRY lpAutoDialEntries,DWORD dwcbAutoDialEntries,DWORD dwcAutoDialEntries);
typedef DWORD (WINAPI *PFNRASSETAUTODIALENABLE)(DWORD dwDialingLocation, BOOL fEnabled);

typedef HRESULT (CALLBACK *PFNDOWNLOADINIT)(LPTSTR pszURL, DWORD_PTR FAR *pdwCDialDlg, DWORD_PTR FAR *pdwDownLoad, HWND g_hWndMain);
typedef HRESULT (CALLBACK *PFNDOWNLOADGETSESSION)(DWORD_PTR dwDownLoad, HINTERNET *phInternet);
typedef HRESULT (CALLBACK *PFNDOWNLOADCANCEL)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADEXECUTE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADCLOSE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD_PTR dwDownLoad, INTERNET_STATUS_CALLBACK lpfn);
typedef HRESULT (CALLBACK *PFNDOWNLOADPROCESS)(DWORD_PTR dwDownLoad);

typedef HRESULT (CALLBACK *PFNAUTODIALINIT)(LPTSTR lpszISPFile, BYTE fFlags, BYTE bMask, DWORD dwCountry, WORD wState);

typedef struct tagGatherInfo
{
    LCID    m_lcidUser;
    LCID    m_lcidSys;
    LCID    m_lcidApps;
    DWORD   m_dwOS;
    DWORD   m_dwMajorVersion;
    DWORD   m_dwMinorVersion;
    WORD    m_wArchitecture;
    TCHAR   m_szPromo[MAX_PROMO];

    DWORD   m_dwCountry;
    TCHAR   m_szAreaCode[MAX_AREACODE+1];
    HWND    m_hwnd;
    LPLINECOUNTRYLIST m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;

    TCHAR   m_szSUVersion[MAX_VERSION_LEN];
    WORD    m_wState;
    BYTE    m_fType;
    BYTE    m_bMask;
    TCHAR   m_szISPFile[MAX_PATH+1];
    TCHAR   m_szAppDir[MAX_PATH+1];

    TCHAR   m_szRelProd[MAX_RELPROD + 1];
    TCHAR   m_szRelVer[MAX_RELVER + 1];
    DWORD    m_dwFlag;

} GATHERINFO, *LPGATHERINFO;


typedef struct tagRASDEVICE
{
    LPRASDEVINFO lpRasDevInfo;
    DWORD dwTapiDev;
} RASDEVICE, *PRASDEVICE;


//--------------------------------------------------------------------------------
// Prototypes
DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );
BOOL FInsureTCPIP();
LPTSTR GetSz(WORD wszID);
#ifdef UNICODE
LPSTR  GetSzA(WORD wszID);
#endif
void SetStatusArrow(CState wState);
BOOL FInsureModemTAPI(HWND hwnd);
BOOL FGetModemSpeed(PDWORD pdwSpeed);
BOOL FGetDeviceID(HLINEAPP *phLineApp, PDWORD pdwAPI, PDWORD pdwDevice);
BOOL FDoModemWizard(HWND hWnd);
void CALLBACK LineCallback(DWORD hDevice, DWORD dwMessage, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2, DWORD dwParam3);
BOOL FInsureNetwork(PBOOL pfNeedReboot);
BOOL TestInternetConnection();
inline DWORD Sz2Dw(LPCTSTR pSz);
inline DWORD Sz2DwFast(LPCTSTR pSz);
inline BOOL FSz2Dw(LPCTSTR pSz,LPDWORD dw);
int __cdecl CompareCountryNames(const void *pv1, const void *pv2);
DWORD GetCurrentTapiCountryID(void);
int __cdecl CompareNPAEntry(const void *pv1, const void *pv2);
//HRESULT GatherInformation(LPGATHERINFO pGatheredInfo, HWND hwndParent);
HRESULT DownLoadISPInfo(GATHERINFO *pGI);
HRESULT GetDataFromISPFile(LPTSTR pszISPCode, LPTSTR pszSection, LPTSTR pszDataName, LPTSTR pszOutput, 
                           DWORD dwOutputLength);
HRESULT GetINTFromISPFile
(
    LPTSTR   pszISPCode, 
    LPTSTR   pszSection,
    LPTSTR   pszDataName, 
    int far *lpData,
    int     iDefaultValue
);

HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey);
HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey);
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD dwInstance,
                           DWORD dwParam1,
                           DWORD dwParam2,
                           DWORD dwParam3);
VOID WINAPI MyProgressCallBack(
    HINTERNET hInternet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    );

HRESULT ReleaseBold(HWND hwnd);
HRESULT MakeBold (HWND hwnd, BOOL fSize, LONG lfWeight);
HRESULT ShowPickANumberDlg(PSUGGESTINFO pSuggestInfo);
//HRESULT ShowDialingDialog(LPTSTR, LPGATHERINFO, LPTSTR);
DWORD RasErrorToIDS(DWORD dwErr);
HRESULT CreateEntryFromDUNFile(LPTSTR pszDunFile);
//HRESULT RestoreHappyWelcomeScreen();
HRESULT KillHappyWelcomeScreen();
HRESULT GetCurrentWebSettings();
LPTSTR LoadInfoFromWindowUser();
HRESULT GetTapiCountryID2(LPDWORD pdwCountryID);
HRESULT RestoreAutodialer();
//HRESULT FilterStringDigits(LPTSTR);
BOOL IsDigitString(LPTSTR szBuff);
BOOL WaitForAppExit(HINSTANCE hInstance);
VOID PrepareForRunOnceApp(VOID);
void MinimizeRNAWindow(LPTSTR pszConnectoidName, HINSTANCE hInst);
// 3/18/97 ChrisK Olympus 304
DWORD MyGetTempPath(UINT uiLength, LPTSTR szPath);
// 3/28/97 ChrisK Olympus 296
void StopRNAReestablishZapper(HANDLE hthread);
HANDLE LaunchRNAReestablishZapper(HINSTANCE hInst);
BOOL FGetSystemShutdownPrivledge();
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry);
BOOL IsScriptingInstalled();
void InstallScripter(void);
void DeleteStartUpCommand ();
extern BOOL IsNT (VOID);
extern BOOL IsNT4SP3Lower (VOID);
//
// ChrisK Olympus 6368 6/24/97
//
VOID Win95JMoveDlgItem( HWND hwndParent, HWND hwndItem, int iUp );
#if defined(DEBUG)
void LoadTestingLocaleOverride(LPDWORD lpdwCountryID, LCID FAR *lplcid);
BOOL FCampusNetOverride();
BOOL FRefURLOverride();
void TweakRefURL( TCHAR* szUrl, 
                  LCID*  lcid, 
                  DWORD* dwOS,
                  DWORD* dwMajorVersion, 
                  DWORD* dwMinorVersion,
                  WORD*  wArchitecture, 
                  TCHAR* szPromo, 
                  TCHAR* szOEM, 
                  TCHAR* szArea, 
                  DWORD* dwCountry,
                  TCHAR* szSUVersion,//&m_lpGatherInfo->m_szSUVersion[0],  
                  TCHAR* szProd, 
                  DWORD* dwBuildNumber, //For this we really want to LOWORD
                  TCHAR* szRelProd, 
                  TCHAR* szRelProdVer, 
                  DWORD* dwCONNWIZVersion, 
                  TCHAR* szPID, 
                  long*  lAllOffers);
#endif //DEBUG
                
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
LPTSTR FileToPath(LPTSTR pszFile);
HRESULT ANSI2URLValue(TCHAR *s, TCHAR *buf, UINT uiLen);
BOOL BreakUpPhoneNumber(LPRASENTRY prasentry, LPTSTR pszPhone);
extern "C" int _cdecl _purecall(void);

//    //10/24/96 jmazner Normandy 6968
//    //No longer neccessary thanks to Valdon's hooks for invoking ICW.
// 11/21/96 jmazner Normandy 11812
// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
// ICW 1.1 needs to morph the IE 3 icon.
HRESULT GetDeskTopInternetCommand();
HRESULT RestoreDeskTopInternetCommand();

//
// 7/24/97 ChrisK Olympus 1923
//
BOOL WaitForConnectionTermination(HRASCONN);

// 11/21/96 jmazner Normandy #11812
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS);
// Note that bryanst and marcl have confirmed that this key will be supported in IE 4
#define IE_PATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")


// IE 4 has major.minor version 4.71
// IE 3 golden has major.minor.release.build version # > 4.70.0.1155
// IE 2 has major.minor of 4.40

#define IE4_MAJOR_VERSION (UINT) 4
#define IE4_MINOR_VERSION (UINT) 71
#define IE4_VERSIONMS (DWORD) ((IE4_MAJOR_VERSION << 16) | IE4_MINOR_VERSION)

HRESULT ClearProxySettings();
HRESULT RestoreProxySettings();
BOOL FShouldRetry2(HRESULT hrErr);

extern void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg);
extern void InfoMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg);

VOID CALLBACK BusyMessagesTimerProc(HWND hwnd,
        UINT uMsg,
        UINT idEvent,
        DWORD dwTime);


// 4-30-97 ChrisK Olympus 2934
// While the ICW is trying to connect to the referral server, indicate something is
// working
#define MAX_BUSY_MESSAGE    255
#define MAX_VALUE_NAME        10
#define DEFAULT_IDEVENT        31
#define DEFAULT_UELAPSE        3000
class CBusyMessages
{
friend VOID CALLBACK BusyMessagesTimerProc(HWND hwnd,
        UINT uMsg,
        UINT idEvent,
        DWORD dwTime);
public:
    CBusyMessages();
    ~CBusyMessages();
    DWORD Start(HWND hwnd, INT iID, HRASCONN hrasconn);
    DWORD Stop();

private:
    // Private data members
    HWND    m_hwnd;
    INT        m_iStatusLabel;
    CHAR    m_szMessage[MAX_BUSY_MESSAGE];
    DWORD    m_dwCurIdx;
    UINT    m_uIDTimer;
    HINSTANCE m_hInstance;
    HRASCONN m_hrasconn;
    RNAAPI* m_prna;
};

//
// defined in connmain.cpp
//
class RegEntry
{
    public:
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry();
        
        long    GetError()    { return _error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        // long    SetValue(const TCHAR *pszValue, unsigned long dwNumber);
        TCHAR *    GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
        //long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        /**long    FlushKey();
        long    MoveToSubKey(const TCHAR *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; } **/

    private:
        HKEY    _hkey;
        long    _error;
        BOOL    bhkeyValid;
};


// Trace flags
#define TF_RNAAPI           0x00000010      // RNA Api stuff
#define TF_SMARTSTART       0x00000020      // Smart Start code
#define TF_SYSTEMCONFIG     0x00000040      // System Config
#define TF_TAPIINFO         0x00000080      // TAPI stuff
#define TF_INSHANDLER       0x00000100      // INS processing stuff

// Prototypes for stuff in MISC.CPP
int Sz2W (LPCTSTR szBuf);
int FIsDigit( int c );
LPBYTE MyMemSet(LPBYTE dest,int c, size_t count);
LPBYTE MyMemCpy(LPBYTE dest,const LPBYTE src, size_t count);
BOOL ShowControl(HWND hDlg,int idControl,BOOL fShow);
BOOL ConvertToLongFilename(LPTSTR szOut, LPTSTR szIn, DWORD dwSize);


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : malloc(cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) free(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    TCHAR  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


typedef struct SERVER_TYPES_tag
{
    TCHAR szType[6];
    DWORD dwType;
    DWORD dwfOptions;
} SERVER_TYPES;
#define NUM_SERVER_TYPES    4

// Default branding flags the we will support
#define BRAND_FAVORITES 1
#define BRAND_STARTSEARCH 2
#define BRAND_TITLE 4
#define BRAND_BITMAPS 8
#define BRAND_MAIL 16
#define BRAND_NEWS 32

#define BRAND_DEFAULT (BRAND_FAVORITES | BRAND_STARTSEARCH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\progress.cpp ===
/*-----------------------------------------------------------------------------
    progress.cpp

    Download thread and progress update.  Part of CRefDial

    History:
        1/11/98      DONALDM Moved to new ICW project and string
                     and nuked 16 bit stuff
-----------------------------------------------------------------------------*/

#include "stdafx.h"
#include "icwhelp.h"
#include "refdial.h"
#include "icwdl.h"

#define MAX_EXIT_RETRIES 10

extern BOOL MinimizeRNAWindowEx();

void WINAPI MyProgressCallBack
(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
)
{
    CRefDial    *pRefDial = (CRefDial *)dwContext;
    int         prc;

    if (!dwContext) 
        return;

    switch(dwInternetStatus)
    {
        case CALLBACK_TYPE_PROGRESS:
            prc = *(int*)lpvStatusInformation;\
            // Set the status string ID
            pRefDial->m_DownloadStatusID = IDS_RECEIVING_RESPONSE;

            // Post a message to fire an event
            PostMessage(pRefDial->m_hWnd, WM_DOWNLOAD_PROGRESS, prc, 0);
            break;
            
        case CALLBACK_TYPE_URL:
            if (lpvStatusInformation)
                lstrcpy(pRefDial->m_szRefServerURL, (LPTSTR)lpvStatusInformation);
            break;            
            
        default:
            TraceMsg(TF_GENERAL, TEXT("CONNECT:Unknown Internet Status (%d).\n"),dwInternetStatus);
            pRefDial->m_DownloadStatusID = 0;
            break;
    }
}

DWORD WINAPI  DownloadThreadInit(LPVOID lpv)
{
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    CRefDial    *pRefDial = (CRefDial*)lpv;
    HINSTANCE   hDLDLL = NULL; // Download .DLL
    HINSTANCE   hADDll = NULL;
    FARPROC     fp;

    MinimizeRNAWindowEx();

    hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);
    if (!hDLDLL)
    {
        hr = ERROR_DOWNLOAD_NOT_FOUND;
        AssertMsg(0,TEXT("icwdl missing"));
        goto ThreadInitExit;
    }

    // Set up for download
    //
    fp = GetProcAddress(hDLDLL,DOWNLOADINIT);
    AssertMsg(fp != NULL,TEXT("DownLoadInit API missing"));
    hr = ((PFNDOWNLOADINIT)fp)(pRefDial->m_szUrl, (DWORD_PTR FAR *)pRefDial, &pRefDial->m_dwDownLoad, pRefDial->m_hWnd);
    if (hr != ERROR_SUCCESS) 
        goto ThreadInitExit;
    
    // Set up call back for progress dialog
    //
    fp = GetProcAddress(hDLDLL,DOWNLOADSETSTATUS);
    Assert(fp);
    hr = ((PFNDOWNLOADSETSTATUS)fp)(pRefDial->m_dwDownLoad,(INTERNET_STATUS_CALLBACK)MyProgressCallBack);

    // Download stuff MIME multipart
    //
    fp = GetProcAddress(hDLDLL,DOWNLOADEXECUTE);
    Assert(fp);
    hr = ((PFNDOWNLOADEXECUTE)fp)(pRefDial->m_dwDownLoad);
    if (hr)
    {
        goto ThreadInitExit;
    }

    fp = GetProcAddress(hDLDLL,DOWNLOADPROCESS);
    Assert(fp);
    hr = ((PFNDOWNLOADPROCESS)fp)(pRefDial->m_dwDownLoad);
    if (hr)
    {
        goto ThreadInitExit;
    }

    hr = ERROR_SUCCESS;

ThreadInitExit:

    // Clean up
    //
    if (pRefDial->m_dwDownLoad)
    {
        fp = GetProcAddress(hDLDLL,DOWNLOADCLOSE);
        Assert(fp);
        ((PFNDOWNLOADCLOSE)fp)(pRefDial->m_dwDownLoad);
        pRefDial->m_dwDownLoad = 0;
    }

    // Call the OnDownLoadCompelete method
    PostMessage(pRefDial->m_hWnd, WM_DOWNLOAD_DONE, 0, 0);

    // Free the libs used to do the download
    if (hDLDLL) 
        FreeLibrary(hDLDLL);
    if (hADDll) 
        FreeLibrary(hADDll);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\inshandler.cpp ===
// INSHandler.cpp : Implementation of CINSHandler
#include "stdafx.h"
#include "icwhelp.h"
#include "INSHandler.h"
#include "webgate.h"

#include <icwacct.h>

#define MAXNAME             80
#define MAXIPADDRLEN        20
#define MAXLONGLEN          80
#define MAX_ISP_NAME        256
#define MAX_ISP_MSG         560
#define MAX_ISP_PHONENUMBER 80

#define SIZE_ReadBuf    0x00008000    // 32K buffer size
#define myisdigit(ch) (((ch) >= '0') && ((ch) <= '9'))


// The following values are global read only strings used to
// process the INS file
#pragma data_seg(".rdata")

static const TCHAR cszAlias[]         = TEXT("Import_Name");
static const TCHAR cszML[]            = TEXT("Multilink");

static const TCHAR cszPhoneSection[]  = TEXT("Phone");
static const TCHAR cszDialAsIs[]      = TEXT("Dial_As_Is");
static const TCHAR cszPhone[]         = TEXT("Phone_Number");
static const TCHAR cszAreaCode[]      = TEXT("Area_Code");
static const TCHAR cszCountryCode[]   = TEXT("Country_Code");
static const TCHAR cszCountryID[]     = TEXT("Country_ID");

static const TCHAR cszDeviceSection[] = TEXT("Device");
static const TCHAR cszDeviceType[]    = TEXT("Type");
static const TCHAR cszDeviceName[]    = TEXT("Name");
static const TCHAR cszDevCfgSize[]    = TEXT("Settings_Size");
static const TCHAR cszDevCfg[]        = TEXT("Settings");

static const TCHAR cszServerSection[] = TEXT("Server");
static const TCHAR cszServerType[]    = TEXT("Type");
static const TCHAR cszSWCompress[]    = TEXT("SW_Compress");
static const TCHAR cszPWEncrypt[]     = TEXT("PW_Encrypt");
static const TCHAR cszNetLogon[]      = TEXT("Network_Logon");
static const TCHAR cszSWEncrypt[]     = TEXT("SW_Encrypt");
static const TCHAR cszNetBEUI[]       = TEXT("Negotiate_NetBEUI");
static const TCHAR cszIPX[]           = TEXT("Negotiate_IPX/SPX");
static const TCHAR cszIP[]            = TEXT("Negotiate_TCP/IP");
static TCHAR cszDisableLcp[]          = TEXT("Disable_LCP");

static const TCHAR cszIPSection[]     = TEXT("TCP/IP");
static const TCHAR cszIPSpec[]        = TEXT("Specify_IP_Address");
static const TCHAR cszIPAddress[]     = TEXT("IP_address");
static const TCHAR cszServerSpec[]    = TEXT("Specify_Server_Address");
static const TCHAR cszDNSAddress[]    = TEXT("DNS_address");
static const TCHAR cszDNSAltAddress[] = TEXT("DNS_Alt_address");
static const TCHAR cszWINSAddress[]   = TEXT("WINS_address");
static const TCHAR cszWINSAltAddress[]= TEXT("WINS_Alt_address");
static const TCHAR cszIPCompress[]    = TEXT("IP_Header_Compress");
static const TCHAR cszWanPri[]        = TEXT("Gateway_On_Remote");

static const TCHAR cszMLSection[]     = TEXT("Multilink");
static const TCHAR cszLinkIndex[]     = TEXT("Line_%s");

static const TCHAR cszScriptingSection[] = TEXT("Scripting");
static const TCHAR cszScriptName[]    = TEXT("Name");

static const TCHAR cszScriptSection[] = TEXT("Script_File");

static const TCHAR cszCustomDialerSection[] = TEXT("Custom_Dialer");
static const TCHAR cszAutoDialDLL[]   = TEXT("Auto_Dial_DLL");
static const TCHAR cszAutoDialFunc[]  = TEXT("Auto_Dial_Function");

// These strings will be use to populate the registry, with the data above
static const TCHAR cszKeyIcwRmind[]   = TEXT("Software\\Microsoft\\Internet Connection Wizard\\IcwRmind");

static const TCHAR cszTrialRemindSection[] = TEXT("TrialRemind");
static const TCHAR cszEntryISPName[]       = TEXT("ISP_Name");
static const TCHAR cszEntryISPPhone[]      = TEXT("ISP_Phone");
static const TCHAR cszEntryISPMsg[]        = TEXT("ISP_Message");
static const TCHAR cszEntryTrialDays[]     = TEXT("Trial_Days");
static const TCHAR cszEntrySignupURL[]     = TEXT("Signup_URL");
// ICWRMIND expects this value in the registry
static const TCHAR cszEntrySignupURLTrialOver[] = TEXT("Expired_URL");

// We get these two from the INS file 
static const TCHAR cszEntryExpiredISPFileName[] = TEXT("Expired_ISP_File");
static const TCHAR cszSignupExpiredISPURL[] = TEXT("Expired_ISP_URL");

static const TCHAR cszEntryConnectoidName[] = TEXT("Entry_Name");
static const TCHAR cszSignupSuccessfuly[] = TEXT("TrialConverted");

static const TCHAR cszReminderApp[] = TEXT("ICWRMIND.EXE");
static const TCHAR cszReminderParams[] = TEXT("-t");

static const TCHAR cszPassword[]      = TEXT("Password");
static const TCHAR cszCMHeader[]      = TEXT("Connection Manager CMS 0");

extern SERVER_TYPES aServerTypes[];

// These are the field names from an INS file that will
// determine the mail and news settings
static const TCHAR cszMailSection[]       = TEXT("Internet_Mail");
static const TCHAR cszEntryName[]         = TEXT("Entry_Name");
static const TCHAR cszPOPServer[]         = TEXT("POP_Server");
static const TCHAR cszPOPServerPortNumber[] = TEXT("POP_Server_Port_Number");
static const TCHAR cszPOPLogonName[]      = TEXT("POP_Logon_Name");
static const TCHAR cszPOPLogonPassword[]  = TEXT("POP_Logon_Password");
static const TCHAR cszSMTPServer[]        = TEXT("SMTP_Server");
static const TCHAR cszSMTPServerPortNumber[] = TEXT("SMTP_Server_Port_Number");
static const TCHAR cszNewsSection[]       = TEXT("Internet_News");
static const TCHAR cszNNTPServer[]        = TEXT("NNTP_Server");
static const TCHAR cszNNTPServerPortNumber[] = TEXT("NNTP_Server_Port_Number");
static const TCHAR cszNNTPLogonName[]     = TEXT("NNTP_Logon_Name");
static const TCHAR cszNNTPLogonPassword[] = TEXT("NNTP_Logon_Password");
static const TCHAR cszUseMSInternetMail[] = TEXT("Install_Mail");
static const TCHAR cszUseMSInternetNews[] = TEXT("Install_News");


static const TCHAR cszEMailSection[]    = TEXT("Internet_Mail");
static const TCHAR cszEMailName[]       = TEXT("EMail_Name");
static const TCHAR cszEMailAddress[]    = TEXT("EMail_Address");
static const TCHAR cszUseExchange[]     = TEXT("Use_MS_Exchange");
static const TCHAR cszUserSection[]     = TEXT("User");
static const TCHAR cszUserName[]        = TEXT("Name");
static const TCHAR cszDisplayPassword[] = TEXT("Display_Password");
static const TCHAR cszYes[]             = TEXT("yes");
static const TCHAR cszNo[]              = TEXT("no");

#define CLIENT_OFFSET(elem)    ((DWORD)(DWORD_PTR)&(((LPINETCLIENTINFO)(NULL))->elem))
#define CLIENT_SIZE(elem)      sizeof(((LPINETCLIENTINFO)(NULL))->elem)
#define CLIENT_ENTRY(section, value, elem) \
    {section, value, CLIENT_OFFSET(elem), CLIENT_SIZE(elem)}

CLIENT_TABLE iniTable[] =
{
    CLIENT_ENTRY(cszEMailSection, cszEMailName,         szEMailName),
    CLIENT_ENTRY(cszEMailSection, cszEMailAddress,      szEMailAddress),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonName,      szPOPLogonName),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonPassword,  szPOPLogonPassword),
    CLIENT_ENTRY(cszEMailSection, cszPOPServer,         szPOPServer),
    CLIENT_ENTRY(cszEMailSection, cszSMTPServer,        szSMTPServer),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonName,     szNNTPLogonName),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonPassword, szNNTPLogonPassword),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPServer,        szNNTPServer),
    {NULL, NULL, 0, 0}
};

static const TCHAR cszFileName[]           = TEXT("Custom_File");
static const TCHAR cszCustomFileSection[]  = TEXT("Custom_File");
static const TCHAR cszNull[] = TEXT("");

static const TCHAR cszURLSection[] = TEXT("URL");
static const TCHAR cszSignupURL[] =  TEXT("Signup");
static const TCHAR cszAutoConfigURL[] =  TEXT("Autoconfig");

static const TCHAR cszExtINS[] = TEXT(".ins");
static const TCHAR cszExtISP[] = TEXT(".isp");
static const TCHAR cszExtHTM[] = TEXT(".htm");
static const TCHAR cszExtHTML[] = TEXT(".html");

static const TCHAR cszEntrySection[]     = TEXT("Entry");
static const TCHAR cszCancel[]           = TEXT("Cancel");
static const TCHAR cszStartURL[]         = TEXT("StartURL");
static const TCHAR cszRun[]              = TEXT("Run");
static const TCHAR cszArgument[]         = TEXT("Argument");

static const TCHAR cszConnect2[]         = TEXT("icwconn2.exe");
static const TCHAR cszClientSetupSection[]  = TEXT("ClientSetup");

static const TCHAR cszRequiresLogon[]  = TEXT("Requires_Logon");

static const TCHAR cszCustomSection[]  = TEXT("Custom");
static const TCHAR cszKeepConnection[] = TEXT("Keep_Connection");
static const TCHAR cszKeepBrowser[]    = TEXT("Keep_Browser");

static const TCHAR cszBrandingSection[]  = TEXT("Branding");
static const TCHAR cszBrandingFlags[] = TEXT("Flags");

static const TCHAR cszHTTPS[] = TEXT("https:");
// code relies on these two being the same length
static const TCHAR cszHTTP[] = TEXT("http:");
static const TCHAR cszFILE[] = TEXT("file:");

static const TCHAR cszKioskMode[] = TEXT("-k ");
static const TCHAR cszOpen[] = TEXT("open");
static const TCHAR cszBrowser[] = TEXT("iexplore.exe");
static const TCHAR szNull[] = TEXT("");

static const TCHAR cszDEFAULT_BROWSER_KEY[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR cszDEFAULT_BROWSER_VALUE[] = TEXT("check_associations");

// Registry keys which will contain News and Mail settings
#define MAIL_KEY        TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\Mail")
#define MAIL_POP3_KEY    TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\POP3\\")
#define MAIL_SMTP_KEY    TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\SMTP\\")
#define NEWS_KEY        TEXT("SOFTWARE\\Microsoft\\Internet Mail and News\\News")
#define MAIL_NEWS_INPROC_SERVER32 TEXT("CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32")
typedef HRESULT (WINAPI *PFNSETDEFAULTNEWSHANDLER)(void);

// These are the value names where the INS settings will be saved
// into the registry                                            
static const TCHAR cszMailSenderName[]        = TEXT("Sender Name");
static const TCHAR cszMailSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszMailRASPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszMailConnectionType[]    = TEXT("Connection Type");
static const TCHAR cszDefaultPOP3Server[]    = TEXT("Default POP3 Server");
static const TCHAR cszDefaultSMTPServer[]    = TEXT("Default SMTP Server");
static const TCHAR cszPOP3Account[]            = TEXT("Account");
static const TCHAR cszPOP3Password[]            = TEXT("Password");
static const TCHAR cszPOP3Port[]                = TEXT("Port");
static const TCHAR cszSMTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPSenderName[]        = TEXT("Sender Name");
static const TCHAR cszNNTPSenderEMail[]        = TEXT("Sender EMail");
static const TCHAR cszNNTPDefaultServer[]    = TEXT("DefaultServer"); // NOTE: NO space between "Default" and "Server".
static const TCHAR cszNNTPAccountName[]        = TEXT("Account Name");
static const TCHAR cszNNTPPassword[]            = TEXT("Password");
static const TCHAR cszNNTPPort[]                = TEXT("Port");
static const TCHAR cszNNTPRasPhonebookEntry[]= TEXT("RAS Phonebook Entry");
static const TCHAR cszNNTPConnectionType[]    = TEXT("Connection Type");

static const TCHAR arBase64[] = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U',
            'V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
            'q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='};


#define ICWCOMPLETEDKEY TEXT("Completed")
            
// 2/19/97 jmazner Olympus #1106 -- SAM/SBS integration
TCHAR FAR cszSBSCFG_DLL[] = TEXT("SBSCFG.DLL\0");
CHAR FAR cszSBSCFG_CONFIGURE[] = "Configure\0";
typedef DWORD (WINAPI * SBSCONFIGURE) (HWND hwnd, LPTSTR lpszINSFile, LPTSTR szConnectoidName);
SBSCONFIGURE  lpfnConfigure;

// 09/02/98 Donaldm: Integrate with Connection Manager
TCHAR FAR cszCMCFG_DLL[] = TEXT("CMCFG32.DLL\0");
CHAR  FAR cszCMCFG_CONFIGURE[]   = "CMConfig\0"; // Proc address
CHAR  FAR cszCMCFG_CONFIGUREEX[] = "CMConfigEx\0"; // Proc address

typedef BOOL (WINAPI * CMCONFIGUREEX)(LPCSTR lpszINSFile);
typedef BOOL (WINAPI * CMCONFIGURE)(LPCSTR lpszINSFile, LPCSTR lpszConnectoidNams);
CMCONFIGURE   lpfnCMConfigure;
CMCONFIGUREEX lpfnCMConfigureEx;
            
#pragma data_seg()


//+----------------------------------------------------------------------------
//
//    Function:    CallCMConfig
//
//    Synopsis:    Call into the Connection Manager dll's Configure function to allow CM to
//                process the .ins file as needed.
//
//    Arguements: lpszINSFile -- full path to the .ins file
//
//    Returns:    TRUE if a CM profile is created, FALSE otherwise
//
//    History:    09/02/98    DONALDM
//
//-----------------------------------------------------------------------------
BOOL CINSHandler::CallCMConfig(LPCTSTR lpszINSFile)
{
    HINSTANCE   hCMDLL = NULL;
    BOOL        bRet = FALSE;

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling LoadLibrary on %s\n"), cszCMCFG_DLL);
    // Load DLL and entry point
    hCMDLL = LoadLibrary(cszCMCFG_DLL);
    if (NULL != hCMDLL)
    {

        // To determine whether we should call CMConfig or CMConfigEx
        // Loop to find the appropriate buffer size to retieve the ins to memory
        ULONG ulBufferSize = 1024*10;
        // Parse the ISP section in the INI file to find query pair to append
        TCHAR *pszKeys = NULL;
        PTSTR pszKey = NULL;
        ULONG ulRetVal     = 0;
        BOOL  bEnumerate = TRUE;
        BOOL  bUseEx = FALSE;
 
        PTSTR pszBuff = NULL;
        ulRetVal = 0;

        pszKeys = new TCHAR [ulBufferSize];
        while (ulRetVal < (ulBufferSize - 2))
        {

            ulRetVal = ::GetPrivateProfileString(NULL, NULL, _T(""), pszKeys, ulBufferSize, lpszINSFile);
            if (0 == ulRetVal)
               bEnumerate = FALSE;

            if (ulRetVal < (ulBufferSize - 2))
            {
                break;
            }
            delete [] pszKeys;
            ulBufferSize += ulBufferSize;
            pszKeys = new TCHAR [ulBufferSize];
            if (!pszKeys)
            {
                bEnumerate = FALSE;
            }

        }

        if (bEnumerate)
        {
            pszKey = pszKeys;
            if (ulRetVal != 0) 
            {
                while (*pszKey)
                {
                    if (!lstrcmpi(pszKey, cszCMHeader)) 
                    {
                        bUseEx = TRUE;
                        break;
                    }
                    pszKey += lstrlen(pszKey) + 1;
                }
            }
        }


        if (pszKeys)
            delete [] pszKeys;
        
        TCHAR   szConnectoidName[RAS_MaxEntryName];
        // Get the connectoid name from the [Entry] Section
        GetPrivateProfileString(cszEntrySection,
                                    cszEntryName,
                                    cszNull,
                                    szConnectoidName,
                                    RAS_MaxEntryName,
                                    lpszINSFile);

        if (bUseEx)
        {
            // Call CMConfigEx
            lpfnCMConfigureEx = (CMCONFIGUREEX)GetProcAddress(hCMDLL,cszCMCFG_CONFIGUREEX);
            if( lpfnCMConfigureEx )
            {
#ifdef UNICODE
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigureEx(szFile);    
#else
                bRet = lpfnCMConfigureEx(lpszINSFile);    
#endif
            }
        }
        else
        {
            // Call CMConfig
            lpfnCMConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL,cszCMCFG_CONFIGURE);
            // Call function
            if( lpfnCMConfigure )
            {

#ifdef UNICODE
                CHAR szEntry[RAS_MaxEntryName];
                CHAR szFile[_MAX_PATH + 1];

                wcstombs(szEntry, szConnectoidName, RAS_MaxEntryName);
                wcstombs(szFile, lpszINSFile, _MAX_PATH + 1);

                bRet = lpfnCMConfigure(szFile, szEntry);  
#else
                bRet = lpfnCMConfigure(lpszINSFile, szConnectoidName);  
#endif

            }
        }

        if (bRet)
        {
            // restore original autodial settings
            m_lpfnInetSetAutodial(TRUE, szConnectoidName);
        }
    }

    // Cleanup
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnCMConfigure )
        lpfnCMConfigure = NULL;

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: CallSBSConfig exiting with error code %d \n"), bRet);
    return bRet;
}


//+----------------------------------------------------------------------------
//
//    Function:    CallSBSConfig
//
//    Synopsis:    Call into the SBSCFG dll's Configure function to allow SBS to
//                process the .ins file as needed
//
//    Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//                lpszINSFile -- full path to the .ins file
//
//    Returns:    windows error code that sbscfg returns.
//
//    History:    2/19/97    jmazner    Created for Olympus #1106
//
//-----------------------------------------------------------------------------
DWORD CINSHandler::CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile)
{
    HINSTANCE   hSBSDLL = NULL;
    DWORD       dwRet = ERROR_SUCCESS;
    TCHAR       lpszConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");

    //
    // Get name of connectoid we created by looking in autodial
    // We need to pass this name into SBSCFG
    // 5/14/97    jmazner    Windosw NT Bugs #87209
    //
    BOOL fEnabled = FALSE;

    if( NULL == m_lpfnInetGetAutodial )
    {
        TraceMsg(TF_INSHANDLER, TEXT("m_lpfnInetGetAutodial is NULL!!!!"));
        return ERROR_INVALID_FUNCTION;
    }

    dwRet = m_lpfnInetGetAutodial(&fEnabled,lpszConnectoidName,RAS_MaxEntryName);

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling LoadLibrary on %s\n"), cszSBSCFG_DLL);
    hSBSDLL = LoadLibrary(cszSBSCFG_DLL);

    // Load DLL and entry point
    if (NULL != hSBSDLL)
    {
        TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling GetProcAddress on %s\n"), cszSBSCFG_CONFIGURE);
        lpfnConfigure = (SBSCONFIGURE)GetProcAddress(hSBSDLL,cszSBSCFG_CONFIGURE);
    }
    else
    {
        // 4/2/97    ChrisK    Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallSBSConfigExit;
    }
    
    // Call function
    if( hSBSDLL && lpfnConfigure )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Calling the Configure entry point: %s, %s\n"), lpszINSFile, lpszConnectoidName);
        dwRet = lpfnConfigure(hwnd, (TCHAR *)lpszINSFile, lpszConnectoidName);    
    }
    else
    {
        TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: Unable to call the Configure entry point\n"));
        dwRet = GetLastError();
    }

CallSBSConfigExit:
    if( hSBSDLL )
        FreeLibrary(hSBSDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    TraceMsg(TF_INSHANDLER, TEXT("ICWCONN1: CallSBSConfig exiting with error code %d \n"), dwRet);
    return dwRet;
}

BOOL CINSHandler::SetICWCompleted( DWORD dwCompleted )
{
    HKEY hKey = NULL;

    HRESULT hr = RegCreateKey(HKEY_CURRENT_USER,ICWSETTINGSPATH,&hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx(hKey, ICWCOMPLETEDKEY, 0, REG_DWORD,
                    (CONST BYTE*)&dwCompleted, sizeof(dwCompleted));
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}

/////////////////////////////////////////////////////////////////////////////
// CINSHandler


HRESULT CINSHandler::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

#define FILE_BUFFER_SIZE 65534
#ifndef FILE_BEGIN
#define FILE_BEGIN  0
#endif

//+---------------------------------------------------------------------------
//
//  Function:   MassageFile
//
//  Synopsis:   Convert 0x0d's in the file to 0x0d 0x0A sequences
//
//+---------------------------------------------------------------------------
HRESULT CINSHandler::MassageFile(LPCTSTR lpszFile)
{
    LPBYTE  lpBufferIn;
    LPBYTE  lpBufferOut;
    HFILE   hfile;
    HRESULT hr = ERROR_SUCCESS;

    if (!SetFileAttributes(lpszFile, FILE_ATTRIBUTE_NORMAL))
    {
        return GetLastError();
    }

    lpBufferIn = (LPBYTE) GlobalAlloc(GPTR, 2 * FILE_BUFFER_SIZE);
    if (NULL == lpBufferIn)
    {
        return ERROR_OUTOFMEMORY;
    }
    lpBufferOut = lpBufferIn + FILE_BUFFER_SIZE;

#ifdef UNICODE
    CHAR szTmp[MAX_PATH+1];
    wcstombs(szTmp, lpszFile, MAX_PATH+1);
    hfile = _lopen(szTmp, OF_READWRITE);
#else
    hfile = _lopen(lpszFile, OF_READWRITE);
#endif
    if (HFILE_ERROR != hfile)
    {
        BOOL    fChanged = FALSE;
        UINT    uBytesOut = 0;
        UINT    uBytesIn = _lread(hfile, lpBufferIn, (UINT)(FILE_BUFFER_SIZE - 1));

        // Note:  we asume, in our use of lpCharIn, that the file is always less than
        // FILE_BUFFER_SIZE
        if (HFILE_ERROR != uBytesIn)
        {
            LPBYTE  lpCharIn = lpBufferIn;
            LPBYTE  lpCharOut = lpBufferOut;

            while ((*lpCharIn) && (FILE_BUFFER_SIZE - 2 > uBytesOut))
            {
              *lpCharOut++ = *lpCharIn;
              uBytesOut++;
              if ((0x0d == *lpCharIn) && (0x0a != *(lpCharIn + 1)))
              {
                fChanged = TRUE;

                *lpCharOut++ = 0x0a;
                uBytesOut++;
              }
              lpCharIn++;
            }

            if (fChanged)
            {
                if (HFILE_ERROR != _llseek(hfile, 0, FILE_BEGIN))
                {
                    if (HFILE_ERROR ==_lwrite(hfile, (LPCSTR) lpBufferOut, uBytesOut))
                    {
                        hr = GetLastError();
                    }
                }
                else
                {
                    hr = GetLastError();
                }
            }
        }
        else
        {
            hr = GetLastError();
        }
        _lclose(hfile);
    }
    else
    {
        hr = GetLastError();
    }

    GlobalFree((HGLOBAL)lpBufferIn);
    return ERROR_SUCCESS;
}

DWORD CINSHandler::RunExecutable(void)
{
    DWORD               dwRet;
    SHELLEXECUTEINFO    sei;

    // Hide the active window first
    HWND  hWndHide = GetActiveWindow();
    ::ShowWindow(hWndHide, SW_HIDE);
    
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_NOCLOSEPROCESS;
    sei.hwnd = NULL;
    sei.lpVerb = cszOpen;
    sei.lpFile = m_szRunExecutable;
    sei.lpParameters = m_szRunArgument;
    sei.lpDirectory = NULL;
    sei.nShow = SW_SHOWNORMAL;
    sei.hInstApp = NULL;
    // Optional members 
    sei.hProcess = NULL;

    if (ShellExecuteEx(&sei))
    {
        DWORD iWaitResult = 0;
        // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
        while((iWaitResult=MsgWaitForMultipleObjects(1, &sei.hProcess, FALSE, INFINITE, QS_ALLINPUT))==(WAIT_OBJECT_0 + 1))
        {
           MSG msg ;
           // read all of the messages in this next loop
           // removing each message as we read it
           while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
           {
               if (msg.message == WM_QUIT)
               {
                   CloseHandle(sei.hProcess);
                   return NO_ERROR;
               }
               else
                   DispatchMessage(&msg);
            }
        }

        CloseHandle(sei.hProcess);
        dwRet = ERROR_SUCCESS;
    }
    else
    {
        dwRet = GetLastError();
    }

    ::ShowWindow(hWndHide, SW_SHOW);
    
    return dwRet;
}

void CINSHandler::SaveAutoDial(void)
{
    Assert(m_lpfnInetGetAutodial);
    Assert(m_lpfnInetGetProxy);
    Assert(m_lpfnInetSetProxy);

    // if the original autodial settings have not been saved 
    if (!m_fAutodialSaved)
    {
        // save the current autodial settings
        m_lpfnInetGetAutodial(
                &m_fAutodialEnabled,
                m_szAutodialConnection,
                sizeof(m_szAutodialConnection));

        m_lpfnInetGetProxy(
                &m_fProxyEnabled,
                NULL, 0,
                NULL, 0);

        // turn off proxy
        m_lpfnInetSetProxy(FALSE, NULL, NULL);

        m_fAutodialSaved = TRUE;
    }
}

void CINSHandler::RestoreAutoDial(void)
{
    Assert(m_lpfnInetSetAutodial);
    Assert(m_lpfnInetSetProxy);

    if (m_fAutodialSaved)
    {
        // restore original autodial settings
        m_lpfnInetSetAutodial(m_fAutodialEnabled, m_szAutodialConnection);
        m_fAutodialSaved = FALSE;
    }
}

BOOL CINSHandler::KeepConnection(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszCustomSection,
                            cszKeepConnection,
                            cszNo,
                            szTemp,
                            10,
                            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD CINSHandler::ImportCustomInfo
(
    LPCTSTR lpszImportFile,
    LPTSTR lpszExecutable,
    DWORD cbExecutable,
    LPTSTR lpszArgument,
    DWORD cbArgument
)
{
    GetPrivateProfileString(cszCustomSection,
                              cszRun,
                              cszNull,
                              lpszExecutable,
                              (int)cbExecutable,
                              lpszImportFile);

    GetPrivateProfileString(cszCustomSection,
                              cszArgument,
                              cszNull,
                              lpszArgument,
                              (int)cbArgument,
                              lpszImportFile);

    return ERROR_SUCCESS;
}


DWORD CINSHandler::ImportFile
(
    LPCTSTR lpszImportFile, 
    LPCTSTR lpszSection, 
    LPCTSTR lpszOutputFile
)
{
    HFILE   hFile;
    LPTSTR  pszLine, pszFile;
    int     i, iMaxLine;
    UINT    cbSize, cbRet;
    DWORD   dwRet = ERROR_SUCCESS;

    // Allocate a buffer for the file
    if ((pszFile = (LPTSTR)LocalAlloc(LMEM_FIXED, SIZE_ReadBuf * 2)) == NULL)
    { 
        return ERROR_OUTOFMEMORY;
    }

    // Look for script
    if (GetPrivateProfileString(lpszSection,
                                NULL,
                                szNull,
                                pszFile,
                                SIZE_ReadBuf / sizeof(TCHAR),
                                lpszImportFile) != 0)
    {
        // Get the maximum line number
        pszLine = pszFile;
        iMaxLine = -1;
        while (*pszLine)
        {
            i = _ttoi(pszLine);
            iMaxLine = max(iMaxLine, i);
            pszLine += lstrlen(pszLine)+1;
        };

        // If we have at least one line, we will import the script file
        if (iMaxLine >= 0)
        {
            // Create the script file
#ifdef UNICODE
            CHAR szTmp[MAX_PATH+1];
            wcstombs(szTmp, lpszOutputFile, MAX_PATH+1);
            hFile = _lcreat(szTmp, 0);
#else
            hFile = _lcreat(lpszOutputFile, 0);
#endif

            if (hFile != HFILE_ERROR)
            {     
                TCHAR  szLineNum[MAXLONGLEN+1];

                // From The first line to the last line
                for (i = 0; i <= iMaxLine; i++)
                {
                    // Read the script line
                    wsprintf(szLineNum, TEXT("%d"), i);
                    if ((cbSize = GetPrivateProfileString(lpszSection,
                                                          szLineNum,
                                                          szNull,
                                                          pszLine,
                                                          SIZE_ReadBuf / sizeof(TCHAR),
                                                          lpszImportFile)) != 0)
                    {
                        // Write to the script file
                        lstrcat(pszLine, TEXT("\x0d\x0a"));
#ifdef UNICODE
                        wcstombs(szTmp, pszLine, MAX_PATH+1);
                        cbRet=_lwrite(hFile, szTmp, cbSize+2);
#else
			cbRet=_lwrite(hFile, pszLine, cbSize+2);
#endif
                    }
                }
                _lclose(hFile);
            }
            else
            {
                dwRet = ERROR_PATH_NOT_FOUND;
            }
        }
        else
        {
            dwRet = ERROR_PATH_NOT_FOUND;
        }
    }
    else
    {
        dwRet = ERROR_PATH_NOT_FOUND;
    }
    LocalFree(pszFile);

    return dwRet;
}

DWORD CINSHandler::ImportCustomFile
(
    LPCTSTR lpszImportFile
)
{
    TCHAR   szFile[_MAX_PATH];
    TCHAR   szTemp[_MAX_PATH];

    // If a custom file name does not exist, do nothing
    if (GetPrivateProfileString(cszCustomSection,
                                cszFileName,
                                cszNull,
                                szTemp,
                                _MAX_PATH,
                                lpszImportFile) == 0)
    {
        return ERROR_SUCCESS;
    };

    GetWindowsDirectory(szFile, _MAX_PATH);
    if (*CharPrev(szFile, szFile + lstrlen(szFile)) != '\\')
    {
        lstrcat(szFile, TEXT("\\"));
    }
    lstrcat(szFile, szTemp);
  
    return (ImportFile(lpszImportFile, cszCustomFileSection, szFile));
}

BOOL CINSHandler::LoadExternalFunctions(void)
{
    BOOL    bRet = FALSE;

    do 
    {
        // Load the Brading library functions
        m_hBranding = LoadLibrary(TEXT("IEDKCS32.DLL"));
        if (m_hBranding != NULL)
        {
            if (NULL == (m_lpfnBrandICW = (PFNBRANDICW)GetProcAddress(m_hBranding, "BrandICW2")))
                break;
        }
        else
        {
            break;
        }

        // Load the Inet Config library functions
        m_hInetCfg = LoadLibrary(TEXT("INETCFG.DLL"));
        if (m_hInetCfg != NULL)
        {
#ifdef UNICODE
            if (NULL == (m_lpfnInetConfigSystem = (PFNINETCONFIGSYSTEM)GetProcAddress(m_hInetCfg, "InetConfigSystem")))
                break;
            if (NULL == (m_lpfnInetGetProxy = (PFNINETGETPROXY)GetProcAddress(m_hInetCfg, "InetGetProxyW")))
                break;
            if (NULL == (m_lpfnInetConfigClient = (PFNINETCONFIGCLIENT)GetProcAddress(m_hInetCfg, "InetConfigClientW")))
                break;
            //if (NULL == (m_lpfnInetConfigClientEx = (PFNINETCONFIGCLIENTEX)GetProcAddress(m_hInetCfg, "InetConfigClientExW")))
            //    break;
            if (NULL == (m_lpfnInetGetAutodial = (PFNINETGETAUTODIAL)GetProcAddress(m_hInetCfg, "InetGetAutodialW")))
                break;
            if (NULL == (m_lpfnInetSetAutodial = (PFNINETSETAUTODIAL)GetProcAddress(m_hInetCfg, "InetSetAutodialW")))
                break;
            if (NULL == (m_lpfnInetSetClientInfo = (PFNINETSETCLIENTINFO)GetProcAddress(m_hInetCfg, "InetSetClientInfoW")))
                break;
            if (NULL == (m_lpfnInetSetProxy = (PFNINETSETPROXY)GetProcAddress(m_hInetCfg, "InetSetProxyW")))
                break;
#else  // UNICODE
            if (NULL == (m_lpfnInetConfigSystem = (PFNINETCONFIGSYSTEM)GetProcAddress(m_hInetCfg, "InetConfigSystem")))
                break;
            if (NULL == (m_lpfnInetGetProxy = (PFNINETGETPROXY)GetProcAddress(m_hInetCfg, "InetGetProxy")))
                break;
            if (NULL == (m_lpfnInetConfigClient = (PFNINETCONFIGCLIENT)GetProcAddress(m_hInetCfg, "InetConfigClient")))
                break;
            if (NULL == (m_lpfnInetGetAutodial = (PFNINETGETAUTODIAL)GetProcAddress(m_hInetCfg, "InetGetAutodial")))
                break;
            if (NULL == (m_lpfnInetSetAutodial = (PFNINETSETAUTODIAL)GetProcAddress(m_hInetCfg, "InetSetAutodial")))
                break;
            if (NULL == (m_lpfnInetSetClientInfo = (PFNINETSETCLIENTINFO)GetProcAddress(m_hInetCfg, "InetSetClientInfo")))
                break;
            if (NULL == (m_lpfnInetSetProxy = (PFNINETSETPROXY)GetProcAddress(m_hInetCfg, "InetSetProxy")))
                break;
#endif // UNICODE
        }
        else
        {
            break;
        }

        if( IsNT() )
        {
            // Load the RAS functions
            m_hRAS = LoadLibrary(TEXT("RASAPI32.DLL"));
            if (m_hRAS != NULL)
            {
#ifdef UNICODE
                if (NULL == (m_lpfnRasSetAutodialEnable = (PFNRASSETAUTODIALENABLE)GetProcAddress(m_hRAS, "RasSetAutodialEnableW")))
                    break;
                if (NULL == (m_lpfnRasSetAutodialAddress = (PFNRASSETAUTODIALADDRESS)GetProcAddress(m_hRAS, "RasSetAutodialAddressW")))
                    break;
#else
                if (NULL == (m_lpfnRasSetAutodialEnable = (PFNRASSETAUTODIALENABLE)GetProcAddress(m_hRAS, "RasSetAutodialEnableA")))
                    break;
                if (NULL == (m_lpfnRasSetAutodialAddress = (PFNRASSETAUTODIALADDRESS)GetProcAddress(m_hRAS, "RasSetAutodialAddressA")))
                    break;
#endif
            }
            else
            {
                break;
            }
        }

        // Success if we get to here
        bRet = TRUE;
        break;
    } while(1);

    return bRet;
}

//-----------------------------------------------------------------------------
//    OpenIcwRmindKey
//-----------------------------------------------------------------------------
BOOL CINSHandler::OpenIcwRmindKey(CMcRegistry &reg)
{
    // This method will open the IcwRmind key in the registry.  If the key
    // does not exist it will be created here.
    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, cszKeyIcwRmind);

    if (!bRetCode)
    {
         bRetCode = reg.CreateKey(HKEY_LOCAL_MACHINE, cszKeyIcwRmind);
        _ASSERT(bRetCode);
    }

    return bRetCode;
}

BOOL CINSHandler::ConfigureTrialReminder
(
    LPCTSTR  lpszFile
)
{
    USES_CONVERSION;
    
    TCHAR   szISPName[MAX_ISP_NAME];
    TCHAR   szISPMsg[MAX_ISP_MSG];
    TCHAR   szISPPhoneNumber[MAX_ISP_PHONENUMBER];
    int     iTrialDays;
    TCHAR   szConvertURL[INTERNET_MAX_URL_LENGTH];
    
    TCHAR   szExpiredISPFileURL[INTERNET_MAX_URL_LENGTH];
    TCHAR   szExpiredISPFileName[MAX_PATH]; // The fully qualified path to the final INS file
    TCHAR   szISPFile[MAX_PATH];            // The name we get in the INS
    
    TCHAR   szConnectoidName[MAXNAME];
    
    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPName,
                                cszNull,
                                szISPName,
                                MAX_ISP_NAME,
                                lpszFile) == 0)
    {
        return FALSE;
    }

    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPPhone,
                                cszNull,
                                szISPPhoneNumber,
                                MAX_ISP_PHONENUMBER,
                                lpszFile) == 0)
    {
        return FALSE;
    }

    if ((iTrialDays = GetPrivateProfileInt(cszTrialRemindSection,
                                           cszEntryTrialDays,
                                           0,
                                           lpszFile)) == 0)
    {
        return FALSE;
    }
           
    
    if (GetPrivateProfileString(cszTrialRemindSection,
                                cszEntrySignupURL,
                                cszNull,
                                szConvertURL,
                                INTERNET_MAX_URL_LENGTH,
                                lpszFile) == 0)
    {
        return FALSE;
    }

    //optional
    GetPrivateProfileString(cszTrialRemindSection,
                                cszEntryISPMsg,
                                cszNull,
                                szISPMsg,
                                MAX_ISP_MSG,
                                lpszFile);
    
    // Get the connectoid name from the [Entry] Section
    if (GetPrivateProfileString(cszEntrySection,
                                cszEntryName,
                                cszNull,
                                szConnectoidName,
                                MAXNAME,
                                lpszFile) == 0)
    {
        return FALSE;
    }    
    
    // If we get to here, we have everything to setup a trial, so let's do it.
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        // Set the values we have
        reg.SetValue(cszEntryISPName, szISPName);
        reg.SetValue(cszEntryISPMsg, szISPMsg);
        reg.SetValue(cszEntryISPPhone, szISPPhoneNumber);
        reg.SetValue(cszEntryTrialDays, (DWORD)iTrialDays);
        reg.SetValue(cszEntrySignupURL, szConvertURL);
        reg.SetValue(cszEntryConnectoidName, szConnectoidName);
        
        // See if we have to create an ISP file        
        if (GetPrivateProfileString(cszTrialRemindSection,
                                    cszEntryExpiredISPFileName,
                                    cszNull,
                                    szISPFile,
                                    MAX_PATH,
                                    lpszFile) != 0)
        {
    
            // Set the fully qualified path for the ISP file name
            wsprintf(szExpiredISPFileName,TEXT("%s\\%s"),g_pszAppDir,szISPFile);
            
            if (GetPrivateProfileString(cszTrialRemindSection,
                                        cszSignupExpiredISPURL,
                                        cszNull,
                                        szExpiredISPFileURL,
                                        INTERNET_MAX_URL_LENGTH,
                                        lpszFile) != 0)
            {
                
                // Download the ISP file, and then copy its contents
                IWebGate    *pWebGate;
                CComBSTR    bstrURL;
                CComBSTR    bstrFname;
                BOOL        bRetVal;
                
                if (SUCCEEDED(CoCreateInstance (CLSID_WebGate, 
                                         NULL, 
                                         CLSCTX_INPROC_SERVER,
                                         IID_IWebGate, 
                                         (void **)&pWebGate)))
                {
                    // Setup the webGate object, and download the ISP file
                    bstrURL = A2BSTR(szExpiredISPFileURL);
                    pWebGate->put_Path(bstrURL);
                    pWebGate->FetchPage(1, 1, &bRetVal);
                    if (bRetVal)
                    {
                        pWebGate->get_DownloadFname(&bstrFname);                                
                
                        // Copy the file from the temp location, making sure one does not
                        // yet exist
                        DeleteFile(szExpiredISPFileName);
                        MoveFile(OLE2A(bstrFname), szExpiredISPFileName);
                    
                        // Write the new file to the registry
                        reg.SetValue(cszEntrySignupURLTrialOver, szExpiredISPFileName);
                    }                                
                    pWebGate->Release();
                }                    
            }                
        }        
    }
    
    return TRUE;
    
}

DWORD CINSHandler::ImportBrandingInfo
(
    LPCTSTR lpszFile,
    LPCTSTR lpszConnectoidName
)
{
    TCHAR szPath[_MAX_PATH + 1];
    Assert(m_lpfnBrandICW != NULL);

    GetWindowsDirectory(szPath, sizeof(szPath));

#ifdef WIN32
#ifdef UNICODE
    CHAR szEntry[RAS_MaxEntryName];
    CHAR szFile[_MAX_PATH + 1];
    CHAR szAsiPath[_MAX_PATH + 1];

    WideCharToMultiByte(CP_ACP, 0, lpszFile, -1, szFile, _MAX_PATH + 1, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, szPath, -1, szAsiPath, _MAX_PATH + 1, NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, lpszConnectoidName, -1, szEntry, RAS_MaxEntryName, NULL, NULL);
    m_lpfnBrandICW(szFile, szAsiPath, m_dwBrandFlags, szEntry);


#else
    m_lpfnBrandICW(lpszFile, szPath, m_dwBrandFlags, lpszConnectoidName);
#endif
#endif

    return ERROR_SUCCESS;
}


DWORD CINSHandler::ReadClientInfo
(
    LPCTSTR lpszFile, 
    LPINETCLIENTINFO lpClientInfo, 
    LPCLIENT_TABLE lpClientTable
)
{
    LPCLIENT_TABLE lpTable;

    for (lpTable = lpClientTable; NULL != lpTable->lpszSection; ++lpTable)
    {
        GetPrivateProfileString(lpTable->lpszSection,
                lpTable->lpszValue,
                cszNull,
                (LPTSTR)((LPBYTE)lpClientInfo + lpTable->uOffset),
                lpTable->uSize / sizeof(TCHAR),
                lpszFile);
    }

    lpClientInfo->dwFlags = 0;
    if (*lpClientInfo->szPOPLogonName)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }
    if ((*lpClientInfo->szNNTPLogonName) || (*lpClientInfo->szNNTPServer))
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    return ERROR_SUCCESS;
}

BOOL CINSHandler::WantsExchangeInstalled(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszEMailSection,
            cszUseExchange,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

BOOL CINSHandler::DisplayPassword(LPCTSTR lpszFile)
{
    TCHAR szTemp[10];

    GetPrivateProfileString(cszUserSection,
            cszDisplayPassword,
            cszNo,
            szTemp,
            10,
            lpszFile);

    return (!lstrcmpi(szTemp, cszYes));
}

DWORD CINSHandler::ImportClientInfo
(
    LPCTSTR lpszFile,
    LPINETCLIENTINFO lpClientInfo
)
{
    DWORD dwRet;

    lpClientInfo->dwSize = sizeof(INETCLIENTINFO);

    dwRet = ReadClientInfo(lpszFile, lpClientInfo, iniTable);

    return dwRet;
}

DWORD CINSHandler::ConfigureClient
(
    HWND hwnd,
    LPCTSTR lpszFile,
    LPBOOL lpfNeedsRestart,
    LPBOOL lpfConnectoidCreated,
    BOOL fHookAutodial,
    LPTSTR szConnectoidName,
    DWORD dwConnectoidNameSize   
)
{
    LPICONNECTION       pConn;
    LPINETCLIENTINFO    pClientInfo = NULL;
    DWORD               dwRet = ERROR_SUCCESS;
    UINT                cb = sizeof(ICONNECTION) + sizeof(INETCLIENTINFO);
    DWORD               dwfOptions = INETCFG_INSTALLTCP | INETCFG_WARNIFSHARINGBOUND;
    LPRASENTRY          pRasEntry = NULL;

    //
    // ChrisK Olympus 4756 5/25/97
    // Do not display busy animation on Win95
    //
    if (!m_bSilentMode && IsNT())
    {
        dwfOptions |=  INETCFG_SHOWBUSYANIMATION;
    }

    // Allocate a buffer for connection and clientinfo objects
    //
    if ((pConn = (LPICONNECTION)LocalAlloc(LPTR, cb)) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    if (WantsExchangeInstalled(lpszFile))
    {
        dwfOptions |= INETCFG_INSTALLMAIL;
    }

    // Create either a CM profile, or a connectoid
    if (CallCMConfig(lpszFile))
    {
        *lpfConnectoidCreated = TRUE;       // A dialup connection was created
    }
    else
    {
        dwRet = ImportConnection(lpszFile, pConn);
        if (ERROR_SUCCESS == dwRet)
        {
            pRasEntry = &pConn->RasEntry;
            dwfOptions |= INETCFG_SETASAUTODIAL |
                        INETCFG_INSTALLRNA |
                        INETCFG_INSTALLMODEM;
        }
        else if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY != dwRet)
        {
            return dwRet;
        }

        if (!m_bSilentMode && DisplayPassword(lpszFile))
        {
            if (*pConn->szPassword || *pConn->szUserName)
            {
                TCHAR szFmt[1024];
                TCHAR szMsg[1024];

                LoadString(_Module.GetModuleInstance(), IDS_PASSWORD, szFmt, 1024);
                wsprintf(szMsg, szFmt, pConn->szUserName, pConn->szPassword);

                ::MessageBox(hwnd, szMsg, GetSz(IDS_TITLE), MB_ICONINFORMATION | MB_OK);
            }
        }

        if (fHookAutodial &&
            ((0 == *pConn->RasEntry.szAutodialDll) ||
             (0 == *pConn->RasEntry.szAutodialFunc)))
        {
            lstrcpy(pConn->RasEntry.szAutodialDll, TEXT("isign32.dll"));
            lstrcpy(pConn->RasEntry.szAutodialFunc, TEXT("AutoDialLogon"));
        }
     
        // humongous hack for ISBU
        Assert(m_lpfnInetConfigClient);
        Assert(m_lpfnInetGetAutodial);

        dwRet = m_lpfnInetConfigClient(hwnd,
                                     NULL,
                                     pConn->szEntryName,
                                     pRasEntry,
                                     pConn->szUserName,
                                     pConn->szPassword,
                                     NULL,
                                     NULL,
                                     dwfOptions & ~INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart);
        lstrcpy(szConnectoidName, pConn->szEntryName);

        LclSetEntryScriptPatch(pRasEntry->szScript,pConn->szEntryName);
        BOOL fEnabled = TRUE;
        DWORD dwResult = 0xba;
        dwResult = m_lpfnInetGetAutodial(&fEnabled, pConn->szEntryName, RAS_MaxEntryName);
        if ((ERROR_SUCCESS == dwRet) && lstrlen(pConn->szEntryName))
        {
            *lpfConnectoidCreated = (NULL != pRasEntry);
            PopulateNTAutodialAddress( lpszFile, pConn->szEntryName );
        }
        else
        {
            TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: ERROR: InetGetAutodial failed, will not be able to set NT Autodial\n"));
        }
    }

    // If we were successfull in creating the connectio, then see if the user wants a 
    // mail client installed       
    if (ERROR_SUCCESS == dwRet)
    {
        // Get the mail client info
        INETCLIENTINFO pClientInfo;

        ImportClientInfo(lpszFile, &pClientInfo);
    
        // use inet config to install the mail client
        dwRet = m_lpfnInetConfigClient(hwnd,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL,
                                     &pClientInfo, 
                                     dwfOptions & INETCFG_INSTALLMAIL,
                                     lpfNeedsRestart);
    }

    // cleanup
    LocalFree(pConn);
    return dwRet;
 }


//+----------------------------------------------------------------------------
//
//    Function:    PopulateNTAutodialAddress
//
//    Synopsis:    Take Internet addresses from INS file and load them into the
//                autodial database
//
//    Arguments:    pszFileName - pointer to INS file name
//
//    Returns:    Error code (ERROR_SUCCESS == success)
//
//    History:    8/29/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#define AUTODIAL_ADDRESS_BUFFER_SIZE 2048
#define AUTODIAL_ADDRESS_SECTION_NAME TEXT("Autodial_Addresses_for_NT")
HRESULT CINSHandler::PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName)
{
    HRESULT hr = ERROR_SUCCESS;
    LONG lRC = 0;
    LPLINETRANSLATECAPS lpcap = NULL;
    LPLINETRANSLATECAPS lpTemp = NULL;
    LPLINELOCATIONENTRY lpLE = NULL;
    LPRASAUTODIALENTRY rADE;
    INT idx = 0;
    LPTSTR lpszBuffer = NULL;
    LPTSTR lpszNextAddress = NULL;
    rADE = NULL;

    Assert(m_lpfnRasSetAutodialEnable);
    Assert(m_lpfnRasSetAutodialAddress);

    //RNAAPI *pRnaapi = NULL;

    // jmazner  10/8/96  this function is NT specific
    if( !IsNT() )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: Bypassing PopulateNTAutodialAddress for win95.\r\n"));
        return( ERROR_SUCCESS );
    }

    //Assert(pszFileName && pszEntryName);
    //dprintf("ISIGNUP: PopulateNTAutodialAddress "%s %s.\r\n",pszFileName, pszEntryName);
    TraceMsg(TF_INSHANDLER, pszFileName);
    TraceMsg(TF_INSHANDLER, TEXT(", "));
    TraceMsg(TF_INSHANDLER, pszEntryName);
    TraceMsg(TF_INSHANDLER, TEXT(".\r\n"));

    //
    // Get list of TAPI locations
    //
    lpcap = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
    if (!lpcap)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }
    lpcap->dwTotalSize = sizeof(LINETRANSLATECAPS);
    lRC = lineGetTranslateCaps(0,0x10004,lpcap);
    if (SUCCESS == lRC)
    {
        lpTemp = (LPLINETRANSLATECAPS)GlobalAlloc(GPTR,lpcap->dwNeededSize);
        if (!lpTemp)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto PopulateNTAutodialAddressExit;
        }
        lpTemp->dwTotalSize = lpcap->dwNeededSize;
        GlobalFree(lpcap);
        lpcap = (LPLINETRANSLATECAPS)lpTemp;
        lpTemp = NULL;
        lRC = lineGetTranslateCaps(0,0x10004,lpcap);
    }

    if (SUCCESS != lRC)
    {
        hr = (HRESULT)lRC; // REVIEW: not real sure about this.
        goto PopulateNTAutodialAddressExit;
    }

    //
    // Create an array of RASAUTODIALENTRY structs
    //
    rADE = (LPRASAUTODIALENTRY)GlobalAlloc(GPTR,
        sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations);
    if (!rADE)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }
    

    //
    // Enable autodialing for all locations
    //
    idx = lpcap->dwNumLocations;
    lpLE = (LPLINELOCATIONENTRY)((DWORD_PTR)lpcap + (DWORD)lpcap->dwLocationListOffset);
    while (idx)
    {
        idx--;
        m_lpfnRasSetAutodialEnable(lpLE[idx].dwPermanentLocationID,TRUE);

        //
        // fill in array values
        //
        rADE[idx].dwSize = sizeof(RASAUTODIALENTRY);
        rADE[idx].dwDialingLocation = lpLE[idx].dwPermanentLocationID;
        lstrcpyn(rADE[idx].szEntry,pszEntryName,RAS_MaxEntryName);
    }

    //
    // Get list of addresses
    //
    lpszBuffer = (LPTSTR)GlobalAlloc(GPTR,AUTODIAL_ADDRESS_BUFFER_SIZE);
    if (!lpszBuffer)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }

    if((AUTODIAL_ADDRESS_BUFFER_SIZE-2) == GetPrivateProfileSection(AUTODIAL_ADDRESS_SECTION_NAME,
        lpszBuffer,AUTODIAL_ADDRESS_BUFFER_SIZE,pszFileName))
    {
        //AssertSz(0,"Autodial address section bigger than buffer.\r\n");
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto PopulateNTAutodialAddressExit;
    }

    //
    // Walk list of addresses and set autodialing for each one
    //
    lpszNextAddress = lpszBuffer;
    do
    {
        lpszNextAddress = MoveToNextAddress(lpszNextAddress);
        if (!(*lpszNextAddress))
            break;    // do-while
        m_lpfnRasSetAutodialAddress(lpszNextAddress,0,rADE,
            sizeof(RASAUTODIALENTRY)*lpcap->dwNumLocations,lpcap->dwNumLocations);
        lpszNextAddress = lpszNextAddress + lstrlen(lpszNextAddress);
    } while(1);

PopulateNTAutodialAddressExit:
    if (lpcap) 
        GlobalFree(lpcap);
    lpcap = NULL;
    if (rADE)
        GlobalFree(rADE);
    rADE = NULL;
    if (lpszBuffer)
        GlobalFree(lpszBuffer);
    lpszBuffer = NULL;
    //if( pRnaapi )
    //    delete pRnaapi;
    //pRnaapi = NULL;
    return hr;
}



//+----------------------------------------------------------------------------
//
//    Function:    MoveToNextAddress
//
//    Synopsis:    Given a pointer into the data bufffer, this function will move
//                through the buffer until it points to the begining of the next
//                address or it reaches the end of the buffer.
//
//    Arguements:    lpsz - pointer into buffer
//
//    Returns:    Pointer to the next address, return value will point to NULL
//                if there are no more addresses
//
//    History:    8/29/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
LPTSTR CINSHandler::MoveToNextAddress(LPTSTR lpsz)
{
    BOOL fLastCharWasNULL = FALSE;

    //AssertSz(lpsz,"MoveToNextAddress: NULL input\r\n");

    //
    // Look for an = sign
    //
    do
    {
        if (fLastCharWasNULL && '\0' == *lpsz)
            break; // are we at the end of the data?

        if ('\0' == *lpsz)
            fLastCharWasNULL = TRUE;
        else
            fLastCharWasNULL = FALSE;

        if ('=' == *lpsz)
            break;

        if (*lpsz)
            lpsz = CharNext(lpsz);
        else
            lpsz += sizeof(TCHAR);
    } while (1);
    
    //
    // Move to the first character beyond the = sign.
    //
    if (*lpsz)
        lpsz = CharNext(lpsz);

    return lpsz;
}


//+----------------------------------------------------------------------------
//
//    Function:    ImportCustomDialer
//
//    Synopsis:    Import custom dialer information from the specified file
//                and save the information in the RASENTRY
//
//    Arguments:    lpRasEntry - pointer to a valid RASENTRY structure
//                szFileName - text file (in .ini file format) containing the
//                Custom Dialer information
//
//    Returns:    ERROR_SUCCESS - success otherwise a Win32 error
//
//    History:    ChrisK    Created        7/11/96
//            8/12/96    ChrisK    Ported from \\trango
//
//-----------------------------------------------------------------------------
DWORD CINSHandler::ImportCustomDialer(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{

    // If there is an error reading the information from the file, or the entry
    // missing or blank, the default value (cszNull) will be used.
    GetPrivateProfileString(cszCustomDialerSection,
                            cszAutoDialDLL,
                            cszNull,
                            lpRasEntry->szAutodialDll,
                            MAX_PATH,
                            szFileName);

    GetPrivateProfileString(cszCustomDialerSection,
                            cszAutoDialFunc,
                            cszNull,
                            lpRasEntry->szAutodialFunc,
                            MAX_PATH,
                            szFileName);

    return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL StrToip (LPTSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//****************************************************************************
LPCTSTR CINSHandler::StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal)
{
    LPCTSTR  pszIP = szIPAddress;
    BYTE    val = 0;

    // skip separators (non digits)
    while (*pszIP && !myisdigit(*pszIP))
    {
          ++pszIP;
    }

    while (myisdigit(*pszIP))
    {
        val = (val * 10) + (BYTE)(*pszIP - '0');
        ++pszIP;
    }
   
    *pVal = val;

    return pszIP;
}


DWORD CINSHandler::StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr)
{
    LPCTSTR pszIP = szIPAddress;

    pszIP = StrToSubip(pszIP, &ipAddr->a);
    pszIP = StrToSubip(pszIP, &ipAddr->b);
    pszIP = StrToSubip(pszIP, &ipAddr->c);
    pszIP = StrToSubip(pszIP, &ipAddr->d);

    return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCTSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
    TCHAR   szYesNo[MAXNAME];

    if (GetPrivateProfileString(cszPhoneSection,
                               cszPhone,
                               cszNull,
                               lpRasEntry->szLocalPhoneNumber,
                               RAS_MaxPhoneNumber,
                               szFileName) == 0)
    {
        return ERROR_BAD_PHONE_NUMBER;
    }

    lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

    GetPrivateProfileString(cszPhoneSection,
                            cszDialAsIs,
                            cszNo,
                            szYesNo,
                            MAXNAME,
                            szFileName);

    // Do we have to get country code and area code?
    if (!lstrcmpi(szYesNo, cszNo))
    {

        // If we cannot get the country ID or it is zero, default to dial as is
        //
        if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
        {
            lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

            GetPrivateProfileString(cszPhoneSection,
                                      cszAreaCode,
                                      cszNull,
                                      lpRasEntry->szAreaCode,
                                      RAS_MaxAreaCode,
                                      szFileName);

            lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

        }
  }
  else
  {
      // bug in RasSetEntryProperties still checks area codes
      // even when RASEO_UseCountryAndAreaCodes is not set
      lstrcpy(lpRasEntry->szAreaCode, TEXT("805"));
      lpRasEntry->dwCountryID = 1;
      lpRasEntry->dwCountryCode = 1;
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPTSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
    TCHAR   szYesNo[MAXNAME];
    TCHAR   szType[MAXNAME];
    DWORD  i;

    // Get the server type name
    GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          cszNull,
                          szType,
                          MAXNAME,
                          szFileName);

    // need to convert the string into
    // one of the following values
    //   RASFP_Ppp
    //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
    //   RASFP_Ras

    for (i = 0; i < NUM_SERVER_TYPES; ++i)
    {
        if (!lstrcmpi(aServerTypes[i].szType, szType))
        {
            lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
            lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
            break;
        }
    }

    // Get the server type settings
    if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_SwCompression;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              cszNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {   
            lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
        }
    }

    // Get the protocol settings
    if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
        }
        else
        {
            lpRasEntry->dwfNetProtocols |= RASNP_Ip;
        }
    }

    if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
                              cszNull,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
        }
    }

    return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPTSTR szEntryName, LPTSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName)
{
    TCHAR   szIPAddr[MAXIPADDRLEN];
    TCHAR   szYesNo[MAXNAME];

    // Import IP address information
    if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            // The import file has IP address specified, get the IP address
            lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
            if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddr);
            }
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
        }
    }

    // Import Server address information
    if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              cszNo,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszYes))
        {
            // The import file has server address specified, get the server address
            lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
            if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
            }

            if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  cszNull,
                                  szIPAddr,
                                  MAXIPADDRLEN,
                                  szFileName))
            {
                StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
            }
        }
        else
        {
            lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
        }
    }

    // Header compression and the gateway settings
    if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
            lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
        }
        else
        {
            lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        }
    }

    if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              cszYes,
                              szYesNo,
                              MAXNAME,
                              szFileName))
    {
        if (!lstrcmpi(szYesNo, cszNo))
        {
          lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
        }
        else
        {
          lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
        }
    }
    return ERROR_SUCCESS;
}

DWORD CINSHandler::ImportScriptFile(
    LPCTSTR lpszImportFile,
    LPTSTR szScriptFile,
    UINT cbScriptFile)
{
    TCHAR szTemp[_MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;
    
    // Get the script filename
    //
    if (GetPrivateProfileString(cszScriptingSection,
                                cszScriptName,
                                cszNull,
                                szTemp,
                                _MAX_PATH,
                                lpszImportFile) != 0)
    {
 
//!!! commonize this code
//!!! make it DBCS compatible
//!!! check for overruns
//!!! check for absolute path name
        GetWindowsDirectory(szScriptFile, cbScriptFile);
        if (*CharPrev(szScriptFile, szScriptFile + lstrlen(szScriptFile)) != '\\')
        {
            lstrcat(szScriptFile, TEXT("\\"));
        }
        lstrcat(szScriptFile, szTemp);
  
        dwRet =ImportFile(lpszImportFile, cszScriptSection, szScriptFile);
    }

    return dwRet;
}
 
//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPTSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::RnaValidateImportEntry (LPCTSTR szFileName)
{
    TCHAR  szTmp[MAX_PATH+1];

    // Get the alias entry name
    //
    // 12/4/96    jmazner    Normandy #12373
    // If no such key, don't return ERROR_INVALID_PHONEBOOK_ENTRY,
    // since ConfigureClient always ignores that error code.

    return (GetPrivateProfileString(cszEntrySection,
                                  cszEntryName,
                                  cszNull,
                                  szTmp,
                                  MAX_PATH,
                                  szFileName) > 0 ?
            ERROR_SUCCESS : ERROR_UNKNOWN);
}

//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportRasEntry (LPCTSTR szFileName, LPRASENTRY lpRasEntry)
{
    DWORD         dwRet;

    dwRet = ImportPhoneInfo(lpRasEntry, szFileName);
    if (ERROR_SUCCESS == dwRet)
    {
        // Get device type
        //
        GetPrivateProfileString(cszDeviceSection,
                              cszDeviceType,
                              cszNull,
                              lpRasEntry->szDeviceType,
                              RAS_MaxDeviceType,
                              szFileName);
        
        // Get Server Type settings
        //
        dwRet = ImportServerInfo(lpRasEntry, szFileName);
        if (ERROR_SUCCESS == dwRet)
        {
            // Get IP address
            //
            dwRet = ImportIPInfo(lpRasEntry, szFileName);
        }
    }

    return dwRet;
}


//****************************************************************************
// DWORD WINAPI RnaImportEntry (LPTSTR, LPBYTE, DWORD)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CINSHandler::ImportConnection (LPCTSTR szFileName, LPICONNECTION lpConn)
{
    DWORD   dwRet;

    lpConn->RasEntry.dwSize = sizeof(RASENTRY);

    dwRet = RnaValidateImportEntry(szFileName);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    GetPrivateProfileString(cszEntrySection,
                          cszEntryName,
                          cszNull,
                          lpConn->szEntryName,
                          RAS_MaxEntryName,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          cszNull,
                          lpConn->szUserName,
                          UNLEN,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          cszNull,
                          lpConn->szPassword,
                          PWLEN,
                          szFileName);
  
    dwRet = ImportRasEntry(szFileName, &lpConn->RasEntry);
    if (ERROR_SUCCESS == dwRet)
    {
        dwRet = ImportCustomDialer(&lpConn->RasEntry, szFileName);
    }

    if (ERROR_SUCCESS == dwRet)
    {
        // Import the script file
        //
        dwRet = ImportScriptFile(szFileName,
                                 lpConn->RasEntry.szScript,
                                 sizeof(lpConn->RasEntry.szScript)/sizeof(TCHAR));
    }

    // Use an ISPImport object to Config The ras device
    CISPImport  ISPImport;

    ISPImport.set_hWndMain(GetActiveWindow());
    dwRet = ISPImport.ConfigRasEntryDevice(&lpConn->RasEntry);
    switch( dwRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_CANCELLED:
            if(!m_bSilentMode)
                InfoMsg1(NULL, IDS_SIGNUPCANCELLED, NULL);
            // Fall through
        default:
            goto ImportConnectionExit;
    }

ImportConnectionExit:
    return dwRet;
}

// Prototype for acct manager entry point we want
typedef HRESULT (WINAPI *PFNCREATEACCOUNTSFROMFILEEX)(LPTSTR szFile, CONNECTINFO *pCI, DWORD dwFlags);

// Regkeys for Acct manager
#define ACCTMGR_PATHKEY TEXT("SOFTWARE\\Microsoft\\Internet Account Manager")
#define ACCTMGR_DLLPATH TEXT("DllPath")


// ############################################################################
//
//    Name:    ImportMailAndNewsInfo
//
//    Description:    Import information from INS file and set the associated
//                        registry keys for Internet Mail and News (Athena)
//
//    Input:    lpszFile - Fully qualified filename of INS file
//
//    Return:    Error value
//
//    History:        6/27/96            Created
//
// ############################################################################
DWORD CINSHandler::ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone)
{
    DWORD dwRet = ERROR_SUCCESS;
    
    TCHAR szAcctMgrPath[MAX_PATH + 1] = TEXT("");
    TCHAR szExpandedPath[MAX_PATH + 1] = TEXT("");
    DWORD dwAcctMgrPathSize = 0;
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    HINSTANCE hInst = NULL;
    CONNECTINFO connectInfo;
    TCHAR szConnectoidName[RAS_MaxEntryName] = TEXT("nogood\0");
    PFNCREATEACCOUNTSFROMFILEEX fp = NULL;


    // get path to the AcctMgr dll
    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ACCTMGR_PATHKEY,0, KEY_READ, &hKey);
    if ( (dwRet != ERROR_SUCCESS) || (NULL == hKey) )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo couldn't open reg key %s\n"), ACCTMGR_PATHKEY);
        return( dwRet );
    }

    dwAcctMgrPathSize = sizeof (szAcctMgrPath);
    dwRet = RegQueryValueEx(hKey, ACCTMGR_DLLPATH, NULL, NULL, (LPBYTE) szAcctMgrPath, &dwAcctMgrPathSize);
    

    RegCloseKey( hKey );
    
    if ( dwRet != ERROR_SUCCESS )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: RegQuery failed with error %d\n"), dwRet);
        return( dwRet );
    }

    // 6/18/97 jmazner Olympus #6819
    TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: read in DllPath of %s\n"), szAcctMgrPath);
    ExpandEnvironmentStrings( szAcctMgrPath, szExpandedPath, sizeof(szExpandedPath) );

    //
    // 6/4/97 jmazner
    // if we created a connectoid, then get its name and use that as the
    // connection type.  Otherwise, assume we're supposed to connect via LAN
    //
    connectInfo.cbSize = sizeof(CONNECTINFO);
    connectInfo.type = CONNECT_LAN;

    if( fConnectPhone && m_lpfnInetGetAutodial )
    {
        BOOL fEnabled = FALSE;

        dwRet = m_lpfnInetGetAutodial(&fEnabled,szConnectoidName,RAS_MaxEntryName);

        if( ERROR_SUCCESS==dwRet && szConnectoidName[0] )
        {
            connectInfo.type = CONNECT_RAS;
#ifdef UNICODE
            wcstombs(connectInfo.szConnectoid, szConnectoidName, MAX_PATH);
#else
            lstrcpyn( connectInfo.szConnectoid, szConnectoidName, sizeof(connectInfo.szConnectoid) );
#endif
            TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: setting connection type to RAS with %s\n"), szConnectoidName);
        }
    }

    if( CONNECT_LAN == connectInfo.type )
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo: setting connection type to LAN\n"));
#ifdef UNICODE
        wcstombs(connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!"), MAX_PATH);
#else
        lstrcpy( connectInfo.szConnectoid, TEXT("I said CONNECT_LAN!") );
#endif
    }



    hInst = LoadLibrary(szExpandedPath);
    if (hInst)
    {
        fp = (PFNCREATEACCOUNTSFROMFILEEX) GetProcAddress(hInst,"CreateAccountsFromFileEx");
        if (fp)
            hr = fp( (TCHAR *)lpszFile, &connectInfo, NULL );
    }
    else
    {
        TraceMsg(TF_INSHANDLER, TEXT("ImportMailAndNewsInfo unable to LoadLibrary on %s\n"), szAcctMgrPath);
    }

    //
    // Clean up and release resourecs
    //
    if( hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    if( fp )
    {
        fp = NULL;
    }

    return dwRet;
}

// ############################################################################
//
//    Name:    WriteMailAndNewsKey
//
//    Description:    Read a string value from the given INS file and write it
//                    to the registry
//
//    Input:    hKey - Registry key where the data will be written
//            lpszSection - Section name inside of INS file where data is read
//                from
//            lpszValue -    Name of value to read from INS file
//            lpszBuff - buffer where data will be read into
//            dwBuffLen - size of lpszBuff
//            lpszSubKey - Value name where information will be written to
//            dwType - data type (Should always be REG_SZ)
//            lpszFileName - Fully qualified filename to INS file
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
HRESULT CINSHandler::WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue,
                            LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey,
                            DWORD dwType, LPCTSTR lpszFile)
{
    ZeroMemory(lpszBuff,dwBuffLen);
    GetPrivateProfileString(lpszSection,lpszValue,TEXT(""),lpszBuff,dwBuffLen,lpszFile);
    if (lstrlen(lpszBuff))
    {
        return RegSetValueEx(hKey,lpszSubKey,0,dwType,(CONST BYTE*)lpszBuff,
            sizeof(TCHAR)*(lstrlen(lpszBuff)+1));
    }
    else
    {
        TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: WriteMailAndNewsKey, missing value in INS file\n"));
        return ERROR_NO_MORE_ITEMS;
    }
}


// ############################################################################
//
//    Name:    PreparePassword
//
//    Description:    Encode given password and return value in place.  The
//                    encoding is done right to left in order to avoid having
//                    to allocate a copy of the data.  The encoding uses base64
//                    standard as specified in RFC 1341 5.2
//
//    Input:    szBuff - Null terminated data to be encoded
//            dwBuffLen - Full length of buffer, this should exceed the length of
//                the input data by at least 1/3
//
//    Return:    Error value
//
//    Histroy:        6/27/96            Created
//
// ############################################################################
HRESULT CINSHandler::PreparePassword(LPTSTR szBuff, DWORD dwBuffLen)
{
    DWORD   dwX;
    LPTSTR   szOut = NULL;
    LPTSTR   szNext = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BYTE    bTemp = 0;
    DWORD   dwLen = 0;

    dwLen = lstrlen(szBuff);
    if (!dwLen)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    // Calculate the size of the buffer that will be needed to hold
    // encoded data
    //

    szNext = &szBuff[dwLen-1];
    dwLen = (((dwLen % 3 ? (3-(dwLen%3)):0) + dwLen) * 4 / 3);

    if (dwBuffLen < dwLen+1)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto PreparePasswordExit;
    }

    szOut = &szBuff[dwLen];
    *szOut-- = '\0';

    // Add padding = characters
    //

    switch (lstrlen(szBuff) % 3)
    {
    case 0:
        // no padding
        break;
    case 1:
        *szOut-- = 64;
        *szOut-- = 64;
        *szOut-- = (*szNext & 0x3) << 4;
        *szOut-- = (*szNext-- & 0xFC) >> 2;
        break;
    case 2:
        *szOut-- = 64;
        *szOut-- = (*szNext & 0xF) << 2;
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Encrypt data into indicies
    //

    while (szOut > szNext && szNext >= szBuff)
    {
        *szOut-- = *szNext & 0x3F;
        *szOut = ((*szNext-- & 0xC0) >> 6);
        *szOut-- |= ((*szNext & 0xF) << 2);
        *szOut = ((*szNext-- & 0xF0) >> 4);
        *szOut-- |= ((*szNext & 0x3) << 4);
        *szOut-- = (*szNext-- & 0xFC) >> 2;
    }

    // Translate indicies into printable characters
    //

    szNext = szBuff;

    // BUG OSR#10435--if there is a 0 in the generated string of base-64 
    // encoded digits (this can happen if the password is "Willypassword"
    // for example), then instead of encoding the 0 to 'A', we just quit
    // at this point, produces an invalid base-64 string.
    
    for(dwX=0; dwX < dwLen; dwX++)
        *szNext = arBase64[*szNext++];

PreparePasswordExit:
    return hr;
}

// ############################################################################
//
//    Name: FIsAthenaPresent
//
//    Description:    Determine if Microsoft Internet Mail And News client (Athena)
//                    is installed
//
//    Input:    none
//
//    Return:    TRUE - Athena is installed
//            FALSE - Athena is NOT installed
//
//    History:        7/1/96            Created
//
// ############################################################################
BOOL CINSHandler::FIsAthenaPresent()
{
    TCHAR       szBuff[MAX_PATH + 1];
    HRESULT     hr = ERROR_SUCCESS;
    HINSTANCE   hInst = NULL;
    DWORD       dwLen = 0;
    DWORD       dwType = REG_SZ;
    // Get path to Athena client
    //

    dwLen = sizeof(TCHAR)*MAX_PATH;
    hr = RegQueryValueEx(HKEY_CLASSES_ROOT,
                         MAIL_NEWS_INPROC_SERVER32,
                         NULL,
                         &dwType,
                         (LPBYTE) szBuff,
                         &dwLen);
    if (hr == ERROR_SUCCESS)
    {
        // Attempt to load client
        //

        hInst = LoadLibrary(szBuff);
        if (!hInst)
        {
            TraceMsg(TF_INSHANDLER, TEXT("ISIGNUP: Internet Mail and News server didn't load.\n"));
            hr = ERROR_FILE_NOT_FOUND;
        } 
        else 
        {
            FreeLibrary(hInst);
        }
        hInst = NULL;
    }

    return (hr == ERROR_SUCCESS);
}

// ############################################################################
//
//    Name:    FTurnOffBrowserDefaultChecking
//
//    Description:    Turn Off IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
BOOL CINSHandler::FTurnOffBrowserDefaultChecking()
{
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    BOOL bRC = TRUE;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Read current settings for check associations
    //
    dwType = 0;
    dwSize = sizeof(m_szCheckAssociations);
    ZeroMemory(m_szCheckAssociations,dwSize);
    RegQueryValueEx(hKey,
                    cszDEFAULT_BROWSER_VALUE,
                    0,
                    &dwType,
                    (LPBYTE)m_szCheckAssociations,
                    &dwSize);
    // ignore return value, even if the calls fails we are going to try
    // to change the setting to "NO"
    
    //
    // Set value to "no" to turn off checking
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)cszNo,
                      sizeof(TCHAR)*(lstrlen(cszNo)+1)))
    {
        bRC = FALSE;
        goto FTurnOffBrowserDefaultCheckingExit;
    }

    //
    // Clean up and return
    //
FTurnOffBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    if (bRC)
        m_fResforeDefCheck = TRUE;
    hKey = NULL;
    return bRC;
}

// ############################################################################
//
//    Name:    FRestoreBrowserDefaultChecking
//
//    Description:    Restore IE checking to see if it is the default browser
//
//    Input:    none
//
//    Output:    TRUE - success
//            FALSE - failed
//
//    History:        7/2/96            Created
//
// ############################################################################
BOOL CINSHandler::FRestoreBrowserDefaultChecking()
{
    HKEY hKey = NULL;
    BOOL bRC = TRUE;

    //
    // Open IE settings registry key
    //
    if (RegOpenKey(HKEY_CURRENT_USER,cszDEFAULT_BROWSER_KEY,&hKey))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

    //
    // Set value to original value
    //
    if (RegSetValueEx(hKey,
                      cszDEFAULT_BROWSER_VALUE,
                      0,
                      REG_SZ,
                      (LPBYTE)m_szCheckAssociations,
                      sizeof(TCHAR)*(lstrlen(m_szCheckAssociations)+1)))
    {
        bRC = FALSE;
        goto FRestoreBrowserDefaultCheckingExit;
    }

FRestoreBrowserDefaultCheckingExit:
    if (hKey)
        RegCloseKey(hKey);
    hKey = NULL;
    return bRC;
}



// This is the main entry point for processing an INS file.
// DJM: BUGBUG: TODO: Need to pass in branding flags
STDMETHODIMP CINSHandler::ProcessINS(BSTR bstrINSFilePath, BOOL * pbRetVal)
{
    USES_CONVERSION;

    BOOL        fConnectoidCreated = FALSE;
    BOOL        fClientSetup       = FALSE;
    BOOL        bKeepConnection    = FALSE;
    BOOL        fErrMsgShown       = FALSE;
    HRESULT     hr                 = E_FAIL;
    LPTSTR       lpszFile           = NULL;
    LPRASENTRY  lpRasEntry         = NULL;
    TCHAR        szTemp[3]          = TEXT("\0");
    TCHAR        szConnectoidName[RAS_MaxEntryName*2] = TEXT("");
    
    *pbRetVal = FALSE;

    // The Connection has not been killed yet
    m_fConnectionKilled = FALSE;
    m_fNeedsRestart = FALSE;

    Assert(bstrINSFilePath);

    lpszFile = OLE2A(bstrINSFilePath);
    do 
    {
        // Make sure we can load the necessary extern support functions
        if (!LoadExternalFunctions())
            break;

        // Convert EOL chars in the passed file.
        if (FAILED(MassageFile(lpszFile)))
        {
            if(!m_bSilentMode)
                ErrorMsg1(GetActiveWindow(), IDS_CANNOTPROCESSINS, NULL);
            break;
        }
        if(GetPrivateProfileString(cszURLSection,
                                    cszStartURL,
                                    szNull,
                                    m_szStartURL,
                                    MAX_PATH + 1,
                                    lpszFile) == 0)
        {
            m_szStartURL[0] = '\0';
        }

        if (GetPrivateProfileString(cszEntrySection,
                                    cszCancel,
                                    szNull,
                                    szTemp,
                                    3,
                                    lpszFile) != 0)
        {
            // We do not want to process a CANCEL.INS file
            // here.
            break;
        }

        // See if this INS has a client setup section
        if (GetPrivateProfileSection(cszClientSetupSection,
                                     szTemp,
                                     3,
                                     lpszFile) != 0)
            fClientSetup = TRUE;
        
        // Process the trial reminder section, if it exists.  this needs to be
        // done BEFORE we allow the connection to be closed
        if (ConfigureTrialReminder(lpszFile))
        {
            // We configured a trial, so we need to launch the remind app now
            SHELLEXECUTEINFO    sei;

            sei.cbSize = sizeof(sei);
            sei.fMask = SEE_MASK_NOCLOSEPROCESS;
            sei.hwnd = NULL;
            sei.lpVerb = cszOpen;
            sei.lpFile = cszReminderApp;
            sei.lpParameters = cszReminderParams;
            sei.lpDirectory = NULL;
            sei.nShow = SW_SHOWNORMAL;
            sei.hInstApp = NULL;
            // Optional members 
            sei.hProcess = NULL;

            ShellExecuteEx(&sei);
        }
        
        // Check to see if we should keep the connection open.  The custom section
        // might want this for processing stuff
        if (!fClientSetup && !KeepConnection(lpszFile))
        {
            Fire_KillConnection();
            m_fConnectionKilled = TRUE;
        }
    
        // Import the Custom Info
        ImportCustomInfo(lpszFile,
                         m_szRunExecutable,
                         MAX_PATH ,
                         m_szRunArgument,
                         MAX_PATH );

        ImportCustomFile(lpszFile);

        // configure the client.  
        hr = ConfigureClient(GetActiveWindow(),
                             lpszFile,
                             &m_fNeedsRestart,
                             &fConnectoidCreated,
                             FALSE,
                             szConnectoidName,
                             RAS_MaxEntryName);
        if( ERROR_SUCCESS != hr )
        {

            if(!m_bSilentMode)
                ErrorMsg1(GetActiveWindow(), IDS_INSTALLFAILED, NULL);
            fErrMsgShown = TRUE;
        }

        // If we created a connectoid, tell the world that ICW
        // has left the building...
        if(!m_bSilentMode)
            SetICWCompleted( (DWORD)1 );

        // Call IEAK branding dll

        ImportBrandingInfo(lpszFile, szConnectoidName);
        //::MessageBox(NULL, TEXT("Step 4"), TEXT("TEST"), MB_OK);

        // 2/19/97 jmazner    Olympus 1106
        // For SBS/SAM integration.
        DWORD dwSBSRet = 0;//CallSBSConfig(GetActiveWindow(), lpszFile);
        switch( dwSBSRet )
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_MOD_NOT_FOUND:
            case ERROR_DLL_NOT_FOUND:
                TraceMsg(TF_INSHANDLER, TEXT("ISIGN32: SBSCFG DLL not found, I guess SAM ain't installed.\n"));
                break;
            default:
                if(!m_bSilentMode)
                    ErrorMsg1(GetActiveWindow(), IDS_SBSCFGERROR, NULL);
        }

        //
        // If the INS file contains the ClientSetup section, build the commandline
        // arguments for ICWCONN2.exe.
        //
        if (fClientSetup)
        {
            // Check to see if a REBOOT is needed and tell the next application to
            // handle it.
            if (m_fNeedsRestart)
            {
                wsprintf(m_szRunArgument,TEXT(" /INS:\"%s\" /REBOOT"),lpszFile);
                m_fNeedsRestart = FALSE;
            }
            else
            {       
                wsprintf(m_szRunArgument,TEXT(" /INS:\"%s\""),lpszFile);
            }
        }
        
        // humongous hack for ISBU
        if (ERROR_SUCCESS != hr && fConnectoidCreated)
        {
            if(!m_bSilentMode)
                InfoMsg1(GetActiveWindow(), IDS_MAILFAILED, NULL);
            hr = ERROR_SUCCESS;
        }

        //
        // Import settings for mail and new read from INS file (ChrisK, 7/1/96)
        //
        if (ERROR_SUCCESS == hr)
        {

            ImportMailAndNewsInfo(lpszFile, fConnectoidCreated);

            // If we did not create a connectiod, then restore
            // the autodial one
            if (!fConnectoidCreated)
            {
                RestoreAutoDial();
            }

            // Delete the INS file now
            if (m_szRunExecutable[0] == '\0')
            {
                DeleteFile(lpszFile);
            }
        }
        else
        {
            RestoreAutoDial();
            if( !fErrMsgShown )
                if(!m_bSilentMode)
                    ErrorMsg1(GetActiveWindow(), IDS_BADSETTINGS, NULL);
        }


        if (m_szRunExecutable[0] != '\0')
        {
            // Fire an event to the container telling it that we are
            // about to run a custom executable
            Fire_RunningCustomExecutable();
            if FAILED(RunExecutable())
            {
                if(!m_bSilentMode)
                    ErrorMsg1(NULL, IDS_EXECFAILED, m_szRunExecutable);
            }

            // If the Connection has not been killed yet
            // then tell the browser to do it now
            if (!m_fConnectionKilled)
            {
                Fire_KillConnection();
                m_fConnectionKilled = TRUE;
            }
        }


        // If we get to here, we are successful.
        if(fConnectoidCreated && SUCCEEDED(hr))
            *pbRetVal = TRUE;
        break;

    }   while(1);

    return S_OK;
}

// If this is true, then the user will need to reboot, so
// the finish page should indicate this.
STDMETHODIMP CINSHandler::get_NeedRestart(BOOL *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_fNeedsRestart;
    return S_OK;
}

STDMETHODIMP CINSHandler::put_BrandingFlags(long lFlags)
{
    m_dwBrandFlags = lFlags;
    return S_OK;
}

STDMETHODIMP CINSHandler::put_SilentMode(BOOL bSilent)
{
    m_bSilentMode = bSilent;
    return S_OK;
}

// If this is true, get the URL from the INS file
STDMETHODIMP CINSHandler::get_DefaultURL(BSTR *pszURL)
{
    if (pszURL == NULL)
        return E_POINTER;

    *pszURL = A2BSTR(m_szStartURL);;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\mcreg.cpp ===
#define  STRICT
#include "stdafx.h"

//---------------------------------------------------------------------------

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------------------------
// ctor
//---------------------------------------------------------------------------
CMcRegistry::CMcRegistry()
 :	m_hkey(NULL)
{
}

//---------------------------------------------------------------------------
// dtor
//---------------------------------------------------------------------------
CMcRegistry::~CMcRegistry()
{
	if (m_hkey)
	{
		CloseKey();
	}
}


//---------------------------------------------------------------------------
// OpenKey
//---------------------------------------------------------------------------
bool
CMcRegistry::OpenKey(
	HKEY hkeyStart, LPCTSTR strKey, REGSAM sam /* = KEY_READ | KEY_WRITE */)
{
	long lErr = ::RegOpenKeyEx(hkeyStart, strKey, 0, sam, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CreateKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CreateKey(HKEY hkeyStart, LPCTSTR strKey)
{
	// You shouldn't have opened now.
	if (m_hkey)
	{
		_ASSERT(!m_hkey);
		return false;
	}

	long lErr = ::RegCreateKey(hkeyStart, strKey, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CloseKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CloseKey()
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegCloseKey(m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
	
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = nBufferSize;

	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(strData), &cbData);

	return ERROR_SUCCESS == lErr && REG_SZ == dwType;
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, DWORD& rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = sizeof(rdw);
	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(&rdw), &cbData);

	return ERROR_SUCCESS == lErr && REG_DWORD == dwType;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, LPCTSTR strData)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_SZ, 
		reinterpret_cast<const BYTE*>(strData), sizeof(TCHAR)*(lstrlen(strData) + 1));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, DWORD rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_DWORD,
		reinterpret_cast<PBYTE>(&rdw), sizeof(rdw));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\inshandler.h ===
// INSHandler.h : Declaration of the CINSHandler

#ifndef __INSHANDLER_H_
#define __INSHANDLER_H_

// This struct is used to configure the client
typedef struct
{
    LPCTSTR lpszSection;
    LPCTSTR lpszValue;
    UINT    uOffset;
    UINT    uSize;
} CLIENT_TABLE, FAR *LPCLIENT_TABLE;

typedef struct
{
    TCHAR         szEntryName[RAS_MaxEntryName+1];
    TCHAR         szUserName[UNLEN+1];
    TCHAR         szPassword[PWLEN+1];
    TCHAR         szScriptFile[MAX_PATH+1];
    RASENTRY      RasEntry;
} ICONNECTION, FAR * LPICONNECTION;

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CINSHandler
class ATL_NO_VTABLE CINSHandler :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CINSHandler,&CLSID_INSHandler>,
	public CComControl<CINSHandler>,
	public IDispatchImpl<IINSHandler, &IID_IINSHandler, &LIBID_ICWHELPLib>,
    public IProvideClassInfo2Impl<&CLSID_INSHandler, &DIID__INSHandlerEvents, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CINSHandler>,
	public IOleControlImpl<CINSHandler>,
	public IOleObjectImpl<CINSHandler>,
	public IOleInPlaceActiveObjectImpl<CINSHandler>,
	public IViewObjectExImpl<CINSHandler>,
	public IOleInPlaceObjectWindowlessImpl<CINSHandler>,
    public CProxy_INSHandlerEvents<CINSHandler>,
    public IConnectionPointContainerImpl<CINSHandler>,
    public IObjectSafetyImpl<CINSHandler>
{
public:
	CINSHandler()
	{
        m_szRunExecutable      [0]  = '\0';
        m_szRunArgument        [0]  = '\0';
        m_szCheckAssociations  [0]  = '\0';
        m_szAutodialConnection [0]  = '\0';
        m_szStartURL           [0]  = '\0';
        m_fResforeDefCheck          = FALSE;
        m_fAutodialSaved            = TRUE;
        m_fAutodialEnabled          = FALSE;
        m_fProxyEnabled             = FALSE;
        m_bSilentMode               = FALSE;
        m_lpfnInetConfigSystem      = NULL;
        m_lpfnInetGetProxy          = NULL;
        m_lpfnInetConfigClient      = NULL;
        //m_lpfnInetConfigClientEx    = NULL;
        m_lpfnInetGetAutodial       = NULL;
        m_lpfnInetSetAutodial       = NULL;
        m_lpfnInetSetClientInfo     = NULL;
        m_lpfnInetSetProxy          = NULL;
        m_lpfnBrandICW              = NULL;
        m_lpfnRasSetAutodialEnable  = NULL;
	    m_lpfnRasSetAutodialAddress = NULL;
        m_hInetCfg                  = NULL;
        m_hBranding                 = NULL;
        m_hRAS                      = NULL;
        m_dwBrandFlags              = BRAND_DEFAULT;      
	}

DECLARE_REGISTRY_RESOURCEID(IDR_INSHANDLER)

BEGIN_COM_MAP(CINSHandler) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IINSHandler)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CINSHandler)
    CONNECTION_POINT_ENTRY(DIID__INSHandlerEvents)
END_CONNECTION_POINT_MAP()


BEGIN_PROPERTY_MAP(CINSHandler)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CINSHandler)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

    
// IINSHandler
public:
	STDMETHOD (put_BrandingFlags) (/*[in]*/ long lFlags);
	STDMETHOD (put_SilentMode)    (/*[in]*/ BOOL bSilent);
    STDMETHOD (get_NeedRestart)   (/*[out, retval]*/ BOOL *pVal);
	STDMETHOD (ProcessINS)        (BSTR bstrINSFilePath, /*[out, retval]*/ BOOL *pbRetVal);
	STDMETHOD (get_DefaultURL)    (/*[out, retval]*/ BSTR *pszURL);
	
    HRESULT   OnDraw(ATL_DRAWINFO& di);

private:
    CComBSTR    m_bstrINSFileName;
    HRESULT     MassageFile(LPCTSTR lpszFile);
    DWORD       RunExecutable(void);
    BOOL        KeepConnection(LPCTSTR lpszFile);
    DWORD       ImportCustomInfo(LPCTSTR lpszImportFile, LPTSTR lpszExecutable, DWORD cbExecutable, LPTSTR lpszArgument, DWORD cbArgument);
    DWORD       ImportFile(LPCTSTR lpszImportFile, LPCTSTR lpszSection, LPCTSTR lpszOutputFile);
    DWORD       ImportCustomFile(LPCTSTR lpszImportFile);
    DWORD       ImportBrandingInfo(LPCTSTR lpszFile, LPCTSTR lpszConnectoidName);
    // Client Config functions
    DWORD       ImportCustomDialer(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    LPCTSTR     StrToSubip (LPCTSTR szIPAddress, LPBYTE pVal);
    DWORD       StrToip (LPCTSTR szIPAddress, RASIPADDR *ipAddr);
    DWORD       ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    DWORD       ImportServerInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    DWORD       ImportIPInfo(LPRASENTRY lpRasEntry, LPCTSTR szFileName);
    DWORD       ImportScriptFile(LPCTSTR lpszImportFile, LPTSTR szScriptFile, UINT cbScriptFile);
    DWORD       RnaValidateImportEntry (LPCTSTR szFileName);
    DWORD       ImportRasEntry (LPCTSTR szFileName, LPRASENTRY lpRasEntry);
    DWORD       ImportConnection (LPCTSTR szFileName, LPICONNECTION lpConn);
    DWORD       ImportMailAndNewsInfo(LPCTSTR lpszFile, BOOL fConnectPhone);
    HRESULT     WriteMailAndNewsKey(HKEY hKey, LPCTSTR lpszSection, LPCTSTR lpszValue,LPTSTR lpszBuff, DWORD dwBuffLen,LPCTSTR lpszSubKey,DWORD dwType, LPCTSTR lpszFile);
    BOOL        LoadExternalFunctions(void);
    DWORD       ReadClientInfo(LPCTSTR lpszFile, LPINETCLIENTINFO lpClientInfo, LPCLIENT_TABLE lpClientTable);
    BOOL        WantsExchangeInstalled(LPCTSTR lpszFile);
    BOOL        DisplayPassword(LPCTSTR lpszFile);
    DWORD       ImportClientInfo(LPCTSTR lpszFile, LPINETCLIENTINFO lpClientInfo);
    DWORD       ConfigureClient(HWND hwnd, LPCTSTR lpszFile, LPBOOL lpfNeedsRestart, LPBOOL lpfConnectoidCreated, BOOL fHookAutodial, LPTSTR szConnectoidName, DWORD dwConnectoidNameSize);
    HRESULT     PopulateNTAutodialAddress(LPCTSTR pszFileName, LPCTSTR pszEntryName);
    LPTSTR      MoveToNextAddress(LPTSTR lpsz);
    HRESULT     PreparePassword(LPTSTR szBuff, DWORD dwBuffLen);
    BOOL        FIsAthenaPresent();
    BOOL        FTurnOffBrowserDefaultChecking();
    BOOL        FRestoreBrowserDefaultChecking();
    void        SaveAutoDial(void);
    void        RestoreAutoDial(void);


    BOOL        OpenIcwRmindKey(CMcRegistry &reg);
    BOOL        ConfigureTrialReminder(LPCTSTR  lpszFile);

    BOOL        SetICWCompleted( DWORD dwCompleted );
    DWORD       CallSBSConfig(HWND hwnd, LPCTSTR lpszINSFile);
    BOOL        CallCMConfig(LPCTSTR lpszINSFile);
    
    
    DWORD       dw_ProcessFlags;        // Flags used to control INS processing
    TCHAR       m_szRunExecutable[MAX_PATH + 1];
    TCHAR       m_szRunArgument[MAX_PATH + 1];
    TCHAR       m_szCheckAssociations[20];
    TCHAR       m_szAutodialConnection[RAS_MaxEntryName + 1];
    TCHAR       m_szStartURL[MAX_PATH + 1];

    BOOL        m_fConnectionKilled;
    BOOL        m_fNeedsRestart;
    BOOL        m_fResforeDefCheck;
    BOOL        m_fAutodialSaved;
    BOOL        m_fAutodialEnabled;
    BOOL        m_fProxyEnabled;
    BOOL        m_bSilentMode;

    PFNINETCONFIGSYSTEM         m_lpfnInetConfigSystem;
    PFNINETGETPROXY             m_lpfnInetGetProxy;
    PFNINETCONFIGCLIENT         m_lpfnInetConfigClient;
    //PFNINETCONFIGCLIENTEX       m_lpfnInetConfigClientEx;
    PFNINETGETAUTODIAL          m_lpfnInetGetAutodial;
    PFNINETSETAUTODIAL          m_lpfnInetSetAutodial;
    PFNINETSETCLIENTINFO        m_lpfnInetSetClientInfo;
    PFNINETSETPROXY             m_lpfnInetSetProxy;

    PFNBRANDICW                 m_lpfnBrandICW;
    PFNRASSETAUTODIALENABLE     m_lpfnRasSetAutodialEnable;
	PFNRASSETAUTODIALADDRESS    m_lpfnRasSetAutodialAddress;


    HINSTANCE           m_hInetCfg;
    HINSTANCE           m_hBranding;
    HINSTANCE           m_hRAS;
    DWORD               m_dwBrandFlags;
};

#endif //__INSHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\refdial.h ===
// RefDial.h : Declaration of the CRefDial

#ifndef __REFDIAL_H_
#define __REFDIAL_H_

// Defines used for Dialing
#define MAX_EXIT_RETRIES 10
#define MAX_RETIES 3
#define MAX_RASENTRYNAME 126

#define MAX_DIGITAL_PID     256

typedef DWORD (WINAPI *PFNRASGETCONNECTSTATUS)(HRASCONN,LPRASCONNSTATUS);

/////////////////////////////////////////////////////////////////////////////
// CRefDial
class ATL_NO_VTABLE CRefDial :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRefDial,&CLSID_RefDial>,
    public CWindowImpl<CRefDial>,
    public IDispatchImpl<IRefDial, &IID_IRefDial, &LIBID_ICWHELPLib>,
    public IProvideClassInfo2Impl<&CLSID_RefDial, &DIID__RefDialEvents, &LIBID_ICWHELPLib>,
    public CProxy_RefDialEvents<CRefDial>,
    public IConnectionPointContainerImpl<CRefDial>
{
public:

    CRefDial()
    {
        m_szCurrentDUNFile[0]              = '\0';
        m_szLastDUNFile[0]                 = '\0';
        m_szEntryName[0]                   = '\0';
        m_szConnectoid[RAS_MaxEntryName+1] = '\0';
        m_szConnectoid[0]                  = '\0';
        m_szPID[0]                         = '\0';
        m_szRefServerURL[0]                = '\0';
        m_hrDisplayableNumber              = ERROR_SUCCESS;
        m_dwCountryCode                    = 0;
        *m_szISPSupportNumber              = 0;
        m_RasStatusID                      = 0;
        m_dwTapiDev                        = 0xFFFFFFFF; // NOTE: 0 is a valid value
        m_dwWizardVersion                  = 0;
        m_lBrandingFlags                   = BRAND_DEFAULT;
        m_lCurrentModem                    = -1;
        m_lAllOffers                       = 0;
        m_PhoneNumberEnumidx               = 0;
        m_bDownloadHasBeenCanceled         = TRUE;  // This will get set to FALSE when a DOWNLOAD starts
        m_bQuitWizard                      = FALSE;
        m_bTryAgain                        = FALSE;
        m_bDisconnect                      = FALSE;
        m_bWaitingToHangup                 = FALSE;
        m_bModemOverride                   = FALSE; //allows campus net to be used.
        m_hThread                          = NULL;
        m_hrasconn                         = NULL;
        m_pSuggestInfo                     = NULL;
        m_rgpSuggestedAE                   = NULL;
        m_pszDisplayable                   = NULL;
        m_pcRNA                            = NULL;
        m_hRasDll                          = NULL;
        m_fpRasDial                        = NULL;
        m_fpRasGetEntryDialParams          = NULL;
        m_lpGatherInfo                     = new GATHERINFO; 
        m_reflpRasEntryBuff                = NULL;
        m_reflpRasDevInfoBuff              = NULL;
    }

    CRefDial::~CRefDial()
    {
        if (m_hThread)
        {
            //This is to fix a crashing bug where we unloaded this dll
            //before this thread figured out what had happened. 
            //Now we give it time to understand it's dead
            DWORD dwThreadResults = STILL_ACTIVE;
            while(dwThreadResults == STILL_ACTIVE)
            {
                GetExitCodeThread(m_hThread,&dwThreadResults);
                Sleep(500);
            }
        }    
        
        if (m_hrasconn)
            DoHangup();

        if (m_lpGatherInfo)
            delete(m_lpGatherInfo);
            
        if (m_pSuggestInfo)
        {
            GlobalFree(m_pSuggestInfo->rgpAccessEntry);
            
            GlobalFree(m_pSuggestInfo);
        }

        if( (m_pcRNA!=NULL) && (m_szConnectoid[0]!='\0') )
        {
            m_pcRNA->RasDeleteEntry(NULL,m_szConnectoid);
            delete m_pcRNA;
        }

        if(m_reflpRasEntryBuff)
        {
            GlobalFree(m_reflpRasEntryBuff);
            m_reflpRasEntryBuff = NULL;
        }
        if(m_reflpRasDevInfoBuff)
        {
            GlobalFree(m_reflpRasDevInfoBuff);
            m_reflpRasDevInfoBuff = NULL;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_REFDIAL)

BEGIN_COM_MAP(CRefDial) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IRefDial)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CRefDial)
    CONNECTION_POINT_ENTRY(DIID__RefDialEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CRefDial)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CRefDial)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DOWNLOAD_DONE, OnDownloadEvent)
    MESSAGE_HANDLER(WM_DOWNLOAD_PROGRESS, OnDownloadEvent)

    MESSAGE_HANDLER(WM_RASDIALEVENT, OnRasDialEvent)
    MESSAGE_HANDLER(m_unRasDialMsg, OnRasDialEvent)
ALT_MSG_MAP(1)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }


    friend DWORD WINAPI DownloadThreadInit(LPVOID lpv);

// IRefDial
public:
    STDMETHOD(get_LoggingEndUrl)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_LoggingStartUrl)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISPSupportPhoneNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ISPSupportPhoneNumber)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_CurrentModem)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_CurrentModem)(/*[in]*/ long newVal);
    STDMETHOD(get_BrandingFlags)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_BrandingFlags)(/*[in]*/ long newVal);
    STDMETHOD(get_HavePhoneBook)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(ValidatePhoneNumber)(/*[in]*/ BSTR bstrPhoneNumber, /*[out,retval]*/ BOOL *pbRetVal);
    STDMETHOD(ShowPhoneBook)(/*[in]*/ DWORD dwCountryCode, /*[in]*/ long newVal, /*[out,retval]*/ BOOL *pbRetVal);
    STDMETHOD(ShowDialingProperties)(/*[out,retval]*/ BOOL *pbRetVal);
    STDMETHOD(get_SupportNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISPSupportNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ModemEnum_NumDevices)(/*[out, retval]*/ long *pVal);
    STDMETHOD(ModemEnum_Next)(/*[out, retval] */BSTR *pDeviceName);
    STDMETHOD(ModemEnum_Reset)();
    STDMETHOD(get_DialErrorMsg)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DialError)(/*[out, retval]*/ HRESULT *pVal);
    STDMETHOD(put_Redial)(/*[in]*/ BOOL newbVal);
    STDMETHOD(get_TryAgain)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_SignupURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_AutoConfigURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISDNURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ISDNAutoConfigURL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(FormReferralServerURL)(/*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(get_SignedPID)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(ProcessSignedPID)(/*[out, retval]*/ BOOL *pbRetVal);
    void GetPID();
    STDMETHOD(DoInit)();
    STDMETHOD(DoHangup)();
    STDMETHOD(get_DialStatusString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(DoOfferDownload)(/*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(get_ProductCode)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ProductCode)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_PromoCode)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_PromoCode)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_OemCode)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_AllOfferCode)(/*[in]*/ long newVal);
    STDMETHOD(get_URL)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DialPhoneNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DialPhoneNumber)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_UserPickNumber)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_QuitWizard)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(SetupForDialing)(BSTR bstrISPFile, DWORD dwCountry, BSTR bstrAreaCode, DWORD dwFlag,/*[out, retval] */BOOL *pbRetVal);
    STDMETHOD(get_DownloadStatusString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(DoConnect)(/*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(put_ModemOverride)(/*[in]*/ BOOL newbVal);

    HRESULT OnDraw(ATL_DRAWINFO& di);

    STDMETHOD(SelectedPhoneNumber)(/*[in]*/ long newVal, /*[out, retval]*/ BOOL * pbRetVal);
    STDMETHOD(PhoneNumberEnum_Reset)();
    STDMETHOD(PhoneNumberEnum_Next)(/*[out, retval]*/ BSTR *pNumber);
    STDMETHOD(get_PhoneNumberEnum_NumDevices)(/*[out, retval]*/ long * pVal);
    
    
    STDMETHOD(get_bIsISDNDevice)(/*[out, retval] */ BOOL *pVal);
    STDMETHOD(RemoveConnectoid)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_RasGetConnectStatus)(/*[out, retval]*/ BOOL *pVal);
    
    LRESULT OnRasDialEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDownloadDone(void);

    // Dialing service functions
    HRESULT GetDisplayableNumber();
    HRESULT Dial();
    BOOL FShouldRetry(HRESULT hrErr);

    DWORD MyRasDial(LPRASDIALEXTENSIONS,LPTSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
    DWORD MyRasGetEntryDialParams(LPTSTR,LPRASDIALPARAMS,LPBOOL); 

    DWORD ReadConnectionInformation(void);
    DWORD FillGatherInfoStruct(LPGATHERINFO lpGatherInfo);
    HRESULT CreateEntryFromDUNFile(LPTSTR pszDunFile);
    HRESULT UserPickANumber(HWND hWnd,
                            LPGATHERINFO lpGatherInfo, 
                            PSUGGESTINFO lpSuggestInfo,
                            HINSTANCE hPHBKDll,
                            DWORD_PTR dwPhoneBook,
                            TCHAR *pszConnectoid, 
                            DWORD dwSize,
                            DWORD dwPhoneDisplayFlags);
    HRESULT SetupForRASDialing(LPGATHERINFO lpGatherInfo, 
                               HINSTANCE hPHBKDll,
                               DWORD_PTR *lpdwPhoneBook,
                               PSUGGESTINFO *ppSuggestInfo,
                               TCHAR *pszConnectoid, 
                               BOOL FAR *bConnectiodCreated);
    HRESULT SetupConnectoid(PSUGGESTINFO pSuggestInfo, int irc, 
                            TCHAR *pszConnectoid, DWORD dwSize, BOOL * pbSuccess);
    HRESULT FormURL(void);
    
    HRESULT MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
                                        LPTSTR lpszPhonebookEntry, 
                                        LPRASENTRY *lplpRasEntryBuff,
                                        LPDWORD lpdwRasEntryBuffSize,
                                        LPRASDEVINFO *lplpRasDevInfoBuff,
                                        LPDWORD lpdwRasDevInfoBuffSize);

    // Dialing service members
    UINT            m_unRasDialMsg;
    DWORD           m_dwTapiDev;
    HRASCONN        m_hrasconn;
    TCHAR           m_szConnectoid[RAS_MaxEntryName+1];
    HANDLE          m_hThread;
    DWORD           m_dwThreadID;
    HINSTANCE       m_hRasDll;
    FARPROC         m_fpRasDial;
    FARPROC         m_fpRasGetEntryDialParams;
    LPGATHERINFO    m_pGI;
    TCHAR           m_szUrl[INTERNET_MAX_URL_LENGTH];               // Download thread

    DWORD_PTR       m_dwDownLoad;           // Download thread
    HLINEAPP        m_hLineApp;
    DWORD           m_dwAPIVersion;
    LPTSTR          m_pszDisplayable;
    RNAAPI          *m_pcRNA;
    TCHAR           m_szPhoneNumber[256];
    BOOL            m_bDialAsIs;
    UINT            m_uiRetry;
    CComBSTR        m_bstrISPFile;
    TCHAR           m_szCurrentDUNFile[MAX_PATH];
    TCHAR           m_szLastDUNFile[MAX_PATH];
    TCHAR           m_szEntryName[RAS_MaxEntryName+1];
    TCHAR           m_szISPSupportNumber[RAS_MaxAreaCode + RAS_MaxPhoneNumber +1];

//  CBusyMessages   m_objBusyMessages;
    BOOL            m_bDownloadHasBeenCanceled;
    BOOL            m_bDisconnect;
    BOOL            m_bWaitingToHangup;

    LPGATHERINFO    m_lpGatherInfo;
    //
    // Used for Phone book look-up
    //
    PSUGGESTINFO    m_pSuggestInfo;
    PACCESSENTRY    *m_rgpSuggestedAE;

    CISPImport      m_ISPImport;      // Import an ISP file

    int             m_RasStatusID;
    int             m_DownloadStatusID;

    TCHAR           m_szRefServerURL[INTERNET_MAX_URL_LENGTH];
    LPRASENTRY      m_reflpRasEntryBuff;
    LPRASDEVINFO    m_reflpRasDevInfoBuff;
 

private:
    BOOL IsSBCSString( TCHAR *sz );
    void GetISPFileSettings(LPTSTR lpszFile);
    
    BOOL m_bModemOverride;

protected:
    BOOL            m_bTryAgain;
    BOOL            m_bQuitWizard;
    BOOL            m_bUserPickNumber;
    BOOL            m_bRedial;
    HRESULT         m_hrDisplayableNumber;
    HRESULT         m_hrDialErr;

    CComBSTR        m_bstrPromoCode;
    CComBSTR        m_bstrProductCode;
    TCHAR           m_szOEM[MAX_OEMNAME];
    CComBSTR        m_bstrSignedPID;
    CComBSTR        m_bstrSupportNumber;
    CComBSTR        m_bstrLoggingStartUrl;
    CComBSTR        m_bstrLoggingEndUrl;

    long            m_lAllOffers;
    CEnumModem      m_emModemEnum;
    CSupport        m_SupportInfo;
    DWORD           m_dwCountryCode;

    long            m_lBrandingFlags;
    long            m_lCurrentModem;
    // Version of the wizard HTML.  Sent to RefServer
    DWORD           m_dwWizardVersion;
    TCHAR           m_szPID[(MAX_DIGITAL_PID * 2) + 1];
    
    void CRefDial::ShowCredits();
    
    long            m_PhoneNumberEnumidx;
};

#endif //__REFDIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\misc.cpp ===
/*-----------------------------------------------------------------------------
    misc.cpp

    service functions

  History:
        1/7/98      DONALDM Moved to new ICW project and string
                    and nuked 16 bit stuff
-----------------------------------------------------------------------------*/

#include "stdafx.h"
#include <stdio.h>

#if defined (DEBUG)
#include "refdial.h"
#endif

#define DIR_SIGNUP  TEXT("signup")
#define DIR_WINDOWS TEXT("windows")
#define DIR_SYSTEM  TEXT("system")
#define DIR_TEMP    TEXT("temp")

BOOL g_bGotProxy=FALSE; 

#if defined (DEBUG)
extern TCHAR g_BINTOHEXLookup[16];
#endif

//+---------------------------------------------------------------------------
//
//    Function:    ProcessDBCS
//
//    Synopsis:    Converts control to use DBCS compatible font
//                Use this at the beginning of the dialog procedure
//    
//                Note that this is required due to a bug in Win95-J that prevents
//                it from properly mapping MS Shell Dlg.  This hack is not needed
//                under winNT.
//
//    Arguments:    hwnd - Window handle of the dialog
//                cltID - ID of the control you want changed.
//
//    Returns:    ERROR_SUCCESS
// 
//    History:    4/31/97 a-frankh    Created
//                5/13/97    jmazner        Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
    HFONT hFont = NULL;

    if( IsNT() )
    {
        return;
    }

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
}

// ############################################################################
//  StoreInSignUpReg
//
//  Created 3/18/96,        Chris Kauffman
// ############################################################################
HRESULT StoreInSignUpReg(LPBYTE lpbData, DWORD dwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey;

    hr = RegCreateKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto StoreInSignUpRegExit;
    hr = RegSetValueEx(hKey,pszKey,0,dwType,lpbData,sizeof(TCHAR)*dwSize);


    RegCloseKey(hKey);

StoreInSignUpRegExit:
    return hr; 
}

HRESULT ReadSignUpReg(LPBYTE lpbData, DWORD *pdwSize, DWORD dwType, LPCTSTR pszKey)
{
    HRESULT hr = ERROR_ACCESS_DENIED;
    HKEY hKey = 0;

    hr = RegOpenKey(HKEY_LOCAL_MACHINE,SIGNUPKEY,&hKey);
    if (hr != ERROR_SUCCESS) goto ReadSignUpRegExit;
    hr = RegQueryValueEx(hKey,pszKey,0,&dwType,lpbData,pdwSize);

ReadSignUpRegExit:
    if (hKey) RegCloseKey (hKey);
    return hr;
}

// ############################################################################
//  GetDataFromISPFile
//
//  This function will read a specific piece of information from an ISP file.
//
//  Created 3/16/96,        Chris Kauffman
// ############################################################################
HRESULT GetDataFromISPFile
(
    LPTSTR pszISPCode, 
    LPTSTR pszSection,
    LPTSTR pszDataName, 
    LPTSTR pszOutput, 
    DWORD  dwOutputLength)
{
    LPTSTR  pszTemp;
    HRESULT hr = ERROR_SUCCESS;
    TCHAR   szTempPath[MAX_PATH];
    TCHAR   szBuff256[256];

    // Locate ISP file
    if (!SearchPath(NULL,pszISPCode,INF_SUFFIX,MAX_PATH,szTempPath,&pszTemp))
    {
        wsprintf(szBuff256,TEXT("Can not find:%s%s (%d) (connect.exe)"),pszISPCode,INF_SUFFIX,GetLastError());
        AssertMsg(0,szBuff256);
        lstrcpyn(szTempPath,pszISPCode,MAX_PATH);
        lstrcpyn(&szTempPath[lstrlen(szTempPath)],INF_SUFFIX,MAX_PATH-lstrlen(szTempPath));
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),szTempPath);
        MessageBox(NULL,szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
        hr = ERROR_FILE_NOT_FOUND;
    } else if (!GetPrivateProfileString(pszSection,pszDataName,INF_DEFAULT,
        pszOutput, (int)dwOutputLength,szTempPath))
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP: %s not specified in ISP file.\n"),pszDataName);
        hr = ERROR_FILE_NOT_FOUND;
    } 

    // 10/23/96    jmazner    Normandy #9921
    // CompareString does _not_ have same return values as lsrtcmp!
    // Return value of 2 indicates strings are equal.
    //if (!CompareString(LOCALE_SYSTEM_DEFAULT,0,INF_DEFAULT,lstrlen(INF_DEFAULT),pszOutput,lstrlen(pszOutput)))
    if (2 == CompareString(LOCALE_SYSTEM_DEFAULT,0,INF_DEFAULT,lstrlen(INF_DEFAULT),pszOutput,lstrlen(pszOutput)))
    {
        hr = ERROR_FILE_NOT_FOUND;
    }

    if (hr != ERROR_SUCCESS && dwOutputLength) 
        *pszOutput = TEXT('\0');
    return hr;
}

// ############################################################################
//  GetINTFromISPFile
//
//  This function will read a specific integer from an ISP file.
//
//  
// ############################################################################
HRESULT GetINTFromISPFile
(
    LPTSTR  pszISPCode, 
    LPTSTR  pszSection,
    LPTSTR  pszDataName, 
    int far *lpData,
    int     iDefaultValue
)
{
    LPTSTR  pszTemp;
    HRESULT hr = ERROR_SUCCESS;
    TCHAR   szTempPath[MAX_PATH];
    TCHAR   szBuff256[256];

    // Locate ISP file
    if (!SearchPath(NULL,pszISPCode,INF_SUFFIX,MAX_PATH,szTempPath,&pszTemp))
    {
        wsprintf(szBuff256,TEXT("Can not find:%s%s (%d) (connect.exe)"),pszISPCode,INF_SUFFIX,GetLastError());
        AssertMsg(0,szBuff256);
        lstrcpyn(szTempPath,pszISPCode,MAX_PATH);
        lstrcpyn(&szTempPath[lstrlen(szTempPath)],INF_SUFFIX,MAX_PATH-lstrlen(szTempPath));
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),szTempPath);
        MessageBox(NULL,szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
        hr = ERROR_FILE_NOT_FOUND;
    } 
    
    *lpData = GetPrivateProfileInt(pszSection, 
                                   pszDataName, 
                                   iDefaultValue, 
                                   szTempPath);
    return hr;
}


//+-------------------------------------------------------------------
//
//    Function:    IsNT
//
//    Synopsis:    findout If we are running on NT
//
//    Arguements:    none
//
//    Return:        TRUE -  Yes
//                FALSE - No
//
//--------------------------------------------------------------------
BOOL 
IsNT (
    VOID
    )
{
    OSVERSIONINFO  OsVersionInfo;

    ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);
    return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);

}  //end of IsNT function call

//+-------------------------------------------------------------------
//
//    Function:    IsNT4SP3Lower
//
//    Synopsis:    findout If we are running on NTSP3 or lower
//
//    Arguements:    none
//
//    Return:        TRUE -  Yes
//                FALSE - No
//
//--------------------------------------------------------------------

BOOL IsNT4SP3Lower()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
    GetVersionEx(&os);

    if(os.dwPlatformId != VER_PLATFORM_WIN32_NT)
        return FALSE;

    // Exclude NT5 or higher
    if(os.dwMajorVersion > 4)
        return FALSE;

	if(os.dwMajorVersion < 4)
        return TRUE;

    // version 4.0
    if ( os.dwMinorVersion > 0)
        return FALSE;        // assume that sp3 is not needed for nt 4.1 or higher

    int nServicePack;
    if(_stscanf(os.szCSDVersion, TEXT("Service Pack %d"), &nServicePack) != 1)
        return TRUE;

    if(nServicePack < 4)
        return TRUE;
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   MyGetTempPath()
//
//  Synopsis:   Gets the path to temporary directory
//                - Use GetTempFileName to get a file name 
//                  and strips off the filename portion to get the temp path
//
//  Arguments:  [uiLength - Length of buffer to contain the temp path]
//                [szPath      - Buffer in which temp path will be returned]
//
//    Returns:    Length of temp path if successful
//                0 otherwise
//
//  History:    7/6/96     VetriV    Created
//                8/23/96        VetriV        Delete the temp file
//                12/4/96        jmazner     Modified to serve as a wrapper of sorts;
//                                     if TMP or TEMP don't exist, setEnv our own
//                                     vars that point to conn1's installed path
//                                     (Normandy #12193)
//
//----------------------------------------------------------------------------
DWORD MyGetTempPath(UINT uiLength, LPTSTR szPath)
{ 
#    define ICWHELPPATHKEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWHELP.EXE")
#    define PATHKEYNAME TEXT("Path")
    TCHAR szEnvVarName[MAX_PATH + 1] = TEXT("\0unitialized szEnvVarName\0");
    DWORD dwFileAttr = 0;

    lstrcpyn( szPath, TEXT("\0unitialized szPath\0"), 20 );

    // is the TMP variable set?
    lstrcpyn(szEnvVarName,GetSz(IDS_TMPVAR),sizeof(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        // if there was any error, this directory isn't valid.
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    lstrcpyn( szEnvVarName, TEXT("\0unitialized again\0"), 19 );

    // if not, is the TEMP variable set?
    lstrcpyn(szEnvVarName,GetSz(IDS_TEMPVAR),sizeof(szEnvVarName));
    if( GetEnvironmentVariable( szEnvVarName, szPath, uiLength ) )
    {
        // 1/7/96 jmazner Normandy #12193
        // verify validity of directory name
        dwFileAttr = GetFileAttributes(szPath);
        if( 0xFFFFFFFF != dwFileAttr )
        {
            if( FILE_ATTRIBUTE_DIRECTORY & dwFileAttr )
            {
                return( lstrlen(szPath) );
            }
        }
    }

    // neither one is set, so let's use the path to the installed icwhelp.dll
    // from the registry  SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\ICWHELP.DLL\Path
    HKEY hkey = NULL;

#ifdef UNICODE
    uiLength = sizeof(TCHAR)*uiLength;
#endif
    if ((RegOpenKeyEx(HKEY_LOCAL_MACHINE,ICWHELPPATHKEY, 0, KEY_QUERY_VALUE, &hkey)) == ERROR_SUCCESS)
        RegQueryValueEx(hkey, PATHKEYNAME, NULL, NULL, (LPBYTE)szPath, (DWORD *)&uiLength);
    if (hkey) 
    {
        RegCloseKey(hkey);
    }

    //The path variable is supposed to have a semicolon at the end of it.
    // if it's there, remove it.
    if( TEXT(';') == szPath[uiLength - 2] )
        szPath[uiLength - 2] = TEXT('\0');

    TraceMsg(TF_GENERAL, TEXT("ICWHELP: using path %s\r\n"), szPath);


    // go ahead and set the TEMP variable for future reference
    // (only effects currently running process)
    if( szEnvVarName[0] )
    {
        SetEnvironmentVariable( szEnvVarName, szPath );
    }
    else
    {
        lstrcpyn( szPath, TEXT("\0unitialized again\0"), 19 );
        return( 0 );
    }

    return( uiLength );
} 

// ############################################################################
HRESULT ClearProxySettings()
{
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = ERROR_SUCCESS;

    hinst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hinst)
    {
        fp = GetProcAddress(hinst,"InetGetProxy");
        if (!fp)
        {
            hr = GetLastError();
            goto ClearProxySettingsExit;
        }
        hr = ((PFNINETGETPROXY)fp)(&g_bProxy,NULL,0,NULL,0);
        if (hr == ERROR_SUCCESS) 
            g_bGotProxy = TRUE;
        else
            goto ClearProxySettingsExit;

        if (g_bProxy)
        {
            fp = GetProcAddress(hinst, "InetSetProxy");
            if (!fp)
            {
                hr = GetLastError();
                goto ClearProxySettingsExit;
            }
            ((PFNINETSETPROXY)fp)(FALSE,NULL,NULL);
        }
    } else {
        hr = GetLastError();
    }

ClearProxySettingsExit:
    if (hinst) 
        FreeLibrary(hinst);
    return hr;
}

// ############################################################################
HRESULT RestoreProxySettings()
{
    HINSTANCE hinst = NULL;
    FARPROC fp;
    HRESULT hr = ERROR_SUCCESS;

    hinst = LoadLibrary(TEXT("INETCFG.DLL"));
    if (hinst && g_bGotProxy)
    {
        fp = GetProcAddress(hinst, "InetSetProxy");
        if (!fp)
        {
            hr = GetLastError();
            goto RestoreProxySettingsExit;
        }
        ((PFNINETSETPROXY)fp)(g_bProxy,NULL,NULL);
    } else {
        hr = GetLastError();
    }

RestoreProxySettingsExit:
    if (hinst) 
        FreeLibrary(hinst);
    return hr;
}

// ############################################################################
BOOL FSz2Dw(LPCTSTR pSz,LPDWORD dw)
{
    DWORD val = 0;
    while (*pSz && *pSz != TEXT('.'))
    {
        if (*pSz >= TEXT('0') && *pSz <= TEXT('9'))
        {
            val *= 10;
            val += *pSz++ - TEXT('0');
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
LPTSTR GetNextNumericChunk(LPTSTR psz, LPTSTR pszLim, LPTSTR* ppszNext)
{
    LPTSTR pszEnd;

    // init for error case
    *ppszNext = NULL;
    // skip non numerics if any to start of next numeric chunk
    while(*psz<TEXT('0') || *psz>TEXT('9'))
    {
        if(psz >= pszLim) return NULL;
        psz++;
    }
    // skip all numerics to end of country code
    for(pszEnd=psz; *pszEnd>=TEXT('0') && *pszEnd<=TEXT('9') && pszEnd<pszLim; pszEnd++)
        ;
    // zap whatever delimiter there was to terminate this chunk
    *pszEnd++ = TEXT('\0');
    // return ptr to next chunk (pszEnd now points to it)
    if(pszEnd<pszLim) 
        *ppszNext = pszEnd;
        
    return psz;    // return ptr to start of chunk
}

// ############################################################################
BOOL BreakUpPhoneNumber(LPRASENTRY prasentry, LPTSTR pszPhone)
{
    LPTSTR         pszStart,pszNext, pszLim, pszArea;
//    LPPHONENUM     ppn;
    
    if (!pszPhone) return FALSE; // skip if no number
    
    pszLim = pszPhone + lstrlen(pszPhone);    // find end of string

    //ppn = (fMain) ? &(pic->PhoneNum) : &(pic->PhoneNum2);
    
    ////Get the country ID...
    //ppn->dwCountryID = PBKDWCountryId();
    
    // Get Country Code from phone number...
    pszStart = _tcschr(pszPhone,TEXT('+'));
    if(!pszStart) goto error; // bad format

    // get country code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    if(!pszStart) goto error; // bad format
    //ppn->dwCountryCode = Sz2Dw(pszStart);
    FSz2Dw(pszStart,&prasentry->dwCountryCode);
    pszStart = pszNext;
        
    //Now get the area code
    pszStart = GetNextNumericChunk(pszStart, pszLim, &pszNext);
    //if(!pszStart || !pszNext) goto error; // bad format
    if(!pszStart) goto error; // bad format //icw bug 8950
    //lstrcpy(ppn->szAreaCode, pszStart);
    lstrcpyn(prasentry->szAreaCode,pszStart,sizeof(prasentry->szAreaCode));
    //
    // Keep track of the start of the area code, because it may actually be the
    // local phone number.
    //
    pszArea = pszStart;

    pszStart = pszNext;

    // If pszStart is NULL then we don't have an area code, just a country code and a local
    // phone number.  Therefore we will copy what we thought was the area code into the
    // phone number and replace the area code with a space (which seems to make RAS happy).
    //
    if (pszStart)
    {
        //now the local phone number (everything from here to : or end)
        pszNext = _tcschr(pszStart, TEXT(':'));
        if(pszNext) *pszNext=TEXT('\0');

        lstrcpyn(prasentry->szLocalPhoneNumber,pszStart,sizeof(prasentry->szLocalPhoneNumber));
    } else {
        //
        // Turns out that there is no area code. So copy what we thought was the area code
        // into the local phone number and make the area code NULL
        //
        lstrcpyn(prasentry->szLocalPhoneNumber,pszArea,sizeof(prasentry->szLocalPhoneNumber));
        //lstrcpyn(prasentry->szAreaCode," ",sizeof(prasentry->szAreaCode));
        prasentry->szAreaCode[0] = TEXT('\0');
    }

    //no extension. what is extension?
    //ppn->szExtension[0] = TEXT('\0');
    //LocalFree(pszPhone);
    return TRUE;

error:
    // This means number is not canonical. Set it as local number anyway!
    // memset(ppn, 0, sizeof(*ppn));
    // Bug#422: need to strip stuff after : or dial fails!!
    pszNext = _tcschr(pszPhone, TEXT(':'));
    if(pszNext) *pszNext=TEXT('\0');
    //lstrcpy(ppn->szLocal,pszPhone);
    lstrcpy(prasentry->szLocalPhoneNumber,pszPhone);
    //LocalFree(pszPhone);
    return TRUE;
}


// ############################################################################
int Sz2W (LPCTSTR szBuf)
{
    DWORD dw;
    if (FSz2Dw(szBuf,&dw))
    {
        return (WORD)dw;
    }
    return 0;
}

// ############################################################################
int FIsDigit( int c )
{
    TCHAR  szIn[2];
    WORD   rwOut[2];
    szIn[0] = (TCHAR)c;
    szIn[1] = TEXT('\0');
    GetStringTypeEx(LOCALE_USER_DEFAULT,CT_CTYPE1,szIn,-1,rwOut);
    return rwOut[0] & C1_DIGIT;

}

// ############################################################################
LPBYTE MyMemSet(LPBYTE dest,int c, size_t count)
{
    LPVOID pv = dest;
    LPVOID pvEnd = (LPVOID)(dest + (WORD)count);
    while (pv < pvEnd)
    {
        *(LPINT)pv = c;
        //((WORD)pv)++;
        pv=((LPINT)pv)+1;
    }
    return dest;
}

// ############################################################################
LPBYTE MyMemCpy(LPBYTE dest,const LPBYTE src, size_t count)
{
    LPBYTE pbDest = (LPBYTE)dest;
    LPBYTE pbSrc = (LPBYTE)src;
    LPBYTE pbEnd = (LPBYTE)((DWORD_PTR)src + count);
    while (pbSrc < pbEnd)
    {
        *pbDest = *pbSrc;
        pbSrc++;
        pbDest++;
    }
    return dest;
}

// ############################################################################
BOOL ShowControl(HWND hDlg,int idControl,BOOL fShow)
{
    HWND hWnd;

    if (NULL == hDlg)
    {
        AssertMsg(0,TEXT("Null Param"));
        return FALSE;
    }


    hWnd = GetDlgItem(hDlg,idControl);
    if (hWnd)
    {
        ShowWindow(hWnd,fShow ? SW_SHOW : SW_HIDE);
    }

    return TRUE;
}

BOOL isAlnum(TCHAR c)
{
    if ((c >= TEXT('0') && c <= TEXT('9') ) ||
        (c >= TEXT('a') && c <= TEXT('z') ) ||
        (c >= TEXT('A') && c <= TEXT('Z') ))
        return TRUE;
    return FALSE;
}

// ############################################################################
HRESULT ANSI2URLValue(TCHAR *s, TCHAR *buf, UINT uiLen)
{
    HRESULT hr;
    TCHAR *t;
    hr = ERROR_SUCCESS;

    for (t=buf;*s; s++)
    {
        if (*s == TEXT(' ')) *t++ = TEXT('+');
        else if (isAlnum(*s)) *t++ = *s;
        else {
            wsprintf(t, TEXT("%%%02X"), (unsigned char) *s);
            t += 3;
        }
    }
    *t = TEXT('\0');
    return hr;
}

// ############################################################################
LPTSTR FileToPath(LPTSTR pszFile)
{
    TCHAR  szBuf[MAX_PATH+1];
    TCHAR  szTemp[MAX_PATH+1];
    LPTSTR pszTemp;
    LPTSTR pszTemp2;
    LPTSTR pszHold = pszFile;
    int    j;

    for(j=0; *pszFile; pszFile++)
    {
        if(j>=MAX_PATH)
                return NULL;
        if(*pszFile==TEXT('%'))
        {
            pszFile++;
            pszTemp = _tcschr(pszFile, TEXT('%'));
            if(!pszTemp)
                    return NULL;
            *pszTemp = 0;
            if(lstrcmpi(pszFile, DIR_SIGNUP)==0)
            {
                LPTSTR pszCmdLine = GetCommandLine();
                _tcsncpy(szTemp, pszCmdLine, MAX_PATH);
                szBuf[MAX_PATH] = 0;
                pszTemp = _tcstok(szTemp, TEXT(" \t\r\n"));
                pszTemp2 = _tcsrchr(pszTemp, TEXT('\\'));
                if(!pszTemp2) pszTemp2 = _tcsrchr(pszTemp, TEXT('/'));
                if(pszTemp2)
                {
                    *pszTemp2 = 0;
                    lstrcpy(szBuf+j, pszTemp);
                }
                else
                {
                    Assert(FALSE);
                    GetCurrentDirectory(MAX_PATH, szTemp);
                    szTemp[MAX_PATH] = 0;
                    lstrcpy(szBuf+j, pszTemp);
                }
                
                j+= lstrlen(pszTemp);
            }
            else if(lstrcmpi(pszFile, DIR_WINDOWS)==0)
            {
                GetWindowsDirectory(szTemp, MAX_PATH);
                szTemp[MAX_PATH] = 0;
                lstrcpy(szBuf+j, szTemp);
                j+= lstrlen(szTemp);
            }
            else if(lstrcmpi(pszFile, DIR_SYSTEM)==0)
            {
                GetSystemDirectory(szTemp, MAX_PATH);
                szTemp[MAX_PATH] = 0;
                lstrcpy(szBuf+j, szTemp);
                j+= lstrlen(szTemp);
            }
            else if(lstrcmpi(pszFile, DIR_TEMP)==0)
            {
                // 3/18/97 ChrisK Olympus 304
                MyGetTempPath(MAX_PATH, &szTemp[0]);
                szTemp[MAX_PATH] = 0;
                if(szTemp[lstrlen(szTemp)-1]==TEXT('\\'))
                    szTemp[lstrlen(szTemp)-1]=0;
                lstrcpy(szBuf+j, szTemp);
                j+= lstrlen(szTemp);
            }
            else
                    return NULL;
            pszFile=pszTemp;
        }
        else
            szBuf[j++] = *pszFile;
    }
    szBuf[j] = 0;
    TraceMsg(TF_GENERAL, TEXT("CONNECT:File to Path output ,%s.\n"),szBuf);
    return lstrcpy(pszHold,&szBuf[0]);
}

// ############################################################################
BOOL FShouldRetry2(HRESULT hrErr)
{
    BOOL bRC;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    return bRC;
}

#if 0
// DJM I don't this we will need this
//+----------------------------------------------------------------------------
//
//    Function:    FGetSystemShutdownPrivledge
//
//    Synopsis:    For windows NT the process must explicitly ask for permission
//                to reboot the system.
//
//    Arguements:    none
//
//    Return:        TRUE - privledges granted
//                FALSE - DENIED
//
//    History:    8/14/96    ChrisK    Created
//
//    Note:        BUGBUG for Win95 we are going to have to softlink to these
//                entry points.  Otherwise the app won't even load.
//                Also, this code was originally lifted out of MSDN July96
//                "Shutting down the system"
//-----------------------------------------------------------------------------
BOOL FGetSystemShutdownPrivledge()
{
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;
 
    BOOL bRC = FALSE;

    if (VER_PLATFORM_WIN32_NT == g_dwPlatform)
    {
        // 
        // Get the current process token handle 
        // so we can get shutdown privilege. 
        //

        if (!OpenProcessToken(GetCurrentProcess(), 
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
                goto FGetSystemShutdownPrivledgeExit;

        //
        // Get the LUID for shutdown privilege.
        //

        ZeroMemory(&tkp,sizeof(tkp));
        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
                &tkp.Privileges[0].Luid); 

        tkp.PrivilegeCount = 1;  /* one privilege to set    */ 
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

        //
        // Get shutdown privilege for this process.
        //

        AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
            (PTOKEN_PRIVILEGES) NULL, 0); 

        if (ERROR_SUCCESS == GetLastError())
            bRC = TRUE;
    }
    else
    {
        bRC = TRUE;
    }

FGetSystemShutdownPrivledgeExit:
    if (hToken) CloseHandle(hToken);
    return bRC;
}
#endif

//+----------------------------------------------------------------------------
//
//    Function:    LoadTestingLocaleOverride
//
//    Synopsis:    Allow the testers to override the locale information sent to
//                the referal server
//
//    Arguments:    lpdwCountryID - pointer to country ID
//                lplcid - pointer to current lcid
//
//    Returns:    none
//
//    History:    8/15/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#if defined(DEBUG)
void LoadTestingLocaleOverride(LPDWORD lpdwCountryID, LCID FAR *lplcid)
{
    HKEY hkey = NULL;
    LONG lRC = ERROR_SUCCESS;
    DWORD dwTemp = 0;
    LCID lcidTemp = 0;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    BOOL fWarn = FALSE;

    Assert(lpdwCountryID && lplcid);

    //
    // Open debug key
    //
    lRC = RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey);
    if (ERROR_SUCCESS != lRC)
        goto LoadTestingLocaleOverrideExit;

    //
    //    Get CountryID
    //
    dwSize = sizeof(dwTemp);
    lRC = RegQueryValueEx(hkey,TEXT("CountryID"),0,&dwType,(LPBYTE)&dwTemp,&dwSize);
    AssertMsg(lRC || REG_DWORD == dwType,TEXT("Wrong value type for CountryID.  Must be DWORD.\r\n"));
    if (ERROR_SUCCESS==lRC)
    {
        *lpdwCountryID = dwTemp;
        fWarn = TRUE;
    }

    //
    //    Get LCID
    //
    dwSize = sizeof(lcidTemp);
    lRC = RegQueryValueEx(hkey,TEXT("LCID"),0,&dwType,(LPBYTE)&lcidTemp,&dwSize);
    AssertMsg(lRC || REG_DWORD == dwType,TEXT("Wrong value type for LCID.  Must be DWORD.\r\n"));
    if (ERROR_SUCCESS==lRC)
    {
        *lplcid = lcidTemp;
        fWarn = TRUE;
    }

    //
    // Inform the user that overrides have been used
    //
    if (fWarn)
    {
        MessageBox(NULL,TEXT("DEBUG ONLY: LCID and/or CountryID overrides from the registry are now being used."),TEXT("Testing Override"),0);
    }

LoadTestingLocaleOverrideExit:
    if (hkey)
        RegCloseKey(hkey);
    hkey = NULL;
    return;
}
#endif //DEBUG

//+----------------------------------------------------------------------------
//
//    Function:    FCampusNetOverride
//
//    Synopsis:    Detect if the dial should be skipped for the campus network
//
//    Arguments:    None
//
//    Returns:    TRUE - overide enabled
//
//    History:    8/15/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
#if defined(DEBUG)
BOOL FCampusNetOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey))
        goto FCampusNetOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("CampusNet"),0,&dwType,
        (LPBYTE)&dwData,&dwSize))
        goto FCampusNetOverrideExit;

    AssertMsg(REG_DWORD == dwType,TEXT("Wrong value type for CampusNet.  Must be DWORD.\r\n"));
    bRC = (0 != dwData);

    if (bRC)
    {
        if (IDOK != MessageBox(NULL,TEXT("DEBUG ONLY: CampusNet will be used."),TEXT("Testing Override"),MB_OKCANCEL))
            bRC = FALSE;
    }
FCampusNetOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}
#endif //DEBUG

#if defined(DEBUG)
BOOL FRefURLOverride()
{
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\ISignup\\Debug"),&hkey))
        goto FRefURLOverrideExit;

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,TEXT("TweakURL"),0,&dwType,
        (LPBYTE)&dwData,&dwSize))
        goto FRefURLOverrideExit;

    AssertMsg(REG_DWORD == dwType,TEXT("Wrong value type for TweakURL.  Must be DWORD.\r\n"));
    bRC = (0 != dwData);

    if (bRC)
    {
        if (IDOK != MessageBox(NULL,TEXT("DEBUG ONLY: TweakURL settings will be used."),TEXT("Testing Override"),MB_OKCANCEL))
            bRC = FALSE;
    }
FRefURLOverrideExit:
    if (hkey)
        RegCloseKey(hkey);

    return bRC;
}

void TweakRefURL( TCHAR* szUrl, 
                  LCID*  lcid, 
                  DWORD* dwOS,
                  DWORD* dwMajorVersion, 
                  DWORD* dwMinorVersion,
                  WORD*  wArchitecture, 
                  TCHAR* szPromo, 
                  TCHAR* szOEM, 
                  TCHAR* szArea, 
                  DWORD* dwCountry,
                  TCHAR* szSUVersion,//&m_lpGatherInfo->m_szSUVersion[0],  
                  TCHAR* szProd, 
                  DWORD* dwBuildNumber, 
                  TCHAR* szRelProd, 
                  TCHAR* szRelProdVer, 
                  DWORD* dwCONNWIZVersion, 
                  TCHAR* szPID, 
                  long*  lAllOffers)
{
    HKEY  hKey = NULL;
    BOOL  bRC = FALSE;
    BYTE  bData[MAX_PATH*3];
    DWORD cbData = MAX_PATH*3;          
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwData = 0;

    dwSize = sizeof(dwData);
      
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ISignup\\Debug\\TweakURLValues"),&hKey))
    {
       //szURL
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("URL"), NULL ,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szUrl, (TCHAR*)&bData);             
          }
       }
       //lcid
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("LCID"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *lcid = dwData;
       }
       //dwOS
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("OS"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwOS = dwData;
       }
       //dwMajorVersion
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("MajorVer"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwMajorVersion = dwData;
       }
       //dwMinorVersion
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("MinorVer"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwMinorVersion = dwData;
       }
       //wArchitecture
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("SysArch"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *wArchitecture = (WORD)dwData;
       }
       //szPromo
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Promo"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szPromo, (TCHAR*)&bData);             
          }
       }
       //szOEM
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("OEM"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szOEM, (TCHAR*)&bData);             
          }
       }
       //szArea
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Area"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szArea, (TCHAR*)&bData);             
          }
       }
       //dwCountry
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Country"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwCountry = dwData;
       }
       //szSUVersion
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("SUVer"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_VERSION_LEN))
          {
              lstrcpy(szSUVersion, (TCHAR*)&bData);             
          }
       }
       //szProd
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("Product"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szProd, (TCHAR*)&bData);             
          }
       }
       //dwBuildNumber
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("BuildNum"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwBuildNumber = dwData;
       }
       //szRelProd
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("RelProd"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szRelProd, (TCHAR*)&bData);             
          }
       } 
       //szRelProdVer
       cbData = sizeof(TCHAR)*(MAX_PATH*3);  
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("RelProdVer"),0,&dwType, bData, &cbData))
       {
          if ((cbData > 1) && (cbData <= MAX_PATH))
          {
              lstrcpy(szRelProdVer, (TCHAR*)&bData);             
          }
       }
       //dwCONNWIZVersion
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("ConnwizVer"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *dwCONNWIZVersion = dwData;
       }
       //szPID
       BYTE byDigitalPID[MAX_DIGITAL_PID];
       DWORD dwType2 = REG_BINARY;
       DWORD dwSize2 = sizeof(byDigitalPID);
       if (RegQueryValueEx(hKey,
                            TEXT("PID"),
                            NULL,
                            &dwType2,
                            (LPBYTE)byDigitalPID,
                            &dwSize2) == ERROR_SUCCESS)
       {
           if ((dwSize2 > 1) && (dwSize2 <= ((MAX_DIGITAL_PID * 2) + 1)))
           {
               // BINHEX the digital PID data so we can send it to the ref_server
               int     i = 0;
               BYTE    by;
               for (DWORD dwX = 0; dwX < dwSize2; dwX++)
               {
                   by = byDigitalPID[dwX];
                   szPID[i++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                   szPID[i++] = g_BINTOHEXLookup[(by & 0x0F)];
               }
               szPID[i] = TEXT('\0');
           }
           else
           {
               szPID[0] = TEXT('\0');
           }
       }

       //lAllOffers
       if (ERROR_SUCCESS == RegQueryValueEx(hKey,TEXT("AllOffers"),0,&dwType, (LPBYTE)&dwData, &dwSize))
       {
          if (dwData != 0)
            *lAllOffers = dwData;
       }
    }
    if (hKey)
        RegCloseKey(hKey);
}

#endif //DEBUG
   
   
//+----------------------------------------------------------------------------
//    Function    CopyUntil
//
//    Synopsis    Copy from source until destination until running out of source
//                or until the next character of the source is the chend character
//
//    Arguments    dest - buffer to recieve characters
//                src - source buffer
//                lpdwLen - length of dest buffer
//                chend - the terminating character
//
//    Returns        FALSE - ran out of room in dest buffer
//
//    Histroy        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
static BOOL CopyUntil(LPTSTR *dest, LPTSTR *src, LPDWORD lpdwLen, TCHAR chend)
{
    while ((TEXT('\0') != **src) && (chend != **src) && (0 != *lpdwLen))
    {
        **dest = **src;
        (*lpdwLen)--;
        (*dest)++;
        (*src)++;
    }
    return (0 != *lpdwLen);
}

//+----------------------------------------------------------------------------
//    Function    ConvertToLongFilename
//
//    Synopsis    convert a file to the full long file name
//                ie. c:\progra~1\icw-in~1\isignup.exe becomes
//                c:\program files\icw-internet connection wizard\isignup.exe
//
//    Arguments    szOut - output buffer
//                szIn - filename to be converted
//                dwSize - size of the output buffer
//
//    Returns        TRUE - success
//
//    History        10/25/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL ConvertToLongFilename(LPTSTR szOut, LPTSTR szIn, DWORD dwSize)
{
    BOOL   bRC = FALSE;
    LPTSTR pCur = szIn;
    LPTSTR pCurOut = szOut;
    LPTSTR pCurOutFilename = NULL;
    WIN32_FIND_DATA fd;
    DWORD  dwSizeTemp;
    LPTSTR pTemp = NULL;

    ZeroMemory(pCurOut,dwSize);

    //
    // Validate parameters
    //
    if (NULL != pCurOut && NULL != pCur && 0 != dwSize)
    {
        //
        // Copy drive letter
        //
        if (!CopyUntil(&pCurOut,&pCur,&dwSize,TEXT('\\')))
            goto ConvertToLongFilenameExit;
        pCurOut[0] = TEXT('\\');
        dwSize--;
        pCur++;
        pCurOut++;
        pCurOutFilename = pCurOut;

        while (*pCur)
        {
            //
            // Copy over possibly short name
            //
            pCurOut = pCurOutFilename;
            dwSizeTemp = dwSize;
            if (!CopyUntil(&pCurOut,&pCur,&dwSize,TEXT('\\')))
                goto ConvertToLongFilenameExit;

            ZeroMemory(&fd, sizeof(fd));
            //
            // Get long filename
            //
            if (INVALID_HANDLE_VALUE != FindFirstFile(szOut,&fd))
            {
                //
                // Replace short filename with long filename
                //
                dwSize = dwSizeTemp;
                pTemp = &(fd.cFileName[0]);
                if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,TEXT('\0')))
                    goto ConvertToLongFilenameExit;
                if (*pCur)
                {
                    //
                    // If there is another section then we just copied a directory
                    // name.  Append a \ character;
                    //
                    pTemp = (LPTSTR)memcpy(TEXT("\\X"),TEXT("\\X"),0);
                    if (!CopyUntil(&pCurOutFilename,&pTemp,&dwSize,TEXT('X')))
                        goto ConvertToLongFilenameExit;
                    pCur++;
                }
            }
            else
            {
                break;
            }
        }
        //
        // Did we get to the end (TRUE) or fail before that (FALSE)?
        //
        bRC = (TEXT('\0') == *pCur);
    }
ConvertToLongFilenameExit:
    return bRC;
}

#if 0
// DJM I don't think we need this
//+----------------------------------------------------------------------------
//
//    Function:    GetIEVersion
//
//    Synopsis:    Gets the major and minor version # of the installed copy of Internet Explorer
//
//    Arguments:    pdwVerNumMS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the major version number,
//                  and the lower 16 bits will contain the minor version number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionMS)
//                pdwVerNumLS - pointer to a DWORD;
//                  On succesful return, the top 16 bits will contain the release number,
//                  and the lower 16 bits will contain the build number
//                  (this is the data in VS_FIXEDFILEINFO.dwProductVersionLS)
//
//    Returns:    TRUE - Success.  *pdwVerNumMS and LS contains installed IE version number
//                FALSE - Failure. *pdVerNumMS == *pdVerNumLS == 0
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//                jmazner        updated to deal with release.build as well 10/11/96
//                jmazner        stolen from isign32\isignup.cpp 11/21/96
//                            (for Normandy #11812)
//
//-----------------------------------------------------------------------------
BOOL GetIEVersion(PDWORD pdwVerNumMS, PDWORD pdwVerNumLS)
{
    HRESULT hr;
    HKEY hKey = 0;
    LPVOID lpVerInfoBlock;
    VS_FIXEDFILEINFO *lpTheVerInfo;
    UINT uTheVerInfoSize;
    DWORD dwVerInfoBlockSize, dwUnused, dwPathSize;
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");


    *pdwVerNumMS = 0;
    *pdwVerNumLS = 0;

    // get path to the IE executable
    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, IE_PATHKEY,0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );

    // now go through the convoluted process of digging up the version info
    dwVerInfoBlockSize = GetFileVersionInfoSize( szIELocalPath, &dwUnused );
    if ( 0 == dwVerInfoBlockSize ) return( FALSE );

    lpVerInfoBlock = GlobalAlloc( GPTR, dwVerInfoBlockSize );
    if( NULL == lpVerInfoBlock ) return( FALSE );

    if( !GetFileVersionInfo( szIELocalPath, NULL, dwVerInfoBlockSize, lpVerInfoBlock ) )
        return( FALSE );

    if( !VerQueryValue(lpVerInfoBlock, TEXT("\\"), (void **)&lpTheVerInfo, &uTheVerInfoSize) )
        return( FALSE );

    *pdwVerNumMS = lpTheVerInfo->dwProductVersionMS;
    *pdwVerNumLS = lpTheVerInfo->dwProductVersionLS;


    GlobalFree( lpVerInfoBlock );

    return( TRUE );
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   GenericMsg
//
//----------------------------------------------------------------------------
void GenericMsg
(
    HWND    hwnd,
    UINT    uId,
    LPCTSTR  lpszArg,
    UINT    uType
)
{
    TCHAR szTemp[MAX_STRING + 1];
    TCHAR szMsg[MAX_STRING + MAX_PATH + 1];

    Assert( lstrlen( GetSz((USHORT)uId) ) <= MAX_STRING );

    lstrcpy( szTemp, GetSz( (USHORT)uId ) );

    if (lpszArg)
    {
        Assert( lstrlen( lpszArg ) <= MAX_PATH );
        wsprintf(szMsg, szTemp, lpszArg);
    }
    else
    {
        lstrcpy(szMsg, szTemp);
    }
    MessageBox(hwnd,
               szMsg,
               GetSz(IDS_TITLE),
               uType);
}
//+---------------------------------------------------------------------------
//
//  Function:   ErrorMsg1()
//
//  Synopsis:   1 stop shopping for showing a msgBox when you need to wsprintf the string to be displayed
//
//                Displays an error dialog from a string resource with a "%s" format command,
//                and a string argument to stick into it.
//
//  Arguments:  hwnd -- Handle of parent window  
//                uID -- ID of a string resource with a %s argument
//                lpszArg -- pointer to a string to fill into the %s in uID string
//
//
//  History:    9/18/96        jmazner        copied from isign32\utils.cpp (for Normandy 7537)
//                                        modified to work in conn1
//
//----------------------------------------------------------------------------
void ErrorMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg)
{
    GenericMsg(hwnd, 
               uId, 
               lpszArg, 
               MB_ICONERROR | MB_SETFOREGROUND | MB_OK | MB_APPLMODAL);
}

//+---------------------------------------------------------------------------
//
//  Function:   InfoMsg1()
//
//----------------------------------------------------------------------------
void InfoMsg1(HWND hwnd, UINT uId, LPCTSTR lpszArg)
{
    GenericMsg(hwnd, 
               uId, 
               lpszArg, 
               MB_ICONINFORMATION | MB_SETFOREGROUND | MB_OK | MB_APPLMODAL);
}


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPTSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        AssertMsg(0,TEXT("Bogus String Type."));
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
#ifndef UNICODE // this module is not necessary for Unicode.
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    TCHAR szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(_Module.GetModuleInstance(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);

}
#endif

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\refdial.cpp ===
//**********************************************************************
// File name: RefDial.cpp
//
//      Implementation of CRefDial
//
// Functions:
//
// Copyright (c) 1992 - 1999 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "stdafx.h"
#include "icwhelp.h"
#include "RefDial.h"
#include "appdefs.h"
#include <regstr.h>

#include <urlmon.h>
#include <mshtmhst.h>
const TCHAR  c_szCreditsMagicNum[] =    TEXT("1 425 555 1212");

const TCHAR c_szRegStrValDigitalPID[] = TEXT("DigitalProductId");
const TCHAR c_szSignedPIDFName[] =      TEXT("signed.pid");

const TCHAR c_szRASProfiles[] =         TEXT("RemoteAccess\\Profile");
const TCHAR c_szProxyEnable[] =         TEXT("ProxyEnable");

TCHAR g_BINTOHEXLookup[16] = 
{
    TEXT('0'),
    TEXT('1'),
    TEXT('2'),
    TEXT('3'),
    TEXT('4'),
    TEXT('5'),
    TEXT('6'),
    TEXT('7'),
    TEXT('8'),
    TEXT('9'),
    TEXT('A'),
    TEXT('B'),
    TEXT('C'),
    TEXT('D'),
    TEXT('E'),
    TEXT('F')
};

typedef DWORD (WINAPI * GETICWCONNVER) ();
GETICWCONNVER  lpfnGetIcwconnVer;

HWND g_hwndRNAApp = NULL;
    
/////////////////////////////////////////////////////////////////////////////
// CRefDial

HRESULT CRefDial::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

LRESULT CRefDial::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Register the RASDIALEVENT message
    m_unRasDialMsg = RegisterWindowMessageA( RASDIALEVENT );
    if (m_unRasDialMsg == 0)
    {
        m_unRasDialMsg = WM_RASDIALEVENT;
    }
    
    // Make sure the window is hidden
    ShowWindow(SW_HIDE);
    return 0;
}

LRESULT CRefDial::OnDownloadEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    USES_CONVERSION;
    if (uMsg == WM_DOWNLOAD_DONE)
    {
        DWORD   dwThreadResults = STILL_ACTIVE;
        int     iRetries = 0;

        // We keep the RAS connection open here, it must be explicitly 
        // close by the container (a call DoHangup)
        // This code will wait until the download thread exists, and
        // collect the download status.
        do {
            if (!GetExitCodeThread(m_hThread,&dwThreadResults))
            {
                AssertMsg(0,TEXT("CONNECT:GetExitCodeThread failed.\n"));
            }

            iRetries++;
            if (dwThreadResults  == STILL_ACTIVE) 
                Sleep(500);
        } while (dwThreadResults == STILL_ACTIVE && iRetries < MAX_EXIT_RETRIES);  

        
        // See if there is an URL to pass to the container
        BSTR    bstrURL;
        if (m_szRefServerURL[0] != TEXT('\0'))
            bstrURL = (BSTR)A2BSTR(m_szRefServerURL);
        else
            bstrURL = NULL;

        m_RasStatusID    = IDS_DOWNLOAD_COMPLETE;
        Fire_DownloadComplete(bstrURL, dwThreadResults);
        
        // The download is complete now, so we reset this to TRUE, so the RAS
        // event handler does not get confused
        m_bDownloadHasBeenCanceled = TRUE;
        
        // Free any memory allocated above during the conversion
        SysFreeString(bstrURL);

    }
    else if (uMsg == WM_DOWNLOAD_PROGRESS)
    {
        // Fire a progress event to the container
        m_RasStatusID = IDS_DOWNLOADING;
        Fire_DownloadProgress((long)wParam);
    }
    return 0;
}

static const TCHAR szRnaAppWindowClass[] = _T("#32770");    // hard coded dialog class name

BOOL NeedZapperEx(void)
{
    OSVERSIONINFO oi;
    memset(&oi, 0, sizeof(oi));
    oi.dwOSVersionInfoSize = sizeof(oi);

    if( GetVersionEx(&oi) && 
       (oi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) &&
       (oi.dwMajorVersion==4) &&
       (oi.dwMinorVersion==0) &&
       (LOWORD(oi.dwBuildNumber) <= 1070) )
            return TRUE;
    else
            return FALSE;
}

void GetRNAWindowEx()
{
    TCHAR szTitle[MAX_PATH] = TEXT("\0");

    if (!LoadString(_Module.GetModuleInstance(), IDS_CONNECTED, szTitle, sizeof(szTitle)))
        lstrcpy(szTitle , _T("Connected To "));

    g_hwndRNAApp = FindWindow(szRnaAppWindowClass, szTitle);
}

BOOL MinimizeRNAWindowEx()
{
    if(g_hwndRNAApp)
    {
        // Get the main frame window's style
        LONG window_style = GetWindowLong(g_hwndRNAApp, GWL_STYLE);

        //Remove the system menu from the window's style
        window_style |= WS_MINIMIZE;
        
        //set the style attribute of the main frame window
        SetWindowLong(g_hwndRNAApp, GWL_STYLE, window_style);

        ShowWindow(g_hwndRNAApp, SW_MINIMIZE);

        return TRUE;
    }
    return FALSE;
}

LRESULT CRefDial::OnRasDialEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RNAAPI* pcRNA;

    TraceMsg(TF_GENERAL, TEXT("ICWHELP: Ras event %u error code (%ld)\n"),wParam,lParam);

    TCHAR dzRasError[10];
    wsprintf(dzRasError,TEXT("%d %d"),wParam,lParam);
    RegSetValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\iSignUp"),REG_SZ,dzRasError,lstrlen(dzRasError)+1);

    // In NT4, it gives wParma with error code in lParam rather than a
    // actual wParam message
    if (lParam)
    {
         wParam = RASCS_Disconnected;
    }

    m_RasStatusID = 0;
    switch(wParam)
    {
        case RASCS_OpenPort:
            m_RasStatusID    = IDS_RAS_OPENPORT;
            break;
        case RASCS_PortOpened:
            m_RasStatusID    = IDS_RAS_PORTOPENED;
            break;
        case RASCS_ConnectDevice:
            m_RasStatusID    = IDS_RAS_DIALING;
            break;
        case RASCS_DeviceConnected:
            m_RasStatusID    = IDS_RAS_CONNECTED;
            break;
        case RASCS_AllDevicesConnected:
            m_RasStatusID    = IDS_RAS_CONNECTED;
            break; 
        case RASCS_Authenticate:
            m_RasStatusID    = IDS_RAS_CONNECTING;
            break;
        case RASCS_StartAuthentication:
        case RASCS_LogonNetwork:
            m_RasStatusID    = IDS_RAS_LOCATING;
            break;  
        case RASCS_Connected:
        {
            m_RasStatusID = IDS_RAS_CONNECTED;

            //
            // Hide RNA window on Win95 retail
            //
            if (NeedZapperEx())
                GetRNAWindowEx();
            
            break;
        }
        case RASCS_Disconnected:
            // Normandy 13184 - ChrisK 1-9-97
            m_RasStatusID    = IDS_RAS_HANGINGUP;
            IF_NTONLY
                // jmazner Normandy #5603 ported from ChrisK's fix in icwdial
                // There is a possibility that we will get multiple disconnects in NT
                // and we only want to handle the first one. Note: the flag is reset
                // in the INITIALIZE event, so we should handle 1 disconnect per instance
                // of the dialog.
                if (m_bDisconnect)
                    break;
                else
                    m_bDisconnect = TRUE;
            ENDIF_NTONLY
            //
            // If we are in the middle of a download, cancel the it!
            //
                //
            // ChrisK 5240 Olympus
            // Only the thread that creates the dwDownload should invalidate it
            // so we need another method to track if the cancel button has been
            // pressed.
            //
            if (!m_bDownloadHasBeenCanceled)
            {
                HINSTANCE hDLDLL = LoadLibrary(DOWNLOAD_LIBRARY);
                if (hDLDLL)
                {
                    FARPROC fp = GetProcAddress(hDLDLL,DOWNLOADCANCEL);
                    if(fp)
                        ((PFNDOWNLOADCANCEL)fp)(m_dwDownLoad);
                    FreeLibrary(hDLDLL);
                    hDLDLL = NULL;
                    m_bDownloadHasBeenCanceled = TRUE;
                }
            }

            // If we get a disconnected status from the RAS server, then
            // hangup the modem here
            if (m_hrasconn)
            {  
                pcRNA = new RNAAPI;
                if (pcRNA)
                {
                    pcRNA->RasHangUp(m_hrasconn);
                    m_hrasconn = NULL;
                    delete pcRNA;
                    pcRNA = NULL;
                }
            }
            break;
    }

    // Fire the event to the container.
    Fire_RasDialStatus((USHORT)wParam);

    // If we are connected then fire an event telling the container
    // that we are ready
    if (wParam == RASCS_Connected)
        Fire_RasConnectComplete(TRUE);
    else if (wParam == RASCS_Disconnected)
    {
        m_hrDialErr = (HRESULT)lParam;
        Fire_RasConnectComplete(FALSE);
    }

    return 0;
}

STDMETHODIMP CRefDial::get_DownloadStatusString(BSTR * pVal)
{
    USES_CONVERSION;
    if (pVal == NULL)
         return E_POINTER;
    if (m_DownloadStatusID)
        *pVal = (BSTR)A2BSTR(GetSz((USHORT)m_DownloadStatusID));
    else
        *pVal = (BSTR)A2BSTR(TEXT(""));

    return S_OK;
}

/******************************************************************************
// These functions come from the existing ICW code and are use to setup a 
// connectiod to the referral server, dial it, and perform the download.
******************************************************************************/

//+----------------------------------------------------------------------------
//    Function:    ReadConnectionInformation
//
//    Synopsis:    Read the contents from the ISP file
//
//    Arguments:    none
//
//    Returns:    error value - ERROR_SUCCESS = succes
//
//    History:    1/9/98      DONALDM     Adapted from ICW 1.x
//-----------------------------------------------------------------------------
DWORD CRefDial::ReadConnectionInformation(void)
{
    USES_CONVERSION;
    DWORD       hr;
    TCHAR       szUserName[UNLEN+1];
    TCHAR       szPassword[PWLEN+1];
    LPTSTR      pszTemp;
    BOOL        bReboot;
    LPTSTR      lpRunOnceCmd;
            
    bReboot = FALSE;
    lpRunOnceCmd = NULL;


    //
    // Get the name of DUN file from ISP file, if there is one.
    //
    TCHAR pszDunFile[MAX_PATH];
#ifdef UNICODE
    hr = GetDataFromISPFile(m_bstrISPFile,INF_SECTION_ISPINFO, INF_DUN_FILE, pszDunFile,MAX_PATH);
#else
    hr = GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_DUN_FILE, pszDunFile,MAX_PATH);
#endif
    if (ERROR_SUCCESS == hr) 
    {
        //
        // Get the full path to the DUN File
        //
        TCHAR    szTempPath[MAX_PATH];
        lstrcpy(szTempPath,pszDunFile);
        if (!(hr = SearchPath(NULL,szTempPath,NULL,MAX_PATH,pszDunFile,&pszTemp)))
        {
            ErrorMsg1(m_hWnd, IDS_CANTREADTHISFILE, CharUpper(pszDunFile));
            goto ReadConnectionInformationExit;
        } 

        //
        // save current DUN file name in global (for ourself)
        //
        lstrcpy(m_szCurrentDUNFile, pszDunFile);
    }
    
    //
    // Read the DUN/ISP file File
    //
    hr = m_ISPImport.ImportConnection(m_szCurrentDUNFile[0] != '\0' ? m_szCurrentDUNFile : OLE2A(m_bstrISPFile), 
                                      m_szISPSupportNumber,
                                      m_szEntryName,
                                      szUserName, 
                                      szPassword, 
                                      &bReboot);

    if ((VER_PLATFORM_WIN32_NT == g_dwPlatform) && (ERROR_INVALID_PARAMETER == hr))
    {
        // If there are only dial-out entries configured on NT, we get
        // ERROR_INVALID_PARAMETER returned from RasSetEntryProperties,
        // which InetConfigClient returns to ImportConnection which
        // returns it to us.  If we get this error, we want to display
        // a different error instructing the user to configure a modem
        // for dial-out.
        MessageBox(GetSz(IDS_NODIALOUT),
                   GetSz(IDS_TITLE),
                   MB_ICONERROR | MB_OK | MB_APPLMODAL);
        goto ReadConnectionInformationExit;
    }
    else
    if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == hr)
    {
        //
        // The disk is full, or something is wrong with the
        // phone book file
        MessageBox(GetSz(IDS_NOPHONEENTRY),
                   GetSz(IDS_TITLE),
                   MB_ICONERROR | MB_OK | MB_APPLMODAL);
        goto ReadConnectionInformationExit;
    }
    else if (hr == ERROR_CANCELLED)
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP: User cancelled, quitting.\n"));
        goto ReadConnectionInformationExit;
    }
    else if (hr == ERROR_RETRY)
    {
        TraceMsg(TF_GENERAL, TEXT("ICWHELP: User retrying.\n"));
        goto ReadConnectionInformationExit;
    }
    else if (hr != ERROR_SUCCESS) 
    {
        ErrorMsg1(m_hWnd, IDS_CANTREADTHISFILE, CharUpper(pszDunFile));
        goto ReadConnectionInformationExit;
    } 
    else 
    {

        //
        // place the name of the connectoid in the registry
        //
        if (ERROR_SUCCESS != (hr = StoreInSignUpReg((LPBYTE)m_szEntryName, lstrlen(m_szEntryName)+1, REG_SZ, RASENTRYVALUENAME)))
        {
            MsgBox(IDS_CANTSAVEKEY,MB_MYERROR);
            goto ReadConnectionInformationExit;
        }
    }

    AssertMsg(!bReboot, TEXT("ICWHELP: We should never reboot here.\r\n"));
ReadConnectionInformationExit:
    return hr;
}

HRESULT CRefDial::GetDisplayableNumber()
{
    HRESULT                 hr = ERROR_SUCCESS;
    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    LPLINETRANSLATEOUTPUT   lpOutput1 = NULL;

    DWORD dwNumDev;
    LPLINETRANSLATEOUTPUT lpOutput2;
    LPLINEEXTENSIONID lpExtensionID = NULL;
    
    //
    // Get phone number from connectoid
    //
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);


    if (hr != ERROR_SUCCESS || NULL == lpRasEntry)
    {
        goto GetDisplayableNumberExit;
    }

    //
    // If this is a dial as is number, just get it from the structure
    //
    m_bDialAsIs = !(lpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);
    if (m_bDialAsIs)
    {
        if (m_pszDisplayable) GlobalFree(m_pszDisplayable);
        m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, sizeof(TCHAR)*(lstrlen(lpRasEntry->szLocalPhoneNumber)+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lstrcpy(m_szPhoneNumber, lpRasEntry->szLocalPhoneNumber);
        lstrcpy(m_pszDisplayable, lpRasEntry->szLocalPhoneNumber);
        TCHAR szAreaCode[MAX_AREACODE+1];
        TCHAR szCountryCode[8];
        if (SUCCEEDED(tapiGetLocationInfo(szCountryCode,szAreaCode)))
        {
            if (szCountryCode[0] != '\0')
                m_dwCountryCode = _ttoi(szCountryCode);
            else    
                m_dwCountryCode = 1;
        }
        else
        {
            m_dwCountryCode = 1;
            
        }

    }
    else
    {
        //
        // If there is no area code, don't use parentheses
        //
        if (lpRasEntry->szAreaCode[0])
            wsprintf(m_szPhoneNumber,TEXT("+%lu (%s) %s\0"),lpRasEntry->dwCountryCode,
                        lpRasEntry->szAreaCode,lpRasEntry->szLocalPhoneNumber);
        else
            wsprintf(m_szPhoneNumber,TEXT("+%lu %s\0"),lpRasEntry->dwCountryCode,
                        lpRasEntry->szLocalPhoneNumber);
        
     
        //
        //  Initialize TAPIness
        //
        dwNumDev = 0;
        hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,(LPSTR)NULL,&dwNumDev);

        if (hr != ERROR_SUCCESS)
            goto GetDisplayableNumberExit;

        lpExtensionID = (LPLINEEXTENSIONID )GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
        if (!lpExtensionID)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }

        if (m_dwTapiDev == 0xFFFFFFFF)
        {
                m_dwTapiDev = 0;
        }

        //
        // ChrisK Olympus 5558 6/11/97
        // PPTP device will choke the version negotiating
        //
        do {
            hr = lineNegotiateAPIVersion(m_hLineApp, m_dwTapiDev, 0x00010004, 0x00010004,
                &m_dwAPIVersion, lpExtensionID);

        } while (hr != ERROR_SUCCESS && m_dwTapiDev++ < dwNumDev - 1);

        if (m_dwTapiDev >= dwNumDev)
        {
            m_dwTapiDev = 0;
        }

        // ditch it since we don't use it
        //
        if (lpExtensionID) GlobalFree(lpExtensionID);
        lpExtensionID = NULL;
        if (hr != ERROR_SUCCESS)
            goto GetDisplayableNumberExit;

        // Format the phone number
        //

        lpOutput1 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR,sizeof(LINETRANSLATEOUTPUT));
        if (!lpOutput1)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }
        lpOutput1->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

        // Turn the canonical form into the "displayable" form
        //

        hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,m_dwAPIVersion,
                                    m_szPhoneNumber,0,
                                    LINETRANSLATEOPTION_CANCELCALLWAITING,
                                    lpOutput1);

        if (hr != ERROR_SUCCESS || (lpOutput1->dwNeededSize != lpOutput1->dwTotalSize))
        {
            lpOutput2 = (LPLINETRANSLATEOUTPUT)GlobalAlloc(GPTR, (size_t)lpOutput1->dwNeededSize);
            if (!lpOutput2)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetDisplayableNumberExit;
            }
            lpOutput2->dwTotalSize = lpOutput1->dwNeededSize;
            GlobalFree(lpOutput1);
            lpOutput1 = lpOutput2;
            lpOutput2 = NULL;
            hr = lineTranslateAddress(m_hLineApp,m_dwTapiDev,
                                        m_dwAPIVersion,m_szPhoneNumber,0,
                                        LINETRANSLATEOPTION_CANCELCALLWAITING,
                                        lpOutput1);
        }

        if (hr != ERROR_SUCCESS)
        {
            goto GetDisplayableNumberExit;
        }

        m_pszDisplayable = (LPTSTR)GlobalAlloc(GPTR, ((size_t)lpOutput1->dwDisplayableStringSize+1));
        if (!m_pszDisplayable)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto GetDisplayableNumberExit;
        }

        lstrcpyn(m_pszDisplayable,
                    (LPTSTR)&((LPBYTE)lpOutput1)[lpOutput1->dwDisplayableStringOffset],
                    (int)lpOutput1->dwDisplayableStringSize);

        TCHAR szAreaCode[MAX_AREACODE+1];
        TCHAR szCountryCode[8];
        if (SUCCEEDED(tapiGetLocationInfo(szCountryCode,szAreaCode)))
        {
            if (szCountryCode[0] != '\0')
                m_dwCountryCode = _ttoi(szCountryCode);
            else    
                m_dwCountryCode = 1;
        }
        else
        {
            m_dwCountryCode = 1;
            
        }

    }

GetDisplayableNumberExit:

    if (lpOutput1) GlobalFree(lpOutput1);
    if (m_hLineApp) lineShutdown(m_hLineApp);
    return hr;
}

typedef DWORD (WINAPI* PFNRASDIALA)(LPRASDIALEXTENSIONS,LPSTR,LPRASDIALPARAMSA,DWORD,LPVOID,LPHRASCONN);
DWORD CRefDial::MyRasDial
(
    LPRASDIALEXTENSIONS  lpRasDialExtensions,
    LPTSTR  lpszPhonebook,
    LPRASDIALPARAMS  lpRasDialParams,
    DWORD  dwNotifierType,
    LPVOID  lpvNotifier,
    LPHRASCONN  lphRasConn
)
{
    HRESULT hr;
    
    if (!m_hRasDll)
        m_hRasDll = LoadLibrary(TEXT("RasApi32.dll"));

    if (!m_hRasDll)
    {
        hr = GetLastError();
        goto MyRasDialExit;
    }

    if (m_hRasDll && !m_fpRasDial)
        m_fpRasDial = GetProcAddress(m_hRasDll,"RasDialA");

    if (!m_fpRasDial)
    {
        hr = GetLastError();
        goto MyRasDialExit;
    }

    if (m_fpRasDial)
    {
#ifdef UNICODE
        // RasDialW version always fails to connect.
        // I don't know why. So I want to call RasDialA even if this is UNICODE build.
        RASDIALPARAMSA RasDialParams;
        RasDialParams.dwSize = sizeof(RASDIALPARAMSA);
        wcstombs(RasDialParams.szEntryName, lpRasDialParams->szEntryName, RAS_MaxEntryName+1);
        wcstombs(RasDialParams.szPhoneNumber, lpRasDialParams->szPhoneNumber, RAS_MaxPhoneNumber+1);
        wcstombs(RasDialParams.szCallbackNumber, lpRasDialParams->szCallbackNumber, RAS_MaxCallbackNumber+1);
        wcstombs(RasDialParams.szUserName, lpRasDialParams->szUserName, UNLEN+1);
        wcstombs(RasDialParams.szPassword, lpRasDialParams->szPassword, PWLEN+1);
        wcstombs(RasDialParams.szDomain, lpRasDialParams->szDomain, DNLEN+1);

        hr = ((PFNRASDIALA)m_fpRasDial)(lpRasDialExtensions,NULL,
                                            &RasDialParams,
                                            dwNotifierType, 
                                            (LPVOID) lpvNotifier,
                                            lphRasConn);
#else
        hr = ((PFNRASDIAL)m_fpRasDial)(lpRasDialExtensions,lpszPhonebook,
                                            lpRasDialParams,
                                            dwNotifierType, 
                                            (LPVOID) lpvNotifier,
                                            lphRasConn);
#endif
        Assert(hr == ERROR_SUCCESS);
    }
   
MyRasDialExit:
    return hr;
}



DWORD CRefDial::MyRasGetEntryDialParams
(
    LPTSTR  lpszPhonebook,
    LPRASDIALPARAMS  lprasdialparams,
    LPBOOL  lpfPassword
)
{
    HRESULT hr;

    if (!m_hRasDll)
        m_hRasDll = LoadLibrary(TEXT("RasApi32.dll"));

    if (!m_hRasDll)
    {
        hr = GetLastError();
        goto MyRasGetEntryDialParamsExit;
    }

    if (m_hRasDll && !m_fpRasGetEntryDialParams)
#ifdef UNICODE
        m_fpRasGetEntryDialParams = GetProcAddress(m_hRasDll,"RasGetEntryDialParamsW");
#else
        m_fpRasGetEntryDialParams = GetProcAddress(m_hRasDll,"RasGetEntryDialParamsA");
#endif

    if (!m_fpRasGetEntryDialParams)
    {
        hr = GetLastError();
        goto MyRasGetEntryDialParamsExit;
    }

    if (m_fpRasGetEntryDialParams)
        hr = ((PFNRASGETENTRYDIALPARAMS)m_fpRasGetEntryDialParams)(lpszPhonebook,lprasdialparams,lpfPassword);

MyRasGetEntryDialParamsExit:
    return hr;
}


BOOL CRefDial::FShouldRetry(HRESULT hrErr)
{
    BOOL bRC;

    m_uiRetry++;

    if (hrErr == ERROR_LINE_BUSY ||
        hrErr == ERROR_VOICE_ANSWER ||
        hrErr == ERROR_NO_ANSWER ||
        hrErr == ERROR_NO_CARRIER ||
        hrErr == ERROR_AUTHENTICATION_FAILURE ||
        hrErr == ERROR_PPP_TIMEOUT ||
        hrErr == ERROR_REMOTE_DISCONNECTION ||
        hrErr == ERROR_AUTH_INTERNAL ||
        hrErr == ERROR_PROTOCOL_NOT_CONFIGURED ||
        hrErr == ERROR_PPP_NO_PROTOCOLS_CONFIGURED)
    {
        bRC = TRUE;
    } else {
        bRC = FALSE;
    }

    bRC = bRC && m_uiRetry < MAX_RETIES;

    return bRC;
}


// This function will perform the actual dialing
STDMETHODIMP CRefDial::DoConnect(BOOL * pbRetVal)
{
    USES_CONVERSION;

    TCHAR               szPassword[PWLEN+2];
    LPRASDIALPARAMS     lpRasDialParams = NULL;
    LPRASDIALEXTENSIONS lpRasDialExtentions = NULL;
    HRESULT             hr = ERROR_SUCCESS;
    BOOL                bPW;

    // Initialize the dial error member
    m_hrDialErr = ERROR_SUCCESS;    
    
    // Get connectoid information
    //
    lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
    if (!lpRasDialParams)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto DialExit;
    }
    lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
    lstrcpyn(lpRasDialParams->szEntryName,m_szConnectoid,sizeof(lpRasDialParams->szEntryName));
    bPW = FALSE;
    hr = MyRasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
    if (hr != ERROR_SUCCESS)
    {
        goto DialExit;
    }

    //
    // This is only used on WINNT
    //
    lpRasDialExtentions = (LPRASDIALEXTENSIONS)GlobalAlloc(GPTR,sizeof(RASDIALEXTENSIONS));
    if (lpRasDialExtentions)
    {
        lpRasDialExtentions->dwSize = sizeof(RASDIALEXTENSIONS);
        lpRasDialExtentions->dwfOptions = RDEOPT_UsePrefixSuffix;
    }


    //
    // Add the user's password
    //
    szPassword[0] = 0;
    GetPrivateProfileString(INFFILE_USER_SECTION,
                            INFFILE_PASSWORD,
                            NULLSZ,
                            szPassword,
                            PWLEN + 1, 
                            m_szCurrentDUNFile[0] != '\0'? m_szCurrentDUNFile : OLE2A(m_bstrISPFile));

    if(szPassword[0])
        lstrcpy(lpRasDialParams->szPassword, szPassword);
                                        
    //
    // Dial connectoid
    //
    
    //Fix for redialing, on win9x we need to make sure we "hangup"
    //and free the rna resources in case we are redialing.
    //NT - is smart enough not to need it but it won't hurt.
    if (m_pcRNA)
        m_pcRNA->RasHangUp(m_hrasconn);
    
    m_hrasconn = NULL;




#if defined(DEBUG)
    if (FCampusNetOverride())
    {
        m_bModemOverride = TRUE;
    }
#endif

    if (m_bModemOverride)
    {
        // Skip dialing because the server is on the campus network
        //
        PostMessage(RegisterWindowMessageA(RASDIALEVENT),RASCS_Connected,0);
        hr = ERROR_SUCCESS;
    }
    else
        hr = MyRasDial(lpRasDialExtentions,NULL,lpRasDialParams,0xFFFFFFFF, m_hWnd,
                       &m_hrasconn);

    m_bModemOverride = FALSE;

    if (( hr != ERROR_SUCCESS) || m_bWaitingToHangup)
    {
        // We failed to connect for some reason, so hangup
        if (m_hrasconn)
        {
            if (!m_pcRNA) m_pcRNA = new RNAAPI;
            if (!m_pcRNA)
            {
                MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
            } else {
                m_pcRNA->RasHangUp(m_hrasconn);
                m_bWaitingToHangup = FALSE;
                m_hrasconn = NULL;
            }
        }
        goto DialExit;
    }

    if (lpRasDialParams) 
        GlobalFree(lpRasDialParams);
    lpRasDialParams = NULL;

DialExit:
    if (lpRasDialExtentions) 
        GlobalFree(lpRasDialExtentions);
    lpRasDialExtentions = NULL;

    // Set the return value for the method
    if (hr != ERROR_SUCCESS)
        *pbRetVal = FALSE;
    else
        *pbRetVal = TRUE;

    m_hrDialErr = hr;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   MyRasGetEntryProperties()
//
//  Synopsis:   Performs some buffer size checks and then calls RasGetEntryProperties()
//                See the RasGetEntryProperties() docs to understand why this is needed.
//
//  Arguments:  Same as RasGetEntryProperties with the following exceptions:
//                lplpRasEntryBuff -- pointer to a pointer to a RASENTRY struct.  On successfull
//                                    return, *lplpRasEntryBuff will point to the RASENTRY struct
//                                    and buffer returned by RasGetEntryProperties.
//                                    NOTE: should not have memory allocated to it at call time!
//                                          To emphasize this point, *lplpRasEntryBuff must be NULL
//                lplpRasDevInfoBuff -- pointer to a pointer to a RASDEVINFO struct.  On successfull
//                                    return, *lplpRasDevInfoBuff will point to the RASDEVINFO struct
//                                    and buffer returned by RasGetEntryProperties.
//                                    NOTE: should not have memory allocated to it at call time!
//                                          To emphasize this point, *lplpRasDevInfoBuff must be NULL
//                                    NOTE: Even on a successfull call to RasGetEntryProperties,
//                                          *lplpRasDevInfoBuff may return with a value of NULL
//                                          (occurs when there is no extra device info)
//
//    Returns:    ERROR_NOT_ENOUGH_MEMORY if unable to allocate either RASENTRY or RASDEVINFO buffer
//                Otherwise, it retuns the error code from the call to RasGetEntryProperties.
//                NOTE: if return is anything other than ERROR_SUCCESS, *lplpRasDevInfoBuff and
//                      *lplpRasEntryBuff will be NULL,
//                      and *lpdwRasEntryBuffSize and *lpdwRasDevInfoBuffSize will be 0
//
//  Example:
//
//      LPRASENTRY    lpRasEntry = NULL;
//      LPRASDEVINFO  lpRasDevInfo = NULL;
//      DWORD            dwRasEntrySize, dwRasDevInfoSize;
//
//      hr = MyRasGetEntryProperties( NULL,
//                                      g_pcDialErr->m_szConnectoid,
//                                    &lpRasEntry,
//                                    &dwRasEntrySize,
//                                    &lpRasDevInfo,
//                                    &dwRasDevInfoSize);
//
//
//      if (hr != ERROR_SUCCESS)
//      {
//            //handle errors here
//      } else
//      {
//            //continue processing
//      }
//
//
//  History:    9/10/96     JMazner        Created for icwconn2
//                9/17/96        JMazner        Adapted for icwconn1
//              1/8/98      DONALDM     Moved to the new ICW/GetConn project
//----------------------------------------------------------------------------
HRESULT CRefDial::MyRasGetEntryProperties(LPTSTR lpszPhonebookFile,
                                LPTSTR lpszPhonebookEntry, 
                                LPRASENTRY *lplpRasEntryBuff,
                                LPDWORD lpdwRasEntryBuffSize,
                                LPRASDEVINFO *lplpRasDevInfoBuff,
                                LPDWORD lpdwRasDevInfoBuffSize)
{

    HRESULT hr;
    RNAAPI *pcRNA = NULL;

    DWORD dwOldDevInfoBuffSize;

    Assert( NULL != lplpRasEntryBuff );
    Assert( NULL != lpdwRasEntryBuffSize );
    Assert( NULL != lplpRasDevInfoBuff );
    Assert( NULL != lpdwRasDevInfoBuffSize );

    *lpdwRasEntryBuffSize = 0;
    *lpdwRasDevInfoBuffSize = 0;

    pcRNA = new RNAAPI;
    if (!pcRNA)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MyRasGetEntryPropertiesErrExit;
    }

    // use RasGetEntryProperties with a NULL lpRasEntry pointer to find out size buffer we need
    // As per the docs' recommendation, do the same with a NULL lpRasDevInfo pointer.

    hr = pcRNA->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
                                (LPBYTE) NULL,
                                lpdwRasEntryBuffSize,
                                (LPBYTE) NULL,
                                lpdwRasDevInfoBuffSize);

    // we expect the above call to fail because the buffer size is 0
    // If it doesn't fail, that means our RasEntry is messed, so we're in trouble
    if( ERROR_BUFFER_TOO_SMALL != hr )
    { 
        goto MyRasGetEntryPropertiesErrExit;
    }

    // dwRasEntryBuffSize and dwRasDevInfoBuffSize now contain the size needed for their
    // respective buffers, so allocate the memory for them

    // dwRasEntryBuffSize should never be less than the size of the RASENTRY struct.
    // If it is, we'll run into problems sticking values into the struct's fields

    Assert( *lpdwRasEntryBuffSize >= sizeof(RASENTRY) );

    if (m_reflpRasEntryBuff)
    {
        if (*lpdwRasEntryBuffSize > m_reflpRasEntryBuff->dwSize)
        {
            m_reflpRasEntryBuff = (LPRASENTRY)GlobalReAlloc(m_reflpRasEntryBuff, *lpdwRasEntryBuffSize, GPTR);
        }
    }
    else
    {
        m_reflpRasEntryBuff = (LPRASENTRY)GlobalAlloc(GPTR,*lpdwRasEntryBuffSize);
    }


    if (!m_reflpRasEntryBuff)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MyRasGetEntryPropertiesErrExit;
    }

    // This is a bit convoluted:  lpRasEntrySize->dwSize needs to contain the size of _only_ the
    // RASENTRY structure, and _not_ the actual size of the buffer that lpRasEntrySize points to.
    // This is because the dwSize field is used by RAS for compatability purposes to determine which
    // version of the RASENTRY struct we're using.
    // Same holds for lpRasDevInfo->dwSize
    
    m_reflpRasEntryBuff->dwSize = sizeof(RASENTRY);

    //
    // Allocate the DeviceInfo size that RasGetEntryProperties told us we needed.
    // If size is 0, don't alloc anything
    //
    if( *lpdwRasDevInfoBuffSize > 0 )
    {
        Assert( *lpdwRasDevInfoBuffSize >= sizeof(RASDEVINFO) );
        if (m_reflpRasDevInfoBuff)
        {
            // check if existing size is not sufficient
            if ( *lpdwRasDevInfoBuffSize > m_reflpRasDevInfoBuff->dwSize )
            {
                m_reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalReAlloc(m_reflpRasDevInfoBuff,*lpdwRasDevInfoBuffSize, GPTR);
            }
        }
        else
        {
            m_reflpRasDevInfoBuff = (LPRASDEVINFO)GlobalAlloc(GPTR,*lpdwRasDevInfoBuffSize);
        }

        if (!m_reflpRasDevInfoBuff)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto MyRasGetEntryPropertiesErrExit;
        }
    } 
    else
    {
        m_reflpRasDevInfoBuff = NULL;
    }

    if( m_reflpRasDevInfoBuff )
    {
        m_reflpRasDevInfoBuff->dwSize = sizeof(RASDEVINFO);
    }


    // now we're ready to make the actual call...

    // jmazner   see below for why this is needed
    dwOldDevInfoBuffSize = *lpdwRasDevInfoBuffSize;

    hr = pcRNA->RasGetEntryProperties(lpszPhonebookFile, lpszPhonebookEntry,
                                (LPBYTE) m_reflpRasEntryBuff,
                                lpdwRasEntryBuffSize,
                                (LPBYTE) m_reflpRasDevInfoBuff,
                                lpdwRasDevInfoBuffSize);

    // jmazner 10/7/96  Normandy #8763
    // For unknown reasons, in some cases on win95, devInfoBuffSize increases after the above call,
    // but the return code indicates success, not BUFFER_TOO_SMALL.  If this happens, set the
    // size back to what it was before the call, so the DevInfoBuffSize and the actuall space allocated 
    // for the DevInfoBuff match on exit.
    if( (ERROR_SUCCESS == hr) && (dwOldDevInfoBuffSize != *lpdwRasDevInfoBuffSize) )
    {
        *lpdwRasDevInfoBuffSize = dwOldDevInfoBuffSize;
    }


    if( pcRNA )
    {
        delete pcRNA;
        pcRNA = NULL;
    }

    *lplpRasEntryBuff = m_reflpRasEntryBuff;
    *lplpRasDevInfoBuff = m_reflpRasDevInfoBuff;

    return( hr );

MyRasGetEntryPropertiesErrExit:

    if(m_reflpRasEntryBuff)
    {
        GlobalFree(m_reflpRasEntryBuff);
        m_reflpRasEntryBuff = NULL;
        *lplpRasEntryBuff = NULL;
    }
    if(m_reflpRasDevInfoBuff)
    {
        GlobalFree(m_reflpRasDevInfoBuff);
        m_reflpRasDevInfoBuff = NULL;
        *lplpRasDevInfoBuff = NULL;
    }
        
    if( pcRNA )
    {
        delete pcRNA;
        pcRNA = NULL;
    }

    *lpdwRasEntryBuffSize = 0;
    *lpdwRasDevInfoBuffSize = 0;
    
    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   LineCallback()
//
//  Synopsis:   Call back for TAPI line
//
//+---------------------------------------------------------------------------
void CALLBACK LineCallback(DWORD hDevice,
                           DWORD dwMessage,
                           DWORD dwInstance,
                           DWORD dwParam1,
                           DWORD dwParam2,
                           DWORD dwParam3)
{
}


HRESULT MyGetFileVersion(LPCTSTR pszFileName, LPGATHERINFO lpGatherInfo)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD   dwSize = 0;
    DWORD   dwTemp = 0;
    LPVOID  pv = NULL, pvVerInfo = NULL;
    UINT    uiSize;
    DWORD   dwVerPiece;
    //int idx;

    
    // verify parameters
    //
    Assert(pszFileName && lpGatherInfo);

    // Get version
    //
    dwSize = GetFileVersionInfoSize((LPTSTR)pszFileName,&dwTemp);
    if (!dwSize)
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }
    pv = (LPVOID)GlobalAlloc(GPTR, (size_t)dwSize);
    if (!pv) goto MyGetFileVersionExit;
    if (!GetFileVersionInfo((LPTSTR)pszFileName,dwTemp,dwSize,pv))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }

    if (!VerQueryValue(pv,TEXT("\\\0"),&pvVerInfo,&uiSize))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }
    pvVerInfo = (LPVOID)((DWORD_PTR)pvVerInfo + sizeof(DWORD)*4);
    lpGatherInfo->m_szSUVersion[0] = '\0';
    dwVerPiece = (*((LPDWORD)pvVerInfo)) >> 16;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%d."),dwVerPiece);

    dwVerPiece = (*((LPDWORD)pvVerInfo)) & 0x0000ffff;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%s%d."),lpGatherInfo->m_szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)pvVerInfo)[1]) >> 16;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%s%d."),lpGatherInfo->m_szSUVersion,dwVerPiece);

    dwVerPiece = (((LPDWORD)pvVerInfo)[1]) & 0x0000ffff;
    wsprintf(lpGatherInfo->m_szSUVersion,TEXT("%s%d"),lpGatherInfo->m_szSUVersion,dwVerPiece);

    if (!VerQueryValue(pv,TEXT("\\VarFileInfo\\Translation"),&pvVerInfo,&uiSize))
    {
        hr = GetLastError();
        goto MyGetFileVersionExit;
    }

    // separate version information from character set
    lpGatherInfo->m_lcidApps = (LCID)(LOWORD(*(DWORD*)pvVerInfo));

    hr = ERROR_SUCCESS;

MyGetFileVersionExit:
    if (pv) GlobalFree(pv);
    
    return hr;
}

DWORD CRefDial::FillGatherInfoStruct(LPGATHERINFO lpGatherInfo)
{
    USES_CONVERSION;
    HKEY        hkey = NULL;
    SYSTEM_INFO si;
    TCHAR       szTempPath[MAX_PATH];
    DWORD       dwRet = ERROR_SUCCESS;
        
    lpGatherInfo->m_lcidUser  = GetUserDefaultLCID();
    lpGatherInfo->m_lcidSys   = GetSystemDefaultLCID();
    
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

     if (!GetVersionEx(&osvi))
    {
        // Nevermind, we'll just assume the version is 0.0 if we can't read it
        //
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    }

    lpGatherInfo->m_dwOS = osvi.dwPlatformId;
    lpGatherInfo->m_dwMajorVersion = osvi.dwMajorVersion;
    lpGatherInfo->m_dwMinorVersion = osvi.dwMinorVersion;

    ZeroMemory(&si,sizeof(SYSTEM_INFO));
    GetSystemInfo(&si);

    lpGatherInfo->m_wArchitecture = si.wProcessorArchitecture;

    // Sign-up version
    //
    lpGatherInfo->m_szSUVersion[0] = '\0';
    if( GetModuleFileName(_Module.GetModuleInstance(), szTempPath, MAX_PATH))
    {
        if ((MyGetFileVersion(szTempPath, lpGatherInfo)) != ERROR_SUCCESS)
        {
            return (GetLastError());
        }
    }
    else
        return( GetLastError() );

    // OEM code
    //
    TCHAR szOeminfoPath[MAX_PATH + 1];
    TCHAR *lpszTerminator = NULL;
    TCHAR *lpszLastChar = NULL;
    TCHAR szTemp[MAX_PATH];
        
    if( 0 != GetSystemDirectory( szOeminfoPath, MAX_PATH + 1 ) )
    {
        lpszTerminator = &(szOeminfoPath[ lstrlen(szOeminfoPath) ]);
        lpszLastChar = CharPrev( szOeminfoPath, lpszTerminator );

        if( '\\' != *lpszLastChar )
        {
            lpszLastChar = CharNext( lpszLastChar );
            *lpszLastChar = '\\';
            lpszLastChar = CharNext( lpszLastChar );
            *lpszLastChar = '\0';
        }

        lstrcat( szOeminfoPath, ICW_OEMINFO_FILENAME );

        //Default oem code must be NULL if it doesn't exist in oeminfo.ini
        if (!GetPrivateProfileString(ICW_OEMINFO_OEMSECTION,
                                     ICW_OEMINFO_OEMKEY,
                                     TEXT(""),
                                     m_szOEM,
                                     MAX_OEMNAME,
                                     szOeminfoPath))
        {
            //oem = (nothing), set to NULL
            m_szOEM[0] = '\0';
        }
                    
        // Get the Product Code, Promo code and ALLOFFERS code if they exist
        if (GetPrivateProfileString(ICW_OEMINFO_ICWSECTION,
                                ICW_OEMINFO_PRODUCTCODE,
                                DEFAULT_PRODUCTCODE,
                                szTemp,
                                sizeof(szTemp),
                                szOeminfoPath))
        {
            m_bstrProductCode = A2BSTR(szTemp);
        }
        else
            m_bstrProductCode = A2BSTR(DEFAULT_PRODUCTCODE);
       
        if (GetPrivateProfileString(ICW_OEMINFO_ICWSECTION,
                                ICW_OEMINFO_PROMOCODE,
                                DEFAULT_PROMOCODE,
                                szTemp,
                                sizeof(szTemp),
                                szOeminfoPath))
        {
            m_bstrPromoCode = A2BSTR(szTemp);
        }
        else
            m_bstrPromoCode = A2BSTR(DEFAULT_PROMOCODE);
          
        m_lAllOffers = GetPrivateProfileInt(ICW_OEMINFO_ICWSECTION,
                                            ICW_OEMINFO_ALLOFFERS,
                                            1,
                                            szOeminfoPath);
    }


    // 2/20/97    jmazner    Olympus #259
    if ( RegOpenKey(HKEY_LOCAL_MACHINE,ICWSETTINGSPATH,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize; 
        DWORD dwType;
        dwType = REG_SZ;
        dwSize = sizeof(TCHAR)*(MAX_RELPROD + 1);
        if (RegQueryValueEx(hkey,RELEASEPRODUCTKEY,NULL,&dwType,(LPBYTE)&lpGatherInfo->m_szRelProd[0],&dwSize) != ERROR_SUCCESS)
            lpGatherInfo->m_szRelProd[0] = '\0';

        dwSize = sizeof(TCHAR)*(MAX_RELVER + 1);
        if (RegQueryValueEx(hkey,RELEASEVERSIONKEY,NULL,&dwType,(LPBYTE)&lpGatherInfo->m_szRelVer[0],&dwSize) != ERROR_SUCCESS)
            lpGatherInfo->m_szRelVer[0] = '\0';


        RegCloseKey(hkey);
    }

    // PromoCode
    lpGatherInfo->m_szPromo[0] = '\0';

    
    TCHAR    szPIDPath[MAX_PATH];        // Reg path to the PID

    // Form the Path, it is HKLM\\Software\\Microsoft\Windows[ NT]\\CurrentVersion
    lstrcpy(szPIDPath, TEXT("Software\\Microsoft\\Windows"));
    IF_NTONLY
        lstrcat(szPIDPath, TEXT(" NT"));
    ENDIF_NTONLY
    lstrcat(szPIDPath, TEXT("\\CurrentVersion"));

    BYTE    byDigitalPID[MAX_DIGITAL_PID];

    // Get the Product ID for this machine
    if ( RegOpenKey(HKEY_LOCAL_MACHINE,szPIDPath,&hkey) == ERROR_SUCCESS)
    {
        DWORD dwSize; 
        DWORD dwType;
        dwType = REG_BINARY;
        dwSize = sizeof(byDigitalPID);
        if (RegQueryValueEx(hkey,
                            c_szRegStrValDigitalPID,
                            NULL,
                            &dwType,
                            (LPBYTE)byDigitalPID,
                            &dwSize) == ERROR_SUCCESS)
        {
            // BINHEX the digital PID data so we can send it to the ref_server
            int     i = 0;
            BYTE    by;
            for (DWORD dwX = 0; dwX < dwSize; dwX++)
            {
                by = byDigitalPID[dwX];
                m_szPID[i++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                m_szPID[i++] = g_BINTOHEXLookup[(by & 0x0F)];
            }
            m_szPID[i] = '\0';
        }
        else
        {
            m_szPID[0] = '\0';
        }
        RegCloseKey(hkey);
    }

    return( dwRet );
}

// ############################################################################
HRESULT CRefDial::CreateEntryFromDUNFile(LPTSTR pszDunFile)
{
    TCHAR    szFileName[MAX_PATH];
    TCHAR    szUserName[UNLEN+1];
    TCHAR    szPassword[PWLEN+1];
    LPTSTR   pszTemp;
    HRESULT  hr;
    BOOL     fNeedsRestart=FALSE;


    hr = ERROR_SUCCESS;

    // Get fully qualified path name
    //

    if (!SearchPath(NULL,pszDunFile,NULL,MAX_PATH,&szFileName[0],&pszTemp))
    {
        hr = ERROR_FILE_NOT_FOUND;
        goto CreateEntryFromDUNFileExit;
    } 

    // save current DUN file name in global
    lstrcpy(m_szCurrentDUNFile, &szFileName[0]);

    hr = m_ISPImport.ImportConnection (&szFileName[0], m_szISPSupportNumber, m_szEntryName, szUserName, szPassword,&fNeedsRestart);

    // place the name of the connectoid in the registry
    //
    if (ERROR_SUCCESS != (StoreInSignUpReg((LPBYTE)m_szEntryName, lstrlen(m_szEntryName)+1, REG_SZ, RASENTRYVALUENAME)))
    {
        goto CreateEntryFromDUNFileExit;
    }
    lstrcpy(m_szLastDUNFile, pszDunFile);

CreateEntryFromDUNFileExit:
    return hr;
}


HRESULT CRefDial::UserPickANumber(HWND hWnd,
                            LPGATHERINFO lpGatherInfo, 
                            PSUGGESTINFO lpSuggestInfo,
                            HINSTANCE hPHBKDll,
                            DWORD_PTR dwPhoneBook,
                            TCHAR *pszConnectoid, 
                            DWORD dwSize,
                            DWORD dwPhoneDisplayFlags)
{
    USES_CONVERSION;
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    FARPROC     fp;
    RASENTRY    *prasentry = NULL;
    RASDEVINFO  *prasdevinfo = NULL;
    DWORD       dwRasentrySize = 0;
    DWORD       dwRasdevinfoSize = 0;
    TCHAR        szTemp[256];
    TCHAR        *ppszDunFiles[1];
    TCHAR        *ppszTemp[1];
    TCHAR        szDunFile[12];
    BOOL        bStatus = TRUE;
    
    //
    // If the phone book can't find a number let the user pick
    //
    ppszDunFiles[0] = &szDunFile[0];
    lstrcpy(&szDunFile[0],OLE2A(m_bstrISPFile));

    fp = GetProcAddress(hPHBKDll, PHBK_DISPLAYAPI);
    AssertMsg(fp != NULL,TEXT("display access number api is missing"));
    ppszTemp[0] = szTemp;

    
    //
    // donsc - 3/10/98
    //   
    // We have seen at least one code-path that could bring you into
    // here with lpSuggestInfo or lpGatherInfo == NULL. That has been
    // fixed, but to be defensive, we will ensure that these pointers
    // are valid...even if they don't have information, we will still let
    // the user pick a number.

    SUGGESTINFO SugInfo;
    GATHERINFO  GatInfo;
    
    ::ZeroMemory(&SugInfo,sizeof(SugInfo));
    ::ZeroMemory(&GatInfo,sizeof(GatInfo));

    if(lpSuggestInfo == NULL)
    {
      TraceMsg(TF_GENERAL, TEXT("UserPickANumber: lpSuggestInfo is NULL\n"));
      lpSuggestInfo = &SugInfo;
    }

    if(lpGatherInfo == NULL)
    {
      TraceMsg(TF_GENERAL, TEXT("UserPickANumber: lpGatherInfo is NULL\n"));
      lpGatherInfo = &GatInfo;
    }

    hr = ((PFNPHONEDISPLAY)fp)(dwPhoneBook,
                                ppszTemp,
                                ppszDunFiles,
                                &(lpSuggestInfo->wNumber),
                                &(lpSuggestInfo->dwCountryID),
                                &(lpGatherInfo->m_wState),
                                lpGatherInfo->m_fType,
                                lpGatherInfo->m_bMask,
                                hWnd,
                                dwPhoneDisplayFlags);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;

    
    ZeroMemory(pszConnectoid,dwSize);
    hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ, 
                        RASENTRYVALUENAME);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;


    hr = MyRasGetEntryProperties(NULL,
                                    pszConnectoid,
                                    &prasentry,
                                    &dwRasentrySize,
                                    &prasdevinfo,
                                    &dwRasdevinfoSize);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;
                            
    //
    // Check to see if the user selected a phone number with a different dun file
    // than the one already used to create the connectoid
    //
    TCHAR    szTempPath[MAX_PATH];

    // If we did not use dun file last time, assumed we used the default.
    if ( *m_szLastDUNFile )
        lstrcpy(szTempPath, m_szLastDUNFile);
    else
        bStatus = (ERROR_SUCCESS == GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_DUN_FILE,szTempPath,MAX_PATH));

    if (bStatus)
    {
        if (_tcsicmp(szTempPath,ppszDunFiles[0]))
        {

            //
            // Rats, they changed dun files. We now get to build the connectoid
            // from scratch
            //
            if (CreateEntryFromDUNFile(ppszDunFiles[0]) == ERROR_SUCCESS)
            {
                prasentry = NULL;
                dwRasentrySize = 0;
                prasdevinfo = NULL;
                dwRasdevinfoSize = 0;
            
                hr = MyRasGetEntryProperties(NULL,
                                            pszConnectoid,
                                            &prasentry,
                                            &dwRasentrySize,
                                            &prasdevinfo,
                                            &dwRasdevinfoSize);
            
                if (hr != ERROR_SUCCESS || NULL == prasentry) 
                    goto UserPickANumberExit;
            
                BreakUpPhoneNumber(prasentry, szTemp);
                prasentry->dwCountryID = lpSuggestInfo->dwCountryID;
            } 
            else 
            {
                hr = ERROR_READING_DUN;
                goto UserPickANumberExit;
            }
        } 
        else 
        {
            BreakUpPhoneNumber(prasentry, szTemp);
            prasentry->dwCountryID = lpSuggestInfo->dwCountryID;
        }
    } 
    else 
    {
        hr = ERROR_READING_ISP;
        goto UserPickANumberExit;
    }


    prasentry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
    //
    // Write out new connectoid
    //
    if (m_pcRNA)
        hr = m_pcRNA->RasSetEntryProperties(NULL, pszConnectoid, 
                                                (LPBYTE)prasentry, 
                                                dwRasentrySize, 
                                                (LPBYTE)prasdevinfo, 
                                                dwRasdevinfoSize);
    if (hr != ERROR_SUCCESS) 
        goto UserPickANumberExit;
    
    
    return hr;


UserPickANumberExit:
    TCHAR    szBuff256[257];
    if (hr == ERROR_READING_ISP)
    {
        MsgBox(IDS_CANTREADMSNSUISP, MB_MYERROR);
    } else if (hr == ERROR_READING_DUN) {
        MsgBox(IDS_CANTREADMSDUNFILE, MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWPHBK.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWDL.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_USERBACK || hr == ERROR_USERCANCEL) {
        // Do nothing
    } else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
    } else if ((hr == ERROR_NO_MORE_ITEMS) || (hr == ERROR_INVALID_DATA)
                || (hr == ERROR_FILE_NOT_FOUND)) {
        MsgBox(IDS_CORRUPTPHONEBOOK, MB_MYERROR);
    } else if (hr != ERROR_SUCCESS) {
        wsprintf(szBuff256,TEXT("You can ignore this, just report it and include this number (%d).\n"),hr);
        AssertMsg(0,szBuff256);
    }

    return hr;
} 

HRESULT CRefDial::SetupForRASDialing
(
    LPGATHERINFO lpGatherInfo, 
    HINSTANCE hPHBKDll,
    DWORD_PTR *lpdwPhoneBook,
    PSUGGESTINFO *ppSuggestInfo,
    TCHAR *pszConnectoid, 
    BOOL FAR *bConnectiodCreated
)
{
    USES_CONVERSION;

    HRESULT         hr = ERROR_NOT_ENOUGH_MEMORY;
    FARPROC         fp;
    PSUGGESTINFO    pSuggestInfo = NULL;
    TCHAR           szEntry[MAX_RASENTRYNAME];
    DWORD           dwSize = sizeof(szEntry);
    RASENTRY        *prasentry = NULL;
    RASDEVINFO      *prasdevinfo = NULL;
    DWORD           dwRasentrySize = 0;
    DWORD           dwRasdevinfoSize = 0;
    HINSTANCE       hRasDll =NULL;
    TCHAR           szBuff256[257];

    LPRASCONN       lprasconn = NULL;

    // Load the connectoid
    //
    if (!m_pcRNA) 
        m_pcRNA = new RNAAPI;
    if (!m_pcRNA) 
        goto SetupForRASDialingExit;

    prasentry = (RASENTRY*)GlobalAlloc(GPTR,sizeof(RASENTRY)+2);
    Assert(prasentry);
    if (!prasentry)
    {
        hr = GetLastError();
        goto SetupForRASDialingExit;
    }
    prasentry->dwSize = sizeof(RASENTRY);
    dwRasentrySize = sizeof(RASENTRY);

    
    prasdevinfo = (RASDEVINFO*)GlobalAlloc(GPTR,sizeof(RASDEVINFO));
    Assert(prasdevinfo);
    if (!prasdevinfo)
    {
        hr = GetLastError();
        goto SetupForRASDialingExit;
    }
    prasdevinfo->dwSize = sizeof(RASDEVINFO);
    dwRasdevinfoSize = sizeof(RASDEVINFO);

    
    hr = ReadSignUpReg((LPBYTE)&szEntry[0], &dwSize, REG_SZ, 
                        RASENTRYVALUENAME);
    if (hr != ERROR_SUCCESS) 
        goto SetupForRASDialingExit;

#ifdef UNICODE
    // Comment for UNICODE.
	// RasGetEntryProperties fails in case of UNICODE
	// because of size. So I ask the size first before actual call.
	hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry, 
                                            NULL,
                                            &dwRasentrySize, 
                                            NULL,
                                            &dwRasdevinfoSize);
#else
    hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry, 
                                            (LPBYTE)prasentry, 
                                            &dwRasentrySize, 
                                            (LPBYTE)prasdevinfo, 
                                            &dwRasdevinfoSize);
#endif
    if (hr == ERROR_BUFFER_TOO_SMALL)
    {
        // Comment for UNICODE.
        // This must be happen for UNICODE.

        TraceMsg(TF_GENERAL,TEXT("CONNECT:RasGetEntryProperties failed, try a new size.\n"));
        GlobalFree(prasentry);
        prasentry = (RASENTRY*)GlobalAlloc(GPTR,((size_t)dwRasentrySize));
        prasentry->dwSize = dwRasentrySize;

        GlobalFree(prasdevinfo);
		if(dwRasdevinfoSize > 0)
        {
            prasdevinfo = (RASDEVINFO*)GlobalAlloc(GPTR,((size_t)dwRasdevinfoSize));
            prasdevinfo->dwSize = dwRasdevinfoSize;
        }
        else
            prasdevinfo = NULL;
        hr = m_pcRNA->RasGetEntryProperties(NULL, szEntry, 
                                                (LPBYTE)prasentry, 
                                                &dwRasentrySize, 
                                                (LPBYTE)prasdevinfo, 
                                                &dwRasdevinfoSize);
    }
    if (hr != ERROR_SUCCESS) 
        goto SetupForRASDialingExit;


    lpGatherInfo->m_wState = 0;
    lpGatherInfo->m_fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
    lpGatherInfo->m_bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);



    //
    // Check to see if the phone number was filled in
    //
    if (lstrcmp(&prasentry->szLocalPhoneNumber[0],DUN_NOPHONENUMBER) == 0)
    {
        //
        // allocate and intialize memory
        //
        pSuggestInfo = (PSUGGESTINFO)GlobalAlloc(GPTR,sizeof(SUGGESTINFO));
        Assert(pSuggestInfo);
        if (!pSuggestInfo) 
        {
            hr = GetLastError();
            goto SetupForRASDialingExit;
        }
        *ppSuggestInfo = pSuggestInfo;
 
        // set phone number type and mask
        pSuggestInfo->fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
        pSuggestInfo->bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);

        pSuggestInfo->wAreaCode = Sz2W(lpGatherInfo->m_szAreaCode);
        pSuggestInfo->dwCountryID = lpGatherInfo->m_dwCountry;

    
        // Load Microsoft's phonebook
        //
        fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI);
        AssertMsg(fp != NULL,TEXT("PhoneBookLoad is missing from icwphbk.dll"));

        hr = ((PFNPHONEBOOKLOAD)fp)(OLE2A(m_bstrISPFile),lpdwPhoneBook);
        if (hr != ERROR_SUCCESS) goto SetupForRASDialingExit;
        
        AssertMsg((*lpdwPhoneBook == TRUE),TEXT("Phonebook Load return no error and 0 for phonebook"));

        
        //
        // Load Suggest procedure
        //
        fp = GetProcAddress(hPHBKDll,PHBK_SUGGESTAPI);
        AssertMsg(fp != NULL,TEXT("PhoneBookSuggest is missing from icwphbk.dll"));

        // Set the number of suggestions
        pSuggestInfo->wNumber = NUM_PHBK_SUGGESTIONS;
        
        // get phone number
        hr = ((PFPHONEBOOKSUGGEST)fp)(*lpdwPhoneBook,pSuggestInfo);

        // Inore error because we can continue even without a suggested
        // phone number (the user will just have to pick one).
        hr = ERROR_SUCCESS;
    }
    else
    {
        ZeroMemory(pszConnectoid, dwSize);
        hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ, 
                           RASENTRYVALUENAME);
        if (hr != ERROR_SUCCESS) 
            goto SetupForRASDialingExit;
    
        // Use the RASENTRY that we have to create the connectiod
        hr = m_pcRNA->RasSetEntryProperties(NULL, 
                                            pszConnectoid, 
                                            (LPBYTE)prasentry, 
                                            dwRasentrySize, 
                                            (LPBYTE)prasdevinfo, 
                                            dwRasdevinfoSize);
        *bConnectiodCreated = TRUE;                                            
    }

SetupForRASDialingExit:
    if (prasentry)
        GlobalFree(prasentry);
    if (prasdevinfo)
        GlobalFree(prasdevinfo);
    if (hr == ERROR_READING_ISP)
    {
        MsgBox(IDS_CANTREADMSNSUISP, MB_MYERROR);
    } else if (hr == ERROR_READING_DUN) {
        MsgBox(IDS_CANTREADMSDUNFILE, MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWPHBK.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWDL.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_USERBACK || hr == ERROR_USERCANCEL) {
        // Do nothing
    } else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
    } else if ((hr == ERROR_NO_MORE_ITEMS) || (hr == ERROR_INVALID_DATA)
                || (hr == ERROR_FILE_NOT_FOUND)) {
        MsgBox(IDS_CORRUPTPHONEBOOK, MB_MYERROR);
    } else if (hr != ERROR_SUCCESS) {
        wsprintf(szBuff256,TEXT("You can ignore this, just report it and include this number (%d).\n"),hr);
        AssertMsg(0,szBuff256);
    }
    return hr;
}



// 10/22/96    jmazner    Normandy #9923
// Since in SetupConnectoidExit we're treating results other than ERROR_SUCCESS as
// indicating successfull completion, we need bSuccess to provide a simple way for the
// caller to tell whether the function completed.                
HRESULT CRefDial::SetupConnectoid
(
    PSUGGESTINFO    pSuggestInfo, 
    int             irc, 
    TCHAR           *pszConnectoid, 
    DWORD           dwSize, 
    BOOL            *pbSuccess
)
{
    USES_CONVERSION;
    
    HRESULT     hr = ERROR_NOT_ENOUGH_MEMORY;
    RASENTRY    *prasentry = NULL;
    RASDEVINFO  *prasdevinfo = NULL;
    DWORD       dwRasentrySize = 0;
    DWORD       dwRasdevinfoSize = 0;
    HINSTANCE   hPHBKDll = NULL;
    HINSTANCE   hRasDll =NULL;

    LPTSTR      lpszSetupFile;
    LPRASCONN   lprasconn = NULL;
    CMcRegistry reg;

    Assert(pbSuccess);

    if (!pSuggestInfo)
    {
        hr = ERROR_PHBK_NOT_FOUND;
        goto SetupConnectoidExit;
    }
    
    lpszSetupFile = m_szCurrentDUNFile[0] != '\0' ? m_szCurrentDUNFile : OLE2A(m_bstrISPFile);
    
    if (lstrcmp(pSuggestInfo->rgpAccessEntry[irc]->szDataCenter,lpszSetupFile))
    {
        hr = CreateEntryFromDUNFile(pSuggestInfo->rgpAccessEntry[irc]->szDataCenter);
        if (hr == ERROR_SUCCESS)
        {
            ZeroMemory(pszConnectoid, dwSize);
            hr = ReadSignUpReg((LPBYTE)pszConnectoid, &dwSize, REG_SZ, 
                               RASENTRYVALUENAME);
            if (hr != ERROR_SUCCESS) 
                goto SetupConnectoidExit;
        
            if( prasentry )
            {
                GlobalFree( prasentry );
                prasentry = NULL;
                dwRasentrySize = NULL;
            }
        
            if( prasdevinfo )
            {
                GlobalFree( prasdevinfo );
                prasdevinfo = NULL;
                dwRasdevinfoSize = NULL;
            }

            hr = MyRasGetEntryProperties(NULL,
                                        pszConnectoid,
                                        &prasentry,
                                        &dwRasentrySize,
                                        &prasdevinfo,
                                        &dwRasdevinfoSize);
            if (hr != ERROR_SUCCESS || NULL == prasentry) 
                goto SetupConnectoidExit;
        }
        else
        {
            // 10/22/96    jmazner    Normandy #9923
            goto SetupConnectoidExit;
        }
    }
    else
    {
        goto SetupConnectoidExit;
    }
    
    prasentry->dwCountryID = pSuggestInfo->rgpAccessEntry[irc]->dwCountryID;
    lstrcpyn(prasentry->szAreaCode,
                pSuggestInfo->rgpAccessEntry[irc]->szAreaCode,
                sizeof(prasentry->szAreaCode));
    lstrcpyn(prasentry->szLocalPhoneNumber,
                pSuggestInfo->rgpAccessEntry[irc]->szAccessNumber,
                sizeof(prasentry->szLocalPhoneNumber));

    prasentry->dwCountryCode = 0;
    prasentry->dwfOptions |= RASEO_UseCountryAndAreaCodes;

    // 10/19/96 jmazner Multiple modems problems
    // If no device name and type has been specified, grab the one we've stored
    // in ConfigRasEntryDevice

    if( 0 == lstrlen(prasentry->szDeviceName) )
    {
        // doesn't make sense to have an empty device name but a valid device type
        Assert( 0 == lstrlen(prasentry->szDeviceType) );

        // double check that we've already stored the user's choice.
        Assert( lstrlen(m_ISPImport.m_szDeviceName) );
        Assert( lstrlen(m_ISPImport.m_szDeviceType) );

        lstrcpyn( prasentry->szDeviceName, m_ISPImport.m_szDeviceName, lstrlen(m_ISPImport.m_szDeviceName) );
        lstrcpyn( prasentry->szDeviceType, m_ISPImport.m_szDeviceType, lstrlen(m_ISPImport.m_szDeviceType) );
    }

    // Write out new connectoid
    if (m_pcRNA)
        hr = m_pcRNA->RasSetEntryProperties(NULL, pszConnectoid, 
                                                (LPBYTE)prasentry, 
                                                dwRasentrySize, 
                                                (LPBYTE)prasdevinfo, 
                                                dwRasdevinfoSize);


    // Set this connetiod to have not proxy enabled
    TCHAR        szConnectionProfile[REGSTR_MAX_VALUE_LENGTH];
    
    lstrcpy(szConnectionProfile, c_szRASProfiles);
    lstrcat(szConnectionProfile, TEXT("\\"));
    lstrcat(szConnectionProfile,  pszConnectoid);
    
    reg.CreateKey(HKEY_CURRENT_USER, szConnectionProfile);
    reg.SetValue(c_szProxyEnable, (DWORD)0);
    
        
SetupConnectoidExit:

    *pbSuccess = FALSE;
    TCHAR    szBuff256[257];
    if (hr == ERROR_READING_ISP)
    {
        MsgBox(IDS_CANTREADMSNSUISP, MB_MYERROR);
    } else if (hr == ERROR_READING_DUN) {
        MsgBox(IDS_CANTREADMSDUNFILE, MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWPHBK.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_PHBK_NOT_FOUND) {
        wsprintf(szBuff256,GetSz(IDS_CANTLOADINETCFG),TEXT("ICWDL.DLL"));
        MessageBox(szBuff256,GetSz(IDS_TITLE),MB_MYERROR);
    } else if (hr == ERROR_USERBACK || hr == ERROR_USERCANCEL || hr == ERROR_SUCCESS) {
        // Do nothing
        *pbSuccess = TRUE;
    } else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
    } else if ((hr == ERROR_NO_MORE_ITEMS) || (hr == ERROR_INVALID_DATA)
                || (hr == ERROR_FILE_NOT_FOUND)) {
        MsgBox(IDS_CORRUPTPHONEBOOK, MB_MYERROR);
    } else if (hr != ERROR_SUCCESS) {
        wsprintf(szBuff256,TEXT("You can ignore this, just report it and include this number (%d).\n"),hr);
        AssertMsg(0,szBuff256);
        *pbSuccess = TRUE;
    }
    return hr;
}

// Form the Dialing URL.  Must be called after setting up for dialing.
HRESULT CRefDial::FormURL()
{
    USES_CONVERSION;

    TCHAR    szTemp[MAX_PATH];
    TCHAR    szPromo[MAX_PATH];
    TCHAR    szProd[MAX_PATH];
    TCHAR    szArea[MAX_PATH];
    TCHAR    szOEM[MAX_PATH];
    DWORD    dwCONNWIZVersion = 0;        // Version of CONNWIZ.HTM
        
    //
    // ChrisK Olympus 3997 5/25/97
    //
    TCHAR szRelProd[MAX_PATH];
    TCHAR szRelProdVer[MAX_PATH];
    HRESULT hr = ERROR_SUCCESS;
    OSVERSIONINFO osvi;


    //
    // Build URL complete with name value pairs
    //
    hr = GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_REFERAL_URL,&szTemp[0],256);
    if ('\0' == szTemp[0])
    {
        MsgBox(IDS_MSNSU_WRONG,MB_MYERROR);
        return hr;
    }
    
    Assert(szTemp[0]);

    ANSI2URLValue(m_szOEM,szOEM,0);
    ANSI2URLValue(m_lpGatherInfo->m_szAreaCode,szArea,0);
    if (m_bstrProductCode)
        ANSI2URLValue(OLE2A((BSTR)m_bstrProductCode),szProd,0);
    else
        ANSI2URLValue(DEFAULT_PRODUCTCODE,szProd,0);

    if (m_bstrPromoCode)
        ANSI2URLValue(OLE2A((BSTR)m_bstrPromoCode),szPromo,0);
    else
        ANSI2URLValue(DEFAULT_PROMOCODE,szProd,0);
        
    //
    // ChrisK Olympus 3997 5/25/97
    //
    ANSI2URLValue(m_lpGatherInfo->m_szRelProd, szRelProd, 0);
    ANSI2URLValue(m_lpGatherInfo->m_szRelVer, szRelProdVer, 0);
    ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi))
    {
        ZeroMemory(&osvi,sizeof(OSVERSIONINFO));
    }

#if defined(DEBUG)
    LoadTestingLocaleOverride(&m_lpGatherInfo->m_dwCountry, 
                                &m_lpGatherInfo->m_lcidUser);
#endif //DEBUG

    HINSTANCE hInstIcwconn = LoadLibrary(ICW_DOWNLOADABLE_COMPONENT_NAME);

    if (hInstIcwconn)
    {
        lpfnGetIcwconnVer = (GETICWCONNVER)GetProcAddress(hInstIcwconn, ICW_DOWNLOADABLE_COMPONENT_GETVERFUNC);
        // Get the version of ICWCONN.DLL
        if (lpfnGetIcwconnVer)
            dwCONNWIZVersion = lpfnGetIcwconnVer(); 
    
        FreeLibrary(hInstIcwconn);
    }


#if defined(DEBUG)
    if (FRefURLOverride())
    {
       TweakRefURL(szTemp, 
                   &m_lpGatherInfo->m_lcidUser, 
                   &m_lpGatherInfo->m_dwOS,
                   &m_lpGatherInfo->m_dwMajorVersion, 
                   &m_lpGatherInfo->m_dwMinorVersion,
                   &m_lpGatherInfo->m_wArchitecture, 
                   szPromo, 
                   szOEM, 
                   szArea, 
                   &m_lpGatherInfo->m_dwCountry,
                   &m_lpGatherInfo->m_szSUVersion[0], 
                   szProd, 
                   &osvi.dwBuildNumber, //For this we really want to LOWORD
                   szRelProd, 
                   szRelProdVer, 
                   &dwCONNWIZVersion, 
                   m_szPID, 
                   &m_lAllOffers);
    }
#endif //DEBUG

    // Autoconfig will set alloffers always.
    if ( m_lAllOffers || (m_lpGatherInfo->m_dwFlag & ICW_CFGFLAG_AUTOCONFIG) )
    {
        m_lpGatherInfo->m_dwFlag |= ICW_CFGFLAG_ALLOFFERS;
    }
    wsprintf(m_szUrl,TEXT("%slcid=%lu&sysdeflcid=%lu&appslcid=%lu&icwos=%lu&osver=%lu.%2.2d%s&arch=%u&promo=%s&oem=%s&area=%s&country=%lu&icwver=%s&prod=%s&osbld=%d&icwrp=%s&icwrpv=%s&wizver=%lu&PID=%s&cfgflag=%lu"),
                 szTemp,
                 m_lpGatherInfo->m_lcidUser,
                 m_lpGatherInfo->m_lcidSys,
                 m_lpGatherInfo->m_lcidApps,
                 m_lpGatherInfo->m_dwOS,
                 m_lpGatherInfo->m_dwMajorVersion,    
                 m_lpGatherInfo->m_dwMinorVersion,
                 ICW_OS_VER,
                 m_lpGatherInfo->m_wArchitecture, 
                 szPromo,
                 szOEM, 
                 szArea,
                 m_lpGatherInfo->m_dwCountry, 
                 &m_lpGatherInfo->m_szSUVersion[0], 
                 szProd,
                 LOWORD(osvi.dwBuildNumber), 
                 szRelProd, 
                 szRelProdVer,
                 dwCONNWIZVersion,
                 m_szPID,
                 m_lpGatherInfo->m_dwFlag);

    // Update registry values
    //
    wsprintf(m_lpGatherInfo->m_szISPFile,TEXT("%s\\%s"),g_pszAppDir,OLE2A(m_bstrISPFile));
    lstrcpyn(m_lpGatherInfo->m_szAppDir,g_pszAppDir,sizeof(m_lpGatherInfo->m_szAppDir));

    StoreInSignUpReg(
        (LPBYTE)m_lpGatherInfo,
        sizeof(GATHERINFO), 
        REG_BINARY, 
        GATHERINFOVALUENAME);  
    return hr;
}

static const TCHAR cszBrandingSection[] = TEXT("Branding");
static const TCHAR cszBrandingFlags[]   = TEXT("Flags");

static const TCHAR cszSupportSection[]  = TEXT("Support");
static const TCHAR cszSupportNumber[]   = TEXT("SupportPhoneNumber");

static const TCHAR cszLoggingSection[]  = TEXT("Logging");
static const TCHAR cszStartURL[]        = TEXT("StartURL");
static const TCHAR cszEndURL[]          = TEXT("EndURL");


void CRefDial::GetISPFileSettings(LPTSTR lpszFile)
{
    
    TCHAR szTemp[INTERNET_MAX_URL_LENGTH];

    GetINTFromISPFile(lpszFile, 
                      (LPTSTR)cszBrandingSection, 
                      (LPTSTR)cszBrandingFlags, 
                      (int FAR *)&m_lBrandingFlags, 
                      BRAND_DEFAULT);

    // Read the Support Number
    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPTSTR)cszSupportSection,
                                     (LPTSTR)cszSupportNumber,
                                     szTemp,
                                     sizeof(szTemp)))
        m_bstrSupportNumber = A2BSTR(szTemp);
    else
        m_bstrSupportNumber.Empty();


    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPTSTR)cszLoggingSection,
                                     (LPTSTR)cszStartURL,
                                     szTemp,
                                     sizeof(szTemp)))
        m_bstrLoggingStartUrl = A2BSTR(szTemp);
    else
        m_bstrLoggingStartUrl.Empty();


    if (ERROR_SUCCESS == GetDataFromISPFile(lpszFile,
                                     (LPTSTR)cszLoggingSection,
                                     (LPTSTR)cszEndURL,
                                     szTemp,
                                     sizeof(szTemp)))
        m_bstrLoggingEndUrl = A2BSTR(szTemp);
    else
        m_bstrLoggingEndUrl.Empty();

}

// This function will accept user selected values that are necessary to
// setup a connectiod for dialing
// Returns:
//      TRUE        OK to dial
//      FALSE       Some kind of problem
//                  QuitWizard - TRUE, then terminate
//                  UserPickNumber - TRUE, then display Pick a Number DLG
//                  QuitWizard and UserPickNumber both FALSE, then just
//                  display the page prior to Dialing UI.
STDMETHODIMP CRefDial::SetupForDialing
(
    BSTR bstrISPFile, 
    DWORD dwCountry, 
    BSTR bstrAreaCode, 
    DWORD dwFlag,
    BOOL *pbRetVal
)
{
    USES_CONVERSION;
    HRESULT             hr = S_OK;
    long                lRC = 0;
    LPLINECOUNTRYENTRY  pLCETemp;
    HINSTANCE           hPHBKDll = NULL;
    DWORD_PTR           dwPhoneBook = 0;
    DWORD               idx;
    BOOL                bSuccess = FALSE;
    BOOL                bConnectiodCreated = FALSE;   
    
    // Create a Window. We need a window, which will be hidden, so that we can process RAS status
    // messages
    RECT rcPos;
    Create(NULL, rcPos, NULL, 0, 0, 0 );
    
    // Initialize failure codes
    *pbRetVal = FALSE;
    m_bQuitWizard = FALSE;
    m_bUserPickNumber = FALSE;


    // Stuff the Area Code, and Country Code into the GatherInfo struct
    Assert(bstrAreaCode);
    lstrcpy(m_lpGatherInfo->m_szAreaCode,OLE2A(bstrAreaCode));

    m_lpGatherInfo->m_dwCountry = dwCountry;
    m_lpGatherInfo->m_dwFlag = dwFlag;

    // Make a copy of the ISP file we should use.
    Assert(bstrISPFile);
    m_bstrISPFile = bstrISPFile;

    // Read the ISP file stuff
    GetISPFileSettings(OLE2A(m_bstrISPFile));

    // Read the Connection File information which will create
    // a connectiod from the passed in ISP file
    switch(ReadConnectionInformation())
    {
        case ERROR_SUCCESS:
        {
            // Fill in static info into the GatherInfo sturct
            DWORD dwRet = FillGatherInfoStruct(m_lpGatherInfo);
            switch( dwRet )
            {
                case ERROR_FILE_NOT_FOUND:
                    MsgBox(IDS_MSNSU_WRONG,MB_MYERROR);
                    m_bQuitWizard = TRUE;
                    hr = S_FALSE;
                    break;
                case ERROR_SUCCESS:
                    //do nothing
                    break;
                default:
                    AssertMsg(dwRet, TEXT("FillGatherInfoStruct did not successfully complete.  DUNfile entry corrupt?"));
                    break;
            }
            break;
        }
        case ERROR_CANCELLED:
            hr = S_FALSE;
            m_bQuitWizard = TRUE;
            goto SetupForDialingExit;
            break;
        case ERROR_RETRY:
            m_bTryAgain = TRUE;
            hr = S_FALSE;
            break;
        default:
            MsgBox(IDS_MSNSU_WRONG,MB_MYERROR);
            hr = S_FALSE;
            break;
    }

    //  If we failed for some reason above, we need to return
    //  the error to the caller, and Quit The Wizard.
    if (S_OK != hr)
        goto SetupForDialingExit;

    //  we need to pass a valid window handle to  lineTranslateDialog 
    //  API call -MKarki (4/17/97) Fix for Bug #428
    //
    if (m_lpGatherInfo != NULL)
    {
        m_lpGatherInfo->m_hwnd = GetActiveWindow();
    }

    //
    // Fill in country
    //
    m_lpGatherInfo->m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    Assert(m_lpGatherInfo->m_pLineCountryList);
    m_lpGatherInfo->m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);

    //
    // figure out how much memory we will need
    //
    lRC = lineGetCountry(m_lpGatherInfo->m_dwCountry,0x10004,
                            m_lpGatherInfo->m_pLineCountryList);
    
    if ( lRC && lRC != LINEERR_STRUCTURETOOSMALL)
        AssertMsg(0,TEXT("lineGetCountry error"));
    
    Assert(m_lpGatherInfo->m_pLineCountryList->dwNeededSize);
    
    LPLINECOUNTRYLIST pLineCountryTemp;
    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR, 
                                                        ((size_t)m_lpGatherInfo->m_pLineCountryList->dwNeededSize));
    Assert (pLineCountryTemp);

        
    //
    // initialize structure
    //
    pLineCountryTemp->dwTotalSize = m_lpGatherInfo->m_pLineCountryList->dwNeededSize;
    GlobalFree(m_lpGatherInfo->m_pLineCountryList);
    m_lpGatherInfo->m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

    //
    // fetch information from TAPI
    //
    lRC = lineGetCountry(m_lpGatherInfo->m_dwCountry,0x10004,
                            m_lpGatherInfo->m_pLineCountryList);
    if (lRC)
    {
        Assert(0);
        m_bQuitWizard = TRUE;
        // BUGBUG Probably should have an error message here
        goto SetupForDialingExit;
   }


    //
    // On Windows 95, lineGetCountry has a bug -- if we try to retrieve the 
    // dialing properties of just one country (i.e, if the first parameter is
    // not zero), it returns m_pLineCountryList->dwNumCountries = 0!!
    // But the m_pLineCountryList still has valid data
    //
    if (VER_PLATFORM_WIN32_NT != g_dwPlatform)
    {
        if (0 == m_lpGatherInfo->m_pLineCountryList->dwNumCountries)
            m_lpGatherInfo->m_pLineCountryList->dwNumCountries = 1;
    }

    pLCETemp = (LPLINECOUNTRYENTRY)((UINT_PTR)m_lpGatherInfo->m_pLineCountryList + 
                                    (UINT)m_lpGatherInfo->m_pLineCountryList->dwCountryListOffset);

    //
    // build look up array
    //
    m_lpGatherInfo->m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,((size_t)(sizeof(CNTRYNAMELOOKUPELEMENT)
        * m_lpGatherInfo->m_pLineCountryList->dwNumCountries)));

    for (idx=0; idx < m_lpGatherInfo->m_pLineCountryList->dwNumCountries;
            idx++)
    {
        m_lpGatherInfo->m_rgNameLookUp[idx].psCountryName = (LPTSTR)((DWORD_PTR)m_lpGatherInfo->m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_lpGatherInfo->m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
        m_lpGatherInfo->m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
        AssertMsg(m_lpGatherInfo->m_rgNameLookUp[idx].psCountryName[0],
                    TEXT("Blank country name in look up array"));
    }

    // Prepare to Setup for Dialing, which will use the phonebook
    // to get a suggested number 
    hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
    AssertMsg(hPHBKDll != NULL,TEXT("Phonebook DLL is missing"));
    if (!hPHBKDll)
    {
        //
        // TODO: BUGBUG Pop-up error message
        //
        m_bQuitWizard = TRUE;
        goto SetupForDialingExit;
    }

 
    // Setup, and possible create a connectiod
    hr = SetupForRASDialing(m_lpGatherInfo, 
                         hPHBKDll,
                         &dwPhoneBook,
                         &m_pSuggestInfo,
                         &m_szConnectoid[0],
                         &bConnectiodCreated);
    if (ERROR_SUCCESS != hr)
    {
        m_bQuitWizard = TRUE;
        goto SetupForDialingExit;
    }

    // If we have a RASENTRY struct from SetupForRASDialing, then just use it
    // otherwise use the suggest info
    if (!bConnectiodCreated)
    {
        
        // If there is only 1 suggested number, then we setup the
        // connectiod, and we are ready to dial
        if (1 == m_pSuggestInfo->wNumber)
        {
            SetupConnectoid(m_pSuggestInfo, 0, &m_szConnectoid[0],
                                sizeof(m_szConnectoid), &bSuccess);
            if( !bSuccess )
            {
                m_bQuitWizard = TRUE;
                goto SetupForDialingExit;
            }
        }
        else
        {
            // More than 1 entry in the Phonebook, so we need to
            // ask the user which one they want to use
            if (m_pSuggestInfo->wNumber > 1)
            {
                // we are going to have to save these values for later
                if (m_rgpSuggestedAE)
                {
                    // We allocated an extra pointer so we'd have NULL on the
                    // end of the list and this for loop will work
                    for (int i=0; m_rgpSuggestedAE[i]; i++)
                        GlobalFree(m_rgpSuggestedAE[i]);
                    GlobalFree(m_rgpSuggestedAE);
                    m_rgpSuggestedAE = NULL;
                }

                // We first need to allocate space for the pointers.
                // We'll allocate an extra one so that we will have
                // a NULL pointer at the end of the list for when
                // we free g_rgpSuggestedAE. We don't need to set
                // the pointers to NULL because GPTR includes a flag
                // to tell GlobalAlloc to initialize the memory to zero.
                m_rgpSuggestedAE = (PACCESSENTRY*)GlobalAlloc(GPTR,
                    sizeof(PACCESSENTRY)*(m_pSuggestInfo->wNumber + 1));

                if (NULL == m_rgpSuggestedAE)
                    hr = E_ABORT;
                else if (m_pSuggestInfo->rgpAccessEntry)
                {
                    for (UINT i=0; i < m_pSuggestInfo->wNumber; i++)
                    {
                        m_rgpSuggestedAE[i] = (PACCESSENTRY)GlobalAlloc(GPTR, sizeof(ACCESSENTRY));
                        if (NULL == m_rgpSuggestedAE[i])
                        {
                            hr = E_ABORT;
                            break; // for loop
                        }
                        memmove(m_rgpSuggestedAE[i], m_pSuggestInfo->rgpAccessEntry[i],
                                sizeof(ACCESSENTRY));
                    }
                    m_pSuggestInfo->rgpAccessEntry = m_rgpSuggestedAE;
                }

                if (E_ABORT == hr)
                {
                    MsgBox(IDS_OUTOFMEMORY,MB_MYERROR);
                    m_bQuitWizard = TRUE;
                    goto SetupForDialingExit;
                }

                m_bUserPickNumber = TRUE;
                goto SetupForDialingExit;
            }
            else
            {
                // Call RAS to have the user pick a number to dial
                hr = UserPickANumber(   GetActiveWindow(), m_lpGatherInfo, 
                                        m_pSuggestInfo,
                                        hPHBKDll,
                                        dwPhoneBook,
                                        &m_szConnectoid[0],
                                        sizeof(m_szConnectoid), 
                                        0);
                if (ERROR_USERBACK == hr)
                {
                    goto SetupForDialingExit;
                }
                else if (ERROR_USERCANCEL == hr)
                {
                    m_bQuitWizard = TRUE;
                    goto SetupForDialingExit;
                }
                else if (ERROR_SUCCESS != hr)
                {
                    // Go back to prev page.
                    goto SetupForDialingExit;
                }

                // Error SUCCESS will fall through and set pbRetVal to TRUE below
            }
        }
    }

    // Success if we get to here
    *pbRetVal = TRUE;

    // Generate a Displayable number
    m_hrDisplayableNumber = GetDisplayableNumber();

SetupForDialingExit:

    if (hPHBKDll)
    {
        if (dwPhoneBook)
        {
            FARPROC fp = GetProcAddress(hPHBKDll,PHBK_UNLOADAPI);
            ASSERT(fp);
            ((PFNPHONEBOOKUNLOAD)fp)(dwPhoneBook);
            dwPhoneBook = 0;
        }
        FreeLibrary(hPHBKDll);
        hPHBKDll = NULL;
    }
    return S_OK;
}


STDMETHODIMP CRefDial::RemoveConnectoid(BOOL * pVal)
{
    if (m_hrasconn)
        DoHangup();

    if (m_pSuggestInfo)
    {
        GlobalFree(m_pSuggestInfo->rgpAccessEntry);
        
        GlobalFree(m_pSuggestInfo);
        m_pSuggestInfo = NULL;
    }

    if( (m_pcRNA!=NULL) && (m_szConnectoid[0]!='\0') )
    {
       m_pcRNA->RasDeleteEntry(NULL,m_szConnectoid);
       delete m_pcRNA;
       m_pcRNA = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_QuitWizard(BOOL * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bQuitWizard;    
    return S_OK;
}

STDMETHODIMP CRefDial::get_UserPickNumber(BOOL * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bUserPickNumber;    
    return S_OK;
}

STDMETHODIMP CRefDial::get_DialPhoneNumber(BSTR * pVal)
{
    USES_CONVERSION;
    if (pVal == NULL)
        return E_POINTER;
    if (m_hrDisplayableNumber == ERROR_SUCCESS)
        *pVal = A2BSTR(m_pszDisplayable);
    else
        *pVal = A2BSTR(m_szPhoneNumber);
    return S_OK;
}


STDMETHODIMP CRefDial::put_DialPhoneNumber(BSTR newVal)
{
    USES_CONVERSION;

    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    HRESULT                 hr;

    // Get the current RAS entry properties
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);

    if (NULL ==lpRasDevInfo)
    {
        dwRasDevInfoSize = 0;
    }

    if (hr == ERROR_SUCCESS && NULL != lpRasEntry)
    {
        // Replace the phone number with the new one
        //
        lstrcpy(lpRasEntry->szLocalPhoneNumber, OLE2A(newVal));

        // non-zero dummy values are required due to bugs in win95
        lpRasEntry->dwCountryID = 1;
        lpRasEntry->dwCountryCode = 1;
        lpRasEntry->szAreaCode[1] = '\0';
        lpRasEntry->szAreaCode[0] = '8';

        // Set to dial as is
        //
        lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

        pcRNA = new RNAAPI;
        if (pcRNA)
        {
#if defined(DEBUG)
            TCHAR szMsg[256];
            OutputDebugString(TEXT("CRefDial::put_DialPhoneNumber - MyRasGetEntryProperties()"));
            wsprintf(szMsg, TEXT("lpRasEntry->dwfOptions: %ld"), lpRasEntry->dwfOptions);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->dwCountryID: %ld"), lpRasEntry->dwCountryID);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->dwCountryCode: %ld"), lpRasEntry->dwCountryCode);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->szAreaCode: %s"), lpRasEntry->szAreaCode);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->szLocalPhoneNumber: %s"), lpRasEntry->szLocalPhoneNumber);
            OutputDebugString(szMsg);
            wsprintf(szMsg, TEXT("lpRasEntry->dwAlternateOffset: %ld"), lpRasEntry->dwAlternateOffset);
            OutputDebugString(szMsg);
#endif //DEBUG

            pcRNA->RasSetEntryProperties(NULL,
                                         m_szConnectoid,
                                         (LPBYTE)lpRasEntry,
                                         dwRasEntrySize,
                                         (LPBYTE)lpRasDevInfo,
                                         dwRasDevInfoSize);

            delete pcRNA;
        }
    }

    // Regenerate the displayable number
    GetDisplayableNumber();

    return S_OK;
}

STDMETHODIMP CRefDial::get_URL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_ISPINFO, INF_REFERAL_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_PromoCode(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bstrPromoCode.Copy();    
    return S_OK;
}

STDMETHODIMP CRefDial::put_PromoCode(BSTR newVal)
{
    if (newVal && wcslen(newVal))
        m_bstrPromoCode = newVal;
    return S_OK;
}

STDMETHODIMP CRefDial::get_ProductCode(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrProductCode;
    return S_OK;
}

STDMETHODIMP CRefDial::put_ProductCode(BSTR newVal)
{
    if (newVal && wcslen(newVal))
        m_bstrProductCode = newVal;
    return S_OK;
}

STDMETHODIMP CRefDial::put_OemCode(BSTR newVal)
{
    USES_CONVERSION;

    if (newVal && wcslen(newVal))
        lstrcpy(m_szOEM, OLE2A(newVal));
    return S_OK;
}

STDMETHODIMP CRefDial::put_AllOfferCode(long newVal)
{
        m_lAllOffers = newVal;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoOfferDownload
//
//  Synopsis:   Download the ISP offer from the ISP server
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::DoOfferDownload(BOOL *pbRetVal)
{
    HRESULT hr;
       RNAAPI  *pcRNA;

 
    //
    // Hide RNA window on Win95 retail
    //
//        MinimizeRNAWindow(m_pszConnectoid,g_hInst);
        // 4/2/97    ChrisK    Olympus 296
//        g_hRNAZapperThread = LaunchRNAReestablishZapper(g_hInst);
    //
    // The connection is open and ready.  Start the download.
    //
    m_dwThreadID = 0;
    m_hThread = CreateThread(NULL,
                             0,
                             (LPTHREAD_START_ROUTINE)DownloadThreadInit,
                             (LPVOID)this,
                             0,
                             &m_dwThreadID);

    // 5-1-97    ChrisK Olympus 2934
//    m_objBusyMessages.Start(m_hWnd,IDC_LBLSTATUS,m_hrasconn);

    // If we dont get the donwload thread, then kill the open
    // connection
    if (!m_hThread)
    {
        hr = GetLastError();
        if (m_hrasconn)
        {
            pcRNA = new RNAAPI;
            if (pcRNA)
            {
                pcRNA->RasHangUp(m_hrasconn);
                m_hrasconn = NULL;
                delete pcRNA;
                pcRNA = NULL;
            }
        }

        *pbRetVal = FALSE;
    }
    else
    {
        // Download has started.
        m_bDownloadHasBeenCanceled = FALSE;
        *pbRetVal = TRUE;
    }        
    return S_OK;
}

STDMETHODIMP CRefDial::get_DialStatusString(BSTR * pVal)
{
    USES_CONVERSION;
    if (pVal == NULL)
         return E_POINTER;
    if (m_RasStatusID)
    {
        if (m_bRedial)
        {
            switch (m_RasStatusID)
            {
                case IDS_RAS_DIALING:
                case IDS_RAS_PORTOPENED:
                case IDS_RAS_OPENPORT:
                {
                    *pVal = A2BSTR(GetSz(IDS_RAS_REDIALING));
                    return S_OK;
                }
                default:
                    break;
            }
        }    
        *pVal = A2BSTR(GetSz((USHORT)m_RasStatusID));
    }
    else
        *pVal = A2BSTR(TEXT(""));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoInit
//
//  Synopsis:   Initialize cancel status and the displayable number for this
//              round of dialing.
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::DoInit()
{
    m_bWaitingToHangup = FALSE;

    // Update the phone number to display if user has changed dialing properties
    // This function should be called re-init the dialing properties.
    // SetupforDialing should be called prior to this.
    GetDisplayableNumber();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoHangup
//
//  Synopsis:   Hangup the modem for the currently active RAS session
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::DoHangup()
{
    RNAAPI  *pcRNA;

    // Set the disconnect flag as the system may be too busy with dialing.
    // Once we get a chance to terminate dialing, we know we have to hangup
    m_bWaitingToHangup = TRUE;
    if (NULL != m_hrasconn)
    {
        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            pcRNA->RasHangUp(m_hrasconn);
            m_hrasconn = NULL;
            delete pcRNA;
            pcRNA = NULL;
        }
    }

    return (m_hrasconn == NULL) ? S_OK : E_POINTER;
}


STDMETHODIMP CRefDial::ProcessSignedPID(BOOL * pbRetVal)
{
    USES_CONVERSION;
    HANDLE  hfile;
    DWORD   dwFileSize;
    DWORD   dwBytesRead;
    LPBYTE  lpbSignedPID;
    LPTSTR  lpszSignedPID;

    *pbRetVal = FALSE;

    // Open the PID file for Binary Reading.  It will be in the CWD
    if (INVALID_HANDLE_VALUE != (hfile = CreateFile(c_szSignedPIDFName,
                                                  GENERIC_READ,
                                                  0,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL)))
    {
        dwFileSize = GetFileSize(hfile, NULL);
        
        // Allocate a buffer to read the file, and one to store the BINHEX version
        lpbSignedPID = new BYTE[dwFileSize];
        lpszSignedPID = new TCHAR[(dwFileSize * 2) + 1];

        if (lpbSignedPID && lpszSignedPID)
        {
            if (ReadFile(hfile, (LPVOID) lpbSignedPID, dwFileSize, &dwBytesRead, NULL) &&
                    (dwFileSize == dwBytesRead))
            {
                // BINHEX the signed PID data so we can send it to the signup server
                DWORD   dwX = 0;
                BYTE    by;
                for (DWORD dwY = 0; dwY < dwFileSize; dwY++)
                {
                    by = lpbSignedPID[dwY];
                    lpszSignedPID[dwX++] = g_BINTOHEXLookup[((by & 0xF0) >> 4)];
                    lpszSignedPID[dwX++] = g_BINTOHEXLookup[(by & 0x0F)];
                }
                lpszSignedPID[dwX] = '\0';

                // Convert the signed pid to a BSTR
                m_bstrSignedPID = A2BSTR(lpszSignedPID);

                // Set the return value
                *pbRetVal = TRUE;
            }

            // Free the buffers we allocated
            delete[] lpbSignedPID;
            delete[] lpszSignedPID;
        }

        // Close the File
        CloseHandle(hfile);

#ifndef DEBUG
        // Delete the File
        // defer removal of this file until the container app exits.
        // see BUG 373.
        //DeleteFile(c_szSignedPIDFName);
#endif
    }

    return S_OK;
}

STDMETHODIMP CRefDial::get_SignedPID(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bstrSignedPID.Copy();    
    return S_OK;
}

STDMETHODIMP CRefDial::FormReferralServerURL(BOOL * pbRetVal)
{
    // Form the URL to be used to access the referal server
    if (ERROR_SUCCESS != FormURL())
        *pbRetVal = FALSE;
    else
        *pbRetVal = TRUE;

    return S_OK;
}

STDMETHODIMP CRefDial::get_SignupURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_SIGNUP_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_AutoConfigURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_AUTOCONFIG_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_ISDNURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the ISDN URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_ISDN_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    if (0 == szTemp[0] || NULL == *pVal)
    {
        // Get the sign up URL from the ISP file, and then convert it
        if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_SIGNUP_URL,&szTemp[0],256)))
        {
            *pVal = A2BSTR(szTemp);
        }
        else
        {
            *pVal = NULL;
        }

    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_ISDNAutoConfigURL(BSTR * pVal)
{
    USES_CONVERSION;
    TCHAR szTemp[256];

    if (pVal == NULL)
        return E_POINTER;

    // Get the URL from the ISP file, and then convert it
    if (SUCCEEDED(GetDataFromISPFile(OLE2A(m_bstrISPFile),INF_SECTION_URL, INF_ISDN_AUTOCONFIG_URL,&szTemp[0],256)))
    {
        *pVal = A2BSTR(szTemp);
    }
    else
    {
        *pVal = NULL;
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_TryAgain(BOOL * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bTryAgain;    
    return S_OK;
}

STDMETHODIMP CRefDial::get_DialError(HRESULT * pVal)
{
    *pVal = m_hrDialErr;
    
    return S_OK;
}

STDMETHODIMP CRefDial::put_ModemOverride(BOOL newbVal)
{
    m_bModemOverride = newbVal;
    return S_OK;
}

STDMETHODIMP CRefDial::put_Redial(BOOL newbVal)
{
    m_bRedial = newbVal;

    return S_OK;
}

STDMETHODIMP CRefDial::get_DialErrorMsg(BSTR * pVal)
{
    USES_CONVERSION;

    if (pVal == NULL)
        return E_POINTER;

    if (m_hrDialErr != ERROR_SUCCESS)
    {
        DWORD dwIDS = RasErrorToIDS(m_hrDialErr);
        if (dwIDS != -1 && dwIDS !=0)
        {
            *pVal = A2BSTR(GetSz((WORD)dwIDS));
        }
        else
        {
            *pVal = A2BSTR(GetSz(IDS_PPPRANDOMFAILURE));
        }
    }
    else
    {
        *pVal = A2BSTR(GetSz(IDS_PPPRANDOMFAILURE));
    }
    return S_OK;
}

STDMETHODIMP CRefDial::ModemEnum_Reset()
{
    m_emModemEnum.ResetIndex();

    return S_OK;
}

STDMETHODIMP CRefDial::ModemEnum_Next(BSTR *pDeviceName)
{
    if (pDeviceName == NULL)
        return E_POINTER;

    *pDeviceName = A2BSTR(m_emModemEnum.Next());
    return S_OK;
}

STDMETHODIMP CRefDial::get_ModemEnum_NumDevices(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    m_emModemEnum.ReInit();
    *pVal = m_emModemEnum.GetNumDevices();

    if(m_ISPImport.m_szDeviceName[0]!='\0')
    {
        //
        // Find out what the current device index is
        //
        for(int l=0; l<(*pVal); l++)
        {
            if(lstrcmp(m_ISPImport.m_szDeviceName,m_emModemEnum.GetDeviceName(l))==0)
            {
                m_lCurrentModem = l;
                break;
            }
        }
        if(l == (*pVal))
            m_lCurrentModem = -1;
    }
    else
        m_lCurrentModem = -1;
    
    return S_OK;
}

STDMETHODIMP CRefDial::get_SupportNumber(BSTR * pVal)
{
    USES_CONVERSION;

    TCHAR    szSupportNumber[MAX_PATH];

    if (pVal == NULL)
        return E_POINTER;

    if (m_SupportInfo.GetSupportInfo(szSupportNumber, m_dwCountryCode))
        *pVal = A2BSTR(szSupportNumber);
    else
        *pVal = NULL;

    return S_OK;
}

STDMETHODIMP CRefDial::get_ISPSupportNumber(BSTR * pVal)
{
    USES_CONVERSION;

    if (pVal == NULL)
        return E_POINTER;

    if (*m_szISPSupportNumber)
        *pVal = A2BSTR(m_szISPSupportNumber);
    else
        *pVal = NULL;

    return S_OK;
}

STDMETHODIMP CRefDial::ShowDialingProperties(BOOL * pbRetVal)
{
    HRESULT hr;
    DWORD   dwNumDev = 0;

    *pbRetVal = FALSE;
    
    hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,(LPSTR)NULL,&dwNumDev);

    if (hr == ERROR_SUCCESS)
    {
        LPLINEEXTENSIONID lpExtensionID;
        
        
        if (m_dwTapiDev == 0xFFFFFFFF)
        {
                m_dwTapiDev = 0;
        }

        lpExtensionID = (LPLINEEXTENSIONID)GlobalAlloc(GPTR,sizeof(LINEEXTENSIONID));
        if (lpExtensionID)
        {
            //
            // Negotiate version - without this call
            // lineTranslateDialog would fail
            //
            do {
                hr = lineNegotiateAPIVersion(m_hLineApp, 
                                             m_dwTapiDev, 
                                             0x00010004, 0x00010004,
                                             &m_dwAPIVersion, 
                                             lpExtensionID);

            } while ((hr != ERROR_SUCCESS) && (m_dwTapiDev++ < dwNumDev - 1));

            if (m_dwTapiDev >= dwNumDev)
            {
                m_dwTapiDev = 0;
            }

            //
            // ditch it since we don't use it
            //
            GlobalFree(lpExtensionID);
            lpExtensionID = NULL;

            if (hr == ERROR_SUCCESS)
            {
                hr = lineTranslateDialog(m_hLineApp,
                                         m_dwTapiDev,
                                         m_dwAPIVersion,
                                         GetActiveWindow(),
                                         m_szPhoneNumber);

                lineShutdown(m_hLineApp);
                m_hLineApp = NULL;
            }
        }
    }
    
    if (hr == ERROR_SUCCESS)
    {
        GetDisplayableNumber();
        *pbRetVal = TRUE;
    }        
    
    return S_OK;
}

STDMETHODIMP CRefDial::ShowPhoneBook(DWORD dwCountryCode, long newVal, BOOL * pbRetVal)
{
    USES_CONVERSION;

    DWORD_PTR   dwPhoneBook;
    HINSTANCE   hPHBKDll;
    FARPROC     fp;
    BOOL        bBookLoaded = FALSE;

    *pbRetVal = FALSE;      // Assume Failure

    hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
    if (hPHBKDll)
    {
        if (NULL != (fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI)))
        {
            if (ERROR_SUCCESS  == ((PFNPHONEBOOKLOAD)fp)(OLE2A(m_bstrISPFile),&dwPhoneBook))
            {
                bBookLoaded = TRUE;
                m_pSuggestInfo->dwCountryID = dwCountryCode;

                // Update the device type so we can distinguish ISDN numbers
                TCHAR *pszNewType = m_emModemEnum.GetDeviceType(newVal);
                m_ISPImport.m_bIsISDNDevice = (lstrcmpi(pszNewType, RASDT_Isdn) == 0);
                m_lpGatherInfo->m_fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
                m_lpGatherInfo->m_bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);

                if (ERROR_SUCCESS == UserPickANumber(GetActiveWindow(), 
                                                     m_lpGatherInfo, 
                                                     m_pSuggestInfo,
                                                     hPHBKDll,
                                                     dwPhoneBook,
                                                     &m_szConnectoid[0],
                                                     sizeof(m_szConnectoid),
                                                     DIALERR_IN_PROGRESS))
                {
                    // Regenerate the displayable number
                    GetDisplayableNumber();
                    
                    // Base the Country code on the ras entry, since it was
                    // directly modified in this case
                    LPRASENTRY              lpRasEntry = NULL;
                    LPRASDEVINFO            lpRasDevInfo = NULL;
                    DWORD                   dwRasEntrySize = 0;
                    DWORD                   dwRasDevInfoSize = 0;
                    
                    if (SUCCEEDED(MyRasGetEntryProperties(NULL,
                                                        m_szConnectoid,
                                                        &lpRasEntry,
                                                        &dwRasEntrySize,
                                                        &lpRasDevInfo,
                                                        &dwRasDevInfoSize)))
                    {
                        m_dwCountryCode = lpRasEntry->dwCountryCode;
                    }
                    
                    // Set the return code
                    *pbRetVal = TRUE;
                }
            }
        }
        FreeLibrary(hPHBKDll);
    }


    if (! bBookLoaded)
    {
        // Give the user a message
        MsgBox(IDS_CANTINITPHONEBOOK,MB_MYERROR);
    }
    return S_OK;
}

BOOL CRefDial::IsSBCSString( TCHAR *sz )
{
    Assert(sz);

#ifdef UNICODE
    // Check if the string contains only ASCII chars.
    int attrib = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
    return (BOOL)IsTextUnicode(sz, lstrlen(sz), &attrib);
#else
    while( NULL != *sz )
    {
         if (IsDBCSLeadByte(*sz)) return FALSE;
         sz++;
    }

    return TRUE;
#endif
}

TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

STDMETHODIMP CRefDial::ValidatePhoneNumber(BSTR bstrPhoneNumber, BOOL * pbRetVal)
{
    USES_CONVERSION;

    // Bail if an empty string is passed
    if (!bstrPhoneNumber || !wcslen(bstrPhoneNumber))
    {
        MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
        *pbRetVal = FALSE;
        return(S_OK);
    }
    
    // Check that the phone number only contains valid characters
    LPTSTR   lpNum, lpValid;
    LPTSTR   lpszDialNumber = OLE2A(bstrPhoneNumber);

    // vyung 03/06/99 Remove Easter egg as requested by NT5
#ifdef ICW_EASTEREGG
    if (lstrcmp(lpszDialNumber, c_szCreditsMagicNum) == 0)
    {
        ShowCredits();
        *pbRetVal = FALSE;
        return(S_OK);
    }
#endif
    
    *pbRetVal = TRUE;

    if (!IsSBCSString(lpszDialNumber))
    {
        MsgBox(IDS_SBCSONLY,MB_MYEXCLAMATION);
        *pbRetVal = FALSE;
    }
    else
    {

        for (lpNum = lpszDialNumber;*lpNum;lpNum++)
        {
            for(lpValid = szValidPhoneCharacters;*lpValid;lpValid++)
            {
                if (*lpNum == *lpValid)
                {
                    break; // p2 for loop
                }
            }
            if (!*lpValid) 
            {
                break; // p for loop
            }
        }
    }

    if (*lpNum)
    {
        MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
        *pbRetVal = FALSE;
    }

    return S_OK;
}

STDMETHODIMP CRefDial::get_HavePhoneBook(BOOL * pVal)
{
    USES_CONVERSION;

    DWORD_PTR   dwPhoneBook;
    HINSTANCE   hPHBKDll;
    FARPROC     fp;

    if (pVal == NULL)
        return E_POINTER;

    // Assume failure.
    *pVal = FALSE;

    // Try to load the phone book
    hPHBKDll = LoadLibrary(PHONEBOOK_LIBRARY);
    if (hPHBKDll)
    {
        if (NULL != (fp = GetProcAddress(hPHBKDll,PHBK_LOADAPI)))
        {
            if (ERROR_SUCCESS  == ((PFNPHONEBOOKLOAD)fp)(OLE2A(m_bstrISPFile),&dwPhoneBook))
            {
                *pVal = TRUE;    // Got IT!
            }
        }
        FreeLibrary(hPHBKDll);
    }
    return S_OK;
}

STDMETHODIMP CRefDial::get_BrandingFlags(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_lBrandingFlags;

    return S_OK;
}

STDMETHODIMP CRefDial::put_BrandingFlags(long newVal)
{
    m_lBrandingFlags = newVal;

    return S_OK;
}

/**********************************************************************/
//  
// FUNCTION:   get_CurrentModem
//             put_CurrentModem
//
// DESCRIPTION:
//   These functions are used to set the current modem
//   based on the enumerated modem list, and should only
//   be used after taking a snapshot of the modem list
//   with the ModemEnum_* functions.  The functions are also
//   intended to be used with an existing RAS connectoid, not
//   to set-up the RefDial object before connecting.
//
// HISTORY:
//
//   donsc - 3/11/98   Added these functions to support the dial error
//                     page in the HTML JavaScript code.
//
/**********************************************************************/

//
// get_CurrentModem will return -1 if the modem list was not enumerated
// or no modem has been selected for this RefDial object
//
STDMETHODIMP CRefDial::get_CurrentModem(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_lCurrentModem;

    return S_OK;
}


STDMETHODIMP CRefDial::put_CurrentModem(long newVal)
{
    LPRASENTRY              lpRasEntry = NULL;
    LPRASDEVINFO            lpRasDevInfo = NULL;
    DWORD                   dwRasEntrySize = 0;
    DWORD                   dwRasDevInfoSize = 0;
    RNAAPI                  *pcRNA = NULL;
    HRESULT                 hr = S_OK;

    TCHAR *pszNewName = m_emModemEnum.GetDeviceName(newVal);
    TCHAR *pszNewType = m_emModemEnum.GetDeviceType(newVal);

    if((pszNewName==NULL) || (pszNewType==NULL))
        return E_INVALIDARG;

    if(m_lCurrentModem == newVal)
        return S_OK;

    //
    // Must have a connectoid already established to set the
    // current modem.
    //
    if(m_szConnectoid[0]=='\0')
        return E_FAIL;

    // Get the current RAS entry properties
    hr = MyRasGetEntryProperties(NULL,
                                m_szConnectoid,
                                &lpRasEntry,
                                &dwRasEntrySize,
                                &lpRasDevInfo,
                                &dwRasDevInfoSize);

    //
    // The MyRas function returns 0 on success, not technically
    // an HRESULT
    //
    if(hr!=0 || NULL == lpRasEntry)
        hr = E_FAIL;

    lpRasDevInfo = NULL;
    dwRasDevInfoSize = 0;

    if (SUCCEEDED(hr))
    {
        //
        // Retrieve the dial entry params of the existing entry
        //
        LPRASDIALPARAMS lpRasDialParams = (LPRASDIALPARAMS)GlobalAlloc(GPTR,sizeof(RASDIALPARAMS));
        BOOL bPW = FALSE;

        if (!lpRasDialParams)
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            goto PutModemExit;
        }
        lpRasDialParams->dwSize = sizeof(RASDIALPARAMS);
        lstrcpyn(lpRasDialParams->szEntryName,m_szConnectoid,sizeof(lpRasDialParams->szEntryName));
        bPW = FALSE;
        hr = MyRasGetEntryDialParams(NULL,lpRasDialParams,&bPW);
        
        if (FAILED(hr))
            goto PutModemExit;

        //
        // Enter the new ras device info.
        //
        lstrcpy(lpRasEntry->szDeviceName,pszNewName);
        lstrcpy(lpRasEntry->szDeviceType,pszNewType);

        //
        // Set to dial as is
        //

        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            //
            // When changing the actual device, it is not always reliable
            // to just set the new properties. We need to remove the
            // previous entry and create a new one.
            //
            pcRNA->RasDeleteEntry(NULL,m_szConnectoid);
            
            if(pcRNA->RasSetEntryProperties(NULL,
                                        m_szConnectoid,
                                        (LPBYTE)lpRasEntry,
                                        dwRasEntrySize,
                                        (LPBYTE)NULL,
                                        0)==0)
            {
                //
                // And set the other dialing parameters
                //
                if(pcRNA->RasSetEntryDialParams(NULL,lpRasDialParams,!bPW)!=0)
                    hr = E_FAIL;
            }
            else
                hr = E_FAIL;

            delete pcRNA;
        }
        else
            hr = E_FAIL;

        GlobalFree(lpRasDialParams);
    }

PutModemExit:

    if(SUCCEEDED(hr))
    {
        m_lCurrentModem = newVal;
        lstrcpy(m_ISPImport.m_szDeviceName,pszNewName);
        lstrcpy(m_ISPImport.m_szDeviceType,pszNewType);
        
        // Get the device name and type in the registry, since ConfigRasEntryDevice
        // will use them.  ConfigRasEntryDevice is called when the new connectoid
        // is being created, so if the user changes the modem, we want that
        // reflected in the new connectoid (BUG 20841)
        m_ISPImport.SetDeviceSelectedByUser(DEVICENAMEKEY, pszNewName);
        m_ISPImport.SetDeviceSelectedByUser (DEVICETYPEKEY, pszNewType);

        m_ISPImport.m_bIsISDNDevice = (lstrcmpi(pszNewType, RASDT_Isdn) == 0);
        m_lpGatherInfo->m_fType = TYPE_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
        m_lpGatherInfo->m_bMask = MASK_SIGNUP_ANY | (m_ISPImport.m_bIsISDNDevice ? MASK_ISDN_BIT:MASK_ANALOG_BIT);
    }

    return hr;
}

STDMETHODIMP CRefDial::get_ISPSupportPhoneNumber(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrSupportNumber.Copy();
    return S_OK;
}

STDMETHODIMP CRefDial::put_ISPSupportPhoneNumber(BSTR newVal)
{
    // TODO: Add your implementation code here
    m_bstrSupportNumber = newVal;
    return S_OK;
}

STDMETHODIMP CRefDial::get_LoggingStartUrl(BSTR * pVal)
{
    if(pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrLoggingStartUrl;

    return S_OK;
}

STDMETHODIMP CRefDial::get_LoggingEndUrl(BSTR * pVal)
{
    if(pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrLoggingEndUrl;

    return S_OK;
}


void CRefDial::ShowCredits()
{
#ifdef ICW_EASTEREGG

    HINSTANCE   hinstMSHTML = LoadLibrary(TEXT("MSHTML.DLL"));

    if(hinstMSHTML)
    {
        SHOWHTMLDIALOGFN  *pfnShowHTMLDialog;
      
        pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(hinstMSHTML, "ShowHTMLDialog");

        if(pfnShowHTMLDialog)
        {
            IMoniker *pmk;
            TCHAR    szTemp[MAX_PATH*2];
            BSTR     bstr;

            lstrcpy(szTemp, TEXT("res://"));
            GetModuleFileName(_Module.GetModuleInstance(), szTemp + lstrlen(szTemp), ARRAYSIZE(szTemp) - lstrlen(szTemp));
            lstrcat(szTemp, TEXT("/CREDITS_RESOURCE"));

            bstr = A2BSTR((LPTSTR) szTemp);

            CreateURLMoniker(NULL, bstr, &pmk);

            if(pmk)
            {
                HRESULT  hr;
                VARIANT  varReturn;
         
                VariantInit(&varReturn);

                hr = (*pfnShowHTMLDialog)(NULL, pmk, NULL, NULL, &varReturn);

                pmk->Release();
            }
            SysFreeString(bstr);
        }
        FreeLibrary(hinstMSHTML);
    }
#endif
}



        
STDMETHODIMP CRefDial::SelectedPhoneNumber(long newVal, BOOL * pbRetVal)
{
    BOOL bSuccess = FALSE;
    
    *pbRetVal = TRUE;
    
    SetupConnectoid(m_pSuggestInfo, 
                    newVal, 
                    &m_szConnectoid[0],
                    sizeof(m_szConnectoid), 
                    &bSuccess);
    if( !bSuccess )
    {
        m_bQuitWizard = TRUE;
        *pbRetVal = FALSE;
    }
    else
    {
        // Generate a Displayable number
        m_hrDisplayableNumber = GetDisplayableNumber();
    }
    return S_OK;
}
        
STDMETHODIMP CRefDial::PhoneNumberEnum_Reset()
{
    m_PhoneNumberEnumidx = 0;

    return S_OK;
}

#define MAX_PAN_NUMBER_LEN 64
STDMETHODIMP CRefDial::PhoneNumberEnum_Next(BSTR *pNumber)
{
    TCHAR            szTemp[MAX_PAN_NUMBER_LEN + 1];
    PACCESSENTRY    pAE;

    if (pNumber == NULL)
        return E_POINTER;

    if (m_PhoneNumberEnumidx > m_pSuggestInfo->wNumber - 1)        
        m_PhoneNumberEnumidx = m_pSuggestInfo->wNumber -1;
    
    pAE = m_pSuggestInfo->rgpAccessEntry[m_PhoneNumberEnumidx];
    wsprintf(szTemp,TEXT("%s (%s) %s"),pAE->szCity,pAE->szAreaCode,pAE->szAccessNumber);
    
    ++m_PhoneNumberEnumidx;
    
    *pNumber = A2BSTR(szTemp);
    return S_OK;
}

STDMETHODIMP CRefDial::get_PhoneNumberEnum_NumDevices(long * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    m_PhoneNumberEnumidx = 0;
    *pVal = m_pSuggestInfo->wNumber;
        
    return S_OK;
}

STDMETHODIMP CRefDial::get_bIsISDNDevice(BOOL *pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    // NOTE SetupForDialing needs to be called before this API, otherwise the return
    // value is really undefined

    // Set the return value based on the ISPImport object (that is the object which
    // imports the data from the .ISP file, and also selects the RAS device used
    // to connect
    
    *pVal = m_ISPImport.m_bIsISDNDevice;
    
    return (S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   get_RasGetConnectStatus
//
//  Synopsis:   Checks for existing Ras connection
//
//+---------------------------------------------------------------------------
STDMETHODIMP CRefDial::get_RasGetConnectStatus(BOOL *pVal)
{
    RNAAPI      *pcRNA;
    HRESULT     hr = E_FAIL;
    *pVal = FALSE;

    if (NULL != m_hrasconn)
    {
        RASCONNSTATUS rasConnectState;
        rasConnectState.dwSize = sizeof(RASCONNSTATUS);
        pcRNA = new RNAAPI;
        if (pcRNA)
        {
            if (0 == pcRNA->RasGetConnectStatus(m_hrasconn, 
                                       &rasConnectState))
            {
                if (RASCS_Disconnected != rasConnectState.rasconnstate)
                    *pVal = TRUE;
            }
            delete pcRNA;
            pcRNA = NULL;
            hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwhelp.rc
//
#define IDS_PROJNAME                    100
#define IDS_OUTOFMEMORY                 101
#define IDS_TITLE                       102
#define IDS_TMPVAR                      103
#define IDS_TEMPVAR                     104
#define IDS_CANTREADMSDUNFILE           105
#define IDS_CANTREADTHISFILE            106
#define IDS_NODIALOUT                   107
#define IDS_NOPHONEENTRY                108
#define IDS_CANTREADMSNSUISP            109
#define IDS_CANTSAVEKEY                 110
#define IDS_CANTREADKEY                 111
#define IDS_WANTTOEXIT                  112
#define IDS_AREACODEREQUIRED            113
#define IDS_EXCHCODEREQUIRED            114
#define IDS_CANTINITPHONEBOOK           115
#define IDS_CONNECTED_TO                116
#define IDS_REDIAL                      117
#define IDS_REESTABLISH                 118
#define IDS_CANTLOADINETCFG             119
#define IDS_MSNSU_WRONG                 120
#define IDS_CORRUPTPHONEBOOK            121
#define IDS_INVALIDPN                   122
#define IDS_RAS_DIALING                 124
#define IDS_RAS_PORTOPENED              125
#define IDS_RAS_OPENPORT                126
#define IDS_RAS_CONNECTED               127
#define IDS_RAS_LOCATING                128
#define IDS_RAS_HANGINGUP               129
#define IDS_RAS_CONNECTING              130
#define IDS_RECEIVING_RESPONSE          131
#define IDS_CANTLOADCONFIGAPI           132
#define IDS_EXITFAILED                  133
#define IDS_CONFIGAPIFAILED             134
#define IDS_CONFIGAPIFAILEDRETRY        135
#define IDS_CONFIGURENTFAILED           136
#define IDS_CONFIGURENTFAILEDRETRY      137
#define IDS_CANNOTPROCESSINS            139
#define IDS_MAILFAILED                  140
#define IDS_BADSETTINGS                 141
#define IDS_EXECFAILED                  142
#define IDS_PASSWORD                    143
#define IDS_SIGNUPCANCELLED             144
#define IDS_PPPRANDOMFAILURE            145
#define IDS_NOANSWER                    146
#define IDS_RASNOCARRIER                147
#define IDS_TCPINSTALLERROR             148
#define IDS_PHONEBUSY                   149
#define IDS_NODIALTONE                  150
#define IDS_NODEVICE                    151
#define IDS_USERCANCELEDDIAL            152
#define IDS_DOWNLOAD_NOT_FOUND          153
#define IDS_CANTDOWNLOAD                154
#define IDS_MEDIAINIERROR               155
#define IDS_SERVICEDISABLED             156
#define IDS_SUPPORTMSG                  157
#define IDS_INVALIDPHONE                158
#define IDS_SBCSONLY                    159
#define IDS_INSTALLFAILED               160
#define IDS_SBSCFGERROR                 161
#define IDS_PWCACHE_DISABLED1           164
#define IDS_PWCACHE_DISABLED2           165
#define IDS_RAS_REDIALING               166
#define IDS_CONNECTED                   167
#define IDS_TIMEOUT                     168
#define IDS_DOWNLOADING                 169
#define IDS_DOWNLOAD_COMPLETE           170

#define IDI_PHONE                       500
#define IDI_IE                          501
#define IDC_MODEM                       600
#define IDC_CMDOK                       601
#define IDC_CMDCANCEL                   602
#define IDR_REFDIAL                     1036
#define IDR_DIALERR                     1037
#define IDD_CHOOSEMODEMNAME             1038
#define IDR_SMARTSTART                  1039
#define IDR_ICWSYSTEMCONFIG             1040
#define IDR_TAPILOCATIONINFO            1041
#define IDR_USERINFO                    1042
#define IDR_WEBGATE                     1043
#define IDR_INSHANDLER                  1044
#define IDD_AUTODISCONNECT              1045
#define IDC_SECONDS                     1047
#define IDC_IDLE_TEXT                   1048
#define IDC_DISCONNECT_TEXT             1049
#define IDC_SEC_TEXT                    1050

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         603
#define _APS_NEXT_SYMED_VALUE           1047
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\smstart.cpp ===
// SmStart.cpp : Implementation of CSmartStart
#include "stdafx.h"
#include "icwhelp.h"
#include "SmStart.h"

/////////////////////////////////////////////////////////////////////////////
// CSmartStart


HRESULT CSmartStart::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//    Function:    DoSmartStart
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    Sets m_bIsInternetCapable.
//
//    History:    1/12/98
//
//-----------------------------------------------------------------------------
#define INETCFG_ISSMARTSTART "IsSmartStart"
STDMETHODIMP CSmartStart::IsInternetCapable(BOOL *pbRetVal)
{
    TraceMsg(TF_SMARTSTART, TEXT("ICWHELP: DoSmartStart\n"));

    // Set the initial state.  Assume we are NOT internet capable
    *pbRetVal = FALSE;
    PFNISSMARTSTART fp = NULL;

    // Load the InetCfg library
    HINSTANCE hInetCfg = LoadLibrary(TEXT("inetcfg.dll"));
    if (!hInetCfg)
    {
        // Failure just means we run the wizard
        goto DoSmartStartExit;
    }


    // Load and call the smart start API
    if (NULL == (fp = (PFNISSMARTSTART)
        GetProcAddress(hInetCfg,INETCFG_ISSMARTSTART)))
    {
        goto DoSmartStartExit;
    }

    //
    // Call smart start
    //
    *pbRetVal = (BOOL)fp();
    
DoSmartStartExit:
    if (hInetCfg)
        FreeLibrary(hInetCfg);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_)
#define AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

// Global Variables
extern BOOL g_fRasIsReady;
extern BOOL g_bProxy;

#define IF_NTONLY if(VER_PLATFORM_WIN32_NT == g_dwPlatform) {
#define ENDIF_NTONLY }
extern DWORD g_dwPlatform;
extern DWORD g_dwBuild;

extern LPTSTR    g_pszAppDir;

// Includes
#include <atlcom.h>
#include <atlctl.h>

#include <ccstock.h>

#include <commctrl.h>
#include <ras.h>
#include <raserror.h>
#include <tapi.h>

#include "icwunicd.h" // UNICODE specific information.

#include "resource.h"

// Common global include for ICWHELP
#include "icwglob.h"
#include "import.h"
#include "icwhelp.h"
#include "cpicwhelp.h"      // Connection point proxys
#include "support.h"

#include "mcreg.h"          // abstract class for registry operations

#ifdef  UNICODE
#undef  A2BSTR
#define A2BSTR(lpa)    SysAllocString((OLECHAR FAR*)(lpa))
#endif

#ifdef  UNICODE
#undef  OLE2A
#define OLE2A(lpw)     ((LPTSTR)lpw)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1E7949FE_86F4_11D1_ADD8_0000F87734F0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

MAJORCOMP       = ie4
MINORCOMP       = getconn
TARGET_BOTH     = 1
!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwhelp

PASS0_HEADERDIR   = $(O)
PASS0_SOURCEDIR   = $(O)
MIDL_TLBDIR       = $(O)
MIDL_UUIDDIR      = $(O)

TARGETNAME      = icwhelp
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
TARGETLIBS      = $(LIBRARY_PATH)\gdi32.lib             \
                  $(LIBRARY_PATH)\kernel32.lib          \
                  $(LIBRARY_PATH)\user32.lib            \
                  $(LIBRARY_PATH)\advapi32.lib          \
                  $(LIBRARY_PATH)\shell32.lib           \
                  $(LIBRARY_PATH)\uuid.lib              \
                  $(LIBRARY_PATH)\ole32.lib             \
                  $(LIBRARY_PATH)\oleaut32.lib          \
                  $(LIBRARY_PATH)\wininet.lib           \
                  $(LIBRARY_PATH)\mpr.lib               \
                  $(SDK_LIB_PATH)\rasapi32.lib          \
                  $(SDK_LIB_PATH)\tapi32.lib            \
                  $(SDK_LIB_PATH)\version.lib           \
                  $(SDK_LIB_PATH)\urlmon.lib            \
!if defined(NOT_UNICODE)
                  $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib    \
!else
                  $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib    \
!endif

PRECOMPILED_CXX = 1
USE_STATIC_ATL  = 1
USE_MSVCRT      = 1

DLLDEF          = ..\icwhelp.def
DLLBASE         = 0x63A00000
DLLENTRY        = DllMain

SOURCES         =   ..\icwhelp.rc       \
                    ..\icwhelp.idl      \
                    ..\debug.cpp        \
                    ..\dialerr.cpp      \
                    ..\enumodem.cpp     \
                    ..\icwcfg.cpp       \
                    ..\icwhelp.cpp      \
                    ..\import.cpp       \
                    ..\misc.cpp         \
                    ..\progress.cpp     \
                    ..\refdial.cpp      \
                    ..\rnaapi.cpp       \
                    ..\smstart.cpp      \
                    ..\stdatl.cpp       \
                    ..\userinfo.cpp     \
                    ..\webgate.cpp      \
                    ..\tapiloc.cpp      \
                    ..\inshandler.cpp   \
                    ..\support.cpp      \
                    ..\icwerr.cpp       \
                    ..\mcreg.cpp

PRECOMPILED_INCLUDE = ..\stdafx.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\stdatl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\smstart.h ===
// SmStart.h : Declaration of the CSmartStart

#ifndef __SMARTSTART_H_
#define __SMARTSTART_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CSmartStart
class ATL_NO_VTABLE CSmartStart :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSmartStart,&CLSID_SmartStart>,
	public CComControl<CSmartStart>,
	public IDispatchImpl<ISmartStart, &IID_ISmartStart, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CSmartStart>,
	public IOleControlImpl<CSmartStart>,
	public IOleObjectImpl<CSmartStart>,
	public IOleInPlaceActiveObjectImpl<CSmartStart>,
	public IViewObjectExImpl<CSmartStart>,
	public IOleInPlaceObjectWindowlessImpl<CSmartStart>,
    public IObjectSafetyImpl<CSmartStart>
{
public:
    CSmartStart()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_SMARTSTART)

BEGIN_COM_MAP(CSmartStart) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISmartStart)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CSmartStart)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CSmartStart)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// ISmartStart
public:
	STDMETHOD(IsInternetCapable)(/*[out, retval]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);

};

#endif //__SMARTSTART_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\rnaapi.cpp ===
/*-----------------------------------------------------------------------------
    rnaapi.cpp

    Wrapper to softlink to RNAPH and RASAPI32.DLL

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        ChrisK        ChrisKauffman

    History:
        1/29/96        ChrisK    Created
        7/22/96        ChrisK    Cleaned and formatted
        1/7/98      DONALDM Moved to new ICW project and string
                    16 bit stuff
-----------------------------------------------------------------------------*/

#include "stdafx.h"

static const TCHAR cszRASAPI32_DLL[] = TEXT("RASAPI32.DLL");
static const TCHAR cszRNAPH_DLL[] = TEXT("RNAPH.DLL");

static const CHAR cszRasValidateEntryNamePlain[] = "RasValidateEntryName";

#ifdef UNICODE
static const CHAR cszRasEnumDevices[]        = "RasEnumDevicesW";
static const CHAR cszRasValidateEntryName[]  = "RasValidateEntryNameW";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesW";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesW";
static const CHAR cszRasDeleteEntry[]        = "RasDeleteEntryW";
static const CHAR cszRasHangUp[]             = "RasHangUpW";
static const CHAR cszRasGetConnectStatus[]   = "RasGetConnectStatusW";
static const CHAR cszRasDial[]               = "RasDialW";
static const CHAR cszRasEnumConnections[]    = "RasEnumConnectionsW";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsW";
static const CHAR cszRasGetCountryInfo[]     = "RasGetCountryInfoW";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsW";
#else
static const CHAR cszRasEnumDevices[]        = "RasEnumDevicesA";
static const CHAR cszRasValidateEntryName[]  = "RasValidateEntryNameA";
static const CHAR cszRasSetEntryProperties[] = "RasSetEntryPropertiesA";
static const CHAR cszRasGetEntryProperties[] = "RasGetEntryPropertiesA";
static const CHAR cszRasDeleteEntry[]        = "RasDeleteEntryA";
static const CHAR cszRasHangUp[]             = "RasHangUpA";
static const CHAR cszRasGetConnectStatus[]   = "RasGetConnectStatusA";
static const CHAR cszRasDial[]               = "RasDialA";
static const CHAR cszRasEnumConnections[]    = "RasEnumConnectionsA";
static const CHAR cszRasGetEntryDialParams[] = "RasGetEntryDialParamsA";
static const CHAR cszRasGetCountryInfo[]     = "RasGetCountryInfoA";
static const CHAR cszRasSetEntryDialParams[] = "RasSetEntryDialParamsA";
#endif

// on NT we have to call RasGetEntryProperties with a larger buffer than RASENTRY.
// This is a bug in WinNT4.0 RAS, that didn't get fixed.
//
#define RASENTRY_SIZE_PATCH (7 * sizeof(DWORD))

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RNAAPI
//
//    Synopsis:    Initialize class members and load DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::RNAAPI()
{
    m_hInst = LoadLibrary(cszRASAPI32_DLL);

    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
        m_hInst2 = LoadLibrary(cszRNAPH_DLL);
    }
    else
    {
        m_hInst2 =  NULL;
    }

    m_fnRasEnumDeviecs = NULL;
    m_fnRasValidateEntryName = NULL;
    m_fnRasSetEntryProperties = NULL;
    m_fnRasGetEntryProperties = NULL;
    m_fnRasDeleteEntry = NULL;
    m_fnRasHangUp = NULL;
    m_fnRasGetConnectStatus = NULL;
    m_fnRasEnumConnections = NULL;
    m_fnRasDial = NULL;
    m_fnRasGetEntryDialParams = NULL;
    m_fnRasGetCountryInfo = NULL;
    m_fnRasSetEntryDialParams = NULL;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::~RNAAPI
//
//    Synopsis:    release DLLs
//
//    Arguments:    None
//
//    Returns:    None
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
RNAAPI::~RNAAPI()
{
    //
    // Clean up
    //
    if (m_hInst) FreeLibrary(m_hInst);
    if (m_hInst2) FreeLibrary(m_hInst2);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasEnumDevices
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
                             LPDWORD lpcDevices)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumDevices,(FARPROC*)&m_fnRasEnumDeviecs);

    if (m_fnRasEnumDeviecs)
        dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::LoadApi
//
//    Synopsis:    If the given function pointer is NULL, then try to load the API
//                from the first DLL, if that fails, try to load from the second
//                DLL
//
//    Arguments:    pszFName - the name of the exported function
//                pfnProc - point to where the proc address will be returned
//
//    Returns:    TRUE - success
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
BOOL RNAAPI::LoadApi(LPCSTR pszFName, FARPROC* pfnProc)
{
    if (*pfnProc == NULL)
    {
        // Look for the entry point in the first DLL
        if (m_hInst)
            *pfnProc = GetProcAddress(m_hInst,pszFName);
        
        // if that fails, look for the entry point in the second DLL
        if (m_hInst2 && !(*pfnProc))
            *pfnProc = GetProcAddress(m_hInst2,pszFName);
    }

    return (pfnProc != NULL);
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetConnectStatus
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        7/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetConnectStatus(HRASCONN hrasconn,LPRASCONNSTATUS lprasconnstatus)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetConnectStatus,(FARPROC*)&m_fnRasGetConnectStatus);

    if (m_fnRasGetConnectStatus)
        dwRet = (*m_fnRasGetConnectStatus) (hrasconn,lprasconnstatus);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasValidateEntryName
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasValidateEntryNamePlain,(FARPROC*)&m_fnRasValidateEntryName);

    LoadApi(cszRasValidateEntryName,(FARPROC*)&m_fnRasValidateEntryName);

    if (m_fnRasValidateEntryName)
        dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasSetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo,  DWORD dwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;
    RASENTRY FAR *lpRE = NULL;


    // Look for the API if we haven't already found it
    LoadApi(cszRasSetEntryProperties,(FARPROC*)&m_fnRasSetEntryProperties);

    Assert(
        (NULL != lpbDeviceInfo) && (NULL != dwDeviceInfoSize)
        ||
        (NULL == lpbDeviceInfo) && (NULL == dwDeviceInfoSize)
        );

#define RASGETCOUNTRYINFO_BUFFER_SIZE 256
    if (0 == ((LPRASENTRY)lpbEntryInfo)->dwCountryCode)
    {
        BYTE rasCI[RASGETCOUNTRYINFO_BUFFER_SIZE];
        LPRASCTRYINFO prasCI;
        DWORD dwSize;
        DWORD dw;
        prasCI = (LPRASCTRYINFO)rasCI;
        ZeroMemory(prasCI,sizeof(rasCI));
        prasCI->dwSize = sizeof(RASCTRYINFO);
        dwSize = sizeof(rasCI);

        Assert(((LPRASENTRY)lpbEntryInfo)->dwCountryID);
        prasCI->dwCountryID = ((LPRASENTRY)lpbEntryInfo)->dwCountryID;

        dw = RNAAPI::RasGetCountryInfo(prasCI,&dwSize);
        if (ERROR_SUCCESS == dw)
        {
            Assert(prasCI->dwCountryCode);
            ((LPRASENTRY)lpbEntryInfo)->dwCountryCode = prasCI->dwCountryCode;
        } 
        else
        {
            AssertMsg(0,TEXT("Unexpected error from RasGetCountryInfo.\r\n"));
        }
    }

#ifdef UNICODE
    LPRASENTRY lpRasEntry;
    DWORD      dwSave;

    lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, dwEntryInfoSize + 512);
    dwSave = dwEntryInfoSize;
    if(lpRasEntry)
    {
        memcpy(lpRasEntry, lpbEntryInfo, dwEntryInfoSize);
        dwEntryInfoSize += 512;
    }
    else
        lpRasEntry = (LPRASENTRY)lpbEntryInfo;

    if (m_fnRasSetEntryProperties)
        dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
                                    (LPBYTE)lpRasEntry, dwEntryInfoSize,
                                    lpbDeviceInfo, dwDeviceInfoSize);

    if(lpRasEntry && lpRasEntry != (LPRASENTRY)lpbEntryInfo)
    {
        memcpy(lpbEntryInfo, lpRasEntry, dwSave);
        GlobalFree(lpRasEntry);
    }

#else
    if (m_fnRasSetEntryProperties)
        dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfo, dwEntryInfoSize,
                                    lpbDeviceInfo, dwDeviceInfoSize);
#endif
    lpRE = (RASENTRY FAR*)lpbEntryInfo;
    LclSetEntryScriptPatch(lpRE->szScript,lpszEntry);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetEntryProperties
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//                jmazner    9/17/96 Modified to allow calls with buffers = NULL and InfoSizes = 0.
//                                (Based on earlier modification to the same procedure in icwdial)
//                                See RasGetEntryProperties docs to learn why this is needed.
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                    LPBYTE lpbEntryInfo,  LPDWORD lpdwEntryInfoSize,
                                    LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;
    LPBYTE lpbEntryInfoPatch = NULL;
    LPDWORD  lpdwEntryInfoPatchSize = 0;

#if (WINVER != 0x400)
#error This was built with WINVER not equal to 0x400.  The size of RASENTRY may not be valid.
#endif

    if( (NULL == lpbEntryInfo) && (NULL == lpbDeviceInfo) )
    {
        Assert( NULL != lpdwEntryInfoSize );
        Assert( NULL != lpdwDeviceInfoSize );

        Assert( 0 == *lpdwEntryInfoSize );
        Assert( 0 == *lpdwDeviceInfoSize );

        // we're here to ask RAS what size these buffers need to be, don't use the patch stuff
        // (see RasGetEntryProperties docs)
        lpbEntryInfoPatch = lpbEntryInfo;
        lpdwEntryInfoPatchSize = lpdwEntryInfoSize;
    }
    else
    {

        Assert((*lpdwEntryInfoSize) >= sizeof(RASENTRY));
        Assert(lpbEntryInfo && lpdwEntryInfoSize);

        //
        // We are going to fake out RasGetEntryProperties by creating a slightly larger
        // temporary buffer and copying the data in and out.
        //
        lpdwEntryInfoPatchSize = (LPDWORD) GlobalAlloc(GPTR, sizeof(DWORD));
        if (NULL == lpdwEntryInfoPatchSize)
            return ERROR_NOT_ENOUGH_MEMORY;

        *lpdwEntryInfoPatchSize = (*lpdwEntryInfoSize) + RASENTRY_SIZE_PATCH;
        lpbEntryInfoPatch = (LPBYTE)GlobalAlloc(GPTR,*lpdwEntryInfoPatchSize);
        if (NULL == lpbEntryInfoPatch)
            return ERROR_NOT_ENOUGH_MEMORY;

        // RAS expects the dwSize field to contain the size of the LPRASENTRY struct
        // (used to check which version of the struct we're using) rather than the amount
        // of memory actually allocated to the pointer.
        //((LPRASENTRY)lpbEntryInfoPatch)->dwSize = dwEntryInfoPatch;
        ((LPRASENTRY)lpbEntryInfoPatch)->dwSize = sizeof(RASENTRY);
    }

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryProperties,(FARPROC*)&m_fnRasGetEntryProperties);

    if (m_fnRasGetEntryProperties)
        dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
                                    lpbEntryInfoPatch, lpdwEntryInfoPatchSize,
                                    lpbDeviceInfo, lpdwDeviceInfoSize);

    TraceMsg(TF_RNAAPI, TEXT("ICWHELP: RasGetEntryProperties returned %lu\r\n"), dwRet); 


    if( NULL != lpbEntryInfo )
    {
        //
        // Copy out the contents of the temporary buffer UP TO the size of the original buffer
        //
        Assert(lpbEntryInfoPatch);
        memcpy(lpbEntryInfo,lpbEntryInfoPatch,*lpdwEntryInfoSize);
        GlobalFree(lpbEntryInfoPatch);
        lpbEntryInfoPatch = NULL;

        if( lpdwEntryInfoPatchSize )
        {
            GlobalFree( lpdwEntryInfoPatchSize );
            lpdwEntryInfoPatchSize = NULL;
        }
        //
        // We are again faking Ras functionality here by over writing the size value;
        // This is neccesary due to a bug in the NT implementation of RasSetEntryProperties
        *lpdwEntryInfoSize = sizeof(RASENTRY);
    }

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasDeleteEntry
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDeleteEntry,(FARPROC*)&m_fnRasDeleteEntry);

    if (m_fnRasDeleteEntry)
        dwRet = (*m_fnRasDeleteEntry) (lpszPhonebook, lpszEntry);
    
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasHangUp
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        1/15/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasHangUp(HRASCONN hrasconn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasHangUp,(FARPROC*)&m_fnRasHangUp);

    if (m_fnRasHangUp)
    {
        dwRet = (*m_fnRasHangUp) (hrasconn);
        Sleep(3000);
    }

    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
                      LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType,
                      LPVOID lpvNotifier, LPHRASCONN lphRasConn)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasDial,(FARPROC*)&m_fnRasDial);

    if (m_fnRasDial)
    {
        dwRet = (*m_fnRasDial) (lpRasDialExtensions,lpszPhonebook,lpRasDialParams,
                                dwNotifierType,lpvNotifier,lphRasConn);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasEnumConnections,(FARPROC*)&m_fnRasEnumConnections);

    if (m_fnRasEnumConnections)
    {
        dwRet = (*m_fnRasEnumConnections) (lprasconn,lpcb,lpcConnections);
    }
    return dwRet;
}

// ############################################################################
DWORD RNAAPI::RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                                    LPBOOL lpfPassword)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetEntryDialParams,(FARPROC*)&m_fnRasGetEntryDialParams);

    if (m_fnRasGetEntryDialParams)
    {
        dwRet = (*m_fnRasGetEntryDialParams) (lpszPhonebook,lprasdialparams,lpfPassword);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasGetCountryInfo
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        8/16/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasGetCountryInfo(LPRASCTRYINFO lprci, LPDWORD lpdwSize)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasGetCountryInfo,(FARPROC*)&m_fnRasGetCountryInfo);

    if (m_fnRasGetCountryInfo)
    {
        dwRet = (*m_fnRasGetCountryInfo) (lprci,lpdwSize);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    RNAAPI::RasSetEntryDialParams
//
//    Synopsis:    Softlink to RAS function
//
//    Arguments:    see RAS documentation
//
//    Returns:    see RAS documentation
//
//    History:    ChrisK    Created        8/20/96
//
//-----------------------------------------------------------------------------
DWORD RNAAPI::RasSetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                            BOOL fRemovePassword)
{
    DWORD dwRet = ERROR_DLL_NOT_FOUND;

    // Look for the API if we haven't already found it
    LoadApi(cszRasSetEntryDialParams,(FARPROC*)&m_fnRasSetEntryDialParams);

    if (m_fnRasSetEntryDialParams)
    {
        dwRet = (*m_fnRasSetEntryDialParams) (lpszPhonebook,lprasdialparams,
                            fRemovePassword);
    }
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function    LclSetEntryScriptPatch
//
//    Synopsis    Softlink to RasSetEntryPropertiesScriptPatch
//
//    Arguments    see RasSetEntryPropertiesScriptPatch
//
//    Returns        see RasSetEntryPropertiesScriptPatch
//
//    Histroy        10/3/96    ChrisK Created
//
//-----------------------------------------------------------------------------
typedef BOOL (WINAPI* LCLSETENTRYSCRIPTPATCH)(LPTSTR, LPTSTR);
BOOL LclSetEntryScriptPatch(LPTSTR lpszScript,LPTSTR lpszEntry)
{
    HINSTANCE hinst = NULL;
    LCLSETENTRYSCRIPTPATCH fp = NULL;
    BOOL bRC = FALSE;

    hinst = LoadLibrary(TEXT("ICWDIAL.DLL"));
    if (hinst)
    {
        fp = (LCLSETENTRYSCRIPTPATCH)GetProcAddress(hinst,"RasSetEntryPropertiesScriptPatch");
        if (fp)
            bRC = (fp)(lpszScript,lpszEntry);
        FreeLibrary(hinst);
        hinst = NULL;
        fp = NULL;
    }
    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\support.cpp ===
//#--------------------------------------------------------------
//        
//  File:       support.cpp
//        
//  Synopsis:   holds the  member functions for the support
//              class
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "stdafx.h"

//++--------------------------------------------------------------
//
//  Function:   GetSupportInfo
//
//  Synopsis:   This is the public member function used to get the 
//              support numbers
//
//  Returns:    BOOL - success/failure
//
//  Arguments:  PCHAR - returns the number
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
BOOL
CSupport :: GetSupportInfo 
(
    LPTSTR  pszNumber,
    DWORD   dwCountryID
)
{
    HINSTANCE hPHBKDll = NULL;
    DWORD   dwBufferSize = 0;
    BOOL    bRetVal = FALSE;
    PFNGETSUPPORTNUMBERS pfnSupport = NULL;
    HRESULT hr = ERROR_SUCCESS;
    DWORD   dwTotalNums = 0;
    DWORD   dwIndex = 0;

    
    TraceMsg (TF_GENERAL, TEXT("Entering CSupport :: GetSupportInfo\r\n"));
    
    if (NULL == pszNumber)
    {
        TraceMsg (TF_GENERAL, TEXT("NULL = pszNumber\r\n"));
        goto Cleanup;
    }
    

    
    if (NULL == m_pSupportNumList)
    {
        //
        // being called the first time so load the info
        //
        hPHBKDll = LoadLibrary(PHBK_LIB);
        if (NULL == hPHBKDll)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on LoadLibrary API call with error:%d\r\n"),
                GetLastError () );
            goto Cleanup;
        }

        pfnSupport = (PFNGETSUPPORTNUMBERS) 
                        GetProcAddress(hPHBKDll,PHBK_SUPPORTNUMAPI);
        if (NULL == pfnSupport)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GetProcAddress API call with error:%d\r\n"),
                GetLastError () );
            goto Cleanup;
        }
        
        //
        //  call the first time to get the size needed
        //
        hr = pfnSupport ((PSUPPORTNUM)NULL, (PDWORD)&dwBufferSize);
        if (ERROR_SUCCESS != hr)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GetSupportNumbers API call with error:%d\r\n"),
                hr);
           goto Cleanup; 
        }
    
        //
        // allocate the required memory
        //
        m_pSupportNumList = (PSUPPORTNUM) GlobalAlloc (  
                                            GPTR,
                                            dwBufferSize
                                            );
        if (NULL == m_pSupportNumList)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GlobalAlloc API call with error:%d\r\n"),
                GetLastError ());
            goto Cleanup;                
        }


        //
        //  call second time for the info
        //
        hr = pfnSupport ((PSUPPORTNUM)m_pSupportNumList, (PDWORD)&dwBufferSize);
        if (ERROR_SUCCESS != hr)
        {
            TraceMsg (TF_GENERAL, TEXT("Failed on GetSupportNumbers API call with error:%d\r\n"),
                hr);
            goto Cleanup;
        }

    //
    // find out how many SUPPORTNUM structs we have in the
    // array
    m_dwTotalNums = dwBufferSize / sizeof (SUPPORTNUM);

    }
        
    
    //
    // get the current country code
    //
    for  (dwIndex = 0; dwIndex < m_dwTotalNums; dwIndex++)
    {
        //
        // this struct says countrycode but is actually countryID
        //
        if (m_pSupportNumList[dwIndex].dwCountryCode == dwCountryID)
        {
            //
            //   found a support phone number
            //
            CopyMemory (
                pszNumber, 
                m_pSupportNumList[dwIndex].szPhoneNumber,  
                sizeof (m_pSupportNumList[dwIndex].szPhoneNumber)
                );
            bRetVal = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    if (NULL != hPHBKDll)
         FreeLibrary (hPHBKDll); 

    TraceMsg (TF_GENERAL, TEXT("returning from CSupport :: GetSupportInfo function\r\n"));

    return (bRetVal);

}   //  end of CSupport :: GetSupportInfo function
                
//++--------------------------------------------------------------
//
//  Function:    ~CSupport
//
//  Synopsis:   This is the destructor of the CSupport class
//
//
//  Arguments:  VOID
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
CSupport :: ~CSupport (
        VOID
        )
{
    if (NULL != m_pSupportNumList)
        GlobalFree (m_pSupportNumList);

}   // end of ~CSupport function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\support.h ===
//#--------------------------------------------------------------
//        
//  File:       support.h
//        
//  Synopsis:   holds the  Class declaration for the CSupport
//              class
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#include "..\icwphbk\icwsupport.h"

const TCHAR PHBK_LIB[] = TEXT("icwphbk.dll");
const CHAR PHBK_SUPPORTNUMAPI[] = "GetSupportNumbers";

typedef HRESULT (WINAPI *PFNGETSUPPORTNUMBERS) (PSUPPORTNUM, PDWORD);

class CSupport
{
private:
    PSUPPORTNUM     m_pSupportNumList;
    DWORD           m_dwTotalNums;

    //
    // this function gets the countryID
    //
    BOOL GetCountryID (PDWORD pdwCountryID); 

public:
    CSupport (VOID)
    {
        m_pSupportNumList = NULL;
        m_dwTotalNums = 0;
    }

    ~CSupport (VOID);

    BOOL GetSupportInfo (LPTSTR, DWORD);

};  // end of CSupport class declaration
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\userinfo.h ===
// UserInfo.h : Declaration of the CUserInfo

#ifndef __USERINFO_H_
#define __USERINFO_H_

#include "resource.h"       // main symbols

#define REGSTR_PATH_USERINFO    TEXT("Software\\Microsoft\\User Information")

extern LPCTSTR lpcsz_FirstName;
extern LPCTSTR lpcsz_LastName;
extern LPCTSTR lpcsz_Company;
extern LPCTSTR lpcsz_Address1;
extern LPCTSTR lpcsz_Address2;
extern LPCTSTR lpcsz_City;
extern LPCTSTR lpcsz_State;
extern LPCTSTR lpcsz_ZIPCode;
extern LPCTSTR lpcsz_PhoneNumber;

#define NUM_USERINFO_ELEMENTS   9
typedef struct  userInfoQuery_tag
{
    LPCTSTR   lpcszRegVal;
    BSTR     *pbstrVal;
} USERINFOQUERY;


/////////////////////////////////////////////////////////////////////////////
// CUserInfo
class ATL_NO_VTABLE CUserInfo :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUserInfo,&CLSID_UserInfo>,
	public CComControl<CUserInfo>,
	public IDispatchImpl<IUserInfo, &IID_IUserInfo, &LIBID_ICWHELPLib>,
	public IPersistStreamInitImpl<CUserInfo>,
	public IOleControlImpl<CUserInfo>,
	public IOleObjectImpl<CUserInfo>,
	public IOleInPlaceActiveObjectImpl<CUserInfo>,
	public IViewObjectExImpl<CUserInfo>,
	public IOleInPlaceObjectWindowlessImpl<CUserInfo>,
    public IObjectSafetyImpl<CUserInfo>
{
public:
	CUserInfo()
	{
        m_aUserInfoQuery[0].lpcszRegVal =  lpcsz_FirstName;
        m_aUserInfoQuery[0].pbstrVal    = &m_bstrFirstName;
        m_aUserInfoQuery[1].lpcszRegVal =  lpcsz_LastName;
        m_aUserInfoQuery[1].pbstrVal    = &m_bstrLastName;
        m_aUserInfoQuery[2].lpcszRegVal =  lpcsz_Address1;
        m_aUserInfoQuery[2].pbstrVal    = &m_bstrAddress1;
        m_aUserInfoQuery[3].lpcszRegVal =  lpcsz_Address2;
        m_aUserInfoQuery[3].pbstrVal    = &m_bstrAddress2;
        m_aUserInfoQuery[4].lpcszRegVal =  lpcsz_City;
        m_aUserInfoQuery[4].pbstrVal    = &m_bstrCity;
        m_aUserInfoQuery[5].lpcszRegVal =  lpcsz_State;
        m_aUserInfoQuery[5].pbstrVal    = &m_bstrState;
        m_aUserInfoQuery[6].lpcszRegVal =  lpcsz_ZIPCode;
        m_aUserInfoQuery[6].pbstrVal    = &m_bstrZIPCode;
        m_aUserInfoQuery[7].lpcszRegVal =  lpcsz_PhoneNumber; 
        m_aUserInfoQuery[7].pbstrVal    = &m_bstrPhoneNumber;
        m_aUserInfoQuery[8].lpcszRegVal =  lpcsz_Company; 
        m_aUserInfoQuery[8].pbstrVal    = &m_bstrCompany;
	
	}

DECLARE_REGISTRY_RESOURCEID(IDR_USERINFO)

BEGIN_COM_MAP(CUserInfo) 
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IUserInfo)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CUserInfo)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CUserInfo)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = 0;
		return S_OK;
	}

// IUserInfo
public:
	STDMETHOD(PersistRegisteredUserInfo)(/*[out, retval]*/ BOOL *pbRetVal);
	STDMETHOD(get_Lcid)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_PhoneNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_PhoneNumber)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ZIPCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ZIPCode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_State)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_State)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_City)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_City)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Address2)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Address2)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Address1)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Address1)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_LastName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_LastName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FirstName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FirstName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Company)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Company)(/*[in]*/ BSTR newVal);
    STDMETHOD(CollectRegisteredUserInfo)(/*[out, retval]*/ BOOL *pbRetVal);
	HRESULT OnDraw(ATL_DRAWINFO& di);

private:
    CComBSTR    m_bstrFirstName;
    CComBSTR    m_bstrLastName;
    CComBSTR    m_bstrCompany;
    CComBSTR    m_bstrAddress1;
    CComBSTR    m_bstrAddress2;
    CComBSTR    m_bstrCity;
    CComBSTR    m_bstrState;
    CComBSTR    m_bstrZIPCode;
    CComBSTR    m_bstrPhoneNumber;
	long        m_lLcid;

    USERINFOQUERY   m_aUserInfoQuery[NUM_USERINFO_ELEMENTS];


};

#endif //__USERINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\tapiloc.h ===
// tapiloc.h : Declaration of the CTapiLocationInfo

#ifndef __TAPILOCATIONINFO_H_
#define __TAPILOCATIONINFO_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CTapiLocationInfo
class ATL_NO_VTABLE CTapiLocationInfo :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTapiLocationInfo,&CLSID_TapiLocationInfo>,
    public CComControl<CTapiLocationInfo>,
    public IDispatchImpl<ITapiLocationInfo, &IID_ITapiLocationInfo, &LIBID_ICWHELPLib>,
    public IPersistStreamInitImpl<CTapiLocationInfo>,
    public IOleControlImpl<CTapiLocationInfo>,
    public IOleObjectImpl<CTapiLocationInfo>,
    public IOleInPlaceActiveObjectImpl<CTapiLocationInfo>,
    public IViewObjectExImpl<CTapiLocationInfo>,
    public IOleInPlaceObjectWindowlessImpl<CTapiLocationInfo>,
    public IObjectSafetyImpl<CTapiLocationInfo>
{
public:
    CTapiLocationInfo()
    {
        m_wNumTapiLocations = 0;
        m_dwCountry = 0;
        m_dwCurrLoc = 0;
        m_hLineApp = NULL;
        m_pLineCountryList = NULL;
        m_rgNameLookUp = NULL;
        m_pTC = NULL;
    }

    ~CTapiLocationInfo()
    {
        if (m_pLineCountryList)
        {
            GlobalFree(m_pLineCountryList);
        }
        if (m_rgNameLookUp)
        {
            GlobalFree(m_rgNameLookUp);
        }
        if (m_pTC)
        {
            GlobalFree(m_pTC);
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_TAPILOCATIONINFO)

BEGIN_COM_MAP(CTapiLocationInfo) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITapiLocationInfo)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CTapiLocationInfo)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_MSG_MAP(CTapiLocationInfo)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }

// ITapiLocationInfo
public:
    STDMETHOD(GetTapiLocationInfo)(/*[out, retval]*/ BOOL *pbRetVal);

    STDMETHOD(get_lCountryCode)(/*[out, retval]*/ long *plVal);
    STDMETHOD(get_NumCountries)(/*[out, retval]*/ long *pNumOfCountry);
    STDMETHOD(get_CountryName)(/*[in]*/ long lCountryIndex, /*[out, retval]*/ BSTR * pszCountryName, /*[out, retval]*/ long * pCountryCode);
    STDMETHOD(get_DefaultCountry)(/*[out, retval]*/ BSTR * pszCountryName);
    STDMETHOD(get_bstrAreaCode)(/*[out, retval]*/ BSTR *pbstrAreaCode);
    STDMETHOD(put_bstrAreaCode)(/*[in]*/ BSTR bstrAreaCode);
    STDMETHOD(get_wNumberOfLocations)(/*[out]*/ short *psVal, /*[out, retval]*/ long *pCurrLoc);
    STDMETHOD(get_LocationName)(/*[in]*/ long lLocationIndex, /*[out, retval]*/ BSTR *pszLocationName);
    STDMETHOD(get_LocationInfo)(/*[in]*/ long lLocationIndex, /*[out, retval]*/ long *pLocationID, /*[out, retval]*/ BSTR * pszCountryName, /*[out, retval]*/ long *pCountryCode, /*[out, retval]*/ BSTR * pszAreaCode);
    STDMETHOD(put_LocationId)(/*[in]*/ long lLocationID);
    HRESULT OnDraw(ATL_DRAWINFO& di);

protected:
    HLINEAPP                    m_hLineApp;
    WORD                        m_wNumTapiLocations;
    DWORD                       m_dwCountry;
    DWORD                       m_dwCurrLoc;
    CComBSTR                    m_bstrAreaCode;
    CComBSTR                    m_bstrDefaultCountry;
    LPLINECOUNTRYLIST           m_pLineCountryList;
    LPCNTRYNAMELOOKUPELEMENT    m_rgNameLookUp;
    LPLINELOCATIONENTRY         m_plle;
    LPLINETRANSLATECAPS         m_pTC;
    TCHAR                       m_szCountryCode[8];
};

#endif //__TAPILOCATIONINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\userinfo.cpp ===
// UserInfo.cpp : Implementation of CUserInfo
#include "stdafx.h"
#include "icwhelp.h"
#include "UserInfo.h"
#include <regstr.h>
#include <winnls.h>

LPCTSTR lpcsz_FirstName   = TEXT("Default First Name");
LPCTSTR lpcsz_LastName    = TEXT("Default Last Name");
LPCTSTR lpcsz_Company     = TEXT("Default Company");
LPCTSTR lpcsz_Address1    = TEXT("Mailing Address");
LPCTSTR lpcsz_Address2    = TEXT("Additional Address");
LPCTSTR lpcsz_City        = TEXT("City");
LPCTSTR lpcsz_State       = TEXT("State");
LPCTSTR lpcsz_ZIPCode     = TEXT("ZIP Code");
LPCTSTR lpcsz_PhoneNumber = TEXT("Daytime Phone");

/////////////////////////////////////////////////////////////////////////////
// CUserInfo


HRESULT CUserInfo::OnDraw(ATL_DRAWINFO& di)
{
	return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Collect registered user information from the registry.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CUserInfo::CollectRegisteredUserInfo(BOOL * pbRetVal)
{
    USES_CONVERSION;            // We will be converting from ANSI to BSTR

    HKEY        hkey = NULL;
    TCHAR       szRegValue[REGSTR_MAX_VALUE_LENGTH];

    // Initialize the function return value.
    *pbRetVal = FALSE;
    
    //Try to get the info form the win98/NT5 location
    if (RegOpenKey(HKEY_LOCAL_MACHINE,REGSTR_PATH_USERINFO,&hkey) != ERROR_SUCCESS)
        //try to get it form the win95 spot
        RegOpenKey(HKEY_CURRENT_USER,REGSTR_PATH_USERINFO,&hkey);
    
    if(hkey != NULL)
	{
        DWORD   dwSize;
        DWORD   dwType = REG_SZ;
        for (int iX = 0; iX < NUM_USERINFO_ELEMENTS; iX ++)
        {
            // Set the size each time
            dwSize = sizeof(TCHAR)*REGSTR_MAX_VALUE_LENGTH; 
            if (RegQueryValueEx(hkey,
                                m_aUserInfoQuery[iX].lpcszRegVal,
                                NULL,
                                &dwType,
                                (LPBYTE)szRegValue,
                                &dwSize) == ERROR_SUCCESS)
            {
                *m_aUserInfoQuery[iX].pbstrVal = A2BSTR(szRegValue);
                *pbRetVal = TRUE;
            }
        }
        RegCloseKey(hkey);
    }

	LCID lcid;
	
	lcid = GetUserDefaultLCID();

	m_lLcid =	LOWORD(lcid); 

	return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Persist collected registered user information to the registry.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CUserInfo::PersistRegisteredUserInfo(BOOL * pbRetVal)
{
    USES_CONVERSION;            // We will be converting from ANSI to BSTR

    HKEY        hkey = NULL;

    // Initialize the function return value.
    *pbRetVal = TRUE;
    
    //Try to get the userinfo form the win98/NT5 location
    if (RegOpenKey(HKEY_LOCAL_MACHINE,REGSTR_PATH_USERINFO,&hkey) != ERROR_SUCCESS)
        
        //try to get it form the win95 spot
        if (RegOpenKey(HKEY_CURRENT_USER,REGSTR_PATH_USERINFO,&hkey) != ERROR_SUCCESS)
        {
            // Create the key
            RegCreateKey(HKEY_LOCAL_MACHINE,REGSTR_PATH_USERINFO,&hkey);
        }
    
    if(hkey != NULL)
	{
        LPTSTR  lpszRegVal;
        DWORD   cbData;
        // Loop for each of the values to be persisted
        for (int iX = 0; iX < NUM_USERINFO_ELEMENTS; iX ++)
        {
            if (NULL != *m_aUserInfoQuery[iX].pbstrVal)
            {
                // Convert the BSTR to an ANSI string.  the converted string will
                // be on the stack, so it will get freed when this function exits.
                lpszRegVal = OLE2A(*m_aUserInfoQuery[iX].pbstrVal);
                cbData = lstrlen(lpszRegVal);

                // Set the value
                if (RegSetValueEx(hkey, 
                              m_aUserInfoQuery[iX].lpcszRegVal,
                              0,
                              REG_SZ,
                              (LPBYTE) lpszRegVal,
                              sizeof(TCHAR)*(cbData+1)) != ERROR_SUCCESS)
                {
                    *pbRetVal = FALSE;
                }
            }                
        }
        RegCloseKey(hkey);
    }

	return S_OK;
}

STDMETHODIMP CUserInfo::get_FirstName(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

    *pVal = m_bstrFirstName.Copy();
    return S_OK;
}

STDMETHODIMP CUserInfo::put_FirstName(BSTR newVal)
{
    m_bstrFirstName = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_LastName(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrLastName.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_LastName(BSTR newVal)
{
    m_bstrLastName = newVal;
    return S_OK;
}

STDMETHODIMP CUserInfo::get_Company(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrCompany.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_Company(BSTR newVal)
{
    m_bstrCompany = newVal;
    return S_OK;
}

STDMETHODIMP CUserInfo::get_Address1(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrAddress1.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_Address1(BSTR newVal)
{
    m_bstrAddress1 = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_Address2(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrAddress2.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_Address2(BSTR newVal)
{
    m_bstrAddress2 = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_City(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrCity.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_City(BSTR newVal)
{
    m_bstrCity = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_State(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrState.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_State(BSTR newVal)
{
    m_bstrState = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_ZIPCode(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrZIPCode.Copy();
    return S_OK;
}

STDMETHODIMP CUserInfo::put_ZIPCode(BSTR newVal)
{
    m_bstrZIPCode = newVal;
	return S_OK;
}

STDMETHODIMP CUserInfo::get_PhoneNumber(BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;
    *pVal = m_bstrPhoneNumber.Copy();
	return S_OK;
}

STDMETHODIMP CUserInfo::put_PhoneNumber(BSTR newVal)
{
    m_bstrPhoneNumber = newVal;
	return S_OK;
}


STDMETHODIMP CUserInfo::get_Lcid(long * pVal) //BSTR * pVal)
{
    if (pVal == NULL)
        return E_POINTER;

	*pVal = m_lLcid;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\bmp.h ===
/****************************************************************************
 *
 * Bmp.H
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1993
 *  All rights reserved
 *
 *  Deals with painting bitmaps on the wizard pages
 *  FelixA 1994.
 ***************************************************************************/

// BMP functions
BOOL FAR PASCAL BMP_RegisterClass(HINSTANCE hInstance);
void FAR PASCAL BMP_DestroyClass(HINSTANCE hInstance);
void FAR PASCAL BMP_Paint(HWND hwnd);
LRESULT CALLBACK BMP_WndProc( HWND hWnd, UINT wMsg, WORD wParam, LONG lParam );

// Class name
#define SU_BMP_CLASS "ms_setup_bmp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\tapiloc.cpp ===
// tapiloc.cpp : Implementation of CTapiLocationInfo
#include "stdafx.h"
#include "icwhelp.h"
#include "tapiloc.h"

/////////////////////////////////////////////////////////////////////////////
// CTapiLocationInfo


HRESULT CTapiLocationInfo::OnDraw(ATL_DRAWINFO& di)
{
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_wNumberOfLocations(short * psVal, long *pCurrLoc)
{
    if ((psVal == NULL) || (pCurrLoc == NULL))
        return E_POINTER;
    *psVal = m_wNumTapiLocations;
    *pCurrLoc = m_pTC ? (long) m_dwCurrLoc : 0;
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_bstrAreaCode(BSTR * pbstrAreaCode)
{
    USES_CONVERSION;
    if (pbstrAreaCode == NULL)
         return E_POINTER;
    *pbstrAreaCode = m_bstrAreaCode.Copy();	
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::put_bstrAreaCode(BSTR bstrAreaCode)
{
    USES_CONVERSION;
    m_bstrAreaCode = bstrAreaCode;
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_lCountryCode(long * plVal)
{
    *plVal = m_dwCountry;
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_NumCountries(long *pNumOfCountry)
{
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    LPLINECOUNTRYENTRY pLCETemp;
    DWORD idx;
    DWORD dwCurLID = 0;
    //LPIDLOOKUPELEMENT m_rgIDLookUp;
    

    // Get TAPI country list
    if (m_pLineCountryList)
        GlobalFree(m_pLineCountryList);

    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
        return S_FALSE;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);
    
    idx = lineGetCountry(0,0x10003,m_pLineCountryList);
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        return S_FALSE;
    
    Assert(m_pLineCountryList->dwNeededSize);

    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                        (size_t)m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
        return S_FALSE;
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
    GlobalFree(m_pLineCountryList);
    
    m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

    if (lineGetCountry(0,0x10003,m_pLineCountryList))

        return S_FALSE;

    // look up array
    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList + 
        m_pLineCountryList->dwCountryListOffset);

    if(m_rgNameLookUp)
        GlobalFree(m_rgNameLookUp);

    m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

    if (!m_rgNameLookUp) return S_FALSE;

    DWORD  dwCID = atol((const char *)m_szCountryCode);

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgNameLookUp[idx].psCountryName = (LPTSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
        if (m_rgNameLookUp[idx].pLCE->dwCountryCode == dwCID)
        {
            if (m_rgNameLookUp[idx].psCountryName)
                m_bstrDefaultCountry = A2BSTR(m_rgNameLookUp[idx].psCountryName);
        }
  }

    *pNumOfCountry = m_pLineCountryList->dwNumCountries;

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_CountryName(long lCountryIndex, BSTR* pszCountryName, long* pCountryCode)
{
    *pszCountryName = A2BSTR(m_rgNameLookUp[lCountryIndex].psCountryName);

    if (m_rgNameLookUp[lCountryIndex].pLCE)
    {
        *pCountryCode = m_rgNameLookUp[lCountryIndex].pLCE->dwCountryCode;
    }

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_DefaultCountry(BSTR * pszCountryName)
{
    USES_CONVERSION;
    if (pszCountryName == NULL)
         return E_POINTER;
    *pszCountryName = m_bstrDefaultCountry.Copy();	
	return S_OK;
}

STDMETHODIMP CTapiLocationInfo::GetTapiLocationInfo(BOOL * pbRetVal)
{
    HRESULT             hr = ERROR_SUCCESS;
    TCHAR               szAreaCode[MAX_AREACODE+1];
    DWORD               cDevices=0;
    DWORD               dwCurDev = 0;
    DWORD               dwAPI = 0;
    LONG                lrc = 0;
    LINEEXTENSIONID     leid;
    LPVOID              pv = NULL;
    DWORD               dwCurLoc = 0;
    
    USES_CONVERSION;
    m_hLineApp=NULL;
    // Assume Failure
    *pbRetVal = FALSE;
    if (m_pTC)
    {
        m_dwCountry = 0; // Reset country ID, re-read TAPI info
        GlobalFree(m_pTC);
        m_pTC = NULL;
    }

    // Get area code from TAPI
    if (!m_bstrAreaCode)
    {
        hr = tapiGetLocationInfo(m_szCountryCode,szAreaCode);
        if (hr)
        {
            TraceMsg(TF_TAPIINFO, TEXT("ICWHELP:tapiGetLocationInfo failed.  RUN FOR YOUR LIVES!!\n"));
#ifdef UNICODE
        // There is no lineInitializeW verion in TAPI. So use A version lineInitialize.
            hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSzA(IDS_TITLE),&cDevices);
#else
            hr = lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSz(IDS_TITLE),&cDevices);
#endif
            if (hr == ERROR_SUCCESS)
            {
                lineTranslateDialog(m_hLineApp,0,0x10004,GetActiveWindow(),NULL);
                lineShutdown(m_hLineApp);
            }

            hr = tapiGetLocationInfo(m_szCountryCode,szAreaCode);
        }

        if (hr)
        {
            goto GetTapiInfoExit;
        }
        m_bstrAreaCode = A2BSTR(szAreaCode);
    }

    // Get the numeric Country code from TAPI for the current location
    if (m_dwCountry == 0)
    {
        // Get CountryID from TAPI
        m_hLineApp = NULL;

        // Get the handle to the line app
#ifdef UNICODE
        // There is no lineInitializeW verion in TAPI. So use A version lineInitialize.
        lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSzA(IDS_TITLE),&cDevices);
#else
        lineInitialize(&m_hLineApp,_Module.GetModuleInstance(),LineCallback,GetSz(IDS_TITLE),&cDevices);
#endif
        if (!m_hLineApp)
        {
            // if we can't figure it out because TAPI is messed up
            // just default to the US and bail out of here.
            // The user will still have the chance to pick the right answer.
            m_dwCountry = 1;
            goto GetTapiInfoExit;
        }
        if (cDevices)
        {

            // Get the TAPI API version
            //
            dwCurDev = 0;
            dwAPI = 0;
            lrc = -1;
            while (lrc && dwCurDev < cDevices)
            {
                // NOTE: device ID's are 0 based
                ZeroMemory(&leid,sizeof(leid));
                lrc = lineNegotiateAPIVersion(m_hLineApp,dwCurDev,0x00010004,0x00010004,&dwAPI,&leid);
                dwCurDev++;
            }
            if (lrc)
            {
                // TAPI and us can't agree on anything so nevermind...
                goto GetTapiInfoExit;
            }

            // Find the CountryID in the translate cap structure
            m_pTC = (LINETRANSLATECAPS *)GlobalAlloc(GPTR,sizeof(LINETRANSLATECAPS));
            if (!m_pTC)
            {
                // we are in real trouble here, get out!
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetTapiInfoExit;
            }

            // Get the needed size
            m_pTC->dwTotalSize = sizeof(LINETRANSLATECAPS);
            lrc = lineGetTranslateCaps(m_hLineApp,dwAPI,m_pTC);
            if(lrc)
            {
                goto GetTapiInfoExit;
            }

            pv = GlobalAlloc(GPTR, ((size_t)m_pTC->dwNeededSize));
            if (!pv)
            {
                hr = ERROR_NOT_ENOUGH_MEMORY;
                goto GetTapiInfoExit;
            }
            ((LINETRANSLATECAPS*)pv)->dwTotalSize = m_pTC->dwNeededSize;
            m_pTC = (LINETRANSLATECAPS*)pv;
            pv = NULL;
            lrc = lineGetTranslateCaps(m_hLineApp,dwAPI,m_pTC);
            if(lrc)
            {
                goto GetTapiInfoExit;
            }
        
            // sanity check
            Assert(m_pTC->dwLocationListOffset);

            // We have the Number of TAPI locations, so save it now
            m_wNumTapiLocations = (WORD)m_pTC->dwNumLocations;

            // Loop through the locations to find the correct country code
            m_plle = LPLINELOCATIONENTRY (LPSTR(m_pTC) + m_pTC->dwLocationListOffset);
            for (dwCurLoc = 0; dwCurLoc < m_pTC->dwNumLocations; dwCurLoc++)
            {
                if (m_pTC->dwCurrentLocationID == m_plle->dwPermanentLocationID)
                {
                    m_dwCountry = m_plle->dwCountryID;
                    m_dwCurrLoc = dwCurLoc;
                    break; // for loop
                }
                m_plle++;
            }

            // If we could not find it in the above loop, default to US
            if (!m_dwCountry)
            {
                m_dwCountry = 1;
                goto GetTapiInfoExit;
            }
        }
    }

    *pbRetVal = TRUE;           // Getting here means everything worked

GetTapiInfoExit:

    // Give the user an Error Message, and the wizard will bail.
    if (!*pbRetVal)
    {
        if( m_hLineApp )
        {
            lineShutdown(m_hLineApp);
            m_hLineApp = NULL;
        }
        MsgBox(IDS_CONFIGAPIFAILED,MB_MYERROR);
    }

    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_LocationName(long lLocationIndex, BSTR* pszLocationName)
{
    if (m_pTC == NULL)
        return E_POINTER;

    m_plle = LPLINELOCATIONENTRY (LPSTR(m_pTC) + m_pTC->dwLocationListOffset);
    m_plle += lLocationIndex;
    *pszLocationName = A2BSTR( ((LPSTR) m_pTC) + m_plle->dwLocationNameOffset );   
    return S_OK;
}

STDMETHODIMP CTapiLocationInfo::get_LocationInfo(long lLocationIndex, long *pLocationID, BSTR* pszCountryName, long *pCountryCode, BSTR* pszAreaCode)
{
    DWORD idx;
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    DWORD dwCurLID = 0;

    // Loop through the locations to find the correct country code
    m_plle = LPLINELOCATIONENTRY (LPSTR(m_pTC) + m_pTC->dwLocationListOffset);
    m_plle += lLocationIndex;

    // Assign country code and area code
    *pCountryCode = m_plle->dwCountryID;
    *pszAreaCode =  A2BSTR( ((LPSTR) m_pTC) + m_plle->dwCityCodeOffset );

    // Assign location ID
    *pLocationID = m_plle->dwPermanentLocationID;
   
    if (m_pLineCountryList)
    {
        GlobalFree(m_pLineCountryList);
        m_pLineCountryList = NULL;
    }

    // Get TAPI country name from country ID
    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
        return E_POINTER;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);
    
    idx = lineGetCountry(m_plle->dwCountryID,0x10003,m_pLineCountryList);
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        return E_POINTER;
    
    Assert(m_pLineCountryList->dwNeededSize);

    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                        (size_t)m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
        return E_POINTER;
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
    GlobalFree(m_pLineCountryList);
    
    m_pLineCountryList = pLineCountryTemp;

    if (lineGetCountry(m_plle->dwCountryID,0x10003,m_pLineCountryList))

        return E_POINTER;

    LPLINECOUNTRYENTRY pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList + m_pLineCountryList->dwCountryListOffset);

    LPTSTR psCountryName = (LPTSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[0].dwCountryNameOffset);
    *pszCountryName = A2BSTR(psCountryName);

    return S_OK;
}


STDMETHODIMP CTapiLocationInfo::put_LocationId(long lLocationID)
{
    ASSERT(m_hLineApp);
    // Must call GetTapiLocationInfo to get the Tapi handle first
    if (m_hLineApp)
    {
        lineSetCurrentLocation(m_hLineApp, lLocationID);
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\webgate.h ===
// webgate.h : Declaration of the CWebGate

#ifndef __WEBGATE_H_
#define __WEBGATE_H_

#include <windowsx.h>

// Start with a 16 KB read buffer
#define READ_BUFFER_SIZE    0x4000          

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CWebGate
class ATL_NO_VTABLE CWebGate :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWebGate,&CLSID_WebGate>,
    public CComControl<CWebGate>,
    public IDispatchImpl<IWebGate, &IID_IWebGate, &LIBID_ICWHELPLib>,
    public IProvideClassInfo2Impl<&CLSID_WebGate, &DIID__WebGateEvents, &LIBID_ICWHELPLib>,
    public IPersistStreamInitImpl<CWebGate>,
    public IOleControlImpl<CWebGate>,
    public IOleObjectImpl<CWebGate>,
    public IOleInPlaceActiveObjectImpl<CWebGate>,
    public IViewObjectExImpl<CWebGate>,
    public IOleInPlaceObjectWindowlessImpl<CWebGate>,
    public CProxy_WebGateEvents<CWebGate>,
    public IConnectionPointContainerImpl<CWebGate>,
    public IObjectSafetyImpl<CWebGate>
{
public:
    CWebGate()
    {
        m_pmk = 0;
        m_pbc = 0;
        m_pbsc = 0;
        m_cbBuffer = 0;
        m_bKeepFile = FALSE;
        
        // setup and allocate a data buffer
        m_cbdata = READ_BUFFER_SIZE;
        m_lpdata = (LPSTR) GlobalAllocPtr(GHND, m_cbdata);
        
        m_hEventComplete = 0;
        
    }
    
    ~CWebGate()
    {

        USES_CONVERSION;
                
        m_bstrFormData.Empty();
        m_bstrBuffer.Empty();
        m_bstrPath.Empty();
        m_bstrCacheFileName.Empty();

        if (m_bstrDumpFileName)
        {
#ifdef UNICODE
            DeleteFile(m_bstrDumpFileName);
#else
            DeleteFile(OLE2A(m_bstrDumpFileName));
#endif
            m_bstrDumpFileName.Empty();
        }

        // Release the binding context callback
        if (m_pbsc && m_pbc)
        {
            RevokeBindStatusCallback(m_pbc, m_pbsc);
            m_pbsc->Release();
            m_pbsc = 0;
        }        
    
        // Release the binding context
        if (m_pbc)
        {
            m_pbc->Release();
            m_pbc = 0;
        }        
    
        // release the monikor
        if (m_pmk)
        {
            m_pmk->Release();
            m_pmk = 0;
        }       
        
        // free the data buffer
        if (m_lpdata)
            GlobalFreePtr(m_lpdata);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_WEBGATE)

BEGIN_COM_MAP(CWebGate) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IWebGate)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CWebGate)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CWebGate)
    CONNECTION_POINT_ENTRY(DIID__WebGateEvents)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CWebGate)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()


// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = 0;
        return S_OK;
    }

// IWebGate
public:
    STDMETHOD(get_DownloadFname)(/*out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Buffer)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(FetchPage)(/*[in]*/ DWORD dwKeepFile, /*[in]*/ DWORD dwDoAsync, /*[out, retval]*/ BOOL *pbRetVal);
    STDMETHOD(DumpBufferToFile)(/*[out]*/ BSTR *pFileName, /*[out, retval]*/ BOOL *pbRetVal);
    
    STDMETHOD(put_FormData)(/*[in]*/ BSTR newVal);
    STDMETHOD(put_Path)(/*[in]*/ BSTR newVal);
    HRESULT OnDraw(ATL_DRAWINFO& di);

    // needs to be public, so the bindcallback can access it
    DWORD       m_cbBuffer;
    CComBSTR    m_bstrBuffer;
    CComBSTR    m_bstrCacheFileName;
    CComBSTR    m_bstrDumpFileName;
    BOOL        m_bKeepFile;
    LPSTR       m_lpdata;
    DWORD       m_cbdata;
    HANDLE      m_hEventComplete;
protected:
    CComBSTR m_bstrFormData;
    CComBSTR m_bstrPath;

 private:
   IMoniker*            m_pmk;
   IBindCtx*            m_pbc;
   IBindStatusCallback* m_pbsc;
    
};

#endif //__WEBGATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwhelp\webgate.cpp ===
// webgate.cpp : Implementation of CWebGate
#include "stdafx.h"
#include "icwhelp.h"
#include "webgate.h"
#include "appdefs.h"

#include <wininet.h>

#define MAX_DOWNLOAD_BLOCK 1024

extern BOOL MinimizeRNAWindowEx();

// ===========================================================================
//                     CWebGateBindStatusCallback Definition
//
// This class will be use to indicate download progress
//
// ===========================================================================

class CWebGateBindStatusCallback : public IBindStatusCallback
{
public:
    // IUnknown methods
    STDMETHODIMP            QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // constructors/destructors
    CWebGateBindStatusCallback(CWebGate * lpWebGate);
    ~CWebGateBindStatusCallback();

    // data members
    BOOL            m_bDoneNotification;
    DWORD           m_cRef;
    IBinding*       m_pbinding;
    IStream*        m_pstm;
    DWORD           m_cbOld;
    
    CWebGate        *m_lpWebGate;

private:    
   void ProcessBuffer(void);
    
};

UINT g_nICWFileCount = 0;


BOOL CALLBACK DisconnectDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID CALLBACK IdleTimerProc (HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime);

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
// ---------------------------------------------------------------------------
CWebGateBindStatusCallback::CWebGateBindStatusCallback
(
    CWebGate    *lpWebGate
)
{
    m_pbinding = NULL;
    m_pstm = NULL;
    m_cRef = 1;
    m_cbOld = 0;

    m_lpWebGate = lpWebGate;
}  // CWebGateBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::~CWebGateBindStatusCallback
// ---------------------------------------------------------------------------
CWebGateBindStatusCallback::~CWebGateBindStatusCallback()
{
}  // ~CWebGateBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::QueryInterface
(
    REFIID riid, 
    void** ppv
)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}  // CWebGateBindStatusCallback::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnStartBinding
(
    DWORD dwReserved, 
    IBinding* pbinding
)
{
    if (m_pbinding != NULL)
        m_pbinding->Release();
    m_pbinding = pbinding;
    if (m_pbinding != NULL)
    {
        m_pbinding->AddRef();
    }
    
    return S_OK;
}  // CWebGateBindStatusCallback::OnStartBinding

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::GetPriority
(
    LONG* pnPriority
)
{
    return E_NOTIMPL;
}  // CWebGateBindStatusCallback::GetPriority

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnLowResource
(
    DWORD dwReserved
)
{
    return E_NOTIMPL;
}  // CWebGateBindStatusCallback::OnLowResource

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnProgress
(
    ULONG ulProgress, 
    ULONG ulProgressMax, 
    ULONG ulStatusCode, 
    LPCWSTR szStatusText
)
{
    // If no progress, check for valid connection
    if (0 == ulProgress)
        m_lpWebGate->Fire_WebGateDownloadProgress(TRUE);
    return(NOERROR);
}  // CWebGateBindStatusCallback::OnProgress


void CWebGateBindStatusCallback::ProcessBuffer(void)
{
    m_bDoneNotification = TRUE;

    if (m_pstm)
        m_pstm->Release();

    m_lpWebGate->m_cbBuffer = m_cbOld;
    
    // Create a file, and copy the donwloaded content into it   
    if (m_lpWebGate->m_bKeepFile)        
    {       
        TCHAR   szTempFileFullName[MAX_PATH];
        TCHAR   szTempFileName[MAX_PATH];
        HANDLE  hFile; 
        DWORD   cbRet;
    
        // Make sure it is an htm extension, otherwise, IE will promp for download
        GetTempPath(MAX_PATH, szTempFileFullName);
        wsprintf( szTempFileName, TEXT("ICW%x.htm"), g_nICWFileCount++); 
        lstrcat(szTempFileFullName, szTempFileName);
    
        hFile = CreateFile(szTempFileFullName, 
                           GENERIC_WRITE, 
                           0, 
                           NULL, 
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL, 
                           NULL);
        if (hFile)                               
        {
            WriteFile(hFile, m_lpWebGate->m_lpdata, m_cbOld, (LPDWORD)&cbRet, NULL);
            CloseHandle(hFile);
        }
    
        // Copy the created file name into the webgate control
        m_lpWebGate->m_bstrCacheFileName = A2BSTR(szTempFileFullName);
    }

    // If the WebGate object has a complete event, then signal it, otherwise
    // fire an event
    if (m_lpWebGate->m_hEventComplete)
        SetEvent(m_lpWebGate->m_hEventComplete);
    else
    {
        // Notify the caller that we are done
        m_lpWebGate->Fire_WebGateDownloadComplete(TRUE);
    }        
}

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnStopBinding
(
    HRESULT hrStatus, 
    LPCWSTR pszError
)
{
    if (m_pbinding)
    {
        m_pbinding->Release();
        m_pbinding = NULL;
    }
       
    if (!m_bDoneNotification)
    {
        ProcessBuffer();
    
    }
    m_lpWebGate->Fire_WebGateDownloadProgress(TRUE);

    return S_OK;
}  // CWebGateBindStatusCallback::OnStopBinding

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::GetBindInfo
(
    DWORD* pgrfBINDF, 
    BINDINFO* pbindInfo
)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | 
                 BINDF_PULLDATA | BINDF_GETNEWESTVERSION | 
                 BINDF_NOWRITECACHE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CWebGateBindStatusCallback::GetBindInfo

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnDataAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnDataAvailable
(
    DWORD grfBSCF, 
    DWORD dwSize, 
    FORMATETC* pfmtetc, 
    STGMEDIUM* pstgmed
)
{
    HRESULT hr = E_FAIL; //don't assume success

    // verify we have a read buffer
    if (!m_lpWebGate->m_lpdata)
        return(S_FALSE);
        
    // Get the Stream passed
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {
        m_bDoneNotification = FALSE;
        
        if (!m_pstm && pstgmed->tymed == TYMED_ISTREAM)
        {
            m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
        }
    }

    // If there is some data to be read then go ahead and read them
    if (m_pstm && dwSize)
    {      
        DWORD dwActuallyRead = 0; // Placeholder for amount read during this pull

        do
        {  
           if (MAX_DOWNLOAD_BLOCK + m_cbOld > m_lpWebGate->m_cbdata)
           {
                m_lpWebGate->m_cbdata += READ_BUFFER_SIZE;
                // ::MessageBox(NULL, TEXT("reallov DumpBufferToFile"), TEXT("E R R O R"), MB_OK);
                LPSTR pBuffer = (LPSTR)GlobalReAllocPtr(m_lpWebGate->m_lpdata, m_lpWebGate->m_cbdata , GHND);
                if (pBuffer)
                    m_lpWebGate->m_lpdata  = pBuffer;
                else
                    return S_FALSE;
           }

            // Read what we can 
            hr = m_pstm->Read(m_lpWebGate->m_lpdata+m_cbOld, MAX_DOWNLOAD_BLOCK, &dwActuallyRead);
           
            // keep track of the running total
            m_cbOld += dwActuallyRead;          
           
        } while (hr == E_PENDING || hr != S_FALSE);
    }            

    if (BSCF_LASTDATANOTIFICATION & grfBSCF)
    {
        if (!m_bDoneNotification)
        {
            ProcessBuffer();
        }                    
    }

    return S_OK;
}  // CWebGateBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CWebGateBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP CWebGateBindStatusCallback::OnObjectAvailable
(
    REFIID riid, 
    IUnknown* punk
)
{
    return E_NOTIMPL;
}  // CWebGateBindStatusCallback::OnObjectAvailable

/////////////////////////////////////////////////////////////////////////////
// CWebGate


HRESULT CWebGate::OnDraw(ATL_DRAWINFO& di)
{
    return S_OK;
}

STDMETHODIMP CWebGate::put_Path(BSTR newVal)
{
    // TODO: Add your implementation code here
    USES_CONVERSION;
    m_bstrPath = newVal;
    return S_OK;
}

STDMETHODIMP CWebGate::put_FormData(BSTR newVal)
{
    // TODO: Add your implementation code here
    USES_CONVERSION;
    m_bstrFormData = newVal;
    return S_OK;
}


STDMETHODIMP CWebGate::FetchPage(DWORD dwKeepFile, DWORD dwDoWait, BOOL *pbRetVal)
{
    USES_CONVERSION;

    IStream *pstm = NULL;
    HRESULT hr;
    // Empty the buffer.
    m_bstrBuffer.Empty();
    
    // Clear the cache file name
    m_bstrCacheFileName.Empty();
    
    // Release the binding context callback
    if (m_pbsc && m_pbc)
    {
        RevokeBindStatusCallback(m_pbc, m_pbsc);
        m_pbsc->Release();
        m_pbsc = 0;
    }        
    
    // Release the binding context
    if (m_pbc)
    {
        m_pbc->Release();
        m_pbc = 0;
    }        
    
    // release the monikor
    if (m_pmk)
    {
        m_pmk->Release();
        m_pmk = 0;
    }        
    
    *pbRetVal = FALSE;

    if (dwDoWait)    
        m_hEventComplete = CreateEvent(NULL, TRUE, FALSE, NULL);
        
    m_bKeepFile = (BOOL) dwKeepFile;    
    hr = CreateURLMoniker(NULL, m_bstrPath, &m_pmk);
    if (FAILED(hr))
        goto LErrExit;

    m_pbsc = new CWebGateBindStatusCallback(this);
    if (m_pbsc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
    }

    hr = CreateBindCtx(0, &m_pbc);
    if (FAILED(hr))
        goto LErrExit;

    hr = RegisterBindStatusCallback(m_pbc,
            m_pbsc,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;

    hr = m_pmk->BindToStorage(m_pbc, 0, IID_IStream, (void**)&pstm);
    if (FAILED(hr))
        goto LErrExit;

    // If we were requested to wait, then we wait for the m_hEventComplete to be
    // signaled
    if (dwDoWait && m_hEventComplete)    
    {
        MSG     msg;
        BOOL    bGotFile = FALSE;
        DWORD   dwRetCode;
        HANDLE  hEventList[1];
        hEventList[0] = m_hEventComplete;
    
        while (TRUE)
        {
                // We will wait on window messages and also the named event.
            dwRetCode = MsgWaitForMultipleObjects(1, 
                                                  &hEventList[0], 
                                                  FALSE, 
                                                  300000,            // 5 minutes
                                                  QS_ALLINPUT);

            // Determine why we came out of MsgWaitForMultipleObjects().  If
            // we timed out then let's do some TrialWatcher work.  Otherwise
            // process the message that woke us up.
            if (WAIT_TIMEOUT == dwRetCode)
            {
                bGotFile = FALSE;
                break;
            }
            else if (WAIT_OBJECT_0 == dwRetCode)
            {
                bGotFile = TRUE;
                break;
            }
            else if (WAIT_OBJECT_0 + 1 == dwRetCode)
            {
                // 0 is returned if no message retrieved.
                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT == msg.message)
                    {
                        bGotFile = FALSE;
                        break;
                    }
                    else
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
        }
        *pbRetVal = bGotFile;
        CloseHandle(m_hEventComplete);
        m_hEventComplete = 0;
    }
    else
    {
        *pbRetVal = TRUE;
    }        
    return S_OK;

LErrExit:
    if (m_pbc != NULL)
    {
        m_pbc->Release();
        m_pbc = NULL;
    }
    if (m_pbsc != NULL)
    {
        m_pbsc->Release();
        m_pbsc = NULL;
    }
    if (m_pmk != NULL)
    {
        m_pmk->Release();
        m_pmk = NULL;
    }
    if (pstm)
    {
        pstm->Release();
        pstm = NULL;
    }
    
    *pbRetVal = FALSE;
    return S_OK;
    
}


STDMETHODIMP CWebGate::get_Buffer(BSTR * pVal)
{
    if (pVal == NULL)
         return E_POINTER;
    *pVal = m_bstrBuffer.Copy();

    return S_OK;
}

STDMETHODIMP CWebGate::DumpBufferToFile(BSTR *pFileName, BOOL *pbRetVal)
{
    USES_CONVERSION;
    
    TCHAR   szTempFileFullName[MAX_PATH];
    TCHAR   szTempFileName[MAX_PATH];
    DWORD   cbRet;
    HANDLE  hFile; 
    
    if (pFileName == NULL)
        return(E_POINTER);

    // Delete the previous temp file it it exists
    if (m_bstrDumpFileName)
    {
        DeleteFile(OLE2A(m_bstrDumpFileName));
        m_bstrDumpFileName.Empty();
    }
               
    // Make sure it is an htm extension, otherwise, IE will promp for download
    GetTempPath(MAX_PATH, szTempFileFullName);
    wsprintf( szTempFileName, TEXT("ICW%x.htm"), g_nICWFileCount++); 
    lstrcat(szTempFileFullName, szTempFileName);

    hFile = CreateFile(szTempFileFullName, 
                       GENERIC_WRITE, 
                       0, 
                       NULL, 
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, 
                       NULL);
    if (hFile)                               
    {
        WriteFile(hFile, m_lpdata, m_cbBuffer, (LPDWORD)&cbRet, NULL);
        CloseHandle(hFile);
    }

    // Copy the created file name into the webgate control
    m_bstrDumpFileName = A2BSTR(szTempFileFullName);
    *pFileName = m_bstrDumpFileName.Copy();
    
    *pbRetVal = TRUE;
    
    MinimizeRNAWindowEx();

    return S_OK;
}

STDMETHODIMP CWebGate::get_DownloadFname(BSTR *pVal)
{
    if (pVal == NULL)
        return(E_POINTER);
    
    *pVal = m_bstrCacheFileName.Copy();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\bmp.c ===
/****************************************************************************
 *
 * Bmp.C
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1993
 *  All rights reserved
 *
 *  Deals with painting bitmaps on the wizard pages
 *  FelixA 1994.
 ***************************************************************************/

#include <windows.h>
#include "bmp.h"

//***************************************************************************
//
// BMP_RegisterClass()
//      Registers the bitmap control class
//
// ENTRY:
//	hInstance
//
// EXIT:
//	NONE currently.
//
//***************************************************************************
BOOL FAR PASCAL BMP_RegisterClass(HINSTANCE hInstance)
{
    WNDCLASS wc;
    
    if (!GetClassInfo(hInstance, SU_BMP_CLASS, &wc)) {
	wc.lpszClassName = SU_BMP_CLASS;
	wc.style	 = 0;
	wc.lpfnWndProc	 = (WNDPROC)BMP_WndProc;
	wc.hInstance	 = hInstance;
	wc.hIcon	 = NULL;
	wc.hCursor	 = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = NULL;
	wc.lpszMenuName	 = NULL;
	wc.cbClsExtra	 = 0;
	wc.cbWndExtra	 = 5*sizeof(WORD);

	if (!RegisterClass(&wc))
	    return FALSE;
    }
    return TRUE;
}

//***************************************************************************
//
// BMP_DestroyClass()
//      Draws the bitmap control.
//
// ENTRY:
//	hInstance
//
// EXIT:
//	NONE currently.
//
//***************************************************************************
void FAR PASCAL BMP_DestroyClass( HINSTANCE hInst )
{
    WNDCLASS wndClass;
    
    if( GetClassInfo(hInst, SU_BMP_CLASS, &wndClass) )
        if( !FindWindow( SU_BMP_CLASS, NULL ) )
            UnregisterClass(SU_BMP_CLASS, hInst);
}

//***************************************************************************
//
// BMP_Draw()
//      Draws the bitmap control.
//
// ENTRY:
//	NONE
//
// EXIT:
//	NONE currently.
//
//***************************************************************************
void FAR PASCAL BMP_Paint(HWND hwnd)
{
    PAINTSTRUCT ps;
    HDC         hdc, hdcMem;
    int         idBmp;
    HBITMAP     hbm, hbmOld;
    HBRUSH      hbrOld;
    HINSTANCE   hInst;
    int         iDeleteBmp=TRUE;
    BITMAP      bm;
    
    // For independence.
    idBmp = GetDlgCtrlID( hwnd );
    hInst = (HINSTANCE)GetWindowWord( hwnd, GWW_HINSTANCE );

    // Paint.
    hdc = BeginPaint(hwnd,&ps);
    hbm = LoadBitmap(hInst, MAKEINTRESOURCE(idBmp));
    if (hbm)
    {
        GetObject(hbm, sizeof(bm), &bm);
        hdcMem = CreateCompatibleDC(hdc);
        hbmOld = SelectObject(hdcMem, hbm);

        // Draw the bitmap
        BitBlt(hdc, 0, 0, bm.bmWidth , bm.bmHeight, hdcMem, 0, 0, SRCCOPY);

        // Draw a frame around it.
        hbrOld = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
        Rectangle( hdc, 0, 0, bm.bmWidth, bm.bmHeight );

        SelectObject(hdc, hbrOld);
        SelectObject(hdcMem, hbmOld);
        DeleteObject(hbm);
        DeleteDC(hdcMem);
    }
    EndPaint(hwnd,(LPPAINTSTRUCT)&ps);
}

// ****************************************************************************
//
// BMP_WndProc()
//      This routine handles all the message for the bitmap control.
//
// ENTRY:
//  hWnd    - Progress window handle.
//  wMsg    - Message.
//  wParam  - Message wParam data.
//  lParam  - Message lParam data.
//
// EXIT:
//  Returns depends on message being processed.
//
// NOTES:
//  None.
//
// ***************************************************************************/
LRESULT CALLBACK BMP_WndProc( HWND hWnd, UINT wMsg, WORD wParam, LONG lParam )
{
    switch (wMsg)
    {
//        case WM_NCCREATE:
//            dw = GetWindowLong( hWnd,GWL_STYLE );
//            SetWindowLong( hWnd, GWL_STYLE, dw | WS_BORDER );
//            return TRUE;
        
	case WM_PAINT:
	    BMP_Paint( hWnd );
        return 0L;
    }
    return DefWindowProc( hWnd, wMsg, wParam, lParam );
}

#if 0
// Cached?

//***************************************************************************
//
// zzzBMP_CacheBitmaps()
//      Loads and caches the bitmaps for setup
//
// NOTES:
//      You must free the bitmaps using zzzBMP_FreeBitmaps
//
//***************************************************************************
typedef struct tag_Bitmap
{
    int         iBmp;
    HBITMAP     hBmp;
} BMPCACHE;

static BMPCACHE BmpCache[] = { {IDB_WIZARD_NET, 0},
                               {IDB_WIZARD_SETUP, 0},
                               {0,0} };
                               
VOID FAR PASCAL zzzBMP_CacheBitmaps( )
{
   int i=0;
   while( BmpCache[i].iBmp )
       BmpCache[i++].hBmp = LoadBitmap(hinstExe, MAKEINTRESOURCE(BmpCache[i].iBmp));
}

//***************************************************************************
//
// zzzBMP_FreeBitmapCache()
//      Frees the cache of the bitmaps
//
// NOTES:
//  Uses IDS_MB to actually format this string.
//
//***************************************************************************
VOID FAR PASCAL zzzBMP_FreeBitmapCache( )
{
   int i=0;
   while( BmpCache[i].iBmp )
   {
       if( BmpCache[i].hBmp && DeleteObject(BmpCache[i].hBmp) )
           BmpCache[i].hBmp = 0;
       i++;
   }
}

//***************************************************************************
//
// zzzBMP_LoadCachedBitmaps()
//      Returns the HBMP for the iBitmap you wanted.
//
// NOTES:
//  Uses IDS_MB to actually format this string.
//
//***************************************************************************
HBITMAP FAR PASCAL zzzBMP_LoadCachedBitmaps(int iBitmap)
{
   int i=0;
   while( BmpCache[i].iBmp )
   {
       if( BmpCache[i].iBmp == iBitmap )
           return BmpCache[i].hBmp;
       i++;
   }
   SU_TRAP
   return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\ccsv.cpp ===
// ############################################################################
// INCLUDES
#include "pch.hpp"
#include "ccsv.h"
#include "debug.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
    m_hFile = 0;
    m_iLastRead = 0;
    m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
    AssertMsg(!m_hFile,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCTSTR pszFileName)
{
    AssertMsg(!m_hFile, "a file is already open.");
        
    m_hFile = CreateFile((LPCTSTR)pszFileName, 
                            GENERIC_READ, FILE_SHARE_READ, 
                            0, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        return FALSE;
    }
    m_pchLast = m_pchBuf = NULL;
    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPTSTR psz, DWORD cbMax)
{
    LPTSTR    pszLast;
    int        ch;

    ch = ChNext();
    if (-1 == ch)
        {
        return FALSE;
        }

    pszLast = psz + (cbMax - 1);
    while (psz < pszLast && chComma != ch && chNewline != ch && -1 != ch)
        {
       *psz++ = (TCHAR)ch;
        ch = ChNext(); //Read in the next character
        }

    *psz++ = '\0';

    return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
    if (m_hFile)
        CloseHandle(m_hFile);
#ifdef DEBUG
    if (!m_hFile) TraceMsg(TF_GENERAL, "CCSVFile::Close was called, but m_hFile was already 0\n");
#endif
    m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
    //Read another buffer
#ifdef WIN16
    if ((m_cchAvail = _read(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE)) <= 0)
        return FALSE;
#else
    if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
        {
        return FALSE;     //nothing more to read
        }
#endif

    m_pchBuf = m_rgchBuf;
    m_pchLast = m_pchBuf + m_cchAvail;
    
    return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{

LNextChar:
    if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
        return -1;     //nothing more to read

    m_iLastRead = *m_pchBuf++;
    if (chReturn == m_iLastRead)
        goto LNextChar;        //faster to NOT make extra function call

    return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\icwsupport.cpp ===
//#--------------------------------------------------------------
//        
//  File:       icwsupport.cpp
//        
//  Synopsis:   holds the function which gets the list of
//              support phone numbers for ICW 
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#include "pch.hpp"  
#include <windows.h>
#ifdef WIN16
#include <win16def.h>
#include <win32fn.h>
#include <rasc.h>
#include <raserr.h>
#include <ietapi.h>
extern "C" {
#include "bmp.h"
}
#endif

#include "phbk.h"
#include "misc.h"
#include "phbkrc.h"
#include "suapi.h"
#include "icwsupport.h"



#include "ccsv.h"

const TCHAR SUPPORT_FILE[] = TEXT("support.icw");
const DWORD ALLOCATION_SIZE = 256;

//++--------------------------------------------------------------
//
//  Function:   GetSupportNumsFromFile
//
//  Synopsis:   This is the function used to get the support
//              numbers
//
//  Returns:    HRESULT - success or error info
//
//  Called By:  by the GetSupportNumbers API
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
HRESULT
GetSupportNumsFromFile (
    PSUPPORTNUM   pSupportNumList,
    PDWORD        pdwSize 
    )
{
    BOOL        bReturnMemNeeded = FALSE;
    LPTSTR      pszTemp = NULL;
    TCHAR       szFilePath[MAX_PATH];
    BOOL        bStatus = FALSE;
    CCSVFile    *pcCSVFile = NULL;
    DWORD       dwMemNeeded = 0;
    HRESULT     hRetVal = ERROR_SUCCESS;
    DWORD       dwCurrentIndex = 0;
    DWORD       dwIndexAllocated = 0;
    const DWORD INFOSIZE = sizeof (SUPPORTNUM);
    PSUPPORTNUM pPhbkArray = NULL;
    PSUPPORTNUM pTemp = NULL;

        TraceMsg(TF_GENERAL, "Entering GetSupportNumsFromFile function\r\n");


        //
        // atleast a place where the size can be returned
        //  should be provided
        //
        if (NULL == pdwSize)
        {

           TraceMsg (TF_GENERAL, "pdwSize == NULL\r\n");
           hRetVal = ERROR_INVALID_PARAMETER;
           goto Cleanup;
        }
 
        //
        //  check if the user has provided the buffers
        //
        if (NULL == pSupportNumList)
        {
            TraceMsg (TF_GENERAL, "User justs wants the buffer size\r\n");
            bReturnMemNeeded = TRUE;
        }

        //
        //  get the full path of the support.icw file
        //
        bStatus = SearchPath (
                        NULL, 
                        (PTCHAR)SUPPORT_FILE, 
                        NULL, 
                        MAX_PATH, 
                        (PTCHAR)&szFilePath,
                        (PTCHAR*)&pszTemp    
                        );
        if (FALSE == bStatus)
        {
            TraceMsg (TF_GENERAL,
                "Failed on SearchPath API call with error:%d\r\n",
                GetLastError ()
                );
            hRetVal = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }

        //
        // now we can start processing the file
        //
        pcCSVFile = new CCSVFile;
        if (NULL == pcCSVFile)
        {
            TraceMsg (TF_GENERAL, "Could not allocate mem for CCSVFile\r\n");
            hRetVal = ERROR_OUTOFMEMORY;
           goto Cleanup;
        }

   
        //
        // open the file here
        //
        bStatus = pcCSVFile->Open (szFilePath);
        if (FALSE == bStatus)
        {
            TraceMsg (TF_GENERAL, "Filed on  CCSVFile :: Open call\r\n");
            hRetVal = GetLastError (); 
            goto Cleanup;
        }

       //
       // now we are ready to get the phone number out of the
       // file
       //
       dwCurrentIndex = 0;
       dwIndexAllocated = 0;

       do  
       {
            
            //
            // check if we ned to allocate memory
            //
            if (dwIndexAllocated == dwCurrentIndex)
            {
            
                //
                //  need to allocate memory
                //
                pTemp = (PSUPPORTNUM) GlobalAlloc (
                                    GPTR,
                                    (int)((dwIndexAllocated + ALLOCATION_SIZE)*INFOSIZE)
                                    );
                if (NULL == pTemp)
                {
                    TraceMsg (TF_GENERAL,
                        "Failed on GlobalAlloc API call with error:%d\r\n",
                        GetLastError ()
                        );
                    hRetVal = ERROR_OUTOFMEMORY;
                    goto Cleanup;
                }

                //
                //  now copy over already allocated memory to this buffer
                //
                if (NULL != pPhbkArray) 
                {
                    CopyMemory (
                        pTemp, 
                        pPhbkArray, 
                        (int)(dwIndexAllocated)*INFOSIZE
                        );
    
                    //
                    // free the earlier memory
                    //
                    GlobalFree(pPhbkArray);
                }
            
                pPhbkArray = pTemp;
                dwIndexAllocated += ALLOCATION_SIZE;
            }

            //
            // get the phone number info
            //
            hRetVal = ReadOneLine (&pPhbkArray[dwCurrentIndex], pcCSVFile);
            if (ERROR_NO_MORE_ITEMS == hRetVal)
            {
                TraceMsg (TF_GENERAL, "we have read all the items from the file\r\n");
                break;
            }
            else if (ERROR_SUCCESS != hRetVal)
            {
                goto Cleanup;
            }

            dwCurrentIndex++;
        }
        while (TRUE);


        //
        // get the memory needed  by the user
        //
         dwMemNeeded = (DWORD)(dwCurrentIndex)*INFOSIZE;
    
        //
        // check if the user wants the info, or just the size
        //
        if (FALSE == bReturnMemNeeded) 
        {
            if (*pdwSize >= dwMemNeeded) 
            {
                //
                // user wants us to copy over stuff to the memory 
                // and there is enough space in user buffers.
                //
                CopyMemory (
                    pSupportNumList,
                    pPhbkArray,
                    (int)dwMemNeeded
                    );
            }
            else
            {
                TraceMsg (TF_GENERAL, "Caller did not allocate enough memory\r\n");
                hRetVal = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
                
        }

    
        //
        //  if we reached here, then successfully got the info
        //
        hRetVal = ERROR_SUCCESS;
    

Cleanup:
        //
        // copy the memory used/required to the user size param
        //
        *pdwSize = dwMemNeeded; 
     
        if (NULL != pPhbkArray) 
            GlobalFree (pPhbkArray);

        if (NULL != pcCSVFile)
        {
            pcCSVFile->Close (); 
            delete pcCSVFile;
        }
         

        TraceMsg (TF_GENERAL, "Leaving GetSupportNumsFromFile function call\r\n");

        return (hRetVal);

}   //  end of  GetSupportNumsFromFile function

//++--------------------------------------------------------------
//
//  Function:   ReadOneLine
//
//  Synopsis:   This is the function used to put the info
//              into the buffer, line by line
//
//  Returns:    HRESULT - success or error info
//
//  Called By:  GetSupportNumsFromFile  function
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
HRESULT
ReadOneLine (
    PSUPPORTNUM pPhbk,
    CCSVFile    *pcCSVFile
    )
{
    TCHAR       szTempBuffer[PHONE_NUM_SIZE + 4];
    HRESULT     hResult = ERROR_SUCCESS; 
    BOOL        bRetVal = FALSE;

        if ((NULL == pcCSVFile) || (NULL == pPhbk))
        {
            TraceMsg (TF_GENERAL, "ReadOneLine: Did not correctly pass args\r\n");
            hResult = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        //  get the country code first
        //
        bRetVal = pcCSVFile->ReadToken (szTempBuffer, PHONE_NUM_SIZE);
        if (FALSE == bRetVal)
        {
            hResult = ERROR_NO_MORE_ITEMS;
            goto Cleanup;
        }

        //
        // Convert the string obtained into a number
        //
        bRetVal = FSz2Dw (szTempBuffer, (PDWORD)&pPhbk->dwCountryCode); 
        if (FALSE == bRetVal)
        {
            hResult = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // now get the phone number
        //
        bRetVal = pcCSVFile->ReadToken (szTempBuffer, PHONE_NUM_SIZE);
        if (FALSE == bRetVal)
        {
            hResult = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // copy this string into  our struct
        //
        CopyMemory (
                pPhbk->szPhoneNumber,
                szTempBuffer,
                (int)PHONE_NUM_SIZE
                );
        
        //
        // if we have reached here then success
        //
        hResult = ERROR_SUCCESS;

Cleanup:

    return (hResult);

}   //  end of ReadOneLine function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#include <windows.h>
#ifdef WIN16
#include <win16def.h>
#endif
#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for phone books
class CCSVFile 
{
	
	public: 
		void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
		void operator delete( void far * p ) {GlobalFree(p); };

		CCSVFile();
		~CCSVFile();
		BOOLEAN Open(LPCTSTR pszFileName);
		BOOLEAN ReadToken(LPTSTR pszDest, DWORD cbMax);	// reads up to comma or newline, returns fFalse on EOF
		void Close(void);
		inline int ILastRead(void)
			{
			return m_iLastRead;
			}

	private:
		BOOL 	FReadInBuffer(void);
		inline int 	ChNext(void);
		CHAR 	m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
		LPSTR 	m_pchBuf;			//pointer to the next item in the buffer to read
		LPSTR	m_pchLast;			//pointer to the last item in the buffer
		int  	m_iLastRead;		//the character last read.
		DWORD 	m_cchAvail;
		HANDLE 	m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\pch.h ===
#if defined(WIN16)
#define WINVER 0x30a
#endif

#include <windows.h>

#if defined(WIN16)
#define WCHAR	WORD
#include <stdio.h>
#include <memory.h>
#include <ctype.h>
#endif

#include <tapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\misc.h ===
// ############################################################################
// PROTOTYPES
LPTSTR GetSz(WORD wszID);
void SzCanonicalFromAE (LPTSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE);
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2);
int __cdecl CompareCntryNameLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElements(const void*e1, const void*e2);
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2);
int __cdecl Compare950Entry(const void*e1, const void*e2);
BOOL FSz2Dw(LPCTSTR pSz,DWORD far *dw);
BOOL FSz2W(LPCTSTR pSz,WORD far *w);
BOOL FSz2B(LPCTSTR pSz,BYTE far *pb);
HRESULT MakeBold (HWND hwnd);
HRESULT ReleaseBold(HWND hwnd);
#if !defined(WIN16)
DWORD DWGetWin32Platform();
DWORD DWGetWin32BuildNumber();
#endif
/*
inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw);
inline BOOL FSz2W(PCSTR pSz,WORD *w);
inline BOOL FSz2B(PCSTR pSz,BYTE *pb);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\icwsupport.h ===
//#--------------------------------------------------------------
//        
//  File:       icwsupport.h
//        
//  Synopsis:   holds the function declaration, etc 
//              for the support.cpp file
//
//  History:     5/8/97    MKarki Created
//
//    Copyright (C) 1996-97 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------

#ifndef _SUPPORT_H_
#define _SUPPORT_H_

#include "ccsv.h"
//
// size of Phone Number string
//
const DWORD PHONE_NUM_SIZE = 64;

//
// SUPPORTNUM struct declaration
//
typedef struct _SUPPORTNUM
{
    DWORD   dwCountryCode;
    CHAR    szPhoneNumber[PHONE_NUM_SIZE +4];
}
SUPPORTNUM, *PSUPPORTNUM;

//
// function gets the support phone number from the SUPPORT.ICW 
// file
//
HRESULT
GetSupportNumsFromFile (
    PSUPPORTNUM   pSupportNumList,
    PDWORD        pdwSize 
    );

//
// processes one line at a time from the file
//
HRESULT
ReadOneLine (
    PSUPPORTNUM pPhbk,
    CCSVFile *pcCSVFile
    );

#endif //_SUPPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\pch.hpp ===
#if defined(WIN16)
#define WINVER 0x30a
#endif

#include <windows.h>

#if defined(WIN16)
#define WCHAR	WORD
#include <stdio.h>
#include <memory.h>
#include <ctype.h>
#endif

#if !defined(WIN16)
#define TAPI_CURRENT_VERSION 0x00010004
#endif //!WIN16
#include <tapi.h>

#ifdef WIN16
#include <rasc.h>
#else
#include <ras.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\main.cpp ===
// ############################################################################
#include "pch.hpp"
#ifdef WIN16
#include <win16def.h>
#include <malloc.h>
#include <string.h>
#endif

extern "C" {
HINSTANCE g_hInstDll;	// instance for this DLL  
}


#ifdef WIN16

int CALLBACK LibMain(HINSTANCE hinst, 
						WORD wDataSeg, 
						WORD cbHeap,
						LPSTR lpszCmdLine )
{
	g_hInstDll = hinst;

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateMalloc()
//
//  Synopsis:   Allocate and initialize memory
//
//  Arguments:  [size	- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void far *PrivateMalloc(size_t size)
{
	void far * ReturnValue = NULL;
	
	ReturnValue = malloc(size);
	if (NULL != ReturnValue)
		memset(ReturnValue, 0, size);
		
	return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   PrivateReAlloc()
//
//  Synopsis:   Reallocate memory
//
//  Arguments:  [lpBlock 	- Block to be reallocated ]
//				[size		- Size of memory block to be allocated]
//
//	Returns:	pointer to memory block if successful
//				NULL otherwise
//
//  History:    7/25/96     ValdonB    Created
//
//----------------------------------------------------------------------------
void far *PrivateReAlloc(void far *lpBlock, size_t size)
{
	void far *lpRetBlock;
	
	lpRetBlock = PrivateMalloc(size);
	if (NULL == lpRetBlock)
		return NULL;
	
	if (NULL != lpBlock)
	{
		size_t OldBlockSize, MoveSize;
		
		OldBlockSize = _msize(lpBlock);
		MoveSize = min(OldBlockSize, size);
		memmove(lpRetBlock, lpBlock, MoveSize);  
		PrivateFree(lpBlock);
	}
	
	return lpRetBlock;
}


//+---------------------------------------------------------------------------
//
//  Function:   PrivateFree
//
//  Synopsis:   Free a block of memory
//
//  Arguments:  [lpBlock - Block to be freed]
//
//	Returns:	Nothing
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
void PrivateFree(void far *lpBlock)
{
	free(lpBlock);
}


//+---------------------------------------------------------------------------
//
//  Function:   SearchPath()
//
//  Synopsis:   Searchs for the specified file in the given path
//
//  Arguments:  [lpPath			- Address of search path]
//				[lpFileName		- Address of filename]
//				[lpExtension	- Address of Extension]
//				[nBufferLength	- size, in characters, of buffer]
//				[lpBuffer		- address of buffer for found filename]
//				[lpFilePart		- address of pointer to file component]
//
//	Returns:	Length of string copied to buffer (not including terminating
//					NULL character) if successful
//				0 otherwise
//
//  History:    7/9/96     VetriV    Created
//
//----------------------------------------------------------------------------
DWORD SearchPath(LPCTSTR lpPath,LPCTSTR lpFileName, LPCTSTR lpExtension,
					DWORD nBufferLength, LPTSTR lpBuffer, LPTSTR *lpFilePart)
{ 
	
	BOOL bUseExtension = FALSE, bPathContainsFileName = FALSE;
	DWORD dwRequiredLength;
	LPSTR lpszPath = lpPath;
	char szFileName[MAX_PATH+1];
	OFSTRUCT OpenBuf;
		
	
	
	// Check if extension should be used
	//
	if ((NULL != lpExtension) && !strchr(lpFileName, '.'))
		bUseExtension = TRUE;

	//
	// Form Filename
	//
	lstrcpy(szFileName, lpFileName);
	if (bUseExtension)
		lstrcat(szFileName, lpExtension);
	
	
	//
	// If search path is NULL, then try to OpenFile using OF_SEARCH flag
	// get the full path in OpenBuf struct
	//
	if (NULL == lpszPath)
	{
		
		if (HFILE_ERROR != OpenFile(szFileName, &OpenBuf, OF_EXIST | OF_SEARCH))
		{ 
			//
			// This path contains the file name also
			//
			lpszPath = &OpenBuf.szPathName[0];
			bPathContainsFileName = TRUE;
		}
		else
			return 0;
	}
			
	//
	// Check if output buffer length is sufficient
	//
	dwRequiredLength = lstrlen(lpszPath) + 
						(bPathContainsFileName ? 0 :lstrlen(szFileName)) + 1;
	if (nBufferLength < dwRequiredLength)
		return 0;

	//
	// Copy the full name to buffer
	//
	if (bPathContainsFileName)
		lstrcpy(lpBuffer, lpszPath);
	else
		wsprintf(lpBuffer, "%s\\%s", lpszPath, szFileName);

	
	//
	// Do not include the terminating null character in return length
	//
	return dwRequiredLength - 1;
}


#else // WIN16

extern "C" BOOL WINAPI PHBKDllEntryPoint(
    HINSTANCE  hinstDLL,	// handle to DLL module 
    DWORD  fdwReason,		// reason for calling function 
    LPVOID  lpvReserved 	// reserved 
   )
{
	if (fdwReason == DLL_PROCESS_ATTACH)
		g_hInstDll = hinstDLL;
    
	return TRUE;
}

#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\misc.cpp ===
// ############################################################################
// Miscellaneous support routines
#include "pch.hpp"
#ifdef WIN16
#include <win16def.h>
#endif
#include "phbk.h"

#define irgMaxSzs 5
TCHAR szStrTable[irgMaxSzs][256];

// ############################################################################
LPTSTR GetSz(WORD wszID)
{
    static int iSzTable=0;
    LPTSTR psz = (LPTSTR)&szStrTable[iSzTable][0];
    
    iSzTable++;
    if (iSzTable >= irgMaxSzs)
        iSzTable = 0;
        
    if (!LoadString(g_hInstDll, wszID, psz, 256))
    {
        TraceMsg(TF_GENERAL,"LoadString failed %d\n", (DWORD) wszID);
        *psz = 0;
    }
        
    return (psz);
}

// ############################################################################
void SzCanonicalFromAE (LPTSTR psz, PACCESSENTRY pAE, LPLINECOUNTRYENTRY pLCE)
{
    if (NO_AREA_CODE == pAE->dwAreaCode)
    {
        wsprintf(psz, TEXT("+%ld %s"), pLCE->dwCountryCode, pAE->szAccessNumber);
    }
    else
    {
        wsprintf(psz, TEXT("+%ld (%s) %s"), pLCE->dwCountryCode, pAE->szAreaCode, pAE->szAccessNumber);
    }
    
    return;
}

// ############################################################################
int MyStrcmp(LPVOID pv1, LPVOID pv2)
{
    LPTSTR pc1 = (LPTSTR) pv1;
    LPTSTR pc2 = (LPTSTR) pv2;
    int iRC = 0;
    // loop while not pointed at the ending NULL character and no difference has been found
    while (*pc1 && *pc2 && !iRC)
    {
        iRC = (int)(*pc1 - *pc2);
        pc1++;
        pc2++;
    }

    // if we exited because we got to the end of one string before we found a difference
    // return -1 if pv1 is longer, else return the character pointed at by pv2.  If pv2
    // is longer than pv1 then the value at pv2 will be greater than 0.  If both strings
    // ended at the same time, then pv2 will point to 0.
    if (!iRC)
    {
        iRC = (*pc1) ? -1 : (*pc2);
    }
    return iRC;
}
// ############################################################################
int __cdecl Compare950Entry(const void*pv1, const void*pv2)
{
    return (((NPABLOCK *) pv1)->wAreaCode - ((NPABLOCK *) pv2)->wAreaCode);
}

// ############################################################################
int __cdecl CompareIDLookUpElements(const void *e1, const void *e2)
{
    if (((LPIDLOOKUPELEMENT)e1)->dwID > ((LPIDLOOKUPELEMENT)e2)->dwID)
        return 1;
    if (((LPIDLOOKUPELEMENT)e1)->dwID < ((LPIDLOOKUPELEMENT)e2)->dwID)
        return -1;
    return 0;
}

// ############################################################################
int __cdecl CompareCntryNameLookUpElements(const void *e1, const void *e2)
{
    LPCNTRYNAMELOOKUPELEMENT pCUE1 = (LPCNTRYNAMELOOKUPELEMENT)e1;
    LPCNTRYNAMELOOKUPELEMENT pCUE2 = (LPCNTRYNAMELOOKUPELEMENT)e2;

#ifdef WIN16
    return lstrcmpi(pCUE1->psCountryName, pCUE2->psCountryName);
#else        
    return CompareString(LOCALE_USER_DEFAULT,0,pCUE1->psCountryName,
        pCUE1->dwNameSize,pCUE2->psCountryName,
        pCUE2->dwNameSize) - 2;
//    return CompareString(LOCALE_USER_DEFAULT,0,((LPCNTRYNAMELOOKUPELEMENT)*e1)->psCountryName,
//        ((LPCNTRYNAMELOOKUPELEMENT)*e1)->dwNameSize,((LPCNTRYNAMELOOKUPELEMENT)*e2)->psCountryName,
//        ((LPCNTRYNAMELOOKUPELEMENT)*e2)->dwNameSize) - 2;
#endif
}

// ############################################################################
int __cdecl CompareIdxLookUpElements(const void *e1, const void *e2)
{
    if (((LPIDXLOOKUPELEMENT)e1)->dwIndex > ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
        return 1;
    if (((LPIDXLOOKUPELEMENT)e1)->dwIndex < ((LPIDXLOOKUPELEMENT)e2)->dwIndex)
        return -1;
    return 0;
}

// ############################################################################
int __cdecl CompareIdxLookUpElementsFileOrder(const void *pv1, const void *pv2)
{
    PACCESSENTRY pae1, pae2;
    int iSort;

    pae1 = ((LPIDXLOOKUPELEMENT)pv1)->pAE;
    pae2 = ((LPIDXLOOKUPELEMENT)pv2)->pAE;

    // sort empty enteries to the end of the list
    if (!(pae1 && pae2))
    {
        return (pae1 ? -1 : (pae2 ? 1 : 0));
    }

    // country ASC, state ASC, city ASC, toll free DESC, flip DESC, con spd max DESC
    if (pae1->dwCountryID != pae2->dwCountryID)
    {
        return (int)(pae1->dwCountryID - pae2->dwCountryID);
    }
    
    if (pae1->wStateID != pae2->wStateID)
    {
        return (pae1->wStateID - pae2->wStateID);
    }

    iSort  = MyStrcmp((LPVOID)pae1->szCity, (LPVOID)pae2->szCity);
    if (iSort)
    {
        return (iSort);
    }

    if (pae1->fType != pae2->fType)
    {
        return ((int) (pae2->fType - pae1->fType));
    }

    if (pae1->bFlipFactor != pae2->bFlipFactor)
    {
        return (pae2->bFlipFactor - pae1->bFlipFactor);
    }

    if (pae1->dwConnectSpeedMax != pae2->dwConnectSpeedMax)
    {
        return (int)(pae2->dwConnectSpeedMax - pae1->dwConnectSpeedMax);
    }

    return 0;
}

// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(LPCTSTR pSz,DWORD far *dw)
{
    DWORD val = 0;
    while (*pSz)
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(LPCTSTR pSz,WORD far *w)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(LPCTSTR pSz,BYTE far *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

// ############################################################################
HRESULT MakeBold (HWND hwnd)
{
    HRESULT hr = ERROR_SUCCESS;
    HFONT hfont = NULL;
    HFONT hnewfont = NULL;
    LOGFONT far * plogfont = NULL;

    if (!hwnd) goto MakeBoldExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }
    
    plogfont = (LOGFONT far *)GlobalAlloc(GPTR,sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    if (plogfont->lfHeight < 24)
    {
        plogfont->lfHeight = plogfont->lfHeight + (plogfont->lfHeight / 4);
    }

    plogfont->lfWeight = FW_BOLD;

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = GetLastError();
        goto MakeBoldExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(FALSE,0));

    GlobalFree(plogfont);
    plogfont = NULL;
    
MakeBoldExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    return hr;
}

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function:    DWGetWin32Platform
//
//    Synopsis:    Return a value to determine win32 platform
//
//    Arguements:    None
//
//    Returns:    platform enumeration (see GetVersionEx for details)
//
//    History:    8/8/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32Platform()
{
    OSVERSIONINFO osver;
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (GetVersionEx(&osver))
        return osver.dwPlatformId;
    AssertMsg(0,"GetVersionEx failed.\r\n");
    return 0;
}

//+----------------------------------------------------------------------------
//
//    Function:    DWGetWin32BuildNumber
//
//    Synopsis:    Return a value to determine win32 build
//
//    Arguements:    None
//
//    Returns:    build number
//
//    History:    9/26/96    ChrisK    Created
//
//-----------------------------------------------------------------------------
DWORD DWGetWin32BuildNumber()
{
    OSVERSIONINFO osver;
    ZeroMemory(&osver,sizeof(osver));
    osver.dwOSVersionInfoSize = sizeof(osver);
    if (GetVersionEx(&osver))
        // dwBuildNumber
        // Identifies the build number of the operating system in the low-order
        // word. (The high-order word contains the major and minor version numbers.)
        return (osver.dwBuildNumber & 0xFFFF);
    AssertMsg(0,"GetVersionEx failed.\r\n");
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\phbk.h ===
#ifndef _PHBK
#define _PHBK

#include "ccsv.h"
#include "debug.h"
#include "icwsupport.h"

#ifdef WIN16
#include <malloc.h>

#define DllExportH extern "C" HRESULT WINAPI __export
#else
#define DllExportH extern "C" HRESULT WINAPI __stdcall 
//#define DllExportH extern "C" __declspec(dllexport) HRESULT WINAPI
#endif

#define MsgBox(m,s) MessageBox(GetSz(m),GetSz(IDS_TITLE),s)

#define cbAreaCode    6            // maximum number of characters in an area code, not including \0
#define cbCity 19                // maximum number of chars in city name, not including \0
#define cbAccessNumber 15        // maximum number of chars in phone number, not including \0
#define cbStateName 31             // maximum number of chars in state name, not including \0
                                // check this against state.pbk delivered by mktg
#define cbBaudRate 6            // maximum number of chars in a baud rate, not including \0
#if defined(WIN16)
#define cbDataCenter 12            // max length of data center string
#else
#define cbDataCenter (MAX_PATH+1)            // max length of data center string
#endif
#define NO_AREA_CODE 0xFFFFFFFF

#define PHONE_ENTRY_ALLOC_SIZE    500
#define INF_SUFFIX        TEXT(".ISP")
#define INF_APP_NAME      TEXT("ISP INFO")
#define INF_PHONE_BOOK    TEXT("PhoneBookFile")
#define INF_DEFAULT      TEXT("SPAM SPAM SPAM SPAM SPAM SPAM EGGS AND SPAM")
#define STATE_FILENAME    TEXT("STATE.ICW")
#define FILE_NAME_800950  TEXT("800950.DAT")
#define TEMP_BUFFER_LENGTH 1024
#define MAX_INFCODE 9

#define TYPE_SIGNUP_TOLLFREE    0x83
#define TYPE_SIGNUP_TOLL        0x82
#define TYPE_REGULAR_USAGE        0x42

#define MASK_SIGNUP_TOLLFREE    0xB3
#define MASK_SIGNUP_TOLL        0xB3
#define MASK_REGULAR_USAGE        0x73

// 8/13/96 jmazner for Normandy bug #4597
// ported from core\client\phbk 10/15/96
#define MASK_TOLLFREE_BIT            0x01    // Bit #1: 1=tollfree, 0=charge
#define TYPE_SET_TOLLFREE            0x01    // usage: type |= TYPE_SET_TOLLFREE
// want TYPE_SET_TOLL to be a DWORD to match pSuggestInfo->fType
#define TYPE_SET_TOLL                ~((DWORD)TYPE_SET_TOLLFREE)    // usage: type &= TYPE_SET_TOLL

#define MASK_ISDN_BIT               0x04    // Bit #3: 1=ISDN, 0=Non-ISDN
#define MASK_ANALOG_BIT             0x08    // Bit #4: 1=Analog, 0=Non-Analog

#define clineMaxATT    16
#define NXXMin        200
#define NXXMax        999
#define cbgrbitNXX    ((NXXMax + 1 - NXXMin) / 8)

// Phone number select dialog flags
//

#define FREETEXT_SELECTION_METHOD  0x00000001
#define PHONELIST_SELECTION_METHOD 0x00000002
#define AUTODIAL_IN_PROGRESS       0x00000004
#define DIALERR_IN_PROGRESS        0x00000008

// Phone number type
//

#define ANALOG_TYPE        0
#define ISDN_TYPE          1
#define BOTH_ISDN_ANALOG   2

typedef struct
{
    DWORD    dwIndex;                                // index number
    BYTE    bFlipFactor;                            // for auto-pick
    DWORD    fType;                                    // phone number type
    WORD    wStateID;                                // state ID
    DWORD    dwCountryID;                            // TAPI country ID
    DWORD    dwAreaCode;                                // area code or NO_AREA_CODE if none
    DWORD    dwConnectSpeedMin;                        // minimum baud rate
    DWORD    dwConnectSpeedMax;                        // maximum baud rate
    TCHAR   szCity[cbCity + sizeof('\0')];            // city name
    TCHAR   szAccessNumber[cbAccessNumber + sizeof('\0')];    // access number
    TCHAR   szDataCenter[cbDataCenter + sizeof('\0')];                // data center access string
    TCHAR   szAreaCode[cbAreaCode + sizeof('\0')];                    //Keep the actual area code string around.
} ACCESSENTRY, far *PACCESSENTRY;     // ae

typedef struct {
    DWORD dwCountryID;                                // country ID that this state occurred in
    PACCESSENTRY paeFirst;                            // pointer to first access entry for this state
    TCHAR szStateName[cbStateName + sizeof('\0')];    // state name
} STATE, far *LPSTATE;

typedef struct tagIDLOOKUPELEMENT {
    DWORD dwID;
    LPLINECOUNTRYENTRY pLCE;
    PACCESSENTRY pFirstAE;
} IDLOOKUPELEMENT, far *LPIDLOOKUPELEMENT;

typedef struct tagCNTRYNAMELOOKUPELEMENT {
    LPTSTR psCountryName;
    DWORD dwNameSize;
    LPLINECOUNTRYENTRY pLCE;
} CNTRYNAMELOOKUPELEMENT, far *LPCNTRYNAMELOOKUPELEMENT;

typedef struct tagIDXLOOKUPELEMENT {
    DWORD dwIndex;
    PACCESSENTRY pAE;
} IDXLOOKUPELEMENT,far *LPIDXLOOKUPELEMENT;

typedef struct tagSUGGESTIONINFO
{
    DWORD    dwCountryID;
    DWORD    wAreaCode;
    DWORD    wExchange;
    WORD    wNumber;
    DWORD    fType;  // 9/6/96 jmazner  Normandy
    DWORD    bMask;  // make this struct look like the one in %msnroot%\core\client\phbk\phbk.h
    PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO, far *PSUGGESTINFO;

typedef struct tagNPABlock
{
    WORD wAreaCode;
    BYTE grbitNXX [cbgrbitNXX];
} NPABLOCK, far *LPNPABLOCK;



class CPhoneBook
{
    //friend HRESULT DllExport PhoneBookLoad(LPCTSTR pszISPCode, DWORD *pdwPhoneID);
    //friend class CDialog;
    
    // 1/9/96  jmazner Normandy #13185
    //friend class CAccessNumDlg;
    
    friend class CSelectNumDlg;

public:
    void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
    void operator delete( void far * p ) {GlobalFree(p); };

    CPhoneBook();
    ~CPhoneBook();

    HRESULT Init(LPCTSTR pszISPCode);
    HRESULT Merge(LPCTSTR pszChangeFilename);
    HRESULT Suggest(PSUGGESTINFO pSuggest);
    HRESULT GetCanonical(PACCESSENTRY pAE, LPTSTR psOut);

private:
    PACCESSENTRY            m_rgPhoneBookEntry;
    HANDLE                    m_hPhoneBookEntry;    
    DWORD                    m_cPhoneBookEntries;
    LPLINECOUNTRYENTRY        m_rgLineCountryEntry;
    LPLINECOUNTRYLIST         m_pLineCountryList;
    LPIDLOOKUPELEMENT        m_rgIDLookUp;
    LPCNTRYNAMELOOKUPELEMENT m_rgNameLookUp;
    LPSTATE                    m_rgState;
    DWORD                    m_cStates;
#if !defined(WIN16)
    BOOL              m_bScriptingAvailable;
#endif

    TCHAR                   m_szINFFile[MAX_PATH];
    TCHAR                   m_szINFCode[MAX_INFCODE];
    TCHAR                   m_szPhoneBook[MAX_PATH];

    BOOL ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile);
    BOOL ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile);
    BOOL ReadPhoneBookSZ(LPTSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
    BOOL ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile);
    HRESULT ReadOneLine(PACCESSENTRY pAccessEntry, CCSVFile far *pcCSVFile);
    BOOL FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew);

};

#ifdef __cplusplus
extern "C" {
#endif
extern HINSTANCE g_hInstDll;    // instance for this DLL
extern HWND g_hWndMain;
#ifdef __cplusplus
}
#endif
#endif // _PHBK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\phbk.cpp ===
// ############################################################################
// Phone book APIs
#include "pch.hpp"  
#ifdef WIN16
#include <win16def.h>
#include <win32fn.h>
#include <rasc.h>
#include <raserr.h>
#include <ietapi.h>
extern "C" {
#include "bmp.h"
}
#endif

#include "phbk.h"
#include "misc.h"
#include "phbkrc.h"
#include "suapi.h"

//#define ReadVerifyPhoneBookDW(x)    AssertMsg(ReadPhoneBookDW(&(x),pcCSVFile),"Invalid DWORD in phone book");
#define ReadVerifyPhoneBookDW(x)    if (!ReadPhoneBookDW(&(x),pcCSVFile))                \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");    \
                                            goto ReadError; }
#define ReadVerifyPhoneBookW(x)        if (!ReadPhoneBookW(&(x),pcCSVFile))                \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");    \
                                            goto ReadError; }
#define ReadVerifyPhoneBookB(x)        if (!ReadPhoneBookB(&(x),pcCSVFile))                \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");    \
                                            goto ReadError; }
#define ReadVerifyPhoneBookSZ(x,y)    if (!ReadPhoneBookSZ(&x[0],y+sizeof('\0'),pcCSVFile))    \
                                        {    AssertMsg(0,"Invalid DWORD in phone book");        \
                                            goto ReadError; }

#define CHANGE_BUFFER_SIZE 50

#define TEMP_PHONE_BOOK_PREFIX TEXT("PBH")

#define ERROR_USERBACK 32766
#define ERROR_USERCANCEL 32767

TCHAR szTempBuffer[TEMP_BUFFER_LENGTH];
TCHAR szTempFileName[MAX_PATH];

#ifdef __cplusplus
extern "C" {
#endif
HWND g_hWndMain;
#ifdef __cplusplus
}
#endif

#if !defined(WIN16)
//+----------------------------------------------------------------------------
//
//    Function    IsMSDUN12Installed
//
//    Synopsis    Check if MSDUN 1.2 or higher is installed
//
//    Arguments    none
//
//    Returns        TRUE - MSDUN 1.2 is installed
//
//    History        5/28/97 ChrisK created for Olympus Bug 4392
//                8/7/97    ChrisK lifted from isign32
//
//-----------------------------------------------------------------------------
#define DUN_12_Version ((double)1.2)
BOOL IsMSDUN12Installed()
{
    TCHAR szBuffer[MAX_PATH] = {TEXT("\0")};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);
    FLOAT flVersion = 0e0f;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Services\\RemoteAccess"),
        &hkey))
    {
        goto IsMSDUN12InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
        TEXT("Version"),
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsMSDUN12InstalledExit;
    }

#ifdef UNICODE
    CHAR  szTmp[MAX_PATH];
    wcstombs(szTmp, szBuffer, MAX_PATH+1);
    bRC = DUN_12_Version <= atof(szTmp);
#else
    bRC = DUN_12_Version <= atof(szBuffer);
#endif
IsMSDUN12InstalledExit:
    return bRC;
}
#endif 

// ############################################################################
CPhoneBook::CPhoneBook()
{
    HINSTANCE hInst = NULL;
    LONG lrc;
#if !defined(WIN16)
    HKEY hkey;
#endif
    DWORD dwType;
    DWORD dwSize;
    TCHAR  szData[MAX_PATH+1];

    m_rgPhoneBookEntry = NULL;
    m_hPhoneBookEntry = NULL;
    m_cPhoneBookEntries =0;
    m_rgLineCountryEntry=NULL;
    m_rgState=NULL;
    m_cStates=0;
    m_rgIDLookUp = NULL;
    m_rgNameLookUp = NULL;
    m_pLineCountryList = NULL;

    ZeroMemory(&m_szINFFile[0],MAX_PATH);
    ZeroMemory(&m_szINFCode[0],MAX_INFCODE);
    ZeroMemory(&m_szPhoneBook[0],MAX_PATH);

#if !defined(WIN16)
    if (VER_PLATFORM_WIN32_NT == DWGetWin32Platform())
    {
        m_bScriptingAvailable = TRUE;
    }
    else if (IsMSDUN12Installed())
    {
        //
        // ChrisK 8/7/97 Olympus1 11814
        // Display scripted phone numbers on system with DUN 1.2 installed
        //
        m_bScriptingAvailable = TRUE;
    }
    else
    {
        //
        // Verify scripting by checking for smmscrpt.dll in RemoteAccess registry key
        //
        if (1111 <= DWGetWin32BuildNumber())
        {
            m_bScriptingAvailable = TRUE;
        }
        else
        {
            m_bScriptingAvailable = FALSE;
            hkey = NULL;
            lrc=RegOpenKey(HKEY_LOCAL_MACHINE,TEXT("System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP"),&hkey);
            if (ERROR_SUCCESS == lrc)
            {
                dwSize = sizeof(TCHAR)*MAX_PATH;
                lrc = RegQueryValueEx(hkey,TEXT("Path"),0,&dwType,(LPBYTE)szData,&dwSize);
                if (ERROR_SUCCESS == lrc)
                {
                    if (0 == lstrcmpi(szData,TEXT("smmscrpt.dll")))
                        m_bScriptingAvailable = TRUE;
                }
            }
            if (hkey)
                RegCloseKey(hkey);
            hkey = NULL;
        }

        //
        // Verify that the DLL can be loaded
        //
        if (m_bScriptingAvailable)
        {
            hInst = LoadLibrary(TEXT("smmscrpt.dll"));
            if (hInst)
                FreeLibrary(hInst);
            else
                m_bScriptingAvailable = FALSE;
            hInst = NULL;
        }
    }
#endif // WIN16
}

// ############################################################################
CPhoneBook::~CPhoneBook()
{
#ifdef WIN16
    if (m_rgPhoneBookEntry)
        GlobalFree(m_rgPhoneBookEntry);
#else
    if (m_hPhoneBookEntry)
        GlobalUnlock(m_hPhoneBookEntry);

    if (m_hPhoneBookEntry)
        GlobalFree(m_hPhoneBookEntry);
#endif

    if (m_pLineCountryList) 
        GlobalFree(m_pLineCountryList);

    if (m_rgIDLookUp)
        GlobalFree(m_rgIDLookUp);

    if (m_rgNameLookUp)
        GlobalFree(m_rgNameLookUp);

    if (m_rgState)
        GlobalFree(m_rgState);
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CPhoneBook::ReadPhoneBookSZ(LPTSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CPhoneBook::FixUpFromRealloc(PACCESSENTRY paeOld, PACCESSENTRY paeNew)
{
    BOOL bRC = FALSE;
    LONG_PTR lDiff = 0;
    DWORD idx = 0;

    //
    // No starting value or no move, therefore no fix-ups needed
    //
    if ((0 == paeOld) || (paeNew == paeOld))
    {
        bRC = TRUE;
        goto FixUpFromReallocExit;
    }

    Assert(paeNew);
    Assert(((LONG)paeOld) > 0);    // if these address look like negative numbers
    Assert(((LONG)paeNew) > 0); // I'm not sure the code would handle them

    lDiff = (LONG_PTR)paeOld - (LONG_PTR)paeNew;

    //
    // fix up STATES
    //
    for (idx = 0; idx < m_cStates; idx++)
    {
        if (m_rgState[idx].paeFirst)
            m_rgState[idx].paeFirst = (PACCESSENTRY )((LONG_PTR)m_rgState[idx].paeFirst - lDiff);
    }

    //
    // fix up ID look up array
    //
    for (idx = 0; idx < m_pLineCountryList->dwNumCountries ; idx++)
    {
        if (m_rgIDLookUp[idx].pFirstAE)
            m_rgIDLookUp[idx].pFirstAE = (PACCESSENTRY )((LONG_PTR)m_rgIDLookUp[idx].pFirstAE - lDiff);
    }

    bRC = TRUE;
FixUpFromReallocExit:
    return bRC;
}

// ############################################################################
HRESULT CPhoneBook::Init(LPCTSTR pszISPCode)
{
    LPLINECOUNTRYLIST pLineCountryTemp = NULL;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD dwLastState = 0;
    DWORD dwLastCountry = 0;
    DWORD dwSizeAllocated;
    PACCESSENTRY pCurAccessEntry;
    PACCESSENTRY pAETemp;
    LPLINECOUNTRYENTRY pLCETemp;
    DWORD idx;
    LPTSTR pszTemp;
    CCSVFile far *pcCSVFile=NULL;
    LPSTATE    ps,psLast; //faster to use pointers.
    

/*#ifdef WIN16

    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR, sizeof(LINECOUNTRYLIST) + sizeof(LINECOUNTRYENTRY) + 10);
    if (!m_pLineCountryList)
        goto InitExit;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST) + sizeof(LINECOUNTRYENTRY) + 3;
    m_pLineCountryList->dwNeededSize = m_pLineCountryList->dwUsedSize = m_pLineCountryList->dwTotalSize;
    m_pLineCountryList->dwNumCountries = 1;
    m_pLineCountryList->dwCountryListSize = sizeof(LINECOUNTRYENTRY);
    m_pLineCountryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);

    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD) m_pLineCountryList + m_pLineCountryList->dwCountryListOffset);
    pLCETemp->dwCountryID = 1;
    pLCETemp->dwCountryCode = 1;
    pLCETemp->dwNextCountryID = 0;
    pLCETemp->dwCountryNameSize = 3;
    pLCETemp->dwCountryNameOffset = sizeof(LINECOUNTRYLIST) + sizeof(LINECOUNTRYENTRY);
    pLCETemp->dwSameAreaRuleSize = 0;
    pLCETemp->dwSameAreaRuleOffset = 0;
    pLCETemp->dwLongDistanceRuleSize = 0;
    pLCETemp->dwLongDistanceRuleOffset = 0;
    pLCETemp->dwInternationalRuleSize = 0;
    pLCETemp->dwInternationalRuleOffset = 0;
    lstrcpy ((LPTSTR)((DWORD)m_pLineCountryList + pLCETemp->dwCountryNameOffset), TEXT("USA"));
    pszTemp = (LPTSTR)((DWORD)m_pLineCountryList + pLCETemp->dwCountryNameOffset);

#else    // WIN16   */

    // Get TAPI country list
    m_pLineCountryList = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,sizeof(LINECOUNTRYLIST));
    if (!m_pLineCountryList) 
        goto InitExit;
    
    m_pLineCountryList->dwTotalSize = sizeof(LINECOUNTRYLIST);
    
#if defined(WIN16)
    idx = (DWORD) IETapiGetCountry(0, m_pLineCountryList);
#else
    idx = lineGetCountry(0,0x10003,m_pLineCountryList);
#endif
    if (idx && idx != LINEERR_STRUCTURETOOSMALL)
        goto InitExit;
    
    Assert(m_pLineCountryList->dwNeededSize);

    pLineCountryTemp = (LPLINECOUNTRYLIST)GlobalAlloc(GPTR,
                                                        (size_t)m_pLineCountryList->dwNeededSize);
    if (!pLineCountryTemp)
        goto InitExit;
    
    pLineCountryTemp->dwTotalSize = m_pLineCountryList->dwNeededSize;
    GlobalFree(m_pLineCountryList);
    
    m_pLineCountryList = pLineCountryTemp;
    pLineCountryTemp = NULL;

#if defined(WIN16)
    if (IETapiGetCountry(0, m_pLineCountryList))
#else
    if (lineGetCountry(0,0x10003,m_pLineCountryList))
#endif
        goto InitExit;

//#endif    // WIN16

    // Load Look Up arrays
#ifdef DEBUG
    m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries+5));
#else
    m_rgIDLookUp = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(IDLOOKUPELEMENT)*m_pLineCountryList->dwNumCountries));
#endif
    if (!m_rgIDLookUp) goto InitExit;

    pLCETemp = (LPLINECOUNTRYENTRY)((DWORD_PTR)m_pLineCountryList + 
        m_pLineCountryList->dwCountryListOffset);

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgIDLookUp[idx].dwID = pLCETemp[idx].dwCountryID;
        m_rgIDLookUp[idx].pLCE = &pLCETemp[idx];
    }

    qsort(m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
        CompareIDLookUpElements);

    m_rgNameLookUp = (LPCNTRYNAMELOOKUPELEMENT)GlobalAlloc(GPTR,
        (int)(sizeof(CNTRYNAMELOOKUPELEMENT) * m_pLineCountryList->dwNumCountries));

    if (!m_rgNameLookUp) goto InitExit;

    for (idx=0;idx<m_pLineCountryList->dwNumCountries;idx++)
    {
        m_rgNameLookUp[idx].psCountryName = (LPTSTR)((LPBYTE)m_pLineCountryList + (DWORD)pLCETemp[idx].dwCountryNameOffset);
        m_rgNameLookUp[idx].dwNameSize = pLCETemp[idx].dwCountryNameSize;
        m_rgNameLookUp[idx].pLCE = &pLCETemp[idx];
    }

    qsort(m_rgNameLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(CNTRYNAMELOOKUPELEMENT),
        CompareCntryNameLookUpElements);
    
    // Load States
    if (!SearchPath(NULL,STATE_FILENAME,NULL,TEMP_BUFFER_LENGTH,szTempBuffer,&pszTemp))
    {
        AssertMsg(0,"STATE.ICW not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) goto InitExit;

    if (!pcCSVFile->Open(szTempBuffer))
    {
        AssertMsg(0,"Can not open STATE.ICW");
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto InitExit;
    }

    // first token in state file is the number of states
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
        goto InitExit;

    if (!FSz2Dw(szTempBuffer,&m_cStates))
    {
        AssertMsg(0,"STATE.ICW count is invalid");
        goto InitExit;
    }

    m_rgState = (LPSTATE)GlobalAlloc(GPTR,(int)(sizeof(STATE)*m_cStates));
    if (!m_rgState)
        goto InitExit;

    for (ps = m_rgState, psLast = &m_rgState[m_cStates - 1]; ps <= psLast;++ps)
        {
        pcCSVFile->ReadToken(ps->szStateName,cbStateName);    
        }
    
    pcCSVFile->Close();

    // Locate ISP's INF file
    if (!SearchPath(NULL,(LPCTSTR) pszISPCode,INF_SUFFIX,MAX_PATH,
                        m_szINFFile,&pszTemp))
    {
        wsprintf(szTempBuffer,TEXT("Can not find:%s%s (%d)"),pszISPCode,INF_SUFFIX,GetLastError());
        AssertMsg(0,szTempBuffer);
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    //Load Phone Book
    if (!GetPrivateProfileString(INF_APP_NAME,INF_PHONE_BOOK,INF_DEFAULT,
        szTempBuffer,TEMP_BUFFER_LENGTH,m_szINFFile))
    {
        AssertMsg(0,"PhoneBookFile not specified in INF file");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }
    
#ifdef DEBUG
    if (!lstrcmp(szTempBuffer,INF_DEFAULT))
    {
        wsprintf(szTempBuffer, TEXT("%s value not found in ISP file"), INF_PHONE_BOOK);
        AssertMsg(0,szTempBuffer);
    }
#endif

    
    if (!SearchPath(NULL,szTempBuffer,NULL,MAX_PATH,m_szPhoneBook,&pszTemp))
    {
        AssertMsg(0,"ISP phone book not found");
        hr = ERROR_FILE_NOT_FOUND;
        goto InitExit;
    }

    if (!pcCSVFile->Open(m_szPhoneBook))
    {
        AssertMsg(0,"Can not open phone book");
        hr = GetLastError();
        goto InitExit;
    }
    
    dwSizeAllocated = 0;
    do {
        Assert (dwSizeAllocated >= m_cPhoneBookEntries);
        // check that sufficient memory is allocated
        if (m_rgPhoneBookEntry)
        {
            if (dwSizeAllocated == m_cPhoneBookEntries)
            {
                //
                // we need more memory
                //
//                AssertMsg(0,"Out of memory originally allocated for phone book.\r\n");
//                goto InitExit;

                pAETemp = m_rgPhoneBookEntry;
#ifdef WIN16            
                dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
                m_rgPhoneBookEntry = (PACCESSENTRY)GlobalReAlloc(m_rgPhoneBookEntry,
                    (int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
                if (NULL == m_rgPhoneBookEntry) 
                    goto InitExit;
#else

                // UNLOCK
                Assert(m_hPhoneBookEntry);
                if (FALSE == GlobalUnlock(m_hPhoneBookEntry))
                {
                    if (NO_ERROR != GetLastError())
                        goto InitExit;
                }

                // REALLOC
                dwSizeAllocated += PHONE_ENTRY_ALLOC_SIZE;
                m_hPhoneBookEntry = GlobalReAlloc(m_hPhoneBookEntry,
                    (int)(dwSizeAllocated * sizeof(ACCESSENTRY)),GHND);
                if (NULL == m_hPhoneBookEntry) 
                    goto InitExit;

                // LOCK
                m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
                if (NULL == m_rgPhoneBookEntry) 
                    goto InitExit;
                
#endif
                FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry); 
                TraceMsg(TF_GENERAL, "Grow phone book to %d entries\n",dwSizeAllocated);
                pCurAccessEntry = (PACCESSENTRY)((LONG_PTR)pCurAccessEntry - 
                    ((LONG_PTR)pAETemp - (LONG_PTR)(m_rgPhoneBookEntry)));

            }
        }
        else
        {
            //
            // Initialization for the first time through 
            //
            
            // ALLOC
#ifdef WIN16
            m_rgPhoneBookEntry = (PACCESSENTRY)GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
            if(NULL == m_rgPhoneBookEntry) 
                goto InitExit;
#else
            m_hPhoneBookEntry = GlobalAlloc(GHND,sizeof(ACCESSENTRY) * PHONE_ENTRY_ALLOC_SIZE);
            if(NULL == m_hPhoneBookEntry) 
                goto InitExit;

            // LOCK
            m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
            if(NULL == m_rgPhoneBookEntry) 
                goto InitExit;
#endif
            dwSizeAllocated = PHONE_ENTRY_ALLOC_SIZE;
            pCurAccessEntry = m_rgPhoneBookEntry;
        }

        // Read a line from the phonebook
        hr = ReadOneLine(pCurAccessEntry,pcCSVFile);
        if (hr == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        else if (hr != ERROR_SUCCESS)
        {
            goto InitExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;

        // Check to see if this is the first phone number for a given country
        if (pCurAccessEntry->dwCountryID != dwLastCountry)
        {
            LPIDLOOKUPELEMENT lpIDLookupElement;
            // NOTE: Not sure about the first parameter here.
            lpIDLookupElement = (LPIDLOOKUPELEMENT)bsearch(&pCurAccessEntry->dwCountryID,
                m_rgIDLookUp,(int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
                CompareIDLookUpElements);
            if (!lpIDLookupElement)
            {
                // bad country ID, but we can't assert here
                TraceMsg(TF_GENERAL,"Bad country ID in phone book %d\n",pCurAccessEntry->dwCountryID);
                continue;
            }
            else
            {
                // for a given country ID this is the first phone number
                lpIDLookupElement->pFirstAE = pCurAccessEntry;
                dwLastCountry = pCurAccessEntry->dwCountryID;
            }
        }

        // Check to see if this is the first phone number for a given state
        if (pCurAccessEntry->wStateID && (pCurAccessEntry->wStateID != dwLastState))
        {
            idx = pCurAccessEntry->wStateID - 1;
            m_rgState[idx].dwCountryID = pCurAccessEntry->dwCountryID;
            m_rgState[idx].paeFirst = pCurAccessEntry;
            dwLastState = pCurAccessEntry->wStateID;
        }

        pCurAccessEntry++;
        m_cPhoneBookEntries++;
    } while (TRUE);

    // Trim the phone book for unused memory
    Assert(m_rgPhoneBookEntry && m_cPhoneBookEntries);

    pAETemp = m_rgPhoneBookEntry;

#ifdef WIN16
    m_rgPhoneBookEntry = (PACCESSENTRY)GlobalReAlloc(m_rgPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
    if (!m_rgPhoneBookEntry) goto InitExit;
#else

    // UNLOCK
    Assert(m_hPhoneBookEntry);
    if (FALSE != GlobalUnlock(m_hPhoneBookEntry))
    {
        if (NO_ERROR != GetLastError())
            goto InitExit;
    }

    // REALLOC
    m_hPhoneBookEntry = GlobalReAlloc(m_hPhoneBookEntry,(int)(m_cPhoneBookEntries * sizeof(ACCESSENTRY)),GHND);
    if (NULL == m_hPhoneBookEntry) 
        goto InitExit;

    // LOCK
    m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
    if (NULL == m_rgPhoneBookEntry) 
        goto InitExit;
#endif
    FixUpFromRealloc(pAETemp, m_rgPhoneBookEntry); 

    hr = ERROR_SUCCESS;
InitExit:
    // If something failed release everything
    if (hr != ERROR_SUCCESS)
    {
#ifdef WIN16
        GlobalFree(m_rgPhoneBookEntry);
#else
        GlobalUnlock(m_hPhoneBookEntry);
        GlobalFree(m_hPhoneBookEntry);
#endif
        GlobalFree(m_pLineCountryList);
        GlobalFree(m_rgIDLookUp);
        GlobalFree(m_rgNameLookUp);
        GlobalFree(m_rgState);

        m_cPhoneBookEntries = 0 ;
        m_cStates = 0;

        m_pLineCountryList = NULL;
        m_rgPhoneBookEntry = NULL;
        m_hPhoneBookEntry = NULL;
        m_rgIDLookUp=NULL;
        m_rgNameLookUp=NULL;
        m_rgState=NULL;
    }

    if (pcCSVFile) 
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::Merge(LPCTSTR pszChangeFile)
{
    CCSVFile far *pcCSVFile;
    ACCESSENTRY aeChange;
    LPIDXLOOKUPELEMENT rgIdxLookUp;
    LPIDXLOOKUPELEMENT pCurIdxLookUp;
    DWORD dwAllocated;
    DWORD dwUsed;
    DWORD dwOriginalSize;
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    DWORD    dwIdx;  
#if !defined(WIN16)
    HANDLE hTemp;
    HANDLE hIdxLookUp;
#else
    // Normandy 11746
    LPVOID rgTemp;  // 16-bit only
#endif
    DWORD cch, cchWritten;
    HANDLE hFile;

    // Pad the phonebook for new entries.
    dwAllocated = m_cPhoneBookEntries + CHANGE_BUFFER_SIZE;
#ifdef WIN16
    Assert(m_rgPhoneBookEntry);
    rgTemp = GlobalReAlloc(m_rgPhoneBookEntry, (int)(sizeof(ACCESSENTRY) * dwAllocated),GHND);
    Assert(rgTemp);
    if (!rgTemp) goto MergeExit;
    m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;
#else
    Assert(m_hPhoneBookEntry);
    GlobalUnlock(m_hPhoneBookEntry);
    hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry, sizeof(ACCESSENTRY) * dwAllocated,GHND);
    Assert(hTemp);
    if (!hTemp)
        goto MergeExit;
    m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
    if (!m_rgPhoneBookEntry)
        goto MergeExit;
#endif

    // Create index to loaded phone book, sorted by index
#ifdef WIN16
    rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalAlloc(GHND,(int)(sizeof(IDXLOOKUPELEMENT) * dwAllocated));
#else
    hIdxLookUp = (HANDLE)GlobalAlloc(GHND,sizeof(IDXLOOKUPELEMENT) * dwAllocated);
    rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
#endif
    Assert(rgIdxLookUp);
    if (!rgIdxLookUp)
        goto MergeExit;

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        rgIdxLookUp[dwIdx].dwIndex = rgIdxLookUp[dwIdx].pAE->dwIndex;
        rgIdxLookUp[dwIdx].pAE = &m_rgPhoneBookEntry[dwIdx];
    }
    dwUsed = m_cPhoneBookEntries;
    dwOriginalSize = m_cPhoneBookEntries;

    qsort(rgIdxLookUp,(int)dwOriginalSize,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);

    // Load changes to phone book
    pcCSVFile = new CCSVFile;
    Assert(pcCSVFile);
    if (!pcCSVFile)
        goto MergeExit;
    if (!pcCSVFile->Open(pszChangeFile))
        goto MergeExit;
    
    do {

        // Read a change record
        ZeroMemory(&aeChange,sizeof(ACCESSENTRY));
        hr = ReadOneLine(&aeChange, pcCSVFile);

        if(hr == ERROR_NO_MORE_ITEMS)
        {
            break; // no more enteries
        }
        else if (hr =! ERROR_SUCCESS)
        {
            goto MergeExit;
        }

        hr = ERROR_NOT_ENOUGH_MEMORY;

/*        if (!ReadPhoneBookDW(&aeChange.dwIndex,pcCSVFile))
            break; // no more enteries
        ReadVerifyPhoneBookDW(aeChange.dwCountryID);
        ReadVerifyPhoneBookW(aeChange.wStateID);
        ReadVerifyPhoneBookSZ(aeChange.szCity,cbCity);
        ReadVerifyPhoneBookSZ(aeChange.szAreaCode,cbAreaCode);
        // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
        if (!FSz2Dw(aeChange.szAreaCode,&aeChange.dwAreaCode))
            aeChange.dwAreaCode = NO_AREA_CODE;
        ReadVerifyPhoneBookSZ(aeChange.szAccessNumber,cbAccessNumber);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMin);
        ReadVerifyPhoneBookDW(aeChange.dwConnectSpeedMax);
        ReadVerifyPhoneBookB(aeChange.bFlipFactor);
        ReadVerifyPhoneBookB(aeChange.fType);
        ReadVerifyPhoneBookSZ(aeChange.szDataCenter,cbDataCenter);
        */

        // Determine if this is a delete or add record
        if (aeChange.szAccessNumber[0] == '0' && aeChange.szAccessNumber[1] == '\0')
        {
            // This is a delete record, find matching record
            // NOTE: we only search the numbers that existed before the change file,
            // because they are the only ones that are sorted.
            pCurIdxLookUp = (LPIDXLOOKUPELEMENT)bsearch(&aeChange,rgIdxLookUp,(int)dwOriginalSize,
                sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElements);
            AssertMsg(pCurIdxLookUp,"Attempting to delete a record that does not exist.  The change file and phone book versions do not match.");
            if (pCurIdxLookUp)
                pCurIdxLookUp->pAE = NULL;  //Create a dead entry in the look up table
            m_cPhoneBookEntries--;
        }
        else
        {
            // This is an add entry
            m_cPhoneBookEntries++;
            dwUsed++;
            // Make sure we have enough room
            if (m_cPhoneBookEntries > dwAllocated)
            {
                // Grow phone book
                dwAllocated += CHANGE_BUFFER_SIZE;
#ifdef WIN16
                Assert(m_rgPhoneBookEntry);
                rgTemp = GlobalReAlloc(m_rgPhoneBookEntry,(int)(sizeof(ACCESSENTRY)*dwAllocated),GHND);
                Assert(rgTemp);
                if (!rgTemp)
                    goto MergeExit;
                m_rgPhoneBookEntry = (PACCESSENTRY)rgTemp;

                // Grow look up index
                Assert(rgIdxLookUp);
                rgTemp = GlobalReAlloc(rgIdxLookUp,(int)(sizeof(IDXLOOKUPELEMENT)*dwAllocated),GHND);
                Assert(rgTemp);
                if (!rgTemp)
                    goto MergeExit;
                rgIdxLookUp = (LPIDXLOOKUPELEMENT)rgTemp;
#else
                Assert(m_hPhoneBookEntry);
                GlobalUnlock(m_hPhoneBookEntry);
                hTemp = (HANDLE)GlobalReAlloc(m_hPhoneBookEntry,sizeof(ACCESSENTRY)*dwAllocated,GHND);
                Assert(hTemp);
                if (!hTemp)
                    goto MergeExit;
                m_hPhoneBookEntry = hTemp;
                m_rgPhoneBookEntry = (PACCESSENTRY)GlobalLock(m_hPhoneBookEntry);
                Assert(m_rgPhoneBookEntry);
                if (!m_rgPhoneBookEntry)
                    goto MergeExit;

                // Grow look up index
                Assert(hIdxLookUp);
                GlobalUnlock(hIdxLookUp);
                hTemp = (HANDLE)GlobalReAlloc(hIdxLookUp,sizeof(IDXLOOKUPELEMENT)*dwAllocated,GHND);
                Assert(hTemp);
                if (!hTemp)
                    goto MergeExit;
                hIdxLookUp = hTemp;
                rgIdxLookUp = (LPIDXLOOKUPELEMENT)GlobalLock(hIdxLookUp);
                Assert(rgIdxLookUp);
                if (!rgIdxLookUp)
                    goto MergeExit;
#endif
            }

            //Add entry to the end of the phonebook and to end of look up index
            CopyMemory(&m_rgPhoneBookEntry[m_cPhoneBookEntries],&aeChange,sizeof(ACCESSENTRY));
            rgIdxLookUp[m_cPhoneBookEntries].dwIndex = m_rgPhoneBookEntry[m_cPhoneBookEntries].dwIndex;
            rgIdxLookUp[m_cPhoneBookEntries].pAE = &m_rgPhoneBookEntry[m_cPhoneBookEntries];
            // NOTE: because the entry is added to the end of the list, we can't add
            // and delete entries in the same change file.
        }
    } while (TRUE);

    // resort the IDXLookUp index to reflect the correct order of enteries
    // for the phonebook file, including all of the entries to be deleted.
    qsort(rgIdxLookUp,(int)dwUsed,sizeof(IDXLOOKUPELEMENT),CompareIdxLookUpElementsFileOrder);

    // Build a new phonebook file  
#ifdef WIN16
    GetTempFileName(0, TEMP_PHONE_BOOK_PREFIX, 0, szTempFileName);
#else
    if (!GetTempPath(TEMP_BUFFER_LENGTH,szTempBuffer))
        goto MergeExit;
    if (!GetTempFileName(szTempBuffer,TEMP_PHONE_BOOK_PREFIX,0,szTempFileName))
        goto MergeExit;
#endif
    hFile = CreateFile(szTempFileName,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,
        FILE_FLAG_WRITE_THROUGH,0);
    if (hFile == INVALID_HANDLE_VALUE)
        goto MergeExit;

    for (dwIdx = 0; dwIdx < m_cPhoneBookEntries; dwIdx++)
    {
        cch = wsprintf(szTempBuffer, TEXT("%lu,%lu,%lu,%s,%s,%s,%lu,%lu,%lu,%lu,%s\r\n"),
            rgIdxLookUp[dwIdx].pAE->dwIndex,
            rgIdxLookUp[dwIdx].pAE->dwCountryID,
            DWORD(rgIdxLookUp[dwIdx].pAE->wStateID),
            rgIdxLookUp[dwIdx].pAE->szCity,
            rgIdxLookUp[dwIdx].pAE->szAreaCode,
            rgIdxLookUp[dwIdx].pAE->szAccessNumber,
            rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMin,
            rgIdxLookUp[dwIdx].pAE->dwConnectSpeedMax,
            DWORD(rgIdxLookUp[dwIdx].pAE->bFlipFactor),
            DWORD(rgIdxLookUp[dwIdx].pAE->fType),
            rgIdxLookUp[dwIdx].pAE->szDataCenter);

        if (!WriteFile(hFile,szTempBuffer,cch,&cchWritten,NULL))
        {
            // something went wrong, get rid of the temporary file
            CloseHandle(hFile);
            DeleteFile(szTempFileName);
            hr = GetLastError();
            goto MergeExit;
        }

        Assert(cch == cchWritten);
    }
    CloseHandle(hFile);
    hFile = NULL;

    // Move new phone book over old
    if (!MoveFileEx(szTempFileName,m_szPhoneBook,MOVEFILE_REPLACE_EXISTING))
    {
        hr = GetLastError();
        goto MergeExit;
    }

    // discard the phonebook in memory
#ifndef WIN16
    Assert(m_hPhoneBookEntry);
    GlobalUnlock(m_hPhoneBookEntry);
#endif
    m_rgPhoneBookEntry = NULL;
    m_cPhoneBookEntries = 0; 
    GlobalFree(m_pLineCountryList);
    GlobalFree(m_rgIDLookUp);
    GlobalFree(m_rgNameLookUp);
    GlobalFree(m_rgState);
    m_cStates = 0;

    lstrcpy(szTempBuffer,m_szINFCode);
    m_szINFFile[0] = '\0';
    m_szPhoneBook[0] = '\0';
    m_szINFCode[0] = '\0';

    //  Reload it (and rebuild look up arrays)
    hr = Init(szTempBuffer);

MergeExit:
    if (hr != ERROR_SUCCESS)
    { 
        GlobalFree(rgIdxLookUp);         
        if (pcCSVFile) delete pcCSVFile;
        CloseHandle(hFile);
    }
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::ReadOneLine(PACCESSENTRY lpAccessEntry, CCSVFile far *pcCSVFile)
{
    HRESULT hr = ERROR_SUCCESS;

#if !defined(WIN16)
ReadOneLineStart:
#endif //WIN16
    if (!ReadPhoneBookDW(&lpAccessEntry->dwIndex,pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto ReadExit;
    }
    ReadVerifyPhoneBookDW(lpAccessEntry->dwCountryID);
    ReadVerifyPhoneBookW(lpAccessEntry->wStateID);
    ReadVerifyPhoneBookSZ(lpAccessEntry->szCity,cbCity);
    ReadVerifyPhoneBookSZ(lpAccessEntry->szAreaCode,cbAreaCode);
    // NOTE: 0 is a valid area code and ,, is a valid entry for an area code
    if (!FSz2Dw(lpAccessEntry->szAreaCode,&lpAccessEntry->dwAreaCode))
        lpAccessEntry->dwAreaCode = NO_AREA_CODE;
    ReadVerifyPhoneBookSZ(lpAccessEntry->szAccessNumber,cbAccessNumber);
    ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMin);
    ReadVerifyPhoneBookDW(lpAccessEntry->dwConnectSpeedMax);
    ReadVerifyPhoneBookB(lpAccessEntry->bFlipFactor);
    ReadVerifyPhoneBookDW(lpAccessEntry->fType);
    ReadVerifyPhoneBookSZ(lpAccessEntry->szDataCenter,cbDataCenter);

    switch (lpAccessEntry->bFlipFactor)
    {
        case BOTH_ISDN_ANALOG:
            // This phone number supports both ISDN or Analog, return true
            // We want analog numbers, check the FlipFactor for zero
            lpAccessEntry->fType |= MASK_ISDN_BIT | MASK_ANALOG_BIT;
            break;
        case ANALOG_TYPE:
            // Analog only
            lpAccessEntry->fType |= MASK_ANALOG_BIT;
            break;
        case ISDN_TYPE:
            // We only want ISDN numbers
            lpAccessEntry->fType |= MASK_ISDN_BIT;
            break;
    }
#if !defined(WIN16)
    //
    // If scripting is not available and the phonebook entry has a dun file other than
    // icwip.dun, then ignore the entry and read the one after that.
    //
    if (!m_bScriptingAvailable)
    {
        if (0 != lstrcmpi(lpAccessEntry->szDataCenter,TEXT("icwip.dun")))
        {
            ZeroMemory(lpAccessEntry,sizeof(ACCESSENTRY));
            goto ReadOneLineStart;
        }
    }
#endif //WIN16

ReadExit:
    return hr;
ReadError:
    hr = ERROR_INVALID_DATA;
    goto ReadExit;
}

// ############################################################################
HRESULT CPhoneBook::Suggest(PSUGGESTINFO pSuggest)
{
    WORD        wNumFound = 0;
    HRESULT        hr = ERROR_NOT_ENOUGH_MEMORY;
//    char        szFileName[MAX_PATH];
//    char        *pszTemp;
//    HANDLE        hFile=NULL;
//    HANDLE        hMap=NULL;
//    DWORD        dwSize;
//    LPNPABLOCK    rg950Data = NULL;
//    NPABLOCK    *p950Data;

    
    // Validate parameters
    Assert(pSuggest);
    Assert(pSuggest->wNumber);

    if (wNumFound == pSuggest->wNumber)
        goto SuggestExit;

    LPIDLOOKUPELEMENT pCurLookUp;
    PACCESSENTRY lpAccessEntry;
    
    //REVIEW: double check this
    pCurLookUp = (LPIDLOOKUPELEMENT)bsearch(&pSuggest->dwCountryID,m_rgIDLookUp,
        (int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),
        CompareIDLookUpElements);

    // Check for invalid country
    if (!pCurLookUp)
        goto SuggestExit;

    // Check if there are any phone numbers for this country
    if (!pCurLookUp->pFirstAE) goto SuggestExit;

    lpAccessEntry = pCurLookUp->pFirstAE;
    do {
        // check for the right area code
        if (lpAccessEntry->dwAreaCode == pSuggest->wAreaCode)
        {
            // check for the right type of number
            if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType)
            {
                pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
                wNumFound++;
            }
        }
        lpAccessEntry++;
    } while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) && 
        (wNumFound < pSuggest->wNumber) &&
        (lpAccessEntry->dwCountryID == pSuggest->dwCountryID));



    //
    //  MKarki - Bug 340 no need to list more numbers if one already found
    //  in Area Code specified by user 
    //
    //    5/24/97 jmazner Olympus #340 and #71
    //    nope, this is wrong.  We always want to return as many applicable
    //    phone numbers as we find.  Just because the area code matches
    //  doesn't mean that we've found an ideal phone number.
    //if (wNumFound == 0)
    //{
    //
    
    // if we couldn't find enough numnbers, try something else
    //

    // 10/15/96  jmazner  ported fixes below from core\client\phbk

    // 
    // Do this only if area code is not 0 - Bug #9349 (VetriV)
    //     if ((pSuggest->wAreaCode != 0) && (wNumFound < pSuggest->wNumber))
    //
    // No, there are some places (Finland?  ChrisK knows) where 0 is a legit area code -- jmazner

    if (wNumFound < pSuggest->wNumber)
    {
        lpAccessEntry = pCurLookUp->pFirstAE;

        // Note: we are now only looking for Nationwide phone numbers (state = 0)

        // 8/13/96 jmazner MOS Normandy #4597
        // We want nationwide toll-free numbers to display last, so for this pass,
        // only consider numbers that are _not_ toll free  (fType bit #1 = 0)
        //
        // 5/24/97 jmazner Olympus #71
        // As per GeoffR's spec, the search passes should not be based on
        // the tollfree bit at all
        //
        // 5/28/97 jmazner Olympus #71
        // ahem...as per GeoffR's new spec, we _should_ consider the tollfree
        // bit and in this query only bring up toll free numbers.
        //
        // so, we will only return numbers whose area code match, or which are
        // tollfree
        //
    
        //
        // Tweak pSuggest->bMask to let through the toll/charge bit
        // 
        pSuggest->bMask |= MASK_TOLLFREE_BIT;

        // //Tweak pSuggest->ftype to be charge
        //pSuggest->fType &= TYPE_SET_TOLL;
        //
        // make that tollfree!
        pSuggest->fType |= TYPE_SET_TOLLFREE;

        do {

            // 8/13/96 jmazner MOS Normandy #4598
            // If this entry's area code matches pSuggest->wAreaCode, then we already
            // have included it in the previous pass, so don't duplicate it again here.
            if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
                 lpAccessEntry->wStateID == 0 &&
                 lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
            {
                pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
                wNumFound++;
            }
            lpAccessEntry++;
        } while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) && 
            (wNumFound < pSuggest->wNumber) &&
            (lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
            (lpAccessEntry->wStateID == 0) );
    }


    // 8/13/96 jmazner MOS Normandy #4597
    // if we STILL couldn't find enough numnbers, widen the search to include tollfree #s
    //
    // 5/24/97 jmazner Olympus #71
    // no need for this pass at all.  See earlier comments.

/****
    if (wNumFound < pSuggest->wNumber)
    {
        lpAccessEntry = pCurLookUp->pFirstAE;
    
        // Tweak pSuggest->bMask to let through the toll/charge bit
        // REDUNDANT? If we made it to this point, we _should_ have done this above...
        // Better safe than sorry!
        Assert(pSuggest->bMask & MASK_TOLLFREE_BIT);
        pSuggest->bMask |= MASK_TOLLFREE_BIT;

        // Tweak pSuggest->ftype to be tollfree
        pSuggest->fType |= TYPE_SET_TOLLFREE;

        do {

            // 8/13/96 jmazner MOS Normandy #4598
            // If this entry's area code matches pSuggest->wAreaCode, then we already
            // have included it in the first pass, so don't include it here.
            // Any entry that made it in in the 2nd pass will definitely not make it in here
            // (because of tollfree bit), so no need to worry about dups from there.
            if ((lpAccessEntry->fType & pSuggest->bMask) == pSuggest->fType &&
              lpAccessEntry->wStateID == 0 &&
              lpAccessEntry->dwAreaCode != pSuggest->wAreaCode)
            {
                pSuggest->rgpAccessEntry[wNumFound] = lpAccessEntry;
                wNumFound++;
            }
            lpAccessEntry++;
        } while ((lpAccessEntry <= &m_rgPhoneBookEntry[m_cPhoneBookEntries-1]) && 
            (wNumFound < pSuggest->wNumber) &&
            (lpAccessEntry->dwCountryID == pSuggest->dwCountryID) &&
            (lpAccessEntry->wStateID == 0) );
    }
****/
    //}  //   End of If for Bug - 340 -  MKarki

/*
    // Flip factoring
    if (wNumFound == 2)
    {
        SYSTEMTIME st;
        GetSystemTime(&st);
        srand((UINT)st.wMilliseconds);
        if ((rand() % 10) > pSuggest->rgLPACCESSENTRY[0]->bFlipFactor)
        {
            lpAccessEntry = pSuggest->rgLPACCESSENTRY[0];
            pSuggest->rgpAccessEntry[0] = pSuggest->rgpAccessEntry[1];
            pSuggest->rgpAccessEntry[1] = lpAccessEntry;
        }
    }
*/

    hr = ERROR_SUCCESS;
SuggestExit:
    pSuggest->wNumber = wNumFound;
    return hr;
}

// ############################################################################
HRESULT CPhoneBook::GetCanonical (PACCESSENTRY pAE, LPTSTR psOut)
{
    HRESULT hr = ERROR_SUCCESS;
    LPIDLOOKUPELEMENT pIDLookUp;

    pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&pAE->dwCountryID,m_rgIDLookUp,
        (int)m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);

    if (!pIDLookUp)
    {
        hr = ERROR_INVALID_PARAMETER;
    } else {
        SzCanonicalFromAE (psOut, pAE, pIDLookUp->pLCE);
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookLoad(LPCTSTR pszISPCode, DWORD_PTR far *pdwPhoneID)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    CPhoneBook far *pcPhoneBook;

    if (!g_hInstDll)
        g_hInstDll = GetModuleHandle(NULL);

    // validate parameters
    Assert(pszISPCode && *pszISPCode && pdwPhoneID);
    *pdwPhoneID = NULL;

    // allocate phone book
    pcPhoneBook = new CPhoneBook;

    // initialize phone book
    if (pcPhoneBook)
        hr = pcPhoneBook->Init(pszISPCode);

    // in case of failure
    if (hr && pcPhoneBook)
    {
        delete pcPhoneBook;
    } else {
        *pdwPhoneID = (DWORD_PTR)pcPhoneBook;
    }

#if defined(WIN16)
    if (!hr)
        BMP_RegisterClass(g_hInstDll);
#endif    

    return hr;
}

// ############################################################################
DllExportH PhoneBookUnload(DWORD_PTR dwPhoneID)
{
    Assert(dwPhoneID);

    if (dwPhoneID)
    {
#if defined(WIN16)
        BMP_DestroyClass(g_hInstDll);
#endif
        // Release contents
        delete (CPhoneBook far*)dwPhoneID;
    }

    return ERROR_SUCCESS;
}

// ############################################################################
DllExportH PhoneBookMergeChanges(DWORD_PTR dwPhoneID, LPCTSTR pszChangeFile)
{
    return ((CPhoneBook far*)dwPhoneID)->Merge(pszChangeFile);
}

// ############################################################################
DllExportH PhoneBookSuggestNumbers(DWORD_PTR dwPhoneID, PSUGGESTINFO lpSuggestInfo)
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;

    // get suggested numbers 
    lpSuggestInfo->rgpAccessEntry = (PACCESSENTRY *)GlobalAlloc(GPTR,sizeof(PACCESSENTRY) * lpSuggestInfo->wNumber);
    if (lpSuggestInfo->rgpAccessEntry)
    {
        hr = ((CPhoneBook far *)dwPhoneID)->Suggest(lpSuggestInfo);
    }

    return hr;
}

// ############################################################################
DllExportH PhoneBookGetCanonical (DWORD_PTR dwPhoneID, PACCESSENTRY pAE, LPTSTR psOut)
{
    return ((CPhoneBook far*)dwPhoneID)->GetCanonical(pAE,psOut);
}

// ############################################################################
DllExportH PhoneBookDisplaySignUpNumbers (DWORD_PTR dwPhoneID,
                                                        LPTSTR far *ppszPhoneNumbers,
                                                        LPTSTR far *ppszDunFiles,
                                                        WORD far *pwPhoneNumbers,
                                                        DWORD far *pdwCountry,
                                                        WORD far *pwRegion,
                                                        BYTE fType,
                                                        BYTE bMask,
                                                        HWND hwndParent,
                                                        DWORD dwFlags)
{
    HRESULT hr;
    AssertMsg(ppszPhoneNumbers && pwPhoneNumbers && pdwCountry &&pwRegion,"invalid parameters");


    //CAccessNumDlg *pcDlg;
    CSelectNumDlg far *pcDlg;
    pcDlg = new CSelectNumDlg;
    if (!pcDlg)
    {
        hr = GetLastError();
        goto DisplayExit;
    }

    // Initialize information for dialog
    //

    pcDlg->m_dwPhoneBook = dwPhoneID;
    pcDlg->m_dwCountryID = *pdwCountry;
    pcDlg->m_wRegion = *pwRegion;
    pcDlg->m_fType = fType;
    pcDlg->m_bMask = bMask;
    pcDlg->m_dwFlags = dwFlags;

    // invoke the dialog
    //
    // BUG: NOT THREAD SAFE!!
    g_hWndMain = hwndParent;
    hr = (HRESULT)DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
                            g_hWndMain, PhbkGenericDlgProc,(LPARAM)pcDlg);
    g_hWndMain = NULL;

    if (hr == IDC_CMDNEXT) 
    {
        *pwRegion = pcDlg->m_wRegion;
        *pdwCountry = pcDlg->m_dwCountryID;

        Assert (ppszPhoneNumbers[0] && ppszDunFiles[0]);
        lstrcpy(ppszPhoneNumbers[0],&pcDlg->m_szPhoneNumber[0]);
        lstrcpy(ppszDunFiles[0],&pcDlg->m_szDunFile[0]);

        hr = ERROR_SUCCESS;
    }
    else if (hr == IDC_CMDBACK)
        hr = ERROR_USERBACK;
    else
        hr = ERROR_USERCANCEL;

    //    hr == -1;
DisplayExit:
    if (pcDlg) delete pcDlg;

    return hr;
}

//DllExportH TestBar()
//{
//    LPCSTR pszISPCode;
//    LPDWORD pdwPhoneID;
//
//    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
//    CPhoneBook FAR *pcPhoneBook;
//
//    if (!g_hInstDll)
//        g_hInstDll = GetModuleHandle(NULL);
//
//    // validate parameters
////1    Assert(pszISPCode && *pszISPCode && pdwPhoneID);
////1    *pdwPhoneID = NULL;
//
//    // allocate phone book
////1    pcPhoneBook = new CPhoneBook;
//
//    // initialize phone book
//    if (pcPhoneBook)
//        hr = pcPhoneBook->Init(pszISPCode);
//
//    // in case of failure
//    if (hr && pcPhoneBook)
//    {
//        delete pcPhoneBook;
//    } else {
//        *pdwPhoneID = (DWORD)pcPhoneBook;
//    }
//
////2#if defined(WIN16)
////2    if (!hr)
////2        BMP_RegisterClass(g_hInstDll);
////2#endif    
//
//    return hr;
//}
//

//++--------------------------------------------------------------
//
//  API :       GetSupportNumbers
//
//  Synopsis:   This is the API used to get the support
//              numbers
//
//  Returns:    HRESULT - success or error info
//  
//  Arguments:  [OUT]       PSUPPORTNUM - array of SUPPORTNUM structs
//              [IN/OUT]    PDWORD      - mem for buffersize
//              
//  Called By:  by the EXE using the ICWPHBK.DLL
//
//  History:    MKarki      Created     5/8/97
//
//----------------------------------------------------------------
DllExportH GetSupportNumbers (
        PSUPPORTNUM  pBuffer,
        PDWORD       pBufferSize
        )
{
    return (GetSupportNumsFromFile (pBuffer, pBufferSize));

}   // end of GetSupportNumbers API call
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\phbkrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by phbk.rc
//
#define IDS_950NUMBER                   1
#define IDS_WANTTOEXIT                  2
#define IDS_TITLE                       3
#define IDS_NOTENOUGHMEMORY             4
#define IDS_NATIONWIDE                  5
#define IDS_INVALIDPHONE                6
#define IDS_OK                          7
#define IDD_ACCESSNUMBERS               101
#define IDD_SELECTNUMBER                102
#define IDB_WORLD                       106
#define IDB_PHONE                       107
#define IDC_CMDHELP                     1000
#define IDC_TXTPRIMARY                  1001
#define IDC_TXTSECONDARY                1002
#define IDC_CMDCHANGEPRIMARY            1003
#define IDC_CMDCHANGESECONDARY          1004
#define IDC_CMDEXIT                     1005
#define IDC_CMDOK                       1006
#define IDC_CMBCOUNTRY                  1007
#define IDC_CMBREGION                   1008
#define IDC_LSTNUMBER                   1009
#define IDC_CMDCANCEL                   IDCANCEL
#define IDC_CMBNUMBER                   1011
#define IDC_CMDNEXT                     1012
#define IDC_CMDBACK                     1013
#define IDC_LBLTITLE                    1014
#define IDC_LBLAUTODIAL                 1015
#define IDC_LBLSIGNUP                   1016
#define IDC_LBLDIALERR                  1017
#define IDC_LBLCOUNTRY                  1018
#define IDC_LBLSTATEMSG				    1019
#define IDC_INSTRUCT_ACCESS_TEXT        1020
#define IDC_INSTRUCT_SELECT_TEXT        1021
#define IDC_COUNTRY_TEXT                1022
#define IDC_REGION_TEXT                 1023
#define IDC_PHONE_TEXT                  1024

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\rnaapi.h ===
//-----------------------------------------------------------------------------
// RNAAPI class
// 
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
//      Created 1-29-96	ChrisK

//-----------------------------------------------------------------------------
// TYPEDEF
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);

//-----------------------------------------------------------------------------
// CLASS
// ############################################################################
class CRNAAPI
{
public: 
	void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
	void operator delete( void far * p ) {GlobalFree(p); };

	CRNAAPI();
	~CRNAAPI();

	DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
	DWORD RasValidateEntryName(LPTSTR,LPTSTR);
	DWORD RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
								LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
	DWORD RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
								LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
								LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);


private:
	BOOL LoadApi(LPSTR, FARPROC*);

	HINSTANCE m_hInst;
	HINSTANCE m_hInst2;

	PFNRASENUMDEVICES m_fnRasEnumDeviecs;
	PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
	PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
	PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
};

#ifndef WIN16
inline BOOL IsNT(void)
{
	OSVERSIONINFO  OsVersionInfo;

	ZeroMemory(&OsVersionInfo, sizeof(OSVERSIONINFO));
	OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&OsVersionInfo);
	return (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\phbkex.h ===
#ifndef _PHBKEX
#define _PHBKEX

#define TYPE_SIGNUP_ANY            0x82
#define TYPE_SIGNUP_TOLLFREE    0x83
#define TYPE_SIGNUP_TOLL        0x82
#define TYPE_REGULAR_USAGE        0x42

#define MASK_SIGNUP_ANY            0xB2
#define MASK_SIGNUP_TOLLFREE    0xB3
#define MASK_SIGNUP_TOLL        0xB3
#define MASK_REGULAR_USAGE        0x73

#define cbAreaCode    6            // maximum number of characters in an area code, not including \0
#define cbCity 19                // maximum number of chars in city name, not including \0
#define cbAccessNumber 15        // maximum number of chars in phone number, not including \0
#define cbStateName 31             // maximum number of chars in state name, not including \0
                                // check this against state.pbk delivered by mktg
#define cbBaudRate 6            // maximum number of chars in a baud rate, not including \0
#define cbDataCenter 12            // max length of data center string

typedef struct
{
    DWORD    dwIndex;                                // index number
    BYTE    bFlipFactor;                            // for auto-pick
    BYTE    fType;                                    // phone number type
    WORD    wStateID;                                // state ID
    DWORD    dwCountryID;                            // TAPI country ID
    DWORD    dwAreaCode;                                // area code or NO_AREA_CODE if none
    DWORD    dwConnectSpeedMin;                        // minimum baud rate
    DWORD    dwConnectSpeedMax;                        // maximum baud rate
    TCHAR   szCity[cbCity + sizeof('\0')];            // city name
    TCHAR   szAccessNumber[cbAccessNumber + sizeof('\0')];    // access number
    TCHAR   szDataCenter[cbDataCenter + sizeof('\0')];                // data center access string
    TCHAR   szAreaCode[cbAreaCode + sizeof('\0')];                    //Keep the actual area code string around.
} ACCESSENTRY, FAR  *PACCESSENTRY;     // ae

typedef struct tagSUGGESTIONINFO
{
    DWORD    dwCountryID;
    DWORD    wAreaCode;
    DWORD    wExchange;
    WORD    wNumber;
    BYTE    fType;
    BYTE    bMask;
    PACCESSENTRY *rgpAccessEntry;
} SUGGESTINFO,FAR *PSUGGESTINFO;

#endif _PHBKEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\suapi.cpp ===
// ############################################################################
#include "pch.hpp" 
#include "phbk.h"
#include "debug.h"
#include "phbkrc.h"
#include "misc.h"
#ifdef WIN16
#include <win16def.h>
#include <rasc.h>
#include <raserr.h>
#include <ctl3d.h>
#define MB_SETFOREGROUND     0
#else
//#include "ras.h"
#include <ras.h>
#endif
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "suapi.h"
#include "rnaapi.h" //pick this up to get IsNT

#define ERROR_USER_EXIT 0x8b0bffff
#define MB_MYERROR (MB_APPLMODAL | MB_ICONERROR | MB_SETFOREGROUND)

#ifdef WIN16
#define NOTIFY_CODE (HIWORD(lParam))
#else
#define NOTIFY_CODE (HIWORD(wParam))
#endif

#define WM_SHOWSTATEMSG WM_USER+1

TCHAR szTemp[100];

TCHAR szValidPhoneCharacters[] = {TEXT("0123456789AaBbCcDdPpTtWw!@$ -.()+*#,&\0")};

//+---------------------------------------------------------------------------
//
//    Function:    ProcessDBCS
//
//    Synopsis:    Converts control to use DBCS compatible font
//                Use this at the beginning of the dialog procedure
//    
//                Note that this is required due to a bug in Win95-J that prevents
//                it from properly mapping MS Shell Dlg.  This hack is not needed
//                under winNT.
//
//    Arguments:    hwnd - Window handle of the dialog
//                cltID - ID of the control you want changed.
//
//    Returns:    ERROR_SUCCESS
// 
//    History:    4/31/97 a-frankh    Created
//                5/13/97    jmazner        Stole from CM to use here
//----------------------------------------------------------------------------
void ProcessDBCS(HWND hDlg, int ctlID)
{
#if defined(WIN16)
    return;
#else
    HFONT hFont = NULL;

    if( IsNT() )
    {
        return;
    }

    hFont = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
    if (hFont == NULL)
        hFont = (HFONT) GetStockObject(SYSTEM_FONT);
    if (hFont != NULL)
        SendMessage(GetDlgItem(hDlg,ctlID), WM_SETFONT, (WPARAM) hFont, MAKELPARAM(TRUE, 0));
#endif
}

// ############################################################################
BOOL CSelectNumDlg::FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE)
{
    LPIDLOOKUPELEMENT pIDLookUp;
    IDLOOKUPELEMENT LookUpTarget;
    CPhoneBook far *pcPBTemp;
    PACCESSENTRY pAE = NULL, pAELast = NULL;
    DWORD dwCountryID;

    pcPBTemp = ((CPhoneBook far*)m_dwPhoneBook);

    LookUpTarget.dwID = pLCE->dwCountryID;

    pIDLookUp = NULL;
    pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&LookUpTarget,pcPBTemp->m_rgIDLookUp,
        (int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);

    if (!pIDLookUp) return FALSE; // no such country

    pAE = pIDLookUp->pFirstAE;
    if (!pAE) return FALSE; // no phone numbers at all

    dwCountryID = pAE->dwCountryID;

    pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
    while (pAELast > pAE && 
           pAE->dwCountryID == dwCountryID)
    {
        if ((pAE->fType & m_bMask) == m_fType)
            return TRUE;
        pAE++;
    }
    return FALSE; // no phone numbers of the right type

//    return ((BOOL)(pIDLookUp->pFirstAE));
}

// ############################################################################
LRESULT CSelectNumDlg::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT lResult)
{
    LRESULT lRet = TRUE;
    unsigned int idx;
    int iCurIndex;
    int iLastIndex;
    PACCESSENTRY pAE = NULL;
    LPTSTR p, p2;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        CPhoneBook far *pcPBTemp;
        pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
        m_hwndDlg = hwndDlg;

        // figure out if we are in the middle of an AUTODIAL
        //

        if (m_dwFlags & AUTODIAL_IN_PROGRESS)
        {
            EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),FALSE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
        } else if (m_dwFlags& DIALERR_IN_PROGRESS){
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSIGNUP),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_CMDBACK),SW_HIDE);
            SetDlgItemText(m_hwndDlg,IDC_CMDNEXT,GetSz(IDS_OK));
        }else {
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLAUTODIAL),SW_HIDE);
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLDIALERR),SW_HIDE);
        }

        //
        // Set up fields to handle DBCS chars on win95-J
        ProcessDBCS(m_hwndDlg, IDC_LBLCOUNTRY);
        ProcessDBCS(m_hwndDlg, IDC_CMBCOUNTRY);
        ProcessDBCS(m_hwndDlg, IDC_CMBREGION);

        // Fill in country list and select current country
        //

        iCurIndex = -1;        // 0xFFFFFFFF
        // NOTE: it might be nice for INTL testing purposes to fill this combo box with
        // a list sorted by the country ID instead of the country name.
        for (idx=0;idx<pcPBTemp->m_pLineCountryList->dwNumCountries;idx++)
        {
            if (FHasPhoneNumbers(pcPBTemp->m_rgNameLookUp[idx].pLCE))
            {
                wsprintf(szTemp,TEXT("%s (%ld)"),
                            pcPBTemp->m_rgNameLookUp[idx].psCountryName,
                            pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
                iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,
                                                        CB_ADDSTRING,0,
                                                        (LPARAM)((LPTSTR) &szTemp[0]));
                SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETITEMDATA,
                                    (WPARAM)iLastIndex,
                                    (LPARAM)pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID);
                if (pcPBTemp->m_rgNameLookUp[idx].pLCE->dwCountryID == m_dwCountryID)
                {
                    iCurIndex = iLastIndex;
                }
            }
        }

        if (iCurIndex != -1)    // 0xFFFFFFFF
        {
            SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,(WPARAM)iCurIndex,0);
        } else {
            SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_SETCURSEL,0,0);
            iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,0,0);
            if (iCurIndex != CB_ERR) m_dwCountryID = iCurIndex;
        }

        // Copy country to label
        //
        if (GetDlgItemText(m_hwndDlg,IDC_CMBCOUNTRY,szTemp,100))
        {
            SetDlgItemText(m_hwndDlg,IDC_LBLCOUNTRY,szTemp);
        }

        // Initialize Last Selection Method
        //

        m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
        m_dwFlags |= PHONELIST_SELECTION_METHOD;

        // Fill in region list and select current region
        //
        FillRegion();

        // Fill in phone numbers
        //
        FillNumber();

        SetFocus(GetDlgItem(m_hwndDlg,IDC_CMBCOUNTRY));
        lRet = FALSE;
        break;
    case WM_SHOWSTATEMSG:
        if (wParam)
        {
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_SHOW);
        } else {
            ShowWindow(GetDlgItem(m_hwndDlg,IDC_LBLSTATEMSG),SW_HIDE);
        }
        break;
        // 1/9/96 jmazner  added for Normandy #13185
    case WM_CLOSE:
        if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
        {
            if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                EndDialog(hwndDlg,IDC_CMDCANCEL);
        } else {
            EndDialog(hwndDlg,IDC_CMDCANCEL);
        }
        break;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
            case IDC_CMBCOUNTRY:
                if (NOTIFY_CODE == CBN_SELCHANGE)
                {
                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETCURSEL,0,0);
                    if (iCurIndex == CB_ERR) break;

                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBCOUNTRY,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    if (iCurIndex == CB_ERR) break;
                    m_dwCountryID = iCurIndex;  //REVIEW: data type????

                    FillRegion();
                    m_wRegion = 0;

                    FillNumber();
                }
                break;
            case IDC_CMBREGION:
                if (NOTIFY_CODE == CBN_SELCHANGE)
                {
                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETCURSEL,0,0);
                    if (iCurIndex == CB_ERR) break;

                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    if (iCurIndex == CB_ERR) break;
                     m_wRegion = (USHORT)iCurIndex; //REVIEW: data type???

                    FillNumber();
                }
                break;
            case IDC_CMBNUMBER:
                if ((NOTIFY_CODE == CBN_SELCHANGE) || (NOTIFY_CODE == CBN_DROPDOWN))
                {
                    //iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
                    //if (iCurIndex == CB_ERR) break;

                    EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);

                    //iCurIndex = SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    //if (iCurIndex == CB_ERR) break;
                    //if (!lstrcpy(&m_szDunFile[0],&((PACCESSENTRY)iCurIndex)->szDataCenter[0]))
                    //{
                    //    AssertMsg(0,"Failed to copy data center from AE\n");
                    //    break;
                    //}

                    // Set Last Selection Method
                    //

                    m_dwFlags &= (~FREETEXT_SELECTION_METHOD);
                    m_dwFlags |= PHONELIST_SELECTION_METHOD;

                } else if (NOTIFY_CODE == CBN_EDITCHANGE) {

                    if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,WM_GETTEXTLENGTH,0,0))
                    {
                        EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
                    } else {
                        EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
                    }

                    // Set Last Selection Method
                    //

                    m_dwFlags &= (~PHONELIST_SELECTION_METHOD);
                    m_dwFlags |= FREETEXT_SELECTION_METHOD;
                }

                break;
            case IDC_CMDNEXT:
                if ((m_dwFlags & PHONELIST_SELECTION_METHOD) == PHONELIST_SELECTION_METHOD)
                {
                    DWORD_PTR dwItemData;

                    iCurIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETCURSEL,0,0);
                    if (iCurIndex == CB_ERR) break;

                    dwItemData = (DWORD_PTR)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_GETITEMDATA,(WPARAM)iCurIndex,0);
                    if (iCurIndex == CB_ERR) break;

                    // Get the relavant information out of the AE structures
                    //

                    pAE = (PACCESSENTRY)dwItemData;
                    ((CPhoneBook far *)m_dwPhoneBook)->GetCanonical(pAE,m_szPhoneNumber);
                    lstrcpy(m_szDunFile,pAE->szDataCenter);
                } else {

                    // Parse the text that the user entered
                    //

                    if (GetDlgItemText(m_hwndDlg,IDC_CMBNUMBER,m_szPhoneNumber,RAS_MaxPhoneNumber))
                    {
                        m_szPhoneNumber[RAS_MaxPhoneNumber] = '\0';
                        for (p = m_szPhoneNumber;*p && *p != ':';p++);
                        if (*p)
                        {
                            *p = '\0';
                            p++;
                            lstrcpy(m_szDunFile,p);
                        } else {
                            m_szDunFile[0] = '\0';
                        }

                        // Check that the phone number on contains valid characters
                        //

                        for (p = m_szPhoneNumber;*p;p++)
                        {
                            for(p2 = szValidPhoneCharacters;*p2;p2++)
                            {
                                if (*p == *p2)
                                    break; // p2 for loop
                            }
                            if (!*p2) break; // p for loop
                        }

                        if (*p)
                        {
                            MessageBox(m_hwndDlg,GetSz(IDS_INVALIDPHONE),GetSz(IDS_TITLE),MB_MYERROR);
                            //MsgBox(IDS_INVALIDPHONE,MB_MYERROR);
                            break; // switch statement
                        }
                    } else {
                        AssertMsg(0,"You should never be able to hit NEXT with nothing in the phone number.\n");
                    }
                }
                EndDialog(m_hwndDlg,IDC_CMDNEXT);
                break;
            case IDC_CMDCANCEL:
                if ((m_dwFlags & (AUTODIAL_IN_PROGRESS|DIALERR_IN_PROGRESS)) == 0) 
                {
                    if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                        MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                        EndDialog(hwndDlg,IDC_CMDCANCEL);
                } else {
                    EndDialog(hwndDlg,IDC_CMDCANCEL);
                }
            break;
                EndDialog(m_hwndDlg,IDC_CMDCANCEL);
                break;
            case IDC_CMDBACK:
                EndDialog(m_hwndDlg,IDC_CMDBACK);
                break;
        }
    default:
        lRet = FALSE;
        break;
    }// switch

    return lRet;
}

// ############################################################################
/***** 1/9/96  jmazner  Normandy #13185
CAccessNumDlg::CAccessNumDlg()
{
    m_szDunPrimary[0] = '\0';
    m_szDunSecondary[0] = '\0';
    m_szPrimary[0] = '\0';
    m_szSecondary[0] = '\0';
    m_rgAccessEntry = NULL;
    m_wNumber = 0;
    m_dwPhoneBook=0;
}
*********/

// ############################################################################
/********* 1/9/96 jmazner  Normandy #13185
                           This was dead code, unused anywhere in icwphbk
LRESULT CAccessNumDlg::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                        LRESULT lResult)
{
    LRESULT lRet = TRUE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);
        SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,EM_SETLIMITTEXT,RAS_MaxPhoneNumber,0);

/ *
        // turn AccessEntries into phone numbers
        if(m_szPrimary[0] == '\0')
        {
            LPIDLOOKUPELEMENT pIDLookUp;
            CPhoneBook *pcPBTemp;
            pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);

            AssertMsg(m_dwPhoneBook,"No phonebook set");

            //For the primary phone number
            pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
                pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
                sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
            SzCanonicalFromAE (m_szPrimary, m_rgAccessEntry[0], pIDLookUp->pLCE);

            if (m_rgAccessEntry[1])
            {
                if (m_rgAccessEntry[0]->dwCountryID != m_rgAccessEntry[1]->dwCountryID)
                {
                    pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(&m_rgAccessEntry[0]->dwCountryID,
                        pcPBTemp->m_rgIDLookUp,pcPBTemp->m_pLineCountryList->dwNumCountries,
                        sizeof(IDLOOKUPELEMENT),CompareIdxLookUpElements);
                }
                SzCanonicalFromAE (m_szSecondary, m_rgAccessEntry[1], pIDLookUp->pLCE);
            }
        }
* /
        SendDlgItemMessage(hwnd,IDC_TXTPRIMARY,WM_SETTEXT,0,(LPARAM)&m_szPrimary[0]);
        SendDlgItemMessage(hwnd,IDC_TXTSECONDARY,WM_SETTEXT,0,(LPARAM)&m_szSecondary[0]);
        break;

        
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CMDOK:
            // Check that we have at least one phone number
            // Leave dialog
            GetDlgItemText(hwnd,IDC_TXTPRIMARY,&m_szPrimary[0],RAS_MaxPhoneNumber);
            GetDlgItemText(hwnd,IDC_TXTSECONDARY,&m_szSecondary[0],RAS_MaxPhoneNumber);

            if (m_szPrimary[0])
                m_wNumber=1;
            else
                m_wNumber=0;

            if (m_szSecondary[0])
                m_wNumber++;

            EndDialog(hwnd,IDC_CMDOK);
            break;
        case IDC_CMDEXIT:
            // Verify with user
            // Get out of Dodge
            if (MessageBox(hwnd,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
                MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
                EndDialog(hwnd,IDC_CMDEXIT);
            break;
        case IDC_CMDCHANGEPRIMARY:
            // hide dialog
            ShowWindow(hwnd,SW_HIDE);
            // show new dialog
            CSelectNumDlg far *pcSelectNumDlg;
            pcSelectNumDlg = new CSelectNumDlg;
            if (!pcSelectNumDlg)
            {
                MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//                MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
                ShowWindow(hwnd,SW_SHOW);
                break;
            }
            int irc;
            pcSelectNumDlg->m_dwPhoneBook = m_dwPhoneBook;
            pcSelectNumDlg->m_dwCountryID = m_dwCountryID;
            pcSelectNumDlg->m_wRegion = m_wRegion;
            irc = DialogBoxParam(g_hInstDll,MAKEINTRESOURCE(IDD_SELECTNUMBER),
                                    g_hWndMain,PhbkGenericDlgProc,
                                    (LPARAM)pcSelectNumDlg);
            ShowWindow(hwnd,SW_SHOW);
            switch (irc)
            {
                case -1:
                    MessageBox(hwnd,GetSz(IDS_NOTENOUGHMEMORY),GetSz(IDS_TITLE),MB_MYERROR);
//                    MsgBox(IDS_NOTENOUGHMEMORY,MB_MYERROR);
                    goto DlgProcExit;
                    // break;
                case IDC_CMDOK:
                    m_dwCountryID = pcSelectNumDlg->m_dwCountryID;
                    m_wRegion = pcSelectNumDlg->m_wRegion;
                    lstrcpy(m_szDunPrimary,pcSelectNumDlg->m_szDunFile);
                    SetDlgItemText(hwnd,IDC_TXTPRIMARY,pcSelectNumDlg->m_szPhoneNumber);
                    break;
            }
            break;
        }
        break;
    default:
        lRet = FALSE;
        break;
    }
DlgProcExit:
    return lRet;
}

*********************/

#ifdef WIN16
// ############################################################################
// NAME: SetNonBoldDlg
//
//    Set all the child controls in a window to a non-bold version of the
//    current control font.
//
// Parameters: HWND hDlg    Handle to the dialog window
//
// Created 8/12/96    ValdonB (creatively borrowed from IE)
// ############################################################################

void
SetNonBoldDlg(HWND hDlg)
{
    HFONT hfontDlg = (HFONT) NULL;
    LOGFONT lFont;
    HWND hCtl;
    if ((hfontDlg = (HFONT) SendMessage(hDlg, WM_GETFONT, 0, 0L)))
    {
        if (GetObject(hfontDlg, sizeof(LOGFONT), (LPTSTR) &lFont))
        {
            lFont.lfWeight = FW_NORMAL;
            if (hfontDlg = CreateFontIndirect((LPLOGFONT) &lFont))
            {
                // apply the font to all the child controls
                for (hCtl = GetWindow(hDlg, GW_CHILD);
                        NULL != hCtl;
                        hCtl = GetWindow(hCtl, GW_HWNDNEXT))
                {
                    SendMessage(hCtl, WM_SETFONT, (WPARAM) hfontDlg, 0);
                }
            }
        }
    }
}


// ############################################################################
// NAME: SetNonBoldDlg
//
//     The dialog was modified earlier by unbolding the dialog font, and
//     getting each control in the dialog to use that font. This function
//     is called when the dialog is being destroyed so the font can be
//     deleted
//
// Parameters: HWND hDlg    Handle to the dialog window
//
// Created 8/12/96    ValdonB (creatively borrowed from IE)
// ############################################################################

void
DeleteDlgFont
(
    HWND hDlg
)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hDlg,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
}
#endif    // WIN16


// ############################################################################
#ifdef WIN16
extern "C" BOOL CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,    // handle to dialog box
    UINT  uMsg,    // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam     // second message parameter
   )
{
#if defined(WIN16)
    RECT    MyRect;
    RECT    DTRect;
#endif
//#ifdef DEBUG
//    DebugBreak();
//#endif
    CDialog far *pcDlg = NULL;
    LRESULT lRet;
    switch (uMsg)
    {
    case WM_DESTROY:
        ReleaseBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
        break;
    case WM_INITDIALOG:
        pcDlg = (CDialog far *)lParam;
        SetWindowLongPtr(hwndDlg,DWLP_USER,lParam);
        lRet = TRUE;
#if defined(WIN16)
        //
        // Move the window to the center of the screen
        //
        GetWindowRect(hwndDlg, &MyRect);
        if (0 == MyRect.left && 0 == MyRect.top)
        {
            GetWindowRect(GetDesktopWindow(), &DTRect);
            MoveWindow(hwndDlg, (DTRect.right - MyRect.right) / 2, (DTRect.bottom - MyRect.bottom) /2,
                                MyRect.right, MyRect.bottom, FALSE);
        }
        SetNonBoldDlg(hwndDlg);
#endif
        MakeBold(GetDlgItem(hwndDlg,IDC_LBLTITLE));
        break;
#if defined(WIN16)
    case WM_SYSCOLORCHANGE:
        Ctl3dColorChange();
        break;
#endif
    // 1/9/96  jmazner Normandy #13185, moved to CSelectNumDlg::DlgProc
    //case WM_CLOSE:
    //    if (MessageBox(hwndDlg,GetSz(IDS_WANTTOEXIT),GetSz(IDS_TITLE),
    //        MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES)
    //        EndDialog(hwndDlg,IDC_CMDCANCEL);
    //    lRet = TRUE;
    //    break;
//        //PostQuitMessage(0);
//        EndDialog(hwndDlg,FALSE);
//        lRet = TRUE;
//        break;
    default:
        // let the system process the message
        lRet = FALSE;
    }

    if (!pcDlg) pcDlg = (CDialog far*)GetWindowLongPtr(hwndDlg,DWLP_USER);
    if (pcDlg)
        lRet = pcDlg->DlgProc(hwndDlg,uMsg,wParam,lParam,lRet);

    return (BOOL)lRet;
}

// ############################################################################
HRESULT CSelectNumDlg::FillRegion()
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    int iCurIndex;
    int iLastIndex;
    unsigned int idx;
    CPhoneBook far *pcPBTemp;
    pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
    int iDebugIdx;
    

    //
    // 5/16/97    jmazner    Olympus #4627
    // We don't care about Toll/tollfree at this point
    //
    m_bMask &= ~MASK_TOLLFREE_BIT;
    m_fType &= ~MASK_TOLLFREE_BIT;


    // Fill in region list
    //

    SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_RESETCONTENT,0,0);
    SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)GetSz(IDS_NATIONWIDE));
    iCurIndex = -1;        // 0xFFFFFFFF;
    m_fHasRegions = FALSE;
    for (idx=0;idx<pcPBTemp->m_cStates;idx++)
    {
        if (pcPBTemp->m_rgState[idx].dwCountryID == m_dwCountryID)
        {
            PACCESSENTRY pAE = NULL, pAELast = NULL;
            pAE = pcPBTemp->m_rgState[idx].paeFirst;
            Assert(pAE);
            pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
            while (pAELast > pAE && 
                pAE->dwCountryID == m_dwCountryID &&
                pAE->wStateID == idx+1)
            {
                if ((pAE->fType & m_bMask) == m_fType)
                    goto AddRegion;
                pAE++;
            }
            continue;

AddRegion:
            m_fHasRegions = TRUE;

            iLastIndex = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_ADDSTRING,0,(LPARAM)&pcPBTemp->m_rgState[idx].szStateName[0]);
            iDebugIdx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETITEMDATA,(WPARAM)iLastIndex,(LPARAM)idx+1);
            if ((idx+1) == m_wRegion)
            {
                iCurIndex = iLastIndex;
            }
        }
    }

    // select current region or nation wide
    //

    if (iCurIndex != -1)    // 0xFFFFFFFF
    {
        SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,(WPARAM)iCurIndex,0);
    } else {
        m_wRegion = 0;    // Nationwide
        SendDlgItemMessage(m_hwndDlg,IDC_CMBREGION,CB_SETCURSEL,0,0);
    }

    EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMBREGION),m_fHasRegions);
    PostMessage(m_hwndDlg,WM_SHOWSTATEMSG,m_fHasRegions,0);

    hr = ERROR_SUCCESS;
    return hr;
}

// ############################################################################
CSelectNumDlg::CSelectNumDlg()
{
    m_dwCountryID = 0;
    m_wRegion = 0;
    m_dwPhoneBook = 0;
    m_szPhoneNumber[0] = '\0';
    m_szDunFile[0] = '\0';
    m_fType = 0;
    m_bMask = 0;
    m_fHasRegions = FALSE;
    m_hwndDlg = NULL;
    m_dwFlags = 0;
}

// ############################################################################
HRESULT CSelectNumDlg::FillNumber()
{
    HRESULT hr = ERROR_NOT_ENOUGH_MEMORY;
    PACCESSENTRY pAELast, pAE = NULL;
    PACCESSENTRY pAETemp = NULL;
    CPhoneBook far *pcPBTemp;
    unsigned int idx;
    pcPBTemp = ((CPhoneBook far *)m_dwPhoneBook);
    
    // Check if we need to look up the number from the region or from the country
    //

    if (m_fHasRegions && m_wRegion)
        pAE = pcPBTemp->m_rgState[m_wRegion-1].paeFirst;
    

    // Find the Access Entries for the country
    //

    if (!pAE)
    {
        LPIDLOOKUPELEMENT pIDLookUp, pLookUpTarget;

        pLookUpTarget = (LPIDLOOKUPELEMENT)GlobalAlloc(GPTR,sizeof(IDLOOKUPELEMENT));
        Assert(pLookUpTarget);
        if (!pLookUpTarget) goto FillNumberExit;
        pLookUpTarget->dwID = m_dwCountryID;

        pIDLookUp = NULL;
        pIDLookUp = (LPIDLOOKUPELEMENT)bsearch(pLookUpTarget,pcPBTemp->m_rgIDLookUp,
            (int)pcPBTemp->m_pLineCountryList->dwNumCountries,sizeof(IDLOOKUPELEMENT),CompareIDLookUpElements);
        if (pIDLookUp)
            pAE = pIDLookUp->pFirstAE;
    }

    // Fill the list for whatever AE's we found
    //
    
    SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_RESETCONTENT,0,0);
    if (pAE)
    {
        //pAELast = pcPBTemp->m_rgPhoneBookEntry + pcPBTemp->m_cPhoneBookEntries;

        //
        // first time only get the toll numbers
        // MKarki (5/12/97) - Fix for Bug#71
        //

        
        m_bMask |= MASK_TOLLFREE_BIT;
        m_fType &= TYPE_SET_TOLL;
    
        //
        // save the start of the list as we will need to traverse
        // again later
        //
        pAETemp = pAE;
        pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
        while (pAELast > pAE && pAE->dwCountryID == m_dwCountryID && pAE->wStateID == m_wRegion)
        {
            if ((pAE->fType & m_bMask) == m_fType)
            {
                wsprintf(szTemp,TEXT("%s (%s) %s"),pAE->szCity,pAE->szAreaCode,
                            pAE->szAccessNumber);
                idx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,
                                                CB_ADDSTRING,0,
                                                (LPARAM)((LPTSTR) &szTemp[0]));
                if (idx == -1) goto FillNumberExit;
                SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETITEMDATA,
                                    (WPARAM)idx,(LPARAM)pAE);
            }
            pAE++;
        }
        



        //
        // now get the toll free numbers
        // MKarki (5/12/97) - Fix for Bug#71
        //

        m_bMask |= MASK_TOLLFREE_BIT;
        m_fType |= TYPE_SET_TOLLFREE;
        pAE = pAETemp;
        pAELast = &(pcPBTemp->m_rgPhoneBookEntry[pcPBTemp->m_cPhoneBookEntries - 1]);
        while (pAELast > pAE && pAE->dwCountryID == m_dwCountryID && pAE->wStateID == m_wRegion)
        {
            if ((pAE->fType & m_bMask) == m_fType)
            {
                wsprintf(szTemp,TEXT("%s (%s) %s"),pAE->szCity,pAE->szAreaCode,
                            pAE->szAccessNumber);
            idx = (int)SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,
                                                CB_ADDSTRING,0,
                                                (LPARAM)((LPTSTR) &szTemp[0]));
                if (idx == -1) goto FillNumberExit;
                SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETITEMDATA,
                                    (WPARAM)idx,(LPARAM)pAE);
            }
            pAE++;
        }



        // Select the first item
        //

        if (SendDlgItemMessage(m_hwndDlg,IDC_CMBNUMBER,CB_SETCURSEL,0,0) == CB_ERR)
                EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),FALSE);
        else
                EnableWindow(GetDlgItem(m_hwndDlg,IDC_CMDNEXT),TRUE);
        hr = ERROR_SUCCESS;
    }
FillNumberExit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\rnaapi.cpp ===
//-----------------------------------------------------------------------------
// RNAAPI class
// 
// This class provides a series of cover function for the RNAPH/RASAPI32 dlls
//
// Created 1-29-96	ChrisK

// ############################################################################
// INCLUDES
#include "pch.hpp"
//#include "ras.h"
#ifdef WIN16
#include <win16def.h>
#include <rasc.h>
#include <raserr.h>
#else
#include <ras.h>
#endif
#pragma pack (4)
//#if !defined(WIN16)
//#include <rnaph.h>
//#endif
#pragma pack ()
#include "rnaapi.h"
#include "debug.h"

// ############################################################################
// RNAAPI class 
CRNAAPI::CRNAAPI()
{
#if defined WIN16
    m_hInst = LoadLibrary ("RAS16IE.DLL");
    m_hInst2 = NULL;
#else
	m_hInst = LoadLibrary(TEXT("RASAPI32.DLL"));
	
    if (FALSE == IsNT ())
    {
        //
        // we only load RNAPH.DLL if it is not NT
        // MKarki (5/4/97) - Fix for Bug #3378
        //
	    m_hInst2 = LoadLibrary(TEXT("RNAPH.DLL"));
    }
    else
    {
        m_hInst2 =  NULL;
    }
#endif
	m_fnRasEnumDeviecs = NULL;
	m_fnRasValidateEntryName = NULL;
	m_fnRasSetEntryProperties = NULL;
	m_fnRasGetEntryProperties = NULL;
}

// ############################################################################
CRNAAPI::~CRNAAPI()
{
	// Clean up
	if (m_hInst) FreeLibrary(m_hInst);
	if (m_hInst2) FreeLibrary(m_hInst2);
}

// ############################################################################
DWORD CRNAAPI::RasEnumDevices(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb,
							 LPDWORD lpcDevices)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasEnumDevices",(FARPROC*)&m_fnRasEnumDeviecs);

	if (m_fnRasEnumDeviecs)
		dwRet = (*m_fnRasEnumDeviecs) (lpRasDevInfo, lpcb, lpcDevices);

	return dwRet;
}

// ############################################################################
BOOL CRNAAPI::LoadApi(LPSTR pszFName, FARPROC* pfnProc)
{
	if (*pfnProc == NULL)
	{
		// Look for the entry point in the first DLL
		if (m_hInst)
			*pfnProc = GetProcAddress(m_hInst,pszFName);
		
		// if that fails, look for the entry point in the second DLL
		if (m_hInst2 && !(*pfnProc))
			*pfnProc = GetProcAddress(m_hInst2,pszFName);
	}

	return (pfnProc != NULL);
}

// ############################################################################
DWORD CRNAAPI::RasValidateEntryName(LPTSTR lpszPhonebook,LPTSTR lpszEntry)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasValidateEntryName",(FARPROC*)&m_fnRasValidateEntryName);

	if (m_fnRasValidateEntryName)
		dwRet = (*m_fnRasValidateEntryName) (lpszPhonebook, lpszEntry);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize,
									LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasSetEntryProperties",(FARPROC*)&m_fnRasSetEntryProperties);

	if (m_fnRasSetEntryProperties)
		dwRet = (*m_fnRasSetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, dwEntryInfoSize,
									lpbDeviceInfo, dwDeviceInfoSize);

	return dwRet;
}

// ############################################################################
DWORD CRNAAPI::RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
									LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize,
									LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize)
{
	DWORD dwRet = ERROR_DLL_NOT_FOUND;

	// Look for the API if we haven't already found it
	LoadApi("RasGetEntryProperties",(FARPROC*)&m_fnRasGetEntryProperties);

	if (m_fnRasGetEntryProperties)
		dwRet = (*m_fnRasGetEntryProperties) (lpszPhonebook, lpszEntry,
									lpbEntryInfo, lpdwEntryInfoSize,
									lpbDeviceInfo, lpdwDeviceInfoSize);

	return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\suapi.h ===
// ############################################################################
//#include "ras.h"
#define cbDataCenter (MAX_PATH+1)    // max length of data center string

// ############################################################################
class CDialog
{
public:
    void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
    void operator delete( void far * p ) {GlobalFree(p); };

    CDialog() {};
    ~CDialog() {};
    virtual LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT)=0;
};

// ############################################################################
class CSelectNumDlg : public CDialog
{
public:
    CSelectNumDlg();
    LRESULT DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
    DWORD m_dwCountryID;
    DWORD m_dwCountryIDOrg;
    WORD m_wRegion;
    DWORD_PTR m_dwPhoneBook;
    TCHAR m_szPhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR m_szDunFile[cbDataCenter];
    BYTE m_fType;
    BYTE m_bMask;
    DWORD m_dwFlags;
private:
    BOOL FHasPhoneNumbers(LPLINECOUNTRYENTRY pLCE);
    BOOL m_fHasRegions;
    HWND m_hwndDlg;
    HRESULT FillRegion();
    HRESULT FillNumber();
};

// ############################################################################
/********** 1/9/96 jmazner Normandy #13185
class CAccessNumDlg : public CDialog
{
public:
    CAccessNumDlg();
    ~CAccessNumDlg() {};
    LRESULT            DlgProc(HWND, UINT, WPARAM, LPARAM, LRESULT);
    DWORD            m_dwPhoneBook;
    PACCESSENTRY    *m_rgAccessEntry;
    WORD            m_wNumber;
    DWORD            m_dwCountryID;
    WORD            m_wRegion;
    BYTE            m_fType;
    BYTE            m_bMask;
    TCHAR    m_szPrimary[RAS_MaxPhoneNumber];
    TCHAR    m_szSecondary[RAS_MaxPhoneNumber];
    TCHAR    m_szDunPrimary[cbDataCenter + sizeof('\0')];
    TCHAR    m_szDunSecondary[cbDataCenter + sizeof('\0')];
};    
**************/

// ############################################################################
#ifdef WIN16
extern "C" BOOL CALLBACK __export PhbkGenericDlgProc(
#else
extern "C" __declspec(dllexport) INT_PTR CALLBACK PhbkGenericDlgProc(
#endif
    HWND  hwndDlg,    // handle to dialog box
    UINT  uMsg,    // message
    WPARAM  wParam,    // first message parameter
    LPARAM  lParam     // second message parameter
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwphbk

MAJORCOMP=GETCONN
MINORCOMP=ICWPHBK

TARGETNAME=ICWPHBK
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=PHBKDllEntryPoint
DLLBASE=0x60000000
DLLDEF=..\icwphbk.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

SOURCES=                \
    ..\icwphbk.rc       \
    ..\ccsv.cpp         \
    ..\main.cpp         \
    ..\misc.cpp         \
    ..\phbk.cpp         \
    ..\rnaapi.cpp       \
    ..\suapi.cpp        \
    ..\icwsupport.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\gdi32.lib         \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib
!endif

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\win32fn.c ===
#include "pch.h"
#include <win16def.h>
#include <win32fn.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>

//extern LPSTR g_lpszCmdLine;   

HANDLE CreateFile(
    LPCTSTR lpFileName,	// pointer to name of the file 
    DWORD dwDesiredAccess,	// access (read-write) mode 
    DWORD dwShareMode,	// share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,	// pointer to security descriptor 
    DWORD dwCreationDistribution,	// how to create 
    DWORD dwFlagsAndAttributes,	// file attributes 
    HANDLE hTemplateFile 	// handle to file with attributes to copy  
   )
{
	int oflag = 0, pmode = 0, iHandle = -1;
	
    if ((dwDesiredAccess & GENERIC_READ) && (dwDesiredAccess & GENERIC_WRITE))
    	oflag = _O_RDWR;
    else if (dwDesiredAccess & GENERIC_WRITE)
    	oflag = _O_WRONLY;
    else
    	oflag = _O_RDONLY;							 
    
    switch (dwCreationDistribution)
    {
    	case CREATE_NEW:
    		oflag |= (_O_CREAT | _O_EXCL);
    		break;
    	case CREATE_ALWAYS:
    	case TRUNCATE_EXISTING:
    		oflag |= _O_TRUNC;
    		break;
    	case OPEN_ALWAYS:
    		oflag |= _O_CREAT;
    }
    
    if (dwShareMode & FILE_SHARE_READ)
    	pmode |= _S_IREAD;
    if (dwShareMode & FILE_SHARE_WRITE)
    	pmode |= _S_IWRITE;
	
	iHandle = _open(lpFileName, oflag, pmode);
	if (-1 == iHandle)
		return (HANDLE) INVALID_HANDLE_VALUE;
	else
		return (HANDLE) iHandle;
}


BOOL WriteFile(
    HANDLE hFile,	// handle to file to write to 
    LPCVOID lpBuffer,	// pointer to data to write to file 
    DWORD nNumberOfBytesToWrite,	// number of bytes to write 
    LPDWORD lpNumberOfBytesWritten,	// pointer to number of bytes written 
    LPOVERLAPPED lpOverlapped 	// pointer to structure needed for overlapped I/O
   )
{
	*lpNumberOfBytesWritten = (DWORD) _write(hFile, lpBuffer, 
												(unsigned int)nNumberOfBytesToWrite);
	return (*lpNumberOfBytesWritten == nNumberOfBytesToWrite);
}    


BOOL MoveFileEx(
    LPCTSTR lpExistingFileName,	// address of name of the existing file  
    LPCTSTR lpNewFileName,	// address of new name for the file 
    DWORD dwFlags 	// flag to determine how to move file 
   )
{
	//
	// BUGBUG: Try renaming first and then delete file
	//
	if (dwFlags & MOVEFILE_REPLACE_EXISTING)
	{
		if (_access(lpNewFileName, 0) == 0)
			remove(lpNewFileName);
	}
	
	return (rename(lpExistingFileName, lpNewFileName) == 0);
}
   


BOOL CloseHandle(
    HANDLE hObject 	// handle to object to close  
   )
{
	// We should check if this is really a file hande...
	
	return (!_close(hObject));
}



#if 0
DWORD SearchPath(
    LPCTSTR lpPath,	// address of search path 
    LPCTSTR lpFileName,	// address of filename 
    LPCTSTR lpExtension,	// address of extension 
    DWORD nBufferLength,	// size, in characters, of buffer 
    LPTSTR lpBuffer,	// address of buffer for found filename 
    LPTSTR far *lpFilePart 	// address of pointer to file component 
   )
{
	LPSTR pszPath;
	LPSTR pszFile;
	LPSTR pEnv;
	int len = 0, prevlen;
    
	pszPath = (LPSTR)_fcalloc(1, MAX_PATH*3);
	pszFile = (LPSTR)_fcalloc(1, MAX_PATH);

    //
    // Create an environment variable for searchenv to use.
    //
    strcpy(pszPath, ICW_PATH);
    strcat(pszPath, "=");
    len = strlen(pszPath);
	if (NULL == lpPath)
	{	
		//
		// Directory from which the application laoded
		//
/*		prevlen = len;
		_fstrcpy(szPath+len, g_lpszCmdLine);
		for ( ; szPath[len] != ' ' && szPath[len] != '\0'; len++) ;
		for ( ; len > prevlen+1 && szPath[len] != '\\'; len--) ;
		szPath[len++] = ';';
*/		
		//
		// Windows system directory
		//
	    len += GetSystemDirectory(pszPath+len, MAX_PATH);
	    pszPath[len++] = ';';
	    
	    //
	    // Windows directory
	    //
	    len += GetWindowsDirectory(pszPath+len, MAX_PATH);
	    
	    //
	    // PATH environment variable
	    //
	    if ((pEnv = getenv("PATH")) != NULL)
	    {
	    	pszPath[len++] = ';';
	    	for ( ; *pEnv; pEnv++) pszPath[len++] = *pEnv;
	    }
    	pszPath[len] = '\0';
	}
	else
	{
		lstrcpy(pszPath+len, lpPath);
	}
	
	//
	// Set the environment variable so _searchenv can use it
	//
	_putenv(pszPath);
	
	//
	// Append the extension to the file, if necessary
	//
	lstrcpy(pszFile, lpFileName);
	len = lstrlen(pszFile);
	if ((pszFile[len] != '.') && (lpExtension != NULL))
		lstrcat(pszFile, lpExtension);
		
    _searchenv(pszFile, ICW_PATH, lpBuffer);
	                
	//
	// Clear the temporary environment variable before freeing the memory
	//
	lstrcpy(pszFile, ICW_PATH);
	lstrcat(pszFile, "=");
	_putenv(pszFile);

	_ffree(pszFile);
	_ffree(pszPath);
	
	return (lstrlen(lpBuffer));
}

#endif //0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwphbk\win32fn.h ===
#ifndef _WIN32FN_H_

#define _WIN32FN_H_

#include <win16def.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Defines for 32-bit file io
// 
//#define INVALID_HANDLE_VALUE			-1

#define GENERIC_READ                     (0x80000000L)
#define GENERIC_WRITE                    (0x40000000L)
#define GENERIC_EXECUTE                  (0x20000000L)
#define GENERIC_ALL                      (0x10000000L)

#define FILE_FLAG_WRITE_THROUGH         0x80000000
#define FILE_FLAG_OVERLAPPED            0x40000000
#define FILE_FLAG_NO_BUFFERING          0x20000000
#define FILE_FLAG_RANDOM_ACCESS         0x10000000
#define FILE_FLAG_SEQUENTIAL_SCAN       0x08000000
#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000
#define FILE_FLAG_BACKUP_SEMANTICS      0x02000000
#define FILE_FLAG_POSIX_SEMANTICS       0x01000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#define FILE_SHARE_READ                 0x00000001  
#define FILE_SHARE_WRITE                0x00000002  
#define FILE_SHARE_DELETE               0x00000004  

#define MOVEFILE_REPLACE_EXISTING		0x00000001
#define MOVEFILE_COPY_ALLOWED			0x00000002
#define MOVEFILE_DELAY_UNTIL_REBOOT		0x00000004
#define MOVEFILE_WRITE_THROUGH			0x00000008


	
HANDLE CreateFile(
    LPCTSTR lpFileName,	// pointer to name of the file 
    DWORD dwDesiredAccess,	// access (read-write) mode 
    DWORD dwShareMode,	// share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,	// pointer to security descriptor 
    DWORD dwCreationDistribution,	// how to create 
    DWORD dwFlagsAndAttributes,	// file attributes 
    HANDLE hTemplateFile 	// handle to file with attributes to copy  
   ); 

BOOL WriteFile(
    HANDLE hFile,	// handle to file to write to 
    LPCVOID lpBuffer,	// pointer to data to write to file 
    DWORD nNumberOfBytesToWrite,	// number of bytes to write 
    LPDWORD lpNumberOfBytesWritten,	// pointer to number of bytes written 
    LPOVERLAPPED lpOverlapped 	// pointer to structure needed for overlapped I/O
   );

BOOL MoveFileEx(
    LPCTSTR lpExistingFileName,	// address of name of the existing file  
    LPCTSTR lpNewFileName,	// address of new name for the file 
    DWORD dwFlags 	// flag to determine how to move file 
   );
   
BOOL CloseHandle(
    HANDLE hObject 	// handle to object to close  
   );


#ifdef __cplusplus
}
#endif // __cplusplus   
#endif // _WIN32FN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\icwrmind.h ===
#pragma once

LRESULT WINAPI	MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI	SignUpDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\mcreg.h ===
#pragma once
#define  STRICT
#include <windows.h>
#include <crtdbg.h>

class CMcRegistry
{
public:
	CMcRegistry();
	~CMcRegistry();

public:
	bool OpenKey(HKEY hkeyStart, LPCTSTR strKey, REGSAM sam = KEY_READ | KEY_WRITE);
	bool CreateKey(HKEY hkeyStart, LPCTSTR strKey);
	bool CloseKey();

	bool GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize);
	bool GetValue(LPCTSTR strValue, DWORD& rdw);

	bool SetValue(LPCTSTR strValue, LPCTSTR strData);
	bool SetValue(LPCTSTR strValue, DWORD rdw);

private:
	HKEY	m_hkey;
};

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\regdata.cpp ===
#define  STRICT
#include <windows.h>
#include <stdlib.h>
#include <stdarg.h>
#include <crtdbg.h>
#include <winbase.h>
#include <ras.h>
#include <time.h>
#include "icwunicd.h"
#include "RegData.h"


//-----------------------------------------------------------------------------
//  Defines
//-----------------------------------------------------------------------------
#define MAX_REGSTRING               150
#define DEFAULT_DIALOGTIMEOUT       1800000     // half hour
#define DEFAULT_SLEEPDURATION       30000       // 30 seconds


//-----------------------------------------------------------------------------
//  Global Handles and other defines
//-----------------------------------------------------------------------------
time_t g_tStartDate = 0;
int g_nISPTrialDays = 0;
int g_nTotalNotifications = -1;
DWORD g_dwDialogTimeOut = 0;
DWORD g_dwWakeupInterval = 0;
TCHAR g_szISPName[MAX_REGSTRING];
TCHAR g_szISPPhone[MAX_REGSTRING];
TCHAR g_szSignupURL[MAX_REGSTRING];
TCHAR g_szISPMsg[MAX_ISPMSGSTRING];
TCHAR g_szSignupURLTrialOver[MAX_REGSTRING];
TCHAR g_szConnectoidName[MAX_REGSTRING];


//-----------------------------------------------------------------------------
//  Registry entry strings.
//-----------------------------------------------------------------------------
static const TCHAR* g_szKeyRunOnce = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
static const TCHAR* g_szEntryRunOnce = TEXT("IcwRmind");

    // Key for IE run once stuff
static const TCHAR* g_szKeyIERunOnce = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
static const TCHAR* g_szEntryIERunOnce = TEXT("First Home Page");
static const TCHAR* g_szHtmlFile = TEXT("TrialExp.html");

    // This is the key where all the application data will be stored.
static const TCHAR* g_szKeyIcwRmind = TEXT("Software\\Microsoft\\Internet Connection Wizard\\IcwRmind");

    // These entries will be created by the connection wizard.
static const TCHAR* g_szEntryISPName = TEXT("ISP_Name");
static const TCHAR* g_szEntryISPPhone = TEXT("ISP_Phone");
static const TCHAR* g_szEntryISPMsg = TEXT("ISP_Message");
static const TCHAR* g_szEntryTrialDays = TEXT("Trial_Days");
static const TCHAR* g_szEntrySignupURL = TEXT("Signup_URL");
static const TCHAR* g_szEntrySignupURLTrialOver = TEXT("Expired_URL");
static const TCHAR* g_szEntryConnectoidName = TEXT("Entry_Name");
static const TCHAR* g_szSignupSuccessfuly = TEXT("TrialConverted");

    // These entries will be created by this application.
static const TCHAR* g_szEntryTrialStart = TEXT("Trial_Start");
static const TCHAR* g_szEntryTrialStartString = TEXT("Trial_Start_String");
static const TCHAR* g_szEntryAppIsVisible = TEXT("App_IsVisible");
static const TCHAR* g_szEntryWakeupInterval = TEXT("Wakeup_Interval");
static const TCHAR* g_szEntryTotalNotifications = TEXT("Total_Notifications");
static const TCHAR* g_szEntryDialogTimeOut = TEXT("Dialog_TimeOut");


//-----------------------------------------------------------------------------
//  GetWakeupInterval
//-----------------------------------------------------------------------------
DWORD GetWakeupInterval()
{
    if (g_dwWakeupInterval)
    {
        return g_dwWakeupInterval;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryWakeupInterval, g_dwWakeupInterval);

            // If not in the registry then set the default value.
        if (!bRetCode)
        {
            g_dwWakeupInterval = DEFAULT_SLEEPDURATION;
        }
    }

    return g_dwWakeupInterval;
}


//-----------------------------------------------------------------------------
//  GetDialogTimeout
//-----------------------------------------------------------------------------
DWORD GetDialogTimeout()
{
    if (g_dwDialogTimeOut)
    {
        return g_dwDialogTimeOut;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryDialogTimeOut, g_dwDialogTimeOut);

            // If not in the registry then set the default value.
        if (!bRetCode)
        {
            g_dwDialogTimeOut = DEFAULT_DIALOGTIMEOUT;
        }
    }

    return g_dwDialogTimeOut;
}


//-----------------------------------------------------------------------------
//  IsApplicationVisible
//-----------------------------------------------------------------------------
BOOL IsApplicationVisible()
{
        // This data is debug data so it is not cached.  Default value is 
        // FALSE if not found in registry.
    BOOL bVisible = FALSE;
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryAppIsVisible, dwData);

        if (bRetCode)
        {
            bVisible = (BOOL) dwData;
        }
    }

    return bVisible;
}


//-----------------------------------------------------------------------------
//  GetConnectionName
//-----------------------------------------------------------------------------
const TCHAR* GetISPConnectionName()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szConnectoidName))
    {
        return g_szConnectoidName;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryConnectoidName, g_szConnectoidName, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szConnectoidName;
}


//-----------------------------------------------------------------------------
//  GetISPSignupUrl
//-----------------------------------------------------------------------------
const TCHAR* GetISPSignupUrl()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szSignupURL))
    {
        return g_szSignupURL;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntrySignupURL, g_szSignupURL, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szSignupURL;
}


//-----------------------------------------------------------------------------
//  GetISPSignupUrlTrialOver
//-----------------------------------------------------------------------------
const TCHAR* GetISPSignupUrlTrialOver()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szSignupURLTrialOver))
    {
        return g_szSignupURLTrialOver;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntrySignupURLTrialOver, g_szSignupURLTrialOver, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szSignupURLTrialOver;
}


//-----------------------------------------------------------------------------
//  SetupRunOnce
//-----------------------------------------------------------------------------
void SetupRunOnce()
{
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyRunOnce);
    _ASSERT(bRetCode);

    if (bRetCode)
    {
        LPTSTR lpszFileName = new TCHAR[_MAX_PATH + 20];

        if (GetModuleFileName(GetModuleHandle(NULL), lpszFileName, _MAX_PATH + 20))
        {
                // Add a command line parameter.
            lstrcat(lpszFileName, TEXT(" -R"));
            bRetCode = reg.SetValue(g_szEntryRunOnce, lpszFileName);
            _ASSERT(bRetCode);
        }

        delete [] lpszFileName;
    }
}


//-----------------------------------------------------------------------------
//  RemoveRunOnce
//-----------------------------------------------------------------------------
void RemoveRunOnce()
{
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyRunOnce);
    _ASSERT(bRetCode);

    if (bRetCode)
    {
         bRetCode = reg.SetValue(g_szEntryRunOnce, TEXT(""));
        _ASSERT(bRetCode);
    }
}


//-----------------------------------------------------------------------------
//  GetISPName
//-----------------------------------------------------------------------------
const TCHAR* GetISPName()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szISPName))
    {
        return g_szISPName;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryISPName, g_szISPName, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szISPName;
}


//-----------------------------------------------------------------------------
//  GetISPPhone
//-----------------------------------------------------------------------------
const TCHAR* GetISPPhone()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szISPPhone))
    {
        return g_szISPPhone;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryISPPhone, g_szISPPhone, sizeof(TCHAR)*MAX_REGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szISPPhone;
}

//-----------------------------------------------------------------------------
//  GetISPMessage
//-----------------------------------------------------------------------------
const TCHAR* GetISPMessage()
{
        // If we already retrieved this then simply pass it back.
    if (lstrlen(g_szISPMsg))
    {
        return g_szISPMsg;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.GetValue(g_szEntryISPMsg, g_szISPMsg, sizeof(TCHAR)*MAX_ISPMSGSTRING);
        _ASSERT(bRetCode);
    }

    return g_szISPMsg;
}

//-----------------------------------------------------------------------------
//  GetISPTrialDays
//-----------------------------------------------------------------------------
int GetISPTrialDays()
{
        // If we already retrieved this then simply pass it back.
    if (g_nISPTrialDays)
    {
        return g_nISPTrialDays;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryTrialDays, dwData);
        _ASSERT(bRetCode);

        if (bRetCode)
        {
            g_nISPTrialDays = (int) dwData;
        }
    }

    return g_nISPTrialDays;
}


//-----------------------------------------------------------------------------
//  GetTrialStartDate
//-----------------------------------------------------------------------------
time_t GetTrialStartDate()
{
        // If we already retrieved this then simply pass it back.
    if (g_tStartDate)
    {
        return g_tStartDate;
    }

        // If the trial start date entry does not exist in the registry then
        // this is the first we have been executed so the trial start date
        // is today's date.  Put this back in the registry.
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryTrialStart, dwData);

        if (bRetCode && 0 != dwData)
        {
            g_tStartDate = (time_t) dwData;
        }
        else
        {
            time_t tTime;
            time(&tTime);

            if (reg.SetValue(g_szEntryTrialStart, (DWORD) tTime))
            {
                g_tStartDate = tTime;
                SetStartDateString(tTime);
            }
        }
    }

    return g_tStartDate;
}


//-----------------------------------------------------------------------------
//  OpenIcwRmindKey
//-----------------------------------------------------------------------------
bool OpenIcwRmindKey(CMcRegistry &reg)
{
        // This method will open the IcwRmind key in the registry.  If the key
        // does not exist it will be created here.
    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyIcwRmind);

    if (!bRetCode)
    {
         bRetCode = reg.CreateKey(HKEY_LOCAL_MACHINE, g_szKeyIcwRmind);
        _ASSERT(bRetCode);
    }

    return bRetCode;
}


//-----------------------------------------------------------------------------
//  ClearCachedData
//-----------------------------------------------------------------------------
void ClearCachedData()
{
        // Clear all the global data so that it will be reread out of the
        // registry.
    g_tStartDate = 0;
    g_nISPTrialDays = 0;
    g_dwDialogTimeOut = 0;
    g_dwWakeupInterval = 0;
    g_szISPName[0] = 0;
    g_szISPMsg[0] = 0;
    g_szISPPhone[0] = 0;
    g_szSignupURL[0] = 0;
    g_szSignupURLTrialOver[0] = 0;
    g_szConnectoidName[0] = 0;
    g_nTotalNotifications = -1;
}


//-----------------------------------------------------------------------------
//  ResetCachedData
//-----------------------------------------------------------------------------
void ResetCachedData()
{
        // Clear all the global data so that it will be reread out of the
        // registry.
    g_tStartDate = 0;
    g_nISPTrialDays = 0;
    g_dwDialogTimeOut = 0;
    g_dwWakeupInterval = 0;
    g_szISPName[0] = 0;
    g_szISPMsg[0] = 0;
    g_szISPPhone[0] = 0;
    g_szSignupURL[0] = 0;
    g_szSignupURLTrialOver[0] = 0;
    g_szConnectoidName[0] = 0;
    g_nTotalNotifications = -1;

        // We must also clear the start date and total notifications out
        // of the registry.
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.SetValue(g_szEntryTrialStart, (DWORD) 0);
        _ASSERT(bRetCode);
        bRetCode = reg.SetValue(g_szEntryTotalNotifications, (DWORD) 0);
        _ASSERT(bRetCode);
    }
}


//-----------------------------------------------------------------------------
//  GetTotalNotifications
//-----------------------------------------------------------------------------
int GetTotalNotifications()
{
        // This is the number of times we have notified the user and the user
        // has responded to us.  We will only notify them 3 times.
    if (-1 != g_nTotalNotifications)
    {
        _ASSERT(g_nTotalNotifications <= 3);
        return g_nTotalNotifications;
    }

    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szEntryTotalNotifications, dwData);

        if (bRetCode)
        {
            g_nTotalNotifications = (int) dwData;
        }
        else
        {
            g_nTotalNotifications = 0;
        }
    }

    return g_nTotalNotifications;
}


//-----------------------------------------------------------------------------
//  IncrementTotalNotifications
//-----------------------------------------------------------------------------
void IncrementTotalNotifications()
{
    _ASSERT(g_nTotalNotifications < 3 && -1 != g_nTotalNotifications);

    if (g_nTotalNotifications < 3 && -1 != g_nTotalNotifications)
    {
        ++g_nTotalNotifications;

            // Let's put it back into the registry now.
        CMcRegistry reg;

        if (OpenIcwRmindKey(reg))
        {
            DWORD dwData = 0;
            bool bRetCode = reg.SetValue(g_szEntryTotalNotifications, (DWORD) g_nTotalNotifications);
            _ASSERT(bRetCode);
        }
    }
}


//-----------------------------------------------------------------------------
//  ResetTrialStartDate
//-----------------------------------------------------------------------------
void ResetTrialStartDate(time_t timeNewStartDate)
{
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        if (reg.SetValue(g_szEntryTrialStart, (DWORD) timeNewStartDate))
        {
            g_tStartDate = timeNewStartDate;
            SetStartDateString(timeNewStartDate);
        }
        else
        {
            _ASSERT(false);
        }
    }
    else
    {
        _ASSERT(false);
    }
}


//-----------------------------------------------------------------------------
//  DeleteAllRegistryData
//-----------------------------------------------------------------------------
void DeleteAllRegistryData()
{
        // Delete the Run Once data.  We do this by setting the value
        // to nothing.
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_LOCAL_MACHINE, g_szKeyRunOnce);
    _ASSERT(bRetCode);

    if (bRetCode)
    {
        bRetCode = reg.SetValue(g_szEntryRunOnce, TEXT(""));
        _ASSERT(bRetCode);
    }

        // Delete the Remind Key and all it's values.
    RegDeleteKey(HKEY_LOCAL_MACHINE, g_szKeyIcwRmind);
}


//-----------------------------------------------------------------------------
//  IsSignupSuccessful
//-----------------------------------------------------------------------------
BOOL IsSignupSuccessful()
{
    BOOL bSuccess = FALSE;
    CMcRegistry reg;

        // Do not cache this data.  Some other app will write this entry
        // once the user has successfully signed up.
    if (OpenIcwRmindKey(reg))
    {
        DWORD dwData = 0;
        bool bRetCode = reg.GetValue(g_szSignupSuccessfuly, dwData);

        if (bRetCode)
        {
            bSuccess = (BOOL) dwData;
        }
    }

    return bSuccess;
}


//-----------------------------------------------------------------------------
//  RemoveTrialConvertedFlag
//-----------------------------------------------------------------------------
void RemoveTrialConvertedFlag()
{
    BOOL bSuccess = FALSE;
    CMcRegistry reg;

    if (OpenIcwRmindKey(reg))
    {
        bool bRetCode = reg.SetValue(g_szSignupSuccessfuly, (DWORD) 0);
        _ASSERT(bRetCode);
    }
}

//-----------------------------------------------------------------------------
//  SetStartDateString
//-----------------------------------------------------------------------------
void SetStartDateString(time_t timeStartDate)
{
    CMcRegistry reg;
    TCHAR buf[255];

    wsprintf(buf, TEXT("%s"), ctime(&timeStartDate));

    if (OpenIcwRmindKey(reg))
    {
        reg.SetValue(g_szEntryTrialStartString, buf);
    }
}


//-----------------------------------------------------------------------------
//  SetIERunOnce
//-----------------------------------------------------------------------------
void SetIERunOnce()
{
    CMcRegistry reg;

    bool bRetCode = reg.OpenKey(HKEY_CURRENT_USER, g_szKeyIERunOnce);

        // The html page for the IE run once is in the same directory as
        // the IcwRmind exe.  Create the full qualified path.
    if (bRetCode)
    {
        TCHAR* pszBuf = new TCHAR[_MAX_PATH];

        if (GetModuleFileName(GetModuleHandle(NULL), pszBuf, _MAX_PATH))
        {
            TCHAR* pszBufPath = new TCHAR[_MAX_PATH];
            TCHAR* pszDrive = new TCHAR[_MAX_DRIVE];

            _tsplitpath(pszBuf, pszDrive, pszBufPath, NULL, NULL);
            lstrcpy(pszBuf, pszDrive);
            lstrcat(pszBuf, pszBufPath);
            lstrcat(pszBuf, g_szHtmlFile);
            reg.SetValue(g_szEntryIERunOnce, pszBuf);

            delete [] pszBufPath;
            delete [] pszDrive;
        }

        delete [] pszBuf;
    }
}


//-----------------------------------------------------------------------------
//  RemoveIERunOnce
//-----------------------------------------------------------------------------
void RemoveIERunOnce()
{
    HKEY hkey;
    long lErr = ::RegOpenKeyEx(HKEY_CURRENT_USER, g_szKeyIERunOnce, 0, KEY_READ | KEY_WRITE, &hkey);

    if (ERROR_SUCCESS == lErr)
    {
        RegDeleteValue(hkey, g_szEntryIERunOnce);
        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwrmind.rc
//
#define IDS_TEXT1                       1
#define IDS_TEXT2                       2
#define IDS_DLG_TITLE                   3
#define IDS_SIGNUPLATER                 4
#define IDS_DONOTREMIND                 5
#define IDS_EXPIRED_TEXT1               6
#define IDS_EXPIRED_TEXT2               7
#define IDS_DONOTSIGNUP                 8
#define IDS_EXPIRED_DLG_TITLE           9
#define IDD_SIGNUP                      101
#define IDD_SIGNUP_ISPMSG               102
#define IDC_DONTREMIND                  1000
#define IDC_ICON1                       1002
#define IDC_TEXT1                       1003
#define IDC_ISP_MESSAGE                 1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\mcreg.cpp ===
#define  STRICT
#include "mcReg.h"

//---------------------------------------------------------------------------

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------------------------
// ctor
//---------------------------------------------------------------------------
CMcRegistry::CMcRegistry()
 :	m_hkey(NULL)
{
}

//---------------------------------------------------------------------------
// dtor
//---------------------------------------------------------------------------
CMcRegistry::~CMcRegistry()
{
	if (m_hkey)
	{
		CloseKey();
	}
}


//---------------------------------------------------------------------------
// OpenKey
//---------------------------------------------------------------------------
bool
CMcRegistry::OpenKey(
	HKEY hkeyStart, LPCTSTR strKey, REGSAM sam /* = KEY_READ | KEY_WRITE */)
{
	long lErr = ::RegOpenKeyEx(hkeyStart, strKey, 0, sam, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CreateKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CreateKey(HKEY hkeyStart, LPCTSTR strKey)
{
	// You shouldn't have opened now.
	if (m_hkey)
	{
		_ASSERT(!m_hkey);
		return false;
	}

	long lErr = ::RegCreateKey(hkeyStart, strKey, &m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// CloseKey
//---------------------------------------------------------------------------
bool
CMcRegistry::CloseKey()
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegCloseKey(m_hkey);
	if (ERROR_SUCCESS != lErr)
	{
		m_hkey = NULL;
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
	
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = nBufferSize;

	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(strData), &cbData);

	return ERROR_SUCCESS == lErr && REG_SZ == dwType;
}


//---------------------------------------------------------------------------
// GetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::GetValue(LPCTSTR strValue, DWORD& rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	DWORD dwType;
	ULONG cbData = sizeof(rdw);
	long lErr = ::RegQueryValueEx(
		m_hkey, strValue, NULL, &dwType,
		reinterpret_cast<PBYTE>(&rdw), &cbData);

	return ERROR_SUCCESS == lErr && REG_DWORD == dwType;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, LPCTSTR strData)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_SZ, 
		reinterpret_cast<const BYTE*>(strData), sizeof(TCHAR)*(lstrlen(strData) + 1));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}


//---------------------------------------------------------------------------
// SetValue
//---------------------------------------------------------------------------
bool
CMcRegistry::SetValue(LPCTSTR strValue, DWORD rdw)
{
	if (!m_hkey)
	{
		_ASSERT(m_hkey);
		return false;
	}

	long lErr = ::RegSetValueEx(
		m_hkey, strValue, 0, REG_DWORD,
		reinterpret_cast<PBYTE>(&rdw), sizeof(rdw));

	if (ERROR_SUCCESS != lErr)
	{
		_ASSERT(false);
	}

	return ERROR_SUCCESS == lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\icwrmind.cpp ===
//-----------------------------------------------------------------------------
//  This exe runs in the background and wakes up every so often to do it's work.
//  When it wakes up it checks to see how much time the user has left on their
//  free ISP subscription.  At certain intervals it will tell the user time
//  is running out and will give the user the chance to signup for rea.
//-----------------------------------------------------------------------------
#define  STRICT
#include <windows.h>
#include <stdlib.h>
#include <stdarg.h>
#include <crtdbg.h>
#include <winbase.h>
#include <ras.h>
#include <time.h>
#include "IcwRmind.h"
#include "resource.h"
#include "RegData.h"


//-----------------------------------------------------------------------------
//  Forward Declarations
//-----------------------------------------------------------------------------
BOOL            InitializeApp (void);
BOOL            CheckForRASConnection();
void            CheckForSignupAttempt();
int             GetISPTrialDaysLeft();
void            ShutDownForGood();
void            PerformTheSignup();
void            CenterTheWindow(HWND hWnd);
DWORD           GetTickDelta();
void            AttemptTrialOverSignup();


//-----------------------------------------------------------------------------
//  Defines
//-----------------------------------------------------------------------------
#define TIMER_DIALOG_STAYUP         319     // Wake up timer to do work.
#define TIMER_RUNONCE_SETUP         320
#define TIME_RUNONCE_INTERVAL       30000   // 30 seconds
#define MAXRASCONNS                 8
#define MAX_DIALOGTEXT              512
#define MAX_ATTEMPTCOUNTER          20
#define LONG_WAKEUP_INTERVAL        3600000 // 1 hour

//-----------------------------------------------------------------------------
//  Global Handles and other defines
//-----------------------------------------------------------------------------
HINSTANCE   g_hModule;              // Process Instance handle
HWND        g_hwndMain;             // Main window handle
bool        g_bDoNotRemindAgain;    // Used by signup dialog.
time_t      g_timeAppStartUp;
DWORD       g_dwTickAppStartUp;
int         g_nAttemptCounter;
DWORD       g_dwMasterWakeupInterval;
bool        g_bDialogExpiredMode = false;
static const TCHAR* g_szTrialStartEvent = TEXT("_319IcwTrialStart913_");
static const TCHAR* g_szRunOnceEvent = TEXT("_319IcwRunOnce913_");


//-----------------------------------------------------------------------------
//  WinMain
//-----------------------------------------------------------------------------
int WINAPI WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine,
                    int nCmdShow)
{
    MSG msg;
    HANDLE hEventTrialStart = NULL;
    HANDLE hEventRunOnce = NULL;
    DWORD dwRetCode;
    bool bStartedViaWizard = false;

        // If there is a command line then see who started us.
    if (lstrlen(lpCmdLine))
    {
            // The RunOnce registry stuff will freeze up until we return.  Hence
            // the RunOnce setting in the registry must have some value for the
            // command line.  If we see any data we will spawn a second instance
            // of ourselves and exit this instance.
        if (0 == lstrcmpi(TEXT("-R"), lpCmdLine))
        {
            LPTSTR lpszFileName = new TCHAR[_MAX_PATH + 1];

            if (GetModuleFileName(GetModuleHandle(NULL), lpszFileName, _MAX_PATH + 1))
            {
                STARTUPINFO          sui;
                PROCESS_INFORMATION  pi;
                
                sui.cb               = sizeof (STARTUPINFO);
                sui.lpReserved       = 0;
                sui.lpDesktop        = NULL;
                sui.lpTitle          = NULL;
                sui.dwX              = 0;
                sui.dwY              = 0;
                sui.dwXSize          = 0;
                sui.dwYSize          = 0;
                sui.dwXCountChars    = 0;
                sui.dwYCountChars    = 0;
                sui.dwFillAttribute  = 0;
                sui.dwFlags          = 0;
                sui.wShowWindow      = 0;
                sui.cbReserved2      = 0;
                sui.lpReserved2      = 0;

                BOOL ret = CreateProcess (lpszFileName, NULL, NULL, NULL,
                        FALSE, DETACHED_PROCESS,
                        NULL, NULL, &sui, &pi );
                _ASSERT(ret);

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }

            delete [] lpszFileName;
            return 0;
        }
            // See if this is the start of a new trial.
        else if (0 == lstrcmpi(TEXT("-T"), lpCmdLine))
        {
            bStartedViaWizard = true;
            RemoveTrialConvertedFlag();
        }
    }

        // If we got this far let's create the named event and find out if we
        // are the first instance to run or if there is another instance already
        // running.
    hEventTrialStart = CreateEvent(NULL, FALSE, FALSE, g_szTrialStartEvent);
    if (hEventTrialStart)
    {
            // See if the named event already exists.  If it does then another 
            // instance of the IcwRmind exe is already running.  Signal the event
            // and exit.
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
                // If we were started via the wizard tell the other instance
                // to reset it's trial start data.
            if (bStartedViaWizard)
            {
                SetEvent(hEventTrialStart);
            }
                // Otherwise assume that RunOnce started us again.  In this case
                // Open the existing RunOnce named event and signal it.  This
                // tells the running instance to place us back into RunOnce key.
            else
            {
                hEventRunOnce = OpenEvent(EVENT_MODIFY_STATE, false, g_szRunOnceEvent);
                if (hEventRunOnce)
                {
                    SetEvent(hEventRunOnce);
                    CloseHandle(hEventRunOnce);
                }
            }

            CloseHandle(hEventTrialStart);
            return 0;
        }
    }
    else
    {
        _ASSERT(FALSE);
        return 0;
    }

    hEventRunOnce = CreateEvent(NULL, FALSE, FALSE, g_szRunOnceEvent);
    if (!hEventRunOnce)
    {
        CloseHandle(hEventTrialStart);
        return 0;
    }

        // If this flag is true and we got this far then we are the first
        // instance to run after being started by the wizard.  Let's clear
        // registry data just in case there is old stuff in there.
    if (bStartedViaWizard)
    {
        ResetCachedData();
    }

        // Check the registry and see if the user has successfully signed up.
        // If so then shut down for good.
    if (IsSignupSuccessful())
    {
        ShutDownForGood();
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

    g_hModule = hInstance;
    ClearCachedData();  // This initializes cache data to zero.
    g_nAttemptCounter = 0;

    time(&g_timeAppStartUp);
    g_dwTickAppStartUp = GetTickCount();

        // If the connectoid entry name does not exist in the registry then
        // we will shut down for good.
    const TCHAR* pcszConnectName = GetISPConnectionName();
    if (NULL == pcszConnectName || 0 == lstrlen(pcszConnectName))
    {
        ShutDownForGood();
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

        // If we cannot get or create the start time then something is really
        // bad.  We will stop never to be run again.
    if (0 == GetTrialStartDate())
    {
        ShutDownForGood();
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

        // Initialize and create the window class and window.
    if (!InitializeApp())
    {
        _ASSERT(FALSE);
        CloseHandle(hEventTrialStart);
        CloseHandle(hEventRunOnce);
        return 0;
    }

        // Testers can make the application visible via the registry.
    if (IsApplicationVisible())
    {
        ShowWindow(g_hwndMain, nCmdShow);
    }

        // Let's initialize the wake up interval.  If we are in the first half
        // of the trial then we don't want to wake up very often.  As we get
        // closer to the half way point we want to wake up more ofter to do
        // our polling.
    if (GetISPTrialDaysLeft() > (int)((GetISPTrialDays() / 2) + 1))
    {
            // Don't start polling more often until the day before the
            // half way point.
        g_dwMasterWakeupInterval = LONG_WAKEUP_INTERVAL;
    }
    else
    {
            // Use this method because the wake up interval may be in the
            // registry for testing.
        g_dwMasterWakeupInterval = GetWakeupInterval();
    }

        // Set a timer to re-setup the run once data in the registry.
        // If we do this too soon the intial run once startup will create
        // us multiple times.
    SetTimer(g_hwndMain, TIMER_RUNONCE_SETUP, TIME_RUNONCE_INTERVAL, NULL);

    HANDLE hEventList[2];
    hEventList[0] = hEventTrialStart;
    hEventList[1] = hEventRunOnce;

    while (TRUE)
    {
            // We will wait on window messages and also the named event.
        dwRetCode = MsgWaitForMultipleObjects(2, &hEventList[0], FALSE, g_dwMasterWakeupInterval, QS_ALLINPUT);

            // Determine why we came out of MsgWaitForMultipleObjects().  If
            // we timed out then let's do some TrialWatcher work.  Otherwise
            // process the message that woke us up.
        if (WAIT_TIMEOUT == dwRetCode)
        {
                // If we are still in the long wake up interval do a quick check
                // to see if we should switch to the shorter interval.
            if (LONG_WAKEUP_INTERVAL == g_dwMasterWakeupInterval)
            {
                if (GetISPTrialDaysLeft() <= (int)((GetISPTrialDays() / 2) + 1))
                {
                    g_dwMasterWakeupInterval = GetWakeupInterval();
                }
            }

            CheckForSignupAttempt();
        }
        else if (WAIT_OBJECT_0 == dwRetCode)
        {
                // If we get in here then the named event was signaled meaning
                // a second instance started up.  This means the user has 
                // signed up for a new trial with somebody else.  Clear
                // all persistant registry data.
            ResetCachedData();

                // Reset the trial start date.  If this fails then something
                // is really messed up in the registry.
            if (0 == GetTrialStartDate())
            {
                ShutDownForGood();
                break;
            }
        }
        else if (WAIT_OBJECT_0 + 1== dwRetCode)
        {
                // Signaled by the RunOnce event.  We must reset the timer to
                // place ourselves back into RunOnce.
            KillTimer(g_hwndMain, TIMER_RUNONCE_SETUP); // In case it is already running.
            SetTimer(g_hwndMain, TIMER_RUNONCE_SETUP, TIME_RUNONCE_INTERVAL, NULL);
        }
        else if (WAIT_OBJECT_0 + 2 == dwRetCode)
        {
                // 0 is returned if no message retrieved.
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (WM_QUIT == msg.message)
                {
                    break;
                }
                else
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
    }

    CloseHandle(hEventTrialStart);
    CloseHandle(hEventRunOnce);
    return 1;

    UNREFERENCED_PARAMETER(lpCmdLine);
    UNREFERENCED_PARAMETER(hPrevInstance);
}


//-----------------------------------------------------------------------------
//  InitializeApp
//-----------------------------------------------------------------------------
BOOL InitializeApp(void)
{
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = (WNDPROC)MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = g_hModule;
    wc.hIcon            = NULL;
    wc.hCursor          = LoadCursor(g_hModule, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = TEXT("IcwRmindClass");

    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }

        // Create the main window.  This window will stay hidden during the
        // life of the application.
    g_hwndMain = CreateWindow(TEXT("IcwRmindClass"),
                            TEXT("IcwRmind"),
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            100,
                            100,
                            HWND_DESKTOP,
                            NULL,
                            g_hModule,
                            NULL);

    if (g_hwndMain == NULL)
    {
        _ASSERT(FALSE);
        return(FALSE);
    }

    return(TRUE);
}


//-----------------------------------------------------------------------------
//  MainWndProc
//-----------------------------------------------------------------------------
LRESULT WINAPI MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_CREATE:
        {
            return 0;
        }
        
        case WM_TIMER:
        {
            KillTimer(g_hwndMain, TIMER_RUNONCE_SETUP);
            SetupRunOnce();

                // Wait for trial days left to drop below -1.  The trail to
                // do the trial over sign up.
            if (GetISPTrialDaysLeft() < -1)
            {
                AttemptTrialOverSignup();
            }

            return 1;
        }

        case WM_TIMECHANGE:
        {
                // Calculate the relative current time.  We do not want to 
                // grab the system time because that is the new time after
                // the time change.  Tick count is in milleseconds so we
                // convert that to seconds by dividing by 1000.
            DWORD dwTickDelta = GetTickDelta();
            
                // If tick count rolls around GetTickDelta() will modify app 
                // start date, so get the tick delta before actually using it.
            time_t timeRelativeCurrent = g_timeAppStartUp + (dwTickDelta / 1000);

                // Determine the delta in seconds between the relative
                // system time and the new time set by the user.
            time_t timeCurrent;
            time(&timeCurrent);

                // Delta seconds will be negative if the user has turned
                // the clock back.
            time_t timeDeltaSeconds = timeCurrent - timeRelativeCurrent;
            time_t timeNewTrialStartDate = GetTrialStartDate() + timeDeltaSeconds;

#ifdef _DEBUG
            TCHAR buf[255];
            OutputDebugString(TEXT("-------------------\n"));
            time_t timeOldStart = GetTrialStartDate();
            wsprintf(buf, TEXT("Old Start:  %s\n"), ctime(&timeOldStart));
            OutputDebugString(buf);
            wsprintf(buf, TEXT("New Start:  %s\n"), ctime(&timeNewTrialStartDate));
            OutputDebugString(buf);
            OutputDebugString(TEXT("-------------------\n"));
#endif

                // Now reset the trial start date and the application start
                // date.  Also reset the app start date and app start tick
                // count.  This will be our new frame of reference for 
                // calculating relative dates.
            ResetTrialStartDate(timeNewTrialStartDate);
            g_timeAppStartUp = timeCurrent;
            g_dwTickAppStartUp = GetTickCount();

            return 1;
        }

        case WM_DESTROY:
        {
            PostQuitMessage(0);
            return 1;
        }

        default:
        {
            return DefWindowProc(hwnd, message, wParam, lParam);
        }
    }
}


//-----------------------------------------------------------------------------
//  SignUpDialogProc
//-----------------------------------------------------------------------------
LRESULT WINAPI SignUpDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HICON hIcon = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR bufOut[MAX_DIALOGTEXT];
            TCHAR bufFormat[MAX_DIALOGTEXT];
            TCHAR *bufAll = new TCHAR[MAX_DIALOGTEXT * 2 + MAX_ISPMSGSTRING];

            g_bDoNotRemindAgain = false;

                // This dialog has two modes.  Set the text the correct way.
            if (g_bDialogExpiredMode)
            {
                if (LoadString(g_hModule, IDS_EXPIRED_DLG_TITLE, bufFormat, MAX_DIALOGTEXT))
                {
                    SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) bufFormat);
                }

                if (LoadString(g_hModule, IDS_EXPIRED_TEXT1, bufFormat, MAX_DIALOGTEXT))
                {
                    wsprintf(bufOut, bufFormat, GetISPName());
                    lstrcpy(bufAll, bufOut);
                    lstrcat(bufAll, TEXT("\n\n"));
                }

                if(*GetISPMessage() != '\0')
                {
                    lstrcat(bufAll, GetISPMessage());
                    lstrcat(bufAll, TEXT("\n\n"));
                }

                if (LoadString(g_hModule, IDS_EXPIRED_TEXT2, bufFormat, MAX_DIALOGTEXT))
                {
                    wsprintf(bufOut, bufFormat, GetISPName(), GetISPName(), GetISPPhone());
                    lstrcat(bufAll, bufOut);
                }

                SetDlgItemText(hDlg, IDC_TEXT1, bufAll);

                ShowWindow(GetDlgItem(hDlg, IDC_DONTREMIND), SW_HIDE);

                if (LoadString(g_hModule, IDS_DONOTSIGNUP, bufOut, MAX_DIALOGTEXT))
                {
                    SetDlgItemText(hDlg, IDCANCEL, bufOut);
                }
            }
            else
            {
                    // Set up the text in the dialog box.
                if (LoadString(g_hModule, IDS_DLG_TITLE, bufFormat, MAX_DIALOGTEXT))
                {
                    wsprintf(bufOut, bufFormat, GetISPTrialDaysLeft());
                    SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM) bufOut);
                }

                if (LoadString(g_hModule, IDS_TEXT1, bufFormat, MAX_DIALOGTEXT))
                {
                    wsprintf(bufOut, bufFormat, GetISPName(), GetISPTrialDaysLeft());
                    lstrcpy(bufAll, bufOut);
                    lstrcat(bufAll, TEXT("\n\n"));
                }

                if(*GetISPMessage() != '\0')
                {
                    lstrcat(bufAll, GetISPMessage());
                    lstrcat(bufAll, TEXT("\n\n"));
                }

                if (LoadString(g_hModule, IDS_TEXT2, bufFormat, MAX_DIALOGTEXT))
                {
                    wsprintf(bufOut, bufFormat, GetISPName(), GetISPName(), GetISPPhone());
                    lstrcat(bufAll, bufOut);
                }
                SetDlgItemText(hDlg, IDC_TEXT1, bufAll);

                    // If there are 0 days left then don't give user a change
                    // to say remind me later.
                if (0 == GetISPTrialDaysLeft())
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_DONTREMIND), SW_HIDE);

                    if (LoadString(g_hModule, IDS_DONOTSIGNUP, bufOut, MAX_DIALOGTEXT))
                    {
                        SetDlgItemText(hDlg, IDCANCEL, bufOut);
                    }
                }
            }

                // Set the timer for how long the dialog will stay up before
                // removing itself.
            SetTimer(hDlg, TIMER_DIALOG_STAYUP, GetDialogTimeout(), NULL);
            CenterTheWindow(hDlg);
            delete bufAll;

            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                    // IDOK is the Sign up now button.
                case IDOK:
                {
                    KillTimer(hDlg, TIMER_DIALOG_STAYUP);
                    EndDialog(hDlg, wParam);
                    break;
                }

                    // If the checkbox is clicked then toggle the button text for the
                    // signup later button.
                case IDC_DONTREMIND:
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DONTREMIND))
                    {
                        TCHAR bufOut[MAX_DIALOGTEXT];
                        if (LoadString(g_hModule, IDS_DONOTREMIND, bufOut, MAX_DIALOGTEXT))
                        {
                            SetDlgItemText(hDlg, IDCANCEL, bufOut);
                        }
                    }
                    else
                    {
                        TCHAR bufOut[MAX_DIALOGTEXT];
                        if (LoadString(g_hModule, IDS_SIGNUPLATER, bufOut, MAX_DIALOGTEXT))
                        {
                            SetDlgItemText(hDlg, IDCANCEL, bufOut);
                        }
                    }

                    break;
                }

                    // Otherwise assume they hit the close button or the sign up later
                    // button.
                default:
                {
                        // See if the user never wants reminded again.
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DONTREMIND))
                    {
                        g_bDoNotRemindAgain = true;
                    }

                    KillTimer(hDlg, TIMER_DIALOG_STAYUP);
                    EndDialog(hDlg, wParam);
                    break;
                }
            }

            break;
        }

            // No user interaction has occurred.  remove the dialog but do not count
            // this as an attempt to sign up.
        case WM_TIMER:
        {
            KillTimer(hDlg, TIMER_DIALOG_STAYUP);
            EndDialog(hDlg, IDABORT);
            break;
        }

        case WM_PAINT:
        {
            HDC             hDC;
            PAINTSTRUCT     ps;
            HICON           hIcon;
            HWND            hWndRect;
            RECT            rect;
            POINT           ptUpperLeft;

            hDC = BeginPaint(hDlg, &ps);

            hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_QUESTION));

            if (hIcon)
            {
                hWndRect = GetDlgItem(hDlg, IDC_ICON1);
                GetWindowRect(hWndRect, &rect);

                ptUpperLeft.x = rect.left;
                ptUpperLeft.y = rect.top;
                ScreenToClient(hDlg, &ptUpperLeft);

                DrawIcon(hDC, ptUpperLeft.x, ptUpperLeft.y, hIcon);
            }

            EndPaint(hDlg, &ps);
            break;
        }
    }

    return FALSE;

    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(hDlg);
}


//-----------------------------------------------------------------------------
//  CheckForRASConnection
//-----------------------------------------------------------------------------
BOOL CheckForRASConnection()
{
    RASCONNSTATUS rascs;
    RASCONN rasConn[MAXRASCONNS];
    DWORD dwEntries = MAXRASCONNS;
    DWORD dwSize = sizeof(rasConn);
    DWORD dwRet;
    BOOL bRetCode = FALSE;
    
        // This is the connection name of the ISP the user has signed up
        // with.  We will look for a connectiod with this same name.
    const TCHAR* pszConnectionName = GetISPConnectionName();
    if (NULL == pszConnectionName || 0 == lstrlen(pszConnectionName))
    {
        return FALSE;
    }

    for (int i = 0; i < MAXRASCONNS; ++i)
    {
        rasConn[i].dwSize = sizeof(RASCONN);
    }

    dwRet = RasEnumConnections(rasConn, &dwSize, &dwEntries);

    if (dwRet == 0)
    {
        for (dwRet = 0; dwRet < dwEntries; dwRet++)
        {
                // If this is the connection we are looking for let's make
                // sure the connection is all set to go.
            if (0 == lstrcmpi(pszConnectionName, rasConn[dwRet].szEntryName))
            {
                rascs.dwSize = sizeof(RASCONNSTATUS);
                dwRet = RasGetConnectStatus(rasConn[dwRet].hrasconn, 
                                            &rascs);
                if (dwRet == 0 && rascs.rasconnstate == RASCS_Connected)
                {
                    bRetCode = TRUE;
                }
            }
        }
    }

    return bRetCode;
}


//-----------------------------------------------------------------------------
//  CheckForSignupAttempt
//
//  This method contains the logic that check to see if we should make an attempt
//  to pop up the sign up dialog.  If we should make an attempt will will then
//  enum the RAS connections to see if the user is connected before popping
//  up the dialog.
//-----------------------------------------------------------------------------
void CheckForSignupAttempt()
{
    int nDaysLeft = GetISPTrialDaysLeft();
    int nRetValue = 0;
            
        // Every some many signup attempts lets read the registry and see if
        // a successful signup happened.
    ++g_nAttemptCounter;

    if (MAX_ATTEMPTCOUNTER == g_nAttemptCounter)
    {
        g_nAttemptCounter = 0;

        if (IsSignupSuccessful())
        {
            ShutDownForGood();
            return;
        }

            // If the trial is expired then set the IE run once key.
        if (nDaysLeft < -1)
        {
            SetIERunOnce();
        }
    }

        // If we are in negative days left then do not do anything.  This means
        // the trail is over and the user has not signed up.  We will give
        // them one more signup attempt on application start up.
    if (nDaysLeft < 0)
    {
        return;
    }

    bool bAttemptSignup = false;

        // Based on the total signup notificaiton attempts we will determine
        // if the days left requires another attempt.
    switch (GetTotalNotifications())
    {
            // If we have not made any attempts yet then if we are at the half
            // way point in the trial or past the half way point we will make
            // a signup attempt.
        case 0:
        {
            if (nDaysLeft <= (int)(GetISPTrialDays() / 2))
            {
                bAttemptSignup = true;
            }
            break;
        }

            // If we have already perfomed 1 attempt then the second attempt
            // will come on the next to last day or the last day.
        case 1:
        {
            if (nDaysLeft <= 1)
            {
                bAttemptSignup = true;
            }
            break;
        }

            // The 3rd attempt will not come until the last day.
        case 2:
        {
            if (nDaysLeft == 0)
            {
                bAttemptSignup = true;
            }
            break;
        }

        default:
        {
            break;
        }
    }

    if (bAttemptSignup)
    {
        if (CheckForRASConnection())
        {
                // Before actually showing the dialog do a quick check to see
                // if a previous signup was successful.  If so we will shut 
                // down for good.
            if (IsSignupSuccessful())
            {
                ShutDownForGood();
                return;
            }

            g_bDialogExpiredMode = false;
            //if we have an isp message we need the right dlg template
            if(*GetISPMessage() != '\0')
                nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP_ISPMSG), g_hwndMain, (DLGPROC)SignUpDialogProc);
            else 
                nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP), g_hwndMain, (DLGPROC)SignUpDialogProc);

            switch (nRetValue)
            {
                    // The user wants to try and signup.
                case IDOK:
                {
                    PerformTheSignup();
                    break;
                }

                    // The user said signup later.  Check to see if the don't remind
                    // me button was pressed.  If so then shut down for good.
                case IDCANCEL:
                {
                        // If this is the last day of the trial then the remind
                        // me later button is not the Don't signup button.  In
                        // this case shut down for good.
                    if (0 == nDaysLeft)
                    {
                        ShutDownForGood();
                    }
                    else
                    {
                        IncrementTotalNotifications();
                        
                        if (g_bDoNotRemindAgain)
                        {
                            ShutDownForGood();
                        }
                    }

                    break;
                }

                    // The dialog timed out.  Don't do anything.  The does not
                    // count as an attempt.
                case IDABORT:
                {
                    break;
                }

                    // No work in here, in fact we should not get here.
                default:
                {
                    _ASSERT(false);
                    break;
                }
            }

                // If there is 1 day left let's make sure that total notifications
                // is 2.  If not the dialog may pop up multiple times.  Oh yea,
                // if dialog timed out then don't do this.
            if (IDABORT != nRetValue && 1 == nDaysLeft && 1 == GetTotalNotifications())
            {
                IncrementTotalNotifications();
            }
        }
    }
}


//-----------------------------------------------------------------------------
//  GetISPTrialDaysLeft
//-----------------------------------------------------------------------------
int GetISPTrialDaysLeft()
{
        // Calculate the relative current time.  The current system time cannot
        // be trusted if the System date/time dialog is up.  That dialog will
        // change the actual system time when every the user pokes around even
        // before hitting OK or Apply!!!
    time_t timeRelativeCurrent = g_timeAppStartUp + (GetTickDelta() / 1000);

        // The relative time and the trial start date are both time_t type
        // variables which are in seconds.
    int nSecondsSinceStart = (int)(timeRelativeCurrent - GetTrialStartDate());

        // Now convert seconds into days.  There are 86400 seconds in a day.
        // Note that we will always round up one more day if there is any 
        // remainder.
    div_t divResult = div(nSecondsSinceStart, 86400);
    int nDaysSinceStart = divResult.quot;
    if (divResult.rem)
    {
        ++nDaysSinceStart;
    }

#ifdef _DEBUG
    TCHAR buf[255];
    wsprintf(buf, TEXT("Days Since = %i\n"), nDaysSinceStart);
    OutputDebugString(buf);
    wsprintf(buf, TEXT("Check:  %s\n"), ctime(&timeRelativeCurrent));
    OutputDebugString(buf);
    time_t tt = GetTrialStartDate();
    wsprintf(buf, TEXT("Start:  %s\n"), ctime(&tt));
    OutputDebugString(buf);
#endif

    int nDaysLeft = GetISPTrialDays() - nDaysSinceStart;

#ifdef _DEBUG
    wsprintf(buf, TEXT("Days Left = %i\r\n"), nDaysLeft);
    OutputDebugString(buf);
#endif

    return nDaysLeft;
}


//-----------------------------------------------------------------------------
//  ShutDownForGood
//-----------------------------------------------------------------------------
void ShutDownForGood()
{
    RemoveRunOnce();
    RemoveIERunOnce();
    DeleteAllRegistryData();
    PostMessage(g_hwndMain, WM_CLOSE, 0, 0);
}


//-----------------------------------------------------------------------------
//  PerformTheSignup
//-----------------------------------------------------------------------------
void PerformTheSignup()
{
        // Note that we do not shut down for good.  The sign up may fail so 
        // simply increment the notification count.
    const TCHAR* pcszSignupUrl = GetISPSignupUrl();
    ShellExecute(g_hwndMain, TEXT("open"), pcszSignupUrl, TEXT(""), TEXT(""), SW_SHOW);
    IncrementTotalNotifications();
}


//-----------------------------------------------------------------------------
//  CenterTheWindow
//-----------------------------------------------------------------------------
void CenterTheWindow(HWND hWnd)
{
    HDC hDC = GetDC(hWnd);

    if (hDC)
    {
        int nScreenWidth = GetDeviceCaps(hDC, HORZRES);
        int nScreenHeight = GetDeviceCaps(hDC, VERTRES);
    
        RECT rect;
        GetWindowRect(hWnd, &rect);
        
            // Also make the window "always on top".
        SetWindowPos(hWnd, HWND_TOPMOST, 
                    (nScreenWidth / 2) - ((rect.right - rect.left) / 2), 
                    (nScreenHeight / 2) - ((rect.bottom - rect.top) / 2), 
                    rect.right - rect.left, 
                    rect.bottom - rect.top, 
                    SWP_SHOWWINDOW);

        ReleaseDC(hWnd, hDC);
    }
}


//-----------------------------------------------------------------------------
//  GetTickDelta
//-----------------------------------------------------------------------------
DWORD GetTickDelta()
{
        // This function returns the delta between the startup tick count and
        // the current tick count.  Note that we must watch for a rollover in 
        // the tick count.
    DWORD dwTickDelta;
    DWORD dwTickCurrent = GetTickCount();

        // If tick count rolls over we need to reset the app start up date
        // and the app tick count in case we roll over a second time.
    if (dwTickCurrent < g_dwTickAppStartUp)
    {
            // Calculate the delta by finding out how many ticks to the MAX 
            // tick count a DWORD can handle and then add the wrap around amount.
        DWORD dwDeltaToMax =  0xFFFFFFFF - g_dwTickAppStartUp;
        dwTickDelta = dwDeltaToMax + dwTickCurrent;

            // Modify the application startup by the delta in seconds that have
            // passed since it was last set.  Also reset startup tick count
            // to current tick for our new frame of reference.
        g_timeAppStartUp += (dwTickDelta / 1000);   // Convert to seconds.
        g_dwTickAppStartUp = dwTickCurrent;

            // Since we have modified the application start up date relative
            // to the current tick count and changed the app start up tick
            // count to the current tick count, the delta is zero.
        dwTickDelta = 0;
    }
    else
    {
        dwTickDelta = dwTickCurrent - g_dwTickAppStartUp;
    }

    return dwTickDelta;
}


//-----------------------------------------------------------------------------
//  AttemptTrialOverSignup
//-----------------------------------------------------------------------------
void AttemptTrialOverSignup()
{ 
    int nRetValue = 0;

    // Setup the run once data for IE.
    g_bDialogExpiredMode = true;

    if(*GetISPMessage() != '\0')
        nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP_ISPMSG), g_hwndMain, (DLGPROC)SignUpDialogProc);
    else 
        nRetValue = (int)DialogBox(g_hModule, MAKEINTRESOURCE(IDD_SIGNUP), g_hwndMain, (DLGPROC)SignUpDialogProc);

    
    RemoveIERunOnce();

    switch (nRetValue)
    {
            // The user wants to try and signup.
        case IDOK:
        {
            const TCHAR* pcszSignupUrl = GetISPSignupUrlTrialOver();
            ShellExecute(g_hwndMain, TEXT("open"), pcszSignupUrl, TEXT(""), TEXT(""), SW_SHOW);
            ShutDownForGood();
            break;
        }

        case IDCANCEL:
        {
            ShutDownForGood();
            break;
        }

            // If we get IDABORT the dialog timed out so don't do anything.
        case IDABORT:
        {
            break;
        }

            // No work in here, in fact we should not get here.
        default:
        {
            _ASSERT(false);
            ShutDownForGood();
            break;
        }
    }
}

extern "C" void _stdcall ModuleEntry (void)
{
    LPTSTR      pszCmdLine = GetCommandLine();
    
    if ( *pszCmdLine == TEXT('\"') ) 
    {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
            ;
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else 
    {
        while (*pszCmdLine > TEXT(' '))
        pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) 
    {
        pszCmdLine++;
    }

    int i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine, SW_SHOWDEFAULT);
    
    ExitProcess(i); // Were outa here....  
}   /*  ModuleEntry() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\regdata.h ===
#pragma once
#include "mcReg.h"
#define MAX_ISPMSGSTRING		    560

DWORD			GetWakeupInterval();
BOOL			IsApplicationVisible();
const TCHAR*		GetISPConnectionName();
const TCHAR*		GetISPSignupUrl();
const TCHAR*		GetISPSignupUrlTrialOver();
DWORD			GetDialogTimeout();
void			SetupRunOnce();
void			RemoveRunOnce();
const TCHAR*		GetISPName();
const TCHAR*		GetISPPhone();
const TCHAR*		GetISPMessage();
int				GetISPTrialDays();
time_t			GetTrialStartDate();
bool			OpenIcwRmindKey(CMcRegistry &reg);
void			ClearCachedData();
void			ResetCachedData();
int				GetTotalNotifications();
void			IncrementTotalNotifications();
void			ResetTrialStartDate(time_t timeNewStartDate);
void 			DeleteAllRegistryData();
BOOL 			IsSignupSuccessful();
void			RemoveTrialConvertedFlag();
void			SetStartDateString(time_t timeStartDate);
void			SetIERunOnce();
void			RemoveIERunOnce();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwrmind\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

#
# Cross-compiler macros for unique naming
#

MAJORCOMP       = ie4
MINORCOMP       = getconn


#
# Defines for common.inc
#

TARGET_BOTH     = 1
USE_MSVCRT      = 1


#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

# USE cdecl calling
386_STDCALL = 0

#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = ICWRMIND
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =

LINKLIBS        = $(LIBRARY_PATH)\gdi32.lib         \
                  $(LIBRARY_PATH)\kernel32.lib      \
                  $(LIBRARY_PATH)\advapi32.lib      \
                  $(LIBRARY_PATH)\shell32.lib       \
                  $(LIBRARY_PATH)\user32.lib        \
                  $(LIBRARY_PATH)\rasapi32.lib

# bugbug: scousens.
#         @0 needed because ModuleEntry is _stdcall.
#         On mips _stdcall is mapped to nothing
!if $(386)
UMENTRYABS      = ModuleEntry@0
!else
UMENTRYABS      = ModuleEntry
!endif


#
# List of sources
#
SOURCES=                        \
            ..\IcwRmind.rc      \
            ..\IcwRmind.cpp     \
            ..\mcReg.cpp        \
            ..\RegData.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwtutor\icwtutor.cpp ===
// icwtutor.cpp : Defines the entry point for the application.
//
#include <windows.h>
#include <urlmon.h>
#include <mshtmhst.h>
#include <locale.h>

#define STR_BSTR      0
#define STR_OLESTR    1
#define ARRAYSIZE(a)  (sizeof(a)/sizeof((a)[0]))
#define A2B(x)        (BSTR)A2W((LPSTR)(x), STR_BSTR)

LPWSTR A2W			      (LPSTR psz, BYTE bType);
BSTR  GetHtmFileFromCommandLine (HINSTANCE hInst, LPSTR lpCmdLine);
    
BOOL bFileFromCmdLine = FALSE;
     
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    HINSTANCE hinstMSHTML = NULL;

#ifdef UNICODE
        // Initialize the C runtime locale to the system locale.
    setlocale(LC_ALL, "");
#endif

    hinstMSHTML = LoadLibrary(TEXT("MSHTML.DLL"));

    if(hinstMSHTML)
    {
        SHOWHTMLDIALOGFN  *pfnShowHTMLDialog = NULL;
      
        pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)GetProcAddress(hinstMSHTML, "ShowHTMLDialog");

        if(pfnShowHTMLDialog)
        {
            IMoniker *pmk             = NULL;
            BSTR     bstrHtmFilePath  = NULL;
            
            bstrHtmFilePath = GetHtmFileFromCommandLine(hInstance, lpCmdLine);

            CreateURLMoniker(NULL, bstrHtmFilePath, &pmk);

            SysFreeString(bstrHtmFilePath); 

            if(pmk)
            {
                if(bFileFromCmdLine)
                    (*pfnShowHTMLDialog)(NULL, pmk, NULL, A2B("help: no"), NULL);
                else
                    (*pfnShowHTMLDialog)(NULL, pmk, NULL, A2B("dialogWidth:  36.5em; dialogHeight: 25.5em; help: no"), NULL);

                pmk->Release();
            }
        }
        FreeLibrary(hinstMSHTML);
    }
    return 0;
}

BSTR GetHtmFileFromCommandLine(HINSTANCE hInst, LPSTR lpCmdLine)
{
    CHAR szTemp [MAX_PATH*2] = "\0";

    if (*lpCmdLine == '\"')
    {
        lstrcpynA(szTemp,
                  lpCmdLine + 1, 
                  lstrlenA(lpCmdLine) - 1);
    }
    else
    {
        lstrcpyA(szTemp,
                 lpCmdLine);
    }
    
    if (GetFileAttributesA(szTemp) != 0xFFFFFFFF)
    {
       bFileFromCmdLine = TRUE;
       return A2B(szTemp);
    }

    lstrcpyA(szTemp, "res://");
    GetModuleFileNameA(hInst, szTemp + lstrlenA(szTemp), ARRAYSIZE(szTemp) - lstrlenA(szTemp));
    lstrcatA(szTemp, "/Default.htm");

    return A2B(szTemp);
}

LPWSTR A2W(LPSTR psz, BYTE bType)
{
    int i;
    LPWSTR pwsz;

    if (!psz)
        return(NULL);
    // compute the length of the required BSTR
    if ((i = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0)) <= 0)    
        return NULL;                                                                                            
    switch (bType) 
	{                                                   
        case STR_BSTR:                           
			// SysAllocStringLen adds 1
			pwsz = (LPWSTR)SysAllocStringLen(NULL, (i - 1));            
            break;
        case STR_OLESTR:
            pwsz = (LPWSTR)CoTaskMemAlloc(i * sizeof(WCHAR));
            break;
        default:
            return(NULL);
    }
    if (!pwsz)
        return(NULL);
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return(pwsz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwtutor\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

#
# Cross-compiler macros for unique naming
#

MAJORCOMP       = GETCONN
MINORCOMP       = icwtutor.exe


#
# Defines for common.inc
#

TARGET_BOTH     = 1
USE_LIBCMT	= 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

# USE cdecl calling
386_STDCALL = 0
#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = icwtutor
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =

UMENTRY		= winmain

LINKLIBS    =                                   \
    $(LIBRARY_PATH)\kernel32.lib                \
    $(LIBRARY_PATH)\user32.lib                  \
    $(LIBRARY_PATH)\gdi32.lib                   \
    $(LIBRARY_PATH)\comdlg32.lib                \
    $(LIBRARY_PATH)\advapi32.lib                \
    $(LIBRARY_PATH)\shell32.lib                 \
    $(LIBRARY_PATH)\ole32.lib                   \
    $(LIBRARY_PATH)\comctl32.lib                \
    $(LIBRARY_PATH)\urlmon.lib                  \
    $(LIBRARY_PATH)\uuid.lib                    \
    $(LIBRARY_PATH)\comctl32.lib                \
    $(SDK_LIB_PATH)\oleaut32.lib                \
!if defined(NOT_UNICODE)
    $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib     \
!else
    $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib  \
!endif


#
# List of sources
#
SOURCES =               \
    ..\icwtutor.rc      \
	..\icwtutor.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\bkgndbmp.cpp ===
#include "pre.h"


PBITMAPINFO CreateBitmapInfoStruct
(
    HBITMAP hBmp
)
{ 
    BITMAP      bmp; 
    PBITMAPINFO pbmi; 
    WORD        cClrBits; 

    // Retrieve the bitmap's color format, width, and height. 
    if (!GetObject(hBmp, sizeof(BITMAP), (LPSTR)&bmp)) 
        return NULL;

    // Convert the color format to a count of bits. 
    cClrBits = (WORD)(bmp.bmPlanes * bmp.bmBitsPixel); 
    if (cClrBits == 1) 
        cClrBits = 1; 
    else if (cClrBits <= 4) 
        cClrBits = 4; 
    else if (cClrBits <= 8) 
        cClrBits = 8; 
    else if (cClrBits <= 16) 
        cClrBits = 16; 
    else if (cClrBits <= 24) 
        cClrBits = 24; 
    else cClrBits = 32; 

    // Allocate memory for the BITMAPINFO structure. (This structure 
    // contains a BITMAPINFOHEADER structure and an array of RGBQUAD 
    // data structures.) 
    if (cClrBits != 24) 
    {
        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, 
                                        sizeof(BITMAPINFOHEADER) + 
                                        sizeof(RGBQUAD) * (1<< cClrBits)); 
    }
    else 
    {
        // There is no RGBQUAD array for the 24-bit-per-pixel format. 
        pbmi = (PBITMAPINFO) LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER)); 
    }
    
    // Initialize the fields in the BITMAPINFO structure. 
    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
    pbmi->bmiHeader.biWidth = bmp.bmWidth; 
    pbmi->bmiHeader.biHeight = bmp.bmHeight; 
    pbmi->bmiHeader.biPlanes = bmp.bmPlanes; 
    pbmi->bmiHeader.biBitCount = bmp.bmBitsPixel; 
    if (cClrBits < 24) 
        pbmi->bmiHeader.biClrUsed = (1<<cClrBits); 

    // If the bitmap is not compressed, set the BI_RGB flag. 
    pbmi->bmiHeader.biCompression = BI_RGB; 

    // Compute the number of bytes in the array of color 
    // indices and store the result in biSizeImage. 
    pbmi->bmiHeader.biSizeImage = (pbmi->bmiHeader.biWidth + 7) /8 
                                  * pbmi->bmiHeader.biHeight 
                                  * cClrBits; 
                                  
    // Set biClrImportant to 0, indicating that all of the 
    // device colors are important. 
    pbmi->bmiHeader.biClrImportant = 0; 
    return pbmi; 
} 
 
BOOL CreateBMPFile
(
    LPTSTR      pszFile, 
    PBITMAPINFO pbi, 
    HBITMAP     hBMP, 
    HDC         hDC
) 
{ 
    HANDLE              hf;                 // file handle 
    BITMAPFILEHEADER    hdr;                // bitmap file-header 
    PBITMAPINFOHEADER   pbih;               // bitmap info-header 
    LPBYTE              lpBits;             // memory pointer 
    DWORD               dwTotal;            // total count of bytes 
    DWORD               cb;                 // incremental count of bytes 
    BYTE                *hp;                // byte pointer 
    DWORD               dwTmp; 

    pbih = (PBITMAPINFOHEADER) pbi; 
    lpBits = (LPBYTE) GlobalAlloc(GMEM_FIXED, pbih->biSizeImage);

    if (!lpBits) 
        return FALSE;

    // Retrieve the color table (RGBQUAD array) and the bits 
    // (array of palette indices) from the DIB. 
    if (!GetDIBits(hDC, hBMP, 0, (WORD) pbih->biHeight, lpBits, pbi, DIB_RGB_COLORS)) 
    {
        return FALSE;
    }

    // Create the .BMP file. 
    hf = CreateFile(pszFile, 
                    GENERIC_READ | GENERIC_WRITE, 
                    (DWORD) 0, 
                    NULL, 
                    CREATE_ALWAYS, 
                    FILE_ATTRIBUTE_NORMAL, 
                    (HANDLE) NULL); 
    if (hf == INVALID_HANDLE_VALUE) 
        return FALSE;
        
    hdr.bfType = 0x4d42;        // 0x42 = "B" 0x4d = "M" 
    // Compute the size of the entire file. 
    hdr.bfSize = (DWORD) (sizeof(BITMAPFILEHEADER) + 
                 pbih->biSize + pbih->biClrUsed 
                 * sizeof(RGBQUAD) + pbih->biSizeImage); 
    hdr.bfReserved1 = 0; 
    hdr.bfReserved2 = 0; 

    // Compute the offset to the array of color indices. 
    hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER) + 
                    pbih->biSize + pbih->biClrUsed 
                    * sizeof (RGBQUAD); 

    // Copy the BITMAPFILEHEADER into the .BMP file. 
    if (!WriteFile(hf, (LPVOID) &hdr, sizeof(BITMAPFILEHEADER), 
        (LPDWORD) &dwTmp,  NULL)) 
    {
       return FALSE;
    }

    // Copy the BITMAPINFOHEADER and RGBQUAD array into the file. 
    if (!WriteFile(hf, (LPVOID) pbih, sizeof(BITMAPINFOHEADER) 
                  + pbih->biClrUsed * sizeof (RGBQUAD), 
                  (LPDWORD) &dwTmp, ( NULL))) 
    {                  
        return FALSE;
    }
    
    // Copy the array of color indices into the .BMP file. 
    dwTotal = cb = pbih->biSizeImage; 
    hp = lpBits; 
    if (!WriteFile(hf, (LPSTR) hp, (int) cb, (LPDWORD) &dwTmp,NULL)) 
    {
        return FALSE;
    }
    
    // Close the .BMP file. 
     if (!CloseHandle(hf)) 
     {
        return FALSE;
     }
     
    // Free memory. 
    GlobalFree((HGLOBAL)lpBits);
    
    return TRUE;
}
 
 
BOOL CopyBitmapRectToFile
(
    HBITMAP hbm, 
    LPRECT  lpRect,
    LPTSTR  lpszFileName
)
{
    HDC         hSrcDC, hDestDC;         // screen DC and memory DC
    HDC         hScreenDC;
    HBITMAP     hBitmap, hOldBitmap, hOldSrcBitmap; 
    PBITMAPINFO pbmi; 
    BOOL        bRet;
        
    // check for an empty rectangle
    if (IsRectEmpty(lpRect))
      return FALSE;

    // get the Source Window DC and create
    // a memory DC compatible to screen DC
    hScreenDC = GetDC(NULL);
    hSrcDC = CreateCompatibleDC(hScreenDC);
    hDestDC = CreateCompatibleDC(hScreenDC);
    
    // create a dest bitmap
    hBitmap = CreateCompatibleBitmap(hScreenDC, RECTWIDTH(*lpRect), RECTHEIGHT(*lpRect));

    // select new bitmap into memory DC
    hOldBitmap = (HBITMAP)SelectObject(hDestDC, hBitmap);

    // Select the passed in BMP into the SrcDC
    hOldSrcBitmap = (HBITMAP)SelectObject(hSrcDC, hbm);
    
    // bitblt screen DC to memory DC
    BitBlt(hDestDC, 
           0, 
           0, 
           RECTWIDTH(*lpRect), 
           RECTHEIGHT(*lpRect), 
           hSrcDC, 
           lpRect->left, 
           lpRect->top, 
           SRCCOPY);

    pbmi =  CreateBitmapInfoStruct(hBitmap);
    bRet = CreateBMPFile(lpszFileName,  pbmi,  hBitmap, hDestDC);
    LocalFree(pbmi);
    
    // clean up 
    DeleteObject(SelectObject(hDestDC, hOldBitmap));
    SelectObject(hSrcDC, hOldSrcBitmap);

    DeleteDC(hSrcDC);
    DeleteDC(hDestDC);

    ReleaseDC(NULL, hScreenDC);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\dllentry.cpp ===
/*****************************************************************/
/**          Microsoft                                          **/
/**          Copyright (C) Microsoft Corp., 1991-1998           **/
/*****************************************************************/ 

//
//  DLLENTRY.CPP - 
//

//  HISTORY:
//  
//  05/14/98  donaldm   created
//

#include "pre.h"
#include "registry.h"
#include "webvwids.h"

// We encapsulate the control of this COM server (eg, lock and object
// counting) in a server control C++ object.  Here is it's pointer.
CServer* g_pServer = NULL;

const CLSID * aClassObjects[] = 
{
    &CLSID_ICWWEBVIEW,
    &CLSID_ICWWALKER,
    &CLSID_ICWGIFCONVERT,
    &CLSID_ICWISPDATA
};
#define NUM_CLASS_OBJECTS   sizeof(aClassObjects) / sizeof(aClassObjects[0])
#define MAX_ID_SIZE    100

const TCHAR acszFriendlyNames[][MAX_ID_SIZE] = 
{
    TEXT("CLSID_ICWWebView"),
    TEXT("CLSID_ICWWalker"),
    TEXT("CLSID_ICWGifConvert"),
    TEXT("CLSID_ICWISPData")
};

const TCHAR acszIndProgIDs[][MAX_ID_SIZE] = 
{
    TEXT("ICWCONN.WebView"),
    TEXT("ICWCONN.Walker"),
    TEXT("ICWCONN.GifConvert"),
    TEXT("ICWCONN.ISPData")
};

const TCHAR acszProgIDs[][MAX_ID_SIZE] = 
{
    TEXT("ICWCONN.WebView.1"),
    TEXT("ICWCONN.Walker.1"),
    TEXT("ICWCONN.GifConvert.1"),
    TEXT("ICWCONN.ISPData.1")
};

// instance handle must be in per-instance data segment
HINSTANCE           ghInstance=NULL;
INT                 _convert;               // For string conversion
const VARIANT       c_vaEmpty = {0};

void RegWebOCClass();

typedef UINT RETERR;

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    BOOL    bRet = TRUE;
    
    if(fdwReason == DLL_PROCESS_ATTACH)
    {
        bRet = FALSE;
        // Instantiate the CServer utility class.
        g_pServer = new CServer;
        if (NULL != g_pServer)
        {
            // Remember the DLL Instance handle.
            g_pServer->m_hDllInst = hInstDll;
    
            ghInstance = hInstDll;
        
            // Register the window class that will be used to embed web browser object into dialogs
            RegWebOCClass();
            
            bRet = TRUE;
        }            
    }
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if(g_pServer)
        {
            // We return S_OK of there are no longer any living objects AND
            // there are no outstanding client locks on this server.
            HRESULT hr = (0L==g_pServer->m_cObjects && 0L==g_pServer->m_cLocks) ? S_OK : S_FALSE;

            if(hr == S_OK)
                DELETE_POINTER(g_pServer);
        }        
    }
    return bRet;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus



///////////////////////////////////////////////////////////
//
// Exported functions
//
// These are the functions that COM expects to find
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    HRESULT hr = S_OK;

    if(g_pServer)
    {
        // We return S_OK of there are no longer any living objects AND
        // there are no outstanding client locks on this server.
        hr = (0L==g_pServer->m_cObjects && 0L==g_pServer->m_cLocks) ? S_OK : S_FALSE;

        if(hr == S_OK)
            DELETE_POINTER(g_pServer);
    }
    return hr;
}

//
// Get class factory
//
STDAPI DllGetClassObject
(   
    const CLSID& rclsid,
    const IID& riid,
    void** ppv
)
{
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject:\tCreate class factory.") ;

    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    IUnknown* pCob = NULL;

    hr = E_OUTOFMEMORY;
    pCob = new ClassFactory(g_pServer, &rclsid);
    
    if (NULL != pCob)
    {
        g_pServer->ObjectsUp();
        hr = pCob->QueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            g_pServer->ObjectsDown();
            DELETE_POINTER(pCob);
        }
    }

    return hr;
}


// The following two exported functions are what regsvr32 uses to
// self-register and unregister the dll.  See REGISTRY.CPP for
// actual implementation

//
// Server registration
//
STDAPI DllRegisterServer()
{
    BOOL    bRet = TRUE;
    
    for (int i = 0; i < NUM_CLASS_OBJECTS; i++)
    {    
        bRet = RegisterServer(ghInstance, 
                            *aClassObjects[i],
                            (LPTSTR)acszFriendlyNames[i],
                            (LPTSTR)acszIndProgIDs[i],
                            (LPTSTR)acszProgIDs[i]);
    }
    
    return (bRet ? S_OK : E_FAIL);                        
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    BOOL    bRet = TRUE;

    for (int i = 0; i < NUM_CLASS_OBJECTS; i++)
    {    
        bRet = UnregisterServer(*aClassObjects[i],
                              (LPTSTR)acszIndProgIDs[i],
                              (LPTSTR)acszProgIDs[i]);
    }
    return (bRet ? S_OK : E_FAIL);                        
}


//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\factory.cpp ===
/*****************************************************************/
/**          Microsoft                                          **/
/**          Copyright (C) Microsoft Corp., 1991-1998           **/
/*****************************************************************/ 

//
//  FACTORY.CPP - 
//

//  HISTORY:
//  
//  07/28/98  donaldm   created
//

#include "pre.h"
#include "webvwids.h"

/*---------------------------------------------------------------------------
  Implementation the ClassFactory Class Factory.  CFWebView is the COM
  object class for the Class Factory that can manufacture CLSID_ICWWEBVIEW
  COM Components.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
  Method:   ClassFactory::ClassFactory

  Summary:  
  Args:     
            CServer* pServer)
              Pointer to the server's control object.

  Modifies: m_cRefs

  Returns:  void
---------------------------------------------------------------------------*/
ClassFactory::ClassFactory
(
    CServer *       pServer,
    CLSID const*    pclsid
)
{
    // Zero the COM object's reference count.
    m_cRefs = 0;

    // Init the pointer to the server control object.
    m_pServer = pServer;

    // Keep track of the class type we need to create
    m_pclsid = pclsid;
    return;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::~ClassFactory

  Summary:  ClassFactory Destructor.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
ClassFactory::~ClassFactory(void)
{
    return;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::QueryInterface

  Summary:  QueryInterface of the ClassFactory non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            void ** ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
---------------------------------------------------------------------------*/
STDMETHODIMP ClassFactory::QueryInterface
(
    REFIID riid,
    void ** ppv
)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IID_IUnknown == riid)
    {
        *ppv = this;
    }
    else if (IID_IClassFactory == riid)
    {
        *ppv = static_cast<IClassFactory*>(this);
    }

    if (NULL != *ppv)
    {
        // We've handed out a pointer to the interface so obey the COM rules
        // and AddRef the reference count.
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = NOERROR;
    }

    return (hr);
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::AddRef

  Summary:  AddRef of the ClassFactory non-delegating IUnknown implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
---------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) ClassFactory::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::Release

  Summary:  Release of the ClassFactory non-delegating IUnknown implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
---------------------------------------------------------------------------*/
STDMETHODIMP_(ULONG) ClassFactory::Release(void)
{
    if (InterlockedDecrement(&m_cRefs) == 0)
    {
        // We've reached a zero reference count for this COM object.
        // So we tell the server housing to decrement its global object
        // count so that the server will be unloaded if appropriate.
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0 ;
    }
    TraceMsg(TF_CLASSFACTORY, "CFactory::Release %d", m_cRefs);
    return m_cRefs;
}

/*---------------------------------------------------------------------------
  Method:   ClassFactory::CreateInstance

  Summary:  The CreateInstance member method of this IClassFactory interface
            implementation.  Creates an instance of the CICWWebView COM
            component.

  Args:     IUnknown* pUnkOuter,
              [in] Pointer to the controlling IUnknown.
            REFIID riid,
              [in] GUID of the Interface being requested.
            void ** ppvCob)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code.
---------------------------------------------------------------------------*/
STDMETHODIMP ClassFactory::CreateInstance
(
    IUnknown* pUnkOuter,
    REFIID riid,
    void ** ppv
)
{
    HRESULT         hr = E_FAIL;
    IUnknown    *   pCob = NULL;

    // NULL the output pointer.
    *ppv = NULL;

    // We don't support aggregation
    if (NULL != pUnkOuter)
        hr = CLASS_E_NOAGGREGATION;
    else
    {
        // Instantiate a COM Object, based on the clsid requsted by GetClassObject
        if (IsEqualGUID(CLSID_ICWWEBVIEW, *m_pclsid))
            pCob = (IUnknown *) new CICWWebView(m_pServer);
        else if (IsEqualGUID(CLSID_ICWWALKER, *m_pclsid))
            pCob = (IUnknown *) new CICWWalker(m_pServer);
        else if (IsEqualGUID(CLSID_ICWGIFCONVERT, *m_pclsid))
            pCob = (IUnknown *) new CICWGifConvert(m_pServer);
        else if (IsEqualGUID(CLSID_ICWISPDATA, *m_pclsid))
            pCob = (IUnknown *) new CICWISPData(m_pServer);
        else
            pCob = NULL;
                    
        if (NULL != pCob)
        {
            // We initially created the new COM object so tell the server
            // to increment its global server object count to help ensure
            // that the server remains loaded until this partial creation
            // of a COM component is completed.
            m_pServer->ObjectsUp();

            // We QueryInterface this new COM Object not only to deposit the
            // main interface pointer to the caller's pointer variable, but to
            // also automatically bump the Reference Count on the new COM
            // Object after handing out this reference to it.
            hr = pCob->QueryInterface(riid, (void **)ppv);
            if (FAILED(hr))
            {
                m_pServer->ObjectsDown();
                delete pCob;
            }
        }
        else
             hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*---------------------------------------------------------------------------
  Method:   ClassFactory::LockServer

  Summary:  The LockServer member method of this IClassFactory interface
            implementation.

  Args:     BOOL fLock)
              [in] Flag determining whether to Lock or Unlock the server.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code.
---------------------------------------------------------------------------*/
STDMETHODIMP ClassFactory::LockServer
(
    BOOL fLock
)
{
    HRESULT hr = NOERROR;
    if (fLock)
        m_pServer->Lock();
    else
        m_pServer->Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\factory.h ===
//**********************************************************************
// File name: factory.h
//
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************


#if !defined(FACTORY_H)
#define FACTORY_H

#ifdef __cplusplus

/**********************************************************************
  ObjectClass: ClassFactory

  Summary:     
  Interfaces:  IUnknown
                 Standard interface providing COM object features.
               IClassFactory
                 Standard interface providing COM Class Factory features.

  Aggregation: 
**********************************************************************/
class ClassFactory : public IClassFactory
{
    public:
        // Main Object Constructor & Destructor.
        ClassFactory(CServer* pServer, CLSID const *);
        ~ClassFactory(void);

        // IUnknown methods. Main object, non-delegating.
        virtual STDMETHODIMP            QueryInterface(REFIID, void **);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // Interface IClassFactory
        virtual STDMETHODIMP            CreateInstance(IUnknown* pUnknownOuter,
                                                         const IID& iid,
                                                         void** ppv);
        virtual STDMETHODIMP            LockServer(BOOL bLock); 

    private:
        // Main Object reference count.
        LONG              m_cRefs;

        // Pointer to this component server's control object.
        CServer*          m_pServer;
        
        // CLSID of the COM object to create
        CLSID const*        m_pclsid;
};

typedef ClassFactory* PClassFactory;

#endif // __cplusplus


#endif // FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\icwutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  WIZARD.H - central header file for ICWCONN
//

//  HISTORY:
//  
//  05/14/98    donaldm     created it
//

#ifndef _ICWUTIL_H_
#define _ICWUTIL_H_

//Defs for tweaking HTML
#define MAX_COLOR_NAME  100
#define HTML_DEFAULT_BGCOLOR         TEXT("THREEDFACE")
#define HTML_DEFAULT_SPECIALBGCOLOR  TEXT("WINDOW")
#define HTML_DEFAULT_COLOR           TEXT("WINDOWTEXT")

//JACOB -- BUGBUG: duplicate defs. clean-up
#define MAX_RES_LEN         255 

extern HINSTANCE    ghInstance;
extern INT          _convert;               // For string conversion

extern const TCHAR cszEquals[];
extern const TCHAR cszAmpersand[];
extern const TCHAR cszPlus[];
extern const TCHAR cszQuestion[];

// Trace flags
#define TF_CLASSFACTORY     0x00000010
#define TF_CWEBVIEW         0x00000020

extern const VARIANT c_vaEmpty;
//
// BUGBUG: Remove this ugly const to non-const casting if we can
//  figure out how to put const in IDL files.
//
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

// String conversion in UTIL.CPP
LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCTSTR lpa, int nChars);
LPTSTR WINAPI W2AHelper(LPTSTR lpa, LPCWSTR lpw, int nChars);

#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper

#ifdef UNICODE
#define A2W(lpa) (LPTSTR)(lpa)
#define W2A(lpw) (lpw)
#else  // UNICODE
#define A2W(lpa) (\
        ((LPCTSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA((LPTSTR)lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), (LPTSTR)lpa, _convert)))

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // UNICODE

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCTSTR)W2A(lpw))

HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
);


#define DELETE_POINTER(p)\
{\
  if (NULL != p)\
  {\
    delete p;\
    p = NULL;\
  }\
}

void WINAPI URLEncode(TCHAR* pszUrl, size_t bsize);
void WINAPI URLAppendQueryPair
(
    LPTSTR   lpszQuery, 
    LPTSTR   lpszName, 
    LPTSTR   lpszValue
);


#endif // _ICWUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\gifcon.h ===
// GifConv.h : Declaration of the CGifConv
#ifndef __GIFCONV_H_
#define __GIFCONV_H_

#include <iimgctx.h>

#define     COLOR1              (RGB(0,0,255))
#define     COLOR2              (RGB(0,255,0))

struct ThreadData
{
    HANDLE hEvent;
    HANDLE hExitThreadEvent;
    IImgCtx * pImgCtx;
    LPCWSTR pszBuffer;
    HRESULT * pHr;
};

class CICWGifConvert : public IICWGifConvert
{

    public:
        // IICWGifConvert
        virtual HRESULT STDMETHODCALLTYPE GifToIcon(TCHAR * pszFile, UINT nIconSize, HICON* phIcon);
        virtual HRESULT STDMETHODCALLTYPE GifToBitmap(TCHAR * pszFile, HBITMAP* phBitmap);

        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWGifConvert(CServer * pServer);
        ~CICWGifConvert() {};
    
    
    private:
        DWORD  m_dwClrDepth;
        HRESULT SynchronousDownload (IImgCtx* pIImgCtx, BSTR bstrFile);
        HICON   ExtractImageIcon    (SIZE* pSize, IImgCtx* pIImgCtx);
        HRESULT CreateImageAndMask  (IImgCtx* pIImgCtx, HDC hdcScreen, SIZE * pSize, HBITMAP * phbmImage, HBITMAP * phbmMask);
        HRESULT StretchBltImage     (IImgCtx* pIImgCtx, const SIZE* pSize, HDC hdcDst);
        BOOL    ColorFill           (HDC hdc, const SIZE* pSize, COLORREF clr);
        HRESULT CreateMask          (IImgCtx* pIImgCtx, HDC hdcScreen, HDC hdc1, const SIZE * pSize, HBITMAP * phbMask);
        
        // Class object stuff
        LONG                m_lRefCount;
        // Pointer to this component server's control object.
        CServer*         m_pServer;
};

#endif //__GIFCONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\gifcon.cpp ===
// GifConv.cpp : Implementation of CICWGifConvert

#include "pre.h"
#include "webvwids.h"

/////////////////////////////////////////////////////////////////////////////
// CICWGifConvert

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert:CICWGifConvert
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWGifConvert::CICWGifConvert
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWGifConvert constructor called");
    m_lRefCount = 0;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWGifConvert::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_CWEBVIEW, "CICWGifConvert::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWGifConvert
    if (IID_IICWGifConvert == riid)
        *ppv = (void *)(IICWGifConvert *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWGifConvert::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWGifConvert::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWGifConvert::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWGifConvert::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWGifConvert::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}

void  CALLBACK ImgCtx_Callback(void * pIImgCtx, void* pfDone);

HRESULT CICWGifConvert::GifToBitmap(TCHAR * pszFile, HBITMAP* phBitmap)
{
    HRESULT hr  = E_FAIL; //don't assume success
    ULONG fState;
    SIZE sz;
    IImgCtx* pIImgCtx;

    BSTR bstrFile = A2W(pszFile);

    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                              IID_IImgCtx, (void**)&pIImgCtx);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pIImgCtx);

        hr = SynchronousDownload(pIImgCtx, bstrFile);
        pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIImgCtx);

            HDC hdcScreen = GetDC(NULL);

            if (hdcScreen)
            {
                *phBitmap = CreateCompatibleBitmap(hdcScreen, sz.cx, sz.cy);

                if (*phBitmap)
                {
                    HDC hdcImgDst = CreateCompatibleDC(NULL);
                    if (hdcImgDst)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcImgDst, *phBitmap);
                        if (hbmOld)
                        {
                            hr = StretchBltImage(pIImgCtx, &sz, hdcImgDst);
                            SelectObject(hdcImgDst, hbmOld);
                        }
                        DeleteDC(hdcImgDst);
                    }
                }
                ReleaseDC(NULL, hdcScreen);
            }
        }

        pIImgCtx->Release();
    }

    if (bCoInit)
        CoUninitialize();

    return hr;
}


HRESULT CICWGifConvert::GifToIcon(TCHAR * pszFile, UINT nIconSize, HICON* phIcon)
{
    HRESULT hr  = E_FAIL; //don't assume success
    
    SIZE Size;
    if (0 != nIconSize)
    {
        Size.cx = nIconSize;
        Size.cy = nIconSize;
    }
    
    IImgCtx* pIImgCtx;

    ULONG fState;

    BSTR bstrFile = A2W(pszFile);

    hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                          IID_IImgCtx, (void**)&pIImgCtx);

    BOOL bCoInit = FALSE;

    if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoInit = TRUE;
        hr = CoCreateInstance(CLSID_IImgCtx, NULL, CLSCTX_INPROC_SERVER,
                              IID_IImgCtx, (void**)&pIImgCtx);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(pIImgCtx);

        hr = SynchronousDownload(pIImgCtx, bstrFile);
        if (0 == nIconSize)
        {
            pIImgCtx->GetStateInfo(&fState, &Size, TRUE);
        }

        if (SUCCEEDED(hr))
        {

            *phIcon = ExtractImageIcon(&Size, pIImgCtx);

        }

        pIImgCtx->Release();
    }

    if (bCoInit)
        CoUninitialize();

    return hr;
}

HRESULT CICWGifConvert::SynchronousDownload(IImgCtx* pIImgCtx, BSTR bstrFile)
{
    ASSERT(pIImgCtx);

    HRESULT hr;

    hr = pIImgCtx->Load(bstrFile, 0);

    if (SUCCEEDED(hr))
    {
        ULONG fState;
        SIZE  sz;

        pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        if (!(fState & (IMGLOAD_COMPLETE | IMGLOAD_ERROR)))
        {
            BOOL fDone = FALSE;

            hr = pIImgCtx->SetCallback(ImgCtx_Callback, &fDone);

            if (SUCCEEDED(hr))
            {
                hr = pIImgCtx->SelectChanges(IMGCHG_COMPLETE, 0, TRUE);

                if (SUCCEEDED(hr))
                {
                    MSG msg;
                    BOOL fMsg;

                    // HACK: restrict the message pump to those messages we know that URLMON and
                    // HACK: the imageCtx stuff needs, otherwise we will be pumping messages for
                    // HACK: windows we shouldn't be pumping right now...
                    while(!fDone )
                    {
                        fMsg = PeekMessage(&msg, NULL, WM_USER + 1, WM_USER + 4, PM_REMOVE );

                        if (!fMsg)
                            fMsg = PeekMessage( &msg, NULL, WM_APP + 2, WM_APP + 2, PM_REMOVE );
                        if (!fMsg)
                        {
                            // go to sleep until we get a new message....
                            WaitMessage();
                            continue;
                        }
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            pIImgCtx->Disconnect();
        }
        hr = pIImgCtx->GetStateInfo(&fState, &sz, TRUE);

        if (SUCCEEDED(hr))
            hr = (fState & IMGLOAD_COMPLETE) ? S_OK : E_FAIL;
    }
    return hr;
}

HICON CICWGifConvert::ExtractImageIcon(SIZE* pSize, IImgCtx * pIImgCtx)
{
    ASSERT(pIImgCtx);

    HICON hiconRet = NULL;

    HDC hdcScreen = GetDC(NULL);

    if (hdcScreen)
    {
        HBITMAP hbmImage = CreateCompatibleBitmap(hdcScreen, pSize->cx, pSize->cy);

        if (hbmImage)
        {
            HBITMAP hbmMask = CreateBitmap(pSize->cx, pSize->cy, 1, 1, NULL);

            if (hbmMask)
            {
                SIZE sz;
                sz.cx = pSize->cx;
                sz.cy = pSize->cy;

                if (SUCCEEDED(CreateImageAndMask(pIImgCtx, hdcScreen, &sz,
                                                 &hbmImage, &hbmMask)))
                {
                    ICONINFO ii;

                    ii.fIcon    = TRUE;
                    ii.hbmMask  = hbmMask;
                    ii.hbmColor = hbmImage;

                    hiconRet = CreateIconIndirect(&ii); 
                }
                DeleteObject(hbmMask);
            }
            DeleteObject(hbmImage);
        }
        ReleaseDC(NULL, hdcScreen);
    }
    return hiconRet;
}

HRESULT CICWGifConvert::CreateImageAndMask(IImgCtx * pIImgCtx, 
                                     HDC hdcScreen, 
                                     SIZE * pSize, 
                                     HBITMAP * phbmImage, 
                                     HBITMAP * phbmMask)
{
    ASSERT(pIImgCtx);
    ASSERT(phbmImage);
    ASSERT(phbmMask);

    HRESULT hr = E_FAIL;

    HDC hdcImgDst = CreateCompatibleDC(NULL);
    if (hdcImgDst)
    {
        HGDIOBJ hbmOld = SelectObject(hdcImgDst, *phbmImage);
        if (hbmOld)
        {
            if (ColorFill(hdcImgDst, pSize, COLOR1))
            {
                hr = StretchBltImage(pIImgCtx, pSize, hdcImgDst);

                if (SUCCEEDED(hr))
                {
                    hr = CreateMask(pIImgCtx, hdcScreen, hdcImgDst, pSize,
                                    phbmMask); 
                }
            }
            SelectObject(hdcImgDst, hbmOld);
        }
        DeleteDC(hdcImgDst);
    }
    return hr;
}


HRESULT CICWGifConvert::StretchBltImage(IImgCtx * pIImgCtx, const SIZE * pSize, HDC hdcDst)
{
    ASSERT(pIImgCtx);
    ASSERT(hdcDst);

    HRESULT hr;

    SIZE    sz;
    ULONG   fState;

    hr = pIImgCtx->GetStateInfo(&fState, &sz, FALSE);

    if (SUCCEEDED(hr))
    {
        hr = pIImgCtx->StretchBlt(hdcDst, 0, 0, pSize->cx, pSize->cy, 0, 0,
                                  sz.cx, sz.cy, SRCCOPY);
        ASSERT(SUCCEEDED(hr) && "Icon extraction pIImgCtx->StretchBlt failed!");
    }

    return hr;
}

HRESULT CICWGifConvert::CreateMask(IImgCtx * pIImgCtx, HDC hdcScreen, HDC hdc1, const SIZE * pSize, HBITMAP * phbMask)
{
    ASSERT(hdc1);
    ASSERT(pSize);
    ASSERT(phbMask);

    HRESULT hr = E_FAIL;

    HDC hdc2 = CreateCompatibleDC(NULL);
    if (hdc2)
    {
        HBITMAP hbm2 = CreateCompatibleBitmap(hdcScreen, pSize->cx, pSize->cy);
        if (hbm2)
        {
            HGDIOBJ hbmOld2 = SelectObject(hdc2, hbm2);
            if (hbmOld2)
            {
                ColorFill(hdc2, pSize, COLOR2);

                hr = StretchBltImage(pIImgCtx, pSize, hdc2);

                if (SUCCEEDED(hr) &&
                    BitBlt(hdc2, 0, 0, pSize->cx, pSize->cy, hdc1, 0, 0,
                           SRCINVERT))
                {
                    if (GetDeviceCaps(hdcScreen, BITSPIXEL) <= 8)
                    {
                        //
                        // 6 is the XOR of the index for COLOR1 and the index
                        // for COLOR2.
                        //
                        SetBkColor(hdc2, PALETTEINDEX(6));
                    }
                    else
                    {
                        SetBkColor(hdc2, (COLORREF)(COLOR1 ^ COLOR2));
                    }

                    HDC hdcMask = CreateCompatibleDC(NULL);
                    if (hdcMask)
                    {
                        HGDIOBJ hbmOld = SelectObject(hdcMask, *phbMask);
                        if (hbmOld)
                        {
                            if (BitBlt(hdcMask, 0, 0, pSize->cx, pSize->cy, hdc2, 0,
                                       0, SRCCOPY))
                            {
                                //
                                // RasterOP 0x00220326 does a copy of the ~mask bits
                                // of hdc1 and sets everything else to 0 (Black).
                                //

                                if (BitBlt(hdc1, 0, 0, pSize->cx, pSize->cy, hdcMask,
                                           0, 0, 0x00220326))
                                {
                                    hr = S_OK;
                                }
                            }
                            SelectObject(hdcMask, hbmOld);
                        }
                        DeleteDC(hdcMask);
                    }
                }
                SelectObject(hdc2, hbmOld2);
            }
            DeleteObject(hbm2);
        }
        DeleteDC(hdc2);
    }
    return hr;
}

BOOL CICWGifConvert::ColorFill(HDC hdc, const SIZE * pSize, COLORREF clr)
{
    ASSERT(hdc);

    BOOL fRet = FALSE;

    HBRUSH hbSolid = CreateSolidBrush(clr);
    if (hbSolid)
    {
        HGDIOBJ hbOld = SelectObject(hdc, hbSolid);
        if (hbOld)
        {
            PatBlt(hdc, 0, 0, pSize->cx, pSize->cy, PATCOPY);
            fRet = TRUE;

            SelectObject(hdc, hbOld);
        }
        DeleteObject(hbSolid);
    }
    return fRet;
}

void CALLBACK ImgCtx_Callback(void* pIImgCtx,void* pfDone)
{
    ASSERT(pfDone);

    *(BOOL*)pfDone = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\icwwebvw.h ===
class CICWWebView : public IICWWebView
{
    public:
        CICWWebView (CServer* pServer);
       ~CICWWebView (void);
        
        // IICWWebView
        virtual HRESULT STDMETHODCALLTYPE HandleKey               (LPMSG lpMsg);
        virtual HRESULT STDMETHODCALLTYPE SetFocus                (void);
        virtual HRESULT STDMETHODCALLTYPE ConnectToWindow         (HWND hWnd, DWORD dwHtmPageType);
#ifndef UNICODE
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML             (TCHAR * lpszURL);
#endif
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML             (BSTR bstrURL);
        virtual HRESULT STDMETHODCALLTYPE SetHTMLColors           (LPTSTR lpszForeground, LPTSTR lpszBackground);
        virtual HRESULT STDMETHODCALLTYPE SetHTMLBackgroundBitmap (HBITMAP hbm, LPRECT lpRC);
        virtual HRESULT STDMETHODCALLTYPE get_BrowserObject       (IWebBrowser2 **lpWebBrowser);
        
        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef         (void);
        virtual ULONG   STDMETHODCALLTYPE Release        (void);

        //public members
        COleSite FAR* m_lpOleSite; // Each instance of the ICWWebView object will need an OLE site
     
    private:
        LONG      m_lRefCount;
        IUnknown* m_pUnkOuter;       // Outer unknown (aggregation & delegation).
        CServer*  m_pServer;         // Pointer to this component server's control object.
        BOOL      m_bUseBkGndBitmap;
        HBITMAP   m_hBkGrndBitmap;
        RECT      m_rcBkGrnd;
        TCHAR     m_szBkGrndColor   [MAX_COLOR_NAME];
        TCHAR     m_szForeGrndColor [MAX_COLOR_NAME];

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\icwwebvw.cpp ===
/****************************************************************************
 *
 *  ICWWEBVW.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWApprentice class.
 *
 *  07/22/98     donaldm     adapted from ICWCONNN
 *
 ***************************************************************************/

#include "pre.h"
#include "initguid.h"
#include "webvwids.h"

#define VK_N 'N'
#define VK_P 'P'

HRESULT CICWWebView::get_BrowserObject
(
    IWebBrowser2 **lpWebBrowser
)
{
    ASSERT(m_lpOleSite);

    *lpWebBrowser = m_lpOleSite->m_lpWebBrowser;
    
    return S_OK;
}

HRESULT CICWWebView::ConnectToWindow
(
    HWND    hWnd,
    DWORD   dwHtmPageType
)
{
    ASSERT(m_lpOleSite);
    
    // Set the window long to be this object pointer, since it will be used by the 
    // wnd proc, assuming it is a WebOC class window attaching
    SetWindowLongPtr(hWnd,GWLP_USERDATA,(LPARAM) this);

    m_lpOleSite->ConnectBrowserObjectToWindow(hWnd, 
                                              dwHtmPageType, 
                                              m_bUseBkGndBitmap,
                                              m_hBkGrndBitmap,
                                              &m_rcBkGrnd,
                                              m_szBkGrndColor,
                                              m_szForeGrndColor);
    
    return S_OK;
}

#ifndef UNICODE
HRESULT CICWWebView::DisplayHTML
(
    TCHAR * lpszURL
)
{
    BSTR            bstrURL;
    
    ASSERT(m_lpOleSite);

    // Convert to a BSTR for the call to the web browser object
    bstrURL = A2W(lpszURL);

    // Navigate the Webbrowser object to the requested page
    return (m_lpOleSite->m_lpWebBrowser->Navigate(bstrURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY));
}
#endif

HRESULT CICWWebView::DisplayHTML
(
    BSTR            bstrURL
)
{
    ASSERT(m_lpOleSite);


    // Navigate the Webbrowser object to the requested page
    return (m_lpOleSite->m_lpWebBrowser->Navigate(bstrURL, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY));
}

HRESULT CICWWebView::SetHTMLColors
(
    LPTSTR  lpszForeground,
    LPTSTR  lpszBackground
)
{
    if (NULL == lpszForeground || ('\0' == lpszForeground[0]))
    {
        lstrcpyn(m_szForeGrndColor, HTML_DEFAULT_COLOR, MAX_COLOR_NAME);
    }
    else
    {
        lstrcpyn(m_szForeGrndColor, lpszForeground, MAX_COLOR_NAME);
    }   
    
    if (NULL == lpszBackground || ('\0' == lpszBackground[0]))
    {
        lstrcpyn(m_szBkGrndColor, HTML_DEFAULT_BGCOLOR, MAX_COLOR_NAME);
    }
    else
    {
        lstrcpyn(m_szBkGrndColor, lpszBackground, MAX_COLOR_NAME);
    }   
         
    return S_OK;
}

HRESULT CICWWebView::SetHTMLBackgroundBitmap
(
    HBITMAP hbm, 
    LPRECT lpRC
)
{
    if (NULL != hbm)
    {
        m_hBkGrndBitmap = hbm;
        CopyRect(&m_rcBkGrnd, lpRC);
        m_bUseBkGndBitmap = TRUE;
    }
    else
    {
        m_hBkGrndBitmap = NULL;
        m_bUseBkGndBitmap = FALSE;
    }  
    return S_OK;              
}

HRESULT CICWWebView::HandleKey
(
    LPMSG lpMsg
)
{
    HRESULT hr = E_FAIL;
    ASSERT(m_lpOleSite);

    switch(lpMsg->message)
    {
        case WM_KEYDOWN:
        {
            //needed to disable certain default IE hot key combos. like launching a new browser window.
            if  ((lpMsg->wParam == VK_RETURN) || (lpMsg->wParam == VK_F5) || (((lpMsg->wParam == VK_N) || (lpMsg->wParam == VK_P) ) && (GetKeyState(VK_CONTROL) & 0x1000)))
                break;
        }
        default:
        {
            if(m_lpOleSite->m_lpWebBrowser)
            {
                IOleInPlaceActiveObject* lpIPA;
       
                if(SUCCEEDED(m_lpOleSite->m_lpWebBrowser->QueryInterface(IID_IOleInPlaceActiveObject,(void**)&lpIPA)))
                {
                    hr = lpIPA->TranslateAccelerator(lpMsg);
           
                    lpIPA->Release();
               }
            }
            break;
        }
    }
    return (hr);
}

HRESULT CICWWebView::SetFocus
(
    void
)       
{ 
    if(m_lpOleSite->m_lpInPlaceObject && !m_lpOleSite->m_fInPlaceActive)
    {
        m_lpOleSite->InPlaceActivate();
        m_lpOleSite->UIActivate();
    }

    m_lpOleSite->SetFocusToHtmlPage();       

    return S_OK;
}    

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWWebView::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWWebView
    if (IID_IICWWebView == riid)
        *ppv = (void *)(IICWWebView *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWWebView::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWWebView::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWWebView::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::CICWWebView
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWWebView::CICWWebView
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView constructor called");
    m_lRefCount = 0;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
    
    m_bUseBkGndBitmap = FALSE;
    lstrcpyn(m_szBkGrndColor, HTML_DEFAULT_BGCOLOR, MAX_COLOR_NAME);
    lstrcpyn(m_szForeGrndColor, HTML_DEFAULT_COLOR, MAX_COLOR_NAME);
    
    // Create a new OLE site, which will create an instance of the WebBrowser
    m_lpOleSite = new COleSite();
    if (m_lpOleSite)
        m_lpOleSite->CreateBrowserObject();
}


//+----------------------------------------------------------------------------
//
//  Function    CICWWebView::~CICWWebView
//
//  Synopsis    This is the destructor.  We want to clean up all the memory
//              we allocated in ::Initialize
//
//-----------------------------------------------------------------------------
CICWWebView::~CICWWebView( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWebView destructor called with ref count of %d", m_lRefCount);
    
    if (m_lpOleSite)
    {
        m_lpOleSite->Release();
        delete m_lpOleSite;
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\iocs.cpp ===
//**********************************************************************
// File name: IOCS.CPP
//
//      Implementation file for COleClientSite
//
// Functions:
//
//      See IOCS.H for class definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"


//**********************************************************************
//
// COleClientSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at this interface
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK                -   The interface is supported.
//      E_NOINTERFACE       -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      COleClientSite::QueryInterface SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TraceMsg(TF_GENERAL, "In IOCS::QueryInterface\r\n");

    // delegate to the container Site
    return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CConnWizApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************
STDMETHODIMP_(ULONG) COleClientSite::AddRef()
{
    TraceMsg(TF_GENERAL, "In IOCS::AddRef\r\n");

    // increment the interface reference count (for debugging only)
    ++m_nCount;

    // delegate to the container Site
    return m_pSite->AddRef();
}


//**********************************************************************
//
// CConnWizApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************
STDMETHODIMP_(ULONG) COleClientSite::Release()
{
    TraceMsg(TF_GENERAL, "In IOCS::Release\r\n");

    // decrement the interface reference count (for debugging only)
    --m_nCount;

    // delegate to the container Site
    return m_pSite->Release();
}

//**********************************************************************
//
// COleClientSite::SaveObject
//
// Purpose:
//
//      Called by the object when it wants to be saved to persistant
//      storage
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
//********************************************************************
STDMETHODIMP COleClientSite::SaveObject()
{
    TraceMsg(TF_GENERAL, "In IOCS::SaveObject\r\n");
    return (S_OK);
}

//**********************************************************************
//
// COleClientSite::GetMoniker
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    TraceMsg(TF_GENERAL, "In IOCS::GetMoniker\r\n");

    // need to null the out pointer
    *ppmk = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::GetContainer
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    TraceMsg(TF_GENERAL, "In IOCS::GetContainer\r\n");

    // NULL the out pointer
    *ppContainer = NULL;

    return ResultFromScode(E_NOTIMPL);
}

//**********************************************************************
//
// COleClientSite::ShowObject
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      This function is not implemented because we don't support
//      linking.
//
//********************************************************************

STDMETHODIMP COleClientSite::ShowObject()
{
    TraceMsg(TF_GENERAL, "In IOCS::ShowObject\r\n");
    return NOERROR;
}

//**********************************************************************
//
// COleClientSite::OnShowWindow
//
// Purpose:
//
//      Object calls this method when it is opening/closing non-InPlace
//      Window
//
// Parameters:
//
//      BOOL fShow  - TRUE if Window is opening, FALSE if closing
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      InvalidateRect              Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleClientSite::OnShowWindow(BOOL fShow)
{
    TraceMsg(TF_GENERAL, "In IOCS::OnShowWindow\r\n");
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleClientSite::RequestNewObjectLayout
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleClientSite::RequestNewObjectLayout()
{
    TraceMsg(TF_GENERAL, "In IOCS::RequestNewObjectLayout\r\n");
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\icwwalk.cpp ===
/****************************************************************************
 *
 *  ICWWALK.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWWalker class.
 *
 *  07/22/98     donaldm     adapted from ICWCONNN
 *
 ***************************************************************************/

#include "pre.h"
#include "webvwids.h"

HRESULT CICWWalker::Walk()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->Walk();
        
    return (hr);        
}

HRESULT CICWWalker::AttachToDocument(IWebBrowser2 *lpWebBrowser)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->AttachToDocument(lpWebBrowser);
        
    return (hr);        
}

HRESULT CICWWalker::ExtractUnHiddenText(BSTR* pbstrText)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->ExtractUnHiddenText(pbstrText);
        
    return (hr);        
}

HRESULT CICWWalker::AttachToMSHTML(BSTR bstrURL)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->AttachToMSHTML(bstrURL);
        
    return (hr);        
}

HRESULT CICWWalker::Detach()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->Detach();
        
    return (hr);        
}

HRESULT CICWWalker::InitForMSHTML()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->InitForMSHTML();
        
    return (hr);        
}

HRESULT CICWWalker::TermForMSHTML()
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->TermForMSHTML();
        
    return (hr);        
}

HRESULT CICWWalker::LoadURLFromFile(BSTR bstrURL)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->LoadURLFromFile(bstrURL);
        
    return (hr);        
}

HRESULT CICWWalker::get_IsQuickFinish(BOOL* pbIsQuickFinish)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_IsQuickFinish(pbIsQuickFinish);
        
    return (hr);        
}

HRESULT CICWWalker::get_PageType(LPDWORD pdwPageType)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_PageType(pdwPageType);
        
    return (hr);        
}

HRESULT CICWWalker::get_PageFlag(LPDWORD pdwPageFlag)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_PageFlag(pdwPageFlag);
        
    return (hr);        
}

HRESULT CICWWalker::get_PageID(BSTR *pbstrPageID)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_PageID(pbstrPageID);
        
    return (hr);        
}

HRESULT CICWWalker::get_URL(LPTSTR lpszURL, BOOL bForward)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_URL(lpszURL, bForward);
        
    return (hr);        
}

HRESULT CICWWalker::get_IeakIspFile(LPTSTR lpszIspFile)
{
    ASSERT(m_pHTMLWalker);

    m_pHTMLWalker->get_IeakIspFile(lpszIspFile);
    
    return S_OK;
}

HRESULT CICWWalker::ProcessOLSFile(IWebBrowser2* lpWebBrowser)
{
    ASSERT(m_pHTMLWalker);

    m_pHTMLWalker->ProcessOLSFile(lpWebBrowser);
    
    return S_OK;
}



HRESULT CICWWalker::get_FirstFormQueryString(LPTSTR  lpszQuery)
{
    HRESULT hr = E_FAIL;
    if (m_pHTMLWalker)
        hr = m_pHTMLWalker->get_FirstFormQueryString(lpszQuery);
        
    return (hr);        
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, ...
//
//
//-----------------------------------------------------------------------------
HRESULT CICWWalker::QueryInterface
( 
    REFIID riid, void** ppv 
)
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWWalker
    if (IID_IICWWalker == riid)
        *ppv = (void *)(IICWWalker *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWWalker::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalk::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWWalker::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWWalker::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}

//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::CICWWalker
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWWalker::CICWWalker
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker constructor called");
    m_lRefCount = 0;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
    
    // Create a new Walker object
    m_pHTMLWalker = new CWalker();
}


//+----------------------------------------------------------------------------
//
//  Function    CICWWalker::~CICWWalker
//
//  Synopsis    This is the destructor.  We want to clean up all the memory
//              we allocated in ::Initialize
//
//-----------------------------------------------------------------------------
CICWWalker::~CICWWalker( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWWalker destructor called with ref count of %d", m_lRefCount);
    
    if (m_pHTMLWalker)
    {
        m_pHTMLWalker->Release();
        m_pHTMLWalker = NULL;
    }        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\icwwalk.h ===
class CICWWalker : public IICWWalker
{
    public:
        // IICWWalker
        virtual HRESULT STDMETHODCALLTYPE Walk();
        virtual HRESULT STDMETHODCALLTYPE AttachToDocument         (IWebBrowser2* lpWebBrowser);
        virtual HRESULT STDMETHODCALLTYPE AttachToMSHTML           (BSTR bstrURL);
        virtual HRESULT STDMETHODCALLTYPE ExtractUnHiddenText      (BSTR* pbstrText);
        virtual HRESULT STDMETHODCALLTYPE Detach                   ();
        virtual HRESULT STDMETHODCALLTYPE InitForMSHTML            ();
        virtual HRESULT STDMETHODCALLTYPE TermForMSHTML            ();
        virtual HRESULT STDMETHODCALLTYPE LoadURLFromFile          (BSTR bstrURL);
        virtual HRESULT STDMETHODCALLTYPE ProcessOLSFile           (IWebBrowser2* lpWebBrowser);
        virtual HRESULT STDMETHODCALLTYPE get_PageType             (LPDWORD pdwPageType);
        virtual HRESULT STDMETHODCALLTYPE get_IsQuickFinish        (BOOL* pbIsQuickFinish);
        virtual HRESULT STDMETHODCALLTYPE get_PageFlag             (LPDWORD pdwPageFlag);
        virtual HRESULT STDMETHODCALLTYPE get_PageID               (BSTR* pbstrPageID);
        virtual HRESULT STDMETHODCALLTYPE get_URL                  (LPTSTR lpszURL, BOOL bForward);
        virtual HRESULT STDMETHODCALLTYPE get_FirstFormQueryString (LPTSTR lpszQuery);
        virtual HRESULT STDMETHODCALLTYPE get_IeakIspFile          (LPTSTR lpszIspFile);

        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface (REFIID theGUID, void** retPtr);
        virtual ULONG   STDMETHODCALLTYPE AddRef         (void);
        virtual ULONG   STDMETHODCALLTYPE Release        (void);

        CICWWalker  (CServer* pServer);
        ~CICWWalker (void);

        // Each instance of the ICWWalker object will need a walker object (it does the work)
        CWalker* m_pHTMLWalker;
        
    private:
        LONG      m_lRefCount;        
        IUnknown* m_pUnkOuter; // Outer unknown (aggregation & delegation).
        CServer*  m_pServer;   // Pointer to this component server's control object.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\ioipf.h ===
//**********************************************************************
// File name: IOIPF.H
//
//      Definition of COleInPlaceFrame
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPF_H_ )
#define _IOIPF_H_


// Use the SITE as the frame
class COleSite;

interface COleInPlaceFrame : public IOleInPlaceFrame
{
    int m_nCount;
    COleSite FAR * m_pSite;

    COleInPlaceFrame(COleSite FAR * pSite) {
        m_pSite = pSite;
        m_nCount = 0;
        };

    ~COleInPlaceFrame() {
        assert(m_nCount == 0);
        };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceUIWindow methods ***
    STDMETHODIMP GetBorder (LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths);
    STDMETHODIMP SetBorderSpace (LPCBORDERWIDTHS lpborderwidths);
  //@@WTK WIN32, UNICODE
    //STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCSTR lpszObjName);
    STDMETHODIMP SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCOLESTR lpszObjName);

    // *** IOleInPlaceFrame methods ***
    STDMETHODIMP InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus (HMENU hmenuShared);
  //@@WTK WIN32, UNICODE
    //STDMETHODIMP SetStatusText (LPCSTR lpszStatusText);
    STDMETHODIMP SetStatusText (LPCOLESTR lpszStatusText);
    STDMETHODIMP EnableModeless (BOOL fEnable);
    STDMETHODIMP TranslateAccelerator (LPMSG lpmsg, WORD wID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\iocs.h ===
//**********************************************************************
// File name: IOCS.H
//
//      Definition of COleClientSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOCS_H_ )
#define _IOCS_H_

#include <assert.h>

class COleSite;

interface COleClientSite : public IOleClientSite
{
    int m_nCount;
    COleSite FAR * m_pSite;

    COleClientSite(COleSite FAR * pSite) {
        m_pSite = pSite;
        m_nCount = 0;
        }

    ~COleClientSite() {
        assert(m_nCount == 0);
        }

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleClientSite methods ***
    STDMETHODIMP SaveObject();
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk);
    STDMETHODIMP GetContainer(LPOLECONTAINER FAR* ppContainer);
    STDMETHODIMP ShowObject();
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\ioipf.cpp ===
//**********************************************************************
// File name: IOIPF.CPP
//
//      Implementation file for COleInPlaceFrame
//
// Functions:
//
//      See IOIPF.H for class definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"


//**********************************************************************
//
// CConnWizApp::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the Interface level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      CConnWizApp::QueryInterface  APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TraceMsg(TF_GENERAL, "In IOIPF::QueryInterface\r\n");

// delegate to the document Object
        return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CConnWizApp::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::AddRef()
{
    TraceMsg(TF_GENERAL, "In IOIPF::AddRef\r\n");

    // delegate to the document Object
    m_pSite->AddRef();
    
    // increment the interface reference count
    return ++m_nCount;
}

//**********************************************************************
//
// CConnWizApp::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      CConnWizApp::Release         APP.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceFrame::Release()
{
    TraceMsg(TF_GENERAL, "In IOIPF::Release\r\n");

    // delegate to the document object
    m_pSite->Release();

    // decrement the interface reference count
    return --m_nCount;
}

//**********************************************************************
//
// COleInPlaceFrame::GetWindow
//
// Purpose:
//
//      Returns the frame window handle
//
// Parameters:
//
//      HWND FAR* lphwnd    - Location to return the window handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetWindow (HWND FAR* lphwnd)
{
    TraceMsg(TF_GENERAL, "In IOIPF::GetWindow\r\n");
    
    *lphwnd = m_pSite->m_hWnd;
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::ContextSensitiveHelp
//
// Purpose:
//
//      Used in implementing Context sensitive help
//
// Parameters:
//
//      BOOL fEnterMode -   TRUE if starting Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes in the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::ContextSensitiveHelp (BOOL fEnterMode)
{
    TraceMsg(TF_GENERAL, "In IOIPF::ContextSensitiveHelp\r\n");

    return ResultFromScode(S_OK);
}
//**********************************************************************
//
// COleInPlaceFrame::GetBorder
//
// Purpose:
//
//      Returns the outermost border that frame adornments can be attached
//      during InPlace Activation.
//
// Parameters:
//
//      LPRECT lprectBorder - return parameter to contain the outermost
//                            rect for frame adornments
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      GetClientRect               Windows API
//      CopyRect                    Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::GetBorder (LPRECT lprectBorder)
{
    RECT rect;

    TraceMsg(TF_GENERAL, "In IOIPF::GetBorder\r\n");

    // get the rect for the entire frame.
    GetClientRect(m_pSite->m_hWnd, &rect);

    CopyRect(lprectBorder, &rect);

    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::RequestBorderSpace
//
// Purpose:
//
//      Approves/Denies requests for border space during InPlace
//      negotiation.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - The width in pixels needed on
//                                        each side of the frame.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      This implementation doesn't care about how much border space
//      is used.  It always returns S_OK.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RequestBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{
    TraceMsg(TF_GENERAL, "In IOIPF::RequestBorderSpace\r\n");

    // always approve the request
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetBorderSpace
//
// Purpose:
//
//      The object calls this method when it is actually going to
//      start using the border space.
//
// Parameters:
//
//      LPCBORDERWIDTHS lpborderwidths  - Border space actually being used
//                                        by the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                        Location
//
//      CConnWizApp::AddFrameLevelTools  APP.CPP
//      GetClientRect                   Windows API
//      MoveWindow                      Windows API
//      ResultFromScode                 Windows API
//
// Comments:
//
//      This routine could be a little smarter and check to see if
//      the object is requesting the entire client area of the
//      window.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetBorderSpace (LPCBORDERWIDTHS lpborderwidths)
{

    TraceMsg(TF_GENERAL, "In IOIPF::SetBorderSpace\r\n");
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetActiveObject
//
// Purpose:
//
//
// Parameters:
//
//      LPOLEINPLACEACTIVEOBJECT lpActiveObject     -   Pointer to the
//                                                      objects
//                                                      IOleInPlaceActiveObject
//                                                      interface
//
//@@WTK WIN32, UNICODE
//      //LPCSTR lpszObjName                          -   Name of the object
//      LPCOLESTR lpszObjName                          -   Name of the object
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      IOleInPlaceActiveObject::AddRef     Object
//      IOleInPlaceActiveObject::Release    Object
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

//@@WTK WIN32, UNICODE
//STDMETHODIMP COleInPlaceFrame::SetActiveObject (LPOLEINPLACEACTIVEOBJECT lpActiveObject,LPCSTR lpszObjName)
STDMETHODIMP COleInPlaceFrame::SetActiveObject (
LPOLEINPLACEACTIVEOBJECT lpActiveObject,
LPCOLESTR lpszObjName)
{
    TraceMsg(TF_GENERAL, "In IOIPF::SetActiveObject\r\n");
    return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::InsertMenus
//
// Purpose:
//
//      Inserts the container menu into the combined menu
//
// Parameters:
//
//      HMENU hmenuShared                   -   Menu Handle to be set.
//      LPOLEMENUGROUPWIDTHS lpMenuWidths   -   Width of menus
//
// Return Value:
//
// Function Calls:
//      Function                    Location
//
//      AppendMenu                  Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::InsertMenus (HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
        TraceMsg(TF_GENERAL, "In IOIPF::InsertMenus\r\n");
        return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::SetMenu
//
// Purpose:
//
//      Sets the application menu to the combined menu
//
// Parameters:
//
//      HMENU hmenuShared       - The combined menu
//
//      HOLEMENU holemenu       - Used by OLE
//
//      HWND hwndActiveObject   - Used by OLE
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      SetMenu                     Windows API
//      OleSetMenuDescriptor        OLE API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::SetMenu (HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{

        TraceMsg(TF_GENERAL, "In IOIPF::SetMenu\r\n");
        return ResultFromScode(S_OK);
}


//**********************************************************************
//
// COleInPlaceFrame::RemoveMenus
//
// Purpose:
//
//      Removes the container menus from the combined menu
//
// Parameters:
//
//      HMENU hmenuShared   - Handle to the combined menu.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      GetMenuItemCount            Windows API
//      RemoveMenu                  Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::RemoveMenus (HMENU hmenuShared)
{
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::SetStatusText
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      This function is not implemented due to the fact
//      that this application does not have a status bar.
//
//********************************************************************

//@@WTK WIN32, UNICODE
//STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCSTR lpszStatusText)
STDMETHODIMP COleInPlaceFrame::SetStatusText (LPCOLESTR lpszStatusText)
{
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceFrame::EnableModeless
//
// Purpose:
//
//      Enables/Disables container modeless dialogs
//
// Parameters:
//
//      BOOL fEnable    - Enable/Disable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      There are no modeless dialogs in this application, so the
//      implementation of this method is trivial.
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::EnableModeless (BOOL fEnable)
{
        TraceMsg(TF_GENERAL, "In IOIPF::EnableModeless\r\n");
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceFrame::TranslateAccelerator
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceFrame::TranslateAccelerator (LPMSG lpmsg, WORD wID)
{
        TraceMsg(TF_GENERAL, "In IOIPF::TranslateAccelerator\r\n");
        return ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\ioips.cpp ===
//**********************************************************************
// File name: IOIPS.CPP
//
//      Implementation file for COleInPlaceSite
//
// Functions:
//
//      See IOIPS.H for class Definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"

//**********************************************************************
//
// CConnWizSite::COleInPlaceSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation at the interface level.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      CConnWizSite::QueryInterface SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
        TraceMsg(TF_GENERAL, "In IOIPS::QueryInterface\r\n");

        // delegate to the container Site
        return m_pSite->QueryInterface(riid, ppvObj);
}

//**********************************************************************
//
// CConnWizSite::COleInPlaceSite::AddRef
//
// Purpose:
//
//      Adds to the reference count at the interface level.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::AddRef()
{
        TraceMsg(TF_GENERAL, "In IOIPS::AddRef\r\n");

        // increment the interface reference count (for debugging only)
        ++m_nCount;

        // delegate to the container Site
        return m_pSite->AddRef();
}

//**********************************************************************
//
// CConnWizSite::COleInPlaceSite::Release
//
// Purpose:
//
//      Decrements the reference count at this level
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the interface.
//
// Function Calls:
//      Function                    Location
//
//      CConnWizSite::Release        SITE.CPP
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleInPlaceSite::Release()
{
        TraceMsg(TF_GENERAL, "In IOIPS::Release\r\n");
        // decrement the interface reference count (for debugging only)
        m_nCount--;

        // delegate to the container Site
        return m_pSite->Release();
}

//**********************************************************************
//
// COleInPlaceSite::GetWindow
//
// Purpose:
//
//      Returns the Window Handle of the client site
//
// Parameters:
//
//      HWND FAR* lphwnd    - place to return the handle
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindow (HWND FAR* lphwnd)
{
        TraceMsg(TF_GENERAL, "In IOIPS::GetWindow\r\n");

        // return the handle to our editing window.
        *lphwnd = m_pSite->m_hWnd;

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::ContextSensitiveHelp
//
// Purpose:
//
//
// Parameters:
//
//      BOOL fEnterMode - TRUE for entering Context Sensitive help mode
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//      Be sure to read the technotes included with the OLE toolkit.
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::ContextSensitiveHelp (BOOL fEnterMode)
{
        TraceMsg(TF_GENERAL, "In IOIPS::ContextSensitiveHelp\r\n");

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::CanInPlaceActivate
//
// Purpose:
//
//      Object calls to find out if the container can InPlace activate
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::CanInPlaceActivate ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::CanInPlaceActivate\r\n");
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceActivate
//
// Purpose:
//
//      Called by the object on InPlace Activation
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceActivate ()
{
        HRESULT hrErr;
        TraceMsg(TF_GENERAL, "In IOIPS::OnInPlaceActivate\r\n");

        hrErr = m_pSite->m_lpOleObject->QueryInterface(
                        IID_IOleInPlaceObject, (LPVOID FAR *)&m_pSite->m_lpInPlaceObject);
        if (hrErr != NOERROR)
                return ResultFromScode(E_FAIL);

        // return S_OK to indicate we can in-place activate.
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIActivate
//
// Purpose:
//
//      Object calls this method when it displays it's UI.
//
// Parameters:
//
//      None.
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIActivate ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::OnUIActivate\r\n");

//        m_pSite->m_lpDoc->m_fAddMyUI=FALSE;
//        m_pSite->m_lpDoc->m_fInPlaceActive = TRUE;
        m_pSite->m_fInPlaceActive = TRUE;

        m_pSite->m_lpInPlaceObject->GetWindow((HWND FAR*)&m_pSite->m_hwndIPObj);

        // return S_OK to continue in-place activation
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::GetWindowContext
//
// Purpose:
//
//      Called by the object to get information for InPlace Negotiation.
//
// Parameters:
//
//      LPOLEINPLACEFRAME FAR* lplpFrame    - Location to return a pointer
//                                            to IOleInPlaceFrame.
//
//      LPOLEINPLACEUIWINDOW FAR* lplpDoc   - Location to return a pointer
//                                            to IOleInPlaceUIWindow.
//
//      LPRECT lprcPosRect                  - The rect that the object
//                                            occupies
//
//      LPRECT lprcClipRect                 - The clipping rect
//
//      LPOLEINPLACEFRAMEINFO lpFrameInfo   - Pointer to FRAMEINFO
//
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      COleInPlaceFrame::AddRef    IOIPF.CPP
//      CConnWizSite::GetObjRect     SITE.CPP
//      SetMapMode                  Windows API
//      GetDC                       Windows API
//      ReleaseDC                   Windows API
//      CopyRect                    Windows API
//      GetClientRect               Windows API
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::GetWindowContext (LPOLEINPLACEFRAME FAR* lplpFrame,
                                                           LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                                                           LPRECT lprcPosRect,
                                                           LPRECT lprcClipRect,
                                                           LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
        RECT rect;

        TraceMsg(TF_GENERAL, "In IOIPS::GetWindowContext\r\n");

        // the frame is associated with the application object.
        // need to AddRef() it...
        m_pSite->m_OleInPlaceFrame.AddRef();
        *lplpFrame = &m_pSite->m_OleInPlaceFrame;
        *lplpDoc = NULL;  // must be NULL, cause we're SDI.

        // get the size of the object in pixels
        m_pSite->GetObjRect(&rect);

        // Copy this to the passed buffer
        CopyRect(lprcPosRect, &rect);

        // fill the clipping region
        GetClientRect(m_pSite->m_hWnd, &rect);
        CopyRect(lprcClipRect, &rect);

        // fill the FRAMEINFO
        lpFrameInfo->fMDIApp = FALSE;
        lpFrameInfo->hwndFrame = m_pSite->m_hWnd;
        lpFrameInfo->haccel = NULL;
        lpFrameInfo->cAccelEntries = 0;

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::Scroll
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::Scroll (SIZE scrollExtent)
{
        TraceMsg(TF_GENERAL, "In IOIPS::Scroll\r\n");
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnUIDeactivate
//
// Purpose:
//
//      Called by the object when its UI goes away
//
// Parameters:
//
//       BOOL fUndoable
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      CConnWizAPP::AddFrameLevelUI APP.CPP
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnUIDeactivate (BOOL fUndoable)
{
        // need to clear this flag first
        m_pSite->m_fInPlaceActive = FALSE;

        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::OnInPlaceDeactivate
//
// Purpose:
//
//      Called when the inplace session is over
//
// Parameters:
//
//      None
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                    Location
//
//      ResultFromScode             OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnInPlaceDeactivate ()
{
        if (m_pSite->m_lpInPlaceObject) {
                m_pSite->m_lpInPlaceObject->Release();
                m_pSite->m_lpInPlaceObject = NULL;
        }
        return ResultFromScode(S_OK);
}

//**********************************************************************
//
// COleInPlaceSite::DiscardUndoState
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DiscardUndoState ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::DiscardUndoState\r\n");
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::DeactivateAndUndo
//
// Purpose:
//
//      Not Implemented
//
// Parameters:
//
//      Not Implemented
//
// Return Value:
//
//      Not Implemented
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//      Not Implemented
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::DeactivateAndUndo ()
{
        TraceMsg(TF_GENERAL, "In IOIPS::DeactivateAndUndo\r\n");
        return ResultFromScode(E_FAIL);
}

//**********************************************************************
//
// COleInPlaceSite::OnPosRectChange
//
// Purpose:
//
//      The object calls this method when it's size changes during an
//      InPlace Session
//
// Parameters:
//
//      LPCRECT lprcPosRect -   The new object rect
//
// Return Value:
//
//      S_OK
//
// Function Calls:
//      Function                            Location
//
//      GetClientRect                       Windows API
//      IOleObject::GetExtent               Object
//      IOleObject::QueryInterface          Object
//      IOleInPlaceObject::SetObjectRects   Object
//      IOleInPlaceObject::Release          Object
//      ResultFromScode                     OLE API
//
// Comments:
//
//********************************************************************

STDMETHODIMP COleInPlaceSite::OnPosRectChange (LPCRECT lprcPosRect)
{
    return ResultFromScode(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\ioips.h ===
//**********************************************************************
// File name: IOIPS.H
//
//      Definition of COleInPlaceSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _IOIPS_H_ )
#define _IOIPS_H_


class COleSite;

interface COleInPlaceSite : public IOleInPlaceSite
{
    int m_nCount;
    COleSite FAR * m_pSite;

    COleInPlaceSite(COleSite FAR *pSite) {
        m_pSite = pSite;
        m_nCount = 0;
        };

    ~COleInPlaceSite() {
        assert(m_nCount == 0);
        };

    STDMETHODIMP QueryInterface (REFIID riid, LPVOID FAR* ppv);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    STDMETHODIMP GetWindow (HWND FAR* lphwnd);
    STDMETHODIMP ContextSensitiveHelp (BOOL fEnterMode);

    // *** IOleInPlaceSite methods ***
    STDMETHODIMP CanInPlaceActivate ();
    STDMETHODIMP OnInPlaceActivate ();
    STDMETHODIMP OnUIActivate ();
    STDMETHODIMP GetWindowContext (LPOLEINPLACEFRAME FAR* lplpFrame,
                                   LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                                   LPRECT lprcPosRect,
                                   LPRECT lprcClipRect,
                                   LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll (SIZE scrollExtent);
    STDMETHODIMP OnUIDeactivate (BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate ();
    STDMETHODIMP DiscardUndoState ();
    STDMETHODIMP DeactivateAndUndo ();
    STDMETHODIMP OnPosRectChange (LPCRECT lprcPosRect);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\ispdata.h ===
#ifndef   _ISPDATA_H
#define  _ISPDATA_H

#include "icwhelp.h"
#include "appdefs.h"


typedef BOOL (* VALIDATECONTENT)    (LPCTSTR lpData);

enum IPSDataContentValidators
{
    ValidateCCNumber = 0,
    ValidateCCExpire
};    

typedef struct tag_ISPDATAELEMENT
{
    LPCTSTR         lpQueryElementName;             // Static name to put in query string
    LPTSTR          lpQueryElementValue;            // data for element
    WORD            idContentValidator;             // id of content validator 
    WORD            wValidateNameID;                // validation element name string ID
    DWORD           dwValidateFlag;                 // validation bit flag for this element
}ISPDATAELEMENT, *LPISPDATAELEMENT;

class CICWISPData : public IICWISPData
{
    public:

        // IICWISPData
        virtual BOOL    STDMETHODCALLTYPE   PutDataElement(WORD wElement, LPCTSTR lpValue, WORD wValidateLevel);
        virtual HRESULT STDMETHODCALLTYPE   GetQueryString(BSTR bstrBaseURL, BSTR *lpReturnURL);
        virtual LPCTSTR STDMETHODCALLTYPE   GetDataElement(WORD wElement)
        {
            ASSERT(wElement < ISPDATAELEMENTS_LEN);
            return (m_ISPDataElements[wElement].lpQueryElementValue);
        };
        
        virtual void STDMETHODCALLTYPE      PutValidationFlags(DWORD dwFlags)
        {
            m_dwValidationFlags = dwFlags;
        };
        
        virtual void STDMETHODCALLTYPE      Init(HWND   hWndParent)
        {
            m_hWndParent = hWndParent;
        };
        
        // IUNKNOWN
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWISPData(CServer* pServer );
        ~CICWISPData();

private:
        BOOL    bValidateContent(WORD   wFunctionID, LPCTSTR  lpData);
        
        LPISPDATAELEMENT    m_ISPDataElements;

        HWND                m_hWndParent;       // parent for messages
        DWORD               m_dwValidationFlags;
        // For class object management
        LONG                m_lRefCount;
        CServer*            m_pServer;    // Pointer to this component server's control object.
};
#endif //_ISPDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <ole2.h>
#include <assert.h>
#include <string.h>
#include <ccstock.h>

#include <malloc.h>
#include <wininet.h>
#include <regstr.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <exdisp.h>
#include <mshtmdid.h>

#include "icwunicd.h"
#include "resource.h"
#include "walker.h"
#include "icwutil.h"
#include "server.h"
#include "factory.h"
#include "iocs.h"
#include "ioipf.h"
#include "ioips.h"
#include "site.h"
#include "..\inc\debug.h"
#include "webview.h"
#include "icwwebvw.h"
#include "icwwalk.h"
#include "validate.h"
#include "ispdata.h"
#include "gifcon.h"
#include "appdefs.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Used by icwutil.rc
//

#define IDS_HTML_DEFAULT_FONTFACE   500
#define IDS_HTML_DEFAULT_FONTSIZE   501
#define IDS_APPNAME                 503

#define IDS_ERR_INVALID_INTRO       504
#define IDS_ERR_INVALID_MSG         505

#define IDS_PAYMENT_CC_LUHNCHK      506
#define IDS_PAYMENT_CCEXPDATE       507 

#define IDS_USERINFO_FE_NAME        510
#define IDS_USERINFO_FIRSTNAME      511
#define IDS_USERINFO_LASTNAME       512
#define IDS_USERINFO_COMPANYNAME    513
#define IDS_USERINFO_ADDRESS1       514
#define IDS_USERINFO_ADDRESS2       515
#define IDS_USERINFO_CITY           516
#define IDS_USERINFO_STATE          517
#define IDS_USERINFO_ZIP            518
#define IDS_USERINFO_PHONE          519
#define IDS_PAYMENT_CCNUMBER        520
#define IDS_PAYMENT_CCNAME          521
#define IDS_PAYMENT_CCADDRESS       522
#define IDS_PAYMENT_CCZIP           523
#define IDS_PAYMENT_PBNAME          524
#define IDS_PAYMENT_PBNUMBER        525
#define IDS_USERINFO_FURIGANA       526
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\registry.h ===
/****************************************************************************
 *
 *  REGISTRY.h
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *  4/24/97 jmazner Created
 *
 ***************************************************************************/

#ifndef __Registry_H__
#define __Registry_H__
//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
BOOL WINAPI RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const LPTSTR szFriendlyName,
                       const LPTSTR szVerIndProgID,
                       const LPTSTR szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
BOOL WINAPI UnregisterServer(const CLSID& clsid,
                         const LPTSTR szVerIndProgID,
                         const LPTSTR szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\ispdata.cpp ===
#include "pre.h"
#include "tchar.h"
#include "webvwids.h"

#pragma data_seg(".data")

// The following are the names for the name/value pairs that will be passed as a query string to the
// ISP signup server
const TCHAR csz_USER_FIRSTNAME[]        = TEXT("USER_FIRSTNAME");
const TCHAR csz_USER_LASTNAME[]         = TEXT("USER_LASTNAME");
const TCHAR csz_USER_ADDRESS[]          = TEXT("USER_ADDRESS");
const TCHAR csz_USER_MOREADDRESS[]      = TEXT("USER_MOREADDRESS");
const TCHAR csz_USER_CITY[]             = TEXT("USER_CITY");
const TCHAR csz_USER_STATE[]            = TEXT("USER_STATE");
const TCHAR csz_USER_ZIP[]              = TEXT("USER_ZIP");
const TCHAR csz_USER_PHONE[]            = TEXT("USER_PHONE");
const TCHAR csz_AREACODE[]              = TEXT("AREACODE");
const TCHAR csz_COUNTRYCODE[]           = TEXT("COUNTRYCODE");
const TCHAR csz_USER_FE_NAME[]          = TEXT("USER_FE_NAME");
const TCHAR csz_PAYMENT_TYPE[]          = TEXT("PAYMENT_TYPE");
const TCHAR csz_PAYMENT_BILLNAME[]      = TEXT("PAYMENT_BILLNAME");
const TCHAR csz_PAYMENT_BILLADDRESS[]   = TEXT("PAYMENT_BILLADDRESS");
const TCHAR csz_PAYMENT_BILLEXADDRESS[] = TEXT("PAYMENT_BILLEXADDRESS");
const TCHAR csz_PAYMENT_BILLCITY[]      = TEXT("PAYMENT_BILLCITY");
const TCHAR csz_PAYMENT_BILLSTATE[]     = TEXT("PAYMENT_BILLSTATE");
const TCHAR csz_PAYMENT_BILLZIP[]       = TEXT("PAYMENT_BILLZIP");
const TCHAR csz_PAYMENT_BILLPHONE[]     = TEXT("PAYMENT_BILLPHONE");
const TCHAR csz_PAYMENT_DISPLAYNAME[]   = TEXT("PAYMENT_DISPLAYNAME");
const TCHAR csz_PAYMENT_CARDNUMBER[]    = TEXT("PAYMENT_CARDNUMBER");
const TCHAR csz_PAYMENT_EXMONTH[]       = TEXT("PAYMENT_EXMONTH");
const TCHAR csz_PAYMENT_EXYEAR[]        = TEXT("PAYMENT_EXYEAR");
const TCHAR csz_PAYMENT_CARDHOLDER[]    = TEXT("PAYMENT_CARDHOLDER");
const TCHAR csz_SIGNED_PID[]            = TEXT("SIGNED_PID");
const TCHAR csz_GUID[]                  = TEXT("GUID");
const TCHAR csz_OFFERID[]               = TEXT("OFFERID");
const TCHAR csz_USER_COMPANYNAME[]      = TEXT("USER_COMPANYNAME");
const TCHAR csz_ICW_VERSION[]           = TEXT("ICW_Version");

// NOTE: This order of this table is dependant on the order ot the ENUM in WEBVIEW.H for ISPDATA element.
// DO NOT CHANGE 1 without CHANGING the other!!!!!
ISPDATAELEMENT aryISPDataElements[] = 
{
    { csz_USER_FIRSTNAME,       NULL,   0,                  IDS_USERINFO_FIRSTNAME,     REQUIRE_FIRSTNAME          },
    { csz_USER_LASTNAME,        NULL,   0,                  IDS_USERINFO_LASTNAME,      REQUIRE_LASTNAME           },
    { csz_USER_ADDRESS,         NULL,   0,                  IDS_USERINFO_ADDRESS1,      REQUIRE_ADDRESS            },
    { csz_USER_MOREADDRESS,     NULL,   0,                  IDS_USERINFO_ADDRESS2,      REQUIRE_MOREADDRESS        },
    { csz_USER_CITY,            NULL,   0,                  IDS_USERINFO_CITY,          REQUIRE_CITY               },
    { csz_USER_STATE,           NULL,   0,                  IDS_USERINFO_STATE,         REQUIRE_STATE              },
    { csz_USER_ZIP,             NULL,   0,                  IDS_USERINFO_ZIP,           REQUIRE_ZIP                },
    { csz_USER_PHONE,           NULL,   0,                  IDS_USERINFO_PHONE,         REQUIRE_PHONE              },
    { csz_AREACODE,             NULL,   0,                  0,                          0                          },
    { csz_COUNTRYCODE,          NULL,   0,                  0,                          0                          },
    { csz_USER_FE_NAME,         NULL,   0,                  IDS_USERINFO_FE_NAME,       REQUIRE_FE_NAME            },
    { csz_PAYMENT_TYPE,         NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_BILLNAME,     NULL,   0,                  IDS_PAYMENT_PBNAME,         REQUIRE_PHONEIV_BILLNAME   },
    { csz_PAYMENT_BILLADDRESS,  NULL,   0,                  IDS_PAYMENT_CCADDRESS,      REQUIRE_CCADDRESS          },
    { csz_PAYMENT_BILLEXADDRESS,NULL,   0,                  IDS_USERINFO_ADDRESS2,      REQUIRE_IVADDRESS2         },
    { csz_PAYMENT_BILLCITY,     NULL,   0,                  IDS_USERINFO_CITY,          REQUIRE_IVCITY             },
    { csz_PAYMENT_BILLSTATE,    NULL,   0,                  IDS_USERINFO_STATE,         REQUIRE_IVSTATE            },
    { csz_PAYMENT_BILLZIP,      NULL,   0,                  IDS_USERINFO_ZIP,           REQUIRE_IVZIP              },
    { csz_PAYMENT_BILLPHONE,    NULL,   0,                  IDS_PAYMENT_PBNUMBER,       REQUIRE_PHONEIV_ACCNUM     },
    { csz_PAYMENT_DISPLAYNAME,  NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_CARDNUMBER,   NULL,   ValidateCCNumber,   IDS_PAYMENT_CCNUMBER,       REQUIRE_CCNUMBER           },
    { csz_PAYMENT_EXMONTH,      NULL,   0,                  0,                          0                          },
    { csz_PAYMENT_EXYEAR,       NULL,   ValidateCCExpire,   0,                          0                          },
    { csz_PAYMENT_CARDHOLDER,   NULL,   0,                  IDS_PAYMENT_CCNAME,         REQUIRE_CCNAME             },
    { csz_SIGNED_PID,           NULL,   0,                  0,                          0                          },
    { csz_GUID,                 NULL,   0,                  0,                          0                          },
    { csz_OFFERID,              NULL,   0,                  0,                          0                          },
    { NULL,                     NULL,   0,                  0,                          0                          },
    { NULL,                     NULL,   0,                  0,                          0                          },
    { csz_USER_COMPANYNAME,     NULL,   0,                  IDS_USERINFO_COMPANYNAME,   REQUIRE_COMPANYNAME        },
    { csz_ICW_VERSION,          NULL,   0,                  0,                          0                          }
}; 

#define ISPDATAELEMENTS_LEN sizeof(aryISPDataElements) / sizeof(ISPDATAELEMENT)

#pragma data_seg()

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData:CICWISPData
//
//  Synopsis    This is the constructor, nothing fancy
//
//-----------------------------------------------------------------------------
CICWISPData::CICWISPData
(
    CServer* pServer
) 
{
    TraceMsg(TF_CWEBVIEW, "CICWISPData constructor called");
    m_lRefCount = 0;
    
    // Initialize the data elements array
    m_ISPDataElements = aryISPDataElements;
    
    // Assign the pointer to the server control object.
    m_pServer = pServer;
}

CICWISPData::~CICWISPData()
{
    // Walk through and free any allocated values in m_ISPDataElements
    for (int i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        if (m_ISPDataElements[i].lpQueryElementValue)
            free(m_ISPDataElements[i].lpQueryElementValue);
    }
}

// BUGBUG need a destructor to walk the array and free the lpQueryElementValue members

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//
//-----------------------------------------------------------------------------
HRESULT CICWISPData::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_CWEBVIEW, "CICWISPData::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWISPData
    if (IID_IICWISPData == riid)
        *ppv = (void *)(IICWISPData *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::AddRef
//
//  Synopsis    This is the standard AddRef
//
//
//-----------------------------------------------------------------------------
ULONG CICWISPData::AddRef( void )
{
    TraceMsg(TF_CWEBVIEW, "CICWISPData::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWISPData::Release
//
//  Synopsis    This is the standard Release
//
//
//-----------------------------------------------------------------------------
ULONG CICWISPData::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_CWEBVIEW, "CICWISPData::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        if (NULL != m_pServer)
            m_pServer->ObjectsDown();
    
        delete this;
        return 0;
    }
    return( m_lRefCount );
}


BOOL CICWISPData::PutDataElement
(
    WORD wElement, 
    LPCTSTR lpValue, 
    WORD wValidateLevel
)
{
    ASSERT(wElement < ISPDATAELEMENTS_LEN);
    
    BOOL                bValid = TRUE;
    LPISPDATAELEMENT    lpElement = &m_ISPDataElements[wElement];
    
    ASSERT(lpElement);
        
    if (wValidateLevel > ISPDATA_Validate_None)
    {
        // See if we even need to validate.  A validateflag of 0 means we always validate
        if ((0 == lpElement->dwValidateFlag) || m_dwValidationFlags & lpElement->dwValidateFlag)
        {
            // process based on validation level
            switch (wValidateLevel)
            {
                case ISPDATA_Validate_DataPresent:
                {
                    bValid = IsValid(lpValue, m_hWndParent, lpElement->wValidateNameID);
                    break;
                }
                
                case ISPDATA_Validate_Content:
                {
                    bValid = bValidateContent(lpElement->idContentValidator, lpValue);
                    break;
                }
            }
        }            
    }   
     
    // If the element is valid, then store it.
    if (bValid)
    {
        // If this elemement has been previously set the free it
        if (lpElement->lpQueryElementValue)
            free(lpElement->lpQueryElementValue);
        
        // lpValue can be NULL
        if (lpValue)    
            lpElement->lpQueryElementValue = _tcsdup(lpValue);
        else
            lpElement->lpQueryElementValue = NULL;
                    
    }        
    return (bValid);
}

// This funtion will form the query string to be sent to the ISP signup server
// 
HRESULT CICWISPData::GetQueryString
(
    BSTR    bstrBaseURL,
    BSTR    *lpReturnURL    
)
{
    LPTSTR              lpWorkingURL;
    WORD                cbBuffer = 0;
    LPISPDATAELEMENT    lpElement;
    LPTSTR              lpszBaseURL = W2A(bstrBaseURL);
    int                 i;
       
    ASSERT(lpReturnURL);
    if (!lpReturnURL)
        return E_FAIL;
                
    // Calculate how big of a buffer we will need
    cbBuffer += (WORD)lstrlen(lpszBaseURL);
    cbBuffer += 1;                      // For the & or the ?
    for (i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_ISPDataElements[i];
        ASSERT(lpElement);
        if (lpElement->lpQueryElementName)
        {
            cbBuffer += (WORD)lstrlen(lpElement->lpQueryElementName);
            cbBuffer += (WORD)lstrlen(lpElement->lpQueryElementValue) * 3;       // *3 for encoding
            cbBuffer += 3;              // For the = and & and the terminator (because we copy
                                        // lpQueryElementValue into a new buffer for encoding
        }
        else
        {
            cbBuffer += (WORD)lstrlen(lpElement->lpQueryElementValue);
            cbBuffer += 1;              // for the trailing &
        }        
    }
    cbBuffer += 1;                     // Terminator
    
    // Allocate a buffer large enough
    if (NULL == (lpWorkingURL = (LPTSTR)GlobalAllocPtr(GPTR, sizeof(TCHAR)*cbBuffer)))
        return E_FAIL;
        
    lstrcpy(lpWorkingURL, lpszBaseURL);
    
    // See if this ISP provided URL is already a Query String.
    if (NULL != _tcschr(lpWorkingURL, TEXT('?')))
        lstrcat(lpWorkingURL, cszAmpersand);      // Append our params
    else
        lstrcat(lpWorkingURL, cszQuestion);       // Start with our params

    for (i = 0; i < ISPDATAELEMENTS_LEN; i ++)
    {
        lpElement = &m_ISPDataElements[i];
        ASSERT(lpElement);
            
        if (lpElement->lpQueryElementName)
        {
            // If there is a query value, then encode it
            if (lpElement->lpQueryElementValue)
            {
                // Allocate a buffer to encode into
                size_t size = (sizeof(TCHAR)* lstrlen(lpElement->lpQueryElementValue))*3;
                LPTSTR lpszVal = (LPTSTR) malloc(size+sizeof(TCHAR));
                
                lstrcpy(lpszVal, lpElement->lpQueryElementValue);
                URLEncode(lpszVal, size);
            
                URLAppendQueryPair(lpWorkingURL, 
                                   (LPTSTR)lpElement->lpQueryElementName,
                                   lpszVal);
                free(lpszVal);
            }   
            else
            {
                URLAppendQueryPair(lpWorkingURL, 
                                   (LPTSTR)lpElement->lpQueryElementName,
                                   NULL);
            }             
        }                                   
        else
        {
            if (lpElement->lpQueryElementValue)
            {
                lstrcat(lpWorkingURL, lpElement->lpQueryElementValue);
                lstrcat(lpWorkingURL, cszAmpersand);                                        
            }                
        }    
    }    
    
    // Terminate the working URL properly, by removing the trailing ampersand
    lpWorkingURL[lstrlen(lpWorkingURL)-1] = '\0';
    
    
    // Set the return VALUE.  We must allocate here, since the caller will free
    // this returned string, and A2W only puts the string in the stack
    *lpReturnURL = SysAllocString(A2W(lpWorkingURL));
    
    // Free the buffer
    GlobalFreePtr(lpWorkingURL);
    
    return (S_OK);
}


// Dispatch functioin to handle content specific validation
BOOL    CICWISPData::bValidateContent
(
    WORD        wFunctionID,
    LPCTSTR     lpData
)
{
    BOOL    bValid = FALSE;
    
    switch (wFunctionID)
    {
        case ValidateCCNumber:
            bValid = validate_cardnum(m_hWndParent, lpData);
            break;

        case ValidateCCExpire:
        {
            int iMonth = _ttoi(m_ISPDataElements[ISPDATA_PAYMENT_EXMONTH].lpQueryElementValue);
            int iYear = _ttoi(lpData);
    
            bValid = validate_cardexpdate(m_hWndParent, iMonth, iYear);

            //Because of Y2K we are going to work with this pointer
            //we will assume year is 5 char in len
            if (bValid)
            {
                TCHAR szY2KYear [3] = TEXT("\0");
               
                ASSERT(lstrlen(lpData) == 5);

                lstrcpyn(szY2KYear, lpData + 2, 3);
                lstrcpy((TCHAR*)lpData, szY2KYear);
            }
        }        
    }
    
    return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\registry.cpp ===
/****************************************************************************
 *
 *  REGISTRY.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides functionality for self-registering/unregistering via
 *  the regsvr32.exe
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *  05/14/98    donaldm     copied from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include "registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//
BOOL setKeyAndValue(const LPTSTR pszPath,
                    const LPTSTR szSubkey,
                    const LPTSTR szValue,
                    const LPTSTR szName = NULL) ;
// Convert a CLSID into a tchar string.
void CLSIDtochar(const CLSID& clsid, 
                 LPTSTR szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const LPTSTR szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
BOOL WINAPI RegisterServer(HMODULE hModule,            // DLL module handle
                           const CLSID& clsid,         // Class ID
                           const LPTSTR szFriendlyName, // Friendly Name
                           const LPTSTR szVerIndProgID, // Programmatic
                           const LPTSTR szProgID)       //   IDs
{
    BOOL    bRet = FALSE;
    
    // Get server location.
    TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
                            szModule,
                            sizeof(szModule)/sizeof(TCHAR)) ;
    if (0 != dwResult )
    {

        while (1)
        {
            // Convert the CLSID into a TCHAR.
            TCHAR szCLSID[CLSID_STRING_SIZE] ;
            CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

            // Build the key CLSID\\{...}
            TCHAR szKey[CLSID_STRING_SIZE + 10] ;
            lstrcpy(szKey, TEXT("CLSID\\")) ;
            lstrcat(szKey, szCLSID) ;
          
            // Add the CLSID to the registry.
            bRet = setKeyAndValue(szKey, NULL, szFriendlyName) ;
            if (!bRet)
                break;

            // Add the server filename subkey under the CLSID key.
            bRet = setKeyAndValue(szKey, TEXT("InprocServer32"), szModule) ;
            if (!bRet)
                break;

            // 7/2/97 jmazner IE bug #41852
            // Add Threading Model
            bRet = setKeyAndValue(szKey,
                           TEXT("InprocServer32"),
                           TEXT("Apartment"),
                           TEXT("ThreadingModel")) ; 
            if (!bRet)
                break;

            // Add the ProgID subkey under the CLSID key.
            bRet = setKeyAndValue(szKey, TEXT("ProgID"), szProgID) ;
            if (!bRet)
                break;

            // Add the version-independent ProgID subkey under CLSID key.
            bRet = setKeyAndValue(szKey, TEXT("VersionIndependentProgID"),
                           szVerIndProgID) ;
            if (!bRet)
                break;

            // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
            bRet = setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
            if (!bRet)
                break;
            
            bRet = setKeyAndValue(szVerIndProgID, TEXT("CLSID"), szCLSID) ;
            if (!bRet)
                break;
            
            bRet = setKeyAndValue(szVerIndProgID, TEXT("CurVer"), szProgID) ;
            if (!bRet)
                break;

            // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
            bRet = setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
            if (!bRet)
                break;
                
            bRet = setKeyAndValue(szProgID, TEXT("CLSID"), szCLSID) ;
            break;
        }                
    }
    
    return bRet ;
}

//
// Remove the component from the registry.
//
BOOL WINAPI UnregisterServer(const CLSID& clsid,         // Class ID
                      const LPTSTR szVerIndProgID, // Programmatic
                      const LPTSTR szProgID)       //   IDs
{
    // Convert the CLSID into a TCHAR.
    TCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

    // Build the key CLSID\\{...}
    TCHAR szKey[64] ;
    lstrcpy(szKey, TEXT("CLSID\\")) ;
    lstrcat(szKey, szCLSID) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    ASSERT((lResult == ERROR_SUCCESS) ||
           (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Delete the version-independent ProgID Key.
    lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
    ASSERT((lResult == ERROR_SUCCESS) ||
           (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Delete the ProgID key.
    lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
    ASSERT((lResult == ERROR_SUCCESS) ||
           (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    return TRUE;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a TCHAR string.
void CLSIDtochar(const CLSID& clsid,
                 LPTSTR szCLSID,
                 int length)
{
    ASSERT(length >= CLSID_STRING_SIZE) ;
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    ASSERT(SUCCEEDED(hr)) ;

    // Covert from wide characters to non-wide.
#ifdef UNICODE
    lstrcpyn(szCLSID, wszCLSID, length / sizeof(WCHAR)) ;
#else
    wcstombs(szCLSID, wszCLSID, length) ;
#endif

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const LPTSTR lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
                             KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME    time ;
    TCHAR       szBuffer[256] ;
    DWORD       dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
                        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const LPTSTR szKey,
                    const LPTSTR szSubkey,
                    const LPTSTR szValue,
                    const LPTSTR szName)
{
    HKEY    hKey;
    TCHAR   szKeyBuf[1024] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, TEXT("\\")) ;
        lstrcat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
                                  szKeyBuf, 
                                  0, NULL, REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS, NULL, 
                                  &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
                      (BYTE *)szValue, 
                      sizeof(TCHAR)*(lstrlen(szValue)+1)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\server.h ===
//**********************************************************************
// File name: server.h
//
//      
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined(SERVER_H)
#define SERVER_H

// String Macros.
#define ABOUT_TITLE_STR "DLLSERVE: OLE Tutorial Code Sample"

// Dialog IDs.
#define IDD_ABOUTBOX                1000

// Error-related String Identifiers.
#define IDS_ASSERT_FAIL             2200


#ifdef __cplusplus

//**********************************************************************
//  Class:    CServer
//
//  Summary:  Class to encapsulate control of this COM server (eg, handle
//            Lock and Object counting, encapsulate otherwise global data).
//
//  Methods:  none
//**********************************************************************
class CServer
{
    public:
        CServer(void);
        ~CServer(void);

        void Lock(void);
        void Unlock(void);
        void ObjectsUp(void);
        void ObjectsDown(void);

        // A place to store the handle to loaded instance of this DLL module.
        HINSTANCE m_hDllInst;

        // Global DLL Server living Object count.
        LONG m_cObjects;

        // Global DLL Server Client Lock count.
        LONG m_cLocks;
};

#endif // __cplusplus

// Allow other internal ICWUTIL modules to get at the globals.
extern CServer* g_pServer;


#endif // SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\server.cpp ===
/****************************************************************************
 *
 *  SERVER.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *
 ***************************************************************************/

#include "pre.h"


/*---------------------------------------------------------------------------
  Implementation the internal CServer C++ object.  Used to encapsulate
  some server data and the methods for Lock and Object count incrementing
  and decrementing.
---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
  Method:   CServer::CServer

  Summary:  CServer Constructor.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
CServer::CServer(void)
{
    // Zero the Object and Lock counts for this attached process.
    m_cObjects = 0;
    m_cLocks = 0;

    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::~CServer

  Summary:  CServer Destructor.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
CServer::~CServer(void)
{
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::Lock

  Summary:  Increment the Server's Lock count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::Lock(void)
{
    InterlockedIncrement((PLONG) &m_cLocks);
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::Unlock

  Summary:  Decrement the Server's Lock count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::Unlock(void)
{
    InterlockedDecrement((PLONG) &m_cLocks);
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::ObjectsUp

  Summary:  Increment the Server's living Object count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::ObjectsUp(void)
{
    InterlockedIncrement((PLONG) &m_cObjects);
    return;
}


/*---------------------------------------------------------------------------
  Method:   CServer::ObjectsDown

  Summary:  Decrement the Server's living object count.

  Args:     void

  Modifies: .

  Returns:  void
---------------------------------------------------------------------------*/
void CServer::ObjectsDown(void)
{
    InterlockedDecrement((PLONG) &m_cObjects);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\site.cpp ===
//**********************************************************************
// File name: SITE.CPP
//
//      Implementation file for COleSite
//
// Functions:
//
//      See SITE.H for class definition
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"

extern BOOL CopyBitmapRectToFile
(
    HBITMAP hbm, 
    LPRECT  lpRect,
    LPTSTR  lpszFileName
);

#include "exdispid.h"

#define SETDefFormatEtc(fe, cf, med) \
{\
(fe).cfFormat=cf;\
(fe).dwAspect=DVASPECT_CONTENT;\
(fe).ptd=NULL;\
(fe).tymed=med;\
(fe).lindex=-1;\
};

#define MAX_DISP_NAME         50
#define DISPID_RunIcwTutorApp 12345

typedef struct  dispatchList_tag 
{
    WCHAR   szName[MAX_DISP_NAME];
    int     cName;
    DWORD   dwDispID;

}  DISPATCHLIST;

DISPATCHLIST ExternalInterface[] = 
{
    {L"RunIcwTutorApplication", 22, DISPID_RunIcwTutorApp }
};

const TCHAR  cszOLSNewText[] = TEXT("g_spnOlsNewText");
const TCHAR  cszOLSOldText[] = TEXT("g_spnOlsOldText");

//**********************************************************************
//
// OleFree
//
// Purpose:
//
//      free memory using the currently active IMalloc* allocator
//
// Parameters:
//
//      LPVOID pmem - pointer to memory allocated using IMalloc
//
// Return Value:
//
//      None
//
// Comments:
//
//********************************************************************
void OleFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL)
        return;

    if (FAILED(CoGetMalloc(MEMCTX_TASK, &pmalloc)))
        return;

    pmalloc->Free(pmem);
    pmalloc->Release();
}

//**********************************************************************
//
// COleSite::COleSite
//
// Purpose:
//
//      Constructor for COleSite
//
// Parameters:
//
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                    Location
//
// Comments:
//
//********************************************************************
#pragma warning(disable : 4355)  // turn off this warning.  This warning
                                                                // tells us that we are passing this in
                                                                // an initializer, before "this" is through
                                                                // initializing.  This is ok, because
                                                                // we just store the ptr in the other
                                                                // constructors

COleSite::COleSite (void) :     m_OleClientSite(this) , 
                                m_OleInPlaceSite(this), 
                                m_OleInPlaceFrame(this)
#pragma warning (default : 4355)  // Turn the warning back on
{
    TCHAR   szTempPath[MAX_PATH];
    
    // Init member vars
    m_lpInPlaceObject    = NULL;
    m_lpOleObject        = NULL;
    m_hwndIPObj          = NULL;
    m_hWnd               = NULL;
    m_fInPlaceActive     = FALSE;
    
    m_dwHtmPageType      = 0;
    m_hbmBkGrnd          = NULL;
    lstrcpyn(m_szForeGrndColor, HTML_DEFAULT_COLOR, MAX_COLOR_NAME);
    lstrcpyn(m_szBkGrndColor, HTML_DEFAULT_BGCOLOR, MAX_COLOR_NAME);
    
    m_bUseBkGndBitmap    = FALSE;
    m_dwDrawAspect       = DVASPECT_CONTENT; // clear the reference count
    m_cRef               = 0;                // Init the ref count

    // Create a temp file for storing the background bitmap
    if (GetTempPath(sizeof(szTempPath)/sizeof(TCHAR), szTempPath))
    {
        GetTempFileName(szTempPath, TEXT("ICW"), 0, m_szBkGndBitmapFile);
    }
    
    // Create a storage file for creating/embedding an OLE oject into this site
    StgCreateDocfile (NULL, 
                      STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE, 
                      0, 
                      &m_lpStorage);
}

//**********************************************************************
//
// COleSite::~COleSite
//
// Purpose:
//
//      Destructor for COleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IOleObject::Release                     Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

COleSite::~COleSite ()
{
    TraceMsg(TF_GENERAL, "In COleSite's Destructor \r\n");

    ASSERT( m_cRef == 0 );

    if (m_lpOleObject)
       m_lpOleObject->Release();

    if (m_lpWebBrowser)   
        m_lpWebBrowser->Release();
        
    if (m_lpStorage) 
    {
        m_lpStorage->Release();
        m_lpStorage = NULL;
    }
    
    DeleteFile(m_szBkGndBitmapFile);
}


//**********************************************************************
//
// COleSite::CloseOleObject
//
// Purpose:
//
//      Call IOleObject::Close on the object of the COleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      IOleObject::QueryInterface              Object
//      IOleObject::Close                       Object
//      IOleInPlaceObject::UIDeactivate         Object
//      IOleInPlaceObject::InPlaceDeactivate    Object
//      IOleInPlaceObject::Release              Object
//
// Comments:
//
//********************************************************************

void COleSite::CloseOleObject (void)
{
    TraceMsg(TF_GENERAL, "In COleSite::CloseOleObject \r\n");

    if (m_lpOleObject)
    {
       if (m_fInPlaceActive)
       {
            LPOLEINPLACEOBJECT lpObject;
            LPVIEWOBJECT lpViewObject = NULL;
            
            m_lpOleObject->QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&lpObject);
            lpObject->UIDeactivate();
            // don't need to worry about inside-out because the object
            // is going away.
            lpObject->InPlaceDeactivate();
            lpObject->Release();
       }
    
       m_lpOleObject->Close(OLECLOSE_NOSAVE);
       m_hWnd = NULL;
    }
}


//**********************************************************************
//
// COleSite::UnloadOleObject
//
// Purpose:
//
//      Close and release all pointers to the object of the COleSite
//
// Parameters:
//
//      None
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                                Location
//
//      COleSite::CloseOleObject             SITE.CPP
//      IOleObject::QueryInterface              Object
//      IViewObject::SetAdvise                  Object
//      IViewObject::Release                    Object
//      IStorage::Release                       OLE API
//
// Comments:
//
//********************************************************************

void COleSite::UnloadOleObject (void)
{
    TraceMsg(TF_GENERAL, "In COleSite::UnloadOleObject \r\n");

    if (m_lpOleObject)
    {
        LPVIEWOBJECT lpViewObject;
        CloseOleObject();    // ensure object is closed; NOP if already closed

        m_lpOleObject->QueryInterface(IID_IViewObject, (LPVOID FAR *)&lpViewObject);

        if (lpViewObject)
        {
            // Remove the view advise
            lpViewObject->SetAdvise(m_dwDrawAspect, 0, NULL);
            lpViewObject->Release();
        }

        m_lpOleObject->Release();
        m_lpOleObject = NULL;
    }
}

//**********************************************************************
//
// COleSite::QueryInterface
//
// Purpose:
//
//      Used for interface negotiation of the container Site.
//
// Parameters:
//
//      REFIID riid         -   A reference to the interface that is
//                              being queried.
//
//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to
//                              the interface.
//
// Return Value:
//
//      S_OK    -   The interface is supported.
//      S_FALSE -   The interface is not supported
//
// Function Calls:
//      Function                    Location
//
//      IsEqualIID                  OLE API
//      ResultFromScode             OLE API
//      COleSite::AddRef          OBJ.CPP
//      COleClientSite::AddRef      IOCS.CPP
//      CAdviseSink::AddRef         IAS.CPP
//
// Comments:
//
//
//********************************************************************

STDMETHODIMP COleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    TraceMsg(TF_GENERAL, "In COleSite::QueryInterface\r\n");

    *ppvObj = NULL;     // must set out pointer parameters to NULL

    if ( riid == IID_IDocHostUIHandler)
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }
    
    if ( riid == IID_IUnknown)
    {
        AddRef();
        *ppvObj = this;
        return ResultFromScode(S_OK);
    }

    if ( riid == IID_IOleClientSite)
    {
        m_OleClientSite.AddRef();
        *ppvObj = &m_OleClientSite;
        return ResultFromScode(S_OK);
    }
            
    if ( riid == IID_IOleInPlaceSite)
    {
        m_OleInPlaceSite.AddRef();
        *ppvObj = &m_OleInPlaceSite;
        return ResultFromScode(S_OK);
    }
       
    if( (riid == DIID_DWebBrowserEvents) ||
        (riid == IID_IDispatch))
    {
        AddRef();
        *ppvObj = (LPVOID)(IUnknown*)(DWebBrowserEvents*)this;
        return ResultFromScode(S_OK);
    }     

    // Not a supported interface
    return ResultFromScode(E_NOINTERFACE);
}

//**********************************************************************
//
// COleSite::AddRef
//
// Purpose:
//
//      Increments the reference count of the container Site.
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the site.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleSite::AddRef()
{
    TraceMsg(TF_GENERAL, "In COleSite::AddRef\r\n");
    return ++m_cRef;
}

//**********************************************************************
//
// COleSite::Release
//
// Purpose:
//
//      Decrements the reference count of the container Site
//
// Parameters:
//
//      None
//
// Return Value:
//
//      ULONG   -   The new reference count of the Site.
//
// Function Calls:
//      Function                    Location
//
//
// Comments:
//
//********************************************************************

STDMETHODIMP_(ULONG) COleSite::Release()
{
    TraceMsg(TF_GENERAL, "In COleSite::Release\r\n");

    return --m_cRef;
}


//**********************************************************************
//
// COleSite::CreateBrowserObject
//
// Purpose:
//
//      Used to Create a new WebBrowser object (can't be done in the
//      constructor).
//
// Parameters:
//
// Return Value:
//
//      None
//
// Function Calls:
//
// Comments:
//
//********************************************************************

void COleSite::CreateBrowserObject()
{
        
    HRESULT         hr;
            
    SETDefFormatEtc(m_fe, 0, TYMED_NULL);
            
    hr = OleCreate(CLSID_WebBrowser,
                   IID_IWebBrowser2,
                   OLERENDER_DRAW,
                   &m_fe,
                   &m_OleClientSite,
                   m_lpStorage,
                   (LPVOID FAR *)&m_lpWebBrowser);
                
    if (SUCCEEDED(hr))                       
        InitBrowserObject();
        
    IUnknown    *pOleSite;
    // Get an IUnknow pointer to the site, so I can attach an event sink
    QueryInterface(IID_IUnknown, (LPVOID *)&pOleSite);

    // Setup to get WebBrowserEvents
    ConnectToConnectionPoint(pOleSite, 
                             DIID_DWebBrowserEvents,
                             TRUE,
                             (IUnknown *)m_lpWebBrowser, 
                             &m_dwcpCookie, 
                             NULL);     
    // We can release this instance now, since we have attached the event sink
    pOleSite->Release();
        
}


void COleSite::DestroyBrowserObject()
{

    UnloadOleObject();
    
    if (m_lpWebBrowser)
    {
        m_lpWebBrowser->Release();
        m_lpWebBrowser = NULL;
    }        
}

//**********************************************************************
//
// COleSite::InitBrowserObject
//
// Purpose:
//
//      Used to initialize a newly create object (can't be done in the
//      constructor).
//
// Parameters:
//
// Return Value:
//
//      None
//
// Function Calls:
//      Function                        Location
//
//      IOleObject::SetHostNames        Object
//      IOleObject::QueryInterface      Object
//      IViewObject2::GetExtent         Object
//      IOleObject::DoVerb              Object
//      IViewObject::SetAdvise          Object
//      IViewObject::Release            Object
//      GetClientRect                   Windows API
//      OleSetContainedObject           OLE API
//
// Comments:
//
//********************************************************************

void COleSite::InitBrowserObject()
{
    // If we don't have a WebBrowser object to initialize, then bail
    if (!m_lpWebBrowser)
        return;
            
    // Get An OleObject from the WebBrowser Interface
    m_lpWebBrowser->QueryInterface(IID_IOleObject, (LPVOID FAR *)&m_lpOleObject);

    // inform object handler/DLL object that it is used in the embedding container's context
    OleSetContainedObject(m_lpOleObject, TRUE);
    
    // setup the client setup
    m_lpOleObject->SetClientSite(&m_OleClientSite);
}

void COleSite::ConnectBrowserObjectToWindow
(
    HWND hWnd, 
    DWORD dwHtmPageType, 
    BOOL bUseBkGndBitmap,
    HBITMAP hbmBkGrnd,
    LPRECT lprcBkGrnd,
    LPTSTR lpszclrBkGrnd,
    LPTSTR lpszclrForeGrnd
)
{
    if (m_hWnd)
    {
        // Close the OLE Object, which will deactivate it, so we can then reactivate it
        // with the new window
        CloseOleObject(); 
    }
    
    // Remeber this window handle for later
    m_hWnd              = hWnd; 
    m_dwHtmPageType     = dwHtmPageType;
    m_bUseBkGndBitmap   = bUseBkGndBitmap;
    m_hbmBkGrnd         = hbmBkGrnd;
    if (NULL != lpszclrForeGrnd)
        lstrcpyn(m_szForeGrndColor, lpszclrForeGrnd, MAX_COLOR_NAME);
    if (NULL != lpszclrBkGrnd)
        lstrcpyn(m_szBkGrndColor, lpszclrBkGrnd, MAX_COLOR_NAME);
    
    CopyRect(&m_rcBkGrnd, lprcBkGrnd);
    InPlaceActivate();
}

void COleSite::ShowHTML()
{
    RECT    rect;
    
    // we only want to DoVerb(SHOW) if this is an InsertNew object.
    // we should NOT DoVerb(SHOW) if the object is created FromFile.
    m_lpOleObject->DoVerb( OLEIVERB_SHOW,
                           NULL,
                           &m_OleClientSite,
                           -1,
                           m_hWnd,
                           &rect);
}

void COleSite::InPlaceActivate()
{
    RECT    rect;
    m_lpOleObject->DoVerb( OLEIVERB_INPLACEACTIVATE,
                           NULL,
                           &m_OleClientSite,
                           -1,
                           m_hWnd,
                           &rect);
}

void COleSite::UIActivate()
{
    RECT    rect;
    m_lpOleObject->DoVerb( OLEIVERB_UIACTIVATE,
                           NULL,
                           &m_OleClientSite,
                           -1,
                           m_hWnd,
                           &rect);
}

HRESULT COleSite::TweakHTML( TCHAR*     pszFontFace,
                             TCHAR*     pszFontSize,
                             TCHAR*     pszBgColor,
                             TCHAR*     pszForeColor)
{
    ASSERT(m_lpWebBrowser);
    
    IWebBrowser2*  pwb   = m_lpWebBrowser;
    HRESULT        hr    = E_FAIL;
    IDispatch*     pDisp = NULL;

    hr = pwb->get_Document(&pDisp);

    // Call might succeed but that dosen't guarantee a valid ptr
    if (SUCCEEDED(hr) && pDisp)
    {
        IHTMLDocument2* pDoc = NULL;

        hr = pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc);
        if (SUCCEEDED(hr) && pDoc)
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_BSTR;
            if (m_bUseBkGndBitmap)
            {
                // Use A background bitmap
                SetHTMLBackground(pDoc, m_hbmBkGrnd, &m_rcBkGrnd);
            }
            else
            {
                //Setup the background solid color
                var.bstrVal = A2W(pszBgColor);
                pDoc->put_bgColor(var);
            }
           
            //Setup the Foreground (text) color
            var.bstrVal = A2W(pszForeColor);
            pDoc->put_fgColor(var);
           
            //now we'll try for the font-face/size
            if((NULL != pszFontFace))
            {
                IHTMLElement* pBody;
                //Get the <BODY> from the document
                hr = pDoc->get_body(&pBody);
                if((SUCCEEDED(hr)) && pBody)
                {
                    IHTMLStyle* pStyle = NULL;
                    //Cool, now the inline style sheet
                    hr = pBody->get_style(&pStyle);
                   
                    if (SUCCEEDED(hr) && pStyle)
                    {
                        //Great, now the font-family
                        hr = pStyle->put_fontFamily(A2W(pszFontFace));
                   
                        if(SUCCEEDED(hr))
                        {
                            //Setup for the font-size
                            var.bstrVal = A2W(pszFontSize);
                            //And finally the font-size
                            hr = pStyle->put_fontSize(var);  
                        }
                        pStyle->Release();
                    }
                    pBody->Release();
                }
            }
            pDoc->Release();
        }
        pDisp->Release();
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT COleSite::SetHTMLBackground
( 
    IHTMLDocument2  *pDoc,
    HBITMAP hbm,
    LPRECT  lpRC
)    
{
    HRESULT         hr    = E_FAIL;
    IDispatch*      pDisp = NULL;
    TCHAR           szBmpURL[MAX_PATH+10];
    
    // Get the portion of the Bitmap we are interested into a file
    if (CopyBitmapRectToFile(hbm, lpRC, m_szBkGndBitmapFile))
    {
        wsprintf (szBmpURL, TEXT("file://%s"), m_szBkGndBitmapFile);    
        
        IHTMLElement* pBody;
        //Get the <BODY> from the document
        hr = pDoc->get_body(&pBody);
        if((SUCCEEDED(hr)) && pBody)
        {
             IHTMLBodyElement* pBodyElt = NULL;
                    
             pBody->QueryInterface(IID_IHTMLBodyElement, (void**)&pBodyElt);
                    
             // Set the Background bitmap
             hr = pBodyElt->put_background(A2W(szBmpURL));
             pBodyElt->Release();
        }
    }        
    return (hr);
}

//**********************************************************************
//
// COleSite::GetObjRect
//
// Purpose:
//
//      Retrieves the rect of the object in pixels
//
// Parameters:
//
//      LPRECT lpRect - Rect structure filled with object's rect in pixels
//
//********************************************************************
void COleSite::GetObjRect(LPRECT lpRect)
{
    GetClientRect(m_hWnd, lpRect);
}

// * CConWizSite::GetHostInfo
// *
// * Purpose: Called at initialisation of every instance of Trident.
// *
HRESULT COleSite::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    BSTR wbLoc = NULL;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    // Adjust the HTML properties to our liking based on the offer type
    // pagetype defs in appdefs.h   
    switch(m_dwHtmPageType)
    {
        //YES 3D
        case PAGETYPE_BILLING: 
        case PAGETYPE_ISP_TOS:
        case PAGETYPE_MARKETING:
        case PAGETYPE_CUSTOMPAY:
        {
            pInfo->dwFlags = DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_DISABLE_HELP_MENU;       
            break;
        }
        //NO 3D
        case PAGETYPE_BRANDED:
        case PAGETYPE_ISP_NORMAL:
        case PAGETYPE_NOOFFERS:
        case PAGETYPE_ISP_FINISH:
        case PAGETYPE_ISP_CUSTOMFINISH:
        case PAGETYPE_OLS_FINISH:
        default:
        {
           
            pInfo->dwFlags = DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_DIALOG | DOCHOSTUIFLAG_SCROLL_NO |
                             DOCHOSTUIFLAG_DISABLE_HELP_MENU;
        
            break;
        }
    }    
    return S_OK;
}

// * CConWizSite::ShowUI
// *
// * Purpose: Called when MSHTML.DLL shows its UI
// *
HRESULT COleSite::ShowUI
(
    DWORD dwID, 
    IOleInPlaceActiveObject * /*pActiveObject*/,
    IOleCommandTarget * pCommandTarget,
    IOleInPlaceFrame * /*pFrame*/,
    IOleInPlaceUIWindow * /*pDoc*/
)
{
    // We've already got our own UI in place so just return S_OK
    return S_OK;
}

// * CConWizSite::HideUI
// *
// * Purpose: Called when MSHTML.DLL hides its UI
// *
HRESULT COleSite::HideUI(void)
{
    return S_OK;
}

// * CConWizSite::UpdateUI
// *
// * Purpose: Called when MSHTML.DLL updates its UI
// *
HRESULT COleSite::UpdateUI(void)
{
    return S_OK;
}

// * CConWizSite::EnableModeless
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::EnableModeless
// *
HRESULT COleSite::EnableModeless(BOOL /*fEnable*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::OnDocWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnDocWindowActivate
// *
HRESULT COleSite::OnDocWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::OnFrameWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnFrameWindowActivate
// *
HRESULT COleSite::OnFrameWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::ResizeBorder
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::ResizeBorder
// *
HRESULT COleSite::ResizeBorder(
                LPCRECT /*prcBorder*/, 
                IOleInPlaceUIWindow* /*pUIWindow*/,
                BOOL /*fRameWindow*/)
{
    return E_NOTIMPL;
}

// * CConWizSite::ShowContextMenu
// *
// * Purpose: Called when MSHTML.DLL would normally display its context menu
// *
HRESULT COleSite::ShowContextMenu(
                DWORD /*dwID*/, 
                POINT* /*pptPosition*/,
                IUnknown* /*pCommandTarget*/,
                IDispatch* /*pDispatchObjectHit*/)
{
    return S_OK; // We've shown our own context menu. MSHTML.DLL will no longer try to show its own.
}

// * CConWizSite::TranslateAccelerator
// *
// * Purpose: Called from MSHTML.DLL's TranslateAccelerator routines
// *
HRESULT COleSite::TranslateAccelerator(LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID)
{
    return ResultFromScode(S_FALSE);
}

// * CConWizSite::GetOptionKeyPath
// *
// * Purpose: Called by MSHTML.DLL to find where the host wishes to store 
// *    its options in the registry
// *
HRESULT COleSite::GetOptionKeyPath(BSTR* pbstrKey, DWORD)
{
    return E_NOTIMPL;
}

STDMETHODIMP COleSite::GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget)
{
    return E_NOTIMPL;
}

STDMETHODIMP COleSite::GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch)
{
    // return the IDispatch we have for extending the object Model
    ASSERT(this);
    *ppDispatch = (IDispatch*)this; 
    return S_OK;
}

STDMETHODIMP COleSite::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    HRESULT hr = ResultFromScode(DISP_E_UNKNOWNNAME);
    
    rgDispId[0] = DISPID_UNKNOWN;

    for (int iX = 0; iX < sizeof(ExternalInterface)/sizeof(DISPATCHLIST); iX++)
    {
         if ( 2 == CompareString( lcid, 
                                 NORM_IGNORECASE | NORM_IGNOREWIDTH, 
                                 (LPCTSTR)ExternalInterface[iX].szName, 
                                 ExternalInterface[iX].cName,
                                 (LPCTSTR)rgszNames[0], 
                                 wcslen(rgszNames[0])))
        {
            rgDispId[0] = ExternalInterface[iX].dwDispID;
            hr = NOERROR;
            break;
        }
    }
    
    // Set the disid's for the parameters
    if (cNames > 1)
    {
        // Set a DISPID for function parameters
        for (UINT i = 1; i < cNames ; i++)
            rgDispId[i] = DISPID_UNKNOWN;
    }      
          
    return hr;
}

    
STDMETHODIMP COleSite::TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut)
{
    return E_NOTIMPL;
}
        
STDMETHODIMP COleSite::FilterDataObject( 
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet)
{
    return E_NOTIMPL;
}

HRESULT COleSite::ActivateOLSText(void )
{   
    LPDISPATCH      pDisp = NULL; 
    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)  
    {
        IHTMLDocument2* pDoc = NULL;
        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)) && pDoc)
        {
            IHTMLElementCollection* pColl = NULL;

            // retrieve a reference to the ALL collection
            if (SUCCEEDED(pDoc->get_all( &pColl )))
            {
                // Get the two spans we are interested in from the all collection
                VARIANT varName;
                VariantInit(&varName);
                V_VT(&varName) = VT_BSTR;
                varName.bstrVal = A2W(cszOLSNewText);

                VARIANT varIdx;
                varIdx.vt = VT_UINT;
                varIdx.lVal = 0;

                LPDISPATCH pDispElt = NULL; 
                
                // Get the IDispatch for NewText SPAN, and set it to visible
                if (SUCCEEDED(pColl->item(varName, varIdx, &pDispElt)) && pDispElt)
                {
                    IHTMLElement* pElt = NULL;
                    if (SUCCEEDED(pDispElt->QueryInterface( IID_IHTMLElement, (LPVOID*)&pElt )) && pElt)
                    {                            
                        IHTMLStyle  *pStyle = NULL;
                                        
                        // Get the style interface for this element, so we can tweak it
                        if (SUCCEEDED(pElt->get_style(&pStyle)))
                        {
                            pStyle->put_visibility(A2W(TEXT("visible")));
                            pStyle->Release();
                        }                                        
                        pElt->Release();
                    }                    
                    pDispElt->Release();
                }
                
                pDispElt = NULL;
                varName.bstrVal = A2W(cszOLSOldText);
                // Get the IDispatch for OldText SPAN, and set it to hidden
                if (SUCCEEDED(pColl->item(varName, varIdx, &pDispElt)) && pDispElt)
                {
                    IHTMLElement* pElt = NULL;
                    if (SUCCEEDED(pDispElt->QueryInterface( IID_IHTMLElement, (LPVOID*)&pElt )) && pElt)
                    {                            
                        IHTMLStyle  *pStyle = NULL;
                                        
                        // Get the style interface for this element, so we can tweak it
                        if (SUCCEEDED(pElt->get_style(&pStyle)))
                        {
                            pStyle->put_visibility(A2W(TEXT("hidden")));
                            pStyle->Release();
                        }                                        
                        pElt->Release();
                    }                    
                    pDispElt->Release();
                }
                pColl->Release();
            } // get_all
            pDoc->Release();
        }
        pDisp->Release();
    }        
    return S_OK;
}    


//returns true if focus was sucessfully set
BOOL COleSite::TrySettingFocusOnHtmlElement(IUnknown* pUnk)
{   
    IHTMLControlElement* pControl = NULL;
    
    BOOL bFocusWasSet = FALSE;

    if(SUCCEEDED(pUnk->QueryInterface(IID_IHTMLControlElement, (LPVOID*)&pControl)) && pControl)
    {
        if(SUCCEEDED(pControl->focus()))
            bFocusWasSet = TRUE;
        pControl->Release();
    }
    return bFocusWasSet;
}                        

BOOL COleSite::SetFocusToFirstHtmlInputElement()
{
    VARIANT                   vIndex;
    IDispatch*                pDisp         = NULL;
    IDispatch*                pDispElement  = NULL;
    IHTMLDocument2*           pDoc          = NULL;
    IHTMLElementCollection*   pColl         = NULL;    
    IHTMLButtonElement*       pButton       = NULL;
    IHTMLInputButtonElement*  pInputButton  = NULL;
    IHTMLInputFileElement*    pInputFile    = NULL;
    IHTMLInputTextElement*    pInputText    = NULL;
    IHTMLSelectElement*       pSelect       = NULL;
    IHTMLTextAreaElement*     pTextArea     = NULL;
    IHTMLOptionButtonElement* pOptionButton = NULL;
    VARIANT                   varNull       = { 0 };
    long                      lLen          = 0;
    BOOL                      bFocusWasSet  = FALSE;

    vIndex.vt = VT_UINT;
    
    if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)
    {
        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2,(LPVOID*)&pDoc)) && pDoc)
        {   
            if (SUCCEEDED(pDoc->get_all(&pColl)) && pColl)
            {
                pColl->get_length(&lLen);
    
                for (int i = 0; i < lLen; i++)
                {      
                    vIndex.lVal = i;
                    pDispElement = NULL;     

                    if(SUCCEEDED(pColl->item(vIndex, varNull, &pDispElement)) && pDispElement)
                    {
                        pButton      = NULL;
                        pInputButton = NULL;
                        pInputFile   = NULL;
                        pInputText   = NULL;
                        pSelect      = NULL;
                        
                        if(SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLButtonElement, (LPVOID*)&pButton)) && pButton)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pButton);
                            pButton->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLInputButtonElement, (LPVOID*)&pInputButton)) && pInputButton)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pInputButton);
                            pInputButton->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLInputFileElement, (LPVOID*)&pInputFile)) && pInputFile)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pInputFile);
                            pInputFile->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLInputTextElement, (LPVOID*)&pInputText)) && pInputText)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pInputText);
                            pInputText->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLSelectElement, (LPVOID*)&pSelect)) && pSelect)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pSelect);
                            pSelect->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLTextAreaElement, (LPVOID*)&pTextArea)) && pTextArea)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pTextArea);
                            pTextArea->Release();
                        }
                        else if (SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLOptionButtonElement, (LPVOID*)&pOptionButton)) && pOptionButton)
                        {
                            bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pOptionButton);
                            pOptionButton->Release();
                        }
                        pDispElement->Release();
                    }
                    if(bFocusWasSet)
                        break;
                }
                pColl->Release();
            }
            pDoc->Release();
        }
        pDisp->Release();
    }
    return bFocusWasSet;
}

BOOL COleSite::SetFocusToHtmlPage()
{
    IDispatch*                pDisp         = NULL;
    IHTMLDocument2*           pDoc          = NULL;
    IHTMLElement*             pElement      = NULL;
    BOOL                      bFocusWasSet  = FALSE;

    DOCHOSTUIINFO pInfo;
    pInfo.cbSize = sizeof(DOCHOSTUIINFO);

    if(SUCCEEDED(GetHostInfo(&pInfo)))
    {
        if(!(pInfo.dwFlags & DOCHOSTUIFLAG_SCROLL_NO))
        {    
            if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)
            {
                if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2,(LPVOID*)&pDoc)) && pDoc)
                {   
                    if (SUCCEEDED(pDoc->get_body(&pElement)) && pElement)
                    {
                        bFocusWasSet = TrySettingFocusOnHtmlElement((IUnknown*)pElement);
                        pElement->Release();
                    }
                    pDoc->Release();
                }
                pDisp->Release();
            }
        }
    }

    return bFocusWasSet;
}

HRESULT COleSite::Invoke
( 
    DISPID dispidMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags, 
    DISPPARAMS FAR* pdispparams, 
    VARIANT FAR* pvarResult,  
    EXCEPINFO FAR* pexcepinfo, 
    UINT FAR* puArgErr
)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    
    // Either one of these is good, since we just want to make sure the DOCUMENT pointer is
    // available.
    
    switch(dispidMember)
    {
    
        case DISPID_DOCUMENTCOMPLETE:
        case DISPID_NAVIGATECOMPLETE:
        {
            TCHAR szFontFace [MAX_RES_LEN] = TEXT("\0");
            TCHAR szFontSize [MAX_RES_LEN] = TEXT("\0");

            LoadString(ghInstance, IDS_HTML_DEFAULT_FONTFACE, szFontFace, MAX_RES_LEN);                
            LoadString(ghInstance, IDS_HTML_DEFAULT_FONTSIZE, szFontSize, MAX_RES_LEN);    
            ASSERT(strlen(szFontFace) != 0);
            ASSERT(strlen(szFontSize) != 0);

            // Adjust the HTML properties to our liking based on the offer type
            // html default defs in icwutil.h and icwutil.rc
            // pagetype defs in appdefs.h
            switch(m_dwHtmPageType)
            {
                case PAGETYPE_BILLING:  
                case PAGETYPE_CUSTOMPAY:
                case PAGETYPE_ISP_TOS:
                case PAGETYPE_ISP_NORMAL:
                {
                    TweakHTML(szFontFace,  
                              szFontSize, 
                              m_szBkGrndColor, 
                              m_szForeGrndColor);
                    if(!SetFocusToFirstHtmlInputElement())
                        SetFocusToHtmlPage(); 
                    break;                              
                }
            
                // For the OLS finish page, we need to tweak it's display by
                // invoking the SetNewText script function
                case PAGETYPE_OLS_FINISH:
                {
                    TweakHTML(szFontFace, 
                              szFontSize, 
                              HTML_DEFAULT_BGCOLOR, 
                              HTML_DEFAULT_COLOR);
                              
                    ActivateOLSText();
                    break;
                }
            
                case PAGETYPE_ISP_FINISH:
                case PAGETYPE_ISP_CUSTOMFINISH:
                case PAGETYPE_NOOFFERS:
                {
                    TweakHTML(szFontFace, 
                              szFontSize, 
                              HTML_DEFAULT_SPECIALBGCOLOR, 
                              HTML_DEFAULT_COLOR);
                              
                    break;
                }
                case PAGETYPE_MARKETING:
                case PAGETYPE_BRANDED:
                default:
                {
                    //Do just the background bitmap if necessary
                    if (m_bUseBkGndBitmap)
                    {
                        TweakHTML(NULL, 
                                  NULL, 
                                  HTML_DEFAULT_BGCOLOR, 
                                  HTML_DEFAULT_COLOR);
                    }                                  
                    break;
                }
            }
        
            DisableHyperlinksInDocument();
          
            // Show the Page
            ShowHTML();
            break;
        }
        case DISPID_RunIcwTutorApp: 
        {
            PostMessage(GetParent(m_hWnd), WM_RUNICWTUTORAPP, 0, 0); 
            break;
        }
        default:
        {
           hr = DISP_E_MEMBERNOTFOUND;
           break;
        }
    }
    return hr;
}

void  COleSite::DisableHyperlinksInDocument()
{
    VARIANT                 vIndex;
    IHTMLAnchorElement*     pAnchor;
    IHTMLElement*           pElement;
    IDispatch*              pDisp         = NULL;
    IDispatch*              pDispElement  = NULL;
    IDispatch*              pDispElement2 = NULL;
    IHTMLDocument2*         pDoc          = NULL;
    IHTMLElementCollection* pColl         = NULL;
    BSTR                    bstrInnerHtml = NULL;
    BSTR                    bstrOuterHtml = NULL;
    VARIANT                 varNull       = { 0 };
    long                    lLen          = 0;

    vIndex.vt     = VT_UINT;
    bstrOuterHtml = SysAllocString(A2W(TEXT("&nbsp<SPAN></SPAN>&nbsp")));

    if (SUCCEEDED(m_lpWebBrowser->get_Document(&pDisp)) && pDisp)
    {
        if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2,(LPVOID*)&pDoc)) && pDoc)
        {
            if (SUCCEEDED(pDoc->get_all(&pColl)) && pColl)
            {
                pColl->get_length(&lLen);
    
                for (int i = 0; i < lLen; i++)
                {      
                    vIndex.lVal = i;
                    pDispElement = NULL;     

                    if(SUCCEEDED(pColl->item(vIndex, varNull, &pDispElement)) && pDispElement)
                    {
                        pAnchor = NULL;
            
                        if(SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLAnchorElement, (LPVOID*)&pAnchor)) && pAnchor)
                        {       
                            pAnchor->Release();  
                            pElement = NULL;

                            if(SUCCEEDED(pDispElement->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement)
                            {
                                pElement->get_innerHTML(&bstrInnerHtml);
                                pElement->put_outerHTML(bstrOuterHtml);
                                pElement->Release();

                                if(bstrInnerHtml)
                                {
                                    pDispElement2 = NULL;;
                                    
                                    if(SUCCEEDED(pColl->item(vIndex, varNull, &pDispElement2)) && pDispElement2)
                                    {
                                        pElement = NULL;

                                        if(SUCCEEDED(pDispElement2->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement)
                                        {
                                            pElement->put_innerHTML(bstrInnerHtml);
                                            SysFreeString(bstrInnerHtml);
                                            bstrInnerHtml = NULL;
                                            pElement->Release();
                                        }
                                        pDispElement2->Release();
                                    }
                                }                          
                            }
                        } 
                        pDispElement->Release();
                    }
                }
                pColl->Release();
            }
            pDoc->Release();
        }
        pDisp->Release();
    }
    
    if(bstrInnerHtml)
        SysFreeString(bstrInnerHtml);
    
    SysFreeString(bstrOuterHtml);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\site.h ===
//**********************************************************************
// File name: SITE.H
//
//      Definition of COleSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _SITE_H_ )
#define _SITE_H_

#include <mshtmhst.h>

class COleSite : public IDocHostUIHandler, public DWebBrowserEvents
{
    private:        
        ULONG               m_cRef;     //Reference count        

    public:
        LPSTORAGE           m_lpStorage;
        LPOLEOBJECT         m_lpOleObject;
        LPOLEINPLACEOBJECT  m_lpInPlaceObject;
        HWND                m_hwndIPObj;
        
        IWebBrowser2        *m_lpWebBrowser;
        DWORD               m_dwDrawAspect;
        FORMATETC           m_fe;
        BOOL                m_fInPlaceActive;
        COleClientSite      m_OleClientSite;
        COleInPlaceSite     m_OleInPlaceSite;
        COleInPlaceFrame    m_OleInPlaceFrame;
        
        HWND                m_hWnd;
        DWORD               m_dwHtmPageType;
        BOOL                m_bUseBkGndBitmap;
        HBITMAP             m_hbmBkGrnd;
        RECT                m_rcBkGrnd;
        TCHAR               m_szForeGrndColor[MAX_COLOR_NAME];
        TCHAR               m_szBkGrndColor[MAX_COLOR_NAME];
        DWORD               m_dwcpCookie;
        TCHAR               m_szBkGndBitmapFile[MAX_PATH];
                                
        // IUnknown Interfaces
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();

        // IDocHostUIHandler
        HRESULT STDMETHODCALLTYPE ShowContextMenu( 
            DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
        HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO *pInfo);
        HRESULT STDMETHODCALLTYPE ShowUI( 
            DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
            IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
            IOleInPlaceUIWindow *pDoc);
        HRESULT STDMETHODCALLTYPE HideUI(void);
        HRESULT STDMETHODCALLTYPE UpdateUI(void);
        HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
        HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
        HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
        HRESULT STDMETHODCALLTYPE ResizeBorder( 
            LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
        HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
        HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
        HRESULT STDMETHODCALLTYPE GetDropTarget( 
            IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
        HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDisp);
        HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
        HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

        // DWebBrowserEvents        
        STDMETHOD(GetTypeInfoCount)(UINT FAR* pcInfo) { return E_NOTIMPL; }
        STDMETHOD(GetTypeInfo)( UINT, LCID, ITypeInfo** ) { return E_NOTIMPL; }
        STDMETHOD(GetIDsOfNames)( REFIID, OLECHAR**, UINT, LCID, DISPID* );
        STDMETHOD(Invoke)( DISPID dispidMember, 
                           REFIID riid, 
                           LCID lcid, 
                           WORD wFlags, 
                           DISPPARAMS FAR* pdispparams, 
                           VARIANT FAR* pvarResult, 
                           EXCEPINFO FAR* pexcepinfo, 
                           UINT FAR* puArgErr);
        
        HRESULT TweakHTML ( TCHAR* pszFontFace,
                            TCHAR* pszFontSize,
                            TCHAR* pszBgColor,
                            TCHAR* pszForeColor);

        HRESULT ActivateOLSText(void );
        HRESULT SetHTMLBackground(IHTMLDocument2  *pDoc, HBITMAP hbm, LPRECT  lpRC);
        void CreateBrowserObject(void);
        void DestroyBrowserObject(void);
        
        void InitBrowserObject(void);
        void ConnectBrowserObjectToWindow(HWND hWnd, 
                                          DWORD dwHtmPageType, 
                                          BOOL bUseBkGndBitmap,
                                          HBITMAP hbmBkGrnd,
                                          LPRECT lprcBkGrnd,
                                          LPTSTR lpszclrBkGrnd,
                                          LPTSTR lpszclrForeGrnd);
        void DisableHyperlinksInDocument();
        void ShowHTML();
        void InPlaceActivate();
        void UIActivate();
        BOOL TrySettingFocusOnHtmlElement    (IUnknown* pUnk);
        BOOL SetFocusToFirstHtmlInputElement (void);
        BOOL SetFocusToHtmlPage              (void);

        COleSite();
        ~COleSite();
        void GetObjRect(LPRECT lpRect);
        void CloseOleObject(void);
        void UnloadOleObject(void);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\sources.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwutil

MAJORCOMP=GETCONN
MINORCOMP=ICWCONN


TARGETNAME=ICWUTIL
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=0x60000000
DLLDEF=..\icwutil.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1
C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

BROWSER_INFO="yes"

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

# Conditional compilation

SOURCES= \
    ..\icwutil.rc          \
    ..\dllentry.cpp        \
    ..\server.cpp          \
    ..\factory.cpp         \
    ..\ioips.cpp           \
    ..\ioipf.cpp           \
    ..\iocs.cpp            \
    ..\site.cpp            \
    ..\icwwebvw.cpp        \
    ..\icwwalk.cpp         \
    ..\util.cpp            \
    ..\registry.cpp        \
    ..\weboc.cpp           \
    ..\walker.cpp          \
    ..\gifcon.cpp          \
    ..\validate.cpp        \
    ..\ispdata.cpp         \
    ..\bkgndbmp.cpp

# for DOJ compliance, don't link to shell32p.lib

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\mpr.lib           \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SHELL_LIB_PATH)\shlwapip.lib    \
    $(SDK_LIB_PATH)\version.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pre.h
PRECOMPILED_PCH=pre.pch
PRECOMPILED_OBJ=pre.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  

#include "pre.h"


LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);\
    
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}


HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
)
{
    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    HRESULT hr;
    IConnectionPointContainer *pcpContainer;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;    
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}


void WINAPI URLEncode(TCHAR* pszUrl, size_t bsize)
{   
    ASSERT(pszUrl);
    TCHAR* pszEncode = NULL;   
    TCHAR* pszEStart = NULL;   
#ifdef UNICODE
    TCHAR* pszEEnd   = (TCHAR*)wmemchr( pszUrl, TEXT('\0'), bsize );
#else
    TCHAR* pszEEnd   = (TCHAR*)memchr( pszUrl, '\0', bsize );
#endif
    int   iChr      = sizeof(TCHAR);
    int   iUrlLen   = (int)(pszEEnd-pszUrl);
    pszEEnd = pszUrl;
    
    TCHAR  c;

    if ((size_t)((iChr*iUrlLen)*3) <= bsize)
    {
        
        pszEncode = (TCHAR*)malloc(sizeof(TCHAR)*(iChr *iUrlLen)*3);
        if(pszEncode)
        {
            pszEStart = pszEncode;
            ZeroMemory(pszEncode, sizeof(TCHAR)*(iChr *iUrlLen)*3);
            
            for(; c = *(pszUrl); pszUrl++)
            {
                switch(c)
                {
                    case ' ': //SPACE
                        memcpy(pszEncode, TEXT("+"), sizeof(TCHAR)*1);
                        pszEncode+=1;
                        break;
                    case '#':
                        memcpy(pszEncode, TEXT("%23"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '&':
                        memcpy(pszEncode, TEXT("%26"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '%':
                        memcpy(pszEncode, TEXT("%25"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '=':
                        memcpy(pszEncode, TEXT("%3D"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '<':
                        memcpy(pszEncode, TEXT("%3C"), sizeof(TCHAR)*3);
                        pszEncode+=3;
                        break;
                    case '+':
                        memcpy(pszEncode, TEXT("%2B"), sizeof(TCHAR)*3);
                        pszEncode += 3;
                        break;
                        
                    default:
                        *pszEncode++ = c; 
                        break;          
                }
            }
            *pszEncode++ = '\0';
            memcpy(pszEEnd ,pszEStart, (size_t)(pszEncode - pszEStart));
            free(pszEStart);
        }
    }
}


//BUGBUG:  Need to turn spaces into "+" 
void WINAPI URLAppendQueryPair
(
    LPTSTR   lpszQuery, 
    LPTSTR   lpszName, 
    LPTSTR   lpszValue
)
{
    // Append the Name
    lstrcat(lpszQuery, lpszName);
    lstrcat(lpszQuery, cszEquals);
                    
    // Append the Value
    lstrcat(lpszQuery, lpszValue);
    
    // Append an Ampersand if this is NOT the last pair
    lstrcat(lpszQuery, cszAmpersand);                                        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\validate.h ===
#ifndef   _VALIDATE_H
#define  _VALIDATE_H

BOOL IsValid(LPCTSTR pszText, HWND hWndParent, WORD wNameID);
BOOL validate_cardnum(HWND hWndParent, LPCTSTR lpszRawCardNum);
BOOL validate_cardexpdate(HWND hWndParent, int month, int year);
    
void DoValidErrMsg(HWND hWndParent, int iNameId);
void DoSpecificErrMsg(HWND hWndParent, int iErrId);
    
#endif //_VALIDATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\validate.cpp ===
#include "pre.h"
#include "tchar.h"
#define LCID_JPN    1041  //JAPANESE

// BUGBUG - This function is not very effecient since it requires a alloc/free for each validation
// plus strtok will tokenize the fill string requring a full search of the string.
BOOL IsValid(LPCTSTR pszText, HWND hWndParent, WORD wNameID)
{
    ASSERT(pszText);

    TCHAR* pszTemp = NULL;
    BOOL   bRetVal = FALSE;

    pszTemp = _tcsdup (pszText);    

    if (_tcslen(pszTemp))
    {
        TCHAR seps[]   = TEXT(" ");
        TCHAR* token   = NULL;
        token = _tcstok( pszTemp, seps );
        if (token)
        {
            bRetVal = TRUE;
        }
    }
      
    free(pszTemp);
    
    // If not valid, give the user the error message
    if (!bRetVal)
        DoValidErrMsg(hWndParent, wNameID);
        
    return bRetVal;
    
}

// ============================================================================
// Credit card number validation
// ============================================================================

// Takes a credit card number in the form of 1111-1111-1111-11
// and pads converts it to:
// 11111111111111
// **IMPORTANT** :: This code is multibyte safe but ONLY because we care ONLY about
//                  ANSI #'s
BOOL PadCardNum
(
    LPCTSTR lpszRawCardNum, 
    LPTSTR  szPaddedCardNum,
    UINT    uLenOfRaw
)
{
    LPTSTR lpszTmp = CharPrev(lpszRawCardNum, lpszRawCardNum);    
    UINT  uIndex  = 0;

    for (UINT i =  0; i < uLenOfRaw; i++)
    {
        if( *lpszTmp == '\0' )
            break;
        if((*lpszTmp != '-') && (*lpszTmp != ' '))
        {
            //make sure it's not some other than ansi char.
            if ((*lpszTmp < '0') || (*lpszTmp > '9')) 
                return(FALSE);
            szPaddedCardNum[uIndex] = *lpszTmp;    
            uIndex++;
        }
        
        // Get the prev char
        lpszTmp = CharNext(lpszRawCardNum + i);
    }
    
    szPaddedCardNum[uIndex] = '\0';

    return(TRUE);
} 


/*
    mod_chk()
    performs "Double-Add-Double MOD 10 Check Digit Routine"
    on card number
*/
BOOL mod_chk
(
    LPTSTR credit_card,
    UINT   uCardNumLen
)
{ 
    TCHAR *cp; 
    int dbl       = 0; 
    int check_sum = 0;
    /* 
    * This checksum algorithm has a name, 
    * but I can't think of it. 
    */ 
    cp = credit_card + lstrlen(credit_card) - 1; 
   
    while (cp >= credit_card) 
    { 
        int c; 
        c = *cp-- - '0'; 
        if (dbl) 
        {       
            c *= 2; 
            if (c >= 10) 
                c -= 9; 
        } 
        check_sum += c; 
        dbl = !dbl; 
    } 
    
    return (BOOL)((check_sum % 10) == 0); 
}

BOOL validate_cardnum(HWND hWndParent, LPCTSTR lpszRawCardNum)
// performs:
// a) card type prefix check
// b) Double-Add-Double MOD 10 check digit routine via mod_chk()
//    on the card number.
// The card_num parameter is assumed to have been pre-checked for
// numeric characters and right-justified with '0' padding on the
// left.
{
    BOOL   bRet             = FALSE;
    UINT   uRawLen          = lstrlen(lpszRawCardNum);
    TCHAR* pszPaddedCardNum = (TCHAR*)malloc((uRawLen + 1)*sizeof(TCHAR)); 
    
    if (!pszPaddedCardNum)
        return FALSE;
    
    ZeroMemory(pszPaddedCardNum ,(uRawLen + 1)*sizeof(TCHAR));

    if (PadCardNum(lpszRawCardNum, pszPaddedCardNum, uRawLen))
    {
        UINT  i       = 0;
        LPTSTR tmp_pt = pszPaddedCardNum;
        UINT  uPadLen = lstrlen(pszPaddedCardNum);

        /* find the first non-zero number in card_num */
        while (*tmp_pt == '0' && ++i < uPadLen)
            ++tmp_pt;

        /* all valid  card types are at least 13 characters in length */
        if (uPadLen < 13)
            bRet = FALSE;

        /* check for OK VISA prefix - 4 */
        if ((uPadLen == 16 || uPadLen == 13) && *tmp_pt == '4')
                bRet = mod_chk(pszPaddedCardNum, uPadLen);

        /* check for OK MasterCard prefix - 51 to 55 */
        if (uPadLen == 16) {
            if (*tmp_pt == '5' &&
                *(tmp_pt + 1) >= '1' && *(tmp_pt + 1) <= '5')
                bRet = mod_chk(pszPaddedCardNum, uPadLen);
        }

        /* check for OK American Express prefix - 37 and 34 */
        if (uPadLen == 15 && *tmp_pt == '3' &&
            (*(tmp_pt + 1) == '7' || *(tmp_pt + 1) == '4'))
            bRet = mod_chk(pszPaddedCardNum, uPadLen);

        /* check for OK Discovery prefix - 6011 */
        if (uPadLen == 16 &&
            *tmp_pt == '6' && *(tmp_pt + 1) == '0' &&
            *(tmp_pt + 2) == '1' && *(tmp_pt + 3) == '1')
            bRet = mod_chk(pszPaddedCardNum, uPadLen); 
    }
    
    if (!bRet)
    {
        DoSpecificErrMsg(hWndParent, IDS_PAYMENT_CC_LUHNCHK);
    }

    free(pszPaddedCardNum);
    
    return bRet;
}

BOOL validate_cardexpdate(HWND hWndParent, int month, int year)
{
    BOOL        bRet = FALSE;
    SYSTEMTIME  SystemTime;  
    GetLocalTime(&SystemTime);
    if (year > SystemTime.wYear)
    {
        bRet = TRUE;
    }
    else if (year == SystemTime.wYear)
    {
        if (month >= SystemTime.wMonth)
        {
            bRet = TRUE;
        }
    }

    if (!bRet)
    {
        DoSpecificErrMsg(hWndParent, IDS_PAYMENT_CCEXPDATE);
    }
    return bRet;
}

// ============================================================================
// Error message handlers
// ============================================================================
void DoValidErrMsg(HWND hWndParent, int iNameId)
{
    TCHAR       szCaption     [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR       szErrMsgFmt   [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR       szErrMsgName  [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR       szErrMsg      [2*MAX_RES_LEN];

    if (!LoadString(ghInstance, IDS_APPNAME, szCaption, sizeof(szCaption)))
        return;

    if ((IDS_USERINFO_ADDRESS2 == iNameId) && (LCID_JPN == GetUserDefaultLCID())) 
        iNameId = IDS_USERINFO_FURIGANA;

    if (!LoadString(ghInstance, iNameId, szErrMsgName, sizeof(szErrMsgName)))
        return;
        
    if (!LoadString(ghInstance, IDS_ERR_INVALID_MSG, szErrMsgFmt, sizeof(szErrMsgFmt)))
        return;
        
    wsprintf(szErrMsg, szErrMsgFmt, szErrMsgName);
    
    MessageBox(hWndParent, szErrMsg, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);       
}

void DoSpecificErrMsg(HWND hWndParent, int iErrId)
{
    TCHAR szCaption     [MAX_RES_LEN+1] = TEXT("\0");
    TCHAR szErrMsg      [MAX_RES_LEN+1] = TEXT("\0");

    if (!LoadString(ghInstance, IDS_APPNAME, szCaption, sizeof(szCaption) ))
        return;
    
    if (!LoadString(ghInstance, iErrId, szErrMsg, sizeof(szErrMsg)  ))
        return;
    
    MessageBox(hWndParent, szErrMsg, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\walker.h ===
//**********************************************************************
// File name: WALKER.H
//
//      Definition of COleSite
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _WALKER_H_ )
#define _WALKER_H_

#include <mshtml.h>

class CWalker : public IPropertyNotifySink, IOleClientSite, IDispatch
{
    private:
        ULONG               m_cRef;     //Reference count        
    
    public:
        CWalker()
        {
            m_cRef = 1;
            m_hrConnected = CONNECT_E_CANNOTCONNECT;
            m_dwCookie = 0;
            m_pCP = NULL;
            m_pMSHTML = NULL;
            m_pPageIDForm = NULL;
            m_pBackForm = NULL;
            m_pPageTypeForm = NULL;
            m_pNextForm = NULL;
            m_pPageFlagForm = NULL;
            m_hEventTridentDone = 0;
        }
            
        ~CWalker()
        {
            if (m_pMSHTML)
                m_pMSHTML->Release();
            if (m_pPageIDForm)
                m_pPageIDForm->Release();
            if (m_pBackForm)
                m_pBackForm->Release();
            if (m_pPageTypeForm)
                m_pPageTypeForm->Release();
            if (m_pNextForm)
                m_pNextForm->Release();
            if (m_pPageFlagForm)
                m_pPageFlagForm->Release();
        }

        // IUnknown methods
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)(); 

        // IPropertyNotifySink methods
        STDMETHOD(OnChanged)(DISPID dispID);
        STDMETHOD(OnRequestEdit)(DISPID dispID)
            { return NOERROR; }

        // IOleClientSite methods
        STDMETHOD(SaveObject)(void) { return E_NOTIMPL; }

        STDMETHOD(GetMoniker)(DWORD dwAssign,
                              DWORD dwWhichMoniker,
                             IMoniker** ppmk)
                { return E_NOTIMPL; }

        STDMETHOD(GetContainer)(IOleContainer** ppContainer)
                { return E_NOTIMPL; }

        STDMETHOD(ShowObject)(void)
                { return E_NOTIMPL; }

        STDMETHOD(OnShowWindow)(BOOL fShow)
                { return E_NOTIMPL; }

        STDMETHOD(RequestNewObjectLayout)(void)
                { return E_NOTIMPL; }

        // IDispatch method
        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
                { return E_NOTIMPL; }

        STDMETHOD(GetTypeInfo)(UINT iTInfo,
                LCID lcid,
                ITypeInfo** ppTInfo)
                { return E_NOTIMPL; }

        STDMETHOD(GetIDsOfNames)(REFIID riid,
                LPOLESTR* rgszNames,
                UINT cNames,
                LCID lcid,
                DISPID* rgDispId)
                { return E_NOTIMPL; }
            
        STDMETHOD(Invoke)(DISPID dispIdMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS __RPC_FAR *pDispParams,
                VARIANT __RPC_FAR *pVarResult,
                EXCEPINFO __RPC_FAR *pExcepInfo,
                UINT __RPC_FAR *puArgErr);

        // Additional class methods
        HRESULT Walk                     ();
        HRESULT AttachToDocument         (IWebBrowser2* lpWebBrowser);
        HRESULT AttachToMSHTML           (BSTR bstrURL);
        HRESULT ExtractUnHiddenText      (BSTR* pbstrText);
        HRESULT Detach                   ();
        HRESULT InitForMSHTML            ();
        HRESULT TermForMSHTML            ();
        HRESULT LoadURLFromFile          (BSTR bstrURL);
        HRESULT ProcessOLSFile           (IWebBrowser2* lpWebBrowser);
        HRESULT get_PageType             (LPDWORD pdwPageType);
        HRESULT get_IsQuickFinish        (BOOL* pbIsQuickFinish);
        HRESULT get_PageFlag             (LPDWORD pdwPageFlag);
        HRESULT get_PageID               (BSTR* pbstrPageID);
        HRESULT get_URL                  (LPTSTR lpszURL, BOOL bForward);
        HRESULT get_IeakIspFile          (LPTSTR lpszIspFile);
        HRESULT get_FirstFormQueryString (LPTSTR lpszQuery);

        DWORD               m_dwCookie;
        LPCONNECTIONPOINT   m_pCP;
        HRESULT             m_hrConnected;

        IHTMLFormElement* get_pNextForm() { return m_pNextForm; }
        IHTMLFormElement* get_pBackForm() { return m_pBackForm; }
        
private:
        HRESULT getQueryString(IHTMLFormElement    *pForm,
                               LPTSTR              lpszQuery);  
        void GetInputValue(LPTSTR lpszName, BSTR *pVal, UINT index, IHTMLFormElement *pForm);

protected:
        IHTMLDocument2* m_pTrident;             // An instance of MSHTML that we CoCreated
        IHTMLDocument2* m_pMSHTML;              // A ref of m_pTrident, OR a QI for the WebBrowser's Document
        
        // These elements will contain the navigation information we need
        IHTMLFormElement* m_pPageIDForm;
        IHTMLFormElement* m_pBackForm;
        IHTMLFormElement* m_pPageTypeForm;
        IHTMLFormElement* m_pNextForm;
        IHTMLFormElement* m_pPageFlagForm;
        
        HANDLE            m_hEventTridentDone;
        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\weboc.cpp ===
//**********************************************************************
// File name: CebOC.cpp
//
//      WndProc for Hosting a WebOC in a dialog
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
 
#include "pre.h"

LRESULT CALLBACK WebOCWndProc (HWND hwnd, UINT mMsg, WPARAM wParam, LPARAM lParam)
{ 
    CICWWebView *pICWWebView = (CICWWebView *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (mMsg)
    {
        case WM_SETFOCUS:
        {
            ASSERT(pICWWebView);
            if (pICWWebView)
                pICWWebView->SetFocus();
            return TRUE;
        }
        
        default:
            return (DefWindowProc (hwnd, mMsg, wParam, lParam));
           
     }
}

void RegWebOCClass()
{
    WNDCLASSEX wc; 

    //Register the WebOC class and bind to dummy proc
    ZeroMemory (&wc, sizeof(WNDCLASSEX));
    wc.style         = CS_GLOBALCLASS;
    wc.cbSize        = sizeof(wc);
    wc.lpszClassName = TEXT("WebOC");
    wc.hInstance     = ghInstance;
    wc.lpfnWndProc   = WebOCWndProc;
    wc.lpszMenuName  = NULL;
    
    RegisterClassEx (&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\icwutil\walker.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WALKER.CPP - Functions for walking an HTML input file
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include <urlmon.h>
#include <mshtmdid.h>
#include <mshtml.h>
#include <shlobj.h>

const TCHAR cszEquals[]               = TEXT("=");
const TCHAR cszAmpersand[]            = TEXT("&");
const TCHAR cszPlus[]                 = TEXT("+");
const TCHAR cszQuestion[]             = TEXT("?");
const TCHAR cszFormNamePAGEID[]       = TEXT("PAGEID");
const TCHAR cszFormNameBACK[]         = TEXT("BACK");
const TCHAR cszFormNamePAGETYPE[]     = TEXT("PAGETYPE");
const TCHAR cszFormNameNEXT[]         = TEXT("NEXT");
const TCHAR cszFormNamePAGEFLAG[]     = TEXT("PAGEFLAG");
const TCHAR cszPageTypeTERMS[]        = TEXT("TERMS");
const TCHAR cszPageTypeCUSTOMFINISH[] = TEXT("CUSTOMFINISH");
const TCHAR cszPageTypeFINISH[]       = TEXT("FINISH");
const TCHAR cszPageTypeNORMAL[]       = TEXT("");
const TCHAR cszOLSRegEntries[]        = TEXT("regEntries");
const TCHAR cszKeyName[]              = TEXT("KeyName");
const TCHAR cszEntryName[]            = TEXT("EntryName"); 
const TCHAR cszEntryValue[]           = TEXT("EntryValue");
const TCHAR cszOLSDesktopShortcut[]   = TEXT("DesktopShortcut");
const TCHAR cszSourceName[]           = TEXT("SourceName");
const TCHAR cszTargetName[]           = TEXT("TargetName"); 

#define HARDCODED_IEAK_ISPFILE_ELEMENT_ID TEXT("g_IspFilePath")

// COM interfaces
STDMETHODIMP CWalker::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IPropertyNotifySink == riid)
    {
        *ppv = (LPUNKNOWN)(IPropertyNotifySink*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IOleClientSite == riid)
    {
        *ppv = (IOleClientSite*)this;
        AddRef();
        return NOERROR;
    }
    else if (IID_IDispatch == riid)
    {
        *ppv = (IDispatch*)this;
        AddRef();
        return NOERROR;
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP_(ULONG) CWalker::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CWalker::Release()
{
    if (!(--m_cRef)) 
    { 
        delete this; 
    }
    return m_cRef;
}

// Fired on change of the value of a 'bindable' property
STDMETHODIMP CWalker::OnChanged(DISPID dispID)
{
    HRESULT hr;

    if (DISPID_READYSTATE == dispID)
    {
        // check the value of the readystate property
        assert(m_pMSHTML);

        VARIANT vResult = {0};
        EXCEPINFO excepInfo;
        UINT uArgErr;

        DISPPARAMS dp = {NULL, NULL, 0, 0};
        if (SUCCEEDED(hr = m_pMSHTML->Invoke(DISPID_READYSTATE, IID_NULL, LOCALE_SYSTEM_DEFAULT, 
            DISPATCH_PROPERTYGET, &dp, &vResult, &excepInfo, &uArgErr)))
        {
            assert(VT_I4 == V_VT(&vResult));
            if (READYSTATE_COMPLETE == (READYSTATE)V_I4(&vResult))
                SetEvent(m_hEventTridentDone);
            VariantClear(&vResult);
        }
    }
    return NOERROR;
}

// MSHTML Queries for the IDispatch interface of the host through the IOleClientSite
// interface that MSHTML is passed through its implementation of IOleObject::SetClientSite()
STDMETHODIMP CWalker::Invoke(DISPID dispIdMember,
            REFIID riid,
            LCID lcid,
            WORD wFlags,
            DISPPARAMS __RPC_FAR *pDispParams,
            VARIANT __RPC_FAR *pVarResult,
            EXCEPINFO __RPC_FAR *pExcepInfo,
            UINT __RPC_FAR *puArgErr)
{
    if (!pVarResult)
    {
        return E_POINTER;
    }

    switch(dispIdMember)
    {
        case DISPID_AMBIENT_DLCONTROL: 
            // respond to this ambient to indicate that we only want to
            // download the page, but we don't want to run scripts,
            // Java applets, or ActiveX controls
            V_VT(pVarResult) = VT_I4;
            V_I4(pVarResult) =  DLCTL_DOWNLOADONLY | 
                                DLCTL_NO_SCRIPTS | 
                                DLCTL_NO_JAVA |
                                DLCTL_NO_DLACTIVEXCTLS |
                                DLCTL_NO_RUNACTIVEXCTLS;
            break;
            
        default:
            return DISP_E_MEMBERNOTFOUND;
    }
    return NOERROR;
}

// A more traditional form of persistence. 
// MSHTML performs this asynchronously as well.
HRESULT CWalker::LoadURLFromFile(BSTR   bstrURL)
{
    HRESULT hr;

    LPPERSISTFILE  pPF;
    // MSHTML supports file persistence for ordinary files.
    if ( SUCCEEDED(hr = m_pMSHTML->QueryInterface(IID_IPersistFile, (LPVOID*) &pPF)))
    {
        hr = pPF->Load(bstrURL, 0);
        pPF->Release();
    }

    return hr;
}


// Local interfaces

// This function will attached trient to a location FILE: URL, and ensure that it is ready
// to be walked
HRESULT CWalker::InitForMSHTML()
{
    HRESULT hr;
    LPCONNECTIONPOINTCONTAINER pCPC = NULL;
    LPOLEOBJECT pOleObject = NULL;
    LPOLECONTROL pOleControl = NULL;

    // Create an instance of an dynamic HTML document
    if (FAILED(hr = CoCreateInstance( CLSID_HTMLDocument, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, 
                    (LPVOID*)&m_pTrident )))
    {
        goto Error;
    }

    
    if (FAILED(hr = m_pTrident->QueryInterface(IID_IOleObject, (LPVOID*)&pOleObject)))
    {
        goto Error;
    }
    hr = pOleObject->SetClientSite((IOleClientSite*)this);
    pOleObject->Release();

    if (FAILED(hr = m_pTrident->QueryInterface(IID_IOleControl, (LPVOID*)&pOleControl)))
    {
        goto Error;
    }
    hr = pOleControl->OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL);
    pOleControl->Release();

    // Hook up sink to catch ready state property change
    if (FAILED(hr = m_pTrident->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pCPC)))
    {
        goto Error;
    }

    if (FAILED(hr = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &m_pCP)))
    {
        goto Error;
    }

    m_hrConnected = m_pCP->Advise((LPUNKNOWN)(IPropertyNotifySink*)this, &m_dwCookie);
    
Error:
    if (pCPC) 
        pCPC->Release();

    return hr;
}

// Clean up connection point
HRESULT CWalker::TermForMSHTML()
{
    HRESULT hr = NOERROR;

    // Disconnect from property change notifications
    if (SUCCEEDED(m_hrConnected))
    {
        hr = m_pCP->Unadvise(m_dwCookie);
    }

    // Release the connection point
    if (m_pCP) 
        m_pCP->Release();

    if (m_pTrident)
        m_pTrident->Release();
        
    return hr;
}

HRESULT CWalker::ExtractUnHiddenText(BSTR* pbstrText)
{
    VARIANT                  vIndex;
    LPDISPATCH               pDisp; 
    IHTMLInputHiddenElement* pHidden;
    IHTMLElement*            pElement;
    BSTR                     bstrValue;
    VARIANT                  var2   = { 0 };
    long                     lLen   = 0;
          
    vIndex.vt = VT_UINT;
    bstrValue = SysAllocString(A2W(TEXT("\0")));

    
    Walk();

    if (!m_pNextForm)
        return E_UNEXPECTED;
    
    m_pNextForm->get_length(&lLen);
       
    for (int i = 0; i < lLen; i++)
    {
        vIndex.lVal = i;
        pDisp = NULL;     

        if(SUCCEEDED(m_pNextForm->item(vIndex, var2, &pDisp)) && pDisp)
        {
            pHidden = NULL;
            
            if(SUCCEEDED(pDisp->QueryInterface(IID_IHTMLInputHiddenElement, (LPVOID*)&pHidden)) && pHidden)
            {
                pHidden->put_value(bstrValue);
                pHidden->Release();    
            }
            pDisp->Release();
        }
    }
    
    if (SUCCEEDED(m_pNextForm->QueryInterface(IID_IHTMLElement, (LPVOID*)&pElement)) && pElement) 
        pElement->get_innerHTML(pbstrText);

    SysFreeString(bstrValue);
    
    return S_OK;
}

HRESULT CWalker::AttachToMSHTML(BSTR bstrURL)
{
    HRESULT hr;
    
    // Release any previous instance of the HTML document pointer we might be holding on to
    if(m_pMSHTML)
    {
        m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
    
    m_pMSHTML = m_pTrident;
    m_pMSHTML->AddRef();
    
    m_hEventTridentDone = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    hr = LoadURLFromFile(bstrURL);
    if (SUCCEEDED(hr) || (E_PENDING == hr))
    {
        if (m_hEventTridentDone)
        {
            MSG     msg;
            DWORD   dwRetCode;
            HANDLE  hEventList[1];
            hEventList[0] = m_hEventTridentDone;
    
            while (TRUE)
            {
                // We will wait on window messages and also the named event.
                dwRetCode = MsgWaitForMultipleObjects(1, 
                                                  &hEventList[0], 
                                                  FALSE, 
                                                  300000,            // 5 minutes
                                                  QS_ALLINPUT);

                // Determine why we came out of MsgWaitForMultipleObjects().  If
                // we timed out then let's do some TrialWatcher work.  Otherwise
                // process the message that woke us up.
                if (WAIT_TIMEOUT == dwRetCode)
                {
                    break;
                }
                else if (WAIT_OBJECT_0 == dwRetCode)
                {
                    break;
                }
                else if (WAIT_OBJECT_0 + 1 == dwRetCode)
                {
                    // Process all messages in the Queue, since MsgWaitForMultipleObjects
                    // will not do this for us
                    while (TRUE)
                    {   
                        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                            if (WM_QUIT == msg.message)
                            {
                                break;
                            }
                            else
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }                                
                        } 
                        else
                        {
                            break;
                        }                   
                    }
                }
            }
            
            CloseHandle(m_hEventTridentDone);
            m_hEventTridentDone = 0;
        }            
        else
        {
            // If we were pending, and we could not wait, we got a problem...
            if(E_PENDING == hr)
                hr = E_FAIL;
        }
    }
    return (hr);
}

HRESULT CWalker::AttachToDocument(IWebBrowser2 *lpWebBrowser)
{
    HRESULT     hr;
    LPDISPATCH  pDisp; 
   
    // Release any previous instance of the HTML document pointer we might be holding on to
    if(m_pMSHTML)
    {
        // If the m_pMSHMTL is NOT our internal Trident object (for walking files)
        // then sombody did not do a detach, so we need to release the previous
        // MSHTML object
        if (m_pMSHTML != m_pTrident)
            m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
       
    // Make sure we have a webbrowser to grab onto      
    ASSERT(lpWebBrowser);

    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(hr = lpWebBrowser->get_Document(&pDisp)))  
    {
        if (pDisp)
        {
            hr = pDisp->QueryInterface( IID_IHTMLDocument2, (LPVOID*)&m_pMSHTML );
            // Paranoia, but trident/shdocvw might say OK, but really not give us a document
            if (!m_pMSHTML)
                hr = E_FAIL;
                
            pDisp->Release();                
        }
        else
        {
            hr = E_FAIL;                
        }            
    }
    return (hr);    
}

HRESULT CWalker::Detach()
{
    if (m_pPageIDForm)
    {
        m_pPageIDForm->Release();
        m_pPageIDForm = NULL;
    }       
    if (m_pBackForm)
    {
        m_pBackForm->Release();
        m_pBackForm = NULL;
    }        
    if (m_pPageTypeForm)
    {
        m_pPageTypeForm->Release();
        m_pPageTypeForm = NULL;
    }        
    if (m_pNextForm)
    {
        m_pNextForm->Release();
        m_pNextForm = NULL;
    }        
    if (m_pPageFlagForm)
    {
        m_pPageFlagForm->Release();
        m_pPageFlagForm = NULL;
    }        
    if(m_pMSHTML)
    {
        // If the m_pMSHMTL is NOT our internal Trident object (for walking files)
        // then sombody did not do a detach, so we need to release the previous
        // MSHTML object
        if (m_pMSHTML != m_pTrident)
            m_pMSHTML->Release();
        m_pMSHTML = NULL;
    }
    return S_OK;
}

// Walk the object model.
HRESULT CWalker::Walk()
{
    HRESULT hr;
    IHTMLElementCollection* pColl = NULL;

    assert(m_pMSHTML);
    if (!m_pMSHTML)
    {
        return E_UNEXPECTED;
    }

    // retrieve a reference to the ALL collection
    if (SUCCEEDED(hr = m_pMSHTML->get_all( &pColl )))
    {
        long cElems;

        assert(pColl);

        // retrieve the count of elements in the collection
        if (SUCCEEDED(hr = pColl->get_length( &cElems )))
        {
            // for each element retrieve properties such as TAGNAME and HREF
            for ( int i=0; i<cElems; i++ )
            {
                VARIANT vIndex;
                vIndex.vt = VT_UINT;
                vIndex.lVal = i;
                VARIANT var2 = { 0 };
                LPDISPATCH pDisp; 

                if (SUCCEEDED(hr = pColl->item( vIndex, var2, &pDisp )))
                {
                    // Look for <FORM> tags
                    IHTMLFormElement* pForm = NULL;
                    if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                    {
                        BSTR    bstrName;
                                                    
                        assert(pForm);

                        // Get the Name
                        hr = pForm->get_name(&bstrName);
                        if (SUCCEEDED(hr))
                        {
                            LPTSTR   lpszName = W2A(bstrName);
                            
                            // See what kind it is
                            if (lstrcmpi(lpszName, cszFormNamePAGEID) == 0)
                            {
                                m_pPageIDForm = pForm;
                                m_pPageIDForm->AddRef();
                            }                                    
                            else if (lstrcmpi(lpszName, cszFormNameBACK) == 0)
                            {
                                m_pBackForm = pForm;
                                m_pBackForm->AddRef();
                            }
                            else if (lstrcmpi(lpszName, cszFormNamePAGETYPE) == 0)
                            {
                                m_pPageTypeForm = pForm;
                                m_pPageTypeForm->AddRef();
                            }
                            else if (lstrcmpi(lpszName, cszFormNameNEXT) == 0)
                            {
                                m_pNextForm = pForm;
                                m_pNextForm->AddRef();
                            }
                            else if (lstrcmpi(lpszName, cszFormNamePAGEFLAG) == 0)
                            {
                                m_pPageFlagForm = pForm;
                                m_pPageFlagForm->AddRef();
                            }
                            
                            SysFreeString(bstrName);
                        }
                        pForm->Release();
                    }
                    pDisp->Release();
                } // item
            } // for
        } // get_length
        pColl->Release();
    } // get_all

    return hr;
}



HRESULT CWalker::get_IsQuickFinish(BOOL* pbIsQuickFinish)
{
    if (!m_pPageTypeForm)
        return (E_FAIL);

    IHTMLElement* pElement = NULL;
    VARIANT       varValue;
    VariantInit(&varValue);

    V_VT(&varValue) = VT_BSTR;    
    *pbIsQuickFinish = FALSE;

    if (SUCCEEDED(m_pPageTypeForm->QueryInterface(IID_IHTMLElement, (void**)&pElement)))
    {
        if (SUCCEEDED(pElement->getAttribute(A2W(TEXT("QUICKFINISH")), FALSE, &varValue)))
        {   
            if (VT_NULL != varValue.vt)
            {
                if(lstrcmpi(W2A(varValue.bstrVal), TEXT("TRUE")) == 0)
                    *pbIsQuickFinish = TRUE;
            }                    
        }
        pElement->Release();
    }
    return S_OK;
}

HRESULT CWalker::get_PageType(LPDWORD pdwPageType)
{
    BSTR    bstr;
    HRESULT hr;
    
    if (!m_pPageTypeForm)
        return (E_FAIL);
                                                          
    // Get the Action for the PageType Form
    hr = m_pPageTypeForm->get_action(&bstr);
    if (SUCCEEDED(hr))
    {
        LPTSTR   lpszType = W2A(bstr);
  
        // See what kind it is
        if (lstrcmpi(lpszType, cszPageTypeTERMS) == 0)
            *pdwPageType = PAGETYPE_ISP_TOS;
        else if (lstrcmpi(lpszType, cszPageTypeCUSTOMFINISH) == 0)
            *pdwPageType = PAGETYPE_ISP_CUSTOMFINISH;
        else if (lstrcmpi(lpszType, cszPageTypeFINISH) == 0)
            *pdwPageType = PAGETYPE_ISP_FINISH;
        else if (lstrcmpi(lpszType, cszPageTypeNORMAL) == 0)
            *pdwPageType = PAGETYPE_ISP_NORMAL;
        else
            *pdwPageType = PAGETYPE_UNDEFINED;
            
        SysFreeString(bstr);            
    }
        
    return (hr);    
}

HRESULT CWalker::get_PageFlag(LPDWORD pdwPageFlag)
{
    BSTR    bstr;
    HRESULT hr;
    
    *pdwPageFlag = 0;

    if (!m_pPageFlagForm)
        return (E_FAIL);
                                                   
    // Get the Action for the PageFlag Form
    hr = m_pPageFlagForm->get_action(&bstr);
    if (SUCCEEDED(hr))
    {
        LPTSTR   lpszType = W2A(bstr);
                            
        // See what kind it is
        *pdwPageFlag = _ttol(lpszType);
            
        SysFreeString(bstr);            
    }
        
    return (hr);    
}

HRESULT CWalker::get_PageID(BSTR    *pbstrPageID)
{
    HRESULT hr;
    
    if (!m_pPageIDForm)
        return (E_FAIL);
    
    if (!pbstrPageID)
        return (E_FAIL);
                                                              
    // Get the Action for the PageType Form
    hr = m_pPageIDForm->get_action(pbstrPageID);
        
    return (hr);    
}

HRESULT CWalker::getQueryString
(
    IHTMLFormElement    *pForm,
    LPTSTR               lpszQuery
)    
{
    HRESULT hr;
    long    lFormLength;

    if (SUCCEEDED(pForm->get_length(&lFormLength)))
    {
        for (int i = 0; i < lFormLength; i++)
        {
            VARIANT vIndex;
            vIndex.vt = VT_UINT;
            vIndex.lVal = i;
            VARIANT var2 = { 0 };
            LPDISPATCH pDisp; 

            if (SUCCEEDED(hr = pForm->item( vIndex, var2, &pDisp )))
            {
                // See if the Item is a Input button
                IHTMLButtonElement* pButton = NULL;
                IHTMLInputButtonElement* pInputButton = NULL;
                IHTMLInputFileElement* pInputFile = NULL;
                IHTMLInputHiddenElement* pInputHidden = NULL;
                IHTMLInputTextElement* pInputText = NULL;
                IHTMLSelectElement* pSelect = NULL;
                IHTMLTextAreaElement* pTextArea = NULL;
                IHTMLOptionButtonElement* pOptionButton = NULL;
                
                // First check to see if this is an OptionButton.
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLOptionButtonElement, (LPVOID*)&pOptionButton )))
                {
                    BSTR    bstr = NULL;
                    
                    // See if it is a Radio or a CheckBox
                    if (SUCCEEDED(pOptionButton->get_type(&bstr)))
                    {
                        LPTSTR   lpszType = W2A(bstr);
                        
                        if ((lstrcmpi(lpszType, TEXT("radio")) == 0) || (lstrcmpi(lpszType, TEXT("checkbox")) == 0))
                        {
                            short    bChecked;
                            // See if the button is checked. If it is, then it needs to be
                            // added to the query string
                            if (SUCCEEDED(pOptionButton->get_checked(&bChecked)))
                            {
                                if(bChecked)
                                {
                                    BSTR    bstrName;
                                    BSTR    bstrValue;
                                    
            
                                    if ( SUCCEEDED(pOptionButton->get_name(&bstrName)) &&
                                         SUCCEEDED(pOptionButton->get_value(&bstrValue)) )
                                    {
                                        if (bstrValue)
                                        {
                                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                                            if (szVal)
                                            {
                                                memcpy(szVal, W2A(bstrValue), size);
                                                URLEncode(szVal, size * 3);
                                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                                // Cleanup
                                                free(szVal);
                                            }
                                            SysFreeString(bstrName);
                                            SysFreeString(bstrValue);
                                        }
                                    }

                                }
                            }
                        }
                        SysFreeString(bstr);
                        
                    }
                    
                    // Release the interface
                    pOptionButton->Release();
                    continue;
                }                                
                
                // For the rest we need to form Name=Value pairs
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLButtonElement, (LPVOID*)&pButton )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pButton->get_name(&bstrName)) &&
                        SUCCEEDED(pButton->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR) * (lstrlen(W2A(bstrValue)) + 1 );
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pButton->Release();
                    continue;
                }
                
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputFileElement, (LPVOID*)&pInputFile )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pInputFile->get_name(&bstrName)) &&
                        SUCCEEDED(pInputFile->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pInputFile->Release();
                    continue;
                }
                
                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputHiddenElement, (LPVOID*)&pInputHidden )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pInputHidden->get_name(&bstrName)) &&
                        SUCCEEDED(pInputHidden->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pInputHidden->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLInputTextElement, (LPVOID*)&pInputText )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pInputText->get_name(&bstrName)) &&
                        SUCCEEDED(pInputText->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pInputText->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLSelectElement, (LPVOID*)&pSelect )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pSelect->get_name(&bstrName)) &&
                        SUCCEEDED(pSelect->get_value(&bstrValue)) )
                    {
                        if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pSelect->Release();
                    continue;
                }

                if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLTextAreaElement, (LPVOID*)&pTextArea )))
                {
                    BSTR    bstrName;
                    BSTR    bstrValue;
                                    
                    if (SUCCEEDED(pTextArea->get_name(&bstrName)) &&
                        SUCCEEDED(pTextArea->get_value(&bstrValue)) )
                    {
                         if (bstrValue)
                        {
                            size_t size = sizeof(TCHAR)*(lstrlen(W2A(bstrValue)) + 1);
                            TCHAR* szVal = (TCHAR*)malloc(size * 3);
                            if (szVal)
                            {
                                memcpy(szVal, W2A(bstrValue), size);
                                URLEncode(szVal, size * 3);
                                URLAppendQueryPair(lpszQuery, W2A(bstrName), szVal);                
                                // Cleanup
                                free(szVal);
                            }
                            SysFreeString(bstrName);
                            SysFreeString(bstrValue);
                        }
                    }
                    
                    // Release the interface pointer                    
                    pTextArea->Release();
                }
                pDisp->Release();
            }                
        }
    }
    
    // Null out the last Ampersand, since we don't know when we added the last pair, so we got
    // a trailing ampersand
    lpszQuery[lstrlen(lpszQuery)-1] = '\0';
    
    return S_OK;
}

HRESULT CWalker::get_FirstFormQueryString
(
    LPTSTR  lpszQuery
)
{
    HRESULT                 hr;
    IHTMLElementCollection  *pColl = NULL;
    BOOL                    bDone = FALSE;

    assert(m_pMSHTML);
    if (!m_pMSHTML)
    {
        return E_UNEXPECTED;
    }

    // retrieve a reference to the ALL collection
    if (SUCCEEDED(hr = m_pMSHTML->get_all( &pColl )))
    {
        long cElems;

        assert(pColl);

        // retrieve the count of elements in the collection
        if (SUCCEEDED(hr = pColl->get_length( &cElems )))
        {
            // for each element retrieve properties such as TAGNAME and HREF
            for ( int i=0; (i<cElems) && !bDone; i++ )
            {
                VARIANT vIndex;
                vIndex.vt = VT_UINT;
                vIndex.lVal = i;
                VARIANT var2 = { 0 };
                LPDISPATCH pDisp; 

                if (SUCCEEDED(hr = pColl->item( vIndex, var2, &pDisp )))
                {
                    // Look for <FORM> tags
                    IHTMLFormElement* pForm = NULL;
                    if (SUCCEEDED(hr = pDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                    {
                        assert(pForm);
                        
                        if (SUCCEEDED(getQueryString(pForm, lpszQuery)))
                        {
                            hr = ERROR_SUCCESS;
                        }   
                        else
                        {
                            hr = E_FAIL;
                        }
                        
                        pForm->Release();
                        bDone = TRUE;
                    }
                    pDisp->Release();
                }
            }
        }
        pColl->Release();
    }                                                                                

    // If we fall out of the loop, that is bad, so return a failure code
    if (!bDone)
        hr = E_FAIL;
    
    return (hr);    
}

// For the URL for the next page
HRESULT CWalker::get_URL
(        
    LPTSTR  lpszURL,
    BOOL    bForward
)
{

    HRESULT             hr = S_OK;
    BSTR                bstrURL;
    TCHAR               szQuery[INTERNET_MAX_URL_LENGTH];
    IHTMLFormElement    * pForm =  bForward ? get_pNextForm() : get_pBackForm();
        
    if (!pForm)
        return (E_FAIL);
        
                                                    
    // Get the Action for the Next Form
    hr = pForm->get_action(&bstrURL);
    if (SUCCEEDED(hr))
    {
        memset(szQuery, 0, sizeof(szQuery));
        lstrcpy(szQuery, cszQuestion);
    
        // Get the Query String
        if (SUCCEEDED(getQueryString(pForm, szQuery)))
        {
            // Catenate the two together into the dest buffer
            lstrcpy(lpszURL, W2A(bstrURL));
            lstrcat(lpszURL, szQuery);
        }   
        
        SysFreeString(bstrURL);            
    }    
    
    return hr;
}

HRESULT CWalker::get_IeakIspFile(LPTSTR lpszIspFile)
{
    ASSERT(m_pMSHTML);

    IHTMLElementCollection* pColl = NULL;

    // retrieve a reference to the ALL collection
    if (SUCCEEDED(m_pMSHTML->get_all( &pColl )))
    {
        LPDISPATCH pDisp   = NULL; 
        VARIANT    varName;
        VARIANT    varIdx;

        VariantInit(&varName);
        V_VT(&varName)  = VT_BSTR;
        varName.bstrVal = A2W(HARDCODED_IEAK_ISPFILE_ELEMENT_ID);
        varIdx.vt       = VT_UINT;
        varIdx.lVal     = 0;

        if (SUCCEEDED(pColl->item(varName, varIdx, &pDisp)) && pDisp)
        {
            IHTMLElement* pElement = NULL;
            if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLElement, (void**)&pElement)))
            {
                BSTR bstrVal;
                if (SUCCEEDED(pElement->get_innerHTML(&bstrVal)))
                {
                    lstrcpy(lpszIspFile, W2A(bstrVal));
                    SysFreeString(bstrVal);
                }
                pElement->Release();
            }    
            pDisp->Release();
        }
        pColl->Release();
    }
    return S_OK;
}


void CWalker::GetInputValue
(
    LPTSTR              lpszName, 
    BSTR                *pVal,
    UINT                index,
    IHTMLFormElement    *pForm
)
{
    VARIANT varName;
    VariantInit(&varName);
    V_VT(&varName) = VT_BSTR;
    varName.bstrVal = A2W(lpszName);

    VARIANT varIdx;
    varIdx.vt = VT_UINT;
    varIdx.lVal = index;

    LPDISPATCH pDispElt = NULL; 
    // Get the IDispatch for the named element, from the collection of elements in the
    // passed in form object.
    if (SUCCEEDED(pForm->item(varName, varIdx, &pDispElt)) && pDispElt)
    {
        IHTMLInputElement *pInput = NULL;
        // Get the HTMLInputElement interface, so we can get the value associated with
        // this element
        if (SUCCEEDED(pDispElt->QueryInterface(IID_IHTMLInputElement,(LPVOID*) &pInput)) && pInput)
        {
            pInput->get_value(pVal);
            pInput->Release();
        }
        pDispElt->Release();
    }
}

// Grovel through the OLS HTML and update the registry, and make any desktop shortcuts
HRESULT CWalker::ProcessOLSFile(IWebBrowser2* lpWebBrowser)
{   
    LPDISPATCH      pDisp; 
    
    // Get the document pointer from this webbrowser.
    if (SUCCEEDED(lpWebBrowser->get_Document(&pDisp)))  
    {
         // Call might succeed but that dosen't guarantee a valid ptr
        if(pDisp)
        {
            IHTMLDocument2* pDoc;
            if (SUCCEEDED(pDisp->QueryInterface(IID_IHTMLDocument2, (void**)&pDoc)))
            {
                IHTMLElementCollection* pColl = NULL;
                // retrieve a reference to the ALL collection
                if (SUCCEEDED(pDoc->get_all( &pColl )))
                {
                    long cElems;
                    assert(pColl);

                    // retrieve the count of elements in the collection
                    if (SUCCEEDED(pColl->get_length( &cElems )))
                    {
                        VARIANT vIndex;
                        vIndex.vt = VT_UINT;
                        VARIANT var2 = { 0 };
                        
                        for ( int i=0; i<cElems; i++ )
                        {
                            vIndex.lVal = i;
                            LPDISPATCH pElementDisp; 

                            if (SUCCEEDED(pColl->item( vIndex, var2, &pElementDisp )))
                            {
                                IHTMLFormElement* pForm = NULL;
                                if (SUCCEEDED(pElementDisp->QueryInterface( IID_IHTMLFormElement, (LPVOID*)&pForm )))
                                {
                                    BSTR        bstrName = NULL;
                                    
                                    // Get the name of the form, and see if it is the regEntries form
                                    if (SUCCEEDED(pForm->get_name(&bstrName)))
                                    {
                                        if (lstrcmpi(W2A(bstrName), cszOLSRegEntries) == 0)
                                        {
                                            BSTR    bstrAction = NULL;                                        
                                            // The Action value for this form contains the number of
                                            // reg entries we need to process
                                            if (SUCCEEDED(pForm->get_action(&bstrAction)))
                                            {
                                                int iNumEntries  = _ttoi(W2A(bstrAction));
                                                for (int x = 0; x < iNumEntries; x++)
                                                {
                                                    BSTR    bstrKeyName = NULL;
                                                    BSTR    bstrEntryName = NULL;
                                                    BSTR    bstrEntryValue = NULL;
                                                    HKEY    hkey;
                                                    HKEY    hklm;
                                                                                                        
                                                    // For each entry we need to get the
                                                    // following values:
                                                    // KeyName, EntryName, EntryValue
                                                    GetInputValue((LPTSTR)cszKeyName, &bstrKeyName, x, pForm);
                                                    GetInputValue((LPTSTR)cszEntryName, &bstrEntryName, x, pForm);
                                                    GetInputValue((LPTSTR)cszEntryValue, &bstrEntryValue, x, pForm);
                                                    
                                                    if (bstrKeyName && bstrEntryName && bstrEntryValue)
                                                    {
                                                        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                                         NULL,
                                                                         0,
                                                                         KEY_ALL_ACCESS,
                                                                         &hklm) == ERROR_SUCCESS)
                                                        {
                                                                    
                                                            DWORD dwDisposition;
                                                            if (ERROR_SUCCESS == RegCreateKeyEx(hklm,
                                                                                                W2A(bstrKeyName),
                                                                                                0,
                                                                                                NULL,
                                                                                                REG_OPTION_NON_VOLATILE, 
                                                                                                KEY_ALL_ACCESS, 
                                                                                                NULL, 
                                                                                                &hkey, 
                                                                                                &dwDisposition))
                                                            {
                                                                LPTSTR   lpszValue = W2A(bstrEntryValue);
                                                                RegSetValueEx(hkey,
                                                                              W2A(bstrEntryName),
                                                                              0,
                                                                              REG_SZ,
                                                                              (LPBYTE) lpszValue,
                                                                              sizeof(TCHAR)*(lstrlen(lpszValue)+1));

                                                                RegCloseKey(hkey);
                                                            }       
                                                            RegCloseKey(hklm);
                                                        }        
                                                                                    
                                                        SysFreeString(bstrKeyName);
                                                        SysFreeString(bstrEntryName);
                                                        SysFreeString(bstrEntryValue);
                                                    }                                        
                                                }
                                                SysFreeString(bstrAction);
                                            }
                                        }
                                        else if (lstrcmpi(W2A(bstrName), cszOLSDesktopShortcut) == 0)
                                        {
                                            // Need to create a desktop shortcut
                                            BSTR    bstrSourceName = NULL;
                                            BSTR    bstrTargetName = NULL;
                                                                                                        
                                            // For each entry we need to get the
                                            // following values:
                                            // KeyName, EntryName, EntryValue
                                            GetInputValue((LPTSTR)cszSourceName, &bstrSourceName, 0, pForm);
                                            GetInputValue((LPTSTR)cszTargetName, &bstrTargetName, 0, pForm);
                                                    
                                            if (bstrSourceName && bstrTargetName)
                                            {
                                                TCHAR           szLinkPath[MAX_PATH];
                                                TCHAR           szDestPath[MAX_PATH];
                                                LPITEMIDLIST    lpItemDList = NULL;
                                                IMalloc         *pMalloc = NULL;
                                                   
                                                // Get a reference to the shell allocator
                                                if (SUCCEEDED (SHGetMalloc (&pMalloc)))
                                                {
                                                    if (SUCCEEDED(SHGetSpecialFolderLocation( NULL, CSIDL_PROGRAMS, &lpItemDList)))
                                                    {
                                                    
                                                        SHGetPathFromIDList(lpItemDList, szLinkPath);
                                                        lstrcat(szLinkPath, TEXT("\\"));
                                                        lstrcat(szLinkPath, W2A(bstrSourceName));
                                                        
                                                        pMalloc->Free (lpItemDList);
                                                        lpItemDList = NULL;
                                                        // Form the name where we will copy to
                                                        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList)))
                                                        {
                                                            SHGetPathFromIDList(lpItemDList, szDestPath);
                                                            pMalloc->Free (lpItemDList);
                                                        
                                                            lstrcat(szDestPath, TEXT("\\"));
                                                            lstrcat(szDestPath, W2A(bstrTargetName));
                                                            
                                                            CopyFile(szLinkPath, szDestPath, FALSE);
                                                        }
                                                    }
                                                    // Release the allocator
                                                    pMalloc->Release ();
                                                }
                                                SysFreeString(bstrSourceName);
                                                SysFreeString(bstrTargetName);
                                            }
                                        }
                                        
                                        SysFreeString(bstrName);
                                    }   
                                    pForm->Release();                                     
                                }
                                pElementDisp->Release();
                            } // item
                        } // for
                    } // get_length
                    pColl->Release();
                } // get_all
                pDoc->Release();
            }
            pDisp->Release();
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\appdefs.h ===
#ifndef __APPDEFS_H_
#define __APPDEFS_H_

//This file is for application wide definitions
//e.g. defs that are in common between the exe and various dlls

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

#define ICW_DOWNLOADABLE_COMPONENT_NAME        TEXT("ICWCONN.DLL")
#define ICW_DOWNLOADABLE_COMPONENT_GETVERFUNC  "GetICWCONNVersion"
#define ICW_DOWNLOADABLE_COMPONENT_VERSION     500
#define ICW_OS_VER                             TEXT("01")

#define ID_BUSY_ANIMATION_WINDOW               10000

#define ICW_UTIL                               TEXT("icwutil.dll")
#define ICW_RESOURCE_ONLY_DLL                  TEXT("icwres.dll")
#define ICW_HTML_HELP_FILE                     TEXT("icwdial.chm")
#define ICW_HTML_HELP_TROUBLE_TOPIC            TEXT("icwdial.chm::/icw_trb.htm")

#define MAX_TITLE                              150
#define MAX_MESSAGE                            255
#define MAX_MESSAGE_LEN                        MAX_RES_LEN * 4
#define MAX_INFO_LEN                           MAX_RES_LEN * 3

#define LCID_CHT                               1028  //CHINESE TRADITIONAL
#define LCID_S_KOR                             1042  //SOUTH KOREAN
#define LCID_N_KOR                             2066  //NORTH KOREAN
#define LCID_CHS                               2052  //CHINESE SIMPLIFIED
#define LCID_JPN                               1041  //JAPANESE

//various flags for the icw including branding stuff
#define ICW_CFGFLAG_OFFERS                     0x00000001  // 0 = No offer;        1 = offers
#define ICW_CFGFLAG_AUTOCONFIG                 0x00000002  // 0 = No;              1 = Yes
#define ICW_CFGFLAG_CNS                        0x00000004  // 0 = No star;         1 = Star
#define ICW_CFGFLAG_SIGNUP_PATH                0x00000008  // 0 = Jump to Finish;  1 = Continue down sign up path
#define ICW_CFGFLAG_USERINFO                   0x00000010  // 0 = Hide name/addr;  1 = Show name/addr page
#define ICW_CFGFLAG_BILL                       0x00000020  // 0 = Hide bill        1 = Show bill page
#define ICW_CFGFLAG_PAYMENT                    0x00000040  // 0 = Hide payment;    1 = Show payment page
#define ICW_CFGFLAG_SECURE                     0x00000080  // 0 = Not secure;      1 = Secure
#define ICW_CFGFLAG_IEAKMODE                   0x00000100  // 0 = No IEAK;         1 = IEAK
#define ICW_CFGFLAG_BRANDED                    0x00000200  // 0 = No branding;     1 = Branding
#define ICW_CFGFLAG_SBS                        0x00000400  // 0 = No SBS           1 = SBS
#define ICW_CFGFLAG_ALLOFFERS                  0x00000800  // 0 = Not all offers   1 = All offers
#define ICW_CFGFLAG_USE_COMPANYNAME            0x00001000  // 0 = Not use          1 = Use company name
#define ICW_CFGFLAG_ISDN_OFFER                 0x00002000  // 0 = Non-ISDN offer   1 = ISDN offer
#define ICW_CFGFLAG_OEM_SPECIAL                0x00004000  // 0 = non OEM special offer    1 = OEM special offer
#define ICW_CFGFLAG_OEM                        0x00008000  // 0 = non OEM offer    1 = OEM offer
#define ICW_CFGFLAG_MODEMOVERRIDE              0x00010000  
#define ICW_CFGFLAG_ISPURLOVERRIDE             0x00020000
#define ICW_CFGFLAG_PRODCODE_FROM_CMDLINE      0x00040000
#define ICW_CFGFLAG_PROMOCODE_FROM_CMDLINE     0x00080000
#define ICW_CFGFLAG_OEMCODE_FROM_CMDLINE       0x00100000
#define ICW_CFGFLAG_SMARTREBOOT_NEWISP         0x00200000
#define ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG     0x00400000  // this is seperate from ICW_CFGFLAG_AUTOCONFIG so as not to confuse function of flag
#define ICW_CFGFLAG_SMARTREBOOT_MANUAL         0x00800000
#define ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS  0x01000000
#define ICW_CFGFLAG_SMARTREBOOT_LAN            0x02000000

//Info required flags
// 1 -- required
// 0 -- optional

//User Info
#define REQUIRE_FE_NAME                        0x00000001
#define REQUIRE_FIRSTNAME                      0x00000002
#define REQUIRE_LASTNAME                       0x00000004
#define REQUIRE_ADDRESS                        0x00000008
#define REQUIRE_MOREADDRESS                    0x00000010
#define REQUIRE_CITY                           0x00000020
#define REQUIRE_STATE                          0x00000040
#define REQUIRE_ZIP                            0x00000080
#define REQUIRE_PHONE                          0x00000100
#define REQUIRE_COMPANYNAME                    0x00000200
//Credit Card
#define REQUIRE_CCNAME                         0x00000400
#define REQUIRE_CCADDRESS                      0x00000800
#define REQUIRE_CCNUMBER                       0x00001000
#define REQUIRE_CCZIP                          REQUIRE_ZIP
//Invoice
#define REQUIRE_IVADDRESS1                     REQUIRE_ADDRESS
#define REQUIRE_IVADDRESS2                     REQUIRE_MOREADDRESS
#define REQUIRE_IVCITY                         REQUIRE_CITY
#define REQUIRE_IVSTATE                        REQUIRE_STATE
#define REQUIRE_IVZIP                          REQUIRE_ZIP
//Phone
#define REQUIRE_PHONEIV_BILLNAME               0x00002000
#define REQUIRE_PHONEIV_ACCNUM                 REQUIRE_PHONE

//Htm pagetype flags
#define PAGETYPE_UNDEFINED                     E_FAIL
#define PAGETYPE_NOOFFERS                      0x00000001
#define PAGETYPE_MARKETING                     0x00000002
#define PAGETYPE_BRANDED                       0x00000004
#define PAGETYPE_BILLING                       0x00000008
#define PAGETYPE_CUSTOMPAY                     0x00000010
#define PAGETYPE_ISP_NORMAL                    0x00000020
#define PAGETYPE_ISP_TOS                       0x00000040
#define PAGETYPE_ISP_FINISH                    0x00000080
#define PAGETYPE_ISP_CUSTOMFINISH              0x00000100
#define PAGETYPE_OLS_FINISH                    0x00000200

//Htm page flags
#define PAGEFLAG_SAVE_CHKBOX                   0x00000001  // Display ISP HTML with checkbox to save info at the bottom

//IEAK ICW isp/htm section info
#define ICW_IEAK_SECTION                       TEXT("ICW_IEAK")
#define ICW_IEAK_USEICW                        TEXT("Use_ICW")
#define ICW_IEAK_ISPNAME                       TEXT("Isp_Display_Name")
#define ICW_IEAK_HTML                          TEXT("Html_Page")
#define ICW_IEAK_TITLE                         TEXT("TitleBar")
#define ICW_IEAK_HEADER_BMP                    TEXT("Header_Bitmap")
#define ICW_IEAK_WATERMARK_BMP                 TEXT("Watermark_Bitmap")
#define ICW_IEAK_USERINFO                      TEXT("Get_UserInfo")
#define ICW_IEAK_BILLING                       TEXT("Get_BillingInfo")
#define ICW_IEAK_PAYMENT                       TEXT("Get_PaymentInfo")
#define ICW_IEAK_BILLINGHTM                    TEXT("Billing_Options_Page")
#define ICW_IEAK_PAYMENTCSV                    TEXT("Payment_Csv_File")
#define ICW_IEAK_TUTORCMDLN                    TEXT("Tutorial_Application_Command_Line")
#define ICW_IEAK_USECOMPANYNAME                TEXT("UseCompanyName")
#define ICW_IEAK_VALIDATEFLAGS                 TEXT("ValidationFlags")

//OEMINFO ICW section info
#define ICW_OEMINFO_FILENAME                   TEXT("oeminfo.ini")
#define ICW_OEMINFO_OEMSECTION                 TEXT("General")
#define ICW_OEMINFO_OEMKEY                     TEXT("Manufacturer")
#define ICW_OEMINFO_ICWSECTION                 TEXT("ICW")
#define ICW_OEMINFO_PRODUCTCODE                TEXT("Product")
#define ICW_OEMINFO_PROMOCODE                  TEXT("Promo")
#define ICW_OEMINFO_ALLOFFERS                  TEXT("AllOffers")
#define ICW_OEMINFO_OFFLINEOFFERS              TEXT("OfflineOffers")
#define ICW_OEMINFO_TUTORCMDLN                 ICW_IEAK_TUTORCMDLN
#define ICW_ISPINFOPath                        TEXT("download\\ispinfo.csv")
#define ICW_OEMINFOPath                        TEXT("offline\\oeminfo.csv")

#define ICW50_PATHKEY                          TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE")

#define SPECIAL_VAL_NOOFFER                    0
#define SPECIAL_VAL_OLS                        -1

#define EXTERNAL_DLG_START                     2300

#ifdef ICWDEBUG
//page index defines for ICWDEBUG.EXE
#define ORD_PAGE_ICWDEBUG_OFFER                0
#define ORD_PAGE_ICWDEBUG_SETTINGS             1
#define ORD_PAGE_END                           2
#define EXE_MAX_PAGE_INDEX                     2
#define EXE_NUM_WIZARD_PAGES                   3       // total number of pages in wizard
#else
// page index defines for ICWCONN1.EXE
#define ORD_PAGE_INTRO                         0
#define ORD_PAGE_MANUALOPTIONS                 1
#define ORD_PAGE_AREACODE                      2
#define ORD_PAGE_REFSERVDIAL                   3
#define ORD_PAGE_END                           4
#define ORD_PAGE_ENDOEMCUSTOM                  5
#define ORD_PAGE_ENDOLS                        6
#define ORD_PAGE_REFDIALERROR                  7
#define ORD_PAGE_MULTINUMBER                   8
#define ORD_PAGE_REFSERVERR                    9
#define ORD_PAGE_BRANDEDINTRO                  10
#define ORD_PAGE_INTRO2                        11
#define ORD_PAGE_DEFAULT                       12
#define ORD_PAGE_SBSINTRO                      13
#define EXE_MAX_PAGE_INDEX                     13
#define EXE_NUM_WIZARD_PAGES                   14      // total number of pages in wizard
#endif //ICWDEBUG

// page index defines for ICWCONN.DLL
#define ORD_PAGE_ISPSELECT                     0
#define ORD_PAGE_NOOFFER                       1
#define ORD_PAGE_USERINFO                      2
#define ORD_PAGE_BILLINGOPT                    3
#define ORD_PAGE_PAYMENT                       4
#define ORD_PAGE_ISPDIAL                       5
#define ORD_PAGE_ISPDATA                       6
#define ORD_PAGE_OLS                           7
#define ORD_PAGE_DIALERROR                     8
#define ORD_PAGE_SERVERR                       9
#define ORD_PAGE_ISP_AUTOCONFIG                10
#define ORD_PAGE_ISP_AUTOCONFIG_NOOFFER        11
#define ORD_PAGE_ISDN_NOOFFER                  12
#define ORD_PAGE_OEMOFFER                      13

// Definitions for command line parameters
#define OEMCODE_CMD                            TEXT("/oem")
#define PRODCODE_CMD                           TEXT("/prod")
#define PROMO_CMD                              TEXT("/promo")
#define SHELLNEXT_CMD                          TEXT("/shellnext")
#define SMARTSTART_CMD                         TEXT("/smartstart")
#define STARTURL_CMD                           TEXT("/starturl")
#define UPDATEDESKTOP_CMD                      TEXT("/desktop")
#define RESTOREDESKTOP_CMD                     TEXT("/restoredesktop")
#define ICW_IEAK_CMD                           TEXT("/ieak")
#define BRANDED_CMD                            TEXT("/branded")          // Allow branding
#define RUNONCE_CMD                            TEXT("/runonce")          // Run once only
#define SMARTREBOOT_CMD                        TEXT("/smartreboot")
#define SHORTCUTENTRY_CMD                      TEXT("/icon")             //changed from /shortcut per simons
#define SKIPINTRO_CMD                          TEXT("/skipintro")        // simulate "next" click right away on intro page
#ifdef DEBUG
#define ICON_CMD                               TEXT("/puticon")           // Debug only
#endif
#define DEBUG_OEMCUSTOM                        TEXT("/checkoemcustini")

#define PRODCODE_SBS                           TEXT("sbs")               // for /prod sbs
#define NEWISP_SR                              TEXT("new")               // for /smartreboot new
#define AUTO_SR                                TEXT("auto")              // for /smartreboot auto
#define MANUAL_SR                              TEXT("manual")            // for /smartreboot manual
#define LAN_SR                                 TEXT("lan")               // for /smartreboot LAN
// Default strings for oem, prod, and promo code
#define DEFAULT_OEMCODE                        TEXT("Default")
#define DEFAULT_PRODUCTCODE                    TEXT("Desktop")
#define DEFAULT_PROMOCODE                      TEXT("Default")

#define WM_RUNICWTUTORAPP                      ((WM_USER) + 300)

// This takes into account the inital dial for a total of three
#define NUM_MAX_REDIAL 2 

// handler proc for OK, cancel, etc button handlers
typedef BOOL (CALLBACK* INITPROC)(HWND,BOOL, UINT *);
typedef BOOL (CALLBACK* POSTINITPROC)(HWND,BOOL, UINT *);
typedef BOOL (CALLBACK* OKPROC)(HWND,BOOL,UINT *,BOOL *);
typedef BOOL (CALLBACK* CANCELPROC)(HWND);
typedef BOOL (CALLBACK* CMDPROC)(HWND,WPARAM,LPARAM);
typedef BOOL (CALLBACK* NOTIFYPROC)(HWND, WPARAM, LPARAM);

#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)

// structure with information for each wizard page
typedef struct tagPAGEINFO
{
  UINT          uDlgID;            // dialog ID to use for page
  BOOL          bIsHostingWebOC;
  
  // handler procedures for each page-- any of these can be
  // NULL in which case the default behavior is used
  INITPROC      InitProc;
  POSTINITPROC  PostInitProc;
  OKPROC        OKProc;
  CMDPROC       CmdProc;
  CANCELPROC    CancelProc;
  NOTIFYPROC    NotifyProc;
    
  int           nIdTitle;
  int           nIdSubTitle;
  
  int           idAccel;        // ID of the accelerator table
  HACCEL        hAccel;         // Accelerator table
  HACCEL        hAccelNested;   // Accelerator table for nested dialog
} PAGEINFO;

// These are contol defines for controls that have accelerator access. 
// They must be defined here, instead of in the DLL, so that the app 
// can access the defines

#define IDC_ISPLIST                     3000
#define IDC_ISPMARKETING                3001
#define IDC_ISPLIST_INFO                3002
#define IDC_USERINFO_FIRSTNAME          3008
#define IDC_USERINFO_LASTNAME           3009
#define IDC_USERINFO_COMPANYNAME        3068
#define IDC_USERINFO_ADDRESS1           3010
#define IDC_USERINFO_ADDRESS2           3011
#define IDC_USERINFO_CITY               3012
#define IDC_USERINFO_STATE              3013
#define IDC_USERINFO_ZIP                3014
#define IDC_USERINFO_PHONE              3015
#define IDC_USERINFO_FE_NAME            3007
#define IDC_BILLINGOPT_HTML             3017
#define IDC_PAYMENTTYPE                 3018
#define IDC_PAYMENT_CCNUMBER            3019
#define IDC_PAYMENT_EXPIREMONTH         3020
#define IDC_PAYMENT_EXPIREYEAR          3021
#define IDC_PAYMENT_CCNAME              3022
#define IDC_PAYMENT_CCADDRESS           3023
#define IDC_PAYMENT_CCZIP               3024
#define IDC_PAYMENT_IVADDRESS1          3040
#define IDC_PAYMENT_IVADDRESS2          3042
#define IDC_PAYMENT_IVCITY              3044
#define IDC_PAYMENT_IVSTATE             3046
#define IDC_PAYMENT_IVZIP               3048
#define IDC_PAYMENT_PHONEIV_BILLNAME    3050
#define IDC_PAYMENT_PHONEIV_ACCNUM      3052
#define IDC_ISPDATA_TOSACCEPT           3037
#define IDC_ISPDATA_TOSDECLINE          3038
#define IDC_ISPDATA_TOSSAVE             3065
#define IDC_DIALERR_PHONENUMBER         3062
#define IDC_DIALERR_PROPERTIES          3088
#define IDC_DIAL_HELP                   3071
#define IDC_OEMOFFER_MORE               3202
                                        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)   StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)   StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)    StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)    StrCmpNW(sz1, sz2, cch)

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// BUGBUG (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.

// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;


#endif // RC_INVOKED

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\cfgapi.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CFGAPI.H
//
//  PURPOSE:  Contains API's exported from icfg32.dll and structures
//            required by those functions. 
//
//*******************************************************************

#ifndef _CFGAPI_H_
#define _CFGAPI_H_

// Maximum buffer size for error messages.
#define MAX_ERROR_TEXT  512

// Flags for dwfOptions

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004

//
// ChrisK 5/8/97
// Note: the next three switches are only valid for IcfgNeedInetComponet
// check to see if a LAN adapter with TCP bound is installed
//
#define ICFG_INSTALLLAN            0x00000008

//
// Check to see if a DIALUP adapter with TCP bound is installed
//
#define ICFG_INSTALLDIALUP         0x00000010

//
// Check to see if TCP is installed
//
#define ICFG_INSTALLTCPONLY        0x00000020

// DRIVERTYPE_ defines for TCP/IP configuration apis
#define DRIVERTYPE_NET  0x0001
#define DRIVERTYPE_PPP  0x0002


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents);


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//              
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

DWORD WINAPI IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc);


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgSetInstallSourcePath(LPCSTR lpszSourcePath);


//*******************************************************************
//              
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS);


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgRemoveGlobalDNS(void);


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn);


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for 
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent);



VOID   GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
RETERR DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_CFGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\helpids.h ===
/* Help ID mapping for Internet Connection Wizard Help topics */
/* Help file = connect.hlp */
/* Last saved 4/28/97 a-cynthw */

#define ICW_OVERVIEW            1000
#define icw_trb                 1001
#define ICW_TRB                 1001
#define ICW_SETUP_OPTIONS       1010
#define ICW_USE_EXISTING        1020
#define ICW_SETUP_AUTOMATIC     1030
#define ICW_LOCATION_INFO       1040
#define ICW_CHOOSE_NUMBER       1045
#define ICW_CONNECTING          1050
#define ICW_SETUP_MANUAL        1070
#define ICW_DIALUP_CONNECTION   1080
#define ICW_DIALUP_NAME         1090
#define ICW_PHONE_NUMBER        2000
#define ICW_NAME_PASSWORD       2010
#define ICW_ADVANCED            2020
#define ICW_CONNECTION_TYPE     2030
#define ICW_LOGON_PROCEDURE     2040
#define ICW_IP_ADDRESS          2050
#define ICW_DNS_ADDRESS         2060
#define ICW_LCP_EXTENSIONS      2070
#define ICW_DIALUP_SETTINGS     2080
#define ICW_USE_PROXY           2090
#define ICW_PROXY_SERVERS       3000
#define ICW_PROXY_EXCEPTIONS    3010
#define ICW_CHOOSE_MODEM        3020
#define ICW_COMPLETE            3030
#define ICW_SETUP_PROXY         3040
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwacct.h ===
#ifndef _INC_ICWACCT_H
#define _INC_ICWACCT_H

#include "icwcmn.h"

#ifndef MAC

#ifndef APPRENTICE_DEF
#define APPRENTICE_DEF
#define EXTERNAL_DIALOGID_MINIMUM   2000
#define EXTERNAL_DIALOGID_MAXIMUM   3000
typedef enum
    {
    CANCEL_PROMPT = 0,
    CANCEL_SILENT,
    CANCEL_REBOOT
    } CANCELTYPE;
#endif

// {796AD8F0-B2B7-11d0-8D69-00A0C9A06E1F}
DEFINE_GUID(IID_IICWExtension, 0x796ad8f0, 0xb2b7, 0x11d0, 0x8d, 0x69, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

interface IICWExtension : public IUnknown
    {
    public:
        virtual BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type) = 0;
        virtual BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID) = 0;
    };

typedef enum
    {
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
    };

typedef struct tagCONNECTINFO
    {
    DWORD   cbSize;
    DWORD   type;
    char   szConnectoid[MAX_PATH];
    } CONNECTINFO;

// IICWApprentice::Save error values
#define ERR_MAIL_ACCT       0x0001
#define ERR_NEWS_ACCT       0x0002
#define ERR_DIRSERV_ACCT    0x0004

// IICWApprentice::AddWizardPages flags
#define WIZ_NO_MAIL_ACCT    0x0001
#define WIZ_NO_NEWS_ACCT    0x0002
#define WIZ_NO_LDAP_ACCT    0x0004
#define WIZ_USE_WIZARD97    0x0008
#define WIZ_HOST_ICW_LAN    0x0010
#define WIZ_HOST_ICW_PHONE  0x0020
#define WIZ_HOST_ICW_MPHONE 0x0040 // Show multi modem page id necessary

// {1438E820-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(IID_IICWApprentice, 0x1438E820L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IICWApprentice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
    };

// {ced77e0e-53d7-11d2-9ab6-00a0c9b81d84}
DEFINE_GUID(IID_IICWApprenticeEx, 0xced77e0e, 0x53d7, 0x11d2, 0x9A, 0xB6, 0x00, 0xA0, 0xC9, 0xB8, 0x1D, 0x84);

interface IICWApprenticeEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize               (IICWExtension *pExt)                      = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages           (DWORD dwFlags)                            = 0;
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation (CONNECTINFO *pInfo)                       = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDlgHwnd               (HWND hDlg)                                = 0;
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation (CONNECTINFO *pInfo)                       = 0;
        virtual HRESULT STDMETHODCALLTYPE Save                     (HWND hwnd, DWORD *pdwError)               = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage          (UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags       (DWORD dwFlags)                            = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll (LPCMNSTATEDATA lpData)                    = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe (LPCMNSTATEDATA lpData)                    = 0;
    };


// Athena's CLSID
// {1438E821-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(CLSID_ApprenticeAcctMgr, 0x1438E821L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

//ICW's CLSID
// {8EE42293-C315-11d0-8D6F-00A0C9A06E1F}
DEFINE_GUID(CLSID_ApprenticeICW, 0x8ee42293L, 0xc315, 0x11d0, 0x8d, 0x6f, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

HRESULT WINAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags);
HRESULT WINAPI CreateAccountsFromFileEx(LPSTR lpFile, CONNECTINFO *pci, DWORD dwFlags);

#endif  // !MAC
#endif // _INC_ICWACCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwcmn.h ===
#ifndef _INC_ICWCMN_H
#define _INC_ICWCMN_H

#include "icwhelp.h"

// Data types and things that are common to both ICWCONN1.EXE and ICWCONN.DLL
#define MAX_AREA_CODE       10
#define MAX_COLOR_NAME      100

#define WUM_SETTITLE        (WM_USER + 100)

typedef struct ISPINFO_tag
{
    TCHAR   szISPName       [MAX_PATH*2];
    TCHAR   szSupportNumber [MAX_PATH+1];
    TCHAR   szISPFile       [MAX_PATH+1];
    TCHAR   szBillHtm       [MAX_PATH*2];
    TCHAR   szPayCsv        [MAX_PATH*2];
    TCHAR   szStartURL      [MAX_PATH+1];
    TCHAR   szIspURL        [MAX_PATH+1];
    DWORD   dwValidationFlags;
    BOOL    bFailedIns;
}ISPINFO;

typedef BOOL (WINAPI *PFConfigSys)(HWND hDlg);
typedef void (*PFCompleteOLS)();
typedef void (WINAPI *PFFillWindowWithAppBackground)(HWND hWnd, HDC hdc);

typedef struct CMNSTATEDATA_tag
{
    IICWSystemConfig                *pICWSystemConfig;
    ISPINFO                         ispInfo;
    PFConfigSys                     lpfnConfigSys;
    PFCompleteOLS                   lpfnCompleteOLS;
    DWORD                           dwFlags;
    DWORD                           dwCountryCode;
    TCHAR                           szAreaCode[MAX_AREA_CODE];
    BOOL                            bSystemChecked;
    BOOL                            bPhoneManualWiz;
    BOOL                            bParseIspinfo;
    BOOL                            bOEMOffline;
    BOOL                            bOEMEntryPt;
    BOOL                            bIsISDNDevice;
    HBITMAP                         hbmWatermark;
    TCHAR                           szWizTitle[MAX_PATH*2];
    
    BOOL                            bOEMCustom;        
    HWND                            hWndApp;
    HWND                            hWndWizardPages;
    HBITMAP                         hbmBkgrnd;
    TCHAR                           szHTMLBackgroundColor[MAX_COLOR_NAME];
    TCHAR                           szclrHTMLText[MAX_COLOR_NAME];
    TCHAR                           szBusyAnimationFile[MAX_PATH];
    int                             xPosBusy;
    COLORREF                        clrText;
    PFFillWindowWithAppBackground   lpfnFillWindowWithAppBackground;
    BOOL                            bHideProgressAnime;
} CMNSTATEDATA, FAR *LPCMNSTATEDATA;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#undef CDECL
#define CDECL   _cdecl

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL

// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_dwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern DWORD g_dwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ONVALIDATE       0x00000001      // Break on assertions or validation
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING

// Trace flags for g_dwTraceFlags
#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
// (Upper 28 bits reserved for custom use per-module)

// Old, archaic debug flags.  
// BUGBUG (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg;


#ifndef NOSHELLDEBUG    // Others have own versions of these.
#ifdef DEBUG

#ifdef WIN16
#define DEBUG_BREAK         { _asm int 3 }
#else
#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        { _asm int 3 }
#else
#define DEBUG_BREAK        DebugBreak();
#endif
#endif
// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

BOOL CDECL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreak);
BOOL CDECL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreak);

void CDECL CcshellDebugMsgW(DWORD mask, LPCWSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(DWORD mask, LPCSTR  pszMsg, ...);
void CDECL CcshellFuncMsgW(DWORD mask, LPCWSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(DWORD mask, LPCSTR  pszMsg, ...);
void CDECL CcshellAssertMsgW(BOOL bAssert, LPCWSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR  pszMsg, ...);

void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);
void CDECL _DebugMsgA(DWORD flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(DWORD flag, LPCWSTR psz, ...);

void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);


#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#define CcshellDebugMsg         CcshellDebugMsgW
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#define CcshellDebugMsg         CcshellDebugMsgA
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#define _DebugMsg               _DebugMsgA
#endif



// Explanation of debug macros:
//
// ----
// Assert(f)
// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//   The g_dwBreakFlags global governs whether the function DebugBreaks.
//
// ----
// AssertE(f)
//
//   Works like Assert, except (f) is also executed in the retail 
//   version as well.
//
// ----
// EVAL(f)
//
//   Evaluates the expression (f).  The expression is always evaluated,
//   even in retail builds.  But the macro only asserts in the debug
//   build.  This macro may only be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
// ----
// TraceMsg(mask, sz, args...) 
//
//   Generate wsprintf-formatted msg using specified trace mask.  
//   The g_dwTraceFlags global governs whether message is displayed.
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
// ----
// DebugMsg(mask, sz, args...) 
//
//   OBSOLETE!  
//   Like TraceMsg, except you must wrap the sz parameter with TEXT().
//
// ----
// AssertMsg(bAssert, sz, args...)
//
//   Generate wsprintf-formatted msg if the assertion is false.  
//   The g_dwBreakFlags global governs whether the function DebugBreaks.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//


#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif


#define AssertE(f)          ASSERT(f)
#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg
#endif

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#ifndef WIN16
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#else
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : TEXT("NULL string"))
#endif
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

#define FUNC_MSG            CcshellFuncMsg

// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Assert(f)
#define AssertE(f)      (f)
#define ASSERT(f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define DebugMsg        1 ? (void)0 : (void)
#define FullDebugMsg    1 ? (void)0 : (void)
#define EVAL(exp)       ((exp) != 0)


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#ifdef UNICODE
#define TraceMsg        TraceMsgW
#else
#define TraceMsg        TraceMsgA
#endif

#define FUNC_MSG        1 ? (void)0 : (void)

#define ASSERT_MSGA     TraceMsgA
#define ASSERT_MSGW     TraceMsgW
#define ASSERT_MSG      TraceMsg

#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG
#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG


// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);   // start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwconn.h ===
#ifndef _INC_ICWCONN_H
#define _INC_ICWCONN_H


#ifndef APPRENTICE_DEF
#define APPRENTICE_DEF
#define EXTERNAL_DIALOGID_MINIMUM   2000
#define EXTERNAL_DIALOGID_MAXIMUM   3000
typedef enum
{
    CANCEL_PROMPT = 0,
    CANCEL_SILENT,
    CANCEL_REBOOT
} CANCELTYPE;
#endif

// {7D857593-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(IID_IICW50Extension, 0x7d857593, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

interface IICW50Extension : public IUnknown
{
    public:
        virtual BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
        virtual BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type) = 0;
        virtual BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID) = 0;
        virtual HWND STDMETHODCALLTYPE GetWizardHwnd(void) = 0;
};

// IICW50Apprentice::Save error values

// IICW50Apprentice::AddWizardPages flags

// {7D857594-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(IID_IICW50Apprentice, 0x7d857594, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

interface IICW50Apprentice : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICW50Extension *pExt) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll(LPCMNSTATEDATA lpData) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe(LPCMNSTATEDATA lpData) = 0;
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags(DWORD dwFlags) = 0;
};

// ICWCONN's Apprentice CLSID
// This is used to import wizard pages from an external entity.
// {7D857595-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(CLSID_ApprenticeICWCONN, 0x7d857595, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

//ICWCONN1's Apprentice CLSID
// This is used to share ICWCONN1's wizard pages with an external entity.
// {7D857596-EAAE-11D1-AE03-0000F87734F0}
DEFINE_GUID(CLSID_ApprenticeICWCONN1, 0x7d857596, 0xeaae, 0x11d1, 0xae, 0x3, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

#endif // _INC_ICWCONN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwcfg.h ===
/********************************************************************

  ICWCFG.H

  Copyright(c) Microsoft Corporation, 1996 - 97

  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
  *
  * This header file is not intended for distribution outside Microsoft.
  *
  ***********************************************************

  Header file for Internet Connection Wizard external configuration
  routines found in INETCFG.DLL.

  Routines:

  CheckConnectionWizard - Checks which parts of ICW are installed
        and if it has been run before.  It optionally will start
        either the full or manual path of ICW if it is insalled
        but has not been run before.

  History:  10/22/96    Created
        10/24/96    Added defines and typedefs
        2/25/97     Added CreateDirectoryService -- jmazner
        4/24/97     Removed InetCreate*, these are now owned
                    by the Account Manager -- jmazner

  Support:  This header file (and INETCFG.DLL) is supported by the
            Internet Connection Wizard team (alias icwcore).  Please
            do not modify this directly.

*********************************************************************/

#ifndef _ICWCFG_H_

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS TEXT("Software\\Microsoft\\Internet Connection Wizard")
#define ICW_REGKEYCOMPLETED TEXT("Completed")
#define ICW_REGKEYERROR     TEXT("ICWError")

// Maximum field lengths
#define ICW_MAX_ACCTNAME    256
#define ICW_MAX_PASSWORD    256 // PWLEN
#define ICW_MAX_LOGONNAME   256 // UNLEN
#define ICW_MAX_SERVERNAME  64
#define ICW_MAX_RASNAME     256 // RAS_MaxEntryName
#define ICW_MAX_EMAILNAME   64
#define ICW_MAX_EMAILADDR   128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS     0x0001

#define ICW_LAUNCHFULL      0x0100
#define ICW_LAUNCHMANUAL    0x0200
#define ICW_USE_SHELLNEXT   0x0400
#define ICW_FULL_SMARTSTART 0x0800

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT     0x0001
#define ICW_MANUALPRESENT   0x0002
#define ICW_ALREADYRUN      0x0004

#define ICW_LAUNCHEDFULL    0x0100
#define ICW_LAUNCHEDMANUAL  0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS     0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//
// external function typedefs
//
typedef DWORD   (WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef DWORD   (WINAPI *PFNSETSHELLNEXT) (CHAR *);

//
// external function declarations
//
DWORD   WINAPI CheckConnectionWizard(DWORD, LPDWORD);
DWORD   WINAPI SetShellNextA(CHAR *);
DWORD   WINAPI SetShellNextW(WCHAR *);

#ifdef UNICODE
#define SetShellNext  SetShellNextW
#else
#define SetShellNext  SetShellNextA
#endif


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _ICWCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwdial.h ===
// ############################################################################
#ifndef WIN16
#include <ras.h>
#endif

#ifndef _ICWDIAL
#define _ICWDIAL
// ############################################################################
typedef HRESULT(WINAPI *PFNSTATUSCALLBACK)(DWORD dwStatus, LPTSTR pszBuffer, DWORD dwBufferSize);

typedef struct tagDIALDLGDATA
{
    DWORD dwSize;
    LPTSTR pszMessage;
    LPTSTR pszRasEntryName;
    LPTSTR pszMultipartMIMEUrl;
    HRASCONN *phRasConn;
    PFNSTATUSCALLBACK pfnStatusCallback;
    HINSTANCE hInst;
    HWND hParentHwnd;
    LPTSTR pszDunFile;
    BOOL bSkipDial;
    RASDIALFUNC1 pfnRasDialFunc1;
}DIALDLGDATA,*PDIALDLGDATA, FAR* LPDIALDLGDATA;

typedef struct tagERRORDLGDATA
{
    DWORD dwSize;
    LPTSTR pszMessage;
    LPTSTR pszRasEntryName;
    LPDWORD pdwCountryID;
    LPWORD pwStateID;
    BYTE bType;
    BYTE bMask;
    LPTSTR pszHelpFile;
    DWORD dwHelpID;
    HINSTANCE hInst;
    HWND hParentHwnd;
    DWORD dwPhonebook;
    LPTSTR pszDunFile;
} ERRORDLGDATA, *PERRORDLGDATA, FAR* LPERRORDLGDATA;

#define WM_RegisterHWND (WM_USER + 1000)
// ############################################################################ 
#ifdef WIN16
extern "C" HRESULT WINAPI __export ICWGetRasEntry(LPRASENTRY *ppRasEntry, LPDWORD lpdwRasEntrySize, LPRASDEVINFO *ppDevInfo, LPDWORD lpdwDevInfoSize, LPTSTR pszEntryName);
extern "C" HRESULT WINAPI __export DialingDownloadDialog(PDIALDLGDATA pDD);
extern "C" HRESULT WINAPI __export DialingErrorDialog(PERRORDLGDATA pED);
#else
extern "C"  HRESULT WINAPI ICWGetRasEntry(LPRASENTRY *ppRasEntry, LPDWORD lpdwRasEntrySize, LPRASDEVINFO *ppDevInfo, LPDWORD lpdwDevInfoSize, LPTSTR pszEntryName);
extern "C"  HRESULT WINAPI DialingDownloadDialog(PDIALDLGDATA pDD);
extern "C"  HRESULT WINAPI DialingErrorDialog(PERRORDLGDATA pED);
#endif

typedef HRESULT (WINAPI *PFNICWGetRasEntry)(LPRASENTRY, LPDWORD, LPRASDEVINFO, LPDWORD, LPTSTR);
typedef HRESULT (WINAPI *PFNDDDlg)(PDIALDLGDATA);
typedef HRESULT (WINAPI *PFNDEDlg)(PERRORDLGDATA);
#endif // _ICWDIAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwerr.h ===
#define IDS_PPPRANDOMFAILURE 6999
#define IDS_RASNOCARRIER     6998
#define IDS_PHONEBUSY        6997
#define IDS_NODIALTONE       6996
#define IDS_NODEVICE         6995
#define IDS_USERCANCELEDDIAL 6994
#define IDS_MEDIAINIERROR    6993
#define IDS_NOANSWER         6992
#define IDS_TCPINSTALLERROR  6991

#define IDS_RAS_DIALING      6990
#define IDS_RAS_PORTOPENED   6989
#define IDS_RAS_OPENPORT      6988
#define IDS_RAS_CONNECTED     6987
#define IDS_RAS_LOCATING      6986

#if !defined(ERROR_USERCANCEL)
#define ERROR_USERCANCEL 32767
#endif

#if !defined(ERROR_USERBACK)
#define ERROR_USERBACK 32766
#endif

#if !defined(ERROR_USERNEXT)
#define ERROR_USERNEXT 32765
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwdl.h ===
// ############################################################################
#ifndef _ICWDL_H
#define _ICWDL_H

// These are the types of info that are passed back through the callback
#define CALLBACK_TYPE_URL       100
#define CALLBACK_TYPE_PROGRESS  99

// ############################################################################
#define DOWNLOAD_LIBRARY     TEXT("icwdl.dll")
#define DOWNLOADINIT         "DownLoadInit"
#define DOWNLOADEXECUTE      "DownLoadExecute"
#define DOWNLOADCLOSE        "DownLoadClose"
#define DOWNLOADSETSTATUS    "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS      "DownLoadProcess"
#define DOWNLOADCANCEL       "DownLoadCancel"

// ############################################################################
typedef HRESULT (CALLBACK *PFNDOWNLOADINIT)(LPTSTR pszURL, DWORD_PTR FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hwndParent);
typedef HRESULT (CALLBACK *PFNDOWNLOADCANCEL)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADEXECUTE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADCLOSE)(DWORD_PTR dwDownLoad);

// jmazner  10/2/96  Normandy #8493
// WRONG PROTOTYPE!! This should match icwdl/download.cpp:DownLoadSetStatusCallBack!!
//typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback, DWORD dwContext);
typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD_PTR dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback);

typedef HRESULT (CALLBACK *PFNDOWNLOADPROCESS)(DWORD_PTR dwDownLoad);

#endif // _ICWDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwhelp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0221 */
/* at Tue Dec 22 23:42:06 1998
 */
/* Compiler settings for icwhelp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icwhelp_h__
#define __icwhelp_h__

/* Forward Declarations */ 

#ifndef __IRefDial_FWD_DEFINED__
#define __IRefDial_FWD_DEFINED__
typedef interface IRefDial IRefDial;
#endif 	/* __IRefDial_FWD_DEFINED__ */


#ifndef __IDialErr_FWD_DEFINED__
#define __IDialErr_FWD_DEFINED__
typedef interface IDialErr IDialErr;
#endif 	/* __IDialErr_FWD_DEFINED__ */


#ifndef __ISmartStart_FWD_DEFINED__
#define __ISmartStart_FWD_DEFINED__
typedef interface ISmartStart ISmartStart;
#endif 	/* __ISmartStart_FWD_DEFINED__ */


#ifndef __IICWSystemConfig_FWD_DEFINED__
#define __IICWSystemConfig_FWD_DEFINED__
typedef interface IICWSystemConfig IICWSystemConfig;
#endif 	/* __IICWSystemConfig_FWD_DEFINED__ */


#ifndef __ITapiLocationInfo_FWD_DEFINED__
#define __ITapiLocationInfo_FWD_DEFINED__
typedef interface ITapiLocationInfo ITapiLocationInfo;
#endif 	/* __ITapiLocationInfo_FWD_DEFINED__ */


#ifndef __IUserInfo_FWD_DEFINED__
#define __IUserInfo_FWD_DEFINED__
typedef interface IUserInfo IUserInfo;
#endif 	/* __IUserInfo_FWD_DEFINED__ */


#ifndef __IWebGate_FWD_DEFINED__
#define __IWebGate_FWD_DEFINED__
typedef interface IWebGate IWebGate;
#endif 	/* __IWebGate_FWD_DEFINED__ */


#ifndef __IINSHandler_FWD_DEFINED__
#define __IINSHandler_FWD_DEFINED__
typedef interface IINSHandler IINSHandler;
#endif 	/* __IINSHandler_FWD_DEFINED__ */


#ifndef ___RefDialEvents_FWD_DEFINED__
#define ___RefDialEvents_FWD_DEFINED__
typedef interface _RefDialEvents _RefDialEvents;
#endif 	/* ___RefDialEvents_FWD_DEFINED__ */


#ifndef __RefDial_FWD_DEFINED__
#define __RefDial_FWD_DEFINED__

#ifdef __cplusplus
typedef class RefDial RefDial;
#else
typedef struct RefDial RefDial;
#endif /* __cplusplus */

#endif 	/* __RefDial_FWD_DEFINED__ */


#ifndef __DialErr_FWD_DEFINED__
#define __DialErr_FWD_DEFINED__

#ifdef __cplusplus
typedef class DialErr DialErr;
#else
typedef struct DialErr DialErr;
#endif /* __cplusplus */

#endif 	/* __DialErr_FWD_DEFINED__ */


#ifndef __SmartStart_FWD_DEFINED__
#define __SmartStart_FWD_DEFINED__

#ifdef __cplusplus
typedef class SmartStart SmartStart;
#else
typedef struct SmartStart SmartStart;
#endif /* __cplusplus */

#endif 	/* __SmartStart_FWD_DEFINED__ */


#ifndef __ICWSystemConfig_FWD_DEFINED__
#define __ICWSystemConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class ICWSystemConfig ICWSystemConfig;
#else
typedef struct ICWSystemConfig ICWSystemConfig;
#endif /* __cplusplus */

#endif 	/* __ICWSystemConfig_FWD_DEFINED__ */


#ifndef __TapiLocationInfo_FWD_DEFINED__
#define __TapiLocationInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class TapiLocationInfo TapiLocationInfo;
#else
typedef struct TapiLocationInfo TapiLocationInfo;
#endif /* __cplusplus */

#endif 	/* __TapiLocationInfo_FWD_DEFINED__ */


#ifndef __UserInfo_FWD_DEFINED__
#define __UserInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class UserInfo UserInfo;
#else
typedef struct UserInfo UserInfo;
#endif /* __cplusplus */

#endif 	/* __UserInfo_FWD_DEFINED__ */


#ifndef ___WebGateEvents_FWD_DEFINED__
#define ___WebGateEvents_FWD_DEFINED__
typedef interface _WebGateEvents _WebGateEvents;
#endif 	/* ___WebGateEvents_FWD_DEFINED__ */


#ifndef __WebGate_FWD_DEFINED__
#define __WebGate_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebGate WebGate;
#else
typedef struct WebGate WebGate;
#endif /* __cplusplus */

#endif 	/* __WebGate_FWD_DEFINED__ */


#ifndef ___INSHandlerEvents_FWD_DEFINED__
#define ___INSHandlerEvents_FWD_DEFINED__
typedef interface _INSHandlerEvents _INSHandlerEvents;
#endif 	/* ___INSHandlerEvents_FWD_DEFINED__ */


#ifndef __INSHandler_FWD_DEFINED__
#define __INSHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class INSHandler INSHandler;
#else
typedef struct INSHandler INSHandler;
#endif /* __cplusplus */

#endif 	/* __INSHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_icwhelp_0000 */
/* [local] */ 

#pragma once



extern RPC_IF_HANDLE __MIDL_itf_icwhelp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_icwhelp_0000_v0_0_s_ifspec;

#ifndef __IRefDial_INTERFACE_DEFINED__
#define __IRefDial_INTERFACE_DEFINED__

/* interface IRefDial */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRefDial;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E794A09-86F4-11D1-ADD8-0000F87734F0")
    IRefDial : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoConnect( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DownloadStatusString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetupForDialing( 
            BSTR bstrISPFILE,
            DWORD dwCountry,
            BSTR bstrAreaCode,
            DWORD dwFlag,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QuitWizard( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserPickNumber( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialPhoneNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DialPhoneNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PromoCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PromoCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProductCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProductCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoOfferDownload( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialStatusString( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoHangup( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProcessSignedPID( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignedPID( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FormReferralServerURL( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignupURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TryAgain( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialErrorMsg( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModemEnum_Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ModemEnum_Next( 
            /* [retval][out] */ BSTR __RPC_FAR *pDeviceName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModemEnum_NumDevices( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowDialingProperties( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ShowPhoneBook( 
            /* [in] */ DWORD dwCountryCode,
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValidatePhoneNumber( 
            /* [in] */ BSTR bstrPhoneNumber,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HavePhoneBook( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BrandingFlags( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BrandingFlags( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentModem( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CurrentModem( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISPSupportPhoneNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ISPSupportPhoneNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingStartUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingEndUrl( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectedPhoneNumber( 
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PhoneNumberEnum_Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PhoneNumberEnum_Next( 
            /* [retval][out] */ BSTR __RPC_FAR *pNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneNumberEnum_NumDevices( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialError( 
            /* [retval][out] */ HRESULT __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Redial( 
            /* [in] */ BOOL newbVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoConfigURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoInit( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_OemCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AllOfferCode( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISDNURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISDNAutoConfigURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_bIsISDNDevice( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ModemOverride( 
            /* [in] */ BOOL newbVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveConnectoid( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISPSupportNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RasGetConnectStatus( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRefDialVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRefDial __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRefDial __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRefDial __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoConnect )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DownloadStatusString )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetupForDialing )( 
            IRefDial __RPC_FAR * This,
            BSTR bstrISPFILE,
            DWORD dwCountry,
            BSTR bstrAreaCode,
            DWORD dwFlag,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QuitWizard )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UserPickNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DialPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PromoCode )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PromoCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ProductCode )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ProductCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoOfferDownload )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialStatusString )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoHangup )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessSignedPID )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignedPID )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FormReferralServerURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SignupURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TryAgain )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialErrorMsg )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModemEnum_Reset )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ModemEnum_Next )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pDeviceName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModemEnum_NumDevices )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SupportNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowDialingProperties )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowPhoneBook )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ DWORD dwCountryCode,
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidatePhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR bstrPhoneNumber,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HavePhoneBook )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BrandingFlags )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BrandingFlags )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentModem )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CurrentModem )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISPSupportPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ISPSupportPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LoggingStartUrl )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LoggingEndUrl )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SelectedPhoneNumber )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PhoneNumberEnum_Reset )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PhoneNumberEnum_Next )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PhoneNumberEnum_NumDevices )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialError )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ HRESULT __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Redial )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BOOL newbVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoConfigURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoInit )( 
            IRefDial __RPC_FAR * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OemCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllOfferCode )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISDNURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISDNAutoConfigURL )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bIsISDNDevice )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ModemOverride )( 
            IRefDial __RPC_FAR * This,
            /* [in] */ BOOL newbVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveConnectoid )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ISPSupportNumber )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RasGetConnectStatus )( 
            IRefDial __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        END_INTERFACE
    } IRefDialVtbl;

    interface IRefDial
    {
        CONST_VTBL struct IRefDialVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRefDial_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRefDial_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRefDial_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRefDial_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRefDial_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRefDial_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRefDial_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRefDial_DoConnect(This,pbRetVal)	\
    (This)->lpVtbl -> DoConnect(This,pbRetVal)

#define IRefDial_get_DownloadStatusString(This,pVal)	\
    (This)->lpVtbl -> get_DownloadStatusString(This,pVal)

#define IRefDial_SetupForDialing(This,bstrISPFILE,dwCountry,bstrAreaCode,dwFlag,pbRetVal)	\
    (This)->lpVtbl -> SetupForDialing(This,bstrISPFILE,dwCountry,bstrAreaCode,dwFlag,pbRetVal)

#define IRefDial_get_QuitWizard(This,pVal)	\
    (This)->lpVtbl -> get_QuitWizard(This,pVal)

#define IRefDial_get_UserPickNumber(This,pVal)	\
    (This)->lpVtbl -> get_UserPickNumber(This,pVal)

#define IRefDial_get_DialPhoneNumber(This,pVal)	\
    (This)->lpVtbl -> get_DialPhoneNumber(This,pVal)

#define IRefDial_put_DialPhoneNumber(This,newVal)	\
    (This)->lpVtbl -> put_DialPhoneNumber(This,newVal)

#define IRefDial_get_URL(This,pVal)	\
    (This)->lpVtbl -> get_URL(This,pVal)

#define IRefDial_get_PromoCode(This,pVal)	\
    (This)->lpVtbl -> get_PromoCode(This,pVal)

#define IRefDial_put_PromoCode(This,newVal)	\
    (This)->lpVtbl -> put_PromoCode(This,newVal)

#define IRefDial_get_ProductCode(This,pVal)	\
    (This)->lpVtbl -> get_ProductCode(This,pVal)

#define IRefDial_put_ProductCode(This,newVal)	\
    (This)->lpVtbl -> put_ProductCode(This,newVal)

#define IRefDial_DoOfferDownload(This,pbRetVal)	\
    (This)->lpVtbl -> DoOfferDownload(This,pbRetVal)

#define IRefDial_get_DialStatusString(This,pVal)	\
    (This)->lpVtbl -> get_DialStatusString(This,pVal)

#define IRefDial_DoHangup(This)	\
    (This)->lpVtbl -> DoHangup(This)

#define IRefDial_ProcessSignedPID(This,pbRetVal)	\
    (This)->lpVtbl -> ProcessSignedPID(This,pbRetVal)

#define IRefDial_get_SignedPID(This,pVal)	\
    (This)->lpVtbl -> get_SignedPID(This,pVal)

#define IRefDial_FormReferralServerURL(This,pbRetVal)	\
    (This)->lpVtbl -> FormReferralServerURL(This,pbRetVal)

#define IRefDial_get_SignupURL(This,pVal)	\
    (This)->lpVtbl -> get_SignupURL(This,pVal)

#define IRefDial_get_TryAgain(This,pVal)	\
    (This)->lpVtbl -> get_TryAgain(This,pVal)

#define IRefDial_get_DialErrorMsg(This,pVal)	\
    (This)->lpVtbl -> get_DialErrorMsg(This,pVal)

#define IRefDial_ModemEnum_Reset(This)	\
    (This)->lpVtbl -> ModemEnum_Reset(This)

#define IRefDial_ModemEnum_Next(This,pDeviceName)	\
    (This)->lpVtbl -> ModemEnum_Next(This,pDeviceName)

#define IRefDial_get_ModemEnum_NumDevices(This,pVal)	\
    (This)->lpVtbl -> get_ModemEnum_NumDevices(This,pVal)

#define IRefDial_get_SupportNumber(This,pVal)	\
    (This)->lpVtbl -> get_SupportNumber(This,pVal)

#define IRefDial_ShowDialingProperties(This,pbRetVal)	\
    (This)->lpVtbl -> ShowDialingProperties(This,pbRetVal)

#define IRefDial_ShowPhoneBook(This,dwCountryCode,newVal,pbRetVal)	\
    (This)->lpVtbl -> ShowPhoneBook(This,dwCountryCode,newVal,pbRetVal)

#define IRefDial_ValidatePhoneNumber(This,bstrPhoneNumber,pbRetVal)	\
    (This)->lpVtbl -> ValidatePhoneNumber(This,bstrPhoneNumber,pbRetVal)

#define IRefDial_get_HavePhoneBook(This,pVal)	\
    (This)->lpVtbl -> get_HavePhoneBook(This,pVal)

#define IRefDial_get_BrandingFlags(This,pVal)	\
    (This)->lpVtbl -> get_BrandingFlags(This,pVal)

#define IRefDial_put_BrandingFlags(This,newVal)	\
    (This)->lpVtbl -> put_BrandingFlags(This,newVal)

#define IRefDial_get_CurrentModem(This,pVal)	\
    (This)->lpVtbl -> get_CurrentModem(This,pVal)

#define IRefDial_put_CurrentModem(This,newVal)	\
    (This)->lpVtbl -> put_CurrentModem(This,newVal)

#define IRefDial_get_ISPSupportPhoneNumber(This,pVal)	\
    (This)->lpVtbl -> get_ISPSupportPhoneNumber(This,pVal)

#define IRefDial_put_ISPSupportPhoneNumber(This,newVal)	\
    (This)->lpVtbl -> put_ISPSupportPhoneNumber(This,newVal)

#define IRefDial_get_LoggingStartUrl(This,pVal)	\
    (This)->lpVtbl -> get_LoggingStartUrl(This,pVal)

#define IRefDial_get_LoggingEndUrl(This,pVal)	\
    (This)->lpVtbl -> get_LoggingEndUrl(This,pVal)

#define IRefDial_SelectedPhoneNumber(This,newVal,pbRetVal)	\
    (This)->lpVtbl -> SelectedPhoneNumber(This,newVal,pbRetVal)

#define IRefDial_PhoneNumberEnum_Reset(This)	\
    (This)->lpVtbl -> PhoneNumberEnum_Reset(This)

#define IRefDial_PhoneNumberEnum_Next(This,pNumber)	\
    (This)->lpVtbl -> PhoneNumberEnum_Next(This,pNumber)

#define IRefDial_get_PhoneNumberEnum_NumDevices(This,pVal)	\
    (This)->lpVtbl -> get_PhoneNumberEnum_NumDevices(This,pVal)

#define IRefDial_get_DialError(This,pVal)	\
    (This)->lpVtbl -> get_DialError(This,pVal)

#define IRefDial_put_Redial(This,newbVal)	\
    (This)->lpVtbl -> put_Redial(This,newbVal)

#define IRefDial_get_AutoConfigURL(This,pVal)	\
    (This)->lpVtbl -> get_AutoConfigURL(This,pVal)

#define IRefDial_DoInit(This)	\
    (This)->lpVtbl -> DoInit(This)

#define IRefDial_put_OemCode(This,newVal)	\
    (This)->lpVtbl -> put_OemCode(This,newVal)

#define IRefDial_put_AllOfferCode(This,newVal)	\
    (This)->lpVtbl -> put_AllOfferCode(This,newVal)

#define IRefDial_get_ISDNURL(This,pVal)	\
    (This)->lpVtbl -> get_ISDNURL(This,pVal)

#define IRefDial_get_ISDNAutoConfigURL(This,pVal)	\
    (This)->lpVtbl -> get_ISDNAutoConfigURL(This,pVal)

#define IRefDial_get_bIsISDNDevice(This,pVal)	\
    (This)->lpVtbl -> get_bIsISDNDevice(This,pVal)

#define IRefDial_put_ModemOverride(This,newbVal)	\
    (This)->lpVtbl -> put_ModemOverride(This,newbVal)

#define IRefDial_RemoveConnectoid(This,pbRetVal)	\
    (This)->lpVtbl -> RemoveConnectoid(This,pbRetVal)

#define IRefDial_get_ISPSupportNumber(This,pVal)	\
    (This)->lpVtbl -> get_ISPSupportNumber(This,pVal)

#define IRefDial_get_RasGetConnectStatus(This,pVal)	\
    (This)->lpVtbl -> get_RasGetConnectStatus(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoConnect_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_DoConnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DownloadStatusString_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DownloadStatusString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_SetupForDialing_Proxy( 
    IRefDial __RPC_FAR * This,
    BSTR bstrISPFILE,
    DWORD dwCountry,
    BSTR bstrAreaCode,
    DWORD dwFlag,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_SetupForDialing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_QuitWizard_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_QuitWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_UserPickNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_UserPickNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_DialPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_DialPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_URL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_PromoCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_PromoCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_PromoCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_PromoCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ProductCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ProductCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_ProductCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_ProductCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoOfferDownload_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_DoOfferDownload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialStatusString_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialStatusString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoHangup_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_DoHangup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ProcessSignedPID_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ProcessSignedPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_SignedPID_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_SignedPID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_FormReferralServerURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_FormReferralServerURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_SignupURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_SignupURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_TryAgain_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_TryAgain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialErrorMsg_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialErrorMsg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ModemEnum_Reset_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_ModemEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ModemEnum_Next_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pDeviceName);


void __RPC_STUB IRefDial_ModemEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ModemEnum_NumDevices_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ModemEnum_NumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_SupportNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_SupportNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ShowDialingProperties_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ShowDialingProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ShowPhoneBook_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ DWORD dwCountryCode,
    /* [in] */ long newVal,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ShowPhoneBook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_ValidatePhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR bstrPhoneNumber,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_ValidatePhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_HavePhoneBook_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_HavePhoneBook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_BrandingFlags_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_BrandingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_BrandingFlags_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRefDial_put_BrandingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_CurrentModem_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_CurrentModem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_CurrentModem_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRefDial_put_CurrentModem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISPSupportPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISPSupportPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_ISPSupportPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_ISPSupportPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_LoggingStartUrl_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_LoggingStartUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_LoggingEndUrl_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_LoggingEndUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_SelectedPhoneNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_SelectedPhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_PhoneNumberEnum_Reset_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_PhoneNumberEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_PhoneNumberEnum_Next_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pNumber);


void __RPC_STUB IRefDial_PhoneNumberEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_PhoneNumberEnum_NumDevices_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_PhoneNumberEnum_NumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_DialError_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ HRESULT __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_DialError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_Redial_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BOOL newbVal);


void __RPC_STUB IRefDial_put_Redial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_AutoConfigURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_AutoConfigURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_DoInit_Proxy( 
    IRefDial __RPC_FAR * This);


void __RPC_STUB IRefDial_DoInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_OemCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IRefDial_put_OemCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_AllOfferCode_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRefDial_put_AllOfferCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISDNURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISDNURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISDNAutoConfigURL_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISDNAutoConfigURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_bIsISDNDevice_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_bIsISDNDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IRefDial_put_ModemOverride_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [in] */ BOOL newbVal);


void __RPC_STUB IRefDial_put_ModemOverride_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IRefDial_RemoveConnectoid_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IRefDial_RemoveConnectoid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_ISPSupportNumber_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_ISPSupportNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IRefDial_get_RasGetConnectStatus_Proxy( 
    IRefDial __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IRefDial_get_RasGetConnectStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRefDial_INTERFACE_DEFINED__ */


#ifndef __IDialErr_INTERFACE_DEFINED__
#define __IDialErr_INTERFACE_DEFINED__

/* interface IDialErr */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDialErr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("462F7757-8848-11D1-ADD8-0000F87734F0")
    IDialErr : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDialErrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDialErr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDialErr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDialErr __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDialErr __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IDialErrVtbl;

    interface IDialErr
    {
        CONST_VTBL struct IDialErrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDialErr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDialErr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDialErr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDialErr_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDialErr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDialErr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDialErr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDialErr_INTERFACE_DEFINED__ */


#ifndef __ISmartStart_INTERFACE_DEFINED__
#define __ISmartStart_INTERFACE_DEFINED__

/* interface ISmartStart */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISmartStart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D8D8F19-8B89-11D1-ADDB-0000F87734F0")
    ISmartStart : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsInternetCapable( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISmartStartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISmartStart __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISmartStart __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISmartStart __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISmartStart __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsInternetCapable )( 
            ISmartStart __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } ISmartStartVtbl;

    interface ISmartStart
    {
        CONST_VTBL struct ISmartStartVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISmartStart_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISmartStart_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISmartStart_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISmartStart_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISmartStart_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISmartStart_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISmartStart_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISmartStart_IsInternetCapable(This,pbRetVal)	\
    (This)->lpVtbl -> IsInternetCapable(This,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ISmartStart_IsInternetCapable_Proxy( 
    ISmartStart __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB ISmartStart_IsInternetCapable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISmartStart_INTERFACE_DEFINED__ */


#ifndef __IICWSystemConfig_INTERFACE_DEFINED__
#define __IICWSystemConfig_INTERFACE_DEFINED__

/* interface IICWSystemConfig */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IICWSystemConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7954DD9A-8C2A-11D1-ADDB-0000F87734F0")
    IICWSystemConfig : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConfigSystem( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NeedsReboot( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_QuitWizard( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE VerifyRASIsRunning( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NeedsRestart( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckPasswordCachingPolicy( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IICWSystemConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IICWSystemConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IICWSystemConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigSystem )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NeedsReboot )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QuitWizard )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *VerifyRASIsRunning )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NeedsRestart )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckPasswordCachingPolicy )( 
            IICWSystemConfig __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } IICWSystemConfigVtbl;

    interface IICWSystemConfig
    {
        CONST_VTBL struct IICWSystemConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IICWSystemConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IICWSystemConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IICWSystemConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IICWSystemConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IICWSystemConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IICWSystemConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IICWSystemConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IICWSystemConfig_ConfigSystem(This,pbRetVal)	\
    (This)->lpVtbl -> ConfigSystem(This,pbRetVal)

#define IICWSystemConfig_get_NeedsReboot(This,pVal)	\
    (This)->lpVtbl -> get_NeedsReboot(This,pVal)

#define IICWSystemConfig_get_QuitWizard(This,pVal)	\
    (This)->lpVtbl -> get_QuitWizard(This,pVal)

#define IICWSystemConfig_VerifyRASIsRunning(This,pbRetVal)	\
    (This)->lpVtbl -> VerifyRASIsRunning(This,pbRetVal)

#define IICWSystemConfig_get_NeedsRestart(This,pVal)	\
    (This)->lpVtbl -> get_NeedsRestart(This,pVal)

#define IICWSystemConfig_CheckPasswordCachingPolicy(This,pbRetVal)	\
    (This)->lpVtbl -> CheckPasswordCachingPolicy(This,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_ConfigSystem_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IICWSystemConfig_ConfigSystem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_get_NeedsReboot_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IICWSystemConfig_get_NeedsReboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_get_QuitWizard_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IICWSystemConfig_get_QuitWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_VerifyRASIsRunning_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IICWSystemConfig_VerifyRASIsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_get_NeedsRestart_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IICWSystemConfig_get_NeedsRestart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IICWSystemConfig_CheckPasswordCachingPolicy_Proxy( 
    IICWSystemConfig __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IICWSystemConfig_CheckPasswordCachingPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IICWSystemConfig_INTERFACE_DEFINED__ */


#ifndef __ITapiLocationInfo_INTERFACE_DEFINED__
#define __ITapiLocationInfo_INTERFACE_DEFINED__

/* interface ITapiLocationInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITapiLocationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CB632C75-8DD4-11D1-ADDF-0000F87734F0")
    ITapiLocationInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_wNumberOfLocations( 
            /* [out] */ short __RPC_FAR *psVal,
            /* [retval][out] */ long __RPC_FAR *pCurrLoc) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_bstrAreaCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAreaCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_bstrAreaCode( 
            /* [in] */ BSTR bstrAreaCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lCountryCode( 
            /* [retval][out] */ long __RPC_FAR *plVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTapiLocationInfo( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumCountries( 
            /* [retval][out] */ long __RPC_FAR *pNumOfCountry) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryName( 
            /* [in] */ long lCountryIndex,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [retval][out] */ long __RPC_FAR *pCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCountry( 
            /* [retval][out] */ BSTR __RPC_FAR *pszCountryName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocationName( 
            /* [in] */ long lLocationIndex,
            /* [out] */ BSTR __RPC_FAR *pszLocationName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocationInfo( 
            /* [in] */ long lLocationIndex,
            /* [out] */ long __RPC_FAR *pLocationID,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [out] */ long __RPC_FAR *pCountryCode,
            /* [retval][out] */ BSTR __RPC_FAR *pszAreaCode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LocationId( 
            /* [in] */ long lLocationID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITapiLocationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITapiLocationInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITapiLocationInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_wNumberOfLocations )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [out] */ short __RPC_FAR *psVal,
            /* [retval][out] */ long __RPC_FAR *pCurrLoc);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bstrAreaCode )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrAreaCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bstrAreaCode )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ BSTR bstrAreaCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lCountryCode )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTapiLocationInfo )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumCountries )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pNumOfCountry);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CountryName )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lCountryIndex,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [retval][out] */ long __RPC_FAR *pCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultCountry )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pszCountryName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationName )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lLocationIndex,
            /* [out] */ BSTR __RPC_FAR *pszLocationName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LocationInfo )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lLocationIndex,
            /* [out] */ long __RPC_FAR *pLocationID,
            /* [out] */ BSTR __RPC_FAR *pszCountryName,
            /* [out] */ long __RPC_FAR *pCountryCode,
            /* [retval][out] */ BSTR __RPC_FAR *pszAreaCode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LocationId )( 
            ITapiLocationInfo __RPC_FAR * This,
            /* [in] */ long lLocationID);
        
        END_INTERFACE
    } ITapiLocationInfoVtbl;

    interface ITapiLocationInfo
    {
        CONST_VTBL struct ITapiLocationInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITapiLocationInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITapiLocationInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITapiLocationInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITapiLocationInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITapiLocationInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITapiLocationInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITapiLocationInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITapiLocationInfo_get_wNumberOfLocations(This,psVal,pCurrLoc)	\
    (This)->lpVtbl -> get_wNumberOfLocations(This,psVal,pCurrLoc)

#define ITapiLocationInfo_get_bstrAreaCode(This,pbstrAreaCode)	\
    (This)->lpVtbl -> get_bstrAreaCode(This,pbstrAreaCode)

#define ITapiLocationInfo_put_bstrAreaCode(This,bstrAreaCode)	\
    (This)->lpVtbl -> put_bstrAreaCode(This,bstrAreaCode)

#define ITapiLocationInfo_get_lCountryCode(This,plVal)	\
    (This)->lpVtbl -> get_lCountryCode(This,plVal)

#define ITapiLocationInfo_GetTapiLocationInfo(This,pbRetVal)	\
    (This)->lpVtbl -> GetTapiLocationInfo(This,pbRetVal)

#define ITapiLocationInfo_get_NumCountries(This,pNumOfCountry)	\
    (This)->lpVtbl -> get_NumCountries(This,pNumOfCountry)

#define ITapiLocationInfo_get_CountryName(This,lCountryIndex,pszCountryName,pCountryCode)	\
    (This)->lpVtbl -> get_CountryName(This,lCountryIndex,pszCountryName,pCountryCode)

#define ITapiLocationInfo_get_DefaultCountry(This,pszCountryName)	\
    (This)->lpVtbl -> get_DefaultCountry(This,pszCountryName)

#define ITapiLocationInfo_get_LocationName(This,lLocationIndex,pszLocationName)	\
    (This)->lpVtbl -> get_LocationName(This,lLocationIndex,pszLocationName)

#define ITapiLocationInfo_get_LocationInfo(This,lLocationIndex,pLocationID,pszCountryName,pCountryCode,pszAreaCode)	\
    (This)->lpVtbl -> get_LocationInfo(This,lLocationIndex,pLocationID,pszCountryName,pCountryCode,pszAreaCode)

#define ITapiLocationInfo_put_LocationId(This,lLocationID)	\
    (This)->lpVtbl -> put_LocationId(This,lLocationID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_wNumberOfLocations_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [out] */ short __RPC_FAR *psVal,
    /* [retval][out] */ long __RPC_FAR *pCurrLoc);


void __RPC_STUB ITapiLocationInfo_get_wNumberOfLocations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_bstrAreaCode_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrAreaCode);


void __RPC_STUB ITapiLocationInfo_get_bstrAreaCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_put_bstrAreaCode_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ BSTR bstrAreaCode);


void __RPC_STUB ITapiLocationInfo_put_bstrAreaCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_lCountryCode_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plVal);


void __RPC_STUB ITapiLocationInfo_get_lCountryCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_GetTapiLocationInfo_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB ITapiLocationInfo_GetTapiLocationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_NumCountries_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pNumOfCountry);


void __RPC_STUB ITapiLocationInfo_get_NumCountries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_CountryName_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lCountryIndex,
    /* [out] */ BSTR __RPC_FAR *pszCountryName,
    /* [retval][out] */ long __RPC_FAR *pCountryCode);


void __RPC_STUB ITapiLocationInfo_get_CountryName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_DefaultCountry_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pszCountryName);


void __RPC_STUB ITapiLocationInfo_get_DefaultCountry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_LocationName_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lLocationIndex,
    /* [out] */ BSTR __RPC_FAR *pszLocationName);


void __RPC_STUB ITapiLocationInfo_get_LocationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_get_LocationInfo_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lLocationIndex,
    /* [out] */ long __RPC_FAR *pLocationID,
    /* [out] */ BSTR __RPC_FAR *pszCountryName,
    /* [out] */ long __RPC_FAR *pCountryCode,
    /* [retval][out] */ BSTR __RPC_FAR *pszAreaCode);


void __RPC_STUB ITapiLocationInfo_get_LocationInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITapiLocationInfo_put_LocationId_Proxy( 
    ITapiLocationInfo __RPC_FAR * This,
    /* [in] */ long lLocationID);


void __RPC_STUB ITapiLocationInfo_put_LocationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITapiLocationInfo_INTERFACE_DEFINED__ */


#ifndef __IUserInfo_INTERFACE_DEFINED__
#define __IUserInfo_INTERFACE_DEFINED__

/* interface IUserInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IUserInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9E12E76C-94D6-11D1-ADE2-0000F87734F0")
    IUserInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CollectRegisteredUserInfo( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Company( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Company( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FirstName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FirstName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastName( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LastName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address1( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Address1( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address2( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Address2( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_City( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_City( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ZIPCode( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ZIPCode( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneNumber( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PhoneNumber( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Lcid( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PersistRegisteredUserInfo( 
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUserInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUserInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IUserInfo __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CollectRegisteredUserInfo )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Company )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Company )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FirstName )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FirstName )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LastName )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LastName )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address1 )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Address1 )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Address2 )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Address2 )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_City )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_City )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_State )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_State )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZIPCode )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZIPCode )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PhoneNumber )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PhoneNumber )( 
            IUserInfo __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Lcid )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PersistRegisteredUserInfo )( 
            IUserInfo __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } IUserInfoVtbl;

    interface IUserInfo
    {
        CONST_VTBL struct IUserInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IUserInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IUserInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IUserInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IUserInfo_CollectRegisteredUserInfo(This,pbRetVal)	\
    (This)->lpVtbl -> CollectRegisteredUserInfo(This,pbRetVal)

#define IUserInfo_get_Company(This,pVal)	\
    (This)->lpVtbl -> get_Company(This,pVal)

#define IUserInfo_put_Company(This,newVal)	\
    (This)->lpVtbl -> put_Company(This,newVal)

#define IUserInfo_get_FirstName(This,pVal)	\
    (This)->lpVtbl -> get_FirstName(This,pVal)

#define IUserInfo_put_FirstName(This,newVal)	\
    (This)->lpVtbl -> put_FirstName(This,newVal)

#define IUserInfo_get_LastName(This,pVal)	\
    (This)->lpVtbl -> get_LastName(This,pVal)

#define IUserInfo_put_LastName(This,newVal)	\
    (This)->lpVtbl -> put_LastName(This,newVal)

#define IUserInfo_get_Address1(This,pVal)	\
    (This)->lpVtbl -> get_Address1(This,pVal)

#define IUserInfo_put_Address1(This,newVal)	\
    (This)->lpVtbl -> put_Address1(This,newVal)

#define IUserInfo_get_Address2(This,pVal)	\
    (This)->lpVtbl -> get_Address2(This,pVal)

#define IUserInfo_put_Address2(This,newVal)	\
    (This)->lpVtbl -> put_Address2(This,newVal)

#define IUserInfo_get_City(This,pVal)	\
    (This)->lpVtbl -> get_City(This,pVal)

#define IUserInfo_put_City(This,newVal)	\
    (This)->lpVtbl -> put_City(This,newVal)

#define IUserInfo_get_State(This,pVal)	\
    (This)->lpVtbl -> get_State(This,pVal)

#define IUserInfo_put_State(This,newVal)	\
    (This)->lpVtbl -> put_State(This,newVal)

#define IUserInfo_get_ZIPCode(This,pVal)	\
    (This)->lpVtbl -> get_ZIPCode(This,pVal)

#define IUserInfo_put_ZIPCode(This,newVal)	\
    (This)->lpVtbl -> put_ZIPCode(This,newVal)

#define IUserInfo_get_PhoneNumber(This,pVal)	\
    (This)->lpVtbl -> get_PhoneNumber(This,pVal)

#define IUserInfo_put_PhoneNumber(This,newVal)	\
    (This)->lpVtbl -> put_PhoneNumber(This,newVal)

#define IUserInfo_get_Lcid(This,pVal)	\
    (This)->lpVtbl -> get_Lcid(This,pVal)

#define IUserInfo_PersistRegisteredUserInfo(This,pbRetVal)	\
    (This)->lpVtbl -> PersistRegisteredUserInfo(This,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUserInfo_CollectRegisteredUserInfo_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IUserInfo_CollectRegisteredUserInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Company_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_Company_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_Company_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_FirstName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_FirstName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_FirstName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_LastName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_LastName_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_LastName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Address1_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Address1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_Address1_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_Address1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Address2_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Address2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_Address2_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_Address2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_City_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_City_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_City_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_State_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_State_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_ZIPCode_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_ZIPCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_ZIPCode_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_ZIPCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_PhoneNumber_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_PhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IUserInfo_put_PhoneNumber_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IUserInfo_put_PhoneNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IUserInfo_get_Lcid_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IUserInfo_get_Lcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IUserInfo_PersistRegisteredUserInfo_Proxy( 
    IUserInfo __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IUserInfo_PersistRegisteredUserInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserInfo_INTERFACE_DEFINED__ */


#ifndef __IWebGate_INTERFACE_DEFINED__
#define __IWebGate_INTERFACE_DEFINED__

/* interface IWebGate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWebGate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3724B9A0-9503-11D1-B86A-00A0C90DC849")
    IWebGate : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FormData( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FetchPage( 
            /* [in] */ DWORD dwKeepPage,
            /* [in] */ DWORD dwDoWait,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DownloadFname( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DumpBufferToFile( 
            /* [out] */ BSTR __RPC_FAR *pFileName,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWebGateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWebGate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWebGate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWebGate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FormData )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FetchPage )( 
            IWebGate __RPC_FAR * This,
            /* [in] */ DWORD dwKeepPage,
            /* [in] */ DWORD dwDoWait,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IWebGate __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DownloadFname )( 
            IWebGate __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DumpBufferToFile )( 
            IWebGate __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pFileName,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        END_INTERFACE
    } IWebGateVtbl;

    interface IWebGate
    {
        CONST_VTBL struct IWebGateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWebGate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWebGate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWebGate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWebGate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWebGate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWebGate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWebGate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWebGate_put_Path(This,newVal)	\
    (This)->lpVtbl -> put_Path(This,newVal)

#define IWebGate_put_FormData(This,newVal)	\
    (This)->lpVtbl -> put_FormData(This,newVal)

#define IWebGate_FetchPage(This,dwKeepPage,dwDoWait,pbRetVal)	\
    (This)->lpVtbl -> FetchPage(This,dwKeepPage,dwDoWait,pbRetVal)

#define IWebGate_get_Buffer(This,pVal)	\
    (This)->lpVtbl -> get_Buffer(This,pVal)

#define IWebGate_get_DownloadFname(This,pVal)	\
    (This)->lpVtbl -> get_DownloadFname(This,pVal)

#define IWebGate_DumpBufferToFile(This,pFileName,pbRetVal)	\
    (This)->lpVtbl -> DumpBufferToFile(This,pFileName,pbRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWebGate_put_Path_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWebGate_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IWebGate_put_FormData_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IWebGate_put_FormData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebGate_FetchPage_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [in] */ DWORD dwKeepPage,
    /* [in] */ DWORD dwDoWait,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IWebGate_FetchPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebGate_get_Buffer_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IWebGate_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWebGate_get_DownloadFname_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IWebGate_get_DownloadFname_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWebGate_DumpBufferToFile_Proxy( 
    IWebGate __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pFileName,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IWebGate_DumpBufferToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWebGate_INTERFACE_DEFINED__ */


#ifndef __IINSHandler_INTERFACE_DEFINED__
#define __IINSHandler_INTERFACE_DEFINED__

/* interface IINSHandler */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IINSHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6342E1B5-94DB-11D1-ADE2-0000F87734F0")
    IINSHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProcessINS( 
            BSTR bstrINSFilePath,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NeedRestart( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BrandingFlags( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pszURL) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SilentMode( 
            /* [in] */ BOOL bSilent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IINSHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IINSHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IINSHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IINSHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessINS )( 
            IINSHandler __RPC_FAR * This,
            BSTR bstrINSFilePath,
            /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NeedRestart )( 
            IINSHandler __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BrandingFlags )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultURL )( 
            IINSHandler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pszURL);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SilentMode )( 
            IINSHandler __RPC_FAR * This,
            /* [in] */ BOOL bSilent);
        
        END_INTERFACE
    } IINSHandlerVtbl;

    interface IINSHandler
    {
        CONST_VTBL struct IINSHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IINSHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IINSHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IINSHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IINSHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IINSHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IINSHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IINSHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IINSHandler_ProcessINS(This,bstrINSFilePath,pbRetVal)	\
    (This)->lpVtbl -> ProcessINS(This,bstrINSFilePath,pbRetVal)

#define IINSHandler_get_NeedRestart(This,pVal)	\
    (This)->lpVtbl -> get_NeedRestart(This,pVal)

#define IINSHandler_put_BrandingFlags(This,lFlags)	\
    (This)->lpVtbl -> put_BrandingFlags(This,lFlags)

#define IINSHandler_get_DefaultURL(This,pszURL)	\
    (This)->lpVtbl -> get_DefaultURL(This,pszURL)

#define IINSHandler_put_SilentMode(This,bSilent)	\
    (This)->lpVtbl -> put_SilentMode(This,bSilent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IINSHandler_ProcessINS_Proxy( 
    IINSHandler __RPC_FAR * This,
    BSTR bstrINSFilePath,
    /* [retval][out] */ BOOL __RPC_FAR *pbRetVal);


void __RPC_STUB IINSHandler_ProcessINS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IINSHandler_get_NeedRestart_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IINSHandler_get_NeedRestart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IINSHandler_put_BrandingFlags_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IINSHandler_put_BrandingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IINSHandler_get_DefaultURL_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pszURL);


void __RPC_STUB IINSHandler_get_DefaultURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IINSHandler_put_SilentMode_Proxy( 
    IINSHandler __RPC_FAR * This,
    /* [in] */ BOOL bSilent);


void __RPC_STUB IINSHandler_put_SilentMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IINSHandler_INTERFACE_DEFINED__ */



#ifndef __ICWHELPLib_LIBRARY_DEFINED__
#define __ICWHELPLib_LIBRARY_DEFINED__

/* library ICWHELPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ICWHELPLib;

#ifndef ___RefDialEvents_DISPINTERFACE_DEFINED__
#define ___RefDialEvents_DISPINTERFACE_DEFINED__

/* dispinterface _RefDialEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__RefDialEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("07DB96D0-91D8-11D1-ADE1-0000F87734F0")
    _RefDialEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _RefDialEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _RefDialEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _RefDialEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _RefDialEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _RefDialEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _RefDialEventsVtbl;

    interface _RefDialEvents
    {
        CONST_VTBL struct _RefDialEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _RefDialEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _RefDialEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _RefDialEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _RefDialEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _RefDialEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _RefDialEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _RefDialEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___RefDialEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_RefDial;

#ifdef __cplusplus

class DECLSPEC_UUID("1E794A0A-86F4-11D1-ADD8-0000F87734F0")
RefDial;
#endif

EXTERN_C const CLSID CLSID_DialErr;

#ifdef __cplusplus

class DECLSPEC_UUID("462F7758-8848-11D1-ADD8-0000F87734F0")
DialErr;
#endif

EXTERN_C const CLSID CLSID_SmartStart;

#ifdef __cplusplus

class DECLSPEC_UUID("5D8D8F1A-8B89-11D1-ADDB-0000F87734F0")
SmartStart;
#endif

EXTERN_C const CLSID CLSID_ICWSystemConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("7954DD9B-8C2A-11D1-ADDB-0000F87734F0")
ICWSystemConfig;
#endif

EXTERN_C const CLSID CLSID_TapiLocationInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("CB632C76-8DD4-11D1-ADDF-0000F87734F0")
TapiLocationInfo;
#endif

EXTERN_C const CLSID CLSID_UserInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("9E12E76D-94D6-11D1-ADE2-0000F87734F0")
UserInfo;
#endif

#ifndef ___WebGateEvents_DISPINTERFACE_DEFINED__
#define ___WebGateEvents_DISPINTERFACE_DEFINED__

/* dispinterface _WebGateEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__WebGateEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("166A20C0-AE10-11D1-ADEB-0000F87734F0")
    _WebGateEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _WebGateEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _WebGateEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _WebGateEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _WebGateEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _WebGateEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _WebGateEventsVtbl;

    interface _WebGateEvents
    {
        CONST_VTBL struct _WebGateEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _WebGateEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _WebGateEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _WebGateEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _WebGateEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _WebGateEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _WebGateEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _WebGateEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___WebGateEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WebGate;

#ifdef __cplusplus

class DECLSPEC_UUID("3724B9A1-9503-11D1-B86A-00A0C90DC849")
WebGate;
#endif

#ifndef ___INSHandlerEvents_DISPINTERFACE_DEFINED__
#define ___INSHandlerEvents_DISPINTERFACE_DEFINED__

/* dispinterface _INSHandlerEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__INSHandlerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("1F6D88A2-98D2-11d1-ADE3-0000F87734F0")
    _INSHandlerEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _INSHandlerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _INSHandlerEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _INSHandlerEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _INSHandlerEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _INSHandlerEventsVtbl;

    interface _INSHandlerEvents
    {
        CONST_VTBL struct _INSHandlerEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _INSHandlerEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _INSHandlerEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _INSHandlerEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _INSHandlerEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _INSHandlerEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _INSHandlerEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _INSHandlerEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___INSHandlerEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_INSHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("6342E1B6-94DB-11D1-ADE2-0000F87734F0")
INSHandler;
#endif
#endif /* __ICWHELPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwunicd.h ===
//**********************************************************************
// File name: icwunicd.h
//
//      Commonly used UNICDE definition header.
//
// Copyright (c) 1993-1999 Microsoft Corporation. All rights reserved.
//**********************************************************************
#ifndef _ICWUNICD_H_
#define _ICWUNICD_H_

#ifdef UNICODE
#define REALLY_USE_UNICODE
#endif

#include <tchar.h>   // _tsplitpath, _tmakepath, _ttoi, _itot

#endif // _ICWUNICD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\icwhelp_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Fri May 08 10:39:03 1998
 */
/* Compiler settings for icwhelp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IRefDial = {0x1E794A09,0x86F4,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IDialErr = {0x462F7757,0x8848,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_ISmartStart = {0x5D8D8F19,0x8B89,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IICWSystemConfig = {0x7954DD9A,0x8C2A,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_ITapiLocationInfo = {0xCB632C75,0x8DD4,0x11D1,{0xAD,0xDF,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IUserInfo = {0x9E12E76C,0x94D6,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID IID_IWebGate = {0x3724B9A0,0x9503,0x11D1,{0xB8,0x6A,0x00,0xA0,0xC9,0x0D,0xC8,0x49}};


const IID IID_IINSHandler = {0x6342E1B5,0x94DB,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID LIBID_ICWHELPLib = {0x1E7949FA,0x86F4,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID DIID__RefDialEvents = {0x07DB96D0,0x91D8,0x11D1,{0xAD,0xE1,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_RefDial = {0x1E794A0A,0x86F4,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_DialErr = {0x462F7758,0x8848,0x11D1,{0xAD,0xD8,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_SmartStart = {0x5D8D8F1A,0x8B89,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_ICWSystemConfig = {0x7954DD9B,0x8C2A,0x11D1,{0xAD,0xDB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_TapiLocationInfo = {0xCB632C76,0x8DD4,0x11D1,{0xAD,0xDF,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_UserInfo = {0x9E12E76D,0x94D6,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const IID DIID__WebGateEvents = {0x166A20C0,0xAE10,0x11D1,{0xAD,0xEB,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_WebGate = {0x3724B9A1,0x9503,0x11D1,{0xB8,0x6A,0x00,0xA0,0xC9,0x0D,0xC8,0x49}};


const IID DIID__INSHandlerEvents = {0x1F6D88A2,0x98D2,0x11d1,{0xAD,0xE3,0x00,0x00,0xF8,0x77,0x34,0xF0}};


const CLSID CLSID_INSHandler = {0x6342E1B6,0x94DB,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x77,0x34,0xF0}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\mcreg.h ===
#pragma once

class CMcRegistry
{
public:
    CMcRegistry();
    ~CMcRegistry();

public:
    bool OpenKey(HKEY hkeyStart, LPCTSTR strKey, REGSAM sam = KEY_READ | KEY_WRITE);
    bool CreateKey(HKEY hkeyStart, LPCTSTR strKey);
    bool CloseKey();

    bool GetValue(LPCTSTR strValue, LPTSTR strData, ULONG nBufferSize);
    bool GetValue(LPCTSTR strValue, DWORD& rdw);

    bool SetValue(LPCTSTR strValue, LPCTSTR strData);
    bool SetValue(LPCTSTR strValue, DWORD rdw);

private:
    HKEY    m_hkey;
};

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\inetapi.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
// INETAPI.H -  APIs for system configuration for Internet and phone number
//              setting
//

//  HISTORY:
//  
//  3/3/95  jeremys     Created.
//  96/03/21  markdu  Use private string sizes (MSN_) for PHONENUM since the
//            RAS ones (RAS_) change depending on platform, but MSN does not
//            expect this so the structure sizes won't match on existing code.
//

#ifndef _INETAPI_H_
#define _INETAPI_H_

#ifndef _RNAP_H_
// (copied from RNA header file)

#define MSN_MaxAreaCode     10
#define MSN_MaxLocal        36
#define MSN_MaxExtension    5

typedef struct tagPHONENUMA {
    DWORD dwCountryID;
    DWORD dwCountryCode;
    CHAR  szAreaCode[MSN_MaxAreaCode+1];
    CHAR  szLocal[MSN_MaxLocal+1];
    CHAR  szExtension[MSN_MaxExtension+1];
} PHONENUMA, FAR * LPPHONENUMA;

typedef struct tagPHONENUMW {
    DWORD dwCountryID;
    DWORD dwCountryCode;
    WCHAR szAreaCode[MSN_MaxAreaCode+1];
    WCHAR szLocal[MSN_MaxLocal+1];
    WCHAR szExtension[MSN_MaxExtension+1];
} PHONENUMW, FAR * LPPHONENUMW;

#ifdef UNICODE
#define PHONENUM     PHONENUMW
#define LPPHONENUM   LPPHONENUMW
#else
#define PHONENUM     PHONENUMA
#define LPPHONENUM   LPPHONENUMA
#endif

#endif // ifndef _RNAP_H_

// input flags for APIs
#define ICIF_NOCONFIGURE    0x0001  // for SetInternetPhoneNumber, see comments below
#define ICIF_DONTSETASINTERNETENTRY 0x0002  // if set, phone number will be updated
                            // but this connectoid will not be set as the internet connectoid
#define ICIF_NODNSCHECK     0x0004  // if set, won't check and warn if static DNS is set

// output flags for APIs
#define ICOF_NEEDREBOOT     0x0001  // indicates that caller must restart system


// structures used to contain API parameters

typedef struct tagINTERNET_CONFIGA
{
    DWORD cbSize;           // size of this structure in bytes
    HWND hwndParent;        // parent window handle

    LPCSTR pszModemName;    // name of modem to use
    LPCSTR pszUserName;     // user name for RNA connectoid (ignored if NULL)
    LPCSTR pszPassword;     // password for RNA connectoid (ignored if NULL)

    PHONENUMA PhoneNum;     // phone number to use
    LPCSTR pszEntryName;    // title to use for RNA connectoid (default name
                            // used if NULL)

    PHONENUMA PhoneNum2;    // backup phone number to use
    LPCSTR pszEntryName2;   // title to use for RNA connectoid (default name
                            // used if NULL)


    LPCSTR pszDNSServer;    // points to string w/IP address (e.g. "108.9.107.4");
                            // (ignored if NULL)
    LPCSTR pszDNSServer2;   // points to string w/IP address(e.g. "108.9.107.4");
                            // (ignored if NULL)

    LPCSTR pszAutodialDllName;  // optional: name of autodial dll to use (ignored if NULL)
    LPCSTR pszAutodialFcnName;  // optional: name of function in autodiall dll to use (ignored if NULL)

    DWORD dwInputFlags;     // at entry, some combination of ICIF_ flags
    DWORD dwOutputFlags;    // at return, set to some combination of ICOF_ flags

} INTERNET_CONFIGA, FAR * LPINTERNET_CONFIGA;

typedef struct tagINTERNET_CONFIGW
{
    DWORD cbSize;           // size of this structure in bytes
    HWND hwndParent;        // parent window handle

    LPCWSTR pszModemName;   // name of modem to use
    LPCWSTR pszUserName;    // user name for RNA connectoid (ignored if NULL)
    LPCWSTR pszPassword;    // password for RNA connectoid (ignored if NULL)

    PHONENUMW PhoneNum;     // phone number to use
    LPCWSTR pszEntryName;   // title to use for RNA connectoid (default name
                            // used if NULL)

    PHONENUMW PhoneNum2;    // backup phone number to use
    LPCWSTR pszEntryName2;  // title to use for RNA connectoid (default name
                            // used if NULL)


    LPCWSTR pszDNSServer;   // points to string w/IP address (e.g. "108.9.107.4");
                            // (ignored if NULL)
    LPCWSTR pszDNSServer2;  // points to string w/IP address(e.g. "108.9.107.4");
                            // (ignored if NULL)

    LPCWSTR pszAutodialDllName;  // optional: name of autodial dll to use (ignored if NULL)
    LPCWSTR pszAutodialFcnName;  // optional: name of function in autodiall dll to use (ignored if NULL)

    DWORD dwInputFlags;     // at entry, some combination of ICIF_ flags
    DWORD dwOutputFlags;    // at return, set to some combination of ICOF_ flags

} INTERNET_CONFIGW, FAR * LPINTERNET_CONFIGW;

#ifdef UNICODE
typedef INTERNET_CONFIGW    INTERNET_CONFIG;
typedef LPINTERNET_CONFIGW  LPINTERNET_CONFIG;
#else
typedef INTERNET_CONFIGA    INTERNET_CONFIG;
typedef LPINTERNET_CONFIGA  LPINTERNET_CONFIG;
#endif
 
// function prototypes


/*******************************************************************

    NAME:       ConfigureSystemForInternet

    SYNOPSIS:   Performs all necessary configuration to set system up
                to use Internet.

    ENTRY:      lpInternetConfig - pointer to structure with configuration
                information.

    EXIT:       TRUE if successful, or FALSE if fails.  Displays its
                own error message upon failure.

                If the output flag ICOF_NEEDREBOOT is set, the caller
                must restart the system before continuing.

    NOTES:      Will install TCP/IP, RNA, PPPMAC as necessary; will
                create or modify an Internet RNA connectoid.

                This API displays error messages itself rather than
                passing back an error code because there is a wide range of
                possible error codes from different families, it is difficult
                for the caller to obtain text for all of them.
                
********************************************************************/
extern "C" BOOL WINAPI ConfigureSystemForInternetA(LPINTERNET_CONFIGA lpInternetConfig);
extern "C" BOOL WINAPI ConfigureSystemForInternetW(LPINTERNET_CONFIGW lpInternetConfig);

#ifdef UNICODE
#define ConfigureSystemForInternet ConfigureSystemForInternetW
#else
#define ConfigureSystemForInternet ConfigureSystemForInternetA
#endif


/*******************************************************************

    NAME:       SetInternetPhoneNumber

    SYNOPSIS:   Sets the phone number used to auto-dial to the Internet.

                If the system is not fully configured when this API is called,
                this API will do the configuration after checking with the user.
                (This step is included for extra robustness, in case the user has
                removed something since the system was configured.)
    
    ENTRY:      lpPhonenumConfig - pointer to structure with configuration
                information.

                If the input flag ICIF_NOCONFIGURE is set, then if the system
                is not already configured properly, this API will display an
                error message and return FALSE.  (Otherwise this API will
                ask the user if it's OK to configure the system, and do it.)

    EXIT:       TRUE if successful, or FALSE if fails.  Displays its
                own error message upon failure.

                If the output flag ICOF_NEEDREBOOT is set, the caller
                must restart the system before continuing.  (

    NOTES:      Will create a new connectoid if a connectoid for the internet
                does not exist yet, otherwise modifies existing internet
                connectoid.

                This API displays error messages itself rather than
                passing back an error code because there is a wide range of
                possible error codes from different families, it is difficult
                for the caller to obtain text for all of them.
                
********************************************************************/
extern "C" BOOL WINAPI SetInternetPhoneNumberA(LPINTERNET_CONFIGA lpInternetConfig);
extern "C" BOOL WINAPI SetInternetPhoneNumberW(LPINTERNET_CONFIGW lpInternetConfig);

#ifdef UNICODE
#define SetInternetPhoneNumber  SetInternetPhoneNumberW
#else
#define SetInternetPhoneNumber  SetInternetPhoneNumberA
#endif

#endif // _INETAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\netmpr.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    netmpr.h

Abstract:

    DDK WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:


Revision History:

    20-Mar-1995     LenS
        Created.

--*/

#ifndef _INC_NETMPR_
#define _INC_NETMPR_


//
//  Authentication and Logon/Logoff.
//

#define LOGON_DONE              0x00000001
#define LOGON_PRIMARY           0x00000002
#define LOGON_MUST_VALIDATE     0x00000004

#define LOGOFF_PENDING  1
#define LOGOFF_COMMIT   2
#define LOGOFF_CANCEL   3


//
//  Password Cache.
//

#ifndef PCE_STRUCT_DEFINED
#define PCE_STRUCT_DEFINED

struct PASSWORD_CACHE_ENTRY {
    WORD cbEntry;               /* size of this entry in bytes, incl. pad */
    WORD cbResource;            /* size of resource name in bytes */
    WORD cbPassword;            /* size of password in bytes */
    BYTE iEntry;                /* index number of this entry, for MRU */
    BYTE nType;                 /* type of entry (see below) */
    char abResource[1];         /* resource name (may not be ASCIIZ at all) */
};

#define PCE_MEMORYONLY          0x01    /* for flags field when adding */

/*
    Typedef for the callback routine passed to the enumeration functions.
    It will be called once for each entry that matches the criteria
    requested.  It returns TRUE if it wants the enumeration to
    continue, FALSE to stop.
*/
typedef BOOL (FAR PASCAL *CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData );

#endif  /* PCE_STRUCT_DEFINED */

DWORD APIENTRY
WNetCachePassword(
    LPSTR pbResource,
    WORD  cbResource,
    LPSTR pbPassword,
    WORD  cbPassword,
    BYTE  nType,
    UINT  fnFlags
    );

DWORD APIENTRY
WNetGetCachedPassword(
    LPSTR  pbResource,
    WORD   cbResource,
    LPSTR  pbPassword,
    LPWORD pcbPassword,
    BYTE   nType
    );

DWORD APIENTRY
WNetRemoveCachedPassword(
    LPSTR pbResource,
    WORD  cbResource,
    BYTE  nType
    );

DWORD APIENTRY
WNetEnumCachedPasswords(
    LPSTR pbPrefix,
    WORD  cbPrefix,
    BYTE  nType,
    CACHECALLBACK pfnCallback,
    DWORD dwRefData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\inetcfg.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996 - 97
//
//  *** N O T   F O R   E X T E R N A L   R E L E A S E *******
//  This header file is not intended for distribution outside Microsoft.
//
//  FILE: INETCFG.H
//
//  PURPOSE:  Contains API's exported from inetcfg.dll and structures
//            required by those functions. 
//            Note:  Definitions in this header file require RAS.H.
//
//*******************************************************************

#ifndef _INETCFG_H_
#define _INETCFG_H_

#ifndef UNLEN
#include <lmcons.h>
#endif

// Generic HRESULT error code
#define ERROR_INETCFG_UNKNOWN 0x20000000L

#define MAX_EMAIL_NAME          64
#define MAX_EMAIL_ADDRESS       128
#define MAX_LOGON_NAME          UNLEN
#define MAX_LOGON_PASSWORD      PWLEN
#define MAX_SERVER_NAME         64  // max length of DNS name per RFC 1035 +1

// IE Auto proxy value in registry
#define AUTO_ONCE_EVER              0           // Auto proxy discovery
#define AUTO_DISABLED               1 
#define AUTO_ONCE_PER_SESSION       2
#define AUTO_ALWAYS                 3

// Flags for dwfOptions

// install Internet mail
#define INETCFG_INSTALLMAIL           0x00000001
// Invoke InstallModem wizard if NO MODEM IS INSTALLED
#define INETCFG_INSTALLMODEM          0x00000002
// install RNA (if needed)
#define INETCFG_INSTALLRNA            0x00000004
// install TCP (if needed)
#define INETCFG_INSTALLTCP            0x00000008
// connecting with LAN (vs modem)
#define INETCFG_CONNECTOVERLAN        0x00000010
// Set the phone book entry for autodial
#define INETCFG_SETASAUTODIAL         0x00000020
// Overwrite the phone book entry if it exists
// Note: if this flag is not set, and the entry exists, a unique name will
// be created for the entry.
#define INETCFG_OVERWRITEENTRY        0x00000040
// Do not show the dialog that tells the user that files are about to be installed,
// with OK/Cancel buttons.
#define INETCFG_SUPPRESSINSTALLUI     0x00000080
// Check if TCP/IP file sharing is turned on, and warn user to turn it off.
// Reboot is required if the user turns it off.
#define INETCFG_WARNIFSHARINGBOUND    0x00000100
// Check if TCP/IP file sharing is turned on, and force user to turn it off.
// If user does not want to turn it off, return will be ERROR_CANCELLED
// Reboot is required if the user turns it off.
#define INETCFG_REMOVEIFSHARINGBOUND  0x00000200
// Indicates that this is a temporary phone book entry
// In Win3.1 an icon will not be created
#define INETCFG_TEMPPHONEBOOKENTRY    0x00000400
// Show the busy dialog while checking system configuration
#define INETCFG_SHOWBUSYANIMATION     0x00000800

//
// Chrisk 5/8/97
// Note: the next three switches are only valid for InetNeedSystemComponents
// Check if LAN adapter is installed and bound to TCP
//
#define INETCFG_INSTALLLAN            0x00001000

//
// Check if DIALUP adapter is installed and bound to TCP
//
#define INETCFG_INSTALLDIALUP         0x00002000

//
// Check to see if TCP is installed requardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

// constants for INETCLIENTINFO.dwFlags

#define INETC_LOGONMAIL     0x00000001
#define INETC_LOGONNEWS     0x00000002
#define INETC_LOGONDIRSERV  0x00000004

// Struct INETCLIENTINFO
//
// This structure is used when getting and setting the internet
// client parameters
//
// The members are as follows:
//
//  dwSize
//    size of this structure, for future versioning
//    this member should be set before passing the structure to the DLL
//  dwFlags
//    miscellaneous flags
//    see definitions above
//  szEMailName
//    user's internet email name
//  szEMailAddress
//    user's internet email address
//  ***Note: the following three fields are outdated, and should only be used by old legacy code.
//  ***      new code should use szIncomingMail* and iIncomingProtocol fields.
//  szPOPLogonName
//    user's internet mail server logon name 
//  szPOPLogonPassword
//    user's internet mail server logon password
//  szPOPServer
//    user's internet mail POP3 server
//  szSMTPServer
//    user's internet mail SMTP server
//  szNNTPLogonName
//    user's news server logon name
//  szNNTPLogonPassword
//    user's news server logon password
//  szNNTPServer
//    user's news server
//  ** End of original 1.0 structure.
//  ??/??/96 ValdonB
//  szNNTPName
//    user's friendly name to include in NNTP posts.(?? Valdon?)
//  szNNTPAddress
//    user's reply-to email address for NNTP posts.(?? Valdon?)
//  11/23/96  jmazner Normandy #8504
//  iIncomingProtocol
//    user's choice of POP3 or IMAP4 protocol for incoming mail
//    Holds the enum values defined in ACCTTYPE from imact.h//
//  szIncomingMailLogonName
//    user's internet mail server logon name 
//  szIncomingMailLogonPassword
//    user's internet mail server logon password
//  szIncomingMailServer
//    user's internet mail POP3 server
//  12/15/96    jmazner 
//  fMailLogonSPA
//    Use Sicily/SPA/DPA for the incoming mail server
//  fNewsLogonSPA
//    Use Sicily/SPA/DPA for the news server
//  2/4/96 jmazner -- LDAP functionality
//  szLDAPLogonName
//  szLDAPLogonPassword
//  szLDAPServer
//  fLDAPLogonSPA
//  fLDAPResolve

  typedef struct tagINETCLIENTINFOA
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    CHAR    szEMailName[MAX_EMAIL_NAME + 1];
    CHAR    szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    CHAR    szPOPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szPOPServer[MAX_SERVER_NAME + 1];
    CHAR    szSMTPServer[MAX_SERVER_NAME + 1];
    CHAR    szNNTPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szNNTPServer[MAX_SERVER_NAME + 1];
    // end of version 1.0 structure;
    // extended 1.1 structure includes the following fields:
    CHAR    szNNTPName[MAX_EMAIL_NAME + 1];
    CHAR    szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
    int     iIncomingProtocol;
    CHAR    szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    CHAR    szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szIncomingMailServer[MAX_SERVER_NAME + 1];
    BOOL    fMailLogonSPA;
    BOOL    fNewsLogonSPA;
    CHAR    szLDAPLogonName[MAX_LOGON_NAME + 1];
    CHAR    szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    CHAR    szLDAPServer[MAX_SERVER_NAME + 1];
    BOOL    fLDAPLogonSPA;
    BOOL    fLDAPResolve;

  } INETCLIENTINFOA, *PINETCLIENTINFOA, FAR *LPINETCLIENTINFOA;

  typedef struct tagINETCLIENTINFOW
  {
    DWORD   dwSize;
    DWORD   dwFlags;
    WCHAR   szEMailName[MAX_EMAIL_NAME + 1];
    WCHAR   szEMailAddress[MAX_EMAIL_ADDRESS + 1];
    WCHAR   szPOPLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szPOPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szPOPServer[MAX_SERVER_NAME + 1];
    WCHAR   szSMTPServer[MAX_SERVER_NAME + 1];
    WCHAR   szNNTPLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szNNTPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szNNTPServer[MAX_SERVER_NAME + 1];
    // end of version 1.0 structure;
    // extended 1.1 structure includes the following fields:
    WCHAR   szNNTPName[MAX_EMAIL_NAME + 1];
    WCHAR   szNNTPAddress[MAX_EMAIL_ADDRESS + 1];
    int     iIncomingProtocol;
    WCHAR   szIncomingMailLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szIncomingMailLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szIncomingMailServer[MAX_SERVER_NAME + 1];
    BOOL    fMailLogonSPA;
    BOOL    fNewsLogonSPA;
    WCHAR   szLDAPLogonName[MAX_LOGON_NAME + 1];
    WCHAR   szLDAPLogonPassword[MAX_LOGON_PASSWORD + 1];
    WCHAR   szLDAPServer[MAX_SERVER_NAME + 1];
    BOOL    fLDAPLogonSPA;
    BOOL    fLDAPResolve;

  } INETCLIENTINFOW, *PINETCLIENTINFOW, FAR *LPINETCLIENTINFOW;

#ifdef UNICODE
typedef INETCLIENTINFOW     INETCLIENTINFO;
typedef PINETCLIENTINFOW    PINETCLIENTINFO;
typedef LPINETCLIENTINFOW   LPINETCLIENTINFO;
#else
typedef INETCLIENTINFOA     INETCLIENTINFO;
typedef PINETCLIENTINFOA    PINETCLIENTINFO;
typedef LPINETCLIENTINFOA   LPINETCLIENTINFO;
#endif

// Function prototypes

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetClientInfoA(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo);

HRESULT WINAPI InetGetClientInfoW(
  LPCWSTR           lpszProfileName,
  LPINETCLIENTINFOW lpClientInfo);

#ifdef UNICODE
#define InetGetClientInfo   InetGetClientInfoW
#else
#define InetGetClientInfo   InetGetClientInfoA
#endif


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetSetClientInfoA(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo);

HRESULT WINAPI InetSetClientInfoW(
  LPCWSTR           lpszProfileName,
  LPINETCLIENTINFOW lpClientInfo);

#ifdef UNICODE
#define InetSetClientInfo   InetSetClientInfoW
#else
#define InetSetClientInfo   InetSetClientInfoA
#endif

//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystem(
  HWND    hwndParent,          
  DWORD   dwfOptions,         
  LPBOOL  lpfNeedsRestart);  


//*******************************************************************
//
//  FUNCTION:   InetConfigSystemFromPath
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags and from the given [ath.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//              lpszSourcePath - full path of location of files to install.  If
//              this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigSystemFromPathA(
  HWND    hwndParent,
  DWORD   dwfOptions,
  LPBOOL  lpfNeedsRestart,
  LPCSTR  lpszSourcePath);

HRESULT WINAPI InetConfigSystemFromPathW(
  HWND    hwndParent,
  DWORD   dwfOptions,
  LPBOOL  lpfNeedsRestart,
  LPCWSTR lpszSourcePath);

#ifdef UNICODE
#define InetConfigSystemFromPath  InetConfigSystemFromPathW
#else
#define InetConfigSystemFromPath  InetConfigSystemFromPathA
#endif

//*******************************************************************
//
//  FUNCTION:   InetConfigClient
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install Internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetConfigClientA(
  HWND              hwndParent,         
  LPCSTR            lpszPhonebook,
  LPCSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,         
  LPCSTR            lpszUsername,       
  LPCSTR            lpszPassword,       
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpINetClientInfo,   
  DWORD             dwfOptions,                     
  LPBOOL            lpfNeedsRestart);              

HRESULT WINAPI InetConfigClientW(
  HWND              hwndParent,         
  LPCWSTR           lpszPhonebook,
  LPCWSTR           lpszEntryName,
  LPRASENTRY        lpRasEntry,         
  LPCWSTR           lpszUsername,       
  LPCWSTR           lpszPassword,       
  LPCWSTR           lpszProfileName,
  LPINETCLIENTINFOW lpINetClientInfo,   
  DWORD             dwfOptions,                     
  LPBOOL            lpfNeedsRestart);              

#ifdef UNICODE
#define InetConfigClient    InetConfigClientW
#else
#define InetConfigClient    InetConfigClientA
#endif

//*******************************************************************
//
//  FUNCTION:   InetGetAutodial
//
//  PURPOSE:    This function will get the autodial settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if autodial
//              is enabled
//              lpszEntryName - on return, this buffer will contain the 
//              name of the phone book entry that is set for autodial
//              cbEntryNameSize - size of buffer for phone book entry name
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetGetAutodialA(
  LPBOOL  lpfEnable,     
  LPSTR   lpszEntryName,  
  DWORD   cbEntryNameSize);

HRESULT WINAPI InetGetAutodialW(
  LPBOOL  lpfEnable,     
  LPWSTR  lpszEntryName,  
  DWORD   cbEntryNameSize);

#ifdef UNICODE
#define InetGetAutodial   InetGetAutodialW
#else
#define InetGetAutodial   InetGetAutodialA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetAutodialA(
  BOOL    fEnable,       
  LPCSTR  lpszEntryName); 

HRESULT WINAPI   InetSetAutodialW(
  BOOL    fEnable,       
  LPCWSTR lpszEntryName); 

#ifdef UNICODE
#define InetSetAutodial    InetSetAutodialW
#else
#define InetSetAutodial    InetSetAutodialA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetAutoProxy
//
//  PURPOSE:    This function will set the auto config proxy settings
//              in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              dwProxyDetectMode - value to be update in the
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoProxyDetectMode
//              lpszScriptAddr - value to be update in 
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoConfigURL
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetAutoProxyA(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCSTR  lpszScriptAddr);

HRESULT WINAPI   InetSetAutoProxyW(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCWSTR lpszScriptAddr);

#ifdef UNICODE
#define InetSetAutoProxy   InetSetAutoProxyW
#else
#define InetSetAutoProxy   InetSetAutoProxyA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetProxy
//
//  PURPOSE:    This function is currently replaced by InetSetProxyEx
//              due to a change in Wininet API. It will return 
//              ERROR_SUCCESS.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    ERROR_SUCCESS
//
//*******************************************************************

HRESULT WINAPI   InetSetProxyA(
  BOOL    fEnable,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride);

HRESULT WINAPI   InetSetProxyW(
  BOOL    fEnable,
  LPCWSTR lpszServer,
  LPCWSTR lpszOverride);

#ifdef UNICODE
#define InetSetProxy   InetSetProxyW
#else
#define InetSetProxy   InetSetProxyA
#endif

//*******************************************************************
//
//  FUNCTION:   InetSetProxyEx
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//                        If set to FALSE, proxy will be disabled.
//              lpszConnectoidName - Name of connectoid to set proxy on
//                                   NULL for LAN
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetSetProxyExA(
  BOOL    fEnable,
  LPCSTR  lpszConnectoidName,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride);

HRESULT WINAPI   InetSetProxyExW(
  BOOL    fEnable,
  LPCWSTR lpszConnectoidName,
  LPCWSTR lpszServer,
  LPCWSTR lpszOverride);

#ifdef UNICODE
#define InetSetProxyEx   InetSetProxyExW
#else
#define InetSetProxyEx   InetSetProxyExA
#endif

//*******************************************************************
//
//  FUNCTION:   InetGetProxy
//
//  PURPOSE:    This function will get the proxy settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if proxy
//              is enabled
//              lpszServer - on return, this buffer will contain the 
//              name of the proxy server
//              cbServer - size of buffer for proxy server name
//              lpszOverride - on return, this buffer will contain the 
//              name of the proxy server
//              cbOverride - size of buffer for proxy override
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI   InetGetProxyA(
  LPBOOL  lpfEnable,
  LPSTR   lpszServer,
  DWORD   cbServer,
  LPSTR   lpszOverride,
  DWORD   cbszOverride);

HRESULT WINAPI   InetGetProxyW(
  LPBOOL  lpfEnable,
  LPWSTR  lpszServer,
  DWORD   cbServer,
  LPWSTR  lpszOverride,
  DWORD   cbszOverride);

#ifdef UNICODE
#define InetGetProxy    InetGetProxyW
#else
#define InetGetProxy    InetGetProxyA
#endif

//*******************************************************************
//
//  FUNCTION:   InetStartServices
//
//  PURPOSE:    This function guarentees that RAS services are running
//
//  PARAMETERS: none
//
//  RETURNS     ERROR_SUCCESS - if the services are enabled and running
//
//*******************************************************************
HRESULT WINAPI  InetStartServices();

//*******************************************************************
//
//  Function:   IsSmartStart
//
//  Synopsis:   This function will determine if the ICW should be run.  The
//              decision is made based on the current state of the user's machine.
//              
//  Arguments:  none
//
//  Returns:    TRUE - run ICW; FALSE - quit now
//
//  History:    5/8/97  ChrisK  Created
//
//*******************************************************************
DWORD WINAPI IsSmartStart();

//*******************************************************************
//
//  FUNCTION:   SetAutoProxyConnectoid
//
//  PURPOSE:    This function will set the enable/disable auto
//              proxy settings in creating connectoid.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//
//*******************************************************************

HRESULT WINAPI SetAutoProxyConnectoid( BOOL bEnable);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_INETCFG_H_#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\occimpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _AFX_NO_OCC_SUPPORT

#include "olebind.h"
#include "ocdbid.h"
#include "ocdb.h"

class CDataSourceControl;
class CDataBoundProperty;

// CCmdTarget
    class COleControlContainer;
    class COleControlSite;

class COccManager;
struct _AFX_OCC_DIALOG_INFO;

#define DISPID_DATASOURCE   0x80010001
#define DISPID_DATAFIELD    0x80010002


/////////////////////////////////////////////////////////////////////////////
// OLE Databinding support class for data sources

class CDataSourceControl
{
private:
    CDataSourceControl() {};
public:
    struct METAROWTYPE
    {
        DBCOLUMNID idColumnID;
        DWORD dwColumnID;
        LPSTR lpstrName;
        DWORD dwName;
        CPtrList* m_pClientList;
    };

    CDataSourceControl(COleControlSite *pClientSite);
    ~CDataSourceControl();
    HRESULT Initialize();
    virtual ICursor* GetCursor();
    HRESULT GetMetaData();
    virtual void BindProp(COleControlSite* pClientSite, BOOL bBind = TRUE);
    virtual void BindProp(CDataBoundProperty* pProperty, BOOL bBind = TRUE);
    virtual void BindColumns();
    BOOL CopyColumnID(DBCOLUMNID* pcidDst, DBCOLUMNID const *pcidSrc);
    HRESULT GetBoundClientRow();
    virtual HRESULT UpdateControls();
    virtual HRESULT UpdateCursor();

    COleControlSite *m_pClientSite;  // Back ptr to containing site
    ICursorMove* m_pCursorMove;
    ICursorUpdateARow* m_pCursorUpdateARow;
    int m_nColumns;
    METAROWTYPE* m_pMetaRowData;
    CPtrList m_CursorBoundProps;
    void* m_pVarData;
    int m_nBindings;
    DBCOLUMNBINDING *m_pColumnBindings;
    VARIANT* m_pValues;
    BOOL m_bUpdateInProgress;
};

/////////////////////////////////////////////////////////////////////////////
// OLE Databinding support class for bound controls

class CDataBoundProperty
{
protected:
    CDataBoundProperty() {};
public:
    CDataBoundProperty(CDataBoundProperty* pLast, DISPID dispid, WORD ctlid);
    ~CDataBoundProperty() {};
    void SetClientSite(COleControlSite *pClientSite);
    void SetDSCSite(COleControlSite *pDSCSite);
    void RemoveSource();
    void Notify();
    ICursor* GetCursor();
    CDataBoundProperty* GetNext();

    COleControlSite *m_pClientSite;  // Back ptr to containing site
    WORD m_ctlid;
    DISPID m_dispid;
    COleControlSite *m_pDSCSite;
    BOOL m_bOwnXferOut;
    BOOL m_bIsDirty;
    CDataBoundProperty* m_pNext;
};

/////////////////////////////////////////////////////////////////////////////
// Control containment helper functions

DLGTEMPLATE* _AfxSplitDialogTemplate(const DLGTEMPLATE* pTemplate,
    CMapWordToPtr* pOleItemMap);

void _AfxZOrderOleControls(CWnd* pWnd, CMapWordToPtr* pOleItemMap);

/////////////////////////////////////////////////////////////////////////////
// COleControlContainer - implementation class

class COleControlContainer : public CCmdTarget
{
public:
// Constructors/destructors
    COleControlContainer(CWnd*  pWnd);
    virtual ~COleControlContainer();

// Operations
    BOOL CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
        LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
        CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL,
        COleControlSite** ppNewSite=NULL);
    virtual COleControlSite* FindItem(UINT nID) const;
    virtual BOOL GetAmbientProp(COleControlSite* pSite, DISPID dispid,
        VARIANT* pvarResult);
    void CreateOleFont(CFont* pFont);
    void FreezeAllEvents(BOOL bFreeze);
    virtual void ScrollChildren(int dx, int dy);
    virtual void OnUIActivate(COleControlSite* pSite);
    virtual void OnUIDeactivate(COleControlSite* pSite);

    virtual void CheckDlgButton(int nIDButton, UINT nCheck);
    virtual void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
        int nIDCheckButton);
    virtual CWnd* GetDlgItem(int nID) const;
    virtual void GetDlgItem(int nID, HWND* phWnd) const;
    virtual UINT GetDlgItemInt(int nID, BOOL* lpTrans, BOOL bSigned) const;
    virtual int GetDlgItemText(int nID, LPTSTR lpStr, int nMaxCount) const;
    virtual LRESULT SendDlgItemMessage(int nID, UINT message, WPARAM wParam,
        LPARAM lParam);
    virtual void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned);
    virtual void SetDlgItemText(int nID, LPCTSTR lpszString);
    virtual UINT IsDlgButtonChecked(int nIDButton) const;

// Attributes
    CWnd* m_pWnd;
    CMapPtrToPtr m_siteMap;
    COLORREF m_crBack;
    COLORREF m_crFore;
    LPFONTDISP m_pOleFont;
    COleControlSite* m_pSiteUIActive;

public:
    // Interface maps
    BEGIN_INTERFACE_PART(OleIPFrame, IOleInPlaceFrame)
        INIT_INTERFACE_PART(COleControlContainer, OleIPFrame)
        STDMETHOD(GetWindow)(HWND*);
        STDMETHOD(ContextSensitiveHelp)(BOOL);
        STDMETHOD(GetBorder)(LPRECT);
        STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS);
        STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS);
        STDMETHOD(SetActiveObject)(LPOLEINPLACEACTIVEOBJECT, LPCOLESTR);
        STDMETHOD(InsertMenus)(HMENU, LPOLEMENUGROUPWIDTHS);
        STDMETHOD(SetMenu)(HMENU, HOLEMENU, HWND);
        STDMETHOD(RemoveMenus)(HMENU);
        STDMETHOD(SetStatusText)(LPCOLESTR);
        STDMETHOD(EnableModeless)(BOOL);
        STDMETHOD(TranslateAccelerator)(LPMSG, WORD);
    END_INTERFACE_PART(OleIPFrame)

    BEGIN_INTERFACE_PART(OleContainer, IOleContainer)
        INIT_INTERFACE_PART(COleControlContainer, OleContainer)
        STDMETHOD(ParseDisplayName)(LPBINDCTX, LPOLESTR, ULONG*, LPMONIKER*);
        STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN*);
        STDMETHOD(LockContainer)(BOOL);
    END_INTERFACE_PART(OleContainer)

    DECLARE_INTERFACE_MAP()
    DECLARE_DISPATCH_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// COleControlSite - implementation class

class COleControlSite : public CCmdTarget
{
public:
// Constructors/destructors
    COleControlSite(COleControlContainer* pCtrlCont);
    ~COleControlSite();

// Operations
    HRESULT CreateControl(CWnd* pWndCtrl, REFCLSID clsid,
        LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, UINT nID,
        CFile* pPersist=NULL, BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);
    virtual BOOL DestroyControl();
    UINT GetID();
    BOOL GetEventIID(IID* piid);
    virtual HRESULT DoVerb(LONG nVerb, LPMSG lpMsg = NULL);
    BOOL IsDefaultButton();
    DWORD GetDefBtnCode();
    void SetDefaultButton(BOOL bDefault);
    void GetControlInfo();
    BOOL IsMatchingMnemonic(LPMSG lpMsg);
    void SendMnemonic(LPMSG lpMsg);
    void FreezeEvents(BOOL bFreeze);

    virtual void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
        void* pvRet, const BYTE* pbParamInfo, va_list argList);
    virtual void SetPropertyV(DISPID dwDispID, VARTYPE vtProp,
        va_list argList);
    virtual void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
        void* pvRet, const BYTE* pbParamInfo, ...);
    virtual void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
    virtual void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
    virtual BOOL AFX_CDECL SafeSetProperty(DISPID dwDispID, VARTYPE vtProp, ...);

    virtual DWORD GetStyle() const;
    virtual DWORD GetExStyle() const;
    virtual BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
    virtual BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags);
    virtual void SetWindowText(LPCTSTR lpszString);
    virtual void GetWindowText(CString& str) const;
    virtual int GetWindowText(LPTSTR lpszStringBuf, int nMaxCount) const;
    virtual int GetWindowTextLength() const;
    virtual int GetDlgCtrlID() const;
    virtual int SetDlgCtrlID(int nID);
    virtual void MoveWindow(int x, int y, int nWidth, int nHeight,
        BOOL bRepaint);
    virtual BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
        int cx, int cy, UINT nFlags);
    virtual BOOL ShowWindow(int nCmdShow);
    virtual BOOL IsWindowEnabled() const;
    virtual BOOL EnableWindow(BOOL bEnable);
    virtual CWnd* SetFocus();
    virtual void EnableDSC();
    virtual void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
    virtual void BindProperty(DISPID dwDispId, CWnd* pWndDSC);

// Overridables
    virtual BOOL QuickActivate();

// Attributes
    COleControlContainer* m_pCtrlCont;
    HWND m_hWnd;
    CWnd* m_pWndCtrl;
    UINT m_nID;
    CRect m_rect;
    IID m_iidEvents;
    LPOLEOBJECT m_pObject;
    LPOLEINPLACEOBJECT m_pInPlaceObject;
    LPOLEINPLACEACTIVEOBJECT m_pActiveObject;
    COleDispatchDriver m_dispDriver;
    DWORD m_dwEventSink;
    DWORD m_dwPropNotifySink;
    DWORD m_dwStyleMask;
    DWORD m_dwStyle;
    DWORD m_dwMiscStatus;
    CONTROLINFO m_ctlInfo;

    // Databound control stuff
    DWORD m_dwNotifyDBEvents; // INotifyDBEvents sink cookie
    CDataSourceControl* m_pDataSourceControl;
    CDataBoundProperty* m_pBindings;
    union {
        COleControlSite *m_pDSCSite;
        WORD m_ctlidRowSource;
    };
    DISPID m_defdispid;
    UINT m_dwType;
    CString m_strDataField;
    BOOL m_bIgnoreNotify;
    BOOL m_bIsDirty;
    VARIANT m_varResult;

protected:
// Implementation
    BOOL SetExtent();
    HRESULT CreateOrLoad(REFCLSID clsid, CFile* pPersist, BOOL bStorage,
        BSTR bstrLicKey);
    DWORD ConnectSink(REFIID iid, LPUNKNOWN punkSink);
    void DisconnectSink(REFIID iid, DWORD dwCookie);
    void AttachWindow();
    void DetachWindow();
    BOOL OnEvent(AFX_EVENT* pEvent);
    HRESULT GetCursor(DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut);

public:
// Interface maps
    BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
        INIT_INTERFACE_PART(COleControlSite, OleClientSite)
        STDMETHOD(SaveObject)();
        STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
        STDMETHOD(GetContainer)(LPOLECONTAINER*);
        STDMETHOD(ShowObject)();
        STDMETHOD(OnShowWindow)(BOOL);
        STDMETHOD(RequestNewObjectLayout)();
    END_INTERFACE_PART(OleClientSite)

    BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSite)
        INIT_INTERFACE_PART(COleControlSite, OleIPSite)
        STDMETHOD(GetWindow)(HWND*);
        STDMETHOD(ContextSensitiveHelp)(BOOL);
        STDMETHOD(CanInPlaceActivate)();
        STDMETHOD(OnInPlaceActivate)();
        STDMETHOD(OnUIActivate)();
        STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
            LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
        STDMETHOD(Scroll)(SIZE);
        STDMETHOD(OnUIDeactivate)(BOOL);
        STDMETHOD(OnInPlaceDeactivate)();
        STDMETHOD(DiscardUndoState)();
        STDMETHOD(DeactivateAndUndo)();
        STDMETHOD(OnPosRectChange)(LPCRECT);
    END_INTERFACE_PART(OleIPSite)

    BEGIN_INTERFACE_PART(OleControlSite, IOleControlSite)
        INIT_INTERFACE_PART(COleControlSite, OleControlSite)
        STDMETHOD(OnControlInfoChanged)();
        STDMETHOD(LockInPlaceActive)(BOOL fLock);
        STDMETHOD(GetExtendedControl)(LPDISPATCH* ppDisp);
        STDMETHOD(TransformCoords)(POINTL* lpptlHimetric,
            POINTF* lpptfContainer, DWORD flags);
        STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, DWORD grfModifiers);
        STDMETHOD(OnFocus)(BOOL fGotFocus);
        STDMETHOD(ShowPropertyFrame)();
    END_INTERFACE_PART(OleControlSite)

    BEGIN_INTERFACE_PART(AmbientProps, IDispatch)
        INIT_INTERFACE_PART(COleControlSite, AmbientProps)
        STDMETHOD(GetTypeInfoCount)(unsigned int*);
        STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
        STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, unsigned int, LCID, DISPID*);
        STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
                          VARIANT*, EXCEPINFO*, unsigned int*);
    END_INTERFACE_PART(AmbientProps)

    BEGIN_INTERFACE_PART(PropertyNotifySink, IPropertyNotifySink)
        INIT_INTERFACE_PART(COleControlSite, PropertyNotifySink)
        STDMETHOD(OnChanged)(DISPID dispid);
        STDMETHOD(OnRequestEdit)(DISPID dispid);
    END_INTERFACE_PART(PropertyNotifySink)

    BEGIN_INTERFACE_PART(EventSink, IDispatch)
        INIT_INTERFACE_PART(COleControlSite, EventSink)
        STDMETHOD(GetTypeInfoCount)(unsigned int*);
        STDMETHOD(GetTypeInfo)(unsigned int, LCID, ITypeInfo**);
        STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, unsigned int, LCID, DISPID*);
        STDMETHOD(Invoke)(DISPID, REFIID, LCID, unsigned short, DISPPARAMS*,
                          VARIANT*, EXCEPINFO*, unsigned int*);
    END_INTERFACE_PART(EventSink)

    BEGIN_INTERFACE_PART(BoundObjectSite, IBoundObjectSite)
        STDMETHOD(GetCursor)(DISPID dispid, LPLPCURSOR ppcursorOut, LPVOID *ppcidOut);
    END_INTERFACE_PART(BoundObjectSite)

    BEGIN_INTERFACE_PART(NotifyDBEvents, INotifyDBEvents)
        STDMETHOD(OKToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(Cancelled)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(SyncBefore)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(AboutToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(FailedToDo)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(SyncAfter)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);
        STDMETHOD(DidEvent)(DWORD dwEventWhat, ULONG cReasons, DBNOTIFYREASON rgReasons[]);

        // Not part of i/f - just a helper
        HRESULT FireEvent(DWORD dwEventWhat, ULONG cReasons,
            DBNOTIFYREASON rgReasons[], DSCSTATE nState);
    END_INTERFACE_PART(NotifyDBEvents)

    DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// OLE control container manager

class COccManager : public CNoTrackObject
{
// Operations
public:
    // Event handling
    virtual BOOL OnEvent(CCmdTarget* pCmdTarget, UINT idCtrl, AFX_EVENT* pEvent,
        AFX_CMDHANDLERINFO* pHandlerInfo);

    // Internal object creation
    virtual COleControlContainer* CreateContainer(CWnd* pWnd);
    virtual COleControlSite* CreateSite(COleControlContainer* pCtrlCont);

    // Dialog creation
    virtual const DLGTEMPLATE* PreCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo,
        const DLGTEMPLATE* pOrigTemplate);
    virtual void PostCreateDialog(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
    virtual DLGTEMPLATE* SplitDialogTemplate(const DLGTEMPLATE* pTemplate,
        DLGITEMTEMPLATE** ppOleDlgItems);
    virtual BOOL CreateDlgControls(CWnd* pWndParent, LPCTSTR lpszResourceName,
        _AFX_OCC_DIALOG_INFO* pOccDialogInfo);
    virtual BOOL CreateDlgControls(CWnd* pWndParent, void* lpResource,
        _AFX_OCC_DIALOG_INFO* pOccDialogInfo);

    // Dialog manager
    virtual BOOL IsDialogMessage(CWnd* pWndDlg, LPMSG lpMsg);
    static BOOL AFX_CDECL IsLabelControl(CWnd* pWnd);
    static BOOL AFX_CDECL IsMatchingMnemonic(CWnd* pWnd, LPMSG lpMsg);
    static void AFX_CDECL SetDefaultButton(CWnd* pWnd, BOOL bDefault);
    static DWORD AFX_CDECL GetDefBtnCode(CWnd* pWnd);

// Implementation
protected:
    // Dialog creation
    HWND CreateDlgControl(CWnd* pWndParent, HWND hwAfter, BOOL bDialogEx,
        LPDLGITEMTEMPLATE pDlgItem, WORD nMsg, BYTE* lpData, DWORD cb);

    // Databinding
    void BindControls(CWnd* pWndParent);

    // Dialog manager
    static void AFX_CDECL UIActivateControl(CWnd* pWndNewFocus);
    static void AFX_CDECL UIDeactivateIfNecessary(CWnd* pWndOldFocus, CWnd* pWndNewFocus);
};

struct _AFX_OCC_DIALOG_INFO
{
    DLGTEMPLATE* m_pNewTemplate;
    DLGITEMTEMPLATE** m_ppOleDlgItems;
};

#endif // !_AFX_NO_OCC_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\ocdb.h ===
/*=--------------------------------------------------------------------------=
 * ocdb.h
 *=--------------------------------------------------------------------------=
 * defines the interfaces and constants for use with the OLE Controls Data
 * binding interfaces.
 *
 * Copyright (c) 1994-1997 Microsoft Corporation, All Rights Reserved.
 *
 *
 *
 */
#ifndef __OCDB_H_

#undef Delete
#ifdef __cplusplus
extern "C" {
#endif

/* LPDBSTRs are MultiByte in 16bits, and Unicode in 32bits.
 */
#if defined(_WIN32) && !defined(OLE2ANSI)

#define LPDBSTR           LPWSTR
#define DBCHAR            WCHAR
#define ldbstrlen(str)    wcslen(str)
#define ldbstrcpy(a, b)   wcscpy((a), (b))
#define ldbstrcpyn(a,b,n) wcsncpy((a), (b), (n))
#define ldbstrcmp(a, b)   wcscmp((a), (b))
#define ldbstrcat(a, b)   wcscat((a), (b))
#define ldbstrcmpi(a,b)   wcsicmp((a),(b))
#define DBTEXT(quote)     L##quote

#else

#define LPDBSTR           LPSTR
#define DBCHAR            char
#define ldbstrlen(str)    lstrlen(str)
#define ldbstrcpy(a, b)   lstrcpy((a), (b))
#define ldbstrcpyn(a,b,n) lstrcpyn((a), (b), (n))
#define ldbstrcmp(a, b)   lstrcmp((a), (b))
#define ldbstrcat(a, b)   lstrcat((a), (b))
#define ldbstrcmpi(a,b)   lstrcmpi((a),(b))
#define DBTEXT(quote)     quote

#endif /* _WIN32 && !OLE2ANSI */

typedef LPDBSTR FAR *  LPLPDBSTR;


/* Many systems don't have BLOBs defined.
 */
#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED

typedef struct tagBLOB {

    ULONG cbSize;
    BYTE *pBlobData;

} BLOB, *LPBLOB;

#endif

/*----------------------------------------------------------------------------
 *
 *  dbvar.h
 *
 *----------------------------------------------------------------------------
 */
#ifndef _DBCOLUMNID_DEFINED
#define _DBCOLUMNID_DEFINED
typedef enum tagDBCOLKIND
  {
    DBCOLKIND_GUID_NAME = 0,
    DBCOLKIND_GUID_NUMBER = 1,
        DBCOLKIND_NAME = 2
  }
DBCOLKIND;

#define GUID_NAMEONLY   {0x88c8d398,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}
#define GUID_NUMBERONLY {0x88c8d399,0x863c,0x101b,{0xac,0x3b,0x00,0xaa,0x00,0x44,0x77,0x3d}}

typedef struct tagDBCOLUMNID
  {
  GUID guid;
  DBCOLKIND dwKind;
union
    {
    LONG lNumber;
    LPDBSTR lpdbsz;
    }
  ;
  }
DBCOLUMNID;
#endif   /* ndef _COLUMNID_DEFINED */

#ifndef _DBVARENUM_DEFINED
#define _DBVARENUM_DEFINED
enum DBVARENUM
  {
    DBTYPE_EMPTY = 0,
    DBTYPE_NULL = 1,
    DBTYPE_I2 = 2,
    DBTYPE_I4 = 3,
    DBTYPE_R4 = 4,
    DBTYPE_R8 = 5,
    DBTYPE_CY = 6,
    DBTYPE_DATE = 7,
    DBTYPE_BOOL = 11,
    DBTYPE_UI2 = 18,
    DBTYPE_UI4 = 19,
        DBTYPE_I8 = 20,
        DBTYPE_UI8 = 21,
    DBTYPE_HRESULT = 25,
    DBTYPE_LPSTR = 30,
    DBTYPE_LPWSTR = 31,
    DBTYPE_FILETIME = 64,
    DBTYPE_BLOB = 65,
    DBTYPE_UUID = 72,
    DBTYPE_DBEXPR = 503,
    DBTYPE_COLUMNID = 507,
    DBTYPE_BYTES = 508,
    DBTYPE_CHARS = 509,
    DBTYPE_WCHARS = 510,
    DBTYPE_ANYVARIANT = 511
  }
;
#endif   /* ndef _DBVARENUM_DEFINED */

#define DBTYPE_EXT      0x100
#define DBTYPE_VECTOR   0x1000

typedef struct tagDBVARIANT DBVARIANT;

struct FARSTRUCT tagDBVARIANT{
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
      unsigned char bVal;        /* VT_UI1               */
      short    iVal;             /* VT_I2                */
      long     lVal;             /* VT_I4                */
      float    fltVal;           /* VT_R4                */
      double       dblVal;           /* VT_R8                */
      VARIANT_BOOL xbool;             /* VT_BOOL              */
      SCODE    scode;            /* VT_ERROR             */
      CY       cyVal;            /* VT_CY                */
      DATE     date;             /* VT_DATE              */
      BSTR     bstrVal;          /* VT_BSTR              */
      IUnknown     FAR* punkVal;     /* VT_UNKNOWN           */
      IDispatch    FAR* pdispVal;    /* VT_DISPATCH          */
      SAFEARRAY    FAR* parray;      /* VT_ARRAY|*           */

      unsigned char FAR *pbVal;      /* VT_BYREF|VT_UI1      */
      short    FAR* piVal;       /* VT_BYREF|VT_I2       */
      long     FAR* plVal;       /* VT_BYREF|VT_I4       */
      float    FAR* pfltVal;     /* VT_BYREF|VT_R4       */
      double       FAR* pdblVal;     /* VT_BYREF|VT_R8       */
      VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
      SCODE    FAR* pscode;      /* VT_BYREF|VT_ERROR    */
      CY       FAR* pcyVal;      /* VT_BYREF|VT_CY       */
      DATE     FAR* pdate;       /* VT_BYREF|VT_DATE     */
      BSTR     FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
      IUnknown  FAR* FAR* ppunkVal;  /* VT_BYREF|VT_UNKNOWN  */
      IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
      VARIANT      FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

      void     FAR* byref;       /* Generic ByRef        */

      // types new to DBVARIANTs
      //
      BLOB         blob;             /* VT_BLOB              */
      DBCOLUMNID  *pColumnid;        /* DBTYPE_COLUMNID      */
      LPSTR        pszVal;           /* VT_LPSTR             */
#ifdef WIN32
      LPWSTR       pwszVal;          /* VT_LPWSTR            */
      LPWSTR FAR  *ppwszVal;         /* VT_LPWSTR|VT_BYREF   */
#endif /* WIN32 */
      BLOB FAR    *pblob;            /* VT_BYREF|VT_BLOB     */
      DBCOLUMNID **ppColumnid;       /* VT_BYREF|DBTYPE_COLID*/
      DBVARIANT   *pdbvarVal;        /* VT_BYREF|DBTYPE_VARIANT */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

/*----------------------------------------------------------------------------
 *
 *  dbs.h
 *
 *----------------------------------------------------------------------------
 */
typedef enum tagDBROWFETCH
  {
    DBROWFETCH_DEFAULT = 0,
    DBROWFETCH_CALLEEALLOCATES = 1,
    DBROWFETCH_FORCEREFRESH = 2
  }
DBROWFETCH;

typedef struct tagDBFETCHROWS
  {
  ULONG      cRowsRequested;
  DWORD      dwFlags;
  VOID HUGEP *pData;
  VOID HUGEP *pVarData;
  ULONG      cbVarData;
  ULONG      cRowsReturned;
  }
DBFETCHROWS;

#define DB_NOMAXLENGTH   (DWORD)0
#define DB_NOVALUE       (DWORD)0xFFFFFFFF
#define DB_NULL          (DWORD)0xFFFFFFFF
#define DB_EMPTY         (DWORD)0xFFFFFFFE
#define DB_USEENTRYID    (DWORD)0xFFFFFFFD
#define DB_CANTCOERCE    (DWORD)0xFFFFFFFC
#define DB_TRUNCATED     (DWORD)0xFFFFFFFB
#define DB_UNKNOWN       (DWORD)0xFFFFFFFA
#define DB_NOINFO        (DWORD)0xFFFFFFF9

typedef enum tagDBBINDING
  {
    DBBINDING_DEFAULT = 0,
    DBBINDING_VARIANT = 1,
    DBBINDING_ENTRYID = 2
  }
DBBINDING;

typedef enum tagDBBINDTYPE
  {
        DBBINDTYPE_DATA    = 0,
    DBBINDTYPE_ENTRYID = 1,
    DBBDINTYPE_EITHER  = 2,
    DBBINDTYPE_BOTH    = 3
  }
DBBINDTYPE;

typedef struct tagDBCOLUMNBINDING
  {
  DBCOLUMNID columnID;
  ULONG obData;
  ULONG cbMaxLen;
  ULONG obVarDataLen;
  ULONG obInfo;
  DWORD dwBinding;
  DWORD dwDataType;
  }
DBCOLUMNBINDING;

typedef struct tagDBBINDPARAMS
  {
  ULONG cbMaxLen;
  DWORD dwBinding;
  DWORD dwDataType;
  ULONG cbVarDataLen;
  DWORD dwInfo;
  void *pData;
  }
DBBINDPARAMS;

#define CID_NUMBER_INVALID            -1
#define CID_NUMBER_AUTOINCREMENT       0
#define CID_NUMBER_BASECOLUMNNAME      1
#define CID_NUMBER_BASENAME            2
#define CID_NUMBER_BINARYCOMPARABLE    3
#define CID_NUMBER_BINDTYPE            4
#define CID_NUMBER_CASESENSITIVE       5
#define CID_NUMBER_COLLATINGORDER      6
#define CID_NUMBER_COLUMNID            7
#define CID_NUMBER_CURSORCOLUMN        8
#define CID_NUMBER_DATACOLUMN          9
#define CID_NUMBER_DEFAULTVALUE        10
#define CID_NUMBER_ENTRYIDMAXLENGTH    11
#define CID_NUMBER_FIXED               12
#define CID_NUMBER_HASDEFAULT          13
#define CID_NUMBER_MAXLENGTH           14
#define CID_NUMBER_MULTIVALUED         15
#define CID_NUMBER_NAME                16
#define CID_NUMBER_NULLABLE            17
#define CID_NUMBER_PHYSICALSORT        18
#define CID_NUMBER_NUMBER              19
#define CID_NUMBER_ROWENTRYID          20
#define CID_NUMBER_SCALE               21
#define CID_NUMBER_SEARCHABLE          22
#define CID_NUMBER_TYPE                23
#define CID_NUMBER_UNIQUE              24
#define CID_NUMBER_UPDATABLE           25
#define CID_NUMBER_VERSION             26
#define CID_NUMBER_STATUS              27

/* c and C++ have different meanings for const.
 */
#ifdef __cplusplus
#define EXTERNAL_DEFN    extern const
#else
#define EXTERNAL_DEFN    const
#endif /* __cplusplus */



#define DBCIDGUID {0xfe284700L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS

EXTERNAL_DEFN DBCOLUMNID NEAR COLUMNID_INVALID         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, -1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_AUTOINCREMENT     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BASENAME          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BINDTYPE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CASESENSITIVE     = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLLATINGORDER    = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_COLUMNID          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 7};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_CURSORCOLUMN      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 8};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DATACOLUMN        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 9};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_DEFAULTVALUE      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 10};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH  = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 11};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_FIXED             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 12};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_HASDEFAULT        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 13};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MAXLENGTH         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 14};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_MULTIVALUED       = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 15};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NAME              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 16};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NULLABLE          = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 17};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_PHYSICALSORT      = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 18};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_NUMBER            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 19};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_ROWENTRYID        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 20};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SCALE             = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 21};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_SEARCHABLE        = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 22};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_TYPE              = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 23};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UNIQUE            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 24};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_UPDATABLE         = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 25};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_VERSION           = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 26};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_STATUS            = {DBCIDGUID, DBCOLKIND_GUID_NUMBER, 27};
#else
extern const DBCOLUMNID NEAR COLUMNID_INVALID;
extern const DBCOLUMNID NEAR COLUMN_AUTOINCREMENT;
extern const DBCOLUMNID NEAR COLUMN_BASECOLUMNNAME;
extern const DBCOLUMNID NEAR COLUMN_BASENAME;
extern const DBCOLUMNID NEAR COLUMN_BINARYCOMPARABLE;
extern const DBCOLUMNID NEAR COLUMN_BINDTYPE;
extern const DBCOLUMNID NEAR COLUMN_CASESENSITIVE;
extern const DBCOLUMNID NEAR COLUMN_COLLATINGORDER;
extern const DBCOLUMNID NEAR COLUMN_COLUMNID;
extern const DBCOLUMNID NEAR COLUMN_CURSORCOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DATACOLUMN;
extern const DBCOLUMNID NEAR COLUMN_DEFAULTVALUE;
extern const DBCOLUMNID NEAR COLUMN_ENTRYIDMAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_FIXED;
extern const DBCOLUMNID NEAR COLUMN_HASDEFAULT;
extern const DBCOLUMNID NEAR COLUMN_MAXLENGTH;
extern const DBCOLUMNID NEAR COLUMN_MULTIVALUED;
extern const DBCOLUMNID NEAR COLUMN_NAME;
extern const DBCOLUMNID NEAR COLUMN_NULLABLE;
extern const DBCOLUMNID NEAR COLUMN_PHYSICALSORT;
extern const DBCOLUMNID NEAR COLUMN_NUMBER;
extern const DBCOLUMNID NEAR COLUMN_ROWENTRYID;
extern const DBCOLUMNID NEAR COLUMN_SCALE;
extern const DBCOLUMNID NEAR COLUMN_SEARCHABLE;
extern const DBCOLUMNID NEAR COLUMN_TYPE;
extern const DBCOLUMNID NEAR COLUMN_UNIQUE;
extern const DBCOLUMNID NEAR COLUMN_UPDATABLE;
extern const DBCOLUMNID NEAR COLUMN_VERSION;
extern const DBCOLUMNID NEAR COLUMN_STATUS;
#endif

#define BMK_NUMBER_BMKTEMPORARY    0
#define BMK_NUMBER_BMKTEMPORARYREL 1
#define BMK_NUMBER_BMKCURSOR       2
#define BMK_NUMBER_BMKCURSORREL    3
#define BMK_NUMBER_BMKSESSION      4
#define BMK_NUMBER_BMKSESSIONREL   5
#define BMK_NUMBER_BMKPERSIST      6
#define BMK_NUMBER_BMKPERSISTREL   7


#define DBBMKGUID {0xf6304bb0L,0xd188,0x11cd,{0xad,0x48, 0x0,0xaa, 0x0,0x3c,0x9c,0xb6}}
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARY      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 0};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL   = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 1};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSOR         = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 2};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKCURSORREL      = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 3};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSION        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 4};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKSESSIONREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 5};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSIST        = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 6};
EXTERNAL_DEFN DBCOLUMNID NEAR COLUMN_BMKPERSISTREL     = {DBBMKGUID, DBCOLKIND_GUID_NUMBER, 7};
#else
extern const DBCOLUMNID NEAR COLUMN_BMKINVALID;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARY;
extern const DBCOLUMNID NEAR COLUMN_BMKTEMPORARYREL;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSOR;
extern const DBCOLUMNID NEAR COLUMN_BMKCURSORREL;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSION;
extern const DBCOLUMNID NEAR COLUMN_BMKSESSIONREL;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSIST;
extern const DBCOLUMNID NEAR COLUMN_BMKPERSISTREL;
#endif

#define DB_BMK_SIZE        sizeof(BYTE)
#ifdef DBINITCONSTANTS
EXTERNAL_DEFN BYTE NEAR DBBMK_INVALID   = 0x0;
EXTERNAL_DEFN BYTE NEAR DBBMK_CURRENT   = 0x1;
EXTERNAL_DEFN BYTE NEAR DBBMK_BEGINNING = 0x2;
EXTERNAL_DEFN BYTE NEAR DBBMK_END       = 0x3;
#else
extern const BYTE NEAR DBBMK_INVALID;
extern const BYTE NEAR DBBMK_CURRENT;
extern const BYTE NEAR DBBMK_BEGINNING;
extern const BYTE NEAR DBBMK_END;
#endif

typedef enum tagDBCOLUMNBINDOPTS
  {
    DBCOLUMNBINDOPTS_REPLACE = 0,
    DBCOLUMNBINDOPTS_ADD = 1
  }
DBCOLUMNBINDOPTS;

typedef enum tagDBUPDATELOCK
  {
    DBUPDATELOCK_PESSIMISTIC = 0,
    DBUPDATELOCK_OPTIMISTIC = 1
  }
DBUPDATELOCK;

typedef enum tagDBCOLUMNDATA
  {
    DBCOLUMNDATA_UNCHANGED = 0,
    DBCOLUMNDATA_CHANGED = 1,
        DBCOLUMNDATA_UNKNOWN = 2
  }
DBCOLUMNDATA;

typedef enum tagDBROWACTION
  {
    DBROWACTION_IGNORE = 0,
    DBROWACTION_UPDATE = 1,
    DBROWACTION_DELETE = 2,
    DBROWACTION_ADD = 3,
    DBROWACTION_LOCK = 4,
    DBROWACTION_UNLOCK = 5
  }
DBROWACTION;

typedef enum tagDBUPDATEABLE
  {
    DBUPDATEABLE_UPDATEABLE = 0,
    DBUPDATEABLE_NOTUPDATEABLE = 1,
    DBUPDATEABLE_UNKNOWN = 2
  }
DBUPDATEABLE;

typedef struct tagDBROWSTATUS
  {
  HRESULT hrStatus;
  BLOB Bookmark;
  }
DBROWSTATUS;

typedef enum tagDBEVENTWHATS
  {
    DBEVENT_CURRENT_ROW_CHANGED = 1,
    DBEVENT_CURRENT_ROW_DATA_CHANGED = 2,
    DBEVENT_NONCURRENT_ROW_DATA_CHANGED = 4,
    DBEVENT_SET_OF_COLUMNS_CHANGED = 8,
    DBEVENT_ORDER_OF_COLUMNS_CHANGED = 16,
    DBEVENT_SET_OF_ROWS_CHANGED = 32,
    DBEVENT_ORDER_OF_ROWS_CHANGED = 64,
    DBEVENT_METADATA_CHANGED = 128,
    DBEVENT_ASYNCH_OP_FINISHED = 256,
    DBEVENT_FIND_CRITERIA_CHANGED = 512,
  }
DBEVENTWHATS;

typedef enum tagDBREASON
  {
    DBREASON_DELETED = 1,
    DBREASON_INSERTED = 2,
    DBREASON_MODIFIED = 3,
    DBREASON_REMOVEDFROMCURSOR = 4,
    DBREASON_MOVEDINCURSOR = 5,
    DBREASON_MOVE = 6,
    DBREASON_FIND = 7,
    DBREASON_NEWINDEX = 8,
    DBREASON_ROWFIXUP = 9,
    DBREASON_RECALC = 10,
    DBREASON_REFRESH = 11,
    DBREASON_NEWPARAMETERS = 12,
    DBREASON_SORTCHANGED = 13,
    DBREASON_FILTERCHANGED = 14,
    DBREASON_QUERYSPECCHANGED = 15,
    DBREASON_SEEK = 16,
    DBREASON_PERCENT = 17,
    DBREASON_FINDCRITERIACHANGED = 18,
    DBREASON_SETRANGECHANGED = 19,
    DBREASON_ADDNEW = 20,
    DBREASON_MOVEPERCENT = 21,
    DBREASON_BEGINTRANSACT = 22,
    DBREASON_ROLLBACK = 23,
    DBREASON_COMMIT = 24,
    DBREASON_CLOSE = 25,
    DBREASON_BULK_ERROR = 26,
    DBREASON_BULK_NOTTRANSACTABLE = 27,
    DBREASON_BULK_ABOUTTOEXECUTE = 28,
    DBREASON_CANCELUPDATE = 29,
    DBREASON_SETCOLUMN = 30,
    DBREASON_EDIT = 31,
    DBREASON_UNLOAD = 32
  }
DBREASON;

// Arg1 values for DBREASON_FIND
typedef enum tagDBFINDTYPES
  {
  DB_FINDFIRST = 1,
  DB_FINDLAST = 2,
  DB_FINDNEXT = 3,
  DB_FINDPRIOR = 4,
  DB_FIND = 5
  }
DBFINDTYPES;

typedef struct tagDBNOTIFYREASON
  {
  DWORD dwReason;
  DBVARIANT arg1;
  DBVARIANT arg2;
  }
DBNOTIFYREASON;

#define DB_E_BADBINDINFO           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e00)
#define DB_E_BADBOOKMARK           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e01)
#define DB_E_BADCOLUMNID           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e02)
#define DB_E_BADCRITERIA           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e03)
#define DB_E_BADENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e04)
#define DB_E_BADFRACTION           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e05)
#define DB_E_BADINDEXID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e06)
#define DB_E_BADQUERYSPEC          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e07)
#define DB_E_BADSORTORDER          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e08)
#define DB_E_BADVALUES             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e09)
#define DB_E_CANTCOERCE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0a)
#define DB_E_CANTLOCK              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0b)
#define DB_E_COLUMNUNAVAILABLE     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0c)
#define DB_E_DATACHANGED           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0d)
#define DB_E_INVALIDCOLUMNORDINAL  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0e)
#define DB_E_INVALIDINTERFACE      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e0f)
#define DB_E_LOCKFAILED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e10)
#define DB_E_ROWDELETED            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e11)
#define DB_E_ROWTOOSHORT           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e12)
#define DB_E_SCHEMAVIOLATION       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e13)
#define DB_E_SEEKKINDNOTSUPPORTED  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e14)
#define DB_E_UPDATEINPROGRESS      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e15)
#define DB_E_USEENTRYID            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e16)
#define DB_E_STATEERROR            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e17)
#define DB_E_BADFETCHINFO          MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e18)
#define DB_E_NOASYNC               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e19)
#define DB_E_ENTRYIDOPEN           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1a)
#define DB_E_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0e1b)
#define DB_S_BUFFERTOOSMALL        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec0)
#define DB_S_CANCEL                MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec1)
#define DB_S_DATACHANGED           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec2)
#define DB_S_ENDOFCURSOR           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec3)
#define DB_S_ENDOFRESULTSET        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec4)
#define DB_S_OPERATIONCANCELLED    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec5)
#define DB_S_QUERYINTERFACE        MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec6)
#define DB_S_WORKINGASYNC          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec7)
//#define DB_S_COULDNTCOERCE         MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec8)
#define DB_S_MOVEDTOFIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ec9)
#define DB_S_CURRENTROWUNCHANGED   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0eca)
#define DB_S_ROWADDED              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecb)
#define DB_S_ROWUPDATED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecc)
#define DB_S_ROWDELETED            MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0ecd)

/*----------------------------------------------------------------------------
 *
 *  ICursor
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursor ICursor;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursor;

interface ICursor : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetColumnsCursor
    (
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetBindings
    (
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBindings
    (
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetNextRows
    (
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Requery
    (
        void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursor;

typedef struct ICursorVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursor FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursor FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursor FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursor FAR *this,
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursor FAR *this,
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursor FAR *this,
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursor FAR *this,
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursor FAR *this
    );

} ICursorVtbl;

interface ICursor
{
    ICursorVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursor_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursor_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursor_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursor_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursor_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursor_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursor_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursor_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorMove
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorMove ICursorMove;

typedef enum tagDBCLONEOPTS
  {
    DBCLONEOPTS_DEFAULT = 0,
    DBCLONEOPTS_SAMEROW = 1
  }
DBCLONEOPTS;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorMove;

interface ICursorMove : public ICursor
{
public:
    virtual HRESULT STDMETHODCALLTYPE Move
    (
    ULONG cbBookmark,
    void *pBookmark,
    LARGE_INTEGER dlOffset,
    DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetBookmark
    (
    DBCOLUMNID *pBookmarkType,
    ULONG cbMaxSize,
    ULONG *pcbBookmark,
    void *pBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Clone
    (
    DWORD dwFlags,
    REFIID riid,
    IUnknown **ppvClonedCursor
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorMove;

typedef struct ICursorMoveVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorMove FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorMove FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorMove FAR *this,
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorMove FAR *this,
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorMove FAR *this,
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorMove FAR *this,
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorMove FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorMove FAR *this,
    ULONG cbBookmark,
    void *pBookmark,
    LARGE_INTEGER dlOffset,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorMove FAR *this,
    DBCOLUMNID *pBookmarkType,
    ULONG cbMaxSize,
    ULONG *pcbBookmark,
    void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorMove FAR *this,
    DWORD dwFlags,
    REFIID riid,
    IUnknown **ppvClonedCursor
    );

} ICursorMoveVtbl;

interface ICursorMove
{
    ICursorMoveVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorMove_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorMove_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorMove_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorMove_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorMove_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorMove_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorMove_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorMove_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorMove_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorMove_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorMove_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorScroll
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorScroll ICursorScroll;

typedef enum tagDBCURSORPOPULATED
  {
    DBCURSORPOPULATED_FULLY = 0,
    DBCURSORPOPULATED_PARTIALLY = 1
  }
DBCURSORPOPULATED;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorScroll;

interface ICursorScroll : public ICursorMove
{
public:
    virtual HRESULT STDMETHODCALLTYPE Scroll
    (
    ULONG ulNumerator,
    ULONG ulDenominator,
    DBFETCHROWS *pFetchParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximatePosition
    (
    ULONG cbBookmark,
    void *pBookmark,
    ULONG *pulNumerator,
    ULONG *pulDenominator
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetApproximateCount
    (
    LARGE_INTEGER *pudlApproxCount,
    DWORD *pdwFullyPopulated
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorScroll;

typedef struct ICursorScrollVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorScroll FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorScroll FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumnsCursor)
    (
        ICursorScroll FAR *this,
    REFIID riid,
    IUnknown **ppvColumnsCursor,
    ULONG *pcRows
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetBindings)
    (
        ICursorScroll FAR *this,
    ULONG cCol,
    DBCOLUMNBINDING rgBoundColumns[],
    ULONG cbRowLength,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBindings)
    (
        ICursorScroll FAR *this,
    ULONG *pcCol,
    DBCOLUMNBINDING *prgBoundColumns[],
    ULONG *pcbRowLength
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetNextRows)
    (
        ICursorScroll FAR *this,
    LARGE_INTEGER udlRowsToSkip,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *Requery)
    (
        ICursorScroll FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Move)
    (
        ICursorScroll FAR *this,
    ULONG cbBookmark,
    void *pBookmark,
    LARGE_INTEGER dlOffset,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetBookmark)
    (
        ICursorScroll FAR *this,
    DBCOLUMNID *pBookmarkType,
    ULONG cbMaxSize,
    ULONG *pcbBookmark,
    void *pBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Clone)
    (
        ICursorScroll FAR *this,
    DWORD dwFlags,
    REFIID riid,
    IUnknown **ppvClonedCursor
    );

    HRESULT (STDMETHODCALLTYPE FAR *Scroll)
    (
        ICursorScroll FAR *this,
    ULONG ulNumerator,
    ULONG ulDenominator,
    DBFETCHROWS *pFetchParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximatePosition)
    (
        ICursorScroll FAR *this,
    ULONG cbBookmark,
    void *pBookmark,
    ULONG *pulNumerator,
    ULONG *pulDenominator
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetApproximateCount)
    (
        ICursorScroll FAR *this,
    LARGE_INTEGER *pudlApproxCount,
    DWORD *pdwFullyPopulated
    );

} ICursorScrollVtbl;

interface ICursorScroll
{
    ICursorScrollVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorScroll_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorScroll_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorScroll_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorScroll_GetColumnsCursor(pI, riid, ppvColumnsCursor, pcRows) \
    (*(pI)->lpVtbl->GetColumnsCursor)((pI), riid, ppvColumnsCursor, pcRows)

#define ICursorScroll_SetBindings(pI, cCol, rgBoundColumns, cbRowLength, dwFlags) \
    (*(pI)->lpVtbl->SetBindings)((pI), cCol, rgBoundColumns, cbRowLength, dwFlags)

#define ICursorScroll_GetBindings(pI, pcCol, prgBoundColumns, pcbRowLength) \
    (*(pI)->lpVtbl->GetBindings)((pI), pcCol, prgBoundColumns, pcbRowLength)

#define ICursorScroll_GetNextRows(pI, udlRowsToSkip, pFetchParams) \
    (*(pI)->lpVtbl->GetNextRows)((pI), udlRowsToSkip, pFetchParams)

#define ICursorScroll_Requery(pI) \
    (*(pI)->lpVtbl->Requery)((pI))

#define ICursorScroll_Move(pI, cbBookmark, pBookmark, dlOffset, pFetchParams) \
    (*(pI)->lpVtbl->Move)((pI), cbBookmark, pBookmark, dlOffset, pFetchParams)

#define ICursorScroll_GetBookmark(pI, pBookmarkType, cbMaxSize, pcbBookmark, pBookmark) \
    (*(pI)->lpVtbl->GetBookmark)((pI), pBookmarkType, cbMaxSize, pcbBookmark, pBookmark)

#define ICursorScroll_Clone(pI, dwFlags, riid, ppvClonedCursor) \
    (*(pI)->lpVtbl->Clone)((pI), dwFlags, riid, ppvClonedCursor)

#define ICursorScroll_Scroll(pI, ulNumerator, ulDenominator, pFetchParams) \
    (*(pI)->lpVtbl->Scroll)((pI), ulNumerator, ulDenominator, pFetchParams)

#define ICursorScroll_GetApproximatePosition(pI, cbBookmark, pBookmark, pulNumerator, pulDenominator) \
    (*(pI)->lpVtbl->GetApproximatePosition)((pI), cbBookmark, pBookmark, pulNumerator, pulDenominator)

#define ICursorScroll_GetApproximateCount(pI, pudlApproxCount, pdwFullyPopulated) \
    (*(pI)->lpVtbl->GetApproximateCount)((pI), pudlApproxCount, pdwFullyPopulated)
#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorUpdateARow
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorUpdateARow ICursorUpdateARow;

typedef enum tagDBEDITMODE
  {
    DBEDITMODE_NONE = 1,
    DBEDITMODE_UPDATE = 2,
    DBEDITMODE_ADD = 3
  }
DBEDITMODE;


#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorUpdateARow;

interface ICursorUpdateARow : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginUpdate
    (
    DWORD dwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetColumn
    (
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetColumn
    (
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams,
    DWORD *pdwFlags
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetEditMode
    (
    DWORD *pdwState
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Update
    (
    DBCOLUMNID *pBookmarkType,
    ULONG *pcbBookmark,
    void **ppBookmark
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancel
    (
        void
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Delete
    (
    void
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_ICursorUpdateARow;

typedef struct ICursorUpdateARowVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorUpdateARow FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorUpdateARow FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *BeginUpdate)
    (
        ICursorUpdateARow FAR *this,
    DWORD dwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *SetColumn)
    (
        ICursorUpdateARow FAR *this,
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetColumn)
    (
        ICursorUpdateARow FAR *this,
    DBCOLUMNID *pcid,
    DBBINDPARAMS *pBindParams,
    DWORD *pdwFlags
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetEditMode)
    (
        ICursorUpdateARow FAR *this,
    DWORD *pdwState
    );

    HRESULT (STDMETHODCALLTYPE FAR *Update)
    (
        ICursorUpdateARow FAR *this,
    DBCOLUMNID *pBookmarkType,
    ULONG *pcbBookmark,
    void **ppBookmark
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancel)
    (
        ICursorUpdateARow FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *Delete)
    (
        ICursorUpdateARow FAR *this
    );

} ICursorUpdateARowVtbl;

interface ICursorUpdateARow
{
    ICursorUpdateARowVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorUpdateARow_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorUpdateARow_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorUpdateARow_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorUpdateARow_BeginUpdate(pI, dwFlags) \
    (*(pI)->lpVtbl->BeginUpdate)((pI), dwFlags)

#define ICursorUpdateARow_SetColumn(pI, pcid, pBindParams) \
    (*(pI)->lpVtbl->SetColumn)((pI), pcid, pBindParams)

#define ICursorUpdateARow_GetColumn(pI, pcid, pBindParams, pdwFlags) \
    (*(pI)->lpVtbl->GetColumn)((pI), pcid, pBindParams, pdwFlags)

#define ICursorUpdateARow_GetEditMode(pI, pdwState) \
    (*(pI)->lpVtbl->GetEditMode)((pI), pdwState)

#define ICursorUpdateARow_Update(pI, pBookmarkType, pcbBookmark, ppBookmark) \
    (*(pI)->lpVtbl->Update)((pI), pBookmarkType, pcbBookmark, ppBookmark)

#define ICursorUpdateARow_Cancel(pI) \
    (*(pI)->lpVtbl->Cancel)((pI))

#define ICursorUpdateARow_Delete(pI) \
    (*(pI)->lpVtbl->Delete)((pI))


#endif /* COBJMACROS */

#endif

/*----------------------------------------------------------------------------
 *
 *  ICursorFind
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface ICursorFind ICursorFind;

typedef enum tagDBFINDFLAGS
  {
    DBFINDFLAGS_FINDNEXT = 1,
    DBFINDFLAGS_FINDPRIOR = 2,
    DBFINDFLAGS_INCLUDECURRENT = 4
  }
DBFINDFLAGS;


typedef enum tagDBSEEKFLAGS
  {
    DBSEEK_LT    = 1,
    DBSEEK_LE    = 2,
    DBSEEK_EQ    = 3,       // EXACT EQUALITY
    DBSEEK_GT    = 4,
    DBSEEK_GE    = 5,
    DBSEEK_PARTIALEQ = 6             // only for strings
  }
DBSEEKFLAGS;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_ICursorFind;

interface ICursorFind : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE FindByValues
    (
    ULONG            cbBookmark,
    LPVOID           pBookmark,
    DWORD            dwFindFlags,
    ULONG            cValues,
        DBCOLUMNID       rgColumns[],
    DBVARIANT        rgValues[],
    DWORD            rgdwSeekFlags[],
        DBFETCHROWS FAR *pFetchParams
    ) = 0;
};

#else

/* C Language Binding */
//extern const IID IID_ICursorFind;

typedef struct ICursorFindVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        ICursorFind FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        ICursorFind FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        ICursorFind FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *FindByValues)
    (
        ICursorFind FAR *this,
    ULONG            cbBookmark,
    LPVOID           pBookmark,
    DWORD            dwFindFlags,
    ULONG            cValues,
        DBCOLUMNID       rgColumns[],
    DBVARIANT        rgValues[],
    DWORD            rgdwSeekFlags[],
        DBFETCHROWS      pFetchParams
    );


} ICursorFindVtbl;

interface ICursorFind
{
    ICursorFindVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define ICursorFind_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define ICursorFind_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define ICursorFind_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define ICursorFind_FindByValues(pI, cbB, pB, dwFF, cV, rgC, rgV, rgSF, pF) \
    (*(pI)->lpVtbl->FindByValues)((pI), cbB, pB, dwFF, cB, rgC, rgV, rgSF, pF)

#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *  IEntryID
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface IEntryID IEntryID;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_IEntryID;

interface IEntryID : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInterface
    (
    ULONG cbEntryID,
    void *pEntryID,
        DWORD dwFlags,
        REFIID riid,
    IUnknown **ppvObj
    ) = 0;

};

#else

/* C Language Binding */
//extern const IID IID_IEntryID;

typedef struct IEntryIDVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        IEntryID FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        IEntryID FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        IEntryID FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *GetInterface)
    (
        IEntryID FAR *this,
    ULONG cbEntryID,
    void *pEntryID,
        REFIID riid,
    IUnknown **ppvObj
    );

} IEntryIDVtbl;

interface IEntryID
{
    IEntryIDVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define IEntryID_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define IEntryID_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define IEntryID_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define IEntryID_GetInterface(pI, cbEntryID, pEntryID, riid, ppvObj) \
    (*(pI)->lpVtbl->GetInterface)((pI), cbEntryID, pEntryID, riid, ppvObj)
#endif /* COBJMACROS */

#endif


/*----------------------------------------------------------------------------
 *
 *  INotifyDBEvents
 *
 *----------------------------------------------------------------------------
 */
/* Forward declaration */
//typedef interface INotifyDBEvents INotifyDBEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

/* C++ Language Binding */
//extern "C" const IID IID_INotifyDBEvents;

interface INotifyDBEvents : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE OKToDo
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Cancelled
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncBefore
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE AboutToDo
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE FailedToDo
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE SyncAfter
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

    virtual HRESULT STDMETHODCALLTYPE DidEvent
    (
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    ) = 0;

};

#else

/* C Language Binding */
extern const IID IID_INotifyDBEvents;

typedef struct INotifyDBEventsVtbl
{

    HRESULT (STDMETHODCALLTYPE FAR *QueryInterface)
    (
        INotifyDBEvents FAR *this,
    REFIID riid,
    void **ppvObject
    );

    ULONG (STDMETHODCALLTYPE FAR *AddRef)
    (
        INotifyDBEvents FAR *this
    );

    ULONG (STDMETHODCALLTYPE FAR *Release)
    (
        INotifyDBEvents FAR *this
    );

    HRESULT (STDMETHODCALLTYPE FAR *OKToDo)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *Cancelled)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncBefore)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *AboutToDo)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *FailedToDo)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *SyncAfter)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

    HRESULT (STDMETHODCALLTYPE FAR *DidEvent)
    (
        INotifyDBEvents FAR *this,
    DWORD dwEventWhat,
    ULONG cReasons,
    DBNOTIFYREASON rgReasons[]
    );

} INotifyDBEventsVtbl;

interface INotifyDBEvents
{
    INotifyDBEventsVtbl FAR *lpVtbl;
} ;

#ifdef COBJMACROS

#define INotifyDBEvents_QueryInterface(pI, riid, ppvObject) \
    (*(pI)->lpVtbl->QueryInterface)((pI), riid, ppvObject)

#define INotifyDBEvents_AddRef(pI) \
    (*(pI)->lpVtbl->AddRef)((pI))

#define INotifyDBEvents_Release(pI) \
    (*(pI)->lpVtbl->Release)((pI))

#define INotifyDBEvents_OKToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->OKToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_Cancelled(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->Cancelled)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncBefore(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncBefore)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_AboutToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->AboutToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_FailedToDo(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->FailedToDo)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_SyncAfter(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->SyncAfter)((pI), dwEventWhat, cReasons, rgReasons)

#define INotifyDBEvents_DidEvent(pI, dwEventWhat, cReasons, rgReasons) \
    (*(pI)->lpVtbl->DidEvent)((pI), dwEventWhat, cReasons, rgReasons)
#endif /* COBJMACROS */

#endif


#ifdef __cplusplus
}
#endif

#define __OCDB_H_
#endif // __OCDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\oharestr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//    OHARESTR.H - string defines for O'Hare components
//            
//

//    HISTORY:
//    
//    3/10/95        jeremys        Created.
//    1/10/98       DONALDM         Adapted to the GETCONN proj to be
//                                  be compatible with inetreg.h


#ifndef _OHARESTR_H_
#define _OHARESTR_H_

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_BKUPINTERNETPROFILE    TEXT("BackupInternetProfile")

// class name for window to receive Winsock activity messages
#define AUTODIAL_MONITOR_CLASS_NAME    TEXT("MS_AutodialMonitor")

#endif // _OHARESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\ocdbid.h ===
/*=--------------------------------------------------------------------------=
 * ocdbid.h
 *=--------------------------------------------------------------------------=
 * defines all the guids for OLE Controls Data Binding Interfaces interfaces.
 *
 * Copyright (c) 1994-1997 Microsoft Corporation, All Rights Reserved.
 *
 */

/* {9F6AA700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursor,
0x9f6aa700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {ACFF0690-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorMove,
0xacff0690, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {BB87E420-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorScroll,
0xbb87e420, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {D14216A0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorUpdateARow,
0xd14216a0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {DB526CC0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_INotifyDBEvents,
0xdb526cc0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E01D7850-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_ICursorFind,
0xe01d7850, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E4D19810-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(IID_IEntryID,
0xe4d19810, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {E8BF1170-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_GUID_NAMEONLY,
0xe8bf1170, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {F6304BB0-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBBMKGUID,
0xf6304bb0, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);

/* {FE284700-D188-11cd-AD48-00AA003C9CB6} */
DEFINE_GUID(_DBCIDGUID,
0xfe284700, 0xd188, 0x11cd, 0xad, 0x48, 0x0, 0xaa, 0x0, 0x3c, 0x9c, 0xb6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\olebind.h ===
/*****************************************************************************\
*                                                                             *
* olebind.h     Data binding interfaces for OLE                               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1994, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _OLEBIND_H_ )
#define _OLEBIND_H_

#if !defined( INITGUID )
#include <olectl.h>
#endif

DEFINE_GUID(IID_IBoundObject,
    0x9BFBBC00,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IBoundObjectSite,
    0x9BFBBC01,0xEFF1,0x101A,0x84,0xED,0x00,0xAA,0x00,0x34,0x1D,0x07);

typedef interface IBoundObject FAR* LPBOUNDOBJECT;
typedef interface IBoundObjectSite FAR* LPBOUNDOBJECTSITE;

typedef interface ICursor FAR* LPCURSOR;
typedef interface ICursor FAR* FAR* LPLPCURSOR;
typedef interface ICursorMove FAR* LPCURSORMOVE;
typedef interface ICursorScroll FAR* LPCURSORSCROLL;
typedef interface ICursorFind FAR* LPCURSORFIND;
typedef interface ICursorUpdateARow FAR* LPCURSORUPDATEAROW;

//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObject interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObject

DECLARE_INTERFACE_(IBoundObject, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObject methods
    //
    STDMETHOD(OnSourceChanged)(THIS_ DISPID dispid, BOOL fBound, BOOL FAR* lpfOwnXferOut) PURE;
    STDMETHOD(IsDirty)(THIS_ DISPID dispid) PURE;
};
//////////////////////////////////////////////////////////////////////////////
//
//  IBoundObjectSite interface
//
//////////////////////////////////////////////////////////////////////////////

#undef  INTERFACE
#define INTERFACE IBoundObjectSite

DECLARE_INTERFACE_(IBoundObjectSite, IUnknown)
{
    //
    //  IUnknown methods
    //
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //
    //  IBoundObjectSite methods
    //
    STDMETHOD(GetCursor)(THIS_ DISPID dispid, LPLPCURSOR ppCursor, LPVOID FAR* ppcidOut) PURE;
};


#endif // !defined( _OLEBIND_H_ )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY    ".text" // read only data, same as one generated by linker
#define DATASEG_PERINSTANCE "INSTDATA"    // per instance data
#define DATASEG_SHARED                  // default data goes here
#define CODESEG_INIT        ".text"

#define GetWindowInt        GetWindowLong
#define SetWindowInt        SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLong(hwnd, GCL_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLong(hwnd, GCL_HICON))


#ifdef WINNT

#else

typedef TBYTE TUCHAR;

#endif


#else  // !WIN32

typedef LPCSTR LPCTSTR;
typedef LPSTR  LPTSTR;
typedef const short far *LPCWSTR;
#define TEXT(x) (x)

#define ISLPTR(pv)          (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT        "_INIT"

#define GetWindowInt        GetWindowWord
#define SetWindowInt        SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\ras2.h ===
/* Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access external API
** Public header for external API clients
**
** WINVER values in this file:
**      WINVER < 0x400 = Windows NT 3.5, Windows NT 3.51
**      WINVER = 0x400 = Windows 95, Windows NT SUR (default)
**      WINVER > 0x400 = Windows NT SUR enhancements
*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef UNLEN
#include <lmcons.h>
#endif

#include <pshpack4.h>

/* Flags for RasConnectionNotification().
*/
#define RASCN_Connection        0x00000001
#define RASCN_Disconnection     0x00000002
#define RASCN_BandwidthAdded    0x00000004
#define RASCN_BandwidthRemoved  0x00000008

/* RASENTRY 'dwDialMode' values.
*/
#define RASEDM_DialAll                  1
#define RASEDM_DialAsNeeded             2

/* RASENTRY 'dwIdleDisconnectSeconds' constants.
*/
#define RASIDS_Disabled                 0xffffffff
#define RASIDS_UseGlobalValue           0

/* AutoDial DLL function parameter block.
*/
#define RASADPARAMS struct tagRASADPARAMS
RASADPARAMS
{
    DWORD       dwSize;
    HWND        hwndOwner;
    DWORD       dwFlags;
    LONG        xDlg;
    LONG        yDlg;
};

#define LPRASADPARAMS RASADPARAMS*

/* AutoDial DLL function parameter block 'dwFlags.'
*/
#define RASADFLG_PositionDlg            0x00000001

/* Prototype AutoDial DLL function.
*/
typedef BOOL (WINAPI *RASADFUNCA)( LPSTR, LPSTR, LPRASADPARAMS, LPDWORD );
typedef BOOL (WINAPI *RASADFUNCW)( LPWSTR, LPWSTR, LPRASADPARAMS, LPDWORD );

#ifdef UNICODE
#define RASADFUNC RASADFUNCW
#else
#define RASADFUNC RASADFUNCA
#endif

/* A RAS phone book multilinked sub-entry.
*/
#define RASSUBENTRYA struct tagRASSUBENTRYA
RASSUBENTRYA
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#define RASSUBENTRYW struct tagRASSUBENTRYW
RASSUBENTRYW
{
    DWORD       dwSize;
    DWORD       dwfFlags;
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // Phone numbers
    //
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
};

#ifdef UNICODE
#define RASSUBENTRY RASSUBENTRYW
#else
#define RASSUBENTRY RASSUBENTRYA
#endif

#define LPRASSUBENTRYW RASSUBENTRYW*
#define LPRASSUBENTRYA RASSUBENTRYA*
#define LPRASSUBENTRY  RASSUBENTRY*

/* Ras{Get,Set}Credentials structure.  These calls
** supercede Ras{Get,Set}EntryDialParams.
*/
#define RASCREDENTIALSA struct tagRASCREDENTIALSA
RASCREDENTIALSA
{
    DWORD dwSize;
    DWORD dwMask;
    CHAR szUserName[ UNLEN + 1 ];
    CHAR szPassword[ PWLEN + 1 ];
    CHAR szDomain[ DNLEN + 1 ];
};

#define RASCREDENTIALSW struct tagRASCREDENTIALSW
RASCREDENTIALSW
{
    DWORD dwSize;
    DWORD dwMask;
    WCHAR szUserName[ UNLEN + 1 ];
    WCHAR szPassword[ PWLEN + 1 ];
    WCHAR szDomain[ DNLEN + 1 ];
};

#ifdef UNICODE
#define RASCREDENTIALS RASCREDENTIALSW
#else
#define RASCREDENTIALS RASCREDENTIALSA
#endif

#define LPRASCREDENTIALSW RASCREDENTIALSW*
#define LPRASCREDENTIALSA RASCREDENTIALSA*
#define LPRASCREDENTIALS  RASCREDENTIALS*

/* RASCREDENTIALS 'dwMask' values.
*/
#define RASCM_UserName       0x00000001
#define RASCM_Password       0x00000002
#define RASCM_Domain         0x00000004

/* AutoDial address properties.
*/
#define RASAUTODIALENTRYA struct tagRASAUTODIALENTRYA
RASAUTODIALENTRYA
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    CHAR szEntry[ RAS_MaxEntryName + 1];
};

#define RASAUTODIALENTRYW struct tagRASAUTODIALENTRYW
RASAUTODIALENTRYW
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwDialingLocation;
    WCHAR szEntry[ RAS_MaxEntryName + 1];
};

#ifdef UNICODE
#define RASAUTODIALENTRY RASAUTODIALENTRYW
#else
#define RASAUTODIALENTRY RASAUTODIALENTRYA
#endif

#define LPRASAUTODIALENTRYW RASAUTODIALENTRYW*
#define LPRASAUTODIALENTRYA RASAUTODIALENTRYA*
#define LPRASAUTODIALENTRY  RASAUTODIALENTRY*

/* AutoDial control parameter values for
** Ras{Get,Set}AutodialParam.
*/
#define RASADP_DisableConnectionQuery           0
#define RASADP_LoginSessionDisable              1
#define RASADP_SavedAddressesLimit              2
#define RASADP_FailedConnectionTimeout          3
#define RASADP_ConnectionQueryTimeout           4


DWORD APIENTRY RasGetSubEntryHandleA( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetSubEntryHandleW( HRASCONN, DWORD, LPHRASCONN );

DWORD APIENTRY RasGetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA);

DWORD APIENTRY RasGetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW );

DWORD APIENTRY RasSetCredentialsA( LPSTR, LPSTR, LPRASCREDENTIALSA, BOOL );

DWORD APIENTRY RasSetCredentialsW( LPWSTR, LPWSTR, LPRASCREDENTIALSW, BOOL );

DWORD APIENTRY RasConnectionNotificationA( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasConnectionNotificationW( HRASCONN, HANDLE, DWORD );

DWORD APIENTRY RasGetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasGetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, LPDWORD, LPBYTE, LPDWORD );

DWORD APIENTRY RasSetSubEntryPropertiesA( LPSTR, LPSTR, DWORD,
                    LPRASSUBENTRYA, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasSetSubEntryPropertiesW( LPWSTR, LPWSTR, DWORD,
                    LPRASSUBENTRYW, DWORD, LPBYTE, DWORD );

DWORD APIENTRY RasGetAutodialAddressA( LPSTR, LPDWORD, LPRASAUTODIALENTRYA,
                    LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialAddressW( LPWSTR, LPDWORD, LPRASAUTODIALENTRYW,
                    LPDWORD, LPDWORD);

DWORD APIENTRY RasSetAutodialAddressA( LPSTR, DWORD, LPRASAUTODIALENTRYA,
                    DWORD, DWORD );

DWORD APIENTRY RasSetAutodialAddressW( LPWSTR, DWORD, LPRASAUTODIALENTRYW,
                    DWORD, DWORD );

DWORD APIENTRY RasEnumAutodialAddressesA( LPSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasEnumAutodialAddressesW( LPWSTR *, LPDWORD, LPDWORD );

DWORD APIENTRY RasGetAutodialEnableA( DWORD, LPBOOL );

DWORD APIENTRY RasGetAutodialEnableW( DWORD, LPBOOL );

DWORD APIENTRY RasSetAutodialEnableA( DWORD, BOOL );

DWORD APIENTRY RasSetAutodialEnableW( DWORD, BOOL );

DWORD APIENTRY RasGetAutodialParamA( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasGetAutodialParamW( DWORD, LPVOID, LPDWORD );

DWORD APIENTRY RasSetAutodialParamA( DWORD, LPVOID, DWORD );

DWORD APIENTRY RasSetAutodialParamW( DWORD, LPVOID, DWORD );


#ifdef UNICODE
#define RasDial                 RasDialW
#define RasEnumConnections      RasEnumConnectionsW
#define RasEnumEntries          RasEnumEntriesW
#define RasGetConnectStatus     RasGetConnectStatusW
#define RasGetErrorString       RasGetErrorStringW
#define RasHangUp               RasHangUpW
#define RasGetProjectionInfo    RasGetProjectionInfoW
#define RasCreatePhonebookEntry RasCreatePhonebookEntryW
#define RasEditPhonebookEntry   RasEditPhonebookEntryW
#define RasSetEntryDialParams   RasSetEntryDialParamsW
#define RasGetEntryDialParams   RasGetEntryDialParamsW
#define RasEnumDevices          RasEnumDevicesW
#define RasGetCountryInfo       RasGetCountryInfoW
#define RasGetEntryProperties   RasGetEntryPropertiesW
#define RasSetEntryProperties   RasSetEntryPropertiesW
#define RasRenameEntry          RasRenameEntryW
#define RasDeleteEntry          RasDeleteEntryW
#define RasValidateEntryName    RasValidateEntryNameW
#define RasGetSubEntryHandle        RasGetSubEntryHandleW
#define RasConnectionNotification   RasConnectionNotificationW
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesW
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesW
#define RasGetCredentials           RasGetCredentialsW
#define RasSetCredentials           RasSetCredentialsW
#define RasGetAutodialAddress       RasGetAutodialAddressW
#define RasSetAutodialAddress       RasSetAutodialAddressW
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesW
#define RasGetAutodialEnable        RasGetAutodialEnableW
#define RasSetAutodialEnable        RasSetAutodialEnableW
#define RasGetAutodialParam         RasGetAutodialParamW
#define RasSetAutodialParam         RasSetAutodialParamW
#else
#define RasDial                 RasDialA
#define RasEnumConnections      RasEnumConnectionsA
#define RasEnumEntries          RasEnumEntriesA
#define RasGetConnectStatus     RasGetConnectStatusA
#define RasGetErrorString       RasGetErrorStringA
#define RasHangUp               RasHangUpA
#define RasGetProjectionInfo    RasGetProjectionInfoA
#define RasCreatePhonebookEntry RasCreatePhonebookEntryA
#define RasEditPhonebookEntry   RasEditPhonebookEntryA
#define RasSetEntryDialParams   RasSetEntryDialParamsA
#define RasGetEntryDialParams   RasGetEntryDialParamsA
#define RasEnumDevices          RasEnumDevicesA
#define RasGetCountryInfo       RasGetCountryInfoA
#define RasGetEntryProperties   RasGetEntryPropertiesA
#define RasSetEntryProperties   RasSetEntryPropertiesA
#define RasRenameEntry          RasRenameEntryA
#define RasDeleteEntry          RasDeleteEntryA
#define RasValidateEntryName    RasValidateEntryNameA
#define RasGetSubEntryHandle        RasGetSubEntryHandleA
#define RasConnectionNotification   RasConnectionNotificationA
#define RasGetSubEntryProperties    RasGetSubEntryPropertiesA
#define RasSetSubEntryProperties    RasSetSubEntryPropertiesA
#define RasGetCredentials           RasGetCredentialsA
#define RasSetCredentials           RasSetCredentialsA
#define RasGetAutodialAddress       RasGetAutodialAddressA
#define RasSetAutodialAddress       RasSetAutodialAddressA
#define RasEnumAutodialAddresses    RasEnumAutodialAddressesA
#define RasGetAutodialEnable        RasGetAutodialEnableA
#define RasSetAutodialEnable        RasSetAutodialEnableA
#define RasGetAutodialParam         RasGetAutodialParamA
#define RasSetAutodialParam         RasSetAutodialParamA
#endif
                      
#ifdef __cplusplus
}
#endif

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\rnaapi.h ===
// ############################################################################
#define RASAPI_LIBRARY "RASAPI32.DLL"
#define RNAPH_LIBRARY "RNAPH.DLL"


#define RASAPI_RASSETENTRY "RasSetEntryPropertiesA"
#define RASAPI_RASGETENTRY "RasGetEntryPropertiesA"
#define RASAPI_RASDELETEENTRY "RasDeleteEntryA"

// ############################################################################
typedef DWORD (WINAPI* PFNRASENUMDEVICES)(LPRASDEVINFO lpRasDevInfo, LPDWORD lpcb, LPDWORD lpcDevices);
typedef DWORD (WINAPI* PFNRASVALIDATEENTRYNAE)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASSETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, DWORD dwEntryInfoSize, LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASGETENTRYPROPERTIES)(LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPBYTE lpbEntryInfo, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
typedef DWORD (WINAPI* PFNRASDELETEENTRY)(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
typedef DWORD (WINAPI* PFNRASHANGUP)(HRASCONN);

typedef DWORD (WINAPI* PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (WINAPI* PFNRASDIAL)(LPRASDIALEXTENSIONS,LPTSTR,LPRASDIALPARAMS,DWORD,LPVOID,LPHRASCONN);
typedef DWORD (WINAPI* PFNRASGETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,LPBOOL);
typedef DWORD (WINAPI* PFNRASGETCONNECTSTATUS)(HRASCONN,LPRASCONNSTATUS);
typedef DWORD (WINAPI* PFNRASGETCOUNTRYINFO)(LPRASCTRYINFO,LPDWORD);
typedef DWORD (WINAPI* PFNRASSETENTRYDIALPARAMS)(LPTSTR,LPRASDIALPARAMS,BOOL);

// ############################################################################
class RNAAPI
{
public:
    RNAAPI();
    ~RNAAPI();

    DWORD RasEnumDevices(LPRASDEVINFO, LPDWORD, LPDWORD);
    DWORD RasValidateEntryName(LPTSTR,LPTSTR);
    DWORD RasSetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                LPBYTE lpbEntryInfo,  DWORD dwEntryInfoSize,
                                LPBYTE lpbDeviceInfo, DWORD dwDeviceInfoSize);
    DWORD RasGetEntryProperties(LPTSTR lpszPhonebook, LPTSTR lpszEntry,
                                LPBYTE lpbEntryInfo,  LPDWORD lpdwEntryInfoSize,
                                LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize);
    DWORD RasDeleteEntry(LPTSTR lpszPhonebook, LPTSTR lpszEntry);
    DWORD RasHangUp(HRASCONN hrasconn);
    DWORD RasGetEntryDialParams(LPTSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams,
                                LPBOOL lpfPassword);
    DWORD RasDial(LPRASDIALEXTENSIONS lpRasDialExtensions,LPTSTR lpszPhonebook,
                  LPRASDIALPARAMS lpRasDialParams,DWORD dwNotifierType,LPVOID lpvNotifier,
                  LPHRASCONN lphRasConn);
    DWORD RasEnumConnections(LPRASCONN lprasconn,LPDWORD lpcb,LPDWORD lpcConnections);
   DWORD RasGetConnectStatus(HRASCONN, LPRASCONNSTATUS);
   DWORD RasGetCountryInfo(LPRASCTRYINFO, LPDWORD);
   DWORD RasSetEntryDialParams(LPTSTR,LPRASDIALPARAMS,BOOL);

private:
    BOOL LoadApi(LPCSTR, FARPROC*);

    HINSTANCE m_hInst;
    HINSTANCE m_hInst2;

    PFNRASENUMDEVICES m_fnRasEnumDeviecs;
    PFNRASVALIDATEENTRYNAE m_fnRasValidateEntryName;
    PFNRASSETENTRYPROPERTIES m_fnRasSetEntryProperties;
    PFNRASGETENTRYPROPERTIES m_fnRasGetEntryProperties;
    PFNRASDELETEENTRY m_fnRasDeleteEntry;
    PFNRASHANGUP m_fnRasHangUp;
    PFNRASENUMCONNECTIONS m_fnRasEnumConnections;
    PFNRASDIAL m_fnRasDial;
    PFNRASGETENTRYDIALPARAMS m_fnRasGetEntryDialParams;
    PFNRASGETCONNECTSTATUS m_fnRasGetConnectStatus;
    PFNRASGETCOUNTRYINFO m_fnRasGetCountryInfo;
    PFNRASSETENTRYDIALPARAMS m_fnRasSetEntryDialParams;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\tapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
granted  a royalty free worldwide, unlimited license to make copies, and use
the   API/SPI  for  making  applications/drivers  that  interface  with  the
specification provided that this paragraph and the Intel/Microsoft copyright
statement is maintained as is in the text and source code files.

Copyright 1995-96 Microsoft, all rights reserved.
Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

Module Name:

    tapi.h

Notes:

    Additions to the Telephony Application Programming Interface (TAPI) since
    version 1.0 are noted by version number (e.g. "TAPI v1.4").

--*/

#ifndef TAPI_H
#define TAPI_H



//
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//
// To build  a TAPI 1.4 application put a define as below in your source
// file before you include TAPI.H:
//
// #define TAPI_CURRENT_VERSION 0x00010004
//
//
#ifndef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020000
#endif

#include <windows.h>

#pragma pack(1)
// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//
// TAPI type definitions
//

#define DECLARE_OPAQUE32(name)  struct name##__ { int unused; }; \
                typedef const struct name##__ FAR* name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

typedef HICON FAR * LPHICON;

typedef void (CALLBACK * LINECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

typedef void (CALLBACK * PHONECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD               dwInstance,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE                       0L
#define LINE_CALLINFO                           1L
#define LINE_CALLSTATE                          2L
#define LINE_CLOSE                              3L
#define LINE_DEVSPECIFIC                        4L
#define LINE_DEVSPECIFICFEATURE                 5L
#define LINE_GATHERDIGITS                       6L
#define LINE_GENERATE                           7L
#define LINE_LINEDEVSTATE                       8L
#define LINE_MONITORDIGITS                      9L
#define LINE_MONITORMEDIA                       10L
#define LINE_MONITORTONE                        11L
#define LINE_REPLY                              12L
#define LINE_REQUEST                            13L
#define PHONE_BUTTON                            14L
#define PHONE_CLOSE                             15L
#define PHONE_DEVSPECIFIC                       16L
#define PHONE_REPLY                             17L
#define PHONE_STATE                             18L
#define LINE_CREATE                             19L             // TAPI v1.4
#define PHONE_CREATE                            20L             // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#define PHONE_REMOVE                            26L             // TAPI v2.0
#endif


#define INITIALIZE_NEGOTIATION                  0xFFFFFFFFL

#define LINEADDRCAPFLAGS_FWDNUMRINGS            0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID          0x00000002
#define LINEADDRCAPFLAGS_SECURE                 0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT         0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        0x00000010
#define LINEADDRCAPFLAGS_DIALED                 0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK            0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK            0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT             0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL          0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT          0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID           0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD           0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE           0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD         0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE         0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL            0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID         0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR          0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR          0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT          0x00100000
#define LINEADDRCAPFLAGS_CONFDROP               0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT         0x00400000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER       0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           0x20000000      // TAPI v2.0
#endif

#define LINEADDRESSMODE_ADDRESSID               0x00000001
#define LINEADDRESSMODE_DIALABLEADDR            0x00000002

#define LINEADDRESSSHARING_PRIVATE              0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL          0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW           0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED        0x00000008
#define LINEADDRESSSHARING_MONITORED            0x00000010

#define LINEADDRESSSTATE_OTHER                  0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC            0x00000002
#define LINEADDRESSSTATE_INUSEZERO              0x00000004
#define LINEADDRESSSTATE_INUSEONE               0x00000008
#define LINEADDRESSSTATE_INUSEMANY              0x00000010
#define LINEADDRESSSTATE_NUMCALLS               0x00000020
#define LINEADDRESSSTATE_FORWARD                0x00000040
#define LINEADDRESSSTATE_TERMINALS              0x00000080
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRESSSTATE_AGENT                  0x00000200      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTSTATE             0x00000400      // TAPI v2.0
#define LINEADDRESSSTATE_AGENTACTIVITY          0x00000800      // TAPI v2.0
#endif

#define LINEADDRFEATURE_FORWARD                 0x00000001
#define LINEADDRFEATURE_MAKECALL                0x00000002
#define LINEADDRFEATURE_PICKUP                  0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL         0x00000008
#define LINEADDRFEATURE_SETTERMINAL             0x00000010
#define LINEADDRFEATURE_SETUPCONF               0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL          0x00000040
#define LINEADDRFEATURE_UNPARK                  0x00000080
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEAGENTFEATURE_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTACTIVITY       0x00000004      // TAPI v2.0
#define LINEAGENTFEATURE_AGENTSPECIFIC          0x00000008      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTACTIVITYLIST   0x00000010      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTGROUP          0x00000020      // TAPI v2.0

#define LINEAGENTSTATE_LOGGEDOFF                0x00000001      // TAPI v2.0
#define LINEAGENTSTATE_NOTREADY                 0x00000002      // TAPI v2.0
#define LINEAGENTSTATE_READY                    0x00000004      // TAPI v2.0
#define LINEAGENTSTATE_BUSYACD                  0x00000008      // TAPI v2.0
#define LINEAGENTSTATE_BUSYINCOMING             0x00000010      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOUTBOUND             0x00000020      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOTHER                0x00000040      // TAPI v2.0
#define LINEAGENTSTATE_WORKINGAFTERCALL         0x00000080      // TAPI v2.0
#define LINEAGENTSTATE_UNKNOWN                  0x00000100      // TAPI v2.0
#define LINEAGENTSTATE_UNAVAIL                  0x00000200      // TAPI v2.0

#define LINEAGENTSTATUS_GROUP                   0x00000001      // TAPI v2.0
#define LINEAGENTSTATUS_STATE                   0x00000002      // TAPI v2.0
#define LINEAGENTSTATUS_NEXTSTATE               0x00000004      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITY                0x00000008      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITYLIST            0x00000010      // TAPI v2.0
#define LINEAGENTSTATUS_GROUPLIST               0x00000020      // TAPI v2.0
#define LINEAGENTSTATUS_CAPSCHANGE              0x00000040      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDSTATES             0x00000080      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDNEXTSTATES         0x00000100      // TAPI v2.0
#endif


#define LINEANSWERMODE_NONE                     0x00000001
#define LINEANSWERMODE_DROP                     0x00000002
#define LINEANSWERMODE_HOLD                     0x00000004

#define LINEBEARERMODE_VOICE                    0x00000001
#define LINEBEARERMODE_SPEECH                   0x00000002
#define LINEBEARERMODE_MULTIUSE                 0x00000004
#define LINEBEARERMODE_DATA                     0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA            0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING         0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                    0x00000001
#define LINEBUSYMODE_TRUNK                      0x00000002
#define LINEBUSYMODE_UNKNOWN                    0x00000004
#define LINEBUSYMODE_UNAVAIL                    0x00000008

#define LINECALLCOMPLCOND_BUSY                  0x00000001
#define LINECALLCOMPLCOND_NOANSWER              0x00000002

#define LINECALLCOMPLMODE_CAMPON                0x00000001
#define LINECALLCOMPLMODE_CALLBACK              0x00000002
#define LINECALLCOMPLMODE_INTRUDE               0x00000004
#define LINECALLCOMPLMODE_MESSAGE               0x00000008

#define LINECALLFEATURE_ACCEPT                  0x00000001
#define LINECALLFEATURE_ADDTOCONF               0x00000002
#define LINECALLFEATURE_ANSWER                  0x00000004
#define LINECALLFEATURE_BLINDTRANSFER           0x00000008
#define LINECALLFEATURE_COMPLETECALL            0x00000010
#define LINECALLFEATURE_COMPLETETRANSF          0x00000020
#define LINECALLFEATURE_DIAL                    0x00000040
#define LINECALLFEATURE_DROP                    0x00000080
#define LINECALLFEATURE_GATHERDIGITS            0x00000100
#define LINECALLFEATURE_GENERATEDIGITS          0x00000200
#define LINECALLFEATURE_GENERATETONE            0x00000400
#define LINECALLFEATURE_HOLD                    0x00000800
#define LINECALLFEATURE_MONITORDIGITS           0x00001000
#define LINECALLFEATURE_MONITORMEDIA            0x00002000
#define LINECALLFEATURE_MONITORTONES            0x00004000
#define LINECALLFEATURE_PARK                    0x00008000
#define LINECALLFEATURE_PREPAREADDCONF          0x00010000
#define LINECALLFEATURE_REDIRECT                0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF          0x00040000
#define LINECALLFEATURE_SECURECALL              0x00080000
#define LINECALLFEATURE_SENDUSERUSER            0x00100000
#define LINECALLFEATURE_SETCALLPARAMS           0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL         0x00400000
#define LINECALLFEATURE_SETTERMINAL             0x00800000
#define LINECALLFEATURE_SETUPCONF               0x01000000
#define LINECALLFEATURE_SETUPTRANSFER           0x02000000
#define LINECALLFEATURE_SWAPHOLD                0x04000000
#define LINECALLFEATURE_UNHOLD                  0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE2_NOHOLDCONFERENCE       0x00000001      // TAPI v2.0
#define LINECALLFEATURE2_ONESTEPTRANSFER        0x00000002      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCAMPON            0x00000004      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCALLBACK          0x00000008      // TAPI v2.0
#define LINECALLFEATURE2_COMPLINTRUDE           0x00000010      // TAPI v2.0
#define LINECALLFEATURE2_COMPLMESSAGE           0x00000020      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERNORM           0x00000040      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERCONF           0x00000080      // TAPI v2.0
#define LINECALLFEATURE2_PARKDIRECT             0x00000100      // TAPI v2.0
#define LINECALLFEATURE2_PARKNONDIRECT          0x00000200      // TAPI v2.0
#endif

#define LINECALLINFOSTATE_OTHER                 0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC           0x00000002
#define LINECALLINFOSTATE_BEARERMODE            0x00000004
#define LINECALLINFOSTATE_RATE                  0x00000008
#define LINECALLINFOSTATE_MEDIAMODE             0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC           0x00000020
#define LINECALLINFOSTATE_CALLID                0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID         0x00000080
#define LINECALLINFOSTATE_ORIGIN                0x00000100
#define LINECALLINFOSTATE_REASON                0x00000200
#define LINECALLINFOSTATE_COMPLETIONID          0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR          0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR          0x00001000
#define LINECALLINFOSTATE_NUMMONITORS           0x00002000
#define LINECALLINFOSTATE_TRUNK                 0x00004000
#define LINECALLINFOSTATE_CALLERID              0x00008000
#define LINECALLINFOSTATE_CALLEDID              0x00010000
#define LINECALLINFOSTATE_CONNECTEDID           0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID         0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID         0x00080000
#define LINECALLINFOSTATE_DISPLAY               0x00100000
#define LINECALLINFOSTATE_USERUSERINFO          0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP         0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP          0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO          0x01000000
#define LINECALLINFOSTATE_TERMINAL              0x02000000
#define LINECALLINFOSTATE_DIALPARAMS            0x04000000
#define LINECALLINFOSTATE_MONITORMODES          0x08000000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif

#define LINECALLORIGIN_OUTBOUND                 0x00000001
#define LINECALLORIGIN_INTERNAL                 0x00000002
#define LINECALLORIGIN_EXTERNAL                 0x00000004
#define LINECALLORIGIN_UNKNOWN                  0x00000010
#define LINECALLORIGIN_UNAVAIL                  0x00000020
#define LINECALLORIGIN_CONFERENCE               0x00000040
#define LINECALLORIGIN_INBOUND                  0x00000080      // TAPI v1.4

#define LINECALLPARAMFLAGS_SECURE               0x00000001
#define LINECALLPARAMFLAGS_IDLE                 0x00000002
#define LINECALLPARAMFLAGS_BLOCKID              0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK          0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK          0x00000010
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif

#define LINECALLPARTYID_BLOCKED                 0x00000001
#define LINECALLPARTYID_OUTOFAREA               0x00000002
#define LINECALLPARTYID_NAME                    0x00000004
#define LINECALLPARTYID_ADDRESS                 0x00000008
#define LINECALLPARTYID_PARTIAL                 0x00000010
#define LINECALLPARTYID_UNKNOWN                 0x00000020
#define LINECALLPARTYID_UNAVAIL                 0x00000040

#define LINECALLPRIVILEGE_NONE                  0x00000001
#define LINECALLPRIVILEGE_MONITOR               0x00000002
#define LINECALLPRIVILEGE_OWNER                 0x00000004

#define LINECALLREASON_DIRECT                   0x00000001
#define LINECALLREASON_FWDBUSY                  0x00000002
#define LINECALLREASON_FWDNOANSWER              0x00000004
#define LINECALLREASON_FWDUNCOND                0x00000008
#define LINECALLREASON_PICKUP                   0x00000010
#define LINECALLREASON_UNPARK                   0x00000020
#define LINECALLREASON_REDIRECT                 0x00000040
#define LINECALLREASON_CALLCOMPLETION           0x00000080
#define LINECALLREASON_TRANSFER                 0x00000100
#define LINECALLREASON_REMINDER                 0x00000200
#define LINECALLREASON_UNKNOWN                  0x00000400
#define LINECALLREASON_UNAVAIL                  0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif

#define LINECALLSELECT_LINE                     0x00000001
#define LINECALLSELECT_ADDRESS                  0x00000002
#define LINECALLSELECT_CALL                     0x00000004

#define LINECALLSTATE_IDLE                      0x00000001
#define LINECALLSTATE_OFFERING                  0x00000002
#define LINECALLSTATE_ACCEPTED                  0x00000004
#define LINECALLSTATE_DIALTONE                  0x00000008
#define LINECALLSTATE_DIALING                   0x00000010
#define LINECALLSTATE_RINGBACK                  0x00000020
#define LINECALLSTATE_BUSY                      0x00000040
#define LINECALLSTATE_SPECIALINFO               0x00000080
#define LINECALLSTATE_CONNECTED                 0x00000100
#define LINECALLSTATE_PROCEEDING                0x00000200
#define LINECALLSTATE_ONHOLD                    0x00000400
#define LINECALLSTATE_CONFERENCED               0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF            0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER        0x00002000
#define LINECALLSTATE_DISCONNECTED              0x00004000
#define LINECALLSTATE_UNKNOWN                   0x00008000

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLTREATMENT_SILENCE               0x00000001      // TAPI v2.0
#define LINECALLTREATMENT_RINGBACK              0x00000002      // TAPI v2.0
#define LINECALLTREATMENT_BUSY                  0x00000003      // TAPI v2.0
#define LINECALLTREATMENT_MUSIC                 0x00000004      // TAPI v2.0
#endif

#define LINECARDOPTION_PREDEFINED               0x00000001      // TAPI v1.4
#define LINECARDOPTION_HIDDEN                   0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVE                0x00000001      // TAPI v1.4
#define LINECONNECTEDMODE_INACTIVE              0x00000002      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECONNECTEDMODE_ACTIVEHELD            0x00000004      // TAPI v2.0
#define LINECONNECTEDMODE_INACTIVEHELD          0x00000008      // TAPI v2.0
#define LINECONNECTEDMODE_CONFIRMED             0x00000010      // TAPI v2.0
#endif

#define LINEDEVCAPFLAGS_CROSSADDRCONF           0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP             0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP              0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL            0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR            0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP               0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING             0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET               0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE            0x00000100

#define LINEDEVSTATE_OTHER                      0x00000001
#define LINEDEVSTATE_RINGING                    0x00000002
#define LINEDEVSTATE_CONNECTED                  0x00000004
#define LINEDEVSTATE_DISCONNECTED               0x00000008
#define LINEDEVSTATE_MSGWAITON                  0x00000010
#define LINEDEVSTATE_MSGWAITOFF                 0x00000020
#define LINEDEVSTATE_INSERVICE                  0x00000040
#define LINEDEVSTATE_OUTOFSERVICE               0x00000080
#define LINEDEVSTATE_MAINTENANCE                0x00000100
#define LINEDEVSTATE_OPEN                       0x00000200
#define LINEDEVSTATE_CLOSE                      0x00000400
#define LINEDEVSTATE_NUMCALLS                   0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS             0x00001000
#define LINEDEVSTATE_TERMINALS                  0x00002000
#define LINEDEVSTATE_ROAMMODE                   0x00004000
#define LINEDEVSTATE_BATTERY                    0x00008000
#define LINEDEVSTATE_SIGNAL                     0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                0x00020000
#define LINEDEVSTATE_REINIT                     0x00040000
#define LINEDEVSTATE_LOCK                       0x00080000
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4

#define LINEDEVSTATUSFLAGS_CONNECTED            0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT              0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE            0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED               0x00000008

#define LINEDIALTONEMODE_NORMAL                 0x00000001
#define LINEDIALTONEMODE_SPECIAL                0x00000002
#define LINEDIALTONEMODE_INTERNAL               0x00000004
#define LINEDIALTONEMODE_EXTERNAL               0x00000008
#define LINEDIALTONEMODE_UNKNOWN                0x00000010
#define LINEDIALTONEMODE_UNAVAIL                0x00000020
    
#define LINEDIGITMODE_PULSE                     0x00000001
#define LINEDIGITMODE_DTMF                      0x00000002
#define LINEDIGITMODE_DTMFEND                   0x00000004
    
#define LINEDISCONNECTMODE_NORMAL               0x00000001
#define LINEDISCONNECTMODE_UNKNOWN              0x00000002
#define LINEDISCONNECTMODE_REJECT               0x00000004
#define LINEDISCONNECTMODE_PICKUP               0x00000008
#define LINEDISCONNECTMODE_FORWARDED            0x00000010
#define LINEDISCONNECTMODE_BUSY                 0x00000020
#define LINEDISCONNECTMODE_NOANSWER             0x00000040
#define LINEDISCONNECTMODE_BADADDRESS           0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE          0x00000100
#define LINEDISCONNECTMODE_CONGESTION           0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE         0x00000400
#define LINEDISCONNECTMODE_UNAVAIL              0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#endif

#define LINEERR_ALLOCATED                       0x80000001
#define LINEERR_BADDEVICEID                     0x80000002
#define LINEERR_BEARERMODEUNAVAIL               0x80000003
#define LINEERR_CALLUNAVAIL                     0x80000005
#define LINEERR_COMPLETIONOVERRUN               0x80000006
#define LINEERR_CONFERENCEFULL                  0x80000007
#define LINEERR_DIALBILLING                     0x80000008
#define LINEERR_DIALDIALTONE                    0x80000009
#define LINEERR_DIALPROMPT                      0x8000000A
#define LINEERR_DIALQUIET                       0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION          0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION          0x8000000D
#define LINEERR_INIFILECORRUPT                  0x8000000E
#define LINEERR_INUSE                           0x8000000F
#define LINEERR_INVALADDRESS                    0x80000010
#define LINEERR_INVALADDRESSID                  0x80000011
#define LINEERR_INVALADDRESSMODE                0x80000012
#define LINEERR_INVALADDRESSSTATE               0x80000013
#define LINEERR_INVALAPPHANDLE                  0x80000014
#define LINEERR_INVALAPPNAME                    0x80000015
#define LINEERR_INVALBEARERMODE                 0x80000016
#define LINEERR_INVALCALLCOMPLMODE              0x80000017
#define LINEERR_INVALCALLHANDLE                 0x80000018
#define LINEERR_INVALCALLPARAMS                 0x80000019
#define LINEERR_INVALCALLPRIVILEGE              0x8000001A
#define LINEERR_INVALCALLSELECT                 0x8000001B
#define LINEERR_INVALCALLSTATE                  0x8000001C
#define LINEERR_INVALCALLSTATELIST              0x8000001D
#define LINEERR_INVALCARD                       0x8000001E
#define LINEERR_INVALCOMPLETIONID               0x8000001F
#define LINEERR_INVALCONFCALLHANDLE             0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE          0x80000021
#define LINEERR_INVALCOUNTRYCODE                0x80000022
#define LINEERR_INVALDEVICECLASS                0x80000023
#define LINEERR_INVALDEVICEHANDLE               0x80000024
#define LINEERR_INVALDIALPARAMS                 0x80000025
#define LINEERR_INVALDIGITLIST                  0x80000026
#define LINEERR_INVALDIGITMODE                  0x80000027
#define LINEERR_INVALDIGITS                     0x80000028
#define LINEERR_INVALEXTVERSION                 0x80000029
#define LINEERR_INVALGROUPID                    0x8000002A
#define LINEERR_INVALLINEHANDLE                 0x8000002B
#define LINEERR_INVALLINESTATE                  0x8000002C
#define LINEERR_INVALLOCATION                   0x8000002D
#define LINEERR_INVALMEDIALIST                  0x8000002E
#define LINEERR_INVALMEDIAMODE                  0x8000002F
#define LINEERR_INVALMESSAGEID                  0x80000030
#define LINEERR_INVALPARAM                      0x80000032
#define LINEERR_INVALPARKID                     0x80000033
#define LINEERR_INVALPARKMODE                   0x80000034
#define LINEERR_INVALPOINTER                    0x80000035
#define LINEERR_INVALPRIVSELECT                 0x80000036
#define LINEERR_INVALRATE                       0x80000037
#define LINEERR_INVALREQUESTMODE                0x80000038
#define LINEERR_INVALTERMINALID                 0x80000039
#define LINEERR_INVALTERMINALMODE               0x8000003A
#define LINEERR_INVALTIMEOUT                    0x8000003B
#define LINEERR_INVALTONE                       0x8000003C
#define LINEERR_INVALTONELIST                   0x8000003D
#define LINEERR_INVALTONEMODE                   0x8000003E
#define LINEERR_INVALTRANSFERMODE               0x8000003F
#define LINEERR_LINEMAPPERFAILED                0x80000040
#define LINEERR_NOCONFERENCE                    0x80000041
#define LINEERR_NODEVICE                        0x80000042
#define LINEERR_NODRIVER                        0x80000043
#define LINEERR_NOMEM                           0x80000044
#define LINEERR_NOREQUEST                       0x80000045
#define LINEERR_NOTOWNER                        0x80000046
#define LINEERR_NOTREGISTERED                   0x80000047
#define LINEERR_OPERATIONFAILED                 0x80000048
#define LINEERR_OPERATIONUNAVAIL                0x80000049
#define LINEERR_RATEUNAVAIL                     0x8000004A
#define LINEERR_RESOURCEUNAVAIL                 0x8000004B
#define LINEERR_REQUESTOVERRUN                  0x8000004C
#define LINEERR_STRUCTURETOOSMALL               0x8000004D
#define LINEERR_TARGETNOTFOUND                  0x8000004E
#define LINEERR_TARGETSELF                      0x8000004F
#define LINEERR_UNINITIALIZED                   0x80000050
#define LINEERR_USERUSERINFOTOOBIG              0x80000051
#define LINEERR_REINIT                          0x80000052
#define LINEERR_ADDRESSBLOCKED                  0x80000053
#define LINEERR_BILLINGREJECTED                 0x80000054
#define LINEERR_INVALFEATURE                    0x80000055
#define LINEERR_NOMULTIPLEINSTANCE              0x80000056
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEERR_INVALAGENTID                    0x80000057      // TAPI v2.0
#define LINEERR_INVALAGENTGROUP                 0x80000058      // TAPI v2.0
#define LINEERR_INVALPASSWORD                   0x80000059      // TAPI v2.0
#define LINEERR_INVALAGENTSTATE                 0x8000005A      // TAPI v2.0
#define LINEERR_INVALAGENTACTIVITY              0x8000005B      // TAPI v2.0
#define LINEERR_DIALVOICEDETECT                 0x8000005C      // TAPI v2.0
#endif

#define LINEFEATURE_DEVSPECIFIC                 0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT             0x00000002
#define LINEFEATURE_FORWARD                     0x00000004
#define LINEFEATURE_MAKECALL                    0x00000008
#define LINEFEATURE_SETMEDIACONTROL             0x00000010
#define LINEFEATURE_SETTERMINAL                 0x00000020
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif

#define LINEFORWARDMODE_UNCOND                  0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL          0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL          0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC          0x00000008
#define LINEFORWARDMODE_BUSY                    0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL            0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL            0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC            0x00000080
#define LINEFORWARDMODE_NOANSW                  0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL          0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL          0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC          0x00000800
#define LINEFORWARDMODE_BUSYNA                  0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL          0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL          0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC          0x00008000
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4

#define LINEGATHERTERM_BUFFERFULL               0x00000001
#define LINEGATHERTERM_TERMDIGIT                0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT             0x00000004
#define LINEGATHERTERM_INTERTIMEOUT             0x00000008
#define LINEGATHERTERM_CANCEL                   0x00000010

#define LINEGENERATETERM_DONE                   0x00000001
#define LINEGENERATETERM_CANCEL                 0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      0x00000001  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USEEVENT             0x00000002  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    0x00000004  // TAPI v2.0
#endif

#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4

#define LINEMAPPER                              0xFFFFFFFF

#define LINEMEDIACONTROL_NONE                   0x00000001
#define LINEMEDIACONTROL_START                  0x00000002
#define LINEMEDIACONTROL_RESET                  0x00000004
#define LINEMEDIACONTROL_PAUSE                  0x00000008
#define LINEMEDIACONTROL_RESUME                 0x00000010
#define LINEMEDIACONTROL_RATEUP                 0x00000020
#define LINEMEDIACONTROL_RATEDOWN               0x00000040
#define LINEMEDIACONTROL_RATENORMAL             0x00000080
#define LINEMEDIACONTROL_VOLUMEUP               0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN             0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL           0x00000400

#define LINEMEDIAMODE_UNKNOWN                   0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE          0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE            0x00000008
#define LINEMEDIAMODE_DATAMODEM                 0x00000010
#define LINEMEDIAMODE_G3FAX                     0x00000020
#define LINEMEDIAMODE_TDD                       0x00000040
#define LINEMEDIAMODE_G4FAX                     0x00000080
#define LINEMEDIAMODE_DIGITALDATA               0x00000100
#define LINEMEDIAMODE_TELETEX                   0x00000200
#define LINEMEDIAMODE_VIDEOTEX                  0x00000400
#define LINEMEDIAMODE_TELEX                     0x00000800
#define LINEMEDIAMODE_MIXED                     0x00001000
#define LINEMEDIAMODE_ADSI                      0x00002000
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LAST_LINEMEDIAMODE                      0x00004000

#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEOPENOPTION_SINGLEADDRESS            0x80000000      // TAPI v2.0
#define LINEOPENOPTION_PROXY                    0x40000000      // TAPI v2.0
#endif

#define LINEPARKMODE_DIRECTED                   0x00000001
#define LINEPARKMODE_NONDIRECTED                0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEPROXYREQUEST_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTACTIVITY       0x00000003      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTCAPS           0x00000004      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTSTATUS         0x00000005      // TAPI v2.0
#define LINEPROXYREQUEST_AGENTSPECIFIC          0x00000006      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTACTIVITYLIST   0x00000007      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTGROUPLIST      0x00000008      // TAPI v2.0
#endif

#define LINEREMOVEFROMCONF_NONE                 0x00000001
#define LINEREMOVEFROMCONF_LAST                 0x00000002
#define LINEREMOVEFROMCONF_ANY                  0x00000003

#define LINEREQUESTMODE_MAKECALL                0x00000001
#define LINEREQUESTMODE_MEDIACALL               0x00000002
#define LINEREQUESTMODE_DROP                    0x00000004
#define LAST_LINEREQUESTMODE                    LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                    0x00000001
#define LINEROAMMODE_UNAVAIL                    0x00000002
#define LINEROAMMODE_HOME                       0x00000004
#define LINEROAMMODE_ROAMA                      0x00000008
#define LINEROAMMODE_ROAMB                      0x00000010

#define LINESPECIALINFO_NOCIRCUIT               0x00000001
#define LINESPECIALINFO_CUSTIRREG               0x00000002
#define LINESPECIALINFO_REORDER                 0x00000004
#define LINESPECIALINFO_UNKNOWN                 0x00000008
#define LINESPECIALINFO_UNAVAIL                 0x00000010

#define LINETERMDEV_PHONE                       0x00000001
#define LINETERMDEV_HEADSET                     0x00000002
#define LINETERMDEV_SPEAKER                     0x00000004

#define LINETERMMODE_BUTTONS                    0x00000001
#define LINETERMMODE_LAMPS                      0x00000002
#define LINETERMMODE_DISPLAY                    0x00000004
#define LINETERMMODE_RINGER                     0x00000008
#define LINETERMMODE_HOOKSWITCH                 0x00000010
#define LINETERMMODE_MEDIATOLINE                0x00000020
#define LINETERMMODE_MEDIAFROMLINE              0x00000040
#define LINETERMMODE_MEDIABIDIRECT              0x00000080

#define LINETERMSHARING_PRIVATE                 0x00000001
#define LINETERMSHARING_SHAREDEXCL              0x00000002
#define LINETERMSHARING_SHAREDCONF              0x00000004

#define LINETOLLLISTOPTION_ADD                  0x00000001
#define LINETOLLLISTOPTION_REMOVE               0x00000002

#define LINETONEMODE_CUSTOM                     0x00000001
#define LINETONEMODE_RINGBACK                   0x00000002
#define LINETONEMODE_BUSY                       0x00000004
#define LINETONEMODE_BEEP                       0x00000008
#define LINETONEMODE_BILLING                    0x00000010

#define LINETRANSFERMODE_TRANSFER               0x00000001
#define LINETRANSFERMODE_CONFERENCE             0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE        0x00000001
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4

#define LINETRANSLATERESULT_CANONICAL           0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL       0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE        0x00000004
#define LINETRANSLATERESULT_LOCAL               0x00000008
#define LINETRANSLATERESULT_INTOLLLIST          0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST       0x00000020
#define LINETRANSLATERESULT_DIALBILLING         0x00000040
#define LINETRANSLATERESULT_DIALQUIET           0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE        0x00000100
#define LINETRANSLATERESULT_DIALPROMPT          0x00000200
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT         0x00000400      // TAPI v2.0
#endif

#define PHONEBUTTONFUNCTION_UNKNOWN             0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE          0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER            0x00000002
#define PHONEBUTTONFUNCTION_DROP                0x00000003
#define PHONEBUTTONFUNCTION_HOLD                0x00000004
#define PHONEBUTTONFUNCTION_RECALL              0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT          0x00000006
#define PHONEBUTTONFUNCTION_CONNECT             0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON           0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF          0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING          0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL          0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD             0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP              0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN           0x0000000E
#define PHONEBUTTONFUNCTION_PARK                0x0000000F
#define PHONEBUTTONFUNCTION_REJECT              0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT            0x00000011
#define PHONEBUTTONFUNCTION_MUTE                0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP            0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN          0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON           0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF          0x00000016
#define PHONEBUTTONFUNCTION_FLASH               0x00000017
#define PHONEBUTTONFUNCTION_DATAON              0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF             0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB        0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM            0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP          0x0000001C
#define PHONEBUTTONFUNCTION_BUSY                0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP             0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME            0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY           0x00000020
#define PHONEBUTTONFUNCTION_COVER               0x00000021
#define PHONEBUTTONFUNCTION_CALLID              0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM             0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV            0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS           0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR        0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL             0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL          0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED         0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED        0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON              0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT          0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL           0x0000002D
#define PHONEBUTTONFUNCTION_NONE                0x0000002E

#define PHONEBUTTONMODE_DUMMY                   0x00000001
#define PHONEBUTTONMODE_CALL                    0x00000002
#define PHONEBUTTONMODE_FEATURE                 0x00000004
#define PHONEBUTTONMODE_KEYPAD                  0x00000008
#define PHONEBUTTONMODE_LOCAL                   0x00000010
#define PHONEBUTTONMODE_DISPLAY                 0x00000020

#define PHONEBUTTONSTATE_UP                     0x00000001
#define PHONEBUTTONSTATE_DOWN                   0x00000002
#define PHONEBUTTONSTATE_UNKNOWN                0x00000004      // TAPI v1.4
#define PHONEBUTTONSTATE_UNAVAIL                0x00000008      // TAPI v1.4

#define PHONEERR_ALLOCATED                      0x90000001
#define PHONEERR_BADDEVICEID                    0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION         0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION         0x90000004
#define PHONEERR_INIFILECORRUPT                 0x90000005
#define PHONEERR_INUSE                          0x90000006
#define PHONEERR_INVALAPPHANDLE                 0x90000007
#define PHONEERR_INVALAPPNAME                   0x90000008
#define PHONEERR_INVALBUTTONLAMPID              0x90000009
#define PHONEERR_INVALBUTTONMODE                0x9000000A
#define PHONEERR_INVALBUTTONSTATE               0x9000000B
#define PHONEERR_INVALDATAID                    0x9000000C
#define PHONEERR_INVALDEVICECLASS               0x9000000D
#define PHONEERR_INVALEXTVERSION                0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV             0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE            0x90000010
#define PHONEERR_INVALLAMPMODE                  0x90000011
#define PHONEERR_INVALPARAM                     0x90000012
#define PHONEERR_INVALPHONEHANDLE               0x90000013
#define PHONEERR_INVALPHONESTATE                0x90000014
#define PHONEERR_INVALPOINTER                   0x90000015
#define PHONEERR_INVALPRIVILEGE                 0x90000016
#define PHONEERR_INVALRINGMODE                  0x90000017
#define PHONEERR_NODEVICE                       0x90000018
#define PHONEERR_NODRIVER                       0x90000019
#define PHONEERR_NOMEM                          0x9000001A
#define PHONEERR_NOTOWNER                       0x9000001B
#define PHONEERR_OPERATIONFAILED                0x9000001C
#define PHONEERR_OPERATIONUNAVAIL               0x9000001D
#define PHONEERR_RESOURCEUNAVAIL                0x9000001F
#define PHONEERR_REQUESTOVERRUN                 0x90000020
#define PHONEERR_STRUCTURETOOSMALL              0x90000021
#define PHONEERR_UNINITIALIZED                  0x90000022
#define PHONEERR_REINIT                         0x90000023

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEFEATURE_GETBUTTONINFO              0x00000001      // TAPI v2.0
#define PHONEFEATURE_GETDATA                    0x00000002      // TAPI v2.0
#define PHONEFEATURE_GETDISPLAY                 0x00000004      // TAPI v2.0
#define PHONEFEATURE_GETGAINHANDSET             0x00000008      // TAPI v2.0
#define PHONEFEATURE_GETGAINSPEAKER             0x00000010      // TAPI v2.0
#define PHONEFEATURE_GETGAINHEADSET             0x00000020      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHANDSET       0x00000040      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHSPEAKER       0x00000080      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHEADSET       0x00000100      // TAPI v2.0
#define PHONEFEATURE_GETLAMP                    0x00000200      // TAPI v2.0
#define PHONEFEATURE_GETRING                    0x00000400      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHANDSET           0x00000800      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMESPEAKER           0x00001000      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHEADSET           0x00002000      // TAPI v2.0
#define PHONEFEATURE_SETBUTTONINFO              0x00004000      // TAPI v2.0
#define PHONEFEATURE_SETDATA                    0x00008000      // TAPI v2.0
#define PHONEFEATURE_SETDISPLAY                 0x00010000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHANDSET             0x00020000      // TAPI v2.0
#define PHONEFEATURE_SETGAINSPEAKER             0x00040000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHEADSET             0x00080000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHANDSET       0x00100000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHSPEAKER       0x00200000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHEADSET       0x00400000      // TAPI v2.0
#define PHONEFEATURE_SETLAMP                    0x00800000      // TAPI v2.0
#define PHONEFEATURE_SETRING                    0x01000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHANDSET           0x02000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMESPEAKER           0x04000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHEADSET           0x08000000      // TAPI v2.0
#endif

#define PHONEHOOKSWITCHDEV_HANDSET              0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER              0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET              0x00000004

#define PHONEHOOKSWITCHMODE_ONHOOK              0x00000001
#define PHONEHOOKSWITCHMODE_MIC                 0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER             0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER          0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN             0x00000010

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     0x00000001  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USEEVENT            0x00000002  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   0x00000004  // TAPI v2.0
#endif

#define PHONELAMPMODE_DUMMY                     0x00000001
#define PHONELAMPMODE_OFF                       0x00000002
#define PHONELAMPMODE_STEADY                    0x00000004
#define PHONELAMPMODE_WINK                      0x00000008
#define PHONELAMPMODE_FLASH                     0x00000010
#define PHONELAMPMODE_FLUTTER                   0x00000020
#define PHONELAMPMODE_BROKENFLUTTER             0x00000040
#define PHONELAMPMODE_UNKNOWN                   0x00000080

#define PHONEPRIVILEGE_MONITOR                  0x00000001
#define PHONEPRIVILEGE_OWNER                    0x00000002

#define PHONESTATE_OTHER                        0x00000001
#define PHONESTATE_CONNECTED                    0x00000002
#define PHONESTATE_DISCONNECTED                 0x00000004
#define PHONESTATE_OWNER                        0x00000008
#define PHONESTATE_MONITORS                     0x00000010
#define PHONESTATE_DISPLAY                      0x00000020
#define PHONESTATE_LAMP                         0x00000040
#define PHONESTATE_RINGMODE                     0x00000080
#define PHONESTATE_RINGVOLUME                   0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH            0x00000200
#define PHONESTATE_HANDSETVOLUME                0x00000400
#define PHONESTATE_HANDSETGAIN                  0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH            0x00001000
#define PHONESTATE_SPEAKERVOLUME                0x00002000
#define PHONESTATE_SPEAKERGAIN                  0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH            0x00008000
#define PHONESTATE_HEADSETVOLUME                0x00010000
#define PHONESTATE_HEADSETGAIN                  0x00020000
#define PHONESTATE_SUSPEND                      0x00040000
#define PHONESTATE_RESUME                       0x00080000
#define PHONESTATE_DEVSPECIFIC                  0x00100000
#define PHONESTATE_REINIT                       0x00200000
#define PHONESTATE_CAPSCHANGE                   0x00400000      // TAPI v1.4
#define PHONESTATE_REMOVED                      0x00800000      // TAPI v1.4

#define PHONESTATUSFLAGS_CONNECTED              0x00000001
#define PHONESTATUSFLAGS_SUSPENDED              0x00000002

#define STRINGFORMAT_ASCII                      0x00000001
#define STRINGFORMAT_DBCS                       0x00000002
#define STRINGFORMAT_UNICODE                    0x00000003
#define STRINGFORMAT_BINARY                     0x00000004

#define TAPI_REPLY                              WM_USER + 99

#define TAPIERR_CONNECTED                       0L
#define TAPIERR_DROPPED                         -1L
#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_INVALWINDOWHANDLE               -5L
#define TAPIERR_INVALDEVICECLASS                -6L
#define TAPIERR_INVALDEVICEID                   -7L
#define TAPIERR_DEVICECLASSUNAVAIL              -8L
#define TAPIERR_DEVICEIDUNAVAIL                 -9L
#define TAPIERR_DEVICEINUSE                     -10L
#define TAPIERR_DESTBUSY                        -11L
#define TAPIERR_DESTNOANSWER                    -12L
#define TAPIERR_DESTUNAVAIL                     -13L
#define TAPIERR_UNKNOWNWINHANDLE                -14L
#define TAPIERR_UNKNOWNREQUESTID                -15L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L

#define TAPIMAXDESTADDRESSSIZE                  80L
#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L
#define TAPIMAXDEVICECLASSSIZE                  40L
#define TAPIMAXDEVICEIDSIZE                     40L



typedef struct lineaddresscaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressSize;
    DWORD       dwAddressOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwAddressSharing;
    DWORD       dwAddressStates;
    DWORD       dwCallInfoStates;
    DWORD       dwCallerIDFlags;
    DWORD       dwCalledIDFlags;
    DWORD       dwConnectedIDFlags;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwCallStates;
    DWORD       dwDialToneModes;
    DWORD       dwBusyModes;
    DWORD       dwSpecialInfo;
    DWORD       dwDisconnectModes;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwMaxNumOnHoldCalls;
    DWORD       dwMaxNumOnHoldPendingCalls;
    DWORD       dwMaxNumConference;
    DWORD       dwMaxNumTransConf;
    DWORD       dwAddrCapFlags;
    DWORD       dwCallFeatures;
    DWORD       dwRemoveFromConfCaps;
    DWORD       dwRemoveFromConfState;
    DWORD       dwTransferModes;
    DWORD       dwParkModes;
    DWORD       dwForwardModes;
    DWORD       dwMaxForwardEntries;
    DWORD       dwMaxSpecificEntries;
    DWORD       dwMinFwdNumRings;
    DWORD       dwMaxFwdNumRings;
    DWORD       dwMaxCallCompletions;
    DWORD       dwCallCompletionConds;
    DWORD       dwCallCompletionModes;
    DWORD       dwNumCompletionMessages;
    DWORD       dwCompletionMsgTextEntrySize;
    DWORD       dwCompletionMsgTextSize;
    DWORD       dwCompletionMsgTextOffset;

    DWORD       dwAddressFeatures;                              // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwNumCallTreatments;                            // TAPI v2.0
    DWORD       dwCallTreatmentListSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentListOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwMaxCallDataSize;                              // TAPI v2.0
    DWORD       dwCallFeatures2;                                // TAPI v2.0
    DWORD       dwMaxNoAnswerTimeout;                           // TAPI v2.0
    DWORD       dwConnectedModes;                               // TAPI v2.0
    DWORD       dwOfferingModes;                                // TAPI v2.0
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
#endif

} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

typedef struct lineaddressstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumInUse;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwAddressFeatures;
    DWORD       dwNumRingsNoAnswer;
    DWORD       dwForwardNumEntries;
    DWORD       dwForwardSize;
    DWORD       dwForwardOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineagentactivityentry_tag
{
    DWORD       dwID;                                           // TAPI v2.0
    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYENTRY, *LPLINEAGENTACTIVITYENTRY;

typedef struct lineagentactivitylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYLIST, *LPLINEAGENTACTIVITYLIST;

typedef struct lineagentcaps_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwAgentHandlerInfoSize;                         // TAPI v2.0
    DWORD       dwAgentHandlerInfoOffset;                       // TAPI v2.0
    DWORD       dwCapsVersion;                                  // TAPI v2.0
    DWORD       dwFeatures;                                     // TAPI v2.0
    DWORD       dwStates;                                       // TAPI v2.0
    DWORD       dwNextStates;                                   // TAPI v2.0
    DWORD       dwMaxNumGroupEntries;                           // TAPI v2.0
    DWORD       dwAgentStatusMessages;                          // TAPI v2.0
    DWORD       dwNumAgentExtensionIDs;                         // TAPI v2.0
    DWORD       dwAgentExtensionIDListSize;                     // TAPI v2.0
    DWORD       dwAgentExtensionIDListOffset;                   // TAPI v2.0

} LINEAGENTCAPS, *LPLINEAGENTCAPS;

typedef struct lineagentgroupentry_tag
{
    struct
    {
        DWORD   dwGroupID1;                                     // TAPI v2.0
        DWORD   dwGroupID2;                                     // TAPI v2.0
        DWORD   dwGroupID3;                                     // TAPI v2.0
        DWORD   dwGroupID4;                                     // TAPI v2.0

    } GroupID;

    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTGROUPENTRY, *LPLINEAGENTGROUPENTRY;

typedef struct lineagentgrouplist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTGROUPLIST, *LPLINEAGENTGROUPLIST;

typedef struct lineagentstatus_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwGroupListSize;                                // TAPI v2.0
    DWORD       dwGroupListOffset;                              // TAPI v2.0
    DWORD       dwState;                                        // TAPI v2.0
    DWORD       dwNextState;                                    // TAPI v2.0
    DWORD       dwActivityID;                                   // TAPI v2.0
    DWORD       dwActivitySize;                                 // TAPI v2.0
    DWORD       dwActivityOffset;                               // TAPI v2.0
    DWORD       dwAgentFeatures;                                // TAPI v2.0
    DWORD       dwValidStates;                                  // TAPI v2.0
    DWORD       dwValidNextStates;                              // TAPI v2.0

} LINEAGENTSTATUS, *LPLINEAGENTSTATUS;

typedef struct lineappinfo_tag
{
    DWORD       dwMachineNameSize;                              // TAPI v2.0
    DWORD       dwMachineNameOffset;                            // TAPI v2.0
    DWORD       dwUserNameSize;                                 // TAPI v2.0
    DWORD       dwUserNameOffset;                               // TAPI v2.0
    DWORD       dwModuleFilenameSize;                           // TAPI v2.0
    DWORD       dwModuleFilenameOffset;                         // TAPI v2.0
    DWORD       dwFriendlyNameSize;                             // TAPI v2.0
    DWORD       dwFriendlyNameOffset;                           // TAPI v2.0
    DWORD       dwMediaModes;                                   // TAPI v2.0
    DWORD       dwAddressID;                                    // TAPI v2.0

} LINEAPPINFO, *LPLINEAPPINFO;
#endif


typedef struct linedialparams_tag
{
    DWORD       dwDialPause;
    DWORD       dwDialSpeed;
    DWORD       dwDigitDuration;
    DWORD       dwWaitForDialtone;

} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    HLINE       hLine;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressID;
    DWORD       dwBearerMode;
    DWORD       dwRate;
    DWORD       dwMediaMode;
    DWORD       dwAppSpecific;
    DWORD       dwCallID;
    DWORD       dwRelatedCallID;
    DWORD       dwCallParamFlags;
    DWORD       dwCallStates;
    DWORD       dwMonitorDigitModes;
    DWORD       dwMonitorMediaModes;
    LINEDIALPARAMS  DialParams;
    DWORD       dwOrigin;
    DWORD       dwReason;
    DWORD       dwCompletionID;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwCountryCode;
    DWORD       dwTrunk;
    DWORD       dwCallerIDFlags;
    DWORD       dwCallerIDSize;
    DWORD       dwCallerIDOffset;
    DWORD       dwCallerIDNameSize;
    DWORD       dwCallerIDNameOffset;
    DWORD       dwCalledIDFlags;
    DWORD       dwCalledIDSize;
    DWORD       dwCalledIDOffset;
    DWORD       dwCalledIDNameSize;
    DWORD       dwCalledIDNameOffset;
    DWORD       dwConnectedIDFlags;
    DWORD       dwConnectedIDSize;
    DWORD       dwConnectedIDOffset;
    DWORD       dwConnectedIDNameSize;
    DWORD       dwConnectedIDNameOffset;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectionIDSize;
    DWORD       dwRedirectionIDOffset;
    DWORD       dwRedirectionIDNameSize;
    DWORD       dwRedirectionIDNameOffset;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwRedirectingIDSize;
    DWORD       dwRedirectingIDOffset;
    DWORD       dwRedirectingIDNameSize;
    DWORD       dwRedirectingIDNameOffset;
    DWORD       dwAppNameSize;
    DWORD       dwAppNameOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;
    DWORD       dwCommentOffset;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwUserUserInfoSize;
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;
    DWORD       dwLowLevelCompOffset;
    DWORD       dwChargingInfoSize;
    DWORD       dwChargingInfoOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallTreatment;                                // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
#endif

} LINECALLINFO, FAR *LPLINECALLINFO;

typedef struct linecalllist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallsNumEntries;
    DWORD       dwCallsSize;
    DWORD       dwCallsOffset;

} LINECALLLIST, FAR *LPLINECALLLIST;

typedef struct linecallparams_tag               // Defaults:
{
    DWORD       dwTotalSize;                    // ---------
    DWORD       dwBearerMode;                   // voice
    DWORD       dwMinRate;                      // (3.1kHz)
    DWORD       dwMaxRate;                      // (3.1kHz)
    DWORD       dwMediaMode;                    // interactiveVoice
    DWORD       dwCallParamFlags;               // 0
    DWORD       dwAddressMode;                  // addressID
    DWORD       dwAddressID;                    // (any available)
    LINEDIALPARAMS  DialParams;                 // (0, 0, 0, 0)
    DWORD       dwOrigAddressSize;              // 0
    DWORD       dwOrigAddressOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;              // 0
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;                  // 0
    DWORD       dwCommentOffset;
    DWORD       dwUserUserInfoSize;             // 0
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;            // 0
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;             // 0
    DWORD       dwLowLevelCompOffset;
    DWORD       dwDevSpecificSize;              // 0
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwTargetAddressSize;                            // TAPI v2.0
    DWORD       dwTargetAddressOffset;                          // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassSize;                              // TAPI v2.0
    DWORD       dwDeviceClassOffset;                            // TAPI v2.0
    DWORD       dwDeviceConfigSize;                             // TAPI v2.0
    DWORD       dwDeviceConfigOffset;                           // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwNoAnswerTimeout;                              // TAPI v2.0
    DWORD       dwCallingPartyIDSize;                           // TAPI v2.0
    DWORD       dwCallingPartyIDOffset;                         // TAPI v2.0
#endif

} LINECALLPARAMS, FAR *LPLINECALLPARAMS;

typedef struct linecallstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallState;
    DWORD       dwCallStateMode;
    DWORD       dwCallPrivilege;
    DWORD       dwCallFeatures;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallFeatures2;                                // TAPI v2.0
#if WIN32
    SYSTEMTIME  tStateEntryTime;                                // TAPI v2.0
#else
    WORD        tStateEntryTime[8];                             // TAPI v2.0
#endif
#endif

} LINECALLSTATUS, FAR *LPLINECALLSTATUS;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linecalltreatmententry_tag
{
    DWORD       dwCallTreatmentID;                              // TAPI v2.0
    DWORD       dwCallTreatmentNameSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentNameOffset;                      // TAPI v2.0

} LINECALLTREATMENTENTRY, FAR *LPLINECALLTREATMENTENTRY;
#endif


typedef struct linecardentry_tag
{
    DWORD       dwPermanentCardID;
    DWORD       dwCardNameSize;
    DWORD       dwCardNameOffset;
    DWORD       dwCardNumberDigits;                             // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4

} LINECARDENTRY, FAR *LPLINECARDENTRY;

typedef struct linecountryentry_tag
{
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwCountryCode;                                  // TAPI v1.4
    DWORD       dwNextCountryID;                                // TAPI v1.4
    DWORD       dwCountryNameSize;                              // TAPI v1.4
    DWORD       dwCountryNameOffset;                            // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4

} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct linecountrylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumCountries;                                 // TAPI v1.4
    DWORD       dwCountryListSize;                              // TAPI v1.4
    DWORD       dwCountryListOffset;                            // TAPI v1.4

} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linedevcaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwSwitchInfoSize;
    DWORD       dwSwitchInfoOffset;
    DWORD       dwPermanentLineID;
    DWORD       dwLineNameSize;
    DWORD       dwLineNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwAddressModes;
    DWORD       dwNumAddresses;
    DWORD       dwBearerModes;
    DWORD       dwMaxRate;
    DWORD       dwMediaModes;
    DWORD       dwGenerateToneModes;
    DWORD       dwGenerateToneMaxNumFreq;
    DWORD       dwGenerateDigitModes;
    DWORD       dwMonitorToneMaxNumFreq;
    DWORD       dwMonitorToneMaxNumEntries;
    DWORD       dwMonitorDigitModes;
    DWORD       dwGatherDigitsMinTimeout;
    DWORD       dwGatherDigitsMaxTimeout;
    DWORD       dwMedCtlDigitMaxListSize;
    DWORD       dwMedCtlMediaMaxListSize;
    DWORD       dwMedCtlToneMaxListSize;
    DWORD       dwMedCtlCallStateMaxListSize;
    DWORD       dwDevCapFlags;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwAnswerMode;
    DWORD       dwRingModes;
    DWORD       dwLineStates;
    DWORD       dwUUIAcceptSize;
    DWORD       dwUUIAnswerSize;
    DWORD       dwUUIMakeCallSize;
    DWORD       dwUUIDropSize;
    DWORD       dwUUISendUserUserInfoSize;
    DWORD       dwUUICallInfoSize;
    LINEDIALPARAMS  MinDialParams;
    LINEDIALPARAMS  MaxDialParams;
    LINEDIALPARAMS  DefaultDialParams;
    DWORD       dwNumTerminals;
    DWORD       dwTerminalCapsSize;
    DWORD       dwTerminalCapsOffset;
    DWORD       dwTerminalTextEntrySize;
    DWORD       dwTerminalTextSize;
    DWORD       dwTerminalTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwLineFeatures;                                 // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwSettableDevStatus;                            // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
#endif

} LINEDEVCAPS, FAR *LPLINEDEVCAPS;
    
typedef struct linedevstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumOpens;
    DWORD       dwOpenMediaModes;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwLineFeatures;
    DWORD       dwNumCallCompletions;
    DWORD       dwRingMode;
    DWORD       dwSignalLevel;
    DWORD       dwBatteryLevel;
    DWORD       dwRoamMode;
    DWORD       dwDevStatusFlags;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
    DWORD       dwAppInfoSize;                                  // TAPI v2.0
    DWORD       dwAppInfoOffset;                                // TAPI v2.0
#endif

} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

typedef struct lineextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;

typedef struct lineforward_tag
{
    DWORD       dwForwardMode;
    DWORD       dwCallerAddressSize;
    DWORD       dwCallerAddressOffset;
    DWORD       dwDestCountryCode;
    DWORD       dwDestAddressSize;
    DWORD       dwDestAddressOffset;

} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNumEntries;
    LINEFORWARD ForwardList[1];

} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

typedef struct linegeneratetone_tag
{
    DWORD       dwFrequency;
    DWORD       dwCadenceOn;
    DWORD       dwCadenceOff;
    DWORD       dwVolume;

} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} LINEINITIALIZEEXPARAMS, FAR *LPLINEINITIALIZEEXPARAMS;
#endif

typedef struct linelocationentry_tag
{
    DWORD       dwPermanentLocationID;
    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;
    DWORD       dwCountryCode;
    DWORD       dwCityCodeSize;
    DWORD       dwCityCodeOffset;
    DWORD       dwPreferredCardID;

    DWORD       dwLocalAccessCodeSize;                          // TAPI v1.4
    DWORD       dwLocalAccessCodeOffset;                        // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeSize;                   // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeOffset;                 // TAPI v1.4
    DWORD       dwTollPrefixListSize;                           // TAPI v1.4
    DWORD       dwTollPrefixListOffset;                         // TAPI v1.4
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4
    DWORD       dwCancelCallWaitingSize;                        // TAPI v1.4
    DWORD       dwCancelCallWaitingOffset;                      // TAPI v1.4

} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linemediacontrolcallstate_tag
{
    DWORD       dwCallStates;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLCALLSTATE, FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag
{
    DWORD       dwDigit;
    DWORD       dwDigitModes;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag
{
    DWORD       dwMediaModes;
    DWORD       dwDuration;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} LINEMESSAGE, FAR *LPLINEMESSAGE;
#endif

typedef struct linemonitortone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;

} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

typedef struct lineproviderentry_tag
{
    DWORD       dwPermanentProviderID;                          // TAPI v1.4
    DWORD       dwProviderFilenameSize;                         // TAPI v1.4
    DWORD       dwProviderFilenameOffset;                       // TAPI v1.4

} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;

typedef struct lineproviderlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumProviders;                                 // TAPI v1.4
    DWORD       dwProviderListSize;                             // TAPI v1.4
    DWORD       dwProviderListOffset;                           // TAPI v1.4

} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;


#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineproxyrequest_tag
{
    DWORD       dwSize;                                         // TAPI v2.0
    DWORD       dwClientMachineNameSize;                        // TAPI v2.0
    DWORD       dwClientMachineNameOffset;                      // TAPI v2.0
    DWORD       dwClientUserNameSize;                           // TAPI v2.0
    DWORD       dwClientUserNameOffset;                         // TAPI v2.0
    DWORD       dwClientAppAPIVersion;                          // TAPI v2.0
    DWORD       dwRequestType;                                  // TAPI v2.0

    union
    {
    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } SetAgentGroup;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentState;                   // TAPI v2.0
        DWORD                   dwNextAgentState;               // TAPI v2.0

    } SetAgentState;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwActivityID;                   // TAPI v2.0

    } SetAgentActivity;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTCAPS           AgentCaps;                      // TAPI v2.0

    } GetAgentCaps;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTSTATUS         AgentStatus;                    // TAPI v2.0

    } GetAgentStatus;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentExtensionIDIndex;        // TAPI v2.0
        DWORD                   dwSize;                         // TAPI v2.0
        BYTE                    Params[1];                      // TAPI v2.0

    } AgentSpecific;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTACTIVITYLIST   ActivityList;                   // TAPI v2.0

    } GetAgentActivityList;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } GetAgentGroupList;
    }; //ProxyRequestType;

} LINEPROXYREQUEST, *LPLINEPROXYREQUEST;
#endif


typedef struct linereqmakecall_tag
{
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALL, FAR *LPLINEREQMAKECALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmakecallW_tag
{
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALLW, FAR *LPLINEREQMAKECALLW;
#endif

#ifdef UNICODE
#define LINEREQMAKECALL LINEREQMAKECALLW
#endif

typedef struct linereqmediacall_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    char        szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALL, FAR *LPLINEREQMEDIACALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmediacallW_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALLW, FAR *LPLINEREQMEDIACALLW;
#endif

#ifdef UNICODE
#define LINEREQMEDIACALL LINEREQMEDIACALLW
#endif


typedef struct linetermcaps_tag
{
    DWORD       dwTermDev;
    DWORD       dwTermModes;
    DWORD       dwTermSharing;

} LINETERMCAPS, FAR *LPLINETERMCAPS;

typedef struct linetranslatecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumLocations;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    DWORD       dwCurrentLocationID;
    DWORD       dwNumCards;
    DWORD       dwCardListSize;
    DWORD       dwCardListOffset;
    DWORD       dwCurrentPreferredCardID;

} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linetranslateoutput_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwDialableStringSize;
    DWORD       dwDialableStringOffset;
    DWORD       dwDisplayableStringSize;
    DWORD       dwDisplayableStringOffset;
    DWORD       dwCurrentCountry;
    DWORD       dwDestCountry;
    DWORD       dwTranslateResults;

} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct phonebuttoninfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwButtonMode;
    DWORD       dwButtonFunction;
    DWORD       dwButtonTextSize;
    DWORD       dwButtonTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwButtonState;                                  // TAPI v1.4

} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

typedef struct phonecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwPhoneInfoSize;
    DWORD       dwPhoneInfoOffset;
    DWORD       dwPermanentPhoneID;
    DWORD       dwPhoneNameSize;
    DWORD       dwPhoneNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwPhoneStates;
    DWORD       dwHookSwitchDevs;
    DWORD       dwHandsetHookSwitchModes;
    DWORD       dwSpeakerHookSwitchModes;
    DWORD       dwHeadsetHookSwitchModes;
    DWORD       dwVolumeFlags;
    DWORD       dwGainFlags;
    DWORD       dwDisplayNumRows;
    DWORD       dwDisplayNumColumns;
    DWORD       dwNumRingModes;
    DWORD       dwNumButtonLamps;
    DWORD       dwButtonModesSize;
    DWORD       dwButtonModesOffset;
    DWORD       dwButtonFunctionsSize;
    DWORD       dwButtonFunctionsOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwNumSetData;
    DWORD       dwSetDataSize;
    DWORD       dwSetDataOffset;
    DWORD       dwNumGetData;
    DWORD       dwGetDataSize;
    DWORD       dwGetDataOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
    DWORD       dwSettableHandsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableSpeakerHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableHeadsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwMonitoredHandsetHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredSpeakerHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredHeadsetHookSwitchModes;              // TAPI v2.0
#endif

} PHONECAPS, FAR *LPPHONECAPS;

typedef struct phoneextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct phoneinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} PHONEINITIALIZEEXPARAMS, FAR *LPPHONEINITIALIZEEXPARAMS;

typedef struct phonemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD       dwCallbackInstance;                             // TAPI v2.0
    DWORD       dwParam1;                                       // TAPI v2.0
    DWORD       dwParam2;                                       // TAPI v2.0
    DWORD       dwParam3;                                       // TAPI v2.0

} PHONEMESSAGE, FAR *LPPHONEMESSAGE;
#endif

typedef struct phonestatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStatusFlags;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwRingMode;
    DWORD       dwRingVolume;
    DWORD       dwHandsetHookSwitchMode;
    DWORD       dwHandsetVolume;
    DWORD       dwHandsetGain;
    DWORD       dwSpeakerHookSwitchMode;
    DWORD       dwSpeakerVolume;
    DWORD       dwSpeakerGain;
    DWORD       dwHeadsetHookSwitchMode;
    DWORD       dwHeadsetVolume;
    DWORD       dwHeadsetGain;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwOwnerNameSize;
    DWORD       dwOwnerNameOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
#endif

} PHONESTATUS, FAR *LPPHONESTATUS;

typedef struct varstring_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStringFormat;
    DWORD       dwStringSize;
    DWORD       dwStringOffset;

} VARSTRING, FAR *LPVARSTRING;



LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineAddProvider(                                                // TAPI v1.4
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef WIN32
LONG
WINAPI
lineAddProviderW(
    LPCTSTR            lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef UNICODE
#define lineAddProvider lineAddProviderW
#endif

#define lineAddProviderA lineAddProvider
#endif


LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineAgentSpecific(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCTSTR            lpszDestAddressW,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineBlindTransfer lineBlineTransferW
#endif
#define lineBlindTransferA lineBlineTransfer
#endif


LONG
WINAPI
lineClose(
    HLINE               hLine
    );

LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    );

LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineConfigDialog lineConfigDialogW
#endif

#define lineConfigDialogA lineConfigDialog
#endif


LONG
WINAPI
lineConfigDialogEdit(                                           // TAPI v1.4
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#if WIN32
LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCTSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#ifdef UNICODE
#define lineConfigDialogEdit lineConfigDialogEditW
#endif

#define lineConfigDialogEditA lineConfigDialogEdit
#endif

LONG
WINAPI
lineConfigProvider(                                             // TAPI v1.4
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    );

LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCTSTR            lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineDial lineDialW
#endif

#define lineDialA lineDial
#endif

LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineForward lineForwardW
#endif

#define lineForwardA lineForward
#endif

LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#if WIN32
LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCTSTR            lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#ifdef UNICODE
#define lineGatherDigits lineGatherDigitsW
#endif

#define lineGatherDigitsA lineGatherDigits
#endif

LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    );

#if WIN32
LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCTSTR           lpszDigits,
    DWORD               dwDuration
    );

#ifdef UNICODE
#define lineGenerateDigits lineGenerateDigitsW
#endif

#define lineGenerateDigitsA lineGenerateDigits
#endif

LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#if WIN32
LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#ifdef UNICODE
#define lineGetAddressCaps lineGetAddressCapsW
#endif

#define lineGetAddressCapsA lineGetAddressCaps
#endif

LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    );

#if WIN32
LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCTSTR           lpsAddress,
    DWORD               dwSize
    );

#ifdef UNICODE
#define lineGetAddressID lineGetAddressIDW
#endif

#define lineGetAddressIDA lineGetAddressID
#endif

LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#if WIN32
LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#ifdef UNICODE
#define lineGetAddressStatus lineGetAddressStatusW
#endif

#define lineGetAddressStatusA lineGetAddressStatus
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentActivityList(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

LONG
WINAPI
lineGetAgentActivityListW(                                       // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

#ifdef UNICODE
#define lineGetAgentActivityList lineGetAgentActivityListW
#endif

#define lineGetAgentActivityListA lineGetAgentActivityList
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentCaps(                                               // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    );

LONG
WINAPI
lineGetAgentGroupList(                                          // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineGetAgentStatus(                                             // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    );
#endif

LONG
WINAPI
lineGetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#if WIN32
LONG
WINAPI
lineGetAppPriorityW(                                             // TAPI v1.4
    LPCTSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#ifdef UNICODE
#define lineGetAppPriority lineGetAppPriorityW
#endif

#define lineGetAppPriorityA lineGetAppPriority
#endif

LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#if WIN32
LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#ifdef UNICODE
#define lineGetCallInfo lineGetCallInfoW
#endif

#define lineGetCallInfoA lineGetCallInfo
#endif

LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    );
    
LONG
WINAPI
lineGetCountry(                                                 // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#if WIN32
LONG
WINAPI
lineGetCountryW(                                                // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#ifdef UNICODE
#define lineGetCountry lineGetCountryW
#endif

#define lineGetCountryA lineGetCountry
#endif


LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#if WIN32
LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#ifdef UNICODE
#define lineGetDevCaps lineGetDevCapsW
#endif

#define lineGetDevCapsA lineGetDevCaps
#endif

LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineGetDevConfig lineGetDevConfigW
#endif

#define lineGetDevConfigA lineGetDevConfig
#endif

LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCTSTR           lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef UNICODE
#define lineGetIcon lineGetIconW
#endif

#define lineGetIconA lineGetIcon
#endif
    
LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineGetID lineGetIDW
#endif

#define lineGetIDA lineGetID
#endif

LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#if WIN32
LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#ifdef UNICODE
#define lineGetDevStatus lineGetDevStatusW
#endif

#define lineGetDevStatusA lineGetDevStatus
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetMessage(                                                 // TAPI v2.0
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    );

LONG
WINAPI
lineGetProviderList(                                            // TAPI v1.4
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#if WIN32
LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#ifdef UNICODE
#define lineGetProviderList lineGetProviderListW
#endif

#define lineGetProviderListA lineGetProviderList
#endif

LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#if WIN32
LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#ifdef UNICODE
#define lineGetRequest lineGetRequestW
#endif

#define lineGetRequestA lineGetRequest
#endif

LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    );

LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#if WIN32
LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#ifdef UNICODE
#define lineGetTranslateCaps lineGetTranslateCapsW
#endif

#define lineGetTranslateCapsA lineGetTranslateCaps
#endif


LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    );

#if WIN32
LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCTSTR             lpszFileName,
    DWORD               dwMediaMode
    );

#ifdef UNICODE
#define lineHandoff lineHandoffW
#endif

#define lineHandoffA lineHandoff
#endif

LONG
WINAPI
lineHold(
    HCALL               hCall
    );

LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineInitializeEx(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

LONG
WINAPI
lineInitializeExW(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCTSTR                   lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

#ifdef UNICODE
#define lineInitializeEx lineInitializeExW
#endif

#define lineInitializeExA lineInitializeEx
#endif


LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCTSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineMakeCall lineMakeCallW
#endif

#define lineMakeCallA lineMakeCall
#endif

LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    );

LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
lineOpen(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineOpenW(
    HLINEAPP hLineApp, 
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineOpen lineOpenW
#endif

#define lineOpenA lineOpen
#endif

LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#if WIN32
LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCTSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#ifdef UNICODE
#define linePark lineParkW
#endif

#define lineParkA linePark
#endif

LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    );

#if WIN32
LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCTSTR             lpszDestAddress,
    LPCTSTR             lpszGroupID
    );

#ifdef UNICODE
#define linePickup linePickupW
#endif

#define linePickupA linePickup
#endif

LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define linePrepareAddToConference linePrepareAddToConferenceW
#endif

#define linePrepareAddToConferenceA linePrepareAddToConference
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineProxyMessage(                                               // TAPI v2.0
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

LONG
WINAPI
lineProxyResponse(                                              // TAPI v2.0
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    );
#endif

LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCTSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineRedirect lineRedirectW
#endif

#define lineRedirectA lineRedirect
#endif

LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    );

LONG
WINAPI
lineReleaseUserUserInfo(                                        // TAPI v1.4
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveProvider(                                             // TAPI v1.4
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    );

LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    );

LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetAgentActivity(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    );

LONG
WINAPI
lineSetAgentGroup(                                              // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineSetAgentState(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    );
#endif

LONG
WINAPI
lineSetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    );

#if WIN32
LONG
WINAPI
lineSetAppPriorityW(                                             // TAPI v1.4
    LPCTSTR           lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCTSTR           lpszExtensionName,
    DWORD               dwPriority
    );

#ifdef UNICODE
#define lineSetAppPriority lineSetAppPriorityW
#endif

#define lineSetAppPriorityA lineSetAppPriority
#endif

LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallData(                                                // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallQualityOfService(                                    // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
WINAPI
lineSetCallTreatment(                                           // TAPI v2.0
    HCALL               hCall,
    DWORD               dwTreatment
    );
#endif

LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    );

LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineSetDevConfig lineSetDevConfigW
#endif

#define lineSetDevConfigA lineSetDevConfig
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetLineDevStatus(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );
#endif

LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList, 
    DWORD                       dwCallStateNumEntries
    );

LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    );

LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    );

#if WIN32
LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCTSTR           lpszAddressInW,
    DWORD               dwTollListOption
    );

#ifdef UNICODE
#define lineSetTollList lineSetTollListW
#endif

#define lineSetTollListA lineSetTollList
#endif


LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineSetupConference lineSetupConferenceW
#endif

#define lineSetupConferenceA lineSetupConference
#endif

LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineSetupTransfer lineSetupTransferW
#endif

#define lineSetupTransferA lineSetupTransfer
#endif

LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    );

LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    );

LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#if WIN32
LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCTSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#ifdef UNICODE
#define lineTranslateAddress lineTranslateAddressW
#endif

#define lineTranslateAddressA  lineTranslateAddress
#endif

LONG
WINAPI
lineTranslateDialog(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    );

#if WIN32
LONG
WINAPI
lineTranslateDialogW(                                            // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCTSTR           lpszAddressIn
    );

#ifdef UNICODE
#define lineTranslateDialog lineTranslateDialogW
#endif

#define lineTranslateDialogA  lineTranslateDialog
#endif

LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    );

LONG
WINAPI
lineUnhold(
    HCALL               hCall
    );

LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    );

#if WIN32
LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCTSTR           lpszDestAddress
    );

#ifdef UNICODE
#define lineUnpark lineUnparkW
#endif

#define lineUnparkA lineUnpark
#endif



LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    );

LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define phoneConfigDialog phoneConfigDialogW
#endif

#define phoneConfigDialogA phoneConfigDialog
#endif

LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#ifdef UNICODE
#define phoneGetButtonInfo phoneGetButtonInfoW
#endif

#define phoneGetButtonInfoA phoneGetButtonInfo
#endif

LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#if WIN32
LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#ifdef UNICODE
#define phoneGetDevCaps phoneGetDevCapsW
#endif

#define phoneGetDevCapsA phoneGetDevCaps
#endif

LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    );

LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCTSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef UNICODE
#define phoneGetIcon phoneGetIconW
#endif

#define phoneGetIconA phoneGetIcon
#endif

LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCTSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define phoneGetID phoneGetIDW
#endif

#define phoneGetIDA phoneGetID
#endif

LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneGetMessage(                                                // TAPI v2.0
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

#if WIN32
LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );


#ifdef UNICODE
#define phoneGetStatus phoneGetStatusW
#endif

#define phoneGetStatusA phoneGetStatus
#endif

LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    );

LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if WIN32
LONG
WINAPI
phoneInitializeW(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCTSTR           lpszAppNameW,
    LPDWORD             lpdwNumDevs
    );

#ifdef UNICODE
#define phoneInitialize phoneInitializeW
#endif

#define phoneInitializeA phoneInitialize
#endif


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneInitializeEx(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

LONG
WINAPI
phoneInitializeExW(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCTSTR                   lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

#ifdef UNICODE
#define phoneInitializeEx phoneInitializeExW
#endif

#define phoneInitializeExA phoneInitializeEx
#endif

LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD               dwCallbackInstance,
    DWORD               dwPrivilege
    );

LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#ifdef UNICODE
#define phoneSetButtonInfo phoneSetButtonInfoW
#endif

#define phoneSetButtonInfoA phoneSetButtonInfo
#endif

LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    );



LONG
WINAPI
tapiGetLocationInfo(
    LPSTR               lpszCountryCode,
    LPSTR               lpszCityCode
    );

#if WIN32
LONG
WINAPI
tapiGetLocationInfoW(
    LPTSTR               lpszCountryCodeW,
    LPTSTR               lpszCityCodeW
    );

#ifdef UNICODE
#define tapiGetLocationInfo tapiGetLocationInfoW
#else
#define tapiGetLocationInfoA tapiGetLocationInfo
#endif
#endif
    

LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    );

LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMakeCallW(
    LPCTSTR            lpszDestAddress,
    LPCTSTR            lpszAppName,
    LPCTSTR            lpszCalledParty,
    LPCTSTR            lpszComment
    );

#ifdef UNICODE
#define tapiRequestMakeCall tapiRequestMakeCallW
#endif

#define tapiRequestMakeCallA tapiRequestMakeCall
#endif
    
LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCTSTR             lpszDeviceClass,
    LPCTSTR             lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCTSTR             lpszDestAddress,
    LPCTSTR             lpszAppName,
    LPCTSTR             lpszCalledParty,
    LPCTSTR             lpszComment
    );

#ifdef UNICODE
#define tapiRequestMediaCall tapiRequestMediaCallW
#endif

#define tapiRequestMediaCallA tapiRequestMediaCall
#endif




#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\semaphor.h ===
//****************************************************************************
//
//  File:       sempahor.h
//
//  Content:    This is the include file that contains the semaphore names
//              used by the various ICW components to ensure that only
//              one component is running at a time
//              (with the following expections:
//                -- with icwconn1 running, isignup and icwconn2 can execute.
//                -- with isignup running, icwconn2 can execute.
//
//  History:
//  12/3/96 jmazner     Created for Normandy bugs 12140, 12088
//              
//
//  Copyright (c) Microsoft Corporation 1996
//
//****************************************************************************


#define ICWCONN1_SEMAPHORE TEXT("Internet Connection Wizard ICWCONN1.EXE")
#define ICW_ELSE_SEMAPHORE TEXT("Internet Connection Wizard Non ICWCONN1 Component")

#define DIALOG_CLASS_NAME   TEXT("#32770")

BOOL IsAnotherComponentRunning32(BOOL bCreatedSemaphore);


/******

                                    Allow this component to execute?
                        /------------------------------------------------------------\
                        | ICWCONN1  | ISIGNUP   | ISIGN.INS | ICWCONN2  | INETWIZ
            /   --------|-------------------------------------------------------------
            |           |           |           |           |           |
            |   ICWCONN1|   no      |   _YES_   |   _YES_   |   _YES_   |   no
            |           |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
if this     |           |           |           |           |           |
component   |   ISIGNUP |   no      |   no      |   _YES_   |   _YES_   |   no      
is running  |           |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
            |           |           |           |           |           |
            |   ISIGNUP |   no      |   no      |   _YES_   |   _YES_   |   no      
            |      .INS |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
            |           |           |           |           |           |
            |   ICWCONN2|   no      |   no      |   _YES_   |   _YES_   |   no      
            |           |           |           |           |           |
            |   --------|-----------|-----------|-----------|-----------|--------------
            |           |           |           |           |           |
            |   INETWIZ |   no      |   no      |   _YES_   |   _YES_   |   no      
            |           |           |           |           |           |
            \   --------|-----------|-----------|-----------|-----------|--------------


Implement this using two semaphores, one for ICWCONN1, and one for everything else (ICW_ELSE)
On startup, each component set its semaphore, then checks what other components are running.

Conn1:          check for ICWCONN1, ICW_ELSE
Isignup:        check for ICW_ELSE
Isignup .ins:   no checks
ICWCONN2:       no checks
Inetwiz:        Check for ICWCONN1, ICW_ELSE

******/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\webvwids.h ===
#ifndef _INC_WEBVWIDS_H
#define _INC_WEBVWIDS_H

// {99BA6178-219E-11D2-AE1B-0000F87734F0}
DEFINE_GUID(IID_IICWWebView, 0x99ba6178, 0x219e, 0x11d2, 0xae, 0x1b, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// ICWUTILS's WebView CLSID
// This is used to create an instance of the WebView object
// {99BA617B-219E-11D2-AE1B-0000F87734F0}
DEFINE_GUID(CLSID_ICWWEBVIEW, 0x99ba617b, 0x219e, 0x11d2, 0xae, 0x1b, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {3B79EEAC-2728-11d2-8D58-0000F87734F0}
DEFINE_GUID(IID_IICWWalker, 0x3b79eeac, 0x2728, 0x11d2, 0x8d, 0x58, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {3B79EEAD-2728-11d2-8D58-0000F87734F0}
DEFINE_GUID(CLSID_ICWWALKER, 0x3b79eead, 0x2728, 0x11d2, 0x8d, 0x58, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);


// {F832C2B5-312D-11d2-8D5F-0000F87734F0}
DEFINE_GUID(IID_IICWGifConvert, 0xf832c2b5, 0x312d, 0x11d2, 0x8d, 0x5f, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {F832C2B2-312D-11d2-8D5F-0000F87734F0}
DEFINE_GUID(CLSID_ICWGIFCONVERT, 0xf832c2b2, 0x312d, 0x11d2, 0x8d, 0x5f, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {29548506-3886-11d2-8D63-0000F87734F0}
DEFINE_GUID(IID_IICWISPData, 0x29548506, 0x3886, 0x11d2, 0x8d, 0x63, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

// {29548507-3886-11d2-8D63-0000F87734F0}
DEFINE_GUID(CLSID_ICWISPDATA, 0x29548507, 0x3886, 0x11d2, 0x8d, 0x63, 0x0, 0x0, 0xf8, 0x77, 0x34, 0xf0);

#endif // _INC_WEBVWDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#ifndef WIN16    
#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)
#else
#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtr((ptr), (UINT)(cch))) ? \
    (TraceMsg(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtr((ptr), (UINT)(cch))) ? \
    (TraceMsg(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)
#endif

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// Hack for components like shlwapi who don't #include commctrl.h
#ifdef DPA_GetPtrCount
BOOL
IsValidHDPA(
    HDPA hdpa);

BOOL
IsValidHDSA(
    HDSA hdsa);
#endif


// For components like comctl32 who don't #include shlobj.h
#ifdef _SHLOBJ_H_
BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl);
#endif

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\webview.h ===
#ifndef _INC_WEBVIEW_H
#define _INC_WEBVIEW_H

#include <exdisp.h>
#include "icwhelp.h"
#include "appdefs.h"

interface IICWWebView : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE HandleKey         (LPMSG lpMsg)                    = 0;
        virtual HRESULT STDMETHODCALLTYPE ConnectToWindow   (HWND hWnd, DWORD dwHtmPageType) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetFocus          ()                               = 0;
#ifndef UNICODE
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML       (TCHAR* lpszURL)                 = 0;
#endif
        virtual HRESULT STDMETHODCALLTYPE DisplayHTML       (BSTR bstrURL)                   = 0;
        virtual HRESULT STDMETHODCALLTYPE SetHTMLColors     (LPTSTR lpszForeGrndColor, LPTSTR lpszBkGrndColor)    = 0;
        virtual HRESULT STDMETHODCALLTYPE SetHTMLBackgroundBitmap (HBITMAP hbm, LPRECT lpRC) = 0;
        virtual HRESULT STDMETHODCALLTYPE get_BrowserObject (IWebBrowser2** lpWebBrowser)    = 0;    
};

interface IICWWalker : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Walk                     ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE AttachToDocument         (IWebBrowser2* lpWebBrowser)    = 0;
        virtual HRESULT STDMETHODCALLTYPE AttachToMSHTML           (BSTR bstrURL)                  = 0;
        virtual HRESULT STDMETHODCALLTYPE Detach                   ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE InitForMSHTML            ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE TermForMSHTML            ()                              = 0;
        virtual HRESULT STDMETHODCALLTYPE LoadURLFromFile          (BSTR bstrURL)                  = 0;
        virtual HRESULT STDMETHODCALLTYPE ExtractUnHiddenText      (BSTR* pbstrText)               = 0;
        virtual HRESULT STDMETHODCALLTYPE ProcessOLSFile           (IWebBrowser2* lpWebBrowser)    = 0;
        virtual HRESULT STDMETHODCALLTYPE get_PageType             (LPDWORD pdwPageType)           = 0;
        virtual HRESULT STDMETHODCALLTYPE get_IsQuickFinish        (BOOL* pbIsQuickFinish)         = 0;
        virtual HRESULT STDMETHODCALLTYPE get_PageFlag             (LPDWORD pdwPageFlag)           = 0;
        virtual HRESULT STDMETHODCALLTYPE get_PageID               (BSTR* pbstrPageID)             = 0;
        virtual HRESULT STDMETHODCALLTYPE get_URL                  (LPTSTR lpszURL, BOOL bForward) = 0;
        virtual HRESULT STDMETHODCALLTYPE get_FirstFormQueryString (LPTSTR lpszQuery)              = 0;
        virtual HRESULT STDMETHODCALLTYPE get_IeakIspFile          (LPTSTR lpszIspFile)            = 0;
};

interface IICWGifConvert : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE GifToIcon(TCHAR * pszFile, UINT nIconSize, HICON* phIcon) = 0;
        virtual HRESULT STDMETHODCALLTYPE GifToBitmap(TCHAR * pszFile, HBITMAP* phBitmap) = 0;
        
};

enum IPSDataElements
{
    ISPDATA_USER_FIRSTNAME = 0,
    ISPDATA_USER_LASTNAME,
    ISPDATA_USER_ADDRESS,
    ISPDATA_USER_MOREADDRESS,
    ISPDATA_USER_CITY,
    ISPDATA_USER_STATE,
    ISPDATA_USER_ZIP,
    ISPDATA_USER_PHONE,
    ISPDATA_AREACODE,
    ISPDATA_COUNTRYCODE,
    ISPDATA_USER_FE_NAME,
    ISPDATA_PAYMENT_TYPE,
    ISPDATA_PAYMENT_BILLNAME,
    ISPDATA_PAYMENT_BILLADDRESS,
    ISPDATA_PAYMENT_BILLEXADDRESS,
    ISPDATA_PAYMENT_BILLCITY,
    ISPDATA_PAYMENT_BILLSTATE,
    ISPDATA_PAYMENT_BILLZIP,
    ISPDATA_PAYMENT_BILLPHONE,
    ISPDATA_PAYMENT_DISPLAYNAME,
    ISPDATA_PAYMENT_CARDNUMBER,
    ISPDATA_PAYMENT_EXMONTH,
    ISPDATA_PAYMENT_EXYEAR,
    ISPDATA_PAYMENT_CARDHOLDER,
    ISPDATA_SIGNED_PID,
    ISPDATA_GUID,
    ISPDATA_OFFERID,
    ISPDATA_BILLING_OPTION,
    ISPDATA_PAYMENT_CUSTOMDATA,
    ISPDATA_USER_COMPANYNAME,
    ISPDATA_ICW_VERSION
};

enum ISPDATAValidateLevels
{
    ISPDATA_Validate_None = 0,
    ISPDATA_Validate_DataPresent,
    ISPDATA_Validate_Content
};
    
interface IICWISPData : public IUnknown
{
    public:
        // IICWISPData
        virtual BOOL STDMETHODCALLTYPE      PutDataElement(WORD wElement, LPCTSTR lpValue, WORD wValidateLevel) = 0;
        virtual LPCTSTR STDMETHODCALLTYPE   GetDataElement(WORD wElement) = 0;
        virtual void STDMETHODCALLTYPE      PutValidationFlags(DWORD dwFlags) = 0;
        virtual void STDMETHODCALLTYPE      Init(HWND   hWndParent) = 0;
        virtual HRESULT STDMETHODCALLTYPE   GetQueryString(BSTR bstrBaseURL, BSTR *lpReturnURL) = 0;
};

#endif // _INC_WEBVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\wizdebug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// debugging macros

#undef ASSERT
#undef DEBUGMSG

#ifdef DEBUG

// component name define
#ifndef SZ_COMPNAME
#define SZ_COMPNAME
#endif  // SZ_COMPNAME

static void _AssertFailedSz(LPCSTR pszText,LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = SZ_COMPNAME "%s (%s,line %d)\r\n";

    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
    {
    if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
        break;
    }
    wsprintf(ach, szAssertFailed, pszText,psz, line);
    OutputDebugString(ach);
}

static void _AssertFailed(LPCSTR pszFile, int line)
{
    static char szAssertFailed[] = "Assertion failed";
    _AssertFailedSz(szAssertFailed,pszFile,line);

}

static void cdecl _DebugMsg(LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  
    va_list args;

    va_start(args,pszMsg);
    wvsprintf(ach, pszMsg, args);
    //wvsprintf(ach, pszMsg, (LPSTR)(&pszMsg + 1));
    OutputDebugString(SZ_COMPNAME);
    OutputDebugString(ach);
    OutputDebugString("\r\n");
}

static void cdecl _DebugTrap(LPCSTR pszMsg, ...)
{
    _DebugMsg(pszMsg);
    DebugBreak();
    //_asm {int 3};
}

//#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERT(f)   {if (!(f)) { _AssertFailed(__FILE__, __LINE__);  DebugBreak(); } }
//#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  _asm {int 3}; } }
#define ASSERTSZ(f,s)   {if (!(f)) { _AssertFailedSz(s,__FILE__, __LINE__);  DebugBreak(); } }
#define DEBUGMSG    _DebugMsg
#define DEBUGTRAP       _DebugTrap

#else // DEBUG

#define ASSERT(f)
#define ASSERTSZ(f,s)
#define DEBUGMSG    1 ? (void)0 : (void)
#define DEBUGTRAP   1 ? (void)0 : (void)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\struct.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
// STRUCT.H - global data structures that need to go through thunk layers
//

//  HISTORY:
//  
//  11/20/94    jeremys     Created.
//  96/03/11  markdu    Added fDisallowTCPInstall and fDisallowRNAInstall.
//            These are used to prevent installing the components, and
//            since we want to allow the installation by default, setting
//            the structure to zeros gives default behaviour with these flags.
//  96/03/12  markdu    Removed nModems since we enumerate modems
//            with RNA now.
//

// Note: this structure is separated out from the main global inc file
// because #define's and other valid C syntax aren't valid for the thunk
// compiler, which just needs the structure.

// structure to hold information about client software configuration
typedef struct tagCLIENTCONFIG {
    BOOL fTcpip;            // TCP/IP currently installed

    BOOL fNetcard;          // net card installed
    BOOL fNetcardBoundTCP;  // TCP/IP bound to net card

    BOOL fPPPDriver;        // PPP driver installed
    BOOL fPPPBoundTCP;      // TCP/IP bound to PPP driver

    BOOL fMailInstalled;    // microsoft mail (exchange) files installed
    BOOL fRNAInstalled;     // RNA (remote access) files installed
    BOOL fMSNInstalled;     // Microsoft network files installed
    BOOL fMSN105Installed;  // MSN 1.05 (Rome) files installed
    BOOL fInetMailInstalled;    // Internet mail (rt. 66) files installed
  BOOL fDisallowTCPInstall; // Do not allow TCP/IP to be installed
  BOOL fDisallowRNAInstall; // Do not allow RNA to be installed
} CLIENTCONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inc\wizglob.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
// WIZGLOB.H -  global data structures and defines for all wizard components
//              (32-bit exe, 32-bit dll, 16-bit dll)

//  HISTORY:
//  
//  11/20/94    jeremys     Created.
//

#ifndef _WIZGLOB_H_
#define _WIZGLOB_H_

#ifndef SETUPX_INC
typedef UINT RETERR;             // setupx Return Error code type.
#endif  // SETUPX_INC

// structure to hold information about client software configuration
#include <struct.h> // separated out so thunk compiler can get at

typedef CLIENTCONFIG FAR * LPCLIENTCONFIG;
typedef char CHAR;
typedef BOOL FAR * LPBOOL;

// component defines for InstallComponent

#define IC_PPPMAC           0x0001      // install PPPMAC
#define IC_TCPIP            0x0002      // install TCP/IP
#define IC_INSTALLFILES     0x0003      // install files, etc from INF

// dwParam bits for IC_INSTALLFILES
#define ICIF_MAIL           0x0001      // install mail files
#define ICIF_RNA            0x0002      // install RNA files
#define ICIF_MSN            0x0004      // install Microsoft Network files
#define ICIF_MSN105         0x0008      // install MSN 1.05 (Rome) files
#define ICIF_INET_MAIL      0x0010      // install Internet mail files

// INSTANCE_ defines for TCP/IP configuration apis
#define INSTANCE_NETDRIVER      0x0001
#define INSTANCE_PPPDRIVER      0x0002
#define INSTANCE_ALL            (INSTANCE_NETDRIVER | INSTANCE_PPPDRIVER)

// PROT_ defines for protocol types
#define PROT_TCPIP              0x0001
#define PROT_IPX                0x0002
#define PROT_NETBEUI            0x0004

#define NEED_RESTART            ((WORD) -1)

#endif // _WIZGLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"

/*******************************************************************

  NAME:    InstallTCPIP

  SYNOPSIS:  Installs MS TCP/IP 

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallTCPIP(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_TCPIP,0);
}

/*******************************************************************

  NAME:    InstallPPPMAC

  SYNOPSIS:  Installs PPPMAC (PPP driver)

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallPPPMAC(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_PPPMAC,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\cfgapi.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  CFGAPI.C - Functions for exported config API.
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Added lpGetLastInstallErrorText.
//

#include "pch.hpp"

UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

extern "C" DWORD WINAPI IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc)
{
  if (lpszErrorDesc)
  {
    lstrcpyn(lpszErrorDesc, gpszLastErrorText, cbErrorDesc);
    return lstrlen(lpszErrorDesc);
  }
  else
  {
    return 0;
  }
}


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  History:	5/8/97 ChrisK Added INSTALLLAN,INSTALLDIALUP,INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgNeedInetComponents()");

  ASSERT(lpfNeedComponents);

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  DWORD dwErrCls;
  UINT err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
    return err;
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
    // need TCP/IP present and bound to PPP driver
    // if (!ClientConfig.fPPPBoundTCP)
    //
    // vyung - PPPBound TCP is not able to be installed through
    // ICW. So here we only check the TCPIP flag.
    if (!ClientConfig.fTcpip)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // need PPPMAC and RNA files if using modem
    if (!ClientConfig.fRNAInstalled ||
      !ClientConfig.fPPPDriver)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // need Exchange if not installed and user wants to install mail
  if ((dwfOptions & ICFG_INSTALLMAIL) &&
    (!ClientConfig.fMailInstalled || !ClientConfig.fInetMailInstalled))
  {
    if (lpfNeedComponents)
    {
      *lpfNeedComponents = TRUE;
    }
    return ERROR_SUCCESS;
  }

  //
  // ChrisK	5/8/97
  // check if we have a bound LAN adapter
  //
  if (dwfOptions & ICFG_INSTALLLAN)
  {
	  if (!ClientConfig.fNetcard ||
		  !ClientConfig.fNetcardBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if we have a bound Dial up adapter
  //
  if (dwfOptions & ICFG_INSTALLDIALUP)
  {
	  if (!ClientConfig.fPPPDriver ||
		  !ClientConfig.fPPPBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if TCP is install at all on this system
  //
  if (dwfOptions & ICFG_INSTALLTCPONLY)
  {
	  if (!ClientConfig.fTcpip)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  // no extra drivers needed
  if (lpfNeedComponents)
  {
    *lpfNeedComponents = FALSE;
  }
  return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//              
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart)
{
  RETERR err;
  DWORD dwFiles = 0;
  BOOL  fInitNetMAC = FALSE;
  BOOL  fNeedTCPIP=FALSE;
  BOOL  fNeedPPPMAC=FALSE;
  BOOL  fNeedToRemoveTCPIP=FALSE;
  BOOL  fNeedReboot = FALSE;
  DWORD dwErrCls;
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgInstallInetComponents()");

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
    return err;
  }

  // see if we initially have any kind of net card
  fInitNetMAC = (ClientConfig.fNetcard | ClientConfig.fPPPDriver);

  // install files we need

  // install mail if user wants it and not already installed
  if (dwfOptions & ICFG_INSTALLMAIL)
  {
    // need mail files (capone)? 
    if (!ClientConfig.fMailInstalled)
    {
      DEBUGMSG("Installing Exchange files");
      dwFiles |= ICIF_MAIL;
    }

    // need internet mail files (rt 66)?
    if (!ClientConfig.fInetMailInstalled)
    {
      DEBUGMSG("Installing Internet Mail files");
      dwFiles |= ICIF_INET_MAIL;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install RNA if user is connecting over modem and RNA
    // not already installed
    if (!ClientConfig.fRNAInstalled)
    {
      DEBUGMSG("Installing RNA files");
      dwFiles |= ICIF_RNA;
    }
  }

  if (dwFiles)
  {
    {
      WAITCURSOR WaitCursor;  // show hourglass
      // install the component files
      err = InstallComponent(hwndParent,IC_INSTALLFILES,
        dwFiles);
      if (err == NEED_RESTART)
      {
        DEBUGMSG("Setting restart flag");
        // set restart flag so we restart the system at end
        fNeedReboot = TRUE;
        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      // force an update of the dialog
      if (hwndParent)
      {
        HWND hParent = GetParent(hwndParent);
        UpdateWindow(hParent ? hParent : hwndParent);
      }

      // runonce.exe may get run at next boot, twiddle the
      // registry to work around a bug where it trashes the wallpaper
      PrepareForRunOnceApp();
    }

    if (err != OK)
    {
      LoadSz(IDS_ERRInstallFiles, gpszLastErrorText, MAX_ERROR_TEXT);
      return err;
    }

    WAITCURSOR WaitCursor;  // show hourglass

    // do some extra stuff if we just installed mail
    if (dwFiles & ICIF_MAIL)
    {
      // .inf file leaves an entry in the registry to run
      // MS Exchange wizard, which we don't need since we'll be
      // configuring exchange ourselves.  Remove the registry
      // entry.
      RemoveRunOnceEntry(IDS_MAIL_WIZARD_REG_VAL);

      // run mlset32, Exchange setup app that it needs to have run.
      // need to display error if this fails, this is fairly important.
      err=RunMlsetExe(hwndParent);
      if (err != ERROR_SUCCESS)
      {
        LoadSz(IDS_ERRInstallFiles, gpszLastErrorText, MAX_ERROR_TEXT);
        return err;
      }
    }

    // run the group converter to put the Inbox icon on desktop,
    // put Exchange, RNA et al on start menu
    CHAR szExecGrpconv[SMALL_BUF_LEN],szParam[SMALL_BUF_LEN];
    LoadSz(IDS_EXEC_GRPCONV,szExecGrpconv,sizeof(szExecGrpconv));
    LoadSz(IDS_EXEC_GRPCONV_PARAM,szParam,sizeof(szParam));
    ShellExecute(NULL,NULL,szExecGrpconv,szParam,NULL,SW_SHOW);

  }

  // only install PPPMAC if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install PPPMAC if not already installed
    // Note that we have to install PPPMAC *before* TCP/IP, to work
    // in the case where the user has no net installed to start with.
    // Otherwise when we install TCP/IP, user gets prompted by net setup
    // for their net card; net setup doesn't like the idea of TCP/IP lying
    // around without something to bind it to.
    fNeedPPPMAC = (!ClientConfig.fPPPDriver);
    if (fNeedPPPMAC)
    {
      DEBUGMSG("Installing PPPMAC");

      // make up a computer and workgroup name if not already set, so
      // user doesn't get prompted
      GenerateComputerNameIfNeeded();
      
      err = InstallPPPMAC(hwndParent);

      //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing PPPMAC.

	  //
	  // ChrisK 5/29/97 Olympus 4692
	  // Even if we just rebind PPPMAC we still need to restart the machine.
	  //
      if (err == NEED_RESTART || err == OK)
      {
        // set restart flag so we restart the system at end
        DEBUGMSG("Setting restart flag");
        fNeedReboot = TRUE;

        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      if (err != OK)
      {
        LoadSz(IDS_ERRInstallPPPMAC, gpszLastErrorText, MAX_ERROR_TEXT);
        return err;
      }

      // when we install PPPMAC, if there is another net card then PPPMAC
      // will automatically "grow" all the protocols that were bound to the
      // net card.  Strip these off... (netbeui and IPX)
      RETERR errTmp = RemoveProtocols(hwndParent,INSTANCE_PPPDRIVER,
        PROT_NETBEUI | PROT_IPX);
      ASSERT(errTmp == OK);
    }
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
      CLIENTCONFIG  newClientConfig;

      // read the client configuration again, since installing PPP might have
      // installed TCP/IP
      ZeroMemory(&newClientConfig,sizeof(CLIENTCONFIG));
      DWORD dwErrCls;
      UINT err=GetConfig(&newClientConfig,&dwErrCls);
      if (err != OK)
      {
        LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
        return err;
      }
  
     // figure out if we need to install TCP/IP
     // BUGBUG - only put TCP/IP on appropriate type of card (net card
     // or PPP adapter)
     // user is connecting via modem, need TCP if not already present
     // and bound to PPPMAC.  Want to bind to PPP adapters,
    fNeedTCPIP = !newClientConfig.fPPPBoundTCP;
    if (fNeedTCPIP && newClientConfig.fNetcard &&
      !newClientConfig.fNetcardBoundTCP)
    {
      // if we have to add TCP to PPP driver, then check if TCP is already
      // on netcard.  If not, then TCP is going to glom on to netcard as
      // well as PPP driver when we install it, need to remove it from
      // netcard later.
      fNeedToRemoveTCPIP= TRUE;
    }

    // special case: if there were any existing instances of TCP/IP and
    // we just added PPPMAC then we don't need to install TCP/IP --
    // when the PPPMAC adapter got added it automatically gets an instance
    // of all installed protocols (incl. TCP/IP) created for it
    if (newClientConfig.fTcpip && fNeedPPPMAC)
    {
      fNeedTCPIP = FALSE;
    }
  } // if (dwfOptions & ICFG_INSTALLTCP)

  // install TCP/IP if necessary
  if (fNeedTCPIP)
  {
    DEBUGMSG("Installing TCP/IP");
    // call out to device manager to install TCP/IP
    err = InstallTCPIP(hwndParent);      

    //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing TCP/IP.
    if (err == NEED_RESTART)
    {
      // NEED_REBOOT also implies success, so set ret code to OK
      // Reboot flag is set below ALWAYS.  Should really be set here,
      // but we don't want to suddenly stop rebooting in cases
      // where we used to reboot, even if not needed.
      err = OK;
    }

     if (err != OK)
     {
      LoadSz(IDS_ERRInstallTCPIP, gpszLastErrorText, MAX_ERROR_TEXT);
      return err;
    }

    if (fNeedToRemoveTCPIP)
    {
      // remove TCPIP that may have glommed onto net drivers other
      // than the one we intend it for
      UINT uErrTmp;
      uErrTmp=RemoveProtocols(hwndParent,INSTANCE_NETDRIVER,PROT_TCPIP);
      ASSERT(uErrTmp == OK);
    }

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // if we just installed TCP/IP or PPPMAC, then adjust bindings 
  if (fNeedPPPMAC || fNeedTCPIP)
  {
    UINT uErrTmp;

    // if file sharing (vserver) is installed, TCP/IP will bind
    // to it by default.  This is bad, user could be sharing
    // files to Internet without knowing it.  Unbind VSERVER
    // from TCP/IP instances that may used to connect to Internet
    // (instances of type INSTANCE_PPPDRIVER)
    uErrTmp = IcfgTurnOffFileSharing(INSTANCE_PPPDRIVER, hwndParent);
    ASSERT (uErrTmp == ERROR_SUCCESS);

    // unbind TCP/IP from VREDIR, if bound on this card type
    BOOL fBound;
    uErrTmp = DetectModifyTCPIPBindings(INSTANCE_PPPDRIVER,szVREDIR,
      TRUE,&fBound);
    ASSERT(uErrTmp == ERROR_SUCCESS);
  }

  // refresh the client configuration info
  err = GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    LoadSz(IDS_ERRReadConfig, gpszLastErrorText, MAX_ERROR_TEXT);
    return err;
  }

  // do some special handling if there were *no* netcard devices
  // (net cards or PPP drivers) initially installed
  if (!fInitNetMAC)
  {
    ASSERT(fNeedPPPMAC);  // should have just installed PPPMAC

    // net setup adds some extra net components "by default" when
    // we add PPPMAC and there are no net card devices, go kill them
    // off.
    RETERR reterr = RemoveUnneededDefaultComponents(hwndParent);
    ASSERT(reterr == OK);

    // since there were no net card devices to begin with, we need
    // to restart the system later.  (the NDIS VxD is a static VxD
    // which needs to run, only gets added when you install a net card.)

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // tell caller whether we need to reboot or not
  if (lpfNeedsRestart)
  {
    *lpfNeedsRestart = fNeedReboot;
  }
  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    GetConfig

  SYNOPSIS:  Retrieves client configuration

********************************************************************/
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls)
{
  ASSERT(pClientConfig);
  ASSERT(pdwErrCls);

  // get most the client configuration from 16-bit dll
  UINT uRet = GetClientConfig(pClientConfig);
  if (uRet != OK) {
    // GetClientConfig returns SETUPX error codes
    *pdwErrCls = ERRCLS_SETUPX;
  } 

  return uRet;
}

//*******************************************************************
//
//  FUNCTION:   IcfgStartServices
//
//  PURPOSE:    This is a NOP designed to maintain parity with the NT
//              version (icfgnt.dll).
//
//  PARAMETERS: none
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgStartServices()
{
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\cfgdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (C) Microsoft Corp., 1991-1992      **/
/*****************************************************************/ 

//
//  CFGDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/27  markdu  Initialize and destroy gpszLastErrorText.
//

#include "pch.hpp"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
LPSTR gpszLastErrorText=NULL;
#pragma data_seg(DATASEG_DEFAULT)

typedef UINT RETERR;

// prototypes for functions we thunk to
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  extern RETERR __stdcall GetClientConfig16(LPCLIENTCONFIG pClientConfig);
  extern UINT __stdcall InstallComponent16(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
  extern RETERR __stdcall BeginNetcardTCPIPEnum16(VOID);
  extern BOOL __stdcall GetNextNetcardTCPIPNode16(LPSTR pszTcpNode,WORD cbTcpNode,
    DWORD dwFlags);
  extern VOID __stdcall GetSETUPXErrorText16(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
  extern RETERR __stdcall RemoveProtocols16(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
  extern RETERR __stdcall RemoveUnneededDefaultComponents16(HWND hwndParent);
  extern RETERR __stdcall DoGenInstall16(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);
  extern RETERR __stdcall SetInstallSourcePath16(LPCSTR szSourcePath);

  BOOL WINAPI wizthk_ThunkConnect32(LPSTR pszDll16,LPSTR pszDll32,HINSTANCE hInst,
    DWORD dwReason);
  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

#if defined(CMBUILD)
static const CHAR szDll16[] = "CNET16.DLL";
static const CHAR szDll32[] = "CCFG32.DLL";
#else
static const CHAR szDll16[] = "INET16.DLL";
static const CHAR szDll32[] = "ICFG32.DLL";
#endif

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to inet16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  // initialize thunk layer to inet16.dll
  if (!(wizthk_ThunkConnect32((LPSTR)szDll16,(LPSTR)szDll32,hInstDll,
    fdwReason)))
    return FALSE;

  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;
 
    // Allocate memory for the error message text for GetLastInstallErrorText()
    gpszLastErrorText = (LPSTR)LocalAlloc(LPTR, MAX_ERROR_TEXT);
    if (NULL == gpszLastErrorText)
    {
      return FALSE;
    }
  }


  if( fdwReason == DLL_PROCESS_DETACH )
  {
    LocalFree(gpszLastErrorText);
  }

  return TRUE;
}



/*******************************************************************

  NAME:    GetClientConfig

  SYNOPSIS:  Retrieves client software configration

  ENTRY:    pClientConfig - pointer to struct to fill in with config info

  EXIT:    returns a SETUPX error code

  NOTES:    This is just the 32-bit side wrapper, thunks to GetClientConfig16
        to do real work.  Information needs to be obtained from
        setupx.dll, which is 16-bit.

********************************************************************/
RETERR GetClientConfig(CLIENTCONFIG * pClientConfig)
{
  ASSERT(pClientConfig);
   
  // thunk to GetClientConfig16 to do real work

  return GetClientConfig16(pClientConfig);
}

/*******************************************************************

  NAME:    InstallComponent

  SYNOPSIS:  Installs the specified component

  ENTRY:    dwComponent - ordinal of component to install
        (IC_xxx, defined in wizglob.h)
        dwParam - component-specific parameters, defined in wizglob.h

  EXIT:    returns ERROR_SUCCESS if successful, or a standard error code

  NOTES:    This is just the 32-bit side wrapper, thunks to InstallComponent16
        to do real work.

********************************************************************/
UINT InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam)
{
  // thunk to InstallComponent16 to do real work

  return InstallComponent16(hwndParent,dwComponent,dwParam);
}


/*******************************************************************

  NAME:    BeginNetcardTCPIPEnum16Enum

  SYNOPSIS:  Begins an enumeration of netcard TCP/IP nodes

  NOTES:    Subsequent calls to GetNextNetcardTCPIPNode16 will
        enumerate TCP/IP nodes

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR BeginNetcardTCPIPEnum(VOID)
{
  return BeginNetcardTCPIPEnum16();
}

/*******************************************************************

  NAME:    GetNextNetcardTCPIPNode16

  SYNOPSIS:  Enumerates the next TCP/IP node of specified type

  ENTRY:    pszTcpNode - pointer to buffer to be filled in with
          node subkey name
        cbTcpNode - size of pszTcpNode buffer
        dwFlags - some combination of INSTANCE_ flags
          indicating what kind of instance to enumerate

  EXIT:    returns TRUE if a TCPIP node was enumerated,
        FALSE if no more nodes to enumerate

  NOTES:    BeginNetcardTCPIPEnum16 must be called before each
        enumeration to start at the beginning of the list.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
BOOL GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode, DWORD dwFlags)
{
  return GetNextNetcardTCPIPNode16(pszTcpNode,cbTcpNode,dwFlags);
}


/*******************************************************************

  NAME:    GetSETUPXErrorText

  SYNOPSIS:  Gets text corresponding to SETUPX error code

  ENTRY:    dwErr - error to get text for
        pszErrorDesc - pointer to buffer to fill in with text
        cbErrorDesc - size of pszErrorDesc buffer

  NOTES:    This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
extern "C" VOID GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc)
{
  GetSETUPXErrorText16(dwErr,pszErrorDesc,cbErrorDesc);
}

/*******************************************************************

  NAME:    RemoveUnneededDefaultComponents

  SYNOPSIS:  Removes network components that we don't need which
        are installed by default when an adapter is added
        to a no-net system.

  NOTES:    Removes: vredir, nwredir, netbeui, ipx
        
        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveUnneededDefaultComponents(HWND hwndParent)
{
  return RemoveUnneededDefaultComponents16(hwndParent);
}

/*******************************************************************

  NAME:    RemoveProtocols

  SYNOPSIS:  Removes specified protocols from card of specified type

  NOTES:    This function is useful because if user has a net card
        and we add PPPMAC, all the protocols that were bound
        to the net card appear on PPPMAC.  We need to go through
        and strip them off.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols)
{
  return RemoveProtocols16(hwndParent,dwRemoveFromCardType,dwProtocols);
}

/*******************************************************************

  NAME:    DoGenInstall

  SYNOPSIS:  Calls GenInstall to do file copies, registry entries,
        etc. in specified .inf file and section.

  ENTRY:    hwndParent - parent window
        lpszInfFile - name of .inf file.
        lpszInfSect - name of section in .inf file.

  EXIT:    returns OK, or a SETUPX error code.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect)
{
  return DoGenInstall16(hwndParent,lpszInfFile,lpszInfSect);
}


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgSetInstallSourcePath(LPCSTR lpszSourcePath)
{
  // thunk to InstallComponent16 to do real work

  return SetInstallSourcePath16(lpszSourcePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\cfgtcp.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  TCPCFG.C - Functions to read and set TCP/IP configuration
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
// function prototypes
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);

//*******************************************************************
//              
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS)
{
  CHAR szDNSEnabled[2];    // big enough for "1"
  BOOL fGlobalDNS = FALSE;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  HRESULT hr = reTcp.GetError();
  if (hr == ERROR_SUCCESS)
  {
    // read the registry value to see if DNS is enabled
    reTcp.GetString(szRegValEnableDNS,szDNSEnabled,sizeof(szDNSEnabled));
    hr = reTcp.GetError();
    if ((hr == ERROR_SUCCESS) && (!lstrcmpi(szDNSEnabled,sz1)))
    {
      // DNS is enabled
      fGlobalDNS = TRUE;
    }
  }

  if (NULL != lpfGlobalDNS)
  {
    *lpfGlobalDNS = fGlobalDNS;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgRemoveGlobalDNS(void)
{
  HRESULT hr = ERROR_SUCCESS;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  hr = reTcp.GetError();
  ASSERT(hr == ERROR_SUCCESS);

  if (ERROR_SUCCESS == hr)
  {
    // no name servers; disable DNS.  Set registry switch to "0".
    hr = reTcp.SetValue(szRegValEnableDNS,sz0);
    ASSERT(hr == ERROR_SUCCESS);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn)
{
  BOOL fBound = FALSE;

  ASSERT(lpfSharingOn);

  // call worker function
  HRESULT hr = DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,FALSE,&fBound);

  if (NULL != lpfSharingOn)
  {
    *lpfSharingOn = fBound;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for 
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT WINAPI IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent)
{
  BOOL fBound;

  // call worker function
  return DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,TRUE,&fBound);

}


/*******************************************************************

  NAME:    DetectModifyTCPIPBindings

  SYNOPSIS:  Finds (and optionally removes) bindings between
        VSERVER and TCP/IP for TCP/IP instances on a particular
        card type.

  ENTRY:    dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to find/remove server-TCP/IP bindings for
        pszBoundTo - name of component to look for or modify bindings
          to.  Can be VSERVER or VREDIR
        fRemove - if TRUE, all bindings are removed as we find them.
          If FALSE, bindings are left alone but *pfBound is set
          to TRUE if bindings exist.
        pfBound - pointer to BOOL to be filled in

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    Worker function for TurnOffFileSharing and IsFileSharingTurnedOn

********************************************************************/
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,
  BOOL fRemove,BOOL * pfBound)
{
  ASSERT(pfBound);
  *pfBound = FALSE;  // assume not bound until proven otherwise

  ENUM_TCP_INSTANCE EnumTcpInstance(dwCardFlags,NT_ENUMNODE);

  UINT err = EnumTcpInstance.GetError();
  if (err != ERROR_SUCCESS)
    return err;

  HKEY hkeyInstance = EnumTcpInstance.Next();

  // for every TCP/IP node in enum branch, look at bindings key.
  // Scan the bindings (values in bindings key), if they begin
  // with the string pszBoundTo ("VSERVER" or "VREDIR") then
  // the binding exists.

  while (hkeyInstance) {
    // open bindings key
    RegEntry reBindings(szRegKeyBindings,hkeyInstance);
    ASSERT(reBindings.GetError() == ERROR_SUCCESS);
    if (reBindings.GetError() == ERROR_SUCCESS) {
      RegEnumValues * preBindingVals = new RegEnumValues(&reBindings);
      ASSERT(preBindingVals);
      if (!preBindingVals)
        return ERROR_NOT_ENOUGH_MEMORY;
  
      // enumerate binding values
      while (preBindingVals->Next() == ERROR_SUCCESS) {
        ASSERT(preBindingVals->GetName()); // should always have a valid ptr
        
        // does this binding begin with the string we were passed in
        // pszBoundTo

        CHAR szBindingVal[SMALL_BUF_LEN+1];
        DWORD dwBoundToLen = lstrlen(pszBoundTo);
        lstrcpy(szBindingVal,preBindingVals->GetName());
        if (((DWORD)lstrlen(szBindingVal)) >= dwBoundToLen) {
          // NULL-terminate the copy at the appropriate place
          // so we can do a strcmp rather than a strncmp, which
          // would involve pulling in C runtime or implementing
          // our own strncmp
          szBindingVal[dwBoundToLen] = '\0';
          if (!lstrcmpi(szBindingVal,pszBoundTo)) {

            *pfBound = TRUE;
            // remove the binding if specified by caller
            if (fRemove) {
              // delete the value
              reBindings.DeleteValue(preBindingVals->GetName());

              // destroy and reconstruct RegEnumValues object, otherwise
              // RegEnumValues api gets confused because we deleted a
              // value during enum
              delete preBindingVals;
              preBindingVals = new RegEnumValues(&reBindings);
              ASSERT(preBindingVals);
              if (!preBindingVals)
                return ERROR_NOT_ENOUGH_MEMORY;
            } else {
              // caller just wants to know if binding exists, we
              // filled in pfBound above so we're done
              return ERROR_SUCCESS;
            }
          }
        }
      }
    }
    hkeyInstance = EnumTcpInstance.Next();
  }

  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE

  SYNOPSIS:  Constructor for class to enumerate TCP/IP registry nodes
        according to type of card they are bound to

  ENTRY:    dwCardFlags - combination of INSTANCE_x flags indicating
          what kind of card to enumerate instances for
        dwNodeFlags  - combination of NT_ flags indicating what
          type of node to return (driver node, enum node)

********************************************************************/
ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags) :
  _dwCardFlags (dwCardFlags), _dwNodeFlags (dwNodeFlags)
{
  _hkeyTcpNode = NULL;
  _error = ERROR_SUCCESS;

  // init/reset netcard enumeration
  BeginNetcardTCPIPEnum();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE()
{
  // close current TCP node key, if any
  CloseNode();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::Next

  SYNOPSIS:  Enumerates next TCP/IP driver node

  EXIT:    Returns an open registry key handle, or NULL if
        no more nodes.

  NOTES:    Caller should not close the HKEY that is returned.  This
        HKEY will be valid until the next time the Next() method
        is called or until the object is destructed.

********************************************************************/
HKEY ENUM_TCP_INSTANCE::Next()
{
  CHAR  szSubkeyName[MAX_PATH+1];

  // close current TCP node key, if any
  CloseNode();

  while (_error == ERROR_SUCCESS) {
    CHAR szInstancePath[SMALL_BUF_LEN+1];
    CHAR szDriverPath[SMALL_BUF_LEN+1];

    if (!GetNextNetcardTCPIPNode(szSubkeyName,sizeof(szSubkeyName),
      _dwCardFlags))
      return NULL;  // no more nodes

    // open the enum branch, find the specified subkey
    RegEntry reEnumNet(szRegPathEnumNet,HKEY_LOCAL_MACHINE);

    // if caller wanted enum node, just open that node

    if (_dwNodeFlags & NT_ENUMNODE) {
    
      _error = RegOpenKey(reEnumNet.GetKey(),szSubkeyName,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;

    } else {
      // from enum node, figure out path to driver node
      
      reEnumNet.MoveToSubKey(szSubkeyName);
      if (reEnumNet.GetError() != ERROR_SUCCESS)
        continue;
      // find the driver path to the driver node
      if (!reEnumNet.GetString(szRegValDriver,szDriverPath,
        sizeof(szDriverPath))) {
         ASSERTSZ(FALSE,"No driver path in enum branch for TCP/IP instance");
        continue;  
      }

      // build the path to registry node for this instance
      lstrcpy(szInstancePath,szRegPathClass);
      lstrcat(szInstancePath,szDriverPath);

      _error = RegOpenKey(HKEY_LOCAL_MACHINE,szInstancePath,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;
    }
  }

  // ran through all net cards of specified type w/o finding TCP/IP bound
  _error = ERROR_NO_MORE_ITEMS;
  return NULL;
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::CloseNode

  SYNOPSIS:  Private worker function to close TCP/IP node handle

********************************************************************/
VOID ENUM_TCP_INSTANCE::CloseNode()
{
  if (_hkeyTcpNode) {
    RegCloseKey(_hkeyTcpNode);
    _hkeyTcpNode = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//  
//  12/07/94  jeremys Borrowed from WNET common library
//  96/05/22  markdu  Borrowed (from inetcfg.dll)
//

#include "pch.hpp"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPSTR)::GlobalAlloc(GPTR,cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (unsigned char *)string, sizeof(TCHAR)*(lstrlen(string)+1));
    }
  return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (unsigned char *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;
  
    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;
  
  return dwNumber;
}

long RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(unsigned int size)
{
  return (void *)::GlobalAlloc(GPTR,size); 
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  CHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  CHAR * QueryPtr() const { return (CHAR *)_lpBuffer; }
  operator CHAR *() const { return (CHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const char *pszValue, const char *string);
    long  SetValue(const char *pszValue, unsigned long dwNumber);
    char *  GetString(const char *pszValue, char *string, unsigned long length);
    long  GetNumber(const char *pszValue, long dwDefault = 0);
    long  DeleteValue(const char *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    char *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    CHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\debug.h ===
#ifndef _PHBKDEBUG
#define _PHBKDEBUG

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	void Dprintf(PCSTR pcsz, ...);
//#ifdef __cplusplus
//}
//#endif // __cplusplus

#ifdef DEBUG
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
	void DebugSz(PCSTR psz);
//#ifdef __cplusplus
//}
//#endif // __cplusplus
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg) f
	#define AssertSz(f, sz) f
	#define Assert(f) f
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\debug.cpp ===
// ############################################################################
// Debugging routines

#include "pch.hpp"

BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(PCSTR psz)
{
	OutputDebugString(psz);
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(PCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags)
{
	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	BOOL fAssertIntoDebugger = FALSE;
	LPTSTR pszCommandLine = GetCommandLine();
	HANDLE	hAssertTxt;
	//BYTE	szTime[80];
	CHAR	szTime[80];
	SYSTEMTIME st;
	DWORD	cbWritten;
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
    		ExitProcess(0);
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// string resource IDs
#define IDS_APPNAME                   1000
#define IDS_ERRFORMAT                 1001
#define IDS_EXEC_GRPCONV              1002
#define IDS_EXEC_GRPCONV_PARAM        1003
#define IDS_MAIL_WIZARD_REG_VAL       1004
#define IDS_DEF_COMPUTER_NAME         1005
#define IDS_DEF_WORKGROUP_NAME        1006
#define IDS_ERROutOfMemory            1100
#define IDS_ERRReadConfig             1101
#define IDS_ERRInstallTCPIP           1102
#define IDS_ERRInstallPPPMAC          1103
#define IDS_ERRInstallFiles           1104
#define IDS_ERRWriteDNS               1105

// dialog page IDs
//
// ChrisK 6/3/97 Olympus 5425
// Removed unused dialog
//

#define IDD_DNS_WARNING               2001

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_UNUSED                    -1

#define IDC_DNS_WARNING_TEXT1         3000
#define IDC_DNS_WARNING_TEXT2         3001
#define IDC_DNS_WARNING_TEXT3         3002
#define IDC_DNS_WARNING_TEXT4         3003

// icon IDs
#define IDI_WORLD                     2200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\pch.c ===
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\pch.hpp ===
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\sources.inc ===
!IF $(386)
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\inet32

MAJORCOMP=icw
MINORCOMP=ICFG95

TARGETNAME=ICFG95
TARGETTYPE=DYNLINK
TARGETPATH=obj
DLLENTRY=DllEntryPoint
DLLBASE=$(DEFBASEADDR)
DLLDEF=..\inet32.def
NOT_LEAN_AND_MEAN=1
RCNOFONTMAP=1
C_DEFINES=-DICW32 -DNASHVILLE

USE_MSVCRT40=1

SOURCES= \
    ..\cfgdll.rc    \
    ..\callout.cpp  \
    ..\cfgapi.cpp   \
    ..\cfgdll.cpp   \
    ..\cfgtcp.cpp   \
    ..\clsutil.cpp  \
    ..\strings.cpp  \
    ..\util.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\version.lib       \
    $(SDK_LIB_PATH)\winspool.lib      \
    $(SDK_LIB_PATH)\tapi32.lib        \
    $(SDK_LIB_PATH)\thunk32.lib

i386_SOURCES = ..\wizthk.asm
386_ASMFLAGS = -DIS_32 -DMASM6 -DBUILDDLL -Sg
ASM_DEFINES = -DIS_32 -DMASM6 -DBUILDDLL -Sg

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4231

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pch.hpp
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\i386\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\i386\wizthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.H - Header file for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#ifndef _STRINGS_H_
#define _STRINGS_H_

// registry strings
extern const CHAR szRegPathSetup[];
extern const CHAR szRegPathClass[];
extern const CHAR szRegPathEnumNet[];
extern const CHAR szRegPathSetupRunOnce[];
extern const CHAR szRegPathSoftwareMicrosoft[];
extern const CHAR szRegValOwner[];
extern const CHAR szRegValOrganization[];
extern const CHAR szRegValDriver[];
extern const CHAR szTCPGlobalKeyName[];
extern const CHAR szRegKeyBindings[];
extern const CHAR szRegValEnableDNS[];
extern const CHAR szRegPathExchangeClientOpt[];
extern const CHAR szRegValSilentRunning[];
extern const CHAR szRegValMlSet[];
extern const CHAR szRegPathComputerName[];
extern const CHAR szRegValComputerName[];
extern const CHAR szRegPathWorkgroup[];
extern const CHAR szRegValWorkgroup[];

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//extern const CHAR szRegPathInternetIconCommand[];

extern const CHAR szRegPathIexploreAppPath[];
extern const CHAR szRegPathDesktop[];
extern const CHAR szRegPathSetupWallpaper[];
extern const CHAR szRegValWallpaper[];
extern const CHAR szRegValTileWallpaper[];

// misc strings
extern const CHAR sz0[];
extern const CHAR sz1[];
extern const CHAR szNull[];
extern const CHAR szVSERVER[];
extern const CHAR szVREDIR[];

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\global.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  GLOBAL.H - central header file for Internet config library
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "ICFG32: "
#endif // DEBUG


#include <windows.h>                
#include <windowsx.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "..\inc\oharestr.h"

// various RNA header files
#include <ras.h>
//#include <rnaph.h>

#include "..\inc\wizglob.h"
#include "..\inc\wizdebug.h"


#undef DATASEG_READONLY  
#define DATASEG_READONLY  ".rdata"
#include "inetcfg.h"
#include "cfgapi.h"
#include "clsutil.h"
#include "tcpcmn.h"
#include "ids.h"
#include "strings.h"

// Terminology: ISP - Internet Service Provider

// Defines
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

// Globals

extern HINSTANCE  ghInstance;         // global module instance handle
extern LPSTR      gpszLastErrorText;  // hold text of last error

// Defines

// error class defines for PrepareErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
#define ERRCLS_RNA      0x0003
#define ERRCLS_MAPI     0x0004

#define OK        0    // success code for SETUPX class errors

// functions in PROPMGR.C
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls);

// functions in CALLOUT.C
UINT InstallTCPIP(HWND hwndParent);
UINT InstallPPPMAC(HWND hwndParent);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons);
//int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
LPSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...);
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);
DWORD RunMlsetExe(HWND hwndOwner);
VOID RemoveRunOnceEntry(UINT uResourceID);
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName);
BOOL GenerateComputerNameIfNeeded(VOID);
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//BOOL SetDesktopInternetIconToBrowser(VOID);

VOID PrepareForRunOnceApp(VOID);

// functions in INETAPI.C
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart);

// functions in WIZDLL.C
RETERR   GetClientConfig(CLIENTCONFIG * pClientConfig);
UINT   InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
RETERR   RemoveUnneededDefaultComponents(HWND hwndParent);
RETERR   RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
RETERR   BeginNetcardTCPIPEnum(VOID);
BOOL  GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode,DWORD dwFlags);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;


#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\tcpcmn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  TCPCMN.H - central header file for TCP/IP structures and configuration
//         functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _TCPCMN_H_
#define _TCPCMN_H_

typedef DWORD IPADDRESS;

// same limits as in net setup UI
#define IP_ADDRESS_LEN          15    // big enough for www.xxx.yyy.zzz
#define MAX_GATEWAYS      8
#define MAX_DNSSERVER      3

// big enough for <ip>,<ip>,...
#define MAX_DNSSERVERLEN    MAX_DNSSERVER * (IP_ADDRESS_LEN+1)
#define MAX_GATEWAYLEN      MAX_GATEWAYS * (IP_ADDRESS_LEN+1)

// node type flags for _dwNodeFlags
#define NT_DRIVERNODE  0x0001
#define NT_ENUMNODE    0x0002

class ENUM_TCP_INSTANCE
{
private:
  DWORD       _dwCardFlags;  // INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, etc
  DWORD      _dwNodeFlags;  // NT_DRIVERNODE, NT_ENUMNODE, etc
  UINT       _error;
  HKEY       _hkeyTcpNode;
  VOID      CloseNode();
public:
  ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags);
  ~ENUM_TCP_INSTANCE();
  HKEY Next();
  UINT GetError()  { return _error; }
};


#endif  // _TCPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\strings.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  STRINGS.C - String literals for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#include "pch.hpp"

#pragma data_seg(DATASEG_READONLY)

//////////////////////////////////////////////////////
// registry strings
//////////////////////////////////////////////////////

// "Software\\Microsoft\\Windows\\CurrentVersion"
static const CHAR szRegPathSetup[] =       REGSTR_PATH_SETUP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\"
static const CHAR szRegPathClass[] =       REGSTR_PATH_CLASS "\\";

// "Enum\\Network\\"
static const CHAR szRegPathEnumNet[] =      REGSTR_PATH_ENUM "\\Network\\";

// "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup"
static const CHAR szRegPathSetupRunOnce[] =   REGSTR_PATH_RUNONCE "\\Setup";

static const CHAR szRegPathSoftwareMicrosoft[]= "Software\\Microsoft";

// "RegisteredOwner"
static const CHAR szRegValOwner[] =       REGSTR_VAL_REGOWNER;

// "RegisteredOrganization"
static const CHAR szRegValOrganization[] =     REGSTR_VAL_REGORGANIZATION;

static const CHAR szRegValDriver[] =      "Driver";

// "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
static const CHAR szTCPGlobalKeyName[] =     REGSTR_PATH_VXD "\\MSTCP";

// "RemoteAccess"
static const CHAR szRegKeyBindings[] =      "Bindings";
static const CHAR szRegValEnableDNS[] =     "EnableDNS";

static const CHAR szRegPathExchangeClientOpt[] = "Software\\Microsoft\\Exchange\\Client\\Options";
static const CHAR szRegValSilentRunning[] =    "SilentRunning";
static const CHAR szRegValMlSet[] =        "MlSet";

// "System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"
static const CHAR szRegPathComputerName[] =     REGSTR_PATH_COMPUTRNAME;

// "ComputerName"
static const CHAR szRegValComputerName[] =      REGSTR_VAL_COMPUTRNAME;

// "System\\CurrentControlSet\\Services\\VxD\\VNETSUP"
static const CHAR szRegPathWorkgroup[] =    REGSTR_PATH_VNETSUP;

// "Workgroup"
static const CHAR szRegValWorkgroup[] =      REGSTR_VAL_WORKGROUP;

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//static const CHAR szRegPathInternetIconCommand[] = "CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\Shell\\Open\\Command";
static const CHAR szRegPathIexploreAppPath[] =  "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

// "Control Panel\\Desktop"
static const CHAR szRegPathDesktop[] =      REGSTR_PATH_DESKTOP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
static const CHAR szRegPathSetupWallpaper[] =  REGSTR_PATH_SETUP REGSTR_KEY_SETUP;

static const CHAR szRegValWallpaper[] =      "Wallpaper";
static const CHAR szRegValTileWallpaper[] =    "TileWallpaper";


//////////////////////////////////////////////////////
// misc strings
//////////////////////////////////////////////////////
static const CHAR sz0[]  =       "0";
static const CHAR sz1[]  =        "1";
static const CHAR szNull[] =       "";
static const CHAR szVSERVER[] =     "VSERVER";
static const CHAR szVREDIR[] =      "VREDIR";

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
#if 0
#include "string.h"
#endif

#define MAX_MSG_PARAM     8

// function prototypes
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList);

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    CHAR szMsgBuf[MAX_RES_LEN+1];
  CHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons)
{
  CHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}


/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        CHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      GetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for PrepareErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
    pszFmt,0,0,pszMsg,cbMsg,&ArgList);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    PrepareErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        ... - additional parameters to be inserted in string
          specified by uStrID

********************************************************************/
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);

  if (!ErrorDesc || !ErrorFmt)
  {
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

#ifdef _M_ALPHA
  va_list args[MAX_MSG_PARAM];
  args[0].a0 = (LPSTR) ErrorDesc.QueryPtr();
#else
  LPSTR args[MAX_MSG_PARAM];
  args[0] = (LPSTR) ErrorDesc.QueryPtr();
#endif
  memcpy(&args[1],((CHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  FormatErrorMessage(gpszLastErrorText, MAX_ERROR_TEXT,
#ifdef _M_ALPHA
    ErrorFmt.QueryPtr(), args[1]);
#else
    ErrorFmt.QueryPtr(),(va_list) &args[1]);
#endif
}

/*******************************************************************

  NAME:    RunMlsetExe

  SYNOPSIS:  Runs mlset32.exe, an Exchange app that needs to be
        run after files are installed otherwise Exchange
        barfs

  NOTES:    We look in registry to find path to mlset32.exe

********************************************************************/
DWORD RunMlsetExe(HWND hwndOwner)
{
  DWORD dwRet = ERROR_SUCCESS;

  // get path to mlset32 out of registry
  RegEntry re(szRegPathSoftwareMicrosoft,HKEY_LOCAL_MACHINE);

  CHAR szAppPath[MAX_PATH+1];
  if (re.GetString(szRegValMlSet,szAppPath,sizeof(szAppPath))) {
    PROCESS_INFORMATION pi;
    STARTUPINFO sti;

    // set "SilentRunning" registry switch to make mlset32
    // not display the Exchange wizard
    RegEntry reSilent(szRegPathExchangeClientOpt,HKEY_LOCAL_MACHINE);
    reSilent.SetValue(szRegValSilentRunning,(DWORD) 1);

    ZeroMemory(&sti,sizeof(STARTUPINFO));
    sti.cb = sizeof(STARTUPINFO);
            
    // launch mlset32.exe
    BOOL fRet = CreateProcess(NULL, (LPSTR) szAppPath,
                           NULL, NULL, FALSE, 0, NULL, NULL,
                           &sti, &pi);
    if (fRet) {
      CloseHandle(pi.hThread);

      // wait for mlset to complete
      MsgWaitForMultipleObjectsLoop(pi.hProcess);

      CloseHandle(pi.hProcess);
    } else {
      dwRet = GetLastError();
    }

    // put our window in front of mlset32's
    SetForegroundWindow(hwndOwner);
  
  } else {
    dwRet = ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}

/*******************************************************************

  NAME:    RemoveRunOnceEntry

  SYNOPSIS:  Removes the specified value from setup runonce key

  ENTRY:    uResourceID - ID of value name in resource
          (may be localized)

********************************************************************/
VOID RemoveRunOnceEntry(UINT uResourceID)
{
  RegEntry re(szRegPathSetupRunOnce,HKEY_LOCAL_MACHINE);
  CHAR szValueName[SMALL_BUF_LEN+1];
  ASSERT(re.GetError() == ERROR_SUCCESS);
  re.DeleteValue(LoadSz(uResourceID,
    szValueName,sizeof(szValueName)));
}

/*******************************************************************

  NAME:    GenerateComputerNameIfNeeded

  SYNOPSIS:  Makes up and stores in the registry a computer and/or
        workgroup name if not already set.

  NOTES:    If we don't do this, user will get prompted for computer
        name and workgroup.  These aren't meaningful to the user
        so we'll just make something up if these aren't set.

********************************************************************/
BOOL GenerateComputerNameIfNeeded(VOID)
{
  CHAR szComputerName[CNLEN+1]="";
  CHAR szWorkgroupName[DNLEN+1]="";
  BOOL fNeedToSetComputerName = FALSE;

  // get the computer name out of the registry
  RegEntry reCompName(szRegPathComputerName,HKEY_LOCAL_MACHINE);
  if (reCompName.GetError() == ERROR_SUCCESS) {
    reCompName.GetString(szRegValComputerName,szComputerName,
      sizeof(szComputerName));
    if (!lstrlen(szComputerName)) {
      // no computer name set!  make one up
      GenerateDefaultName(szComputerName,sizeof(szComputerName),
        (CHAR *) szRegValOwner,IDS_DEF_COMPUTER_NAME);
      // store the generated computer name in the registry
      reCompName.SetValue(szRegValComputerName,szComputerName);

      // also need to store the computer name in the workgroup key
      // which we will open below... set a flag so we know to do this.
      // (don't ask me why they store the computer name in two places...
      // but we need to set both.)
      fNeedToSetComputerName = TRUE;
    }
  }

  // get the workgroup name out of the registry
  RegEntry reWorkgroup(szRegPathWorkgroup,HKEY_LOCAL_MACHINE);
  if (reWorkgroup.GetError() == ERROR_SUCCESS) {

    // if we set a new computer name up above, then we have to set
    // a 2nd copy of the new name now, in the workgroup key
    if (fNeedToSetComputerName) {
      reWorkgroup.SetValue(szRegValComputerName,szComputerName);
    }


    reWorkgroup.GetString(szRegValWorkgroup,szWorkgroupName,
      sizeof(szWorkgroupName));
    if (!lstrlen(szWorkgroupName)) {
      // no workgroup name set!  make one up
      GenerateDefaultName(szWorkgroupName,sizeof(szWorkgroupName),
        (CHAR *) szRegValOrganization,IDS_DEF_WORKGROUP_NAME);
      // store the generated workgroup name in the registry
      reWorkgroup.SetValue(szRegValWorkgroup,szWorkgroupName);
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    GenerateDefaultName

  SYNOPSIS:  Generates default computer or workgroup name

  ENTRY:    pszName - buffer to be filled in with name
        cbName - size of cbName buffer
        pszRegValName - name of registry value in ...Windows\CurrentVersion
          key to generate name from
        uIDDefName - ID of string resource to use if no value is
          present in registry to generate name from

********************************************************************/
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName)
{
  ASSERT(pszName);
  ASSERT(pszRegValName);

  *pszName = '\0';  // NULL-terminate buffer

  // look for registered owner/organization name in registry
  RegEntry reSetup(szRegPathSetup,HKEY_LOCAL_MACHINE);
  if (reSetup.GetError() == ERROR_SUCCESS) {
    if (reSetup.GetString(pszRegValName,pszName,cbName) &&
      lstrlen(pszName)) {
      // got string from registry... now terminate at first whitespace
      CHAR * pch = pszName;
      while (*pch) {
        if (*pch == ' ') {
          // found a space, terminate here and stop
          *pch = '\0';           
        } else {
          // advance to next char, keep going
          pch = CharNext(pch);
        }
      }
      // all done!
      return TRUE; 
    }
  }
  
  // couldn't get this name from registry, go for our fallback name
  // from resource

  LoadSz(uIDDefName,pszName,cbName);
  return TRUE;
}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}


/*******************************************************************
// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.


  NAME:    SetDesktopInternetIconToBrowser

  SYNOPSIS:  "Points" The Internet desktop icon to web browser
        (Internet Explorer)

  NOTES:    The Internet icon may initially "point" at this wizard,
        we need to set it to launch web browser once we complete
        successfully.

********************************************************************/
/********BOOL SetDesktopInternetIconToBrowser(VOID)
{
	CHAR szAppPath[MAX_PATH+1]="";
	BOOL fRet = FALSE;

	// look in the app path section in registry to get path to internet
	// explorer

	RegEntry reAppPath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);
	ASSERT(reAppPath.GetError() == ERROR_SUCCESS);
	if (reAppPath.GetError() == ERROR_SUCCESS) {

		reAppPath.GetString(szNull,szAppPath,sizeof(szAppPath));
		ASSERT(reAppPath.GetError() == ERROR_SUCCESS);

	}

	// set the path to internet explorer as the open command for the 
	// internet desktop icon
	if (lstrlen(szAppPath)) {
		RegEntry reIconOpenCmd(szRegPathInternetIconCommand,HKEY_CLASSES_ROOT);
		ASSERT(reIconOpenCmd.GetError() == ERROR_SUCCESS);
		if (reIconOpenCmd.GetError() == ERROR_SUCCESS) {
			UINT uErr = reIconOpenCmd.SetValue(szNull,szAppPath);
			ASSERT(uErr == ERROR_SUCCESS);
			
			fRet = (uErr == ERROR_SUCCESS);
		}
	}

	return fRet;
}
******/

/*******************************************************************

  NAME:    PrepareForRunOnceApp

  SYNOPSIS:  Copies wallpaper value in registry to make the runonce
        app happy

  NOTES:    The runonce app (the app that displays a list of apps
        that are run once at startup) has a bug.  At first boot,
        it wants to change the wallpaper from the setup wallpaper
        to what the user had before running setup.  Setup tucks
        the "old" wallpaper away in a private key, then changes
        the wallpaper to the setup wallpaper.  After the runonce
        app finishes, it looks in the private key to get the old
        wallpaper and sets that to be the current wallpaper.
        However, it does this all the time, not just at first boot!
        The end effect is that whenever you do anything that
        causes runonce.exe to run (add stuff thru add/remove
        programs control panel), your wallpaper gets set back to
        whatever it was when you installed win 95.  This is
        especially bad for Plus!, since wallpaper settings are an
        important part of the product.

        To work around this bug, we copy the current wallpaper settings
        (which we want preserved) to setup's private key.  When
        runonce runs it will say "aha!" and copy those values back
        to the current settings.

********************************************************************/
VOID PrepareForRunOnceApp(VOID)
{
  // open a key to the current wallpaper settings
  RegEntry reDesktop(szRegPathDesktop,HKEY_CURRENT_USER);
  ASSERT(reDesktop.GetError() == ERROR_SUCCESS);

  // open a key to the private setup section
  RegEntry reSetup(szRegPathSetupWallpaper,HKEY_LOCAL_MACHINE);
  ASSERT(reSetup.GetError() == ERROR_SUCCESS);

  if (reDesktop.GetError() == ERROR_SUCCESS &&
    reSetup.GetError() == ERROR_SUCCESS) {
    CHAR szWallpaper[MAX_PATH+1]="";
    CHAR szTiled[10]="";  // big enough for "1" + slop

    // get the current wallpaper name
    if (reDesktop.GetString(szRegValWallpaper,szWallpaper,
      sizeof(szWallpaper))) {

      // set the current wallpaper name in setup's private section
      UINT uRet=reSetup.SetValue(szRegValWallpaper,szWallpaper);
      ASSERT(uRet == ERROR_SUCCESS);

      // get the current 'tiled' value. 
      reDesktop.GetString(szRegValTileWallpaper,szTiled,
        sizeof(szTiled));

      // set the 'tiled' value in setup's section
      if (lstrlen(szTiled)) {
        uRet=reSetup.SetValue(szRegValTileWallpaper,szTiled);
        ASSERT(uRet == ERROR_SUCCESS);
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inet32\i386\wizthk.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 21 14:07:10 1996

;Command Line: ..\..\..\..\dev\tools\binr\thunk.exe -NC _TEXT ..\wizthk.thk 

	TITLE	$..\wizthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_wizthkTargetTable	;Flat address of target table in 16-bit module.

public FT_wizthkChecksum32
FT_wizthkChecksum32	dd	010e07h


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public wizthk_ThunkData32	;This symbol must be exported.
wizthk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_wizthk - offset wizthk_ThunkData32
	dd	offset FT_Prolog_wizthk - offset wizthk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public wizthk_ThunkConnect32@16
wizthk_ThunkConnect32@16:
	pop	edx
	push	offset wizthk_ThkData16
	push	offset wizthk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
wizthk_ThkData16 label byte
	db	"wizthk_ThunkData16",0


		


pfnQT_Thunk_wizthk	dd offset QT_Thunk_wizthk
pfnFT_Prolog_wizthk	dd offset FT_Prolog_wizthk
	.data
QT_Thunk_wizthk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_wizthk label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include wizthk.inc



;************************ START OF THUNK BODIES************************




;
public GetClientConfig16@4
GetClientConfig16@4:
	FAPILOG16	212
	mov	cx, (1 SHL 10) + (0 SHL 8) + 8
; GetClientConfig16(16) = GetClientConfig16(32) {}
;
; dword ptr [ebp+8]:  pClientConfig
;
public IIGetClientConfig16@4
IIGetClientConfig16@4:
	call	dword ptr [pfnFT_Prolog_wizthk]
	sub	esp,24
	mov	esi,[ebp+8]
	or	esi,esi
	jnz	L0
	push	esi
	jmp	L1
L0:
	lea	edi,[ebp-88]
	push	edi	;pClientConfig: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],01h	;Set flag to fixup ESP-rel argument.
	mov	ecx,12
@@:
	lodsd
	stosw
	loop	@B
L1:
	call	FT_Thunk
	movzx	ebx,ax
	mov	edi,[ebp+8]
	or	edi,edi
	jz	L2
	lea	esi,[ebp-88]	;pClientConfig  Struct16->Struct32
	mov	ecx,12
@@:
	lodsw
	cwde
	stosd
	loop	@B
L2:
	jmp	FT_Exit4





;
public BeginNetcardTCPIPEnum16@0
BeginNetcardTCPIPEnum16@0:
	FAPILOG16	161
	mov	cl,6
; BeginNetcardTCPIPEnum16(16) = BeginNetcardTCPIPEnum16(32) {}
;
;
public IIBeginNetcardTCPIPEnum16@0
IIBeginNetcardTCPIPEnum16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn





;
public GetNextNetcardTCPIPNode16@12
GetNextNetcardTCPIPNode16@12:
	FAPILOG16	131
	mov	cl,5
; GetNextNetcardTCPIPNode16(16) = GetNextNetcardTCPIPNode16(32) {}
;
; dword ptr [ebp+8]:  pszTcpNode
; dword ptr [ebp+12]:  cbTcpNode
; dword ptr [ebp+16]:  dwFlags
;
public IIGetNextNetcardTCPIPNode16@12
IIGetNextNetcardTCPIPNode16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	word ptr [ebp+12]	;cbTcpNode: dword->word
	push	dword ptr [ebp+16]	;dwFlags: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	cwde
	call	SUnMapLS_IP_EBP_8
	leave
	retn	12





;
public GetSETUPXErrorText16@12
GetSETUPXErrorText16@12:
	FAPILOG16	106
	mov	cl,4
; GetSETUPXErrorText16(16) = GetSETUPXErrorText16(32) {}
;
; dword ptr [ebp+8]:  dwErr
; dword ptr [ebp+12]:  pszErrorDesc
; dword ptr [ebp+16]:  cbErrorDesc
;
public IIGetSETUPXErrorText16@12
IIGetSETUPXErrorText16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwErr: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbErrorDesc: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public RemoveUnneededDefaultComponents16@4
RemoveUnneededDefaultComponents16@4:
	FAPILOG16	68
	mov	cl,3
; RemoveUnneededDefaultComponents16(16) = RemoveUnneededDefaultComponents16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
;
public IIRemoveUnneededDefaultComponents16@4
IIRemoveUnneededDefaultComponents16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	4





;
public RemoveProtocols16@12
RemoveProtocols16@12:
	FAPILOG16	46
	mov	cl,2
	jmp	IIRemoveProtocols16@12
public InstallComponent16@12
InstallComponent16@12:
	FAPILOG16	189
	mov	cl,7
; RemoveProtocols16(16) = RemoveProtocols16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  dwRemoveFromCardType
; dword ptr [ebp+16]:  dwProtocols
;
public IIRemoveProtocols16@12
IIRemoveProtocols16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	push	dword ptr [ebp+12]	;dwRemoveFromCardType: dword->dword
	push	dword ptr [ebp+16]	;dwProtocols: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	12





;
public DoGenInstall16@12
DoGenInstall16@12:
	FAPILOG16	27
	mov	cl,1
; DoGenInstall16(16) = DoGenInstall16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  lpszInfFile
; dword ptr [ebp+16]:  lpszInfSect
;
public IIDoGenInstall16@12
IIDoGenInstall16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public SetInstallSourcePath16@4
SetInstallSourcePath16@4:
	FAPILOG16	0
	mov	cl,0
; SetInstallSourcePath16(16) = SetInstallSourcePath16(32) {}
;
; dword ptr [ebp+8]:  szSourcePath
;
public IISetInstallSourcePath16@4
IISetInstallSourcePath16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] SetInstallSourcePath16',0
	db	'[F] DoGenInstall16',0
	db	'[F] RemoveProtocols16',0
	db	'[F] RemoveUnneededDefaultComponents16',0
	db	'[F] GetSETUPXErrorText16',0
	db	'[F] GetNextNetcardTCPIPNode16',0
	db	'[F] BeginNetcardTCPIPEnum16',0
	db	'[F] InstallComponent16',0
	db	'[F] GetClientConfig16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef SetInstallSourcePath16:far16
externDef DoGenInstall16:far16
externDef RemoveProtocols16:far16
externDef RemoveUnneededDefaultComponents16:far16
externDef GetSETUPXErrorText16:far16
externDef GetNextNetcardTCPIPNode16:far16
externDef BeginNetcardTCPIPEnum16:far16
externDef InstallComponent16:far16
externDef GetClientConfig16:far16


FT_wizthkTargetTable label word
	dw	offset SetInstallSourcePath16
	dw	   seg SetInstallSourcePath16
	dw	offset DoGenInstall16
	dw	   seg DoGenInstall16
	dw	offset RemoveProtocols16
	dw	   seg RemoveProtocols16
	dw	offset RemoveUnneededDefaultComponents16
	dw	   seg RemoveUnneededDefaultComponents16
	dw	offset GetSETUPXErrorText16
	dw	   seg GetSETUPXErrorText16
	dw	offset GetNextNetcardTCPIPNode16
	dw	   seg GetNextNetcardTCPIPNode16
	dw	offset BeginNetcardTCPIPEnum16
	dw	   seg BeginNetcardTCPIPEnum16
	dw	offset InstallComponent16
	dw	   seg InstallComponent16
	dw	offset GetClientConfig16
	dw	   seg GetClientConfig16




	.data

public wizthk_ThunkData16	;This symbol must be exported.
wizthk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dw	offset FT_wizthkTargetTable
	dw	seg    FT_wizthkTargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public wizthk_ThunkConnect16
wizthk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    wizthk_ThunkData16
	push	offset wizthk_ThunkData16
	push	seg    wizthk_ThkData32
	push	offset wizthk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
wizthk_ThkData32 label byte
	db	"wizthk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\endui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ENDUI.C - Functions for Wizard closing pages and internet tour
//      
//

//  HISTORY:
//  
//  1/12/95   jeremys Created.
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/10  markdu  Made all TCP/IP stuff be per-connectoid.
//  96/03/23  markdu  Removed unused TCP/IP code.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid.
//  96/04/06  markdu  NASH BUG 15369 Enable finish AND back button on last page,
//            and create the connectoid only after finish has been pressed.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/05/02  markdu  NASH BUG 17333 Write out IE news settings.
//  96/05/06  markdu  NASH BUG 21139 Turn off proxy server if connecting
//            over modem.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#include "wizard.h"
#include "icwextsn.h"
#include "imnext.h"

typedef HRESULT (APIENTRY *PFNSETDEFAULTMAILHANDLER)(VOID);
typedef HRESULT (APIENTRY *PFNSETDEFAULTNEWSHANDLER)(VOID);

#define REGKEY_NDC       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")
#define REGKEY_NDC_ENTRY TEXT("CascadeNetworkConnections")
#define REGKEY_NDC_VALUE TEXT("YES")

BOOL CommitConfigurationChanges(HWND hDlg);

/*******************************************************************

  NAME:    ConnectedOKInitProc

  SYNOPSIS:  Called when "Your are connected" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ConnectedOKInitProc(HWND hDlg,BOOL fFirstInit)
{
  // enable "finish" button instead of "next"
  PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH | PSWIZB_BACK);

  // if we've travelled through external apprentice pages,
  // it's easy for our current page pointer to get munged,
  // so reset it here for sanity's sake.
  gpWizardState->uCurrentPage = ORD_PAGE_CONNECTEDOK;

  return TRUE;
}

/*******************************************************************

  NAME:    ConnectedOKOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectedOKOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{

  if (fForward)
  {
    if (CONNECT_RAS == gpUserInfo->uiConnectionType)
    {
        HKEY hKey = NULL; 

        RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_NDC, 0, KEY_WRITE, &hKey);
        if (hKey)
        {
            RegSetValueEx(hKey, REGKEY_NDC_ENTRY, 0, REG_SZ, (LPBYTE)REGKEY_NDC_VALUE, sizeof(REGKEY_NDC_VALUE)*sizeof(TCHAR));
            CloseHandle(hKey);
        }
    }

    // set flag to indicate that the user completed the wizard
    gfUserFinished = TRUE;

    // go configure mail, RNA
    if (!CommitConfigurationChanges(hDlg))
    {
      // set flag to indicate that wizard should exit now
      gfQuitWizard = TRUE;

      return FALSE;
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    CommitConfigurationChanges

  SYNOPSIS:  Performs the following as appropriate:
        Mail configuration, RNA connectoid creation

  ENTRY:    hDlg - handle of parent window

  EXIT:    returns TRUE if successful or partially successful,
        FALSE if unsuccessful

  NOTES:    Displays its own error messages.  This function will
        continue as far as it can, if one item fails it will
        try to commit the rest.

********************************************************************/
BOOL CommitConfigurationChanges(HWND hDlg)
{
    HRESULT   hr;
    FARPROC   fpSetDefault;
    HKEY      hKey;
    TCHAR     szBuf[MAX_PATH+1];
    DWORD     size;


    // if connecting over modem, create a connectoid with
    // ISP name and phone number
    if ( CONNECT_RAS == gpUserInfo->uiConnectionType )
    {
        DWORD dwRet;

        // Only create the connectoid if it is new or has been modified
        if (gpUserInfo->fNewConnection || gpUserInfo->fModifyConnection)
        {
            DEBUGMSG("Creating/modifying connectoid %s", gpUserInfo->szISPName);
            dwRet = CreateConnectoid(NULL, gpUserInfo->szISPName, gpRasEntry,
              gpUserInfo->szAccountName,gpUserInfo->szPassword);

            if (dwRet != ERROR_SUCCESS)
            {
              DisplayErrorMessage(hDlg,IDS_ERRCreateConnectoid,
                dwRet,ERRCLS_RNA,MB_ICONEXCLAMATION);
              return FALSE;      
            }
        }

        // Only change the defaults if we are not just setting
        // up a new mail or news account.
        if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
        {
            //  96/05/06  markdu  NASH BUG 21139 Turn off proxy server if connecting
            //            over modem.
            gpUserInfo->fProxyEnable = FALSE;

            // set the name of this connectoid in registry as the connectoid
            // to use for autodialing
            //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
            InetSetAutodial(TRUE, gpUserInfo->szISPName);

            // clear any old backup number
            SetBackupInternetConnectoid(NULL);
        }
    }
    else if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
        // disable autodialing in registry because user is using LAN
        //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
        InetSetAutodial(FALSE, NULL);
    }


    if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
        if (CONNECT_LAN == gpUserInfo->uiConnectionType)
        {
            // write out proxy server config information
            hr = InetSetProxyEx(gpUserInfo->fProxyEnable,
                                NULL,
                                gpUserInfo->szProxyServer,
                                gpUserInfo->szProxyOverride);
            if (ERROR_SUCCESS != hr)
            {
                DisplayErrorMessage(hDlg,IDS_ERRConfigureProxy,
                  (DWORD) hr,ERRCLS_STANDARD,MB_ICONEXCLAMATION);
                return FALSE;    
            }
        }

        // make sure "The Internet" icon on desktop points to web browser
        // (it may initially be pointing at internet wizard)

        //  //10/24/96 jmazner Normandy 6968
        //  //No longer neccessary thanks to Valdon's hooks for invoking ICW.
        // 11/21/96 jmazner Normandy 11812
        // oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
        // ICW 1.1 needs to morph the IE 3 icon.

        SetDesktopInternetIconToBrowser();

        // set notation in registry whether user selected modem or LAN access,
        // for future reference...
        RegEntry re(szRegPathInternetSettings,HKEY_LOCAL_MACHINE);
        if (re.GetError() == ERROR_SUCCESS)
        {
            re.SetValue(szRegValAccessMedium,(DWORD)
              (CONNECT_LAN == gpUserInfo->uiConnectionType) ? USERPREF_LAN : USERPREF_MODEM);
            ASSERT(re.GetError() == ERROR_SUCCESS);

            re.SetValue(szRegValAccessType, (DWORD) ACCESSTYPE_OTHER_ISP);
            ASSERT(re.GetError() == ERROR_SUCCESS);
        }

        // set the username as the DNS host name, if there is no host name already
        // This is because some ISPs use the DNS host name for security for
        // access to mail, etc.  (Go figure!) 
        RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
        ASSERT(reTcp.GetError() == ERROR_SUCCESS);
        if (reTcp.GetError() == ERROR_SUCCESS)
        {
            TCHAR szHostName[SMALL_BUF_LEN+1]=TEXT("");
            // set DNS host name, but only if there's not a host name already set
            if (!reTcp.GetString(szRegValHostName,szHostName,sizeof(szHostName))
              || !lstrlen(szHostName))
              reTcp.SetValue(szRegValHostName,gpUserInfo->szAccountName);
        }

        // If DNS is set globally, clear it out so the per-connectoid settings
        // will be saved.
        BOOL  fTemp;
        DoDNSCheck(hDlg,&fTemp);
        if (TRUE == fTemp)
        {
            gpWizardState->fNeedReboot = TRUE;
        }
    }

    DWORD dwSaveErr = 0;

    if ( g_fAcctMgrUILoaded && gpImnApprentice )
    {
        CONNECTINFO myConnectInfo;
        myConnectInfo.cbSize = sizeof( CONNECTINFO );

#ifdef UNICODE
        wcstombs(myConnectInfo.szConnectoid, TEXT("Uninitialized\0"), MAX_PATH);
#else
        lstrcpy( myConnectInfo.szConnectoid, TEXT("Uninitialized\0"));
#endif

        myConnectInfo.type = gpUserInfo->uiConnectionType;

        if( CONNECT_RAS == myConnectInfo.type )
        {
#ifdef UNICODE
            wcstombs(myConnectInfo.szConnectoid, gpUserInfo->szISPName, MAX_PATH);
#else           
            lstrcpy( myConnectInfo.szConnectoid, gpUserInfo->szISPName);
#endif
        }


        gpImnApprentice->SetConnectionInformation( &myConnectInfo ); 
        gpImnApprentice->Save( g_pCICWExtension->m_hWizardHWND, &dwSaveErr );  

        if( ERR_MAIL_ACCT & dwSaveErr )
        {
            DEBUGMSG(TEXT("gpImnApprentice->Save returned with ERR_MAIL_ACCT!"));
        }
        if( ERR_NEWS_ACCT & dwSaveErr )
        {
            DEBUGMSG(TEXT("gpImnApprentice->Save returned with ERR_NEWS_ACCT!"));
        }
        if( ERR_DIRSERV_ACCT & dwSaveErr )
        {
            DEBUGMSG("gpImnApprentice->Save returned with ERR_DIR_SERV_ACCT!");
        }
    }
  

    // If we just completed the manual path (not just mail or news) then
    // set the registry key saying that we completed ICW.
    if ( !(gpWizardState->dwRunFlags & RSW_APPRENTICE) )
    {
        RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);
        if (ERROR_SUCCESS == re.GetError())
            re.SetValue(szRegValICWCompleted, (DWORD)1);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  11/27/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//

#include "wizard.h"

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <devguid.h>

// global variables 
static const CHAR c_szModemCPL[] = "rundll32.exe Shell32.dll,Control_RunDLL modem.cpl,,add";

// Define prorotype for InstallNewDevice, exported
// by newdev.dll, which we will now call in order
// to get to the hardware wizard, instead of calling
// the class installer directly;
// also, define constants for the name of the dll and
// the export
typedef BOOL (WINAPI *PINSTNEWDEV)(HWND, LPGUID, PDWORD);

LPGUID g_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;


/*******************************************************************

  NAME:    InvokeModemWizard

  SYNOPSIS:  Starts the modem install wizard

  ENTRY:    hwndToHide - this window, if non-NULL, will be hidden while
        the modem CPL runs

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    launches RUNDLL32 as a process to run the modem wizard.
        Blocks on the completion of that process before returning.

        hwndToHide is not necessarily the calling window!
        For instance, in a property sheet hwndToHide should not be the
        dialog (hDlg), but GetParent(hDlg) so that we hide the property
        sheet itself instead of just the current page.

********************************************************************/
UINT InvokeModemWizard(HWND hwndToHide)
{
    BOOL bSleepNeeded = FALSE;
    UINT err = ERROR_SUCCESS;

    if (IsNT5())
    {
        BOOL bUserIsAdmin = FALSE;
        HKEY hkey;

        if(RegOpenKeyEx(HKEY_USERS, TEXT(".DEFAULT"), 0, KEY_WRITE, &hkey) == 0)
        {
            RegCloseKey(hkey);
            bUserIsAdmin = TRUE;
        }

        //Is the user an admin?
        if(!bUserIsAdmin)
        {
            return ERROR_PRIVILEGE_NOT_HELD;
        }

        /*
        We do this messy NT 5.0 hack because for the time being the 
        NT 4.0 API call fails to kil off the modem wizard in NT 5.0
        In the future when this problem is corrected the origional code should
        prpoably be restored a-jaswed

        Jason Cobb suggested to use InstallNewDevice method on NT5 to invoke MDM WIZ.
        */

        HINSTANCE hInst = NULL;
        PINSTNEWDEV pInstNewDev;
        BOOL bRet = 0;

        TCHAR msg[1024];

        hInst = LoadLibrary (TEXT("hdwwiz.cpl"));
        if (NULL != hInst)
        {

            pInstNewDev = (PINSTNEWDEV)GetProcAddress (hInst, "InstallNewDevice");
            if (NULL != pInstNewDev)
            {
                bRet = pInstNewDev (hwndToHide, g_pguidModem, NULL);
            }

        }
        if (!bRet)
            err = GetLastError();
        FreeLibrary (hInst);
        return err;

    }
    else if (FALSE == IsNT())
    {

        PROCESS_INFORMATION pi;
        BOOL fRet;
        STARTUPINFOA sti;
        TCHAR szWindowTitle[255];

        ZeroMemory(&sti,sizeof(STARTUPINFO));
        sti.cb = sizeof(STARTUPINFO);

        // run the modem wizard
        fRet = CreateProcessA(NULL, (LPSTR)c_szModemCPL,
                               NULL, NULL, FALSE, 0, NULL, NULL,
                               &sti, &pi);
        if (fRet) 
        {
            CloseHandle(pi.hThread);

            // wait for the modem wizard process to complete
            MsgWaitForMultipleObjectsLoop(pi.hProcess);
            CloseHandle(pi.hProcess);
        } 
        else
            err = GetLastError();
        return err;
    }
    else //NT 4.0
    {
        BOOL bNeedsStart;
        
        //
        // Call into icfg32 dll
        //
        if (NULL != lpIcfgInstallModem)
        {
            lpIcfgInstallModem(hwndToHide, 0L, &bNeedsStart);
            return ERROR_SUCCESS;
        }
        else
            return ERROR_GEN_FAILURE;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#include "wizard.h"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPTSTR)::GlobalAlloc(GPTR,sizeof(TCHAR)*cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, sizeof(TCHAR)*cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPTSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const TCHAR *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const TCHAR *pszValue, const TCHAR *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (BYTE *)string, sizeof(TCHAR)*(lstrlen(string)+1));
    }
  return _error;
}

long RegEntry::SetValue(const TCHAR *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (BYTE *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const TCHAR *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


TCHAR *RegEntry::GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;
  
    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const TCHAR *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;
  
  return dwNumber;
}

long RegEntry::MoveToSubKey(const TCHAR *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new TCHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(size_t size)
{
  return (void *)::GlobalAlloc(GPTR,size); 
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  TCHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  TCHAR * QueryPtr() const { return (TCHAR *)_lpBuffer; }
  operator TCHAR *() const { return (TCHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const TCHAR *pszValue, const TCHAR *string);
    long  SetValue(const TCHAR *pszValue, unsigned long dwNumber);
    TCHAR *  GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
    long  GetNumber(const TCHAR *pszValue, long dwDefault = 0);
    long  DeleteValue(const TCHAR *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const TCHAR *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    TCHAR *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    TCHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\export.cpp ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: EXPORT.C
//
//  PURPOSE:  Contains external API's for use by signup wizard.
//
//  HISTORY:
//  96/03/05  markdu  Created.
//  96/03/11  markdu  Added InetConfigClient()
//  96/03/11  markdu  Added InetGetAutodial() and InetSetAutodial().
//  96/03/12  markdu  Added UI during file install.
//  96/03/12  markdu  Added ValidateConnectoidData().
//  96/03/12  markdu  Set connectoid for autodial if INETCFG_SETASAUTODIAL
//            is set.  Renamed ValidateConnectoidData to MakeConnectoid.
//  96/03/12  markdu  Added hwnd param to InetConfigClient() and
//            InetConfigSystem().
//  96/03/13  markdu  Added INETCFG_OVERWRITEENTRY.  Create unique neame
//            for connectoid if it already exists and we can't overwrite.
//  96/03/13  markdu  Added InstallTCPAndRNA().
//  96/03/13  markdu  Added LPINETCLIENTINFO param to InetConfigClient()
//  96/03/16  markdu  Added INETCFG_INSTALLMODEM flag.
//  96/03/16  markdu  Use ReInit member function to re-enumerate modems.
//  96/03/19  markdu  Split export.h into export.h and csexport.h
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Validate lpfNeedsRestart before using.
//  96/03/25  markdu  Clean up some error handling.
//  96/03/26  markdu  Use MAX_ISP_NAME instead of RAS_MaxEntryName 
//            because of bug in RNA.
//  96/03/26  markdu  Implemented UpdateMailSettings().
//  96/03/27  mmaclin InetGetProxy()and InetSetProxy().
//  96/04/04  markdu  NASH BUG 15610  Check for file and printer sharing
//            bound to TCP/IP .
//  96/04/04  markdu  Added phonebook name param to InetConfigClient,
//            MakeConnectoid, SetConnectoidUsername, CreateConnectoid,
//            and ValidateConnectoidName.
//  96/04/05  markdu  Set internet icon on desktop to point to browser.
//  96/04/06  mmaclin Changed InetSetProxy to check for NULL.
//  96/04/06  markdu  NASH BUG 16404 Initialize gpWizardState in
//            UpdateMailSettings.
//  96/04/06  markdu  NASH BUG 16441 If InetSetAutodial is called with NULL
//            as the connection name, the entry is not changed.
//  96/04/18  markdu  NASH BUG 18443 Make exports WINAPI.
//  96/04/19  markdu  NASH BUG 18605 Handle ERROR_FILE_NOT_FOUND return
//            from ValidateConnectoidName.
//  96/04/19  markdu  NASH BUG 17760 Do not show choose profile UI.
//  96/04/22  markdu  NASH BUG 18901 Do not set desktop internet icon to 
//            browser if we are just creating a temp connectoid.
//  96/04/23  markdu  NASH BUG 18719 Make the choose profile dialog TOPMOST.
//  96/04/25  markdu  NASH BUG 19572 Only show choose profile dialog if
//            there is an existing profile.
//  96/04/29  markdu  NASH BUG 20003 Added InetConfigSystemFromPath
//            and removed InstallTCPAndRNA.
//  96/05/01  markdu  NASH BUG 20483 Do not display "installing files" dialog
//            if INETCFG_SUPPRESSINSTALLUI is set.
//  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.  This is 
//            required because sometimes the configuration manager does not 
//            set up the modem correctly, and the user will not be able to
//            dial (will get cryptic error message) until reboot.
//  96/05/06  markdu  NASH BUG 21027  If DNS is set globally, clear it out so
//            the per-connectoid settings will be saved.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/05/28  markdu  Moved InitConfig and DeInitConfig to DllEntryPoint.
//    96/10/21  valdonb Added CheckConnectionWizard and InetCreateMailNewsAccount
//
//*******************************************************************

#include "wizard.h"
#include "inetcfg.h"
#include "icwextsn.h"
#include <icwcfg.h>

// constants
#define LEN_APPEND_INT              3           // number of digits for MAX_APPEND_INT  
#define MAX_APPEND_INT              999         // maximum number to append to connectoid name                                  // when cycling through names to create unique name


#pragma data_seg(".rdata")

// Registry constants
static const TCHAR cszRegPathInternetSettings[]    = REGSTR_PATH_INTERNET_SETTINGS;
static const TCHAR cszRegPathInternetLanSettings[] = REGSTR_PATH_INTERNET_LAN_SETTINGS; 
static const TCHAR cszRegValProxyEnable[]          = REGSTR_VAL_PROXYENABLE;
static const TCHAR cszRegValProxyServer[]          = REGSTR_VAL_PROXYSERVER;
static const TCHAR cszRegValProxyOverride[]        = REGSTR_VAL_PROXYOVERRIDE;
static const TCHAR cszRegValAutoProxyDetectMode[]  = TEXT("AutoProxyDetectMode");
static const TCHAR cszRegValAutoConfigURL[]        = TEXT("AutoConfigURL");

static const TCHAR cszWininet[] = TEXT("WININET.DLL");
static const  CHAR cszInternetSetOption[]   = "InternetSetOptionA";  
static const  CHAR cszInternetQueryOption[] = "InternetQueryOptionA";

#define REGSTR_PATH_TELEPHONYLOCATIONS  REGSTR_PATH_SETUP TEXT("\\Telephony\\Locations")

#pragma data_seg()

// structure to pass data back from IDD_NEEDDRIVERS handler
typedef struct tagNEEDDRIVERSDLGINFO
{
  DWORD       dwfOptions;
  LPBOOL      lpfNeedsRestart;
} NEEDDRIVERSDLGINFO, * PNEEDDRIVERSDLGINFO;

// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  TCHAR szModemName[RAS_MaxDeviceName + 1];
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

// structure to pass data back from IDD_CHOOSEPROFILENAME handler
typedef struct tagCHOOSEPROFILEDLGINFO
{
  TCHAR szProfileName[cchProfileNameMax+1];
  BOOL fSetProfileAsDefault;
} CHOOSEPROFILEDLGINFO, * PCHOOSEPROFILEDLGINFO;

// Function prototypes internal to this file
HRESULT UpdateMailSettings(HWND hwndParent, LPINETCLIENTINFO lpINetClientInfo,
  LPTSTR lpszEntryName);
INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
int  NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo);
VOID EnableDlg(HWND hDlg,BOOL fEnable);
INT_PTR CALLBACK ChooseProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,  LPARAM lParam);
BOOL ChooseProfileDlgInit(HWND hDlg,CHOOSEPROFILEDLGINFO * pChooseProfileDlgInfo);
BOOL ChooseProfileDlgOK(HWND hDlg,CHOOSEPROFILEDLGINFO * pChooseProfileDlgInfo);
DWORD MakeConnectoid(
  HWND        hwndParent,
  DWORD       dwfOptions,
  LPCTSTR      lpszPhonebook,
  LPCTSTR      lpszEntryName,
  LPRASENTRY  lpRasEntry,
  LPCTSTR      lpszUsername,
  LPCTSTR      lpszPassword,
  LPBOOL      lpfNeedsRestart);
HWND WaitCfgInit(HWND hwndParent, DWORD dwIDS);

// Function prototypes external to this file
VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags);
BOOL DoNewProfileDlg(HWND hDlg);
extern DWORD SetIEClientInfo(LPINETCLIENTINFO lpClientInfo);
extern ICFGSETINSTALLSOURCEPATH     lpIcfgSetInstallSourcePath;
extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;

extern BOOL ValidateProductSuite(LPTSTR SuiteName);


#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc(LPCSTR);
VOID   ToAnsiClientInfo(LPINETCLIENTINFOA, LPINETCLIENTINFOW);
VOID   ToUnicodeClientInfo(LPINETCLIENTINFOW, LPINETCLIENTINFOA);
#endif

//
// from rnacall.cpp
//
extern BOOL InitTAPILocation(HWND hwndParent);

#define SMART_RUNICW TRUE
#define SMART_QUITICW FALSE

#include "wininet.h"
typedef BOOL (WINAPI * INTERNETSETOPTION) (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,IN DWORD dwBufferLength);
typedef BOOL (WINAPI * INTERNETQUERYOPTION) (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,IN LPDWORD dwBufferLength);

static const TCHAR g_szRegPathICWSettings[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
static const TCHAR g_szRegValICWCompleted[] = TEXT("Completed");
BOOL        g_bUseAutoProxyforConnectoid = TRUE;

//*******************************************************************
//
//  FUNCTION:   InetConfigSystem
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/05  markdu  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetConfigSystem(
                                           HWND hwndParent,
                                           DWORD dwfOptions,
                                           LPBOOL lpfNeedsRestart)
{
    DWORD         dwRet = ERROR_SUCCESS;
    BOOL          fNeedsRestart = FALSE;  // Default to no reboot needed
    // 4/2/97 ChrisK    Olympus 209
    HWND          hwndWaitDlg = NULL;
    TCHAR         szWindowTitle[255];
    BOOL          bSleepNeeded = FALSE;

    /*
    We do this messy NT 5.0 hack because for the time being the 
    NT 4.0 API call fails to kil off the modem wizard in NT 5.0
    , so we need to pretend we are like 9x
    In the future when this problem is corrected the origional code should
    prpoably be restored -- ALL references to this BOOL should be deleted.
    a-jaswed
    */
    BOOL bNT5NeedModem = FALSE;

    DEBUGMSG("export.c::InetConfigSystem()");
    
    // Validate the parent hwnd
    if (hwndParent && !IsWindow(hwndParent))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Set up the install options
    DWORD dwfInstallOptions = 0;
    if (dwfOptions & INETCFG_INSTALLTCP)
    {
        dwfInstallOptions |= ICFG_INSTALLTCP;
    }
    if (dwfOptions & INETCFG_INSTALLRNA)
    {
        dwfInstallOptions |= ICFG_INSTALLRAS;
    }
    if (dwfOptions & INETCFG_INSTALLMAIL)
    {
        dwfInstallOptions |= ICFG_INSTALLMAIL;
    }
    
    // see if we need to install drivers
    BOOL  fNeedSysComponents = FALSE;
    
    // 4/2/97 ChrisK Olympus 209 Display busy dialog
    if (INETCFG_SHOWBUSYANIMATION == (dwfOptions & INETCFG_SHOWBUSYANIMATION))
        hwndWaitDlg = WaitCfgInit(hwndParent,IDS_WAITCHECKING);
    
    // 
    // Kill Modem control panel if it's already running
    // 4/16/97 ChrisK Olympus 239
    // 6/9/97 jmazner moved this functionality from InvokeModemWizard
    szWindowTitle[0] = '\0';
    LoadSz(IDS_MODEM_WIZ_TITLE,szWindowTitle,255);
    HWND hwndModem = FindWindow(TEXT("#32770"),szWindowTitle);
    if (NULL != hwndModem)
    {
        // Close modem installation wizard
        PostMessage(hwndModem, WM_CLOSE, 0, 0);
        bSleepNeeded = TRUE;
    }
    
    // close modem control panel applet
    LoadSz(IDS_MODEM_CPL_TITLE,szWindowTitle,255);
    hwndModem = FindWindow(TEXT("#32770"),szWindowTitle);
    if (NULL != hwndModem)
    {
        PostMessage(hwndModem, WM_SYSCOMMAND,SC_CLOSE, 0);
        bSleepNeeded = TRUE;
    }
    
    if (bSleepNeeded)
    {
        Sleep(1000);
    }
    
    dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedSysComponents);
    
    if (ERROR_SUCCESS != dwRet)
    {
        TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
        
        
        // 4/2/97 ChrisK Olympus 209
        // Dismiss busy dialog
        if (NULL != hwndWaitDlg)
        {
            BringWindowToTop(hwndParent);
            DestroyWindow(hwndWaitDlg);
            hwndWaitDlg = NULL;
        }
        
        //
        // Get the text of the error message and display it.
        //
        if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
        {
            MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
        }
        
        return dwRet;
    }
    
    if (fNeedSysComponents) 
    {
        // 4/2/97 ChrisK Olympus 209
        // if we are going to install something the busy dialog isn't needed
        if (NULL != hwndWaitDlg)
        {
            BringWindowToTop(hwndParent);
            ShowWindow(hwndWaitDlg,SW_HIDE);
        }
        
        if (dwfOptions & INETCFG_SUPPRESSINSTALLUI)
        {
            dwRet = lpIcfgInstallInetComponents(hwndParent, dwfInstallOptions, &fNeedsRestart);
            //
            // Display error message only if it failed due to something 
            // other than user cancel
            //
            if ((ERROR_SUCCESS != dwRet) && (ERROR_CANCELLED != dwRet))
            {
                TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
                
                // Get the text of the error message and display it.
                if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
                {
                    MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
                }
            }
        }
        else
        {
            // structure to pass to dialog to fill out
            NEEDDRIVERSDLGINFO NeedDriversDlgInfo;
            NeedDriversDlgInfo.dwfOptions = dwfInstallOptions;
            NeedDriversDlgInfo.lpfNeedsRestart = &fNeedsRestart;
            
            // Clear out the last error code so we can safely use it.
            SetLastError(ERROR_SUCCESS);
            
            // Display a dialog and allow the user to cancel install
            int iRet = (int)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_NEEDDRIVERS),hwndParent,
                NeedDriversDlgProc,(LPARAM) &NeedDriversDlgInfo);
            if (0 == iRet)
            {
                // user cancelled
                dwRet = ERROR_CANCELLED;
            }
            else if (-1 == iRet)
            {
                // an error occurred.
                dwRet = GetLastError();
                if (ERROR_SUCCESS == dwRet)
                {
                    // Error occurred, but the error code was not set.
                    dwRet = ERROR_INETCFG_UNKNOWN;
                }
            }
        }
    }
    
    if ( (ERROR_SUCCESS == dwRet) && (TRUE == IsNT()) && (dwfOptions & INETCFG_INSTALLMODEM))
    {
        BOOL bNeedModem = FALSE;
        
        if (NULL == lpIcfgNeedModem)
        {
            //
            // 4/2/97 ChrisK Olympus 209
            //
            if (NULL != hwndWaitDlg)
            {
                BringWindowToTop(hwndParent);
                DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
            }
            
            return ERROR_GEN_FAILURE;
        }
        
        //
        // 4/2/97 ChrisK Olympus 209
        // Show busy dialog here, this can take a few seconds
        //
        if (NULL != hwndWaitDlg)
            ShowWindow(hwndWaitDlg,SW_SHOW);
        
        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS != dwRet)
        {
            //
            // 4/2/97 ChrisK Olympus 209
            //
            if (NULL != hwndWaitDlg)
            {
                BringWindowToTop(hwndParent);
                DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
            }
            
            return dwRet;
        }
        
        if (TRUE == bNeedModem)
        {
            if (IsNT5() == TRUE)
            {
                bNT5NeedModem = bNeedModem;
            }
            else
            {
                // 4/2/97 ChrisK Olympus 209
                if (NULL != hwndWaitDlg)
                {  
                    BringWindowToTop(hwndParent);
                    DestroyWindow(hwndWaitDlg);
                    hwndWaitDlg = NULL;
                }
            
                MsgBoxParam(hwndParent,IDS_ERRNoDialOutModem,MB_ICONERROR,MB_OK);
                return ERROR_GEN_FAILURE;
            }
        }

        //
        // 7/15/97    jmazner    Olympus #6294
        // make sure TAPI location info is valid
        //
        if (!InitTAPILocation(hwndParent))
        {
            if (NULL != hwndWaitDlg)
            {  
                BringWindowToTop(hwndParent);
                DestroyWindow(hwndWaitDlg);
                hwndWaitDlg = NULL;
            }
        
            return ERROR_CANCELLED;
        }

    }
    
    // 4/2/97 ChrisK Olympus 209
    if (NULL != hwndWaitDlg)
    {
        BringWindowToTop(hwndParent);
        ShowWindow(hwndWaitDlg,SW_HIDE);
    }
    
    // See if we are supposed to check if file sharing is turned on
    if (ERROR_SUCCESS == dwRet && !(ValidateProductSuite( TEXT("Small Business") )))
    {
        BOOL fNeedsRestartTmp = FALSE;
        if (dwfOptions & INETCFG_REMOVEIFSHARINGBOUND)
        {
            // Tell user that we cannot continue unless binding is removed.
            dwRet = RemoveIfServerBound(hwndParent,
                (dwfOptions & INETCFG_CONNECTOVERLAN)? INSTANCE_NETDRIVER : INSTANCE_PPPDRIVER, &fNeedsRestartTmp);
        }
        else if (dwfOptions & INETCFG_WARNIFSHARINGBOUND)
        {
            // Warn user that binding should be removed.
            dwRet = WarnIfServerBound(hwndParent,
                (dwfOptions & INETCFG_CONNECTOVERLAN)?INSTANCE_NETDRIVER : INSTANCE_PPPDRIVER, &fNeedsRestartTmp);
        }
        
        // If the settings were removed, we need to reboot.
        if ((ERROR_SUCCESS == dwRet) && (TRUE == fNeedsRestartTmp))
        {
            fNeedsRestart = TRUE;
        }

        // If user installed net component but we need cancel F&P sharing, we still need to restart
        // or NT becomes unstable - Bug 68641
        if(ERROR_CANCELLED == dwRet && fNeedsRestart && IsNT())
            dwRet = ERROR_SUCCESS;
    }
    
    // 4/2/97 ChrisK Olympus 209
    // Dismiss dialog for good
    if (NULL != hwndWaitDlg)
    {
        BringWindowToTop(hwndParent);
        DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
    }
      
    //
    // If not NT then we install the modem after installing RAS
    //
    // See if we are supposed to install a modem
    if (((FALSE == IsNT()) || (bNT5NeedModem))  && (ERROR_SUCCESS == dwRet) && 
        (dwfOptions & INETCFG_INSTALLMODEM))
    {
        // Load RNA if not already loaded since ENUM_MODEM needs it.
        dwRet = EnsureRNALoaded();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }
        
        
        // Enumerate the modems 
        ENUM_MODEM  EnumModem;
        dwRet = EnumModem.GetError();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        // If there are no modems, install one if requested.
        if (0 == EnumModem.GetNumDevices())
        {    
            //
            // 5/22/97 jmazner    Olympus #4698
            // On Win95, calling RasEnumDevices launches RNAAP.EXE
            // If RNAAP.EXE is running, any modems you install won't be usable
            // So, nuke RNAAP.EXE before installing the modem.
            //
            TCHAR szWindowTitle[255] = TEXT("\0nogood");
            
            //
            // Unload the RAS dll's before killing RNAAP, just to be safe
            //
            DeInitRNA();
            
            LoadSz(IDS_RNAAP_TITLE,szWindowTitle,255);
            HWND hwnd = FindWindow(szWindowTitle, NULL);
            if (NULL != hwnd)
            {
                if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
                {
                    DEBUGMSG("Trying to kill RNAAP window returned getError %d", GetLastError());
                }
            }
        
            // invoke the modem wizard UI to install the modem
            UINT uRet = InvokeModemWizard(hwndParent);
            
            if (ERROR_PRIVILEGE_NOT_HELD == uRet)
            {
                TCHAR szAdminDenied      [MAX_PATH] = TEXT("\0");
                LoadSz(IDS_ADMIN_ACCESS_DENIED, szAdminDenied, MAX_PATH);
                MsgBoxSz(hwndParent,szAdminDenied,MB_ICONEXCLAMATION,MB_OK);
                return ERROR_CANCELLED;

            }
            else if (uRet != ERROR_SUCCESS)
            {
                DisplayErrorMessage(hwndParent,IDS_ERRInstallModem,uRet,
                    ERRCLS_STANDARD,MB_ICONEXCLAMATION);
                return ERROR_INVALID_PARAMETER;
            }
            
            // Reload the RAS dlls now that the modem has been safely installed.
            InitRNA(hwndParent);
        
            // Re-numerate the modems to be sure we have the most recent changes  
            dwRet = EnumModem.ReInit();
            if (ERROR_SUCCESS != dwRet)
            {
                return dwRet;
            }
            
            // If there are still no modems, user cancelled
            if (0 == EnumModem.GetNumDevices())
            {
                return ERROR_CANCELLED;
            }
            else
            {
                // removed per GeoffR request 5-2-97
                ////  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.
                //fNeedsRestart = TRUE;
            }
        }
        else
        {
            //
            // 7/15/97    jmazner    Olympus #6294
            // make sure TAPI location info is valid
            //
            // 4/15/99 vyung Tapi changed the location dlg
            if (!InitTAPILocation(hwndParent))
            {
                if (NULL != hwndWaitDlg)
                {  
                    BringWindowToTop(hwndParent);
                    DestroyWindow(hwndWaitDlg);
                    hwndWaitDlg = NULL;
                }

                return ERROR_CANCELLED;
            }
        }
    }
    
    // tell caller whether we need to reboot or not
    if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
    {
        *lpfNeedsRestart = fNeedsRestart;
    }
    
    // 4/2/97 ChrisK    Olympus 209
    // Sanity check
    if (NULL != hwndWaitDlg)
    {
        BringWindowToTop(hwndParent);
        DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
    }
    
    return dwRet;
}




//*******************************************************************
//
//  FUNCTION:   InetNeedSystemComponents
//
//  PURPOSE:    This function will check is components that are needed
//              for internet access (such as TCP/IP and RNA) are already
//                configured based the state of the options flags.
//
//  PARAMETERS: dwfOptions - a combination of INETCFG_ flags that controls
//                                the installation and configuration as follows:
//
//                                INETCFG_INSTALLRNA - install RNA (if needed)
//                                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//
//              lpfNeedsConfig - On return, this will be 
//                                    TRUE if system component(s)
//                                    should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:    05/02/97  VetriV  Created.
//                05/08/97  ChrisK  Added INSTALLLAN, INSTALLDIALUP, and
//                                  INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedSystemComponents(DWORD dwfOptions,
                                                      LPBOOL lpbNeedsConfig)
{
    DWORD    dwRet = ERROR_SUCCESS;


    DEBUGMSG("export.cpp::InetNeedSystemComponents()");

    //
    // Validate parameters
    //
    if (!lpbNeedsConfig)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set up the install options
    //
    DWORD dwfInstallOptions = 0;
    if (dwfOptions & INETCFG_INSTALLTCP)
    {
        dwfInstallOptions |= ICFG_INSTALLTCP;
    }
    if (dwfOptions & INETCFG_INSTALLRNA)
    {
        dwfInstallOptions |= ICFG_INSTALLRAS;
    }

    //
    // ChrisK 5/8/97
    //
    if (dwfOptions & INETCFG_INSTALLLAN)
    {
        dwfInstallOptions |= ICFG_INSTALLLAN;
    }
    if (dwfOptions & INETCFG_INSTALLDIALUP)
    {
        dwfInstallOptions |= ICFG_INSTALLDIALUP;
    }
    if (dwfOptions & INETCFG_INSTALLTCPONLY)
    {
        dwfInstallOptions |= ICFG_INSTALLTCPONLY;
    }

  
    //
    // see if we need to install drivers
    //
    BOOL  bNeedSysComponents = FALSE;

    dwRet = lpIcfgNeedInetComponents(dwfInstallOptions, &bNeedSysComponents);

    if (ERROR_SUCCESS != dwRet)
    {
        TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");

        //
        // Get the text of the error message and display it.
        //
        if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
        {
            DEBUGMSG(szErrorText);
        }

        return dwRet;
    }

    
    *lpbNeedsConfig = bNeedSysComponents;
    return ERROR_SUCCESS;
}

  

//*******************************************************************
//
//  FUNCTION:   InetNeedModem
//
//  PURPOSE:    This function will check if modem is needed or not
//
//  PARAMETERS: lpfNeedsConfig - On return, this will be 
//                                    TRUE if modem
//                                    should be installed
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:    05/02/97  VetriV  Created.
//
//*******************************************************************

extern "C" HRESULT WINAPI InetNeedModem(LPBOOL lpbNeedsModem)
{

    DWORD dwRet = ERROR_SUCCESS;
        
    //
    // Validate parameters
    //
    if (!lpbNeedsModem)
    {
        return ERROR_INVALID_PARAMETER;
    }

    
    if (TRUE == IsNT())
    {
        //
        // On NT call icfgnt.dll to determine if modem is needed
        //
        BOOL bNeedModem = FALSE;
        
        if (NULL == lpIcfgNeedModem)
        {
            return ERROR_GEN_FAILURE;
        }
    

        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        *lpbNeedsModem = bNeedModem;
        return ERROR_SUCCESS;
    }
    else
    {
        //
        // Load RNA if not already loaded since ENUM_MODEM needs it.
        //
        dwRet = EnsureRNALoaded();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        //
        // Enumerate the modems
        //
        ENUM_MODEM  EnumModem;
        dwRet = EnumModem.GetError();
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        //
        // If there are no modems, we need to install one
        //
        if (0 == EnumModem.GetNumDevices())
        {
            *lpbNeedsModem = TRUE;
        }
        else
        {
            *lpbNeedsModem = FALSE;
        }
        return ERROR_SUCCESS;
    }
}



//*******************************************************************
//
//  FUNCTION:   InetConfigSystemFromPath
//
//  PURPOSE:    This function will install files that are needed
//              for internet access (such as TCP/IP and RNA) based
//              the state of the options flags and from the given [ath.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//              lpszSourcePath - full path of location of files to install.  If
//              this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/04/29  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI InetConfigSystemFromPathA
(
  HWND hwndParent,
  DWORD dwfOptions,
  LPBOOL lpfNeedsRestart,
  LPCSTR lpszSourcePath
)
{
  TCHAR  szSourcePath[MAX_PATH+1];
  mbstowcs(szSourcePath, lpszSourcePath, lstrlenA(lpszSourcePath)+1);
  return InetConfigSystemFromPathW(hwndParent, dwfOptions,
                                   lpfNeedsRestart, szSourcePath);
}

HRESULT WINAPI InetConfigSystemFromPathW
#else
HRESULT WINAPI InetConfigSystemFromPathA
#endif
(
  HWND hwndParent,
  DWORD dwfOptions,
  LPBOOL lpfNeedsRestart,
  LPCTSTR lpszSourcePath
)
{
  DWORD dwRet;

  DEBUGMSG("export.c::InetConfigSystemFromPath()");

  // Validate the parent hwnd
  if (hwndParent && !IsWindow(hwndParent))
  {
    return ERROR_INVALID_PARAMETER;
  }

  // Set the install path here
  if (lpszSourcePath && lstrlen(lpszSourcePath))
  {
    dwRet = lpIcfgSetInstallSourcePath(lpszSourcePath);

    if (ERROR_SUCCESS != dwRet)
    {
      return dwRet;
    }
  }

  // Install files if needed.
  dwRet = InetConfigSystem(hwndParent,
    dwfOptions, lpfNeedsRestart);

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   InetConfigClient
//
//  PURPOSE:    This function requires a valid phone book entry name
//              (unless it is being used just to set the client info).
//              If lpRasEntry points to a valid RASENTRY struct, the phone
//              book entry will be created (or updated if it already exists)
//              with the data in the struct.
//              If username and password are given, these
//              will be set as the dial params for the phone book entry.
//              If a client info struct is given, that data will be set.
//              Any files (ie TCP and RNA) that are needed will be
//              installed by calling InetConfigSystem().
//              This function will also perform verification on the device
//              specified in the RASENTRY struct.  If no device is specified,
//              the user will be prompted to install one if there are none
//              installed, or they will be prompted to choose one if there
//              is more than one installed.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "installing files"
//              dialog.
//              lpszPhonebook - name of phone book to store the entry in
//              lpszEntryName - name of phone book entry to be
//              created or modified
//              lpRasEntry - specifies a RASENTRY struct that contains
//              the phone book entry data for the entry lpszEntryName
//              lpszUsername - username to associate with the phone book entry
//              lpszPassword - password to associate with the phone book entry
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//              lpINetClientInfo - client information
//              dwfOptions - a combination of INETCFG_ flags that controls
//              the installation and configuration as follows:
//
//                INETCFG_INSTALLMAIL - install exchange and internet mail
//                INETCFG_INSTALLMODEM - Invoke InstallModem wizard if NO
//                                       MODEM IS INSTALLED.  Note that if
//                                       no modem is installed and this flag
//                                       is not set, the function will fail
//                INETCFG_INSTALLRNA - install RNA (if needed)
//                INETCFG_INSTALLTCP - install TCP/IP (if needed)
//                INETCFG_CONNECTOVERLAN - connecting with LAN (vs modem)
//                INETCFG_SETASAUTODIAL - Set the phone book entry for autodial
//                INETCFG_OVERWRITEENTRY - Overwrite the phone book entry if it
//                                         exists.  Note: if this flag is not
//                                         set, and the entry exists, a unique
//                                         name will be created for the entry.
//                INETCFG_WARNIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                            turned on, and warn user to turn
//                                            it off.  Reboot is required if
//                                            the user turns it off.
//                INETCFG_REMOVEIFSHARINGBOUND - Check if TCP/IP file sharing is
//                                              turned on, and force user to turn
//                                              it off.  If user does not want to
//                                              turn it off, return will be
//                                              ERROR_CANCELLED.  Reboot is
//                                              required if the user turns it off.
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetConfigClientA
(
  HWND              hwndParent,
  LPCSTR            lpszPhonebook,
  LPCSTR            lpszEntryName,
  LPRASENTRY        lpRasEntry,
  LPCSTR            lpszUsername,
  LPCSTR            lpszPassword,
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpINetClientInfo,
  DWORD             dwfOptions,
  LPBOOL            lpfNeedsRestart
)
{
  LPTSTR pszPhonebook = NULL;
  LPTSTR pszEntryName = NULL;
  LPTSTR pszUsername = NULL;
  LPTSTR pszPassword = NULL;
  LPTSTR pszProfileName = NULL;
  INETCLIENTINFOW *pINetClientInfo = NULL;
  
  TCHAR szPhonebook[sizeof(TCHAR*)*(MAX_PATH+1)]    = TEXT("");
  TCHAR szEntryName[sizeof(TCHAR*)*(MAX_PATH+1)]    = TEXT("");
  TCHAR szUsername[sizeof(TCHAR*)*(MAX_PATH+1)]     = TEXT("");
  TCHAR szPassword[sizeof(TCHAR*)*(MAX_PATH+1)]     = TEXT("");
  TCHAR szProfileName[sizeof(TCHAR*)*(MAX_PATH+1)]  = TEXT("");
  INETCLIENTINFOW   INetClientInfo;

  if (NULL != lpszPhonebook)
  {
    mbstowcs(szPhonebook,   lpszPhonebook,   lstrlenA(lpszPhonebook)+1);
    pszPhonebook = szPhonebook;
  }
  if (NULL != lpszEntryName)
  {
    mbstowcs(szEntryName,   lpszEntryName,   lstrlenA(lpszEntryName)+1);
    pszEntryName = szEntryName;
  }
  if (NULL != lpszUsername)
  {
    mbstowcs(szUsername,    lpszUsername,    lstrlenA(lpszUsername)+1);
    pszUsername = szUsername;
  }
  if (NULL != lpszPassword)
  {
    mbstowcs(szPassword,    lpszPassword,    lstrlenA(lpszPassword)+1);
    pszPassword = szPassword;
  }
  if (NULL != lpszProfileName)
  {
    mbstowcs(szProfileName, lpszProfileName, lstrlenA(lpszProfileName)+1);
    pszProfileName = szProfileName;
  }

  if (lpINetClientInfo)
  {
    ToUnicodeClientInfo(&INetClientInfo, lpINetClientInfo);
    pINetClientInfo = &INetClientInfo;
  }

  return InetConfigClientW(hwndParent,
                           pszPhonebook,
                           pszEntryName,
                           lpRasEntry,
                           pszUsername,
                           pszPassword,
                           pszProfileName,
                           pINetClientInfo,
                           dwfOptions,
                           lpfNeedsRestart);
}

extern "C" HRESULT WINAPI InetConfigClientW
#else
extern "C" HRESULT WINAPI InetConfigClientA
#endif
(
  HWND              hwndParent,
  LPCTSTR           lpszPhonebook,
  LPCTSTR           lpszEntryName,
  LPRASENTRY        lpRasEntry,
  LPCTSTR           lpszUsername,
  LPCTSTR           lpszPassword,
  LPCTSTR           lpszProfileName,
  LPINETCLIENTINFO  lpINetClientInfo,
  DWORD             dwfOptions,
  LPBOOL            lpfNeedsRestart
)
{
  TCHAR szConnectoidName[MAX_ISP_NAME + 1] = TEXT("");
  BOOL  fNeedsRestart = FALSE;  // Default to no reboot needed
  HWND hwndWaitDlg = NULL;
  DEBUGMSG("export.c::InetConfigClient()");

  // Install files if needed.
  // Note:  the parent hwnd is validated in InetConfigSystem
  // We must also mask out the InstallModem flag since we want to
  // do that here, not in InetConfigSystem
  DWORD dwRet = InetConfigSystem(hwndParent,
    dwfOptions & ~INETCFG_INSTALLMODEM, &fNeedsRestart);
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  // 4/2/97 ChrisK Olympus 209 Display busy dialog
  if (INETCFG_SHOWBUSYANIMATION == (dwfOptions & INETCFG_SHOWBUSYANIMATION))
      hwndWaitDlg = WaitCfgInit(hwndParent,IDS_WAITCONNECT);
  
    
  // Make sure we have a connectoid name
  if (lpszEntryName && lstrlen(lpszEntryName))
  {
    // Copy the name into a private buffer in case we have 
    // to muck around with it
    lstrcpyn(szConnectoidName, lpszEntryName, sizeof(szConnectoidName));

    // Make sure the name is valid.
    dwRet = ValidateConnectoidName(lpszPhonebook, szConnectoidName);
    if ((ERROR_SUCCESS == dwRet) ||
      (ERROR_ALREADY_EXISTS == dwRet))
    {
      // Find out if we can overwrite an existing connectoid
      if (!(dwfOptions & INETCFG_OVERWRITEENTRY) &&
        (ERROR_ALREADY_EXISTS == dwRet))
      {
        TCHAR szConnectoidNameBase[MAX_ISP_NAME + 1];

        // Create a base string that is truncated to leave room for a space
        // and a 3-digit number to be appended.  So, the buffer size will be
        // MAX_ISP_NAME + 1 - (LEN_APPEND_INT + 1)
        lstrcpyn(szConnectoidNameBase, szConnectoidName,
          MAX_ISP_NAME - LEN_APPEND_INT);

        // If the entry exists, we have to create a unique name
        int nSuffix = 2;
        while ((ERROR_ALREADY_EXISTS == dwRet) && (nSuffix < MAX_APPEND_INT))
        {
          // Add the integer to the end of the base string and then bump it
          wsprintf(szConnectoidName, szFmtAppendIntToString,
            szConnectoidNameBase, nSuffix++);

          // Validate this new name
          dwRet = ValidateConnectoidName(lpszPhonebook, szConnectoidName);
        }

        // If we could not create a unique name, bail
        // Note that dwRet should still be ERROR_ALREADY_EXISTS in this case
        if (nSuffix >= MAX_APPEND_INT)
        {
          if (NULL != hwndWaitDlg)
              DestroyWindow(hwndWaitDlg);
          hwndWaitDlg = NULL;
          return dwRet;
        }
      }

      if (lpRasEntry && lpRasEntry->dwSize == sizeof(RASENTRY))
      {    
        // Create a connectoid with given properties
        dwRet = MakeConnectoid(hwndParent, dwfOptions, lpszPhonebook,
          szConnectoidName, lpRasEntry, lpszUsername, lpszPassword, &fNeedsRestart);
      }

      // If we created a connectoid, we already updated the dial params
      // with the user name and password.  However, if we didn't create a
      // connectoid we still may need to update dial params of an existing one
      else if ((lpszUsername && lstrlen(lpszUsername)) ||
              (lpszPassword && lstrlen(lpszPassword)))
      {
        // Update the dial params for the given connectoid. 
        dwRet = SetConnectoidUsername(lpszPhonebook, szConnectoidName,
          lpszUsername, lpszPassword);
      }

      // If the connectoid was created/updated successfully, see
      // if it is supposed to be set as the autodial connectoid.
      if ((ERROR_SUCCESS == dwRet) && (dwfOptions & INETCFG_SETASAUTODIAL))
      {
        dwRet = InetSetAutodial((DWORD)TRUE, szConnectoidName);

        // make sure "The Internet" icon on desktop points to web browser
        // (it may initially be pointing at internet wizard)
        // 96/04/22 markdu  NASH BUG 18901 Do not do this for temp connectoids.

        if (!(dwfOptions & INETCFG_TEMPPHONEBOOKENTRY))
        {
            //    //10/24/96 jmazner Normandy 6968
            //    //No longer neccessary thanks to Valdon's hooks for invoking ICW.
            // 11/21/96 jmazner Normandy 11812
            // oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
            // ICW 1.1 needs to morph the IE 3 icon.
          SetDesktopInternetIconToBrowser();
        }

      }
    }
  }

  // Now set the client info if provided and no errors have occurred yet.
  if (ERROR_SUCCESS == dwRet)
  {
    if (NULL != lpINetClientInfo)
    {
      dwRet = InetSetClientInfo(lpszProfileName, lpINetClientInfo);
      if (ERROR_SUCCESS != dwRet)
      {
        if (NULL != hwndWaitDlg)
          DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
        return dwRet;
      }
      // update IE news settings
      dwRet = SetIEClientInfo(lpINetClientInfo);
      if (ERROR_SUCCESS != dwRet)
      {
        if (NULL != hwndWaitDlg)
          DestroyWindow(hwndWaitDlg);
        hwndWaitDlg = NULL;
        return dwRet;
      }
    }

    // Now update the mail client if we were asked to do so.
    // Note: if we got here without errors, and INETCFG_INSTALLMAIL is set,
    // then mail has been installed by now.
    if (dwfOptions & INETCFG_INSTALLMAIL)
    {
      INETCLIENTINFO    INetClientInfo;
      ZeroMemory(&INetClientInfo, sizeof(INETCLIENTINFO));
      INetClientInfo.dwSize = sizeof(INETCLIENTINFO);

      // Use a temp pointer that we can modify.
      LPINETCLIENTINFO  lpTmpINetClientInfo = lpINetClientInfo;

      // If no client info struct was given, try to get the profile by name
      if ((NULL == lpTmpINetClientInfo) && (NULL != lpszProfileName) &&
        lstrlen(lpszProfileName))
      {
        lpTmpINetClientInfo = &INetClientInfo;
        dwRet = InetGetClientInfo(lpszProfileName, lpTmpINetClientInfo);
        if (ERROR_SUCCESS != dwRet)
        {
          if (NULL != hwndWaitDlg)
            DestroyWindow(hwndWaitDlg);
          hwndWaitDlg = NULL;
          return dwRet;
        }
      }

      // If we still don't have client info, we should enumerate the profiles
      // If there is one profile, get it.  If multiple, show UI to allow user
      // to choose.  If none, there is nothing to do at this point.
      // For now, we don't support enumeration, so just try to get the default.
      if (NULL == lpTmpINetClientInfo)
      {
        lpTmpINetClientInfo = &INetClientInfo;
        dwRet = InetGetClientInfo(NULL, lpTmpINetClientInfo);
        if (ERROR_SUCCESS != dwRet)
        {
          if (NULL != hwndWaitDlg)
            DestroyWindow(hwndWaitDlg);
          hwndWaitDlg = NULL;
          return dwRet;
        }
      }

      // If we have client info, update mail settings.
      if (NULL != lpTmpINetClientInfo)
      {
        dwRet = UpdateMailSettings(hwndParent, lpTmpINetClientInfo,
          szConnectoidName);
      }
    }
  }

  // tell caller whether we need to reboot or not
  if ((ERROR_SUCCESS == dwRet) && (lpfNeedsRestart))
  {
    *lpfNeedsRestart = fNeedsRestart;
  }

  if (NULL != hwndWaitDlg)
    DestroyWindow(hwndWaitDlg);
  hwndWaitDlg = NULL;

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   UpdateMailSettings
//
//  PURPOSE:    This function will update the settings for mail in
//              the profile of the user's choice.
//
//  PARAMETERS: hwndParent - window handle of calling application.  This
//              handle will be used as the parent for any dialogs that
//              are required for error messages or the "choose profile"
//              dialog.
//              lpINetClientInfo - client information
//              lpszEntryName - name of phone book entry to be
//              set for connection.
//  
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/26  markdu  Created.
//
//*******************************************************************

HRESULT UpdateMailSettings(
  HWND              hwndParent,
  LPINETCLIENTINFO  lpINetClientInfo,
  LPTSTR             lpszEntryName)
{
  DWORD         dwRet = ERROR_SUCCESS;
  MAILCONFIGINFO MailConfigInfo;
  ZeroMemory(&MailConfigInfo,sizeof(MAILCONFIGINFO));  // zero out structure
 
  if (NULL == gpWizardState)
  {
    gpWizardState = new WIZARDSTATE;
    ASSERT(gpWizardState);
    InitWizardState(gpWizardState, 0);
  }
  // call MAPI to set up profile and store this information in it
  if (InitMAPI(hwndParent))
  {
    CHOOSEPROFILEDLGINFO ChooseProfileDlgInfo;
    ZeroMemory(&ChooseProfileDlgInfo, sizeof(CHOOSEPROFILEDLGINFO));
    ChooseProfileDlgInfo.fSetProfileAsDefault = TRUE;

    ENUM_MAPI_PROFILE* pEnumMapiProfile = new(ENUM_MAPI_PROFILE);

    if (pEnumMapiProfile && pEnumMapiProfile->GetEntryCount()) 
    {
      // Display a dialog and allow the user to select/create profile
      BOOL fRet=(BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_CHOOSEPROFILENAME),
        hwndParent, ChooseProfileDlgProc,(LPARAM) &ChooseProfileDlgInfo);
      if (FALSE == fRet)
      {
        // user cancelled, bail
        return ERROR_CANCELLED;
      }
    }

    if (pEnumMapiProfile)
    {
      delete(pEnumMapiProfile);
      pEnumMapiProfile = NULL;
    }

    // set up a structure with mail config information
    MailConfigInfo.pszEmailAddress = lpINetClientInfo->szEMailAddress;
    MailConfigInfo.pszEmailServer = lpINetClientInfo->szPOPServer;
    MailConfigInfo.pszEmailDisplayName = lpINetClientInfo->szEMailName;
    MailConfigInfo.pszEmailAccountName = lpINetClientInfo->szPOPLogonName;
    MailConfigInfo.pszEmailAccountPwd = lpINetClientInfo->szPOPLogonPassword;
    MailConfigInfo.pszConnectoidName = lpszEntryName;
    MailConfigInfo.fRememberPassword = TRUE;
    MailConfigInfo.pszProfileName = ChooseProfileDlgInfo.szProfileName;
    MailConfigInfo.fSetProfileAsDefault = ChooseProfileDlgInfo.fSetProfileAsDefault;

    // BUGBUG SMTP

    // set up the profile through MAPI
    dwRet = SetMailProfileInformation(&MailConfigInfo);
    if (ERROR_SUCCESS != dwRet)
    {
      DisplayErrorMessage(hwndParent,IDS_ERRConfigureMail,
        (DWORD) dwRet,ERRCLS_MAPI,MB_ICONEXCLAMATION);
    }

    DeInitMAPI();
  }
  else
  {
    // an error occurred.
    dwRet = GetLastError();
    if (ERROR_SUCCESS == dwRet)
    {
      // Error occurred, but the error code was not set.
      dwRet = ERROR_INETCFG_UNKNOWN;
    }
  }

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   MakeConnectoid
//
//  PURPOSE:    This function will create a connectoid with the
//              supplied name if lpRasEntry points to a valid RASENTRY
//              struct.  If username and password are given, these
//              will be set as the dial params for the connectoid.
//
//  PARAMETERS: 
//  hwndParent - window handle of calling application.  This
//               handle will be used as the parent for any dialogs that
//               are required for error messages or the "choose modem"
//               dialog.
//  dwfOptions - a combination of INETCFG_ flags that controls
//               the installation and configuration.
//  lpszPhonebook - name of phone book to store the entry in
//  lpszEntryName  - name of connectoid to create/modify
//  lpRasEntry - connectoid data
//  lpszUsername - username to associate with connectoid
//  lpszPassword - password to associate with connectoid
//  lpfNeedsRestart - set to true if we need a restart.  Note that
//                    since this is an internal helper function, we
//                    assume that the pointer is valid, and we don't
//                    initialize it (we only touch it if we are setting
//                    it to TRUE).
//  
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/12  markdu  Created.
//
//*******************************************************************

DWORD MakeConnectoid(
  HWND        hwndParent,
  DWORD       dwfOptions,
  LPCTSTR     lpszPhonebook,
  LPCTSTR     lpszEntryName,
  LPRASENTRY  lpRasEntry,
  LPCTSTR     lpszUsername,
  LPCTSTR     lpszPassword,
  LPBOOL      lpfNeedsRestart)
{
  DWORD dwRet;

  ASSERT(lpfNeedsRestart);
  
  if (dwfOptions & RASEO_UseCountryAndAreaCodes)
  {
    if ((0 == lpRasEntry->dwCountryCode) || (0 == lpRasEntry->dwCountryID))
        return ERROR_INVALID_PARAMETER;
  }
        
  if (0 == lstrlen(lpRasEntry->szLocalPhoneNumber))
  {
    return ERROR_INVALID_PARAMETER;  
  }
  
  
  // Load RNA if not already loaded since ENUM_MODEM needs it.
  dwRet = EnsureRNALoaded();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }

  //
  // Enumerate the modems 
  //
  ENUM_MODEM  EnumModem;
  dwRet = EnumModem.GetError();
  if (ERROR_SUCCESS != dwRet)
  {
    return dwRet;
  }


    if (TRUE == IsNT())
    {
        BOOL bNeedModem = FALSE;
        
        if (NULL == lpIcfgNeedModem)
            return ERROR_GEN_FAILURE;
        
        dwRet = (*lpIcfgNeedModem)(0, &bNeedModem);
        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        if (TRUE == bNeedModem)
        {
            if (NULL == lpIcfgInstallModem)
                return ERROR_GEN_FAILURE;

            dwRet = (*lpIcfgInstallModem)(NULL, 0,     lpfNeedsRestart);

            //
            // TODO: Check to see if user cancelled
            //
        }
    }
    else
    {
  // If there are no modems, install one if requested.
  if (0 == EnumModem.GetNumDevices())
  {
    if (!(dwfOptions & INETCFG_INSTALLMODEM))
    {
      // We have not been asked to install a modem, so there
      // is nothing further we can do.
      return ERROR_INVALID_PARAMETER;
    }

    if (FALSE == IsNT())
    {
        //
        // 5/22/97 jmazner    Olympus #4698
        // On Win95, calling RasEnumDevices launches RNAAP.EXE
        // If RNAAP.EXE is running, any modems you install won't be usable
        // So, nuke RNAAP.EXE before installing the modem.
        //
        TCHAR szWindowTitle[255] = TEXT("\0nogood");

        //
        // Unload the RAS dll's before killing RNAAP, just to be safe
        //
        DeInitRNA();

        LoadSz(IDS_RNAAP_TITLE,szWindowTitle,255);
        HWND hwnd = FindWindow(szWindowTitle, NULL);
        if (NULL != hwnd)
        {
            if (!PostMessage(hwnd, WM_CLOSE, 0, 0))
            {
                DEBUGMSG("Trying to kill RNAAP window returned getError %d", GetLastError());
            }
        }
    }

    // invoke the modem wizard UI to install the modem
    UINT uRet = InvokeModemWizard(NULL);

    if (uRet != ERROR_SUCCESS)
    {
      DisplayErrorMessage(hwndParent,IDS_ERRInstallModem,uRet,
        ERRCLS_STANDARD,MB_ICONEXCLAMATION);
      return ERROR_INVALID_PARAMETER;
    }

    if (FALSE == IsNT())
    {
        // Reload the RAS dlls now that the modem has been safely installed.
        InitRNA(hwndParent);
    }


    // Re-numerate the modems to be sure we have the most recent changes  
    dwRet = EnumModem.ReInit();
    if (ERROR_SUCCESS != dwRet)
    {
      return dwRet;
    }

    // If there are still no modems, user cancelled
    if (0 == EnumModem.GetNumDevices())
    {
      return ERROR_CANCELLED;
    }
    else
    {
        // ChrisK 5-2-97    Removed per GeoffR
        // //  96/05/01  markdu  ICW BUG 8049 Reboot if modem is installed.
        // *lpfNeedsRestart = TRUE;
    }
  }
    }

  // Validate the device if possible
  if (lstrlen(lpRasEntry->szDeviceName) && lstrlen(lpRasEntry->szDeviceType))
  {
    // Verify that there is a device with the given name and type
    if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
      lpRasEntry->szDeviceType))
    {
      // There was no device that matched both name and type,
      // so reset the strings and bring up the choose modem UI.
      lpRasEntry->szDeviceName[0] = '\0';
      lpRasEntry->szDeviceType[0] = '\0';
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceName))
  {
    // Only the name was given.  Try to find a matching type.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceType = 
      EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
    if (szDeviceType)
    {
      lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
    }
  }
  else if (lstrlen(lpRasEntry->szDeviceType))
  {
    // Only the type was given.  Try to find a matching name.
    // If this fails, fall through to recovery case below.
    LPTSTR szDeviceName = 
      EnumModem.GetDeviceNameFromType(lpRasEntry->szDeviceType);
    if (szDeviceName)
    {
      lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
    }
  }

  // If either name or type is missing, bring up choose modem UI if there
  // are multiple devices, else just get first device.
  // Since we already verified that there was at least one device,
  // we can assume that this will succeed.
  if(!lstrlen(lpRasEntry->szDeviceName) ||
     !lstrlen(lpRasEntry->szDeviceType))
  {
    if (1 == EnumModem.GetNumDevices())
    {
      // There is just one device installed, so copy the name
      lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
    }
    else
    {
      // structure to pass to dialog to fill out
      CHOOSEMODEMDLGINFO ChooseModemDlgInfo;

      // Display a dialog and allow the user to select modem
      BOOL fRet=(BOOL)DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME),hwndParent,
        ChooseModemDlgProc,(LPARAM) &ChooseModemDlgInfo);
      if (FALSE == fRet)
      {
        // user cancelled or an error occurred.
        dwRet = GetLastError();
        if (ERROR_SUCCESS == dwRet)
        {
          // Error occurred, but the error code was not set.
          dwRet = ERROR_INETCFG_UNKNOWN;
        }
        return dwRet;
      }

      // Copy the modem name string
      lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
    }

    // Now get the type string for this modem
    lstrcpy (lpRasEntry->szDeviceType,
      EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceName));
    ASSERT(lstrlen(lpRasEntry->szDeviceType));
  }

  // Create a connectoid with given properties
  dwRet = CreateConnectoid(lpszPhonebook, lpszEntryName, lpRasEntry,
    lpszUsername,lpszPassword);

  //  96/05/06  markdu  NASH BUG 21027  If DNS is set globally, clear it out so
  //            the per-connectoid settings will be saved.
  BOOL  fTemp;
  DoDNSCheck(hwndParent,&fTemp);
  if (TRUE == fTemp)
  {
    *lpfNeedsRestart = TRUE;
  }

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   InetGetAutodial
//
//  PURPOSE:    This function will get the autodial settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if autodial
//              is enabled
//              lpszEntryName - on return, this buffer will contain the 
//              name of the phone book entry that is set for autodial
//              cbEntryNameSize - size of buffer for phone book entry name
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetGetAutodialA
(
  LPBOOL lpfEnable,
  LPSTR  lpszEntryName,
  DWORD  cbEntryNameSize
)
{
  HRESULT hr;
  TCHAR   *szEntryName = (TCHAR *)new TCHAR[cbEntryNameSize+1];

  if(szEntryName == NULL)
  {
      lpszEntryName[0] = '\0';
      return ERROR_NOT_ENOUGH_MEMORY;
  }
  
  hr = InetGetAutodialW(lpfEnable, szEntryName, (cbEntryNameSize)*sizeof(TCHAR));

  if (hr == ERROR_SUCCESS)
  {
    wcstombs(lpszEntryName, szEntryName, cbEntryNameSize);
  }
  
  delete [] szEntryName;

  return hr;
}

extern "C" HRESULT WINAPI InetGetAutodialW
#else
extern "C" HRESULT WINAPI InetGetAutodialA
#endif
(
  LPBOOL lpfEnable,
  LPTSTR lpszEntryName,
  DWORD  cbEntryNameSize
)
{
  HRESULT dwRet;

  DEBUGMSG("export.c::InetGetAutodial()");

  ASSERT(lpfEnable);
  ASSERT(lpszEntryName);
  ASSERT(cbEntryNameSize);

  if (!lpfEnable || !lpszEntryName || (cbEntryNameSize == 0))
  {
    return ERROR_BAD_ARGUMENTS;
  }

  HINSTANCE hInst = NULL;
  FARPROC fp = NULL;

  hInst = LoadLibrary(cszWininet);
  
  if (hInst)
  {
    fp = GetProcAddress(hInst,cszInternetQueryOption);
    if (fp)
    {
      CHAR  szDefaultConnection[RAS_MaxEntryName+1];
      DWORD cchDefaultConnection = 
        sizeof(szDefaultConnection) / sizeof(szDefaultConnection[0]);

      // cchDefaultConnection counts the null-terminator
      if (!((INTERNETQUERYOPTION)(fp))(
        NULL,
        INTERNET_OPTION_AUTODIAL_CONNECTION,
        szDefaultConnection,
        &cchDefaultConnection
        ))
      {
        dwRet = GetLastError();
      }
      else if ((cchDefaultConnection * sizeof(TCHAR)) > cbEntryNameSize)
      {
        dwRet = ERROR_INSUFFICIENT_BUFFER;
      }
      else
      {
        dwRet = ERROR_SUCCESS;

        if (cchDefaultConnection == 0)
        {
          lpszEntryName[0] = TEXT('\0');
        }
        else
        {
        
#ifdef UNICODE
          mbstowcs(lpszEntryName, szDefaultConnection, cchDefaultConnection);
#else
          lstrcpyn(lpszEntryName, szDefaultConnection, cchDefaultConnection);
#endif
        }
      }
    }
    else
    {
      dwRet = GetLastError();
    }
    
    FreeLibrary(hInst);
    hInst = NULL;
  }
  else
  {
    dwRet = GetLastError();
  }
  
  if (ERROR_SUCCESS != dwRet)
  {
  
    // Get the name of the connectoid set for autodial.
    // HKCU\RemoteAccess\InternetProfile
    RegEntry reName(szRegPathRNAWizard,HKEY_CURRENT_USER);
    dwRet = reName.GetError();
    if (ERROR_SUCCESS == dwRet)
    {
      reName.GetString(szRegValInternetProfile,lpszEntryName,cbEntryNameSize);
      dwRet = reName.GetError();
    }
  
    if (ERROR_SUCCESS != dwRet)
    {
      return dwRet;
    }

  }
  // Get setting from registry that indicates whether autodialing is enabled.
  // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
  RegEntry reEnable(szRegPathInternetSettings,HKEY_CURRENT_USER);
  dwRet = reEnable.GetError();
  if (ERROR_SUCCESS == dwRet)
  {
    DWORD dwVal = reEnable.GetNumber(szRegValEnableAutodial, 0);
    dwRet = reEnable.GetError();
    if (ERROR_SUCCESS == dwRet)
    {
      *lpfEnable = dwVal;
    }
  }

  return dwRet;
}


//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetSetAutodialA
(
  BOOL fEnable,
  LPCSTR lpszEntryName
)
{
    HRESULT hr;
    LPTSTR  szEntryName;

    szEntryName = ToUnicodeWithAlloc(lpszEntryName);
    hr = InetSetAutodialW(fEnable, szEntryName);
    if(szEntryName)
        GlobalFree(szEntryName);
    return hr;
}

extern "C" HRESULT WINAPI InetSetAutodialW
#else
extern "C" HRESULT WINAPI InetSetAutodialA
#endif
(
  BOOL fEnable,
  LPCTSTR lpszEntryName
)
{
    HRESULT dwRet = ERROR_SUCCESS;
    BOOL    bRet = FALSE;

    DEBUGMSG("export.c::InetSetAutodial()");

    // 2 seperate calls:
    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;

    dwRet = ERROR_SUCCESS;

    hInst = LoadLibrary(cszWininet);
    if (hInst && lpszEntryName)
    {
        fp = GetProcAddress(hInst,cszInternetSetOption);
        if (fp)
        {
            CHAR szNewDefaultConnection[RAS_MaxEntryName+1];
#ifdef UNICODE
            wcstombs(szNewDefaultConnection, lpszEntryName, RAS_MaxEntryName);
#else
            lstrcpyn(szNewDefaultConnection, lpszEntryName, lstrlen(lpszEntryName)+1);
#endif

            bRet = ((INTERNETSETOPTION)fp) (NULL,
                                            INTERNET_OPTION_AUTODIAL_CONNECTION,
                                            szNewDefaultConnection,
                                            strlen(szNewDefaultConnection));

            if (bRet)
            {
                DWORD dwMode = AUTODIAL_MODE_ALWAYS;
                bRet = ((INTERNETSETOPTION)fp) (NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwMode, sizeof(DWORD));
            }
            if( !bRet )
            {
                dwRet = GetLastError();
                DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
            }
        }
        else
        {
            dwRet = GetLastError();
        }
    }

    // From DarrnMi, INTERNETSETOPTION for autodial is new for 5.5. 
    // We should try it this way and if the InternetSetOption fails (you'll get invalid option),
    // set the registry the old way.  That'll work everywhere.

    if (!bRet)
    {

        // Set the name if given, else do not change the entry.
        if (lpszEntryName)
        {
            // Set the name of the connectoid for autodial.
            // HKCU\RemoteAccess\InternetProfile
            RegEntry reName(szRegPathRNAWizard,HKEY_CURRENT_USER);
            dwRet = reName.GetError();
            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = reName.SetValue(szRegValInternetProfile,lpszEntryName);
            }
        }

        //
        // 9/9/97 jmazner IE bug #57426
        // IE 4 uses HKEY_CURRENT_CONFIG to store autodial settings based on current
        // hardware config.  We need to update this key as well as HK_CU
        //
        if (ERROR_SUCCESS == dwRet)
        {
            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCC\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            RegEntry reEnable(szRegPathInternetSettings,HKEY_CURRENT_CONFIG);
            dwRet = reEnable.GetError();
            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = reEnable.SetValue(szRegValEnableAutodial, fEnable);
            }
        }


        if (ERROR_SUCCESS == dwRet)
        {
            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            RegEntry reEnable(szRegPathInternetSettings,HKEY_CURRENT_USER);
            dwRet = reEnable.GetError();
            if (ERROR_SUCCESS == dwRet)
            {
                dwRet = reEnable.SetValue(szRegValEnableAutodial, fEnable);
                dwRet = reEnable.SetValue(szRegValNoNetAutodial, (BOOL)FALSE);
            }
        }

  
        // 2/10/97    jmazner    Normandy #9705, 13233
        //            Notify wininet when we change proxy or autodial
        if (fp)
        {
            if( !((INTERNETSETOPTION)fp) (NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0) )
            {
                dwRet = GetLastError();
                DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
            }
        }
        else
        {
            dwRet = GetLastError();
        }
    }

    if (hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }
    return dwRet;
}



/*******************************************************************

  NAME:     NeedDriversDlgProc

  SYNOPSIS: Dialog proc for installing drivers

********************************************************************/
UINT g_uQueryCancelAutoPlay = 0;

INT_PTR CALLBACK NeedDriversDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // lParam contains pointer to NEEDDRIVERSDLGINFO struct, set it
            // in window data
            ASSERT(lParam);
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            return NeedDriversDlgInit(hDlg,(PNEEDDRIVERSDLGINFO) lParam);
            break;
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    // get data pointer from window data
                    PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo =
                    (PNEEDDRIVERSDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
                    ASSERT(pNeedDriversDlgInfo);
                    // pass the data to the OK handler
                    int fRet=NeedDriversDlgOK(hDlg,pNeedDriversDlgInfo);
                    EndDialog(hDlg,fRet);
                    break;
                }
                case IDCANCEL:
                {
                    SetLastError(ERROR_CANCELLED);
                    EndDialog(hDlg,0);
                    break;
                }
            }
            break;
        }
        default:
        {
            if(!g_uQueryCancelAutoPlay)
                g_uQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay")); 
            if (uMsg && uMsg == g_uQueryCancelAutoPlay)
                return 1;  
        }
    }
    return FALSE;
}


/*******************************************************************

  NAME:    NeedDriversDlgInit

  SYNOPSIS: proc to handle initialization of dialog for installing files

********************************************************************/

BOOL NeedDriversDlgInit(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
  ASSERT(pNeedDriversDlgInfo);

  // put the dialog in the center of the screen
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, NULL,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  return TRUE;
}

/*******************************************************************

  NAME:    NeedDriversDlgOK

  SYNOPSIS:  OK handler for dialog for installing files

********************************************************************/

int NeedDriversDlgOK(HWND hDlg,PNEEDDRIVERSDLGINFO pNeedDriversDlgInfo)
{
    int nResult = 1;
    ASSERT(pNeedDriversDlgInfo);

    // set the dialog text to "Installing files..." to give feedback to
    // user
    TCHAR szMsg[MAX_RES_LEN+1];
    LoadSz(IDS_INSTALLING_FILES,szMsg,sizeof(szMsg));
    SetDlgItemText(hDlg,IDC_TX_STATUS,szMsg);

    // disable buttons & dialog so it can't get focus
    EnableDlg(hDlg, FALSE);

    FARPROC hShell32VersionProc = NULL;
    BOOL    bWasEnabled         = FALSE;

    // install the drivers we need
    HMODULE hShell32Mod = (HMODULE)LoadLibrary(TEXT("shell32.dll"));
    
    if (hShell32Mod)
        hShell32VersionProc = GetProcAddress(hShell32Mod, "DllGetVersion");

    if(!hShell32VersionProc)
        bWasEnabled = TweakAutoRun(FALSE);
    
    DWORD dwRet = lpIcfgInstallInetComponents(hDlg,
    pNeedDriversDlgInfo->dwfOptions,
    pNeedDriversDlgInfo->lpfNeedsRestart);

    if(!hShell32VersionProc)
        TweakAutoRun(bWasEnabled);

    if (ERROR_SUCCESS != dwRet)
    {
        //
        // Don't display error message if user cancelled
        //
        nResult = 0;

        // Enable the dialog again
        EnableDlg(hDlg, TRUE);

        SetLastError(dwRet);
    }
    else
    {
        // Enable the dialog again
        EnableDlg(hDlg, TRUE);
    }

    return nResult;
}


/*******************************************************************

  NAME:      EnableDlg

  SYNOPSIS:  Enables or disables the dlg buttons and the dlg
            itself (so it can't receive focus)

********************************************************************/
VOID EnableDlg(HWND hDlg,BOOL fEnable)
{
  // disable/enable ok and cancel buttons
  EnableWindow(GetDlgItem(hDlg,IDOK),fEnable);
  EnableWindow(GetDlgItem(hDlg,IDCANCEL),fEnable);

  // disable/enable dlg
  EnableWindow(hDlg,fEnable);
  UpdateWindow(hDlg);
}


/*******************************************************************

  NAME:     ChooseModemDlgProc

  SYNOPSIS: Dialog proc for choosing modem

********************************************************************/
INT_PTR CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  BOOL fRet;

  switch (uMsg)
  {
    case WM_INITDIALOG:
      // lParam contains pointer to CHOOSEMODEMDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      fRet = ChooseModemDlgInit(hDlg,(PCHOOSEMODEMDLGINFO) lParam);
      if (!fRet)
      {
        // An error occured.
        EndDialog(hDlg,FALSE);
      }
      return fRet;
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
         case IDOK:
        {
          // get data pointer from window data
          PCHOOSEMODEMDLGINFO pChooseModemDlgInfo =
            (PCHOOSEMODEMDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
          ASSERT(pChooseModemDlgInfo);

          // pass the data to the OK handler
          fRet=ChooseModemDlgOK(hDlg,pChooseModemDlgInfo);
          if (fRet)
          {
            EndDialog(hDlg,TRUE);
          }
        }
        break;

        case IDCANCEL:
          SetLastError(ERROR_CANCELLED);
          EndDialog(hDlg,FALSE);
          break;                  
      }
      break;
  }

  return FALSE;
}


/*******************************************************************

  NAME:    ChooseModemDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgInit(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
  ASSERT(pChooseModemDlgInfo);

  // put the dialog in the center of the screen
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, NULL,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  // fill the combobox with available modems
  DWORD dwRet = InitModemList(GetDlgItem(hDlg,IDC_MODEM));
  if (ERROR_SUCCESS != dwRet)
  {
    DisplayErrorMessage(hDlg,IDS_ERREnumModem,dwRet,
      ERRCLS_STANDARD,MB_ICONEXCLAMATION);

    SetLastError(dwRet);
    return FALSE;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    ChooseModemDlgOK

  SYNOPSIS:  OK handler for dialog for choosing modem

********************************************************************/

BOOL ChooseModemDlgOK(HWND hDlg,PCHOOSEMODEMDLGINFO pChooseModemDlgInfo)
{
  ASSERT(pChooseModemDlgInfo);

  // should always have a selection in combo box if we get here
  ASSERT(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_MODEM)) >= 0);

  // get modem name out of combo box
  ComboBox_GetText(GetDlgItem(hDlg,IDC_MODEM),
    pChooseModemDlgInfo->szModemName,
    sizeof(pChooseModemDlgInfo->szModemName));
  ASSERT(lstrlen(pChooseModemDlgInfo->szModemName));
    
  // clear the modem list
  ComboBox_ResetContent(GetDlgItem(hDlg,IDC_MODEM));
  
  return TRUE;
}


/*******************************************************************

  NAME:     ChooseProfileDlgProc

  SYNOPSIS: Dialog proc for choosing profile

********************************************************************/

INT_PTR CALLBACK ChooseProfileDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg)
  {
    case WM_INITDIALOG:
      // lParam contains pointer to CHOOSEPROFILEDLGINFO struct, set it
      // in window data
      ASSERT(lParam);
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return ChooseProfileDlgInit(hDlg,(PCHOOSEPROFILEDLGINFO) lParam);
      break;

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
         case IDOK:
        {
          // get data pointer from window data
          PCHOOSEPROFILEDLGINFO pChooseProfileDlgInfo =
            (PCHOOSEPROFILEDLGINFO) GetWindowLongPtr(hDlg,DWLP_USER);
          ASSERT(pChooseProfileDlgInfo);

          // pass the data to the OK handler
          BOOL fRet=ChooseProfileDlgOK(hDlg,pChooseProfileDlgInfo);
          if (fRet)
          {
            EndDialog(hDlg,TRUE);
          }
        }
        break;

        case IDCANCEL:
          EndDialog(hDlg,FALSE);
          break;                  

        case IDC_NEW_PROFILE:
          // user has requested to create a new profile
          DoNewProfileDlg(hDlg);
          return TRUE;    
          break;
      }
      break;
  }

  return FALSE;
}


/*******************************************************************

  NAME:     ChooseProfileDlgInit

  SYNOPSIS: proc to handle initialization of dialog for choosing profile

********************************************************************/

BOOL ChooseProfileDlgInit(HWND hDlg,PCHOOSEPROFILEDLGINFO pChooseProfileDlgInfo)
{
  ASSERT(pChooseProfileDlgInfo);

  // put the dialog in the center of the screen
  // 96/04/23 markdu  NASH BUG 18719 Make the choose profile dialog TOPMOST.
  RECT rc;
  GetWindowRect(hDlg, &rc);
  SetWindowPos(hDlg, HWND_TOPMOST,
    ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
    ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
    0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

  // populate the combo box with names of profiles
  ENUM_MAPI_PROFILE EnumMapiProfile;
  LPTSTR pProfileName=NULL;
  BOOL fDefault;
  int iSel;
  HWND hwndCombo = GetDlgItem(hDlg,IDC_PROFILE_LIST);
  ASSERT(hwndCombo);

  // enumerate profile names
  while (EnumMapiProfile.Next(&pProfileName,&fDefault))
  {
    ASSERT(pProfileName);

    // add profile names to combo box
    iSel=ComboBox_AddString(hwndCombo,pProfileName);
    ASSERT(iSel >= 0);

    // if this is the default profile, set it as selection
    if (fDefault)
    {
      ComboBox_SetCurSel(hwndCombo,iSel);
    }
  }

  // should always be a default profile (and should always be at least
  // one existing profile if we get here)... but just in case, select
  // the first profile in list if there's no selection made so far
  if (ComboBox_GetCurSel(hwndCombo) < 0)
    ComboBox_SetCurSel(hwndCombo,0);

  // initialize "set this profile as default" checkbox to be the
  // value that was passed in (in the structure)
  CheckDlgButton(hDlg,IDC_SETDEFAULT,pChooseProfileDlgInfo->fSetProfileAsDefault);

  return TRUE;
}

/*******************************************************************

  NAME:     ChooseProfileDlgOK

  SYNOPSIS: OK handler for dialog for choosing profile

********************************************************************/

BOOL ChooseProfileDlgOK(HWND hDlg,PCHOOSEPROFILEDLGINFO pChooseProfileDlgInfo)
{
  ASSERT(pChooseProfileDlgInfo);

  // should always have a selection in combo box if we get here
  ASSERT(ComboBox_GetCurSel(GetDlgItem(hDlg,IDC_PROFILE_LIST)) >= 0);

  // get selected profile from combo box
  ComboBox_GetText(GetDlgItem(hDlg,IDC_PROFILE_LIST),
    pChooseProfileDlgInfo->szProfileName,
    sizeof(pChooseProfileDlgInfo->szProfileName));

  // get 'use as default profile' checkbox state
  pChooseProfileDlgInfo->fSetProfileAsDefault = IsDlgButtonChecked(hDlg,
    IDC_SETDEFAULT);

  return TRUE;
}

//*******************************************************************
//
//  FUNCTION:   InetSetAutoProxy
//
//  PURPOSE:    This function will set the auto config proxy settings
//              in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              dwProxyDetectMode - value to be update in the
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoProxyDetectMode
//              lpszScriptAddr - value to be update in 
//                                  HKEY_CURRENT_USER\Software\Microsoft
//                                  \Windows\CurrentVersion\Internet Settings
//                                  AutoConfigURL
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetSetAutoProxyA
(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCSTR  lpszScriptAddr
)
{
    HRESULT hr;
    LPTSTR  szScriptAddr;

    szScriptAddr = ToUnicodeWithAlloc(lpszScriptAddr);
    hr = InetSetAutoProxyW(fEnable, dwProxyDetectMode, szScriptAddr);
    if(szScriptAddr)
        GlobalFree(szScriptAddr);

    return hr;
}

HRESULT WINAPI   InetSetAutoProxyW
#else
HRESULT WINAPI   InetSetAutoProxyA
#endif
(
  BOOL    fEnable,
  DWORD   dwProxyDetectMode,
  LPCTSTR lpszScriptAddr
)
{
    DWORD dwRet = ERROR_GEN_FAILURE;
    HKEY hKey;

    if (!fEnable)
        return ERROR_SUCCESS;

    if (ERROR_SUCCESS == (dwRet = RegOpenKey(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, &hKey)) )
    {
        RegSetValueEx(hKey,
                      cszRegValAutoProxyDetectMode,
                      0,
                      REG_BINARY,
                      (LPBYTE) &dwProxyDetectMode,
                      sizeof(DWORD));                              
        RegSetValueEx(hKey,
                      cszRegValAutoConfigURL,
                      0,
                      REG_SZ,
                      (LPBYTE) lpszScriptAddr,
                      sizeof(TCHAR)*(lstrlen(lpszScriptAddr) + 1 ));

    }
    RegCloseKey(hKey);
    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetSetProxy
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//                On Win32 platforms, it will then attempt to notify WinInet
//                of the changes made.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetSetProxyA
(
  BOOL    fEnable,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride
)
{
    return ERROR_SUCCESS;
}

HRESULT WINAPI   InetSetProxyW
#else
HRESULT WINAPI   InetSetProxyA
#endif
(
  BOOL    fEnable,
  LPCTSTR lpszServer,
  LPCTSTR lpszOverride
)
{
    return ERROR_SUCCESS;
}

//*******************************************************************
//
//  FUNCTION:   InetSetProxyEx
//
//  PURPOSE:    This function will set the proxy settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//                        If set to FALSE, proxy will be disabled.
//              lpszConnectoidName - Name of connectoid to set proxy on
//                                   NULL for LAN
//              lpszServer - name of the proxy server.  If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//              lpszOverride - proxy override. If this is "", the
//                           entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetSetProxyExA
(
  BOOL    fEnable,
  LPCSTR  lpszConnectoidName,
  LPCSTR  lpszServer,
  LPCSTR  lpszOverride
)
{
    TCHAR szConnectoidNameW[MAX_ISP_NAME + 1];
    TCHAR szServerW[MAX_URL_STRING + 1];
    TCHAR szOverrideW[MAX_URL_STRING + 1];

    mbstowcs(szConnectoidNameW,lpszConnectoidName,lstrlenA(lpszConnectoidName)+1);
    mbstowcs(szServerW,   lpszServer,   lstrlenA(lpszServer)+1);
    mbstowcs(szOverrideW, lpszOverride, lstrlenA(lpszOverride)+1);

    return InetSetProxyExW(fEnable, szConnectoidNameW, szServerW, szOverrideW);
}

HRESULT WINAPI   InetSetProxyExW
#else
HRESULT WINAPI   InetSetProxyExA
#endif
(
  BOOL    fEnable,
  LPCTSTR lpszConnectoidName,
  LPCTSTR lpszServer,
  LPCTSTR lpszOverride
)
{
    HKEY hKeyCU;
    HKEY hKeyCC;
    HKEY hKeyCULan; 
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    DEBUGMSG("export.c::InetSetProxy()");

    // 12/15/98   vyung  
    //            Change to use Wininet API to set proxy info. Old way of changing
    //            it through the registry is no longer supported.
    HINSTANCE hInst = NULL;
    
    FARPROC fpInternetSetOption, fpInternetQueryOption = NULL;
    dwRet = ERROR_SUCCESS;
    
    hInst = LoadLibrary(cszWininet);
    if (hInst)
    {
        fpInternetSetOption = GetProcAddress(hInst,cszInternetSetOption);
        fpInternetQueryOption = GetProcAddress(hInst,cszInternetQueryOption);
        if (fpInternetSetOption)
        {

            INTERNET_PER_CONN_OPTION_LISTA list;
            DWORD   dwBufSize = sizeof(list);
            CHAR    szProxyServer[RAS_MaxEntryName+1];
            CHAR    szProxyOverride[RAS_MaxEntryName+1];
            CHAR    szConnectoidName[RAS_MaxEntryName+1];
            DWORD   dwOptions = 4;              // always save FLAGS & DISCOVERY_FLAGS
            BOOL fRes;

            memset(szProxyServer,    0, sizeof(szProxyServer));
            memset(szProxyOverride,  0, sizeof(szProxyServer));
            memset(szConnectoidName, 0, sizeof(szProxyServer));

#ifdef UNICODE
            if (lpszServer)
                wcstombs(szProxyServer, lpszServer, RAS_MaxEntryName+1);
            if(lpszOverride)
                wcstombs(szProxyOverride, lpszOverride, RAS_MaxEntryName+1);
            if(lpszConnectoidName)
                wcstombs(szConnectoidName, lpszConnectoidName, RAS_MaxEntryName+1);
#else
            if (lpszServer)
                lstrcpy(szProxyServer, lpszServer);
            if(lpszOverride)
                lstrcpy(szProxyOverride, lpszOverride);
            if(lpszConnectoidName)
                lstrcpy(szConnectoidName, lpszConnectoidName);
#endif

            // fill out list struct
            list.dwSize = sizeof(list);
            if (NULL == lpszConnectoidName)
                list.pszConnection = NULL;                  // NULL == LAN, 
            else
                list.pszConnection = szConnectoidName;      // otherwise connectoid name
            list.dwOptionCount = 1;         // set three options
            list.pOptions = new INTERNET_PER_CONN_OPTIONA[5];
            if(NULL != list.pOptions)
            {
                // set flags
                list.pOptions[0].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;

                //
                // Query autodiscover flags - we just need to set one bit in there
                //
                if (fpInternetQueryOption)
                {
                    if( !((INTERNETQUERYOPTION)fpInternetQueryOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize) )
                    {
                        dwRet = GetLastError();
                        DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
                    }
                }
                else
                    dwRet = GetLastError();

                // 
                // save off all other options
                //
                list.pOptions[0].Value.dwValue |= AUTO_PROXY_FLAG_USER_SET;

                list.pOptions[1].dwOption = INTERNET_PER_CONN_FLAGS;
                list.pOptions[1].Value.dwValue = PROXY_TYPE_DIRECT;

                //
                // save proxy settings
                //
                if (fEnable)
                {
                    list.pOptions[1].Value.dwValue |= PROXY_TYPE_PROXY;
                }

                list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
                list.pOptions[2].Value.pszValue = szProxyServer;

                list.pOptions[3].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
                list.pOptions[3].Value.pszValue = szProxyOverride;

                if (gpUserInfo)
                {
                    //
                    // save autodetect
                    //
                    if (gpUserInfo->bAutoDiscovery)
                    {
                        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
                    }

                    //
                    // save autoconfig
                    //
                    if (gpUserInfo->bAutoConfigScript)
                    {
                        list.pOptions[1].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;

                        list.pOptions[dwOptions].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
#ifdef UNICODE
                        CHAR szAutoConfigURL[MAX_URL_STRING+1];
                        wcstombs(szAutoConfigURL, gpUserInfo->szAutoConfigURL, MAX_URL_STRING+1);
                        list.pOptions[dwOptions].Value.pszValue = szAutoConfigURL;
#else
                        list.pOptions[dwOptions].Value.pszValue = gpUserInfo->szAutoConfigURL;
#endif
                        dwOptions++;
                    }
                }


                list.dwOptionCount = dwOptions;
                if( !((INTERNETSETOPTION)fpInternetSetOption) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, dwBufSize) )
                {
                    dwRet = GetLastError();
                    DEBUGMSG("INETCFG export.c::InetSetProxy() InternetSetOption failed");
                }
                delete [] list.pOptions;
            }   
        }
        else
            dwRet = GetLastError();

        FreeLibrary(hInst);
        hInst = NULL;
    }
    else 
    {
        dwRet = GetLastError();
    }
    
    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetGetProxy
//
//  PURPOSE:    This function will get the proxy settings from the registry.
//
//  PARAMETERS: lpfEnable - on return, this will be TRUE if proxy
//              is enabled
//              lpszServer - on return, this buffer will contain the 
//              name of the proxy server
//              cbServer - size of buffer for proxy server name
//              lpszOverride - on return, this buffer will contain the 
//              name of the proxy server
//              cbOverride - size of buffer for proxy override
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
HRESULT WINAPI   InetGetProxyA
(
  LPBOOL  lpfEnable,
  LPSTR   lpszServer,
  DWORD   cbServer,
  LPSTR   lpszOverride,
  DWORD   cbOverride
)
{
    HRESULT hr;
    TCHAR szServer[MAX_URL_STRING+1];
    TCHAR szOverride[MAX_URL_STRING+1];

    hr = InetGetProxyW(lpfEnable, szServer, cbServer, szOverride, cbOverride);
    wcstombs(lpszServer,   szServer,   MAX_URL_STRING+1);
    wcstombs(lpszOverride, szOverride, MAX_URL_STRING+1);

    return hr;
}

HRESULT WINAPI   InetGetProxyW
#else
HRESULT WINAPI   InetGetProxyA
#endif
(
  LPBOOL  lpfEnable,
  LPTSTR  lpszServer,
  DWORD   cbServer,
  LPTSTR  lpszOverride,
  DWORD   cbOverride
)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    DEBUGMSG("export.c::InetGetProxy()");

    // NEW WININET API
    //
    // Read proxy and autoconfig settings for this connection
    //

    // Comment for UNICODE
	// Wininet.dll doesn't support INTERNET_OPTION_PER_CONNECTION_OPTION
	// in InternetQueryOptionW. Only InternetQueryOptionA supports the flag.
	// Because of restriction of Wininet.dll I have to use A version.
	// WTSEO : 3/19/99
    INTERNET_PER_CONN_OPTION_LISTA list;
    DWORD dwBufSize = sizeof(list);
    //CHAR szEntryA[RAS_MaxEntryName + 1];

    list.pszConnection = NULL;
    list.dwSize = sizeof(list);
    list.dwOptionCount = 4;
    list.pOptions = new INTERNET_PER_CONN_OPTIONA[4];
    if(NULL == list.pOptions)
    {
        return FALSE;
    }

    list.pOptions[0].dwOption = INTERNET_PER_CONN_FLAGS;
    list.pOptions[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
    list.pOptions[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
    list.pOptions[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;

    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;

    dwRet = ERROR_SUCCESS;
    
    hInst = LoadLibrary(cszWininet);
    if (hInst)
    {
        fp = GetProcAddress(hInst,cszInternetQueryOption);
        if (fp)
        {
            if( !((INTERNETQUERYOPTION)fp) (NULL, INTERNET_OPTION_PER_CONNECTION_OPTION, &list, &dwBufSize) )
            {
                dwRet = 0;//GetLastError();
                DEBUGMSG("INETCFG export.c::InetSetAutodial() InternetSetOption failed");
            }
        }
        else
            dwRet = GetLastError();

        FreeLibrary(hInst);
        hInst = NULL;
    }
    else 
    {
        dwRet = GetLastError();
    }

    //
    // move options to gpUserInfo struct
    //
    if (gpUserInfo)
    {
        gpUserInfo->fProxyEnable = (list.pOptions[0].Value.dwValue & PROXY_TYPE_PROXY);
    }
    if(list.pOptions[1].Value.pszValue)
    {
#ifdef UNICODE
        mbstowcs(lpszServer, list.pOptions[1].Value.pszValue, MAX_URL_STRING);
#else
        lstrcpyn(lpszServer, list.pOptions[1].Value.pszValue, MAX_URL_STRING);
#endif
        cbServer = lstrlen(lpszServer);
    }
    if(list.pOptions[2].Value.pszValue)
    {
#ifdef UNICODE
        mbstowcs(lpszOverride, list.pOptions[2].Value.pszValue, MAX_URL_STRING);
#else
        lstrcpyn(lpszOverride, list.pOptions[2].Value.pszValue, MAX_URL_STRING);
#endif
        cbOverride = lstrlen(lpszOverride);;
    }

    //
    // fill in autoconfig and autoproxy field
    //
    if (gpUserInfo)
    {

        // autoconfig enable and url
        gpUserInfo->bAutoConfigScript = list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_PROXY_URL;

        if(list.pOptions[3].Value.pszValue)
        {
#ifdef UNICODE
            mbstowcs(gpUserInfo->szAutoConfigURL, list.pOptions[3].Value.pszValue,
				                         lstrlenA(list.pOptions[3].Value.pszValue)+1);
#else
            lstrcpy(gpUserInfo->szAutoConfigURL, list.pOptions[3].Value.pszValue);
#endif
        }

        // autodiscovery enable
        gpUserInfo->bAutoDiscovery = list.pOptions[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT;
    }

    // all done with options list
    delete [] list.pOptions;

    return dwRet;
}

//+----------------------------------------------------------------------------
//    Function    InetStartServices
//
//    Synopsis    This function guarentees that RAS services are running
//
//    Arguments    none
//
//    Return        ERROR_SUCCESS - if the services are enabled and running
//
//    History        10/16/96    ChrisK    Created
//-----------------------------------------------------------------------------
extern "C" HRESULT WINAPI InetStartServices()
{
    ASSERT(lpIcfgStartServices);
    if (NULL == lpIcfgStartServices)
        return ERROR_GEN_FAILURE;
    return (lpIcfgStartServices());
}

//+----------------------------------------------------------------------------
//
//    Function:    IEInstalled
//
//    Synopsis:    Tests whether a version of Internet Explorer is installed via registry keys
//
//    Arguments:    None
//
//    Returns:    TRUE - Found the IE executable
//                FALSE - No IE executable found
//
//    History:    jmazner        Created        8/19/96    (as fix for Normandy #4571)
//                valdonb        10/22/96    Shamelessly stole and used for my own purposes.
//
//-----------------------------------------------------------------------------

BOOL IEInstalled(void)
{
    HRESULT hr;
    HKEY hKey = 0;
    HANDLE hFindResult;
    TCHAR szTempPath[MAX_PATH + 1] = TEXT("");
    TCHAR szIELocalPath[MAX_PATH + 1] = TEXT("");
    DWORD dwPathSize;
    WIN32_FIND_DATA foundData;

    hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPathIexploreAppPath, 0, KEY_READ, &hKey);
    if (hr != ERROR_SUCCESS) return( FALSE );

    dwPathSize = sizeof (szIELocalPath);
    hr = RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szIELocalPath, &dwPathSize);
    RegCloseKey( hKey );
    if (hr != ERROR_SUCCESS) return( FALSE );
    
    //
    // Olympus 9214 ChrisK
    // NT5 stores the path of IExplorer with environment strings
    //
    if (0 == ExpandEnvironmentStrings(szIELocalPath,szTempPath,MAX_PATH))
    {
        return (FALSE);
    };
    hFindResult = FindFirstFile( szTempPath, &foundData );
    FindClose( hFindResult );
    if (INVALID_HANDLE_VALUE == hFindResult) return( FALSE );

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//    Function:    IsIEAKSignUpNeeded
//
//    Synopsis:    Determine if the IEAK signup should be run by checking the
//                IEAK's registry flag and signup file location
//
//    Arguments:    pszPath - buffer to contain path to signup file
//                dwPathLen - size of pszPath
//
//    Returns:    TRUE - if IEAK signup should be run
//                FALSE - IEAK signup should not be run
//
//    History:    ChrisK    6/18/97    Created
//
//-----------------------------------------------------------------------------
BOOL IsIEAKSignUpNeeded(LPTSTR pszPath, DWORD dwPathLen)
{
    BOOL bRC = FALSE;


    //
    // Validate parameters
    //
    DEBUGMSG("INETCFG: IsIEAKSignUpNeeded.\n");
    ASSERT(pszPath);
    ASSERT(dwPathLen);

    if (NULL == pszPath || 0 == dwPathLen)
    {
        goto IsIEAKSignUpNeededExit;
    }


    //
    // Check if IEAK registry key is set
    //
    {
        RegEntry re(szRegIEAKSettings,HKEY_CURRENT_USER);

        if (ERROR_SUCCESS != re.GetError())
            goto IsIEAKSignUpNeededExit;

        if (0 == re.GetNumber(szREgIEAKNeededKey, 0))
        {
            bRC = FALSE;
            goto IsIEAKSignUpNeededExit;
        }
    }

    //
    // Check to see if IEAK signup page is available.
    //
    {
        RegEntry rePath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);

        if (ERROR_SUCCESS != rePath.GetError())
            goto IsIEAKSignUpNeededExit;

        if (NULL == rePath.GetString(szPathSubKey,pszPath,dwPathLen))
        {
            goto IsIEAKSignUpNeededExit;
        }

        dwPathLen = lstrlen(pszPath);
        ASSERT(dwPathLen);
    }

    //
    // Massage path to point at signup file
    //
    TCHAR *pc, *pcTemp;
    pc = &(pszPath[dwPathLen]);
    pc = CharPrev(pszPath,pc);

    if ('\\' == *pc)
    {
        //
        // add signup part of filename after \ character
        //
        pc = CharNext(pc);
    }
    else if (';' == *pc)
    {
        //
        // overwrite trailing ; character
        //
        // pc = pc
        pcTemp = CharPrev(pszPath,pc);

        //
        // check for trailing \ character and add one if needed
        //
        if ('\\' != *pcTemp)
        {
            *pc = '\\';
            pc = CharNext(pc);
        }
    }
    else
    {
        //
        // The path value contains something we don't understand
        //
        ASSERT(0);
    }

    lstrcpy(pc,szIEAKSignupFilename);
    if (0xFFFFFFFF != GetFileAttributes(pszPath))
    {
        bRC = TRUE;
    }


IsIEAKSignUpNeededExit:

    if (FALSE == bRC)
    {
        pszPath[0] = '\0';
    }

    return bRC;
}
/***************************************************************************

  Function    CheckConnectionWizard
  
  Synopsis    This function checks if ICW is present and if it has been run
            before.  If it is present but has not been run it does one of
            the following based on the value of dwRunFlags:  returns, runs
            the full ICW, or runs the manual path.

  Arguments    dwRunFlags is a combination of the following bit flags.

                Value                    Meaning
                ICW_CHECKSTATUS        Check if ICW is present and if it
                                    has been run.
                ICW_LAUNCHFULL        If ICW is present and the full path
                                    is available, run the full path, if
                                    possible.
                ICW_LAUNCHMANUAL    If ICW is present, run the manual path.
                ICW_USE_SHELLNEXT    If the full ICW path will be run, pass the
                                    value set by SetShellNext to icwconn1 using
                                    the /shellnext command line flag.
                ICW_FULL_SMARTSTART    If ICW is present and the full path
                                    is available, and ICW_LAUNCHFULL is
                                    specified, then add /smartstart parameter
                                    to command line.

            lpdwReturnFlags contains the results of the call.  It is a
                combination of the following bit flags.

                Value                Meaning
                ICW_FULLPRESENT     ICW full path is present on the system.
                ICW_MANUALPRESENT    ICW manual path is present.  This will
                                    always be set if ICW_FULLPRESENT is set.
                ICW_ALREADYRUN        ICW has already been run to completion
                                    before.
                ICW_LAUNCHEDFULL    The full path of ICW was started.
                ICW_LAUNCHEDMANUAL    The manual path of ICW was started.

            Note:    The calling application should exit if ICW_LAUNCHEDFULL or
                    ICW_LAUNCHEDMANUAL are set.  ICW may cause the system to
                    reboot if required system software needs to be installed.

  Return    ERROR_SUCCESS indicates a successful call.
            Any other value indicates failure.

****************************************************************************/
#define LAUNCHFULL_PARAMETER_SIZE (MAX_PATH + 2 + lstrlen(szICWShellNextFlag) + lstrlen(szICWSmartStartFlag))
extern "C" DWORD WINAPI CheckConnectionWizard(DWORD dwRunFlags, LPDWORD lpdwReturnFlags)
{
    DWORD dwRetFlags = 0;
    DWORD dwResult = ERROR_SUCCESS;
    TCHAR *szParameter = NULL;
    HINSTANCE hinst = NULL;
    
    //
    // ChrisK IE 39452 6/18/97
    // IEAK support of ISP mode
    //
    BOOL fIEAKNeeded = FALSE;
    TCHAR szIEAKPage[MAX_PATH + 1] = TEXT("\0invalid");

    fIEAKNeeded = IsIEAKSignUpNeeded(szIEAKPage,MAX_PATH);

    // Find out if full ICW is installed.  Since ICW is bound to the base
    // install of IE, we can just check if IE 3.0 is installed or not.
    // This may change in the future.
    if (IEInstalled())
        dwRetFlags |= ICW_FULLPRESENT;

    // Find out if manual ICW is installed.  Since this if part of INETCFG.DLL
    // and it also contains the manual ICW it is always present.
    dwRetFlags |= ICW_MANUALPRESENT;

    // If nothing's installed, exit now
#if 0    // Always at least manual path
    if (!((dwRetFlags & ICW_FULLPRESENT) || (dwRetFlags & ICW_MANUALPRESENT)))
        goto CheckConnectionWizardExit;
#endif

    // Find out if ICW has been run
    {
        RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

        dwResult = re.GetError();
        if (ERROR_SUCCESS != dwResult)
            goto CheckConnectionWizardExit;

        if (re.GetNumber(szRegValICWCompleted, 0))
        {
            dwRetFlags |= ICW_ALREADYRUN;
            goto CheckConnectionWizardExit;
        }
    }

    if ((dwRetFlags & ICW_FULLPRESENT) && (dwRunFlags & ICW_LAUNCHFULL))
    {


#if !defined(WIN16)
        if( dwRunFlags & ICW_USE_SHELLNEXT )
        {
            RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

            dwResult = re.GetError();
            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szShellNextCmd[MAX_PATH + 1];
                ZeroMemory( szShellNextCmd, sizeof(szShellNextCmd) );
                if( re.GetString(szRegValShellNext, szShellNextCmd, sizeof(szShellNextCmd)) )
                {
                    DEBUGMSG("CheckConnectionWizard read ShellNext = %s", szShellNextCmd);
                    szParameter = (TCHAR *)GlobalAlloc(GPTR, sizeof(TCHAR)*LAUNCHFULL_PARAMETER_SIZE);

                    if( szParameter )
                    {
                        ZeroMemory( szParameter, sizeof(szParameter) );
                        lstrcpy( szParameter, szICWShellNextFlag );
                        lstrcat( szParameter, szShellNextCmd );

                        //
                        // clean up after ourselves
                        //
                        // 7/9/97 jmazner Olympus #9170
                        // Nope, leave the reg key there for the manual path to find.
                        // conn1 and man path should clean this up when they finish.
                        //re.DeleteValue(szRegValShellNext);
                        //
                    }
                }
            }
        }

        //
        // ChrisK 5/25/97 Add the /smartstart parameter if appropriate
        //

        if (!fIEAKNeeded && dwRunFlags & ICW_FULL_SMARTSTART)
        {
            //
            // 6/6/97 jmazner Olympus #5927
            //

            //if(IsSmartStart())

            if( SMART_QUITICW == IsSmartStart() )
            {
                //
                // ChrisK Olympus 5902 6/6/97
                // Set completed flag is SmartStart is TRUE
                //

                RegEntry reg(szRegPathICWSettings,HKEY_CURRENT_USER);

                if (ERROR_SUCCESS == (dwResult = reg.GetError()))
                {
                    reg.SetValue(szRegValICWCompleted, (DWORD)1);
                }

                dwRetFlags |= ICW_ALREADYRUN;
                goto CheckConnectionWizardExit;
            }
        }
#endif

        if (!fIEAKNeeded)
        {
            // Launch the full ICW (ICWCONN1.EXE)
            hinst = ShellExecute (NULL, NULL, szFullICWFileName, szParameter, NULL, SW_NORMAL);
        }
        else
        {
            ASSERT(szIEAKPage[0]);
            //
            // Launch IEAK signup
            //
            hinst = ShellExecute (NULL, NULL, szISignupICWFileName, szIEAKPage, NULL, SW_NORMAL);
        }
    
        if (32 >= (DWORD_PTR)hinst)
        {
            if (NULL == hinst)
                dwResult = ERROR_OUTOFMEMORY;
            else
                dwResult = (DWORD)((DWORD_PTR)hinst);
            goto CheckConnectionWizardExit;
        }

        dwRetFlags |= ICW_LAUNCHEDFULL;
    }
    
    else if ((dwRetFlags & ICW_MANUALPRESENT) &&
             ((dwRunFlags & ICW_LAUNCHFULL) || (dwRunFlags & ICW_LAUNCHMANUAL)))
    {
        // Launch the manual ICW (INETWIZ.EXE)
        HINSTANCE hinst = ShellExecute (NULL, NULL, szManualICWFileName, NULL, NULL, SW_NORMAL);
        
        if (32 >= (DWORD)((DWORD_PTR)hinst))
        {

            if (NULL == hinst)
                dwResult = ERROR_OUTOFMEMORY;
            else
                dwResult = (DWORD)((DWORD_PTR)hinst);
            goto CheckConnectionWizardExit;
        }

        dwRetFlags |= ICW_LAUNCHEDMANUAL;
    }

CheckConnectionWizardExit:

    if( szParameter )
    {
        GlobalFree( szParameter );
    }

    *lpdwReturnFlags = dwRetFlags;
    return dwResult;
}

/******
 *
 * InetCreateMailNewsAccount and InetCreateDirectoryService, below, have
 * been obsoleted by the move to the wizard/apprentice model.  The Account
 * Manager now owns the UI for mail/news/ldap creation, thus there is no
 * longer a need for these entry points.
 *
 * 4/23/97 jmazner Olympus #3136
 *
 ******/

/***************************************************************************

  Function    InetCreateMailNewsAccount

  Synopsis  The InetCreateMailNewsAccount function will create a new Internet
            mail or news account.  The user is prompted through a wizard
            interface for the minimum required information to setup a new
            Internet mail or news account.

  Arguments    hwndparent is the window handle of the parent for the wizard
                dialogs.  If it is NULL the dialogs will be parentless.

            dwConfigType is of the following two enumerated types from ACCTTYPE.

                Value                Meaning
                ICW_ACCTMAIL (0)    Create a new Internet mail account.
                ICW_ACCTNEWS (1)    Create a new Internet news account.

            lpMailNewsInfo is a pointer to a IMNACCTINFO struct.  The values
                passed in will be used as defaults and the user's entries will
                be returned in this structure.  If this is NULL then ICW will
                use defaults as indicated in parentheses below.

  Return    ERROR_SUCCESS indicates a successful call.
            ERROR_CANCELLED indicates the user canceled the wizard.
            Any other value indicates failure.

****************************************************************************/
/***
extern "C" DWORD WINAPI InetCreateMailNewsAccount(    
    HWND hwndParent,                //parent of wizard dialogs                
    ICW_ACCTTYPE AccountType,        //account type                            
    IMNACCTINFO *lpMailNewsInfo,    // mail or news account information        
    DWORD dwInFlags                    // setup flags                            
    )

{
    DWORD dwResult = ERROR_SUCCESS;
    DWORD dwFlags = 0;

    // Initialize the wizard
    gpWizardState = new WIZARDSTATE;
    gpUserInfo = new USERINFO;
    gdwRasEntrySize = sizeof(RASENTRY);
    gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);

    if (!gpWizardState || !gpUserInfo || !gpRasEntry)
    {
        // display an out of memory error
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        dwResult = ERROR_OUTOFMEMORY;
        goto InetCreateMailNewsAccountExit;
    }

    // Assign the global defaults pointer so we will use it later
    gpMailNewsInfo = lpMailNewsInfo;
    gfUseMailNewsDefaults = (dwInFlags & ICW_USEDEFAULTS);
    
    // Set the start page
    switch(AccountType)
    {
    case ICW_ACCTMAIL:
        dwFlags |= RSW_MAILACCT;
        break;

    case ICW_ACCTNEWS:
        dwFlags |= RSW_NEWSACCT;
        break;

    default:
        dwResult = ERROR_INVALID_PARAMETER;
        goto InetCreateMailNewsAccountExit;
        break;
    }

    gfUserFinished = FALSE;
    gfUserCancelled = FALSE;

    RunSignupWizard(dwFlags, hwndParent);

    if (gfUserFinished)
        dwResult = ERROR_SUCCESS;
    else if (gfUserCancelled)
        dwResult = ERROR_CANCELLED;
    else
        dwResult = ERROR_GEN_FAILURE;
    
InetCreateMailNewsAccountExit:

    // free global structures
    if (gpWizardState) 
        delete gpWizardState;

    if (gpUserInfo)
        delete gpUserInfo;

    if (gpEnumModem)
        delete gpEnumModem;

    if (gpRasEntry)
        GlobalFree(gpRasEntry);

    return dwResult;
}
******/

/***************************************************************************

  Function    InetCreateDirectoryService

  Synopsis  The InetCreateDirectoryService function will create a new Internet
            directory service (LDAP account).  The user is prompted through a wizard
            interface for the minimum required information to setup the service

  Arguments    hwndparent is the window handle of the parent for the wizard
                dialogs.  If it is NULL the dialogs will be parentless.

            AccountType should be ICW_ACCTDIRSERV

            lpDirServiceInfo is a pointer to a DIRSERVINFO struct.  The values
                passed in will be used as defaults and the user's entries will
                be returned in this structure.  If this is NULL then ICW will
                use defaults as indicated in parentheses below.

  Return    ERROR_SUCCESS indicates a successful call.
            ERROR_CANCELLED indicates the user canceled the wizard.
            Any other value indicates failure.

****************************************************************************/
/***********
extern "C" DWORD WINAPI InetCreateDirectoryService(    
    HWND hwndParent,                // parent of wizard dialogs    
    ICW_ACCTTYPE AccountType,        // account type    
    DIRSERVINFO *lpDirServiceInfo,    // LDAP account information    
    DWORD dwInFlags                    // setup flags
    )

{
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwFlags = 0;

    // Initialize the wizard
    gpWizardState = new WIZARDSTATE;
    gpUserInfo = new USERINFO;
    gdwRasEntrySize = sizeof(RASENTRY);
    gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);

    if (!gpWizardState || !gpUserInfo || !gpRasEntry)
    {
        // display an out of memory error
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        dwRet = ERROR_OUTOFMEMORY;
        goto InetCreateDirectoryServiceExit;
    }

    // Assign the global defaults pointer so we will use it later
    gpDirServiceInfo = lpDirServiceInfo;
    gfUseDirServiceDefaults = (dwInFlags & ICW_USEDEFAULTS);
    
    // Set the start page
    switch(AccountType)
    {
    case ICW_ACCTDIRSERV:
        dwFlags |= RSW_DIRSERVACCT;
        break;

    default:
        dwRet = ERROR_INVALID_PARAMETER;
        goto InetCreateDirectoryServiceExit;
        break;
    }

    gfUserFinished = FALSE;
    gfUserCancelled = FALSE;

    RunSignupWizard(dwFlags, hwndParent);

    if (gfUserFinished)
        dwRet = ERROR_SUCCESS;
    else if (gfUserCancelled)
        dwRet = ERROR_CANCELLED;
    else
        dwRet = ERROR_GEN_FAILURE;
    
InetCreateDirectoryServiceExit:

    // free global structures
    if (gpWizardState) 
        delete gpWizardState;

    if (gpUserInfo)
        delete gpUserInfo;

    if (gpEnumModem)
        delete gpEnumModem;

    if (gpRasEntry)
        GlobalFree(gpRasEntry);

    return dwRet;
}
******/

#if !defined(WIN16)
// 4/1/97    ChrisK    Olympus 209
//+----------------------------------------------------------------------------
//    Function:    WaitCfgDlgProc
//
//    Synopsis:    Handle busy dialog messages
//
//    Arguments:    standard DialogProc
//
//    Returns:    standard DialogProc
//
//    History:    4/2/97    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CALLBACK WaitCfgDlgProc(
    HWND  hDlg,
    UINT  uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    HWND hwndAni;

    switch (uMsg)
    {
        case WM_DESTROY:
            hwndAni = GetDlgItem(hDlg,IDC_ANIMATE);
            if (hwndAni)
            {
                Animate_Stop(hwndAni);
                Animate_Close(hwndAni);
                hwndAni = NULL;
            }
            break;
        case WM_INITDIALOG:
            // Loop animation forever.
            hwndAni = GetDlgItem(hDlg,IDC_ANIMATE);
            if (hwndAni)
            {
                Animate_Open(hwndAni,MAKEINTRESOURCE(IDA_WAITINGCONFIG));
                Animate_Play(hwndAni, 0, -1, -1);
                hwndAni = NULL;
            }
            break;
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//    Function:    WaitCfgInit
//
//    Synopsis:    Create, center, and display busy dialog
//
//    Arguments:    hwndParent - handle of parent window
//                dwIDS - ID of string resource to display
//
//    Return:        handle to busy window
//
//    History:    4/2/97    ChrisK    Created
//-----------------------------------------------------------------------------
HWND WaitCfgInit(HWND hwndParent, DWORD dwIDS)
{
    HWND    hwnd;
    RECT    MyRect;
    RECT    DTRect;
    TCHAR   szMessage[255];

    // Create dialog
    hwnd = CreateDialog (ghInstance, MAKEINTRESOURCE(IDD_CONFIGWAIT), hwndParent, (DLGPROC)WaitCfgDlgProc);
    if (NULL != hwnd)
    {
        // Center dialog on desktop
        GetWindowRect(hwnd, &MyRect);
        GetWindowRect(GetDesktopWindow(), &DTRect);
        MoveWindow(hwnd, (DTRect.right - (MyRect.right - MyRect.left)) / 2, (DTRect.bottom - (MyRect.bottom - MyRect.top)) /2,
                            (MyRect.right - MyRect.left), (MyRect.bottom - MyRect.top), FALSE);

        // Load string for message
        szMessage[0] = '\0';
        LoadSz(dwIDS,szMessage,sizeof(szMessage)-1);
        SetDlgItemText(hwnd,IDC_LBLWAITCFG,szMessage);

        // Display dialog and paint text
        ShowWindow(hwnd,SW_SHOW);
        UpdateWindow(hwnd);
    }

    return hwnd;
}

//+----------------------------------------------------------------------------
//    Function:    SetShellNext
//
//    Synopsis:    Sets the ShellNext registry key with the passed in value.  This
//                key is passed to icwconn1 via the /shellnext command line option
//                if the ICW_USE_SHELLNEXT option is specified.
//
//    Arguments:    szShellNext -- pointer to a string containing the /shellnext cmd.
//                                **should have length <= MAX_PATH**
//
//    Return:        a win32 result code.  ERROR_SUCCESS indicates success.
//
//    History:    5/21/97    jmazner    Created for Olympus bug #4157
//-----------------------------------------------------------------------------

#ifdef UNICODE
extern "C" DWORD WINAPI SetShellNextA(CHAR *szShellNext)
{
    TCHAR* szShellNextW = new TCHAR[INTERNET_MAX_URL_LENGTH+1];
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    if (szShellNextW)
    {
        mbstowcs(szShellNextW, szShellNext, lstrlenA(szShellNext)+1);
        dwRet = SetShellNextW(szShellNextW);
        delete [] szShellNextW;
    }
    return dwRet;
}

extern "C" DWORD WINAPI SetShellNextW(WCHAR *szShellNext)
#else
extern "C" DWORD WINAPI SetShellNextA(CHAR  *szShellNext)
#endif
{
    DWORD dwResult = ERROR_SUCCESS;

    if( !szShellNext || !szShellNext[0] )
    {
        DEBUGMSG("SetShellNext got an invalid parameter\n");
        return ERROR_INVALID_PARAMETER;
    }

    RegEntry re(szRegPathICWSettings,HKEY_CURRENT_USER);

    dwResult = re.GetError();
    if (ERROR_SUCCESS == dwResult)
    {
        if( ERROR_SUCCESS == re.SetValue(szRegValShellNext, szShellNext) )
        {
            DEBUGMSG("SetShellNext set ShellNext = %s", szShellNext);
        }
        else
        {
            dwResult = re.GetError();
        }
    }

    return dwResult;
}

#ifdef OLD_SMART_START

#define IE4_PROXYSERVER_SETTING_KEY "ProxyServer"
#define IE4_PROXYENABLE_SETTING_KEY "ProxyEnable"
#define IE4_SETTINGS_STARTPAGE "Start Page"
#define IE4_SETTINGS_KEY "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define IE4_SETTINGS_MAIN "Software\\Microsoft\\Internet Explorer\\Main"
#define INETCFG_INETGETAUTODIAL "InetGetAutodial"
#define INETCFG_INETNEEDSYSTEMCOMPONENTS "InetNeedSystemComponents"
typedef HRESULT (WINAPI* PFNINETNEEDSYSTEMCOMPONENTS)(DWORD,LPBOOL);
typedef HRESULT (WINAPI* PFNINETGETAUTODIAL)(LPBOOL,LPTSTR,DWORD);
typedef DWORD (WINAPI* PFNRASGETAUTODIALADDRESS)(LPTSTR,LPDWORD,LPRASAUTODIALENTRY,LPDWORD,LPDWORD);

#define MIN_HTTP_ADDRESS (sizeof(SMART_HTTP) + 1) 
#define SMART_HTTP TEXT("http://")

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartNetcard
//
//    Synopsis:    Check machine to see if it is setup to connect via a netcard
//                and proxy
//
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartNetcard()
{
    BOOL bResult = FALSE;
    HKEY hkey = NULL;
    DWORD dwSize = 0;
    DWORD dwData = 0;
    BOOL bRC = SMART_RUNICW;

    DEBUGMSG("INETCFG: SmartStartNetcard\n");
    //
    // Call Inetcfg to check for LAN card and TCP binding to that card
    //
    if (ERROR_SUCCESS != InetNeedSystemComponents(INETCFG_INSTALLLAN,
                            &bResult) || bResult)
    {
        DEBUGMSG("INETCFG: SmartStart not Netcard or not bound.\n");
        goto SmartStartNetcardExit;
    }

    //
    // Check to see if there are IE4 proxy settings
    //
    hkey = NULL;
    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
                            IE4_SETTINGS_KEY,
                            &hkey)
        || NULL == hkey)
    {
        DEBUGMSG("INETCFG: SmartSmart IE4 Proxy key is not available.\n");
        goto SmartStartNetcardExit;
    }

    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
                            IE4_PROXYENABLE_SETTING_KEY,
                            NULL,    // lpReserved
                            NULL,    // lpType
                            (LPBYTE)&dwData,    // lpData
                            &dwSize)
        || 0 == dwData)
    {
        DEBUGMSG("INETCFG: SmartStart IE4 Proxy not enabled.\n");
        goto SmartStartNetcardExit;
    }
    
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
                            IE4_PROXYSERVER_SETTING_KEY,
                            NULL,    // lpReserved
                            NULL,    // lpType
                            NULL,    // lpData
                            &dwSize)
        || 1 >= dwSize)    // note: a single null character is length 1
    {
        DEBUGMSG("INETCFG: SmartStart IE 4 Proxy server not available.\n");
        goto SmartStartNetcardExit;
    }
    //
    // The user appears to have a valid configuration.  Do not
    // run the ICW.
    //
    bRC = SMART_QUITICW;

SmartStartNetcardExit:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartPPPConnectoid
//
//    Synopsis:    Given a connectoid name determine if the framing protocol is PPP
//
//    Arguments:    lpszEntry - name of connectoid
//
//    Returns:    TRUE - the framing protocol is PPP; FALSE - it is something else
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL IsSmartPPPConnectoid(LPTSTR lpszEntry)
{
    LPRASENTRY lpRasEntry = NULL;
    DWORD dwRasEntrySize = 0;
    LPRASDEVINFO lpRasDevInfo = NULL;
    DWORD dwRasDevInfoSize = 0;
    DWORD dwSize;
    BOOL bRC = FALSE;

    DEBUGMSG("INETCFG: IsSmartPPPConnectoid\n");
    //
    // Check for PPP connectoid
    //

    //
    // ChrisK Olympus 6055 6/7/97
    // Make sure RNA dll functions are loaded, otherwise
    // GetEntry will assert.
    //
    if (ERROR_SUCCESS != EnsureRNALoaded() ||
        ERROR_SUCCESS != GetEntry(&lpRasEntry,
                            &dwRasEntrySize,
                            lpszEntry) ||
        RASFP_Ppp != lpRasEntry->dwFramingProtocol)
    {
        goto IsSmartPPPConnectoidExit;
    }
    else
    {
        //
        // The user appears to have a working modem connectoid
        // so skip the ICW
        //
        bRC = TRUE;
        goto IsSmartPPPConnectoidExit;
    }

IsSmartPPPConnectoidExit:
    //
    // Release memory
    //
    if (NULL != lpRasEntry)
    {
        GlobalFree(lpRasEntry);
        lpRasEntry = NULL;
    }

    if (NULL != lpRasDevInfo)
    {
        GlobalFree(lpRasDevInfo);
        lpRasDevInfo = NULL;
    }
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartPPPConnectoidNT
//
//    Synopsis:    Check that the connectoid for the address of the start page is
//                a PPP connectoid
//
//    Arguments:
//
//    Returns:    TRUE - run ICW; FALSE - quit NOW
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartPPPConnectoidNT()
{
    BOOL bRC = SMART_RUNICW;
    HKEY hkey;
    TCHAR szStartPage[1024];
    TCHAR *pchFrom, *pchTo;
    HINSTANCE hRASAPI32;
    LPRASAUTODIALENTRY lpRasAutoDialEntry = NULL;
    DWORD dwSize=0;
    DWORD dwNum=0;
    FARPROC fp = NULL;

    DEBUGMSG("INETCFG: SmartStartPPPConnectoidNT\n");
    //
    // Read start page from registry
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
                            IE4_SETTINGS_MAIN,
                            &hkey) && hkey)
    {
        goto SmartStartPPPConnectoidNTExit;
    }
    if (ERROR_SUCCESS != RegQueryValueEx(hkey,
                            IE4_SETTINGS_STARTPAGE,
                            NULL,                //lpReserved
                            NULL,                //lpType
                            (LPBYTE)szStartPage,//lpData
                            &dwSize)            //lpcbData
        && dwSize >= MIN_HTTP_ADDRESS)
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    //
    // Parse server name out of start page URL and save it in szStartPage
    //
    if (2 != CompareString(LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szStartPage,
                lstrlen(SMART_HTTP),
                SMART_HTTP,
                lstrlen(SMART_HTTP)))
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    pchFrom = &szStartPage[sizeof(SMART_HTTP)];
    pchTo = &szStartPage[0];
    while (*pchFrom && '/' != *pchFrom)
    {
        *pchTo++ = *pchFrom++;
    }
    *pchTo = '\0';

    //
    // Look up address in RasAutodial database
    //
    if (NULL == (hRASAPI32 = LoadLibrary("rasapi32.dll")))
    {
        DEBUGMSG("INETCFG: rasapi32.dll didn't load.\n");
        goto SmartStartPPPConnectoidNTExit;
    }

#ifdef UNICODE
    if (NULL == (fp = GetProcAddress(hRASAPI32,"RasGetAutodialAddressW")))
#else
    if (NULL == (fp = GetProcAddress(hRASAPI32,"RasGetAutodialAddressA")))
#endif
    {
        DEBUGMSG("INETCFG: RasGetAutodialAddressA didn't load.\n");
        goto SmartStartPPPConnectoidNTExit;
    }

    if (ERROR_SUCCESS != ((PFNRASGETAUTODIALADDRESS)fp)(szStartPage,
                            NULL,        // lpdwReserved
                            NULL,        // lpAutoDialEntries
                            &dwSize,    // lpdwcbAutoDialEntries
                            &dwNum)        // lpdwcAutoDialEntries
        || 0 == dwNum)
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    if (NULL == (lpRasAutoDialEntry = (LPRASAUTODIALENTRY)GlobalAlloc(GPTR,dwSize)))
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    lpRasAutoDialEntry->dwSize = dwSize;
    if (ERROR_SUCCESS != ((PFNRASGETAUTODIALADDRESS)fp)(szStartPage,
                            NULL,                // lpdwReserved
                            lpRasAutoDialEntry,    // lpAutoDialEntries
                            &dwSize,            // lpdwcbAutoDialEntries
                            &dwNum))            // lpdwcAutoDialEntries
    {
        goto SmartStartPPPConnectoidNTExit;
    }

    //
    // Determine if the connectoid is PPP
    //
    if (IsSmartPPPConnectoid(lpRasAutoDialEntry->szEntry))
    {
        bRC = SMART_QUITICW;
    }

SmartStartPPPConnectoidNTExit:
    if (hkey)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartPPPConnectoid95
//
//    Synopsis:    Check that the connectoid set in the autodial setting is a PPP
//                connectoid
//
//    Arguments:
//
//    Returns:    TRUE - run ICW; FALSE - quit NOW
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartPPPConnectoid95()
{
    BOOL bAutodialEnabled = FALSE;
    CHAR szAutodialName[RAS_MaxEntryName + 1];
    DWORD dwSize;
    BOOL bRC = SMART_RUNICW;

    DEBUGMSG("INETCFG: SmartStartPPPConnectoid95\n");

    //
    // Get Autodial connectoid
    //
    dwSize = RAS_MaxEntryName;
    if (ERROR_SUCCESS != InetGetAutodial(&bAutodialEnabled,
                            szAutodialName,
                            dwSize) ||
        !bAutodialEnabled ||
        0 == lstrlen(szAutodialName))
    {
        goto SmartStartPPPConnectoid95Exit;
    }

    //
    // Determine if the connectoid is PPP
    //
    if (IsSmartPPPConnectoid(szAutodialName))
    {
        bRC = SMART_QUITICW;
    }

SmartStartPPPConnectoid95Exit:
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    AtLeastOneTAPILocation
//
//    Synopsis:    Check machine to verify that there is at least 1 tapi dialing
//                location
//
//    Arguments:    none
//
//    Returns:    TRUE 
//
//    History:    3 18 98   donaldm
//
//-----------------------------------------------------------------------------
BOOL AtLeastOneTAPILocation()
{
    HKEY    hkey;
    BOOL    bRet = FALSE;
        
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                      REGSTR_PATH_TELEPHONYLOCATIONS, 
                                      0, 
                                      KEY_ALL_ACCESS, 
                                      &hkey))
    {
        DWORD   dwSubKeys = 0;
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &dwSubKeys,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL))
        {
            // If there are any subkeys under locaitons, then there is at least 1
            if (dwSubKeys)
                bRet = TRUE;
        }                                                         
        RegCloseKey(hkey);
    }
    
    return(bRet);
}

//+----------------------------------------------------------------------------
//
//    Function:    SmartStartModem
//
//    Synopsis:    Check machine to verify that there is a modem and an autodial
//                connectoid
//
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/10/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
BOOL SmartStartModem()
{
    BOOL bResult = FALSE;
    DWORD dwSize = 0;
    BOOL bRC = SMART_RUNICW;
    FARPROC fp;

    DEBUGMSG("INETCFG: SmartStartModem\n");
    //
    // Call Inetcfg to see if a modem is properly installed with TCP
    //
    if (ERROR_SUCCESS == InetNeedSystemComponents(INETCFG_INSTALLDIALUP,
                            &bResult)
        && !bResult)
    {
        //
        // Check to see if Dial-Up networking/RAS/RNA is install
        //
        if (ERROR_SUCCESS == InetNeedSystemComponents(INETCFG_INSTALLRNA,
                                &bResult) 
            && !bResult)
        {
            // DONALDM: GETCON bug 94. If there are no tapi locations, then
            // we can fail smart start, because there is no way the use
            // is connected. We want to bail here because InetNeedModem will call
            // RasEnumDevices, which will pop up the TAPI locations dialog
            if (AtLeastOneTAPILocation())
            {
        
                //
                // ChrisK Olympus 6324 6/11/97
                // Need to explicitly check for modem
                //
                if (ERROR_SUCCESS == InetNeedModem(&bResult) && 
                    !bResult)
                {
                    if (IsNT())
                    {
                        //
                        // Check that Ras services are running
                        //
                        //!JACOBBUGBUG!
                        if (ERROR_SUCCESS != InetStartServices())
                        {
                            goto SmartStartNetcardExit;
                        }

                        bRC = SmartStartPPPConnectoidNT();
                    }
                    else
                    {
                        bRC = SmartStartPPPConnectoid95();
                    }
                }
            }                
        }
    }

SmartStartNetcardExit:
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartStart
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/8/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
extern "C" DWORD WINAPI IsSmartStart()
{
    BOOL bRC = SMART_RUNICW;
    BOOL bResult;

    DEBUGMSG("INETCFG: IsSmartStart\n");

    if (IsNT())
    {
        DEBUGMSG("INETCFG: SmartStart not enabled on NT.\n");
        goto IsSmartStartExit;
    }

    //
    // #1. Check to see if TCP is installed
    //
    bResult = FALSE;
    if (ERROR_SUCCESS != InetNeedSystemComponents(INETCFG_INSTALLTCPONLY,
                            &bResult) || bResult)
    {
        DEBUGMSG("INETCFG: SmartStart TCP is missing\n");
        goto IsSmartStartExit;
    }

    //
    // #2. Check to see if there is a netcard installed
    //
    if (SMART_QUITICW == (bRC = SmartStartNetcard()))
    {
        DEBUGMSG("INETCFG: SmartStart LAN setup found.\n");
        goto IsSmartStartExit;
    }

    //
    // #3. Check to see if there is a modem installed
    //
    bRC = SmartStartModem();
    if (SMART_QUITICW == bRC)
    {
        DEBUGMSG("INETCFG: SmartStart Modem setup found.\n");
    }
    else
    {
        DEBUGMSG("INETCFG: SmartStart no valid setup found.\n");
    }
    
IsSmartStartExit:
    return bRC;
}

#endif      // OLD_SMART_START

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartStartEx
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/8/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
typedef DWORD (WINAPI *PFNInternetGetConnectedState)   (LPDWORD, DWORD);
typedef DWORD (WINAPI *PFNInternetGetConnectedStateEx) (LPDWORD, LPTSTR, DWORD, DWORD);

extern "C" DWORD WINAPI IsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen)
{
    DEBUGMSG("INETCFG: IsSmartStartEx\n");

    BOOL  bRC              = SMART_RUNICW;
    DWORD dwConnectedFlags = 0;
    
    HINSTANCE hWinInet = LoadLibrary(TEXT("wininet.dll"));
    if (hWinInet)
    {
        PFNInternetGetConnectedState   pfnInternetGetConnectedState   = NULL;
        PFNInternetGetConnectedStateEx pfnInternetGetConnectedStateEx = NULL;

#ifdef UNICODE
        pfnInternetGetConnectedStateEx = (PFNInternetGetConnectedStateEx)GetProcAddress(hWinInet,"InternetGetConnectedStateExW");
#else
        pfnInternetGetConnectedStateEx = (PFNInternetGetConnectedStateEx)GetProcAddress(hWinInet,"InternetGetConnectedStateEx");
#endif
        pfnInternetGetConnectedState   = (PFNInternetGetConnectedState)GetProcAddress(hWinInet,"InternetGetConnectedState");

        if (pfnInternetGetConnectedStateEx)
        {
            pfnInternetGetConnectedStateEx(&dwConnectedFlags, 
                                         lpszConnectionName,
                                         dwBufLen,
                                         0);
        }
        else if(pfnInternetGetConnectedState)
        {
            pfnInternetGetConnectedState(&dwConnectedFlags, 0);
        }

        FreeLibrary(hWinInet);
    }
    // Existing connectoin is determined by existing modem or proxy, no need to run ICW
    // Check to see if there is a MODEM or PROXY connection
    if (dwConnectedFlags & 
        (INTERNET_CONNECTION_CONFIGURED | INTERNET_CONNECTION_LAN | 
         INTERNET_CONNECTION_PROXY | INTERNET_CONNECTION_MODEM
         )
        )
    {
        bRC = SMART_QUITICW;
    }
     
    return bRC;
}

//+----------------------------------------------------------------------------
//
//    Function:    IsSmartStart
//
//    Synopsis:    This function will determine if the ICW should be run.  The
//                decision is made based on the current state of the user's machine.
//                
//    Arguments:    none
//
//    Returns:    TRUE - run ICW; FALSE - quit now
//
//    History:    5/8/97    ChrisK    Created
//
//-----------------------------------------------------------------------------
extern "C" DWORD WINAPI IsSmartStart()
{
    return IsSmartStartEx(NULL, 0);
}

//*******************************************************************
//
//  FUNCTION:   SetAutoProxyConnectoid
//
//  PURPOSE:    This function will set the enable/disable auto
//              proxy settings in creating connectoid.
//
//  PARAMETERS: fEnable - If set to TRUE, proxy will be enabled.
//              If set to FALSE, proxy will be disabled.
//
//*******************************************************************

HRESULT WINAPI SetAutoProxyConnectoid( BOOL bEnable)
{
    g_bUseAutoProxyforConnectoid = bEnable;
    return ERROR_SUCCESS;
}

#endif //!WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\factory.cpp ===
/****************************************************************************
 *
 *	FACTORY.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the CFactory class, which is used by COM's CoCreateInstance
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

#include "registry.h"

// Friendly name of component
const TCHAR g_szFriendlyName[] = TEXT("CLSID_ApprenticeICW") ;

// Version-independent ProgID
const TCHAR g_szVerIndProgID[] = TEXT("INETCFG.Apprentice") ;

// ProgID
const TCHAR g_szProgID[] = TEXT("INETCFG.Apprentice.1") ;

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

///////////////////////////////////////////////////////////
//
// Class factory
//
class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;         
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;

	// Interface IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
	                                         void** ppv) ;
	virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor
	CFactory() : m_cRef(1) {}

	// Destructor
	~CFactory() { DEBUGMSG("Class factory:\t\tDestroy self.") ;}

private:
	long m_cRef ;
} ;

//
// Class factory IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(const IID& iid, void** ppv)
{    
	DEBUGMSG("CFactory::QueryInterface");
	if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
	{
		*ppv = static_cast<IClassFactory*>(this) ; 
	}
	else
	{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
	return S_OK ;
}

ULONG __stdcall CFactory::AddRef()
{
	DEBUGMSG("CFactory::AddRef %d", m_cRef + 1);
	return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall CFactory::Release() 
{
	if (InterlockedDecrement(&m_cRef) == 0)
	{
		delete this ;
		return 0 ;
	}
	DEBUGMSG("CFactory::Release %d", m_cRef);
	return m_cRef ;
}

//
// IClassFactory implementation
//
HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
	DEBUGMSG("CFactory::CreateInstance:\t\tCreate component.") ;

	// Cannot aggregate.
	if (pUnknownOuter != NULL)
	{
		return CLASS_E_NOAGGREGATION ;
	}

	// Create component.  Since there's no direct IUnknown implementation,
	// use CICWApprentice.
	CICWApprentice *pApprentice = new CICWApprentice;
	
	DEBUGMSG("CFactory::CreateInstance CICWApprentice->AddRef");
	pApprentice->AddRef();
	
	if( NULL == pApprentice )
	{
		return E_OUTOFMEMORY;
	}

	// Get the requested interface.
	DEBUGMSG("CFactory::CreateInstance About to QI on CICWApprentice");
	HRESULT hr = pApprentice->QueryInterface(iid, ppv) ;

	// Release the IUnknown pointer.
	// (If QueryInterface failed, component will delete itself.)
	DEBUGMSG("CFactory::CreateInstance done with CICWApprentice, releasing (aprtc should have ct of 1)");
	pApprentice->Release() ;
	
	return hr ;
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
	if (bLock)
	{
		InterlockedIncrement(&g_cServerLocks) ; 
	}
	else
	{
		InterlockedDecrement(&g_cServerLocks) ;
	}
	return S_OK ;
}


///////////////////////////////////////////////////////////
//
// Exported functions
//
// These are the functions that COM expects to find
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
	if ((g_cComponents == 0) && (g_cServerLocks == 0))
	{
		return S_OK ;
	}
	else
	{
		return S_FALSE ;
	}
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
	DEBUGMSG("DllGetClassObject:\tCreate class factory.") ;

	// Can we create this component?
	if (clsid != CLSID_ApprenticeICW)
	{
		return CLASS_E_CLASSNOTAVAILABLE ;
	}

	// Create class factory.
	CFactory* pFactory = new CFactory ;  // No AddRef in constructor
	if (pFactory == NULL)
	{
		return E_OUTOFMEMORY ;
	}

	// Get requested interface.
	DEBUGMSG("DllGetClassObject about to QI on CFactory");
	HRESULT hr = pFactory->QueryInterface(iid, ppv) ;
	DEBUGMSG("DllGetClassObject done with CFactory, releasing");
	pFactory->Release() ;


	return hr ;
}


// The following two exported functions are what regsvr32 uses to
// self-register and unregister the dll.  See REGISTRY.CPP for
// actual implementation

//
// Server registration
//
STDAPI DllRegisterServer()
{
	return RegisterServer(ghInstance, 
	                      CLSID_ApprenticeICW,
	                      g_szFriendlyName,
	                      g_szVerIndProgID,
	                      g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
	return UnregisterServer(CLSID_ApprenticeICW,
	                        g_szVerIndProgID,
	                        g_szProgID) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\icfgcall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
//

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#include "wizard.h"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)

// Global variables
HINSTANCE ghInstConfigDll=NULL; // handle to Config dll we load explicitly
DWORD     dwCfgRefCount=0;
BOOL      fCFGLoaded=FALSE; // TRUE if config function addresses have been loaded

// global function pointers for Config apis
DOGENINSTALL            lpDoGenInstall=NULL;
GETSETUPXERRORTEXT      lpGetSETUPXErrorText=NULL;
ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath=NULL;
ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents=NULL;
ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents=NULL;
ICFGISGLOBALDNS             lpIcfgIsGlobalDNS=NULL;
ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS=NULL;
ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing=NULL;
ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn=NULL;
ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText=NULL;
ICFGSTARTSERVICES           lpIcfgStartServices=NULL;
//
// These two calls are only in NT icfg32.dll
//
ICFGNEEDMODEM               lpIcfgNeedModem = NULL;
ICFGINSTALLMODEM            lpIcfgInstallModem = NULL;

// API table for function addresses to fetch
#define NUM_CFGAPI_PROCS   11
APIFCN ConfigApiList[NUM_CFGAPI_PROCS] =
{
//  { (PVOID *) &lpDoGenInstall,            szDoGenInstall},
//  { (PVOID *) &lpGetSETUPXErrorText,      szGetSETUPXErrorText},
  { (PVOID *) &lpIcfgSetInstallSourcePath,    szIcfgSetInstallSourcePath},
  { (PVOID *) &lpIcfgInstallInetComponents,    szIcfgInstallInetComponents},
  { (PVOID *) &lpIcfgNeedInetComponents,       szIcfgNeedInetComponents},
  { (PVOID *) &lpIcfgIsGlobalDNS,             szIcfgIsGlobalDNS},
  { (PVOID *) &lpIcfgRemoveGlobalDNS,         szIcfgRemoveGlobalDNS},
  { (PVOID *) &lpIcfgTurnOffFileSharing,      szIcfgTurnOffFileSharing},
  { (PVOID *) &lpIcfgIsFileSharingTurnedOn,   szIcfgIsFileSharingTurnedOn},
  { (PVOID *) &lpIcfgGetLastInstallErrorText, szIcfgGetLastInstallErrorText},
  { (PVOID *) &lpIcfgStartServices,           szIcfgStartServices},
    //
    // These two calls are only in NT icfg32.dll
    //
  { (PVOID *) &lpIcfgNeedModem,         szIcfgNeedModem},
  { (PVOID *) &lpIcfgInstallModem,      szIcfgInstallModem}
};

#pragma data_seg(DATASEG_DEFAULT)

extern BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,
  UINT nApiProcs);

/*******************************************************************

  NAME:    InitConfig

  SYNOPSIS:  Loads the Config dll (ICFG32), gets proc addresses,

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

********************************************************************/
BOOL InitConfig(HWND hWnd)
{
  UINT uiNumCfgApiProcs = 0;

      
  DEBUGMSG("icfgcall.c::InitConfig()");

  // only actually do init stuff on first call to this function
  // (when reference count is 0), just increase reference count
  // for subsequent calls
  if (dwCfgRefCount == 0) {

    TCHAR szConfigDll[SMALL_BUF_LEN];

    DEBUGMSG("Loading Config DLL");

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    if (TRUE == IsNT())
    {
        if (TRUE == IsNT5())
        {
            LoadSz(IDS_CONFIGNT5DLL_FILENAME,szConfigDll,sizeof(szConfigDll));
        }
        else
        {
            //
            // On Windows NT get the filename (ICFGNT.DLL) out of resource
            //
            LoadSz(IDS_CONFIGNTDLL_FILENAME,szConfigDll,sizeof(szConfigDll));
        }            
    }
    else
    {
        //
        // On Windows 95 get the filename (ICFG95.DLL) out of resource
        //
        LoadSz(IDS_CONFIG95DLL_FILENAME,szConfigDll,sizeof(szConfigDll));
    }

    // load the Config api dll
    ghInstConfigDll = LoadLibrary(szConfigDll);
    if (!ghInstConfigDll) {
      UINT uErr = GetLastError();
      // Normandy 11985 - chrisk
      // filenames changed for Win95 and NT
      if (TRUE == IsNT())
      {
          DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDllNT1,uErr,ERRCLS_STANDARD,
            MB_ICONSTOP);
      }
      else
      {
          DisplayErrorMessage(hWnd,IDS_ERRLoadConfigDll1,uErr,ERRCLS_STANDARD,
            MB_ICONSTOP);
      }
      return FALSE;
    }

    //
    // Cycle through the API table and get proc addresses for all the APIs we
    // need - on NT icfg32.dll has 2 extra entry points
    //
    if (TRUE == IsNT())
        uiNumCfgApiProcs = NUM_CFGAPI_PROCS;
    else
        uiNumCfgApiProcs = NUM_CFGAPI_PROCS - 2;
    
    if (!GetApiProcAddresses(ghInstConfigDll,ConfigApiList,uiNumCfgApiProcs)) {
    // Normandy 11985 - chrisk
    // filenames changed for Win95 and NT
      if (TRUE == IsNT())
      {
        MsgBox(hWnd,IDS_ERRLoadConfigDllNT2,MB_ICONSTOP,MB_OK);
      }
      else
      {
        MsgBox(hWnd,IDS_ERRLoadConfigDll2,MB_ICONSTOP,MB_OK);
      }
      DeInitConfig();
      return FALSE;
    }

  }

  fCFGLoaded = TRUE;

  dwCfgRefCount ++;

  return TRUE;
}

/*******************************************************************

  NAME:    DeInitConfig

  SYNOPSIS:  Unloads Config dll.

********************************************************************/
VOID DeInitConfig()
{
  DEBUGMSG("icfgcall.c::DeInitConfig()");

  UINT nIndex;

  // decrement reference count
  if (dwCfgRefCount)
    dwCfgRefCount --;

  // when the reference count hits zero, do real deinitialization stuff
  if (dwCfgRefCount == 0)
  {
    if (fCFGLoaded)
    {
      // set function pointers to NULL
      for (nIndex = 0;nIndex<NUM_CFGAPI_PROCS;nIndex++) 
        *ConfigApiList[nIndex].ppFcnPtr = NULL;

      fCFGLoaded = FALSE;
    }

    // free the Config dll
    if (ghInstConfigDll)
    {
    DEBUGMSG("Unloading Config DLL");
      FreeLibrary(ghInstConfigDll);
      ghInstConfigDll = NULL;
    }

  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\icfgcall.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//  HISTORY:
//  
//  96/05/23  markdu  Created.
//  96/05/26  markdu  Update config API.
//  96/05/27  markdu  Added lpIcfgGetLastInstallErrorText.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.

#ifndef _ICFGCALL_H_
#define _ICFGCALL_H_

// function pointer typedefs for RNA apis from rnaph.dll and rasapi32.dll
typedef DWORD   (WINAPI * DOGENINSTALL               )  (HWND hwndParent,LPCTSTR lpszInfFile,LPCTSTR lpszInfSect);
typedef DWORD   (WINAPI * GETSETUPXERRORTEXT         )  (DWORD dwErr,LPTSTR pszErrorDesc,DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSETINSTALLSOURCEPATH   )  (LPCTSTR lpszSourcePath);
typedef HRESULT (WINAPI * ICFGINSTALLSYSCOMPONENTS   )  (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart);
typedef HRESULT (WINAPI * ICFGNEEDSYSCOMPONENTS      )  (DWORD dwfOptions, LPBOOL lpfNeedComponents);
typedef HRESULT (WINAPI * ICFGISGLOBALDNS            )  (LPBOOL lpfGlobalDNS);
typedef HRESULT (WINAPI * ICFGREMOVEGLOBALDNS        )  (void);
typedef HRESULT (WINAPI * ICFGTURNOFFFILESHARING     )  (DWORD dwfDriverType, HWND hwndParent);
typedef HRESULT (WINAPI * ICFGISFILESHARINGTURNEDON  )  (DWORD dwfDriverType, LPBOOL lpfSharingOn);
typedef DWORD   (WINAPI * ICFGGETLASTINSTALLERRORTEXT)  (LPTSTR lpszErrorDesc, DWORD cbErrorDesc);
typedef HRESULT (WINAPI * ICFGSTARTSERVICES          )  (void);

//
// These are available only on the NT icfg32.dll
//
typedef HRESULT (WINAPI * ICFGNEEDMODEM				)	(DWORD dwfOptions, LPBOOL lpfNeedModem);
typedef HRESULT (WINAPI * ICFGINSTALLMODEM			)	(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart);

BOOL InitConfig(HWND hWnd);
VOID DeInitConfig();

//
// global function pointers for Config apis
//
extern DOGENINSTALL					lpDoGenInstall;
extern GETSETUPXERRORTEXT			lpGetSETUPXErrorText;
extern ICFGSETINSTALLSOURCEPATH    lpIcfgSetInstallSourcePath;
extern ICFGINSTALLSYSCOMPONENTS    lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS       lpIcfgNeedInetComponents;
extern ICFGISGLOBALDNS             lpIcfgIsGlobalDNS;
extern ICFGREMOVEGLOBALDNS         lpIcfgRemoveGlobalDNS;
extern ICFGTURNOFFFILESHARING      lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn;
extern ICFGGETLASTINSTALLERRORTEXT lpIcfgGetLastInstallErrorText;
extern ICFGSTARTSERVICES           lpIcfgStartServices;
//
// These two calls are only in NT icfg32.dll
//
extern ICFGNEEDMODEM				lpIcfgNeedModem;
extern ICFGINSTALLMODEM			lpIcfgInstallModem;


#endif // _ICFGCALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\iclient.cpp ===
//****************************************************************************
//
//  Module:     INETCFG.DLL
//  File:       iclient.c
//  Content:    This file contains all the functions that handle importing
//              client information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//  96/03/13  markdu  Assimilated with inetcfg.dll.
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/04/18  markdu  NASH BUG 18443
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "wizard.h"
#include "inetcfg.h"

#define REGSTR_PATH_INTERNET_CLIENT     TEXT("Software\\Microsoft\\Internet ClientX")

#pragma data_seg(".rdata")

// registry constants
static const TCHAR cszRegPathInternetClient[] =  REGSTR_PATH_INTERNET_CLIENT;

static const TCHAR cszRegValEMailName[] =           TEXT("EMail_Name");
static const TCHAR cszRegValEMailAddress[] =        TEXT("EMail_Address");
static const TCHAR cszRegValPOPLogonRequired[] =    TEXT("POP_Logon_Required");
static const TCHAR cszRegValPOPLogonName[] =        TEXT("POP_Logon_Name");
static const TCHAR cszRegValPOPLogonPassword[] =    TEXT("POP_Logon_Password");
static const TCHAR cszRegValPOPServer[] =           TEXT("POP_Server");
static const TCHAR cszRegValSMTPServer[] =          TEXT("SMTP_Server");
static const TCHAR cszRegValNNTPLogonRequired[] =   TEXT("NNTP_Logon_Required");
static const TCHAR cszRegValNNTPLogonName[] =       TEXT("NNTP_Logon_Name");
static const TCHAR cszRegValNNTPLogonPassword[] =   TEXT("NNTP_Logon_Password");
static const TCHAR cszRegValNNTPServer[] =          TEXT("NNTP_Server");
static const TCHAR cszNull[] = TEXT("");
static const TCHAR cszYes[] = TEXT("yes");
static const TCHAR cszNo[] = TEXT("no");

#pragma data_seg()

#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc(LPCSTR);
VOID   ToAnsiClientInfo(LPINETCLIENTINFOA, LPINETCLIENTINFOW);
VOID   ToUnicodeClientInfo(LPINETCLIENTINFOW, LPINETCLIENTINFOA);
#endif

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************
#ifdef UNICODE
extern "C" HRESULT WINAPI InetGetClientInfoA
(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo
)
{
    HRESULT hr;
    TCHAR   lpszProfileNameW[MAX_PATH+1];
    INETCLIENTINFOW ClientInfoW;

    mbstowcs(lpszProfileNameW, lpszProfileName, lstrlenA(lpszProfileName)+1);
    hr = InetGetClientInfoW(lpszProfileNameW, &ClientInfoW);
    ToAnsiClientInfo(lpClientInfo, &ClientInfoW);

    return hr;
}

extern "C" HRESULT WINAPI InetGetClientInfoW
#else
extern "C" HRESULT WINAPI InetGetClientInfoA
#endif
(
  LPCTSTR           lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo
)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    if (sizeof(INETCLIENTINFO) > lpClientInfo->dwSize)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    dwRet = RegOpenKey(HKEY_CURRENT_USER, cszRegPathInternetClient, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    lpClientInfo->dwFlags = 0;

    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegQueryValueEx(
            hKey,
            cszRegValPOPLogonRequired,
            0L,
            &dwType,
            (LPBYTE)&dwVal,
            &dwSize);

    if (dwVal)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }

    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegQueryValueEx(
            hKey,
            cszRegValNNTPLogonRequired,
            0L,
            &dwType,
            (LPBYTE)&dwVal,
            &dwSize);

    if (dwVal)
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValEMailName,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValEMailAddress,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szPOPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValPOPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szPOPServer,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szSMTPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValSMTPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szSMTPServer,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            &dwSize);

    RegCloseKey(hKey);

    return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

#ifdef UNICODE
extern "C" HRESULT WINAPI InetSetClientInfoA
(
  LPCSTR            lpszProfileName,
  LPINETCLIENTINFOA lpClientInfo
)
{
    TCHAR   szProfileNameW[MAX_PATH+1];
    INETCLIENTINFOW ClientInfoW;

    mbstowcs(szProfileNameW, lpszProfileName, lstrlenA(lpszProfileName)+1);
    ToUnicodeClientInfo(&ClientInfoW, lpClientInfo);
    return InetSetClientInfoW(szProfileNameW, &ClientInfoW);
}

extern "C" HRESULT WINAPI InetSetClientInfoW
#else
extern "C" HRESULT WINAPI InetSetClientInfoA
#endif
(
  LPCTSTR           lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo
)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    if (sizeof(INETCLIENTINFO) > lpClientInfo->dwSize)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    dwRet = RegCreateKey(HKEY_CURRENT_USER, cszRegPathInternetClient, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    dwVal = lpClientInfo->dwFlags & INETC_LOGONMAIL ? 1 : 0;
    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegSetValueEx(
            hKey,
            cszRegValPOPLogonRequired,
            0L,
            dwType,
            (LPBYTE)&dwVal,
            dwSize);

    dwVal = lpClientInfo->dwFlags & INETC_LOGONNEWS ? 1 : 0;
    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegSetValueEx(
            hKey,
            cszRegValNNTPLogonRequired,
            0L,
            dwType,
            (LPBYTE)&dwVal,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValEMailName,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValEMailAddress,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            dwSize);

    dwSize = sizeof(lpClientInfo->szPOPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValPOPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szPOPServer,
            dwSize);

    dwSize = sizeof(lpClientInfo->szSMTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValSMTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szSMTPServer,
            dwSize);

    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            dwSize);

    RegCloseKey(hKey);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\icwaprtc.cpp ===
/****************************************************************************
 *
 *	ICWAPRTC.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the CICWApprentice class.
 *
 *	5/1/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"
#include "pagefcns.h"
#include "icwcfg.h"

UINT	g_uExternUIPrev, g_uExternUINext;

IICWExtension	*g_pExternalIICWExtension = NULL;
BOOL			g_fConnectionInfoValid = FALSE;

//defined/allocated in propmgr.cpp
extern PAGEINFO PageInfo[NUM_WIZARD_PAGES];
extern INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
								LPARAM lParam);
extern VOID InitWizardState(WIZARDSTATE * pWizardState, DWORD dwFlags);
extern VOID InitUserInfo(USERINFO * pUserInfo);

//define in rnacall.cpp
extern void InitRasEntry(LPRASENTRY lpEntry);

//defined in endui.cpp
extern BOOL CommitConfigurationChanges(HWND hDlg);


/*** Class definition, for reference only ***
  (actual definition is in icwaprtc.h)

class CICWApprentice : public IICWApprentice
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt);
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError);
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
		virtual ULONG	STDMETHODCALLTYPE AddRef( void );
		virtual ULONG	STDMETHODCALLTYPE Release( void );

		CICWApprentice( void );
		~CICWApprentice( void );

		IICWExtension	*m_pIICWExt;

    private:
		LONG	m_lRefCount;

};
****/

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::Initialize
//
//	Synopsis	Called by the main Wizard to initialize class members and
//				globals
//
//	Arguments	[in] pExt -- pointer the Wizard's IICWExtension interface, which
//							encapsulates the functionality needed to add wizard
//							pages.
//
//	Returns		E_OUTOFMEMORY -- unable to allocate global vars.
//				S_OK indicates success
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Initialize(IICWExtension *pExt)
{
	DEBUGMSG("CICWApprentice::Initialize");

	ASSERT( pExt );
	m_pIICWExt = pExt;

	m_pIICWExt->AddRef();

	// various page OKProcs will need this pointer in order
	// to call SetFirstLastPage
	ASSERT( NULL == g_pExternalIICWExtension );
	g_pExternalIICWExtension = pExt;

	g_fConnectionInfoValid = FALSE;

	if( !gpWizardState)
	{
		gpWizardState = new WIZARDSTATE;
	}

	if( !gpUserInfo )
	{
		gpUserInfo = new USERINFO;
	}

	if( !gpRasEntry )
	{
		gdwRasEntrySize = sizeof(RASENTRY);
		gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);
	}

	if( !gpRasEntry || !gpWizardState || !gpUserInfo )
	{
		DEBUGMSG("CICWApprentice::Initialize couldn't initialize the globals!");
		return E_OUTOFMEMORY;
	}

	// stolen from RunSignupWizard in propmgr.cpp
	// initialize the rasentry structure
	InitRasEntry(gpRasEntry);

	// initialize the app state structure
	InitWizardState(gpWizardState, RSW_APPRENTICE);

	gpWizardState->dwRunFlags |= RSW_APPRENTICE;

	// initialize user data structure
	InitUserInfo(gpUserInfo);

    //
	// 6/2/97	jmazner	Olympus #4542
	// default to CONNECT_RAS
	//
	gpUserInfo->uiConnectionType = CONNECT_RAS;

	
	return S_OK;

}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::AddWizardPages
//
//	Synopsis	Creates a series of Property Sheet pages, and adds them to the
//				main wizard via the m_pIICWExt interface pointer.  Note that
//				we add every page in the global PageInfo struct, even though the
//				Apprentice may not use some pages (eg, CONNECTEDOK)
//
//	Arguments	[] dwFlags -- currently unused
//
//	Returns		S_OK indicates success
//				E_FAIL indicates failure.  If for any reason all pages can not be
//						added, we will attempt to remove any pages that had been
//						added prior to the failure.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::AddWizardPages(DWORD dwFlags)
{
	HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
	PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
	UINT nPageIndex;
	HRESULT hr = S_OK;
	unsigned long ulNumItems = 0;

	DEBUGMSG("CICWApprentice::AddWizardPages");

	gpWizardState->dwRunFlags |= RSW_APPRENTICE;

	ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
	ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));

    if (dwFlags & WIZ_USE_WIZARD97)
        g_fIsExternalWizard97 = TRUE;

	// fill out common data property sheet page struct
	psPage.dwSize = sizeof(psPage);
	psPage.hInstance = ghInstance;
	psPage.pfnDlgProc = GenDlgProc;

	// create a property sheet page for each page in the wizard
	for (nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
	{
        UINT    uDlgID;
	    psPage.dwFlags = PSP_DEFAULT | PSP_HASHELP;
        if (g_fIsExternalWizard97)
        {
            psPage.dwFlags |= PSP_USETITLE;
            psPage.pszTitle= gpWizardState->cmnStateData.szWizTitle;    
            uDlgID = PageInfo[nPageIndex].uDlgID97External;
        }
        else
            uDlgID = PageInfo[nPageIndex].uDlgID;
    	psPage.pszTemplate = MAKEINTRESOURCE(uDlgID);
                 
		// set a pointer to the PAGEINFO struct as the private data for this
		// page
		psPage.lParam = (LPARAM) &PageInfo[nPageIndex];

        if (g_fIsExternalWizard97 && PageInfo[nPageIndex].nIdTitle)
        {
		    psPage.dwFlags |= PSP_USEHEADERTITLE | (PageInfo[nPageIndex].nIdSubTitle ? PSP_USEHEADERSUBTITLE : 0);
    		psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
	    	psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
        }

		hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);

		if (!hWizPage[nPageIndex])
		{
			DEBUGTRAP("Failed to create property sheet page");
			MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);

			hr = E_FAIL;
			// creating page failed, free any pages already created and bail
			goto AddWizardPagesErrorExit;
		}

		hr = m_pIICWExt->AddExternalPage( hWizPage[nPageIndex], uDlgID);

		if( FAILED(hr) )
		{
			// free any pages already created and bail
			goto AddWizardPagesErrorExit;
		}


	}
  
    if (((dwFlags & WIZ_HOST_ICW_LAN) || (dwFlags & WIZ_HOST_ICW_PHONE)) ||
        (dwFlags & WIZ_HOST_ICW_MPHONE))
    {
        UINT uNextPage;
        BOOL bDummy;

        g_fIsICW = TRUE;

        if (!InitWizard(0))
        {
            hr = E_FAIL;
            DeinitWizard(RSW_NOREBOOT);
        }
        else
        {
            if (S_OK != ProcessCustomFlags(dwFlags))
            {
                DeinitWizard(RSW_NOREBOOT);
                hr = E_FAIL;
            }
        }

    }
    else  
    {
	    // of course, we have no idea what the last page will really be.
	    // so make a guess here, and update it later when we know for sure.
        if (g_fIsExternalWizard97)
	        m_pIICWExt->SetFirstLastPage( IDD_PAGE_HOWTOCONNECT97, IDD_PAGE_HOWTOCONNECT97 );
        else        
	        m_pIICWExt->SetFirstLastPage( IDD_PAGE_HOWTOCONNECT, IDD_PAGE_HOWTOCONNECT );
    }

	return hr;


AddWizardPagesErrorExit:
	UINT nFreeIndex;
	for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
	{
        UINT    uDlgID;
        if (g_fIsExternalWizard97)
            uDlgID = PageInfo[nPageIndex].uDlgID97External;
        else
            uDlgID = PageInfo[nPageIndex].uDlgID;
    
		DestroyPropertySheetPage(hWizPage[nFreeIndex]);
		m_pIICWExt->RemoveExternalPage( hWizPage[nFreeIndex], uDlgID );
	}

	return hr;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::GetConnectionInformation
//
//	Synopsis	Fills the passed in CONNECTINFO structure with the connection
//				information entered by the user.
//
//	Arguments	[in] pInfo -- pointer to a CONNECTINFO structure
//				[out] pInfo -- the indicated structure will contain the user's
//								connection information.
//
//	Returns		S_OK indicates success
//				E_POINTER --  the pInfo pointer is not valid
//				E_FAIL -- the user has not entered any connection info.  This
//							error will occur if the function is called before
//							the user has completed the apprentice.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::GetConnectionInformation(CONNECTINFO *pInfo)
{
	DEBUGMSG("CICWApprentice::GetConnectionInformation");
	ASSERTSZ(pInfo, "CONNECTINFO *pInfo is NULL!");
	if( !pInfo )
	{
		return E_POINTER;
	}

	if( !g_fConnectionInfoValid )
	{
		DEBUGMSG("CICWApprentice::GetConnectionInformation: haven't gathered any connection info yet!");
		return E_FAIL;
	}
	else
	{
		pInfo->cbSize = sizeof( CONNECTINFO );
		
#ifdef UNICODE
        wcstombs(pInfo->szConnectoid, TEXT("Uninitialized\0"), MAX_PATH);
#else
		lstrcpy( pInfo->szConnectoid, TEXT("Uninitialized\0"));
#endif
		pInfo->type = gpUserInfo->uiConnectionType;

		if( CONNECT_RAS == pInfo->type )
		{
#ifdef UNICODE
            wcstombs(pInfo->szConnectoid, gpUserInfo->szISPName, MAX_PATH);
#else
			lstrcpy( pInfo->szConnectoid, gpUserInfo->szISPName);
#endif
		}
	}


	return S_OK;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::SetConnectionInformation
//
//	Synopsis	Sets the default connectoin information for the Apprentice
//
//	Arguments	[in] pInfo -- pointer to a CONNECTINFO structure containing the
//								defaults to use.
//
//	Returns		S_OK indicates success
//				E_POINTER --  the pInfo pointer is not valid
//				E_INVALIDARG -- pInfo appears to point a different CONNECTINO
//								structure than the one we know about (based on
//								the cbSize member).
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetConnectionInformation(CONNECTINFO *pInfo)
{
	DEBUGMSG("CICWApprentice::SetConnectionInformation");

	ASSERTSZ(pInfo, "CONNECTINFO *pInfo is NULL!");
	if( !pInfo )
	{
		return E_POINTER;
	}
	
	if( !(sizeof( CONNECTINFO ) == pInfo->cbSize) )
	{
		DEBUGMSG("CICWApprentice::SetConnectionInformation pInfo->cbSize is unknown!");
		return E_INVALIDARG;
	}
	
	gpUserInfo->uiConnectionType = pInfo->type;
	if( CONNECT_RAS == pInfo->type )
	{
#ifdef UNICODE
        mbstowcs(gpUserInfo->szISPName, pInfo->szConnectoid, MAX_PATH);
#else
		lstrcpy( gpUserInfo->szISPName, pInfo->szConnectoid);
#endif
	}

	return S_OK;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::Save
//
//	Synopsis	Called by the Wizard to commit changes
//
//	Arguments	[in] hwnd -- hwnd of Wizard window, used to display modal msgs
//				[out] pdwError -- implementation specfic error code.  Not used.
//
//	Returns		S_OK indicates success
//				Otherwise, returns E_FAIL.
//
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Save(HWND hwnd, DWORD *pdwError)
{
	DEBUGMSG("CICWApprentice::Save");
	if( CommitConfigurationChanges(hwnd) )
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

HRESULT CICWApprentice::SetDlgHwnd(HWND hDlg)
{
	m_hwndDlg = hDlg;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::SetPrevNextPage
//
//	Synopsis	Lets the apprentice notify the wizard of the dialog IDs of the
//				first and last pages in the apprentice
//
//
//	Arguments	uPrevPageDlgID -- DlgID of wizard page to back up to
//				uNextPageDlgID -- DlgID of wizard page to go forwards into
//
//
//	Returns		FALSE if both parameters are 0
//				TRUE if the update succeeded.
//
//	Notes:		If either variable is set to 0, the function will not update
//				that information, i.e. a value of 0 means "ignore me".  If both
//				variables are 0, the function immediately returns FALSE.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID)
{
	DEBUGMSG("CICWApprentice::SetPrevNextPage: updating prev = %d, next = %d",
		uPrevPageDlgID, uNextPageDlgID);

	if( (0 == uPrevPageDlgID) && (0 == uNextPageDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: both IDs are 0!");
		return( E_INVALIDARG );
	}

	if( 0 != uPrevPageDlgID )
		g_uExternUIPrev = uPrevPageDlgID;
	if( 0 != uNextPageDlgID )
		g_uExternUINext = uNextPageDlgID;


	return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::ProcessCustomFlags
//
//  Synopsis    Lets the apprentice know that there is a special modification
//              to this set of apprentice pages after it is loaded
//
//  Arguments   dwFlags -- info needed to pass to the external pages
//
//
//  Returns     FALSE if both parameters are 0
//              TRUE if the update succeeded.
//
//  History     9/23/97 vyung     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::ProcessCustomFlags(DWORD dwFlags)
{
    UINT uNextPage;
    BOOL bDummy;
    HRESULT hr = S_OK;

    if (gpUserInfo)
        gpUserInfo->uiConnectionType = (dwFlags & WIZ_HOST_ICW_LAN) ? CONNECT_LAN : CONNECT_RAS;

    g_bSkipMultiModem = (BOOL) (dwFlags & WIZ_HOST_ICW_PHONE);

    if (gpWizardState)
    {
        gpWizardState->cmnStateData.dwFlags = 0;
        if (dwFlags & (WIZ_NO_MAIL_ACCT | WIZ_NO_NEWS_ACCT))
        {
    	    gpWizardState->dwRunFlags |= RSW_NOIMN;
        }
    }

    if (!HowToConnectOKProc(m_hwndDlg, TRUE, &uNextPage, &bDummy))
    {
        if (g_bReboot && gpWizardState && g_fIsICW)
        {
            // Set a registry value indicating that we messed with the desktop
           DWORD dwFlags = 0x00800000;//ICW_CFGFLAG_SMARTREBOOT_MANUAL;
            DWORD dwDisposition;
            HKEY hkey = 0;
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                                ICW_REGPATHSETTINGS,
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE, 
                                                KEY_ALL_ACCESS, 
                                                NULL, 
                                                &hkey, 
                                                &dwDisposition))
            {
                DWORD   dwDesktopChanged = 1;    
                RegSetValueEx(hkey, 
                              ICW_REGKEYERROR, 
                              0, 
                              REG_DWORD,
                              (LPBYTE)&dwFlags, 
                              sizeof(DWORD));
                RegCloseKey(hkey);
            }
            g_bRebootAtExit = FALSE;
        }
        hr = E_FAIL;
    }
    else
    {
        switch( uNextPage )
        {
            case ORD_PAGE_USEPROXY:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_USEPROXY97, IDD_PAGE_USEPROXY97 );
                break;
            case ORD_PAGE_SETUP_PROXY:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_SETUP_PROXY97, IDD_PAGE_SETUP_PROXY97 );
                break;
            case ORD_PAGE_CHOOSEMODEM:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_CHOOSEMODEM97, IDD_PAGE_CHOOSEMODEM97 );
                break;
            case ORD_PAGE_PHONENUMBER:
            case ORD_PAGE_CONNECTION:
                m_pIICWExt->SetFirstLastPage( IDD_PAGE_PHONENUMBER97, IDD_PAGE_PHONENUMBER97 );
                break;
            default:
                m_pIICWExt->SetFirstLastPage( 0, 0 );
                break;
        } // end of switch
    }
	return hr;
}

HRESULT CICWApprentice::SetStateDataFromExeToDll(LPCMNSTATEDATA lpData) 
{
    ASSERT(gpWizardState);
    memcpy(&gpWizardState->cmnStateData, lpData, sizeof(CMNSTATEDATA));
    
    return S_OK;
}

//converse of the previous function
HRESULT CICWApprentice::SetStateDataFromDllToExe(LPCMNSTATEDATA lpData) 
{
    ASSERT(gpWizardState);
    
    memcpy(lpData, &gpWizardState->cmnStateData, sizeof(CMNSTATEDATA));
    
    return (S_OK);
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::QueryInterface
//
//	Synopsis	This is the standard QI, with support for
//				IID_Unknown, IICW_Extension and IID_ICWApprentice
//				(stolen from Inside COM, chapter 7)
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::QueryInterface( REFIID riid, void** ppv )
{
	DEBUGMSG("CICWApprentice::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	// IID_IICWApprentice
	if (IID_IICWApprentice == riid)
		*ppv = (void *)(IICWApprentice *)this;
	// IID_IICWApprenticeEx
	else if (IID_IICWApprenticeEx == riid)
		*ppv = (void *)(IICWApprenticeEx *)this;
    // IID_IICWExtension
    else if (IID_IICWExtension == riid)
        *ppv = (void *)(IICWExtension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
		*ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::AddRef
//
//	Synopsis	This is the standard AddRef
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::AddRef( void )
{
	DEBUGMSG("CICWApprentice::AddRef %d", m_lRefCount + 1);
	return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::Release
//
//	Synopsis	This is the standard Release
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::Release( void )
{
	ASSERT( m_lRefCount > 0 );

	InterlockedDecrement(&m_lRefCount);

	DEBUGMSG("CICWApprentice::Release %d", m_lRefCount);
	if( 0 == m_lRefCount )
	{
		m_pIICWExt->Release();
		m_pIICWExt = NULL;

		delete( this );
		return( 0 );
	}
	else
	{
		return( m_lRefCount );
	}
}

//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::CICWApprentice
//
//	Synopsis	This is the constructor, nothing fancy
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWApprentice::CICWApprentice( void )
{
	DEBUGMSG("CICWApprentice constructor called");
	m_lRefCount = 0;
	m_pIICWExt = NULL;

}


//+----------------------------------------------------------------------------
//
//	Function	CICWApprentice::~CICWApprentice
//
//	Synopsis	This is the destructor.  We want to clean up all the memory
//				we allocated in ::Initialize
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWApprentice::~CICWApprentice( void )
{
	DEBUGMSG("CICWApprentice destructor called with ref count of %d", m_lRefCount);

	if (gpImnApprentice)
	{
		gpImnApprentice->Release();  // DeinitWizard is called in Release() 
		gpImnApprentice = NULL;
	}

	if( g_fIsICW )  // if ICW, we need to clean up, otherwise, leave cleanup later
		DeinitWizard(0);
       
	if( m_pIICWExt )
	{
		m_pIICWExt->Release();
		m_pIICWExt = NULL;
	}

	g_pExternalIICWExtension = NULL;

	g_fConnectionInfoValid = FALSE;

	if( gpWizardState)
	{
		delete gpWizardState;
		gpWizardState = NULL;
	}

	if( gpUserInfo )
	{
		delete gpUserInfo;
		gpUserInfo = NULL;
	}

	if( gpRasEntry )
	{
		GlobalFree(gpRasEntry);
		gpRasEntry = NULL;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\icwextsn.h ===
#include "icwacct.h"

extern	UINT	g_uAcctMgrUIFirst, g_uAcctMgrUILast;
#ifndef EXTERNAL_DIALOGID_MAXIMUM
#define EXTERNAL_DIALOGID_MAXIMUM 3000
#endif
#ifndef EXTERNAL_DIALOGID_MINIMUM
#define EXTERNAL_DIALOGID_MINIMUM 2000
#endif

class CICWExtension : public IICWExtension
{
	public:
		virtual BOOL	STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
		virtual BOOL	STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
		virtual ULONG	STDMETHODCALLTYPE AddRef( void );
		virtual ULONG	STDMETHODCALLTYPE Release( void );

		CICWExtension( void );
		~CICWExtension( void );

		HWND m_hWizardHWND;

	private:
		LONG	m_lRefCount;
};

// This _has_ to be a pointer -- if you just instantiate directly, the compiler doesn't
// correctly fill in the vtable, and thus it can't be treated as an IICWExtension pointer.
extern CICWExtension *g_pCICWExtension;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\icwaprtc.h ===
#include "icwacct.h"

extern	UINT	g_uExternUIPrev, g_uExternUINext;

extern	IICWExtension	*g_pExternalIICWExtension;
extern	BOOL			g_fConnectionInfoValid;


class CICWApprentice : public IICWApprentice, public IICWApprenticeEx
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize               (IICWExtension *pExt);
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages           (DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation (CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation (CONNECTINFO *pInfo);
        virtual HRESULT STDMETHODCALLTYPE Save                     (HWND hwnd, DWORD *pdwError);
        virtual HRESULT STDMETHODCALLTYPE SetDlgHwnd               (HWND hDlg);    
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage          (UINT uPrevPageDlgID, UINT uNextPageDlgID);
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags       (DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll (LPCMNSTATEDATA lpData);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe (LPCMNSTATEDATA lpData);
		virtual HRESULT STDMETHODCALLTYPE QueryInterface           (REFIID theGUID, void** retPtr);
		virtual ULONG	STDMETHODCALLTYPE AddRef                   (void);
		virtual ULONG	STDMETHODCALLTYPE Release                  (void);

		CICWApprentice  (void);
		~CICWApprentice (void);

		IICWExtension *m_pIICWExt;
       
	private:
		LONG m_lRefCount;
        HWND m_hwndDlg;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\ifcbase.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Sep 26 18:52:56 1996
 */
/* Compiler settings for c:\athena\compobj\idl\ifcbase.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, app_config, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ifcbase_h__
#define __ifcbase_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Sep 26 18:52:56 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_CONTROL
#define FACILITY_CONTROL 0xa
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_CONTROL, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(101)
#define E_RegQueryInfoKeyFailed      HR_E(102)
#define E_UserCancel                 HR_E(103)
#define E_RegOpenKeyFailed           HR_E(104)
#define E_RegSetValueFailed          HR_E(105)
#define E_RegDeleteKeyFailed         HR_E(106)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(200)
#define E_BufferTooSmall             HR_E(201)
#define E_BadPropType                HR_E(202)
#define E_BufferSizeMismatch         HR_E(203)
#define E_InvalidBooleanValue        HR_E(204)
#define E_InvalidMinMaxValue         HR_E(205)
#define E_PropNotFound               HR_E(206)
#define E_InvalidPropTag             HR_E(207)
#define E_InvalidPropertySet         HR_E(208)
#define E_EnumFinished               HR_E(209)
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)	    (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyContainer
 * at Thu Sep 26 18:52:56 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_LAST	= TYPE_BOOL + 1
    }	PROPTYPE;


EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HrGetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrGetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrGetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrGetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrGetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrGetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrSetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrSetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HrSetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_HrGetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> HrGetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_HrGetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> HrGetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_HrGetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> HrGetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_HrSetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> HrSetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_HrSetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> HrSetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_HrSetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> HrSetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_HrGetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_HrGetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrGetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_HrGetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrGetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][in] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_HrGetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrSetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_HrSetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrSetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_HrSetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_HrSetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_HrSetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// dialog size
#define MY_CXDLG                      304
#define MY_CYDLG                      163

#define MY_CXDLG97                    343
#define MY_CYDLG97                    177
#define MY_CYFIRSTLASTPG              215

#define MY_CXBMP                      79
#define MY_CYBMP                      160

// string resource IDs
#define IDS_APPNAME                   1000
#define IDS_QUERYCANCEL               1002
#define IDS_ERRFORMAT                 1003
#define IDS_RNADLL_FILENAME           1004
#define IDS_COUNTRY_FMT               1005
#define IDS_SHORT_FMT                 1006
#define IDS_DEFAULT_PROFILE_NAME      1007
#define IDS_MAPIDLL_FILENAME          1008
#define IDS_RNAPHDLL_FILENAME         1013
#define IDS_GENERIC_RNA_ERROR         1015
#define IDS_GENERIC_MAPI_ERROR        1016
#define IDS_HELPFILE_NAME             1022
#define IDS_MSN105_INF_FILE           1026
#define IDS_MSN105_UNINSTALL_SECT     1027
#define IDS_MSN100_INF_FILE           1028
#define IDS_MSN100_UNINSTALL_SECT     1029
#define IDS_SCRIPT_FILE_FILTER        1030
#define IDS_CONFIG95DLL_FILENAME      1031
#define IDS_CONFIGNTDLL_FILENAME      1032
#define IDS_CONFIGNT5DLL_FILENAME     1033

#define IDS_INTERNETMAIL_SERVICENAME  1050
#define IDS_MESSAGESTORE_SERVICENAME  1051
#define IDS_ADDRESSBOOK_SERVICENAME   1052
#define IDS_INTERNETMAIL_DESCRIPTION  1053
#define IDS_MESSAGESTORE_DESCRIPTION  1054
#define IDS_ADDRESSBOOK_DESCRIPTION   1055
#define IDS_PROFILENAME               1056
#define IDS_PROFILENAME1              1057

#define IDS_MESSAGESTORE_FILENAME     1060
#define IDS_MESSAGESTORE_FILENAME1    1061
#define IDS_ADDRESSBOOK_FILENAME      1062
#define IDS_ADDRESSBOOK_FILENAME1     1063

#define IDS_ERROutOfMemory            1100
#define IDS_ERRInstallModem           1101
#define IDS_ERRReadConfig             1102
#define IDS_ERRCoInitialize           1103
#define IDS_ERRLoadRNADll1            1106
#define IDS_ERRLoadRNADll2            1107
#define IDS_ERRCreateConnectoid       1109
#define IDS_ERRLoadMAPIDll1           1110
#define IDS_ERRLoadMAPIDll2           1111
#define IDS_ERRInitMAPI               1112
#define IDS_ERRConfigureMail          1114
#define IDS_ERRConnectoidName95       1115
#define IDS_ERRSetPhoneNumber         1116
#define IDS_ERRWriteDNS               1119
#define IDS_ERRUninstallMSN           1120
#define IDS_ERREnumModem              1121
#define IDS_ERRConfigureProxy         1123
#define IDS_ERRLoadConfigDll1         1124
#define IDS_ERRLoadConfigDll2         1125
#define IDS_ERRCorruptConnection      1126
#define IDS_ERRCorruptAccount         1127
#define IDS_ERRDuplicateConnectoidName  1128

#define IDS_ERRNoDialOutModem         1134
#define IDS_ERRModifyCSLIP            1135
#define IDS_ERRProxyRequired        1136
#define IDS_ERRLoadConfigDllNT1       1137
#define IDS_ERRLoadConfigDllNT2       1138
#define IDS_ERRConnectoidNameNT       1139



#define IDS_WARN_EMPTY_USERNAME       1200
#define IDS_WARN_EMPTY_DNS            1201
#define IDS_WARN_EMPTY_PASSWORD       1203
#define IDS_WARN_SERVER_BOUND         1205
#define IDS_WARN_SERVER_BOUND1        1207
#define IDS_REMOVE_SERVER_BOUND       1208
#define IDS_REMOVE_SERVER_BOUND1      1209

#define IDS_WARNWillRemoveMSN         1221

#define IDS_OKTOCHANGECONFIG          1230
#define IDS_ABOUTTOCHANGECONFIG1      1231
#define IDS_ABOUTTOCHANGECONFIG2      1232
#define IDS_DEF_CONNECTION_NAME_1     1233
#define IDS_DEF_CONNECTION_NAME_2     1234
#define IDS_SYSTEM_ALREADY_CONFIGURED 1235
#define IDS_CONFIGAPIFAILED           1236
#define IDS_SERVICEDISABLED           1237

#define IDS_NEED_PHONENUMBER          1250
#define IDS_NEED_IPADDR               1251
#define IDS_NEED_ISPNAME              1252
#define IDS_NEED_PROFILENAME          1253
#define IDS_NEED_AREACODE             1254
#define IDS_DUPLICATE_PROFILENAME     1255

#define IDS_INVALID_PORTNUM           1260
#define IDS_INVALIDPHONE              1262


#define IDS_INVALID_IPADDR            1300
#define IDS_INSTALLING_FILES          1303

#define IDS_MODIFYCONNECTION          1320

// Normandy 11970 ChrisK - we need a different title if launched from
// mail or news configuration
#define IDS_BEGINMANUAL_ALTERNATE     1323

#define IDS_LOGINSCRIPTINVALID        1324

#define IDS_HOWTOCONNECT_DESC1        1400
#define IDS_HOWTOCONNECT_DESC2        1401
#define IDS_CONNECTION_DESC1          1402
#define IDS_CONNECTION_DESC2          1403


#define IDS_WANTTOREBOOT              1430

#define IDS_WAITCHECKING              1431
#define IDS_WAITCONNECT               1432

#define IDS_MODEM_WIZ_TITLE           1433
#define IDS_MODEM_CPL_TITLE           1434

#define IDS_SBCSONLY                  1435

#define IDS_CONNECTIONTO                  1436

#define IDS_RNAAP_TITLE             1437

#define IDS_CHOOSEMODEM_TITLE           1452
#define IDS_CONNECTION_TITLE            1453
#define IDS_MODIFYCONNECTION_TITLE      1454
#define IDS_CONNECTIONNAME_TITLE        1455
#define IDS_PHONENUMBER_TITLE           1456
#define IDS_NAMEANDPASSWORD_TITLE       1457   
#define IDS_ADVANCED_TITLE              1458   
#define IDS_CONNECTIONPROTOCOL_TITLE    1459
#define IDS_LOGINSCRIPT_TITLE           1460
#define IDS_USEPROXY_TITLE              1461
#define IDS_PROXYSERVERS_TITLE          1462
#define IDS_PROXYEXCEPTIONS_TITLE       1463
#define IDS_IPADDRESS_TITLE             1464
#define IDS_DNSADDRESS_TITLE            1465
#define IDS_LCPEXTENSIONS_TITLE         1467
#define IDS_HOWTOCONNECT_TITLE          1468
#define IDS_CONNECTEDOK_TITLE           1469
#define IDS_SETUP_PROXY_TITLE           1470
#define IDS_WIZ97_TITLE_FONT_FACE       1471
#define IDS_LAN_INETCFG_TITLE           1472
#define IDS_CONNECTION                  1473
#define IDS_ADDRESS                     1474
#define IDS_ADVANCE_PROPERTIES          1475
#define IDS_USEDIALRULES                1476
#define IDS_ADMIN_ACCESS_DENIED         1477
#define IDS_ADMIN_ACCESS_DENIED_TITLE   1478

// dialog page IDs
#define IDD_PAGE_HOWTOCONNECT               2001
#define IDD_PAGE_CHOOSEMODEM                2002
#define IDD_PAGE_CONNECTEDOK                2003
#define IDD_PAGE_CONNECTION                 2004
#define IDD_PAGE_CONNECTIONNAME             2005
#define IDD_PAGE_MODIFYCONNECTION           2006
#define IDD_PAGE_ADVANCED                   2007
#define IDD_PAGE_PHONENUMBER                2008
#define IDD_PAGE_NAMEANDPASSWORD            2009
#define IDD_PAGE_CONNECTIONPROTOCOL         2010
#define IDD_PAGE_LOGINSCRIPT                2011
#define IDD_PAGE_USEPROXY                   2012
#define IDD_PAGE_PROXYSERVERS               2013
#define IDD_PAGE_PROXYEXCEPTIONS            2014
#define IDD_PAGE_IPADDRESS                  2015
#define IDD_PAGE_DNSADDRESS                 2016
#define IDD_PAGE_SETUP_PROXY                2018

#define IDD_PAGE_HOWTOCONNECT97             2030
#define IDD_PAGE_CHOOSEMODEM97              2031
#define IDD_PAGE_CONNECTEDOK97              2032
#define IDD_PAGE_CONNECTION97               2033
#define IDD_PAGE_MODIFYCONNECTION97         2034
#define IDD_PAGE_CONNECTIONNAME97           2035
#define IDD_PAGE_PHONENUMBER97              2036
#define IDD_PAGE_NAMEANDPASSWORD97          2037
#define IDD_PAGE_USEPROXY97                 2043
#define IDD_PAGE_PROXYSERVERS97             2044
#define IDD_PAGE_PROXYEXCEPTIONS97          2045
#define IDD_PAGE_HOWTOCONNECT97FIRSTLAST    2047
#define IDD_PAGE_CONNECTEDOK97FIRSTLAST     2048
#define IDD_PAGE_SETUP_PROXY97              2049
#define IDD_ADVANCE_MANUAL                  2050
#define IDD_ADVANCE_TAB_CONN                2052
#define IDD_ADVANCE_TAB_ADDR                2053

#define IDD_NEWPROFILENAME            2020
#define IDD_SECURITY_CHECK            2021
#define IDD_DNS_WARNING               2022
#define IDD_NEEDDRIVERS               2023
#define IDD_CHOOSEMODEMNAME           2024
#define IDD_CHOOSEPROFILENAME         2025

#define IDS_MAPIERROR_BASE            3000

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_UNUSED                    -1
#define IDC_BMPFRAME                  2100
#define IDC_CONNECT_BY_PHONE          2102
#define IDC_CONNECT_BY_LAN            2103
#define IDC_CONNECT_MANUAL            2104
#define IDC_AREACODE                  2108
#define IDC_PHONENUMBER               2109
#define IDC_USERNAME                  2110
#define IDC_PASSWORD                  2111
#define IDC_CONFIRMPASSWORD           2112
#define IDC_MODIFYCONNECTION          2113
#define IDC_NOMODIFYCONNECTION        2114
#define IDC_CONNECTIONNAME            2115
#define IDC_NEWCONNECTION             2116
#define IDC_EXISTINGCONNECTION        2117
#define IDC_LBLMODIFYCONNECTION       2118
#define IDC_MODIFYADVANCED            2119
#define IDC_NOMODIFYADVANCED          2120
#define IDC_ISPNAME                   2121
#define IDC_USE_DHCP                  2123
#define IDC_USE_IP                    2124
#define IDC_IPADDR                    2125
#define IDC_DNSADDR1                  2127
#define IDC_DNSADDR2                  2128
#define IDC_TX_IPADDR                 2129
#define IDC_AUTO_DNS                  2130
#define IDC_STATIC_DNS                2131
#define IDC_TX_DNSADDR1               2132
#define IDC_TX_DNSADDR2               2133
#define IDC_COUNTRYCODE               2136
#define IDC_MODEM                     2137
#define IDC_TX_STATUS                 2143
#define IDC_SETDEFAULT                2149
#define IDC_NEW_PROFILE               2150
#define IDC_PROFILE_LIST              2151
#define IDC_PROFILENAME               2152
#define IDC_DISABLE_CHECK             2153
#define IDC_GRP_SETTINGS              2154
#define IDC_HELP                      2155
#define IDC_DISABLE_WARNING           2156
#define IDC_USEDIALRULES              2157
#define IDC_PROTOCOLPPP               2158
#define IDC_PROTOCOLSLIP              2159
#define IDC_PROTOCOLCSLIP             2160
#define IDC_NOTERMINALAFTERDIAL       2161
#define IDC_TERMINALAFTERDIAL         2162
#define IDC_SCRIPT                    2163
#define IDC_BROWSE                    2164
#define IDC_SCRIPTFILE                2170
#define IDC_TX_PROXYBYPASS            2178
#define IDC_TX_PROXYSERVER            2179
#define IDC_TX_AREACODE               2180
#define IDC_TX_COUNTRYCODE            2181
#define IDC_TX_SEPARATOR              2182
#define IDC_LBLTITLE                  2183

#define IDC_TX_ACCOUNT                2198
#define IDC_TX_PASSWORD               2199

#define IDC_USEPROXY                  2200
#define IDC_NOUSEPROXY                2201
#define IDC_TX_PROXYTYPE              2202
#define IDC_TX_PROXYADDRESS           2203
#define IDC_TX_PROXYPORT              2204
#define IDC_TX_PROXYHTTP              2205
#define IDC_PROXYHTTP                 2206
#define IDC_PORTHTTP                  2207
#define IDC_TX_PROXYSECURE            2208
#define IDC_PROXYSECURE               2209
#define IDC_PORTSECURE                2210
#define IDC_TX_PROXYFTP               2211
#define IDC_PROXYFTP                  2212
#define IDC_PORTFTP                   2213
#define IDC_TX_PROXYGOPHER            2214
#define IDC_PROXYGOPHER               2215
#define IDC_PORTGOPHER                2216
#define IDC_TX_PROXYSOCKS             2217
#define IDC_PROXYSOCKS                2218
#define IDC_PORTSOCKS                 2219
#define IDC_PROXYSAME                 2220
#define IDC_TX_BYPASSPROXY            2222
#define IDC_BYPASSPROXY               2223
#define IDC_TX_USESEMICOLON           2224
#define IDC_BYPASSLOCAL               2225

#define IDC_INCOMINGMAILTYPE          2226

#define IDC_NEWACCT                   2230
#define IDC_EXISTINGACCT              2231
#define IDC_ACCTNAME                  2232
#define IDC_ACCTLIST                  2233
#define IDC_LBLMODIFYACCT             2234
#define IDC_MODIFYACCT                2235
#define IDC_NOMODIFYACCT              2236

#define IDC_CANCEL                    2240
#define IDC_DISABLELCP                2241
#define IDC_NODISABLELCP              2242

#define IDC_DESC                      2250
#define IDC_LOGONPLAIN                2252
#define IDC_LOGONSICILY               2253
#define IDC_LBLUSERNAME               2254
#define IDC_LBLPASSWORD               2255

#define IDC_NOTE                      2258
#define IDC_CONFIGSCRIPT              2259
#define IDC_MANUAL_PROXY              2260
#define IDC_CONFIG_ADDR               2261
#define IDC_AUTODISCOVER              2262
#define IDC_CONFIGADDR_TX             2263
#define IDC_GRP_AUTO                  2264
#define IDC_SCRIPT_LABEL              2266
#define IDC_DNS_USE_FOLLOW            2267
#define IDC_PRIM_LABEL                2268
#define IDC_SEC_LABEL                 2269
#define IDC_IP_ADDR_LABEL             2270

///fix for dup ids start at 4000
#define IDC_CONNECTEDOK97FIRSTLAST_TEXT1   4000
#define IDC_CONNECTEDOK97FIRSTLAST_TEXT2   4001
#define IDC_CONNECTEDOK97FIRSTLAST_TEXT3   4002
#define IDC_CONNECTIONNAME97_TEXT1         4003
#define IDC_CONNECTIONNAME97_TEXT2         4004
#define IDC_LBLCONNECTIONNAME              4005
#define IDC_PHONENUMBER97_TEXT1            4006
#define IDC_LBLPHONENUMBER                 4007
#define IDC_NAMEANDPASSWORD97_TEXT1        4008
#define IDC_NAMEANDPASSWORD97_TEXT2        4009
#define IDC_LOGINSCRIPT97_TEXT1            4010
#define IDC_LOGINSCRIPT97_TEXT2            4011
#define IDC_PROXYSERVERS97_TEXT1           4012
#define IDC_PROXYSERVERS97_TEXT2           4013
#define IDC_PROXYSERVERS97_TEXT3           4014
#define IDC_PROXYSERVERS97_TEXT4           4015
#define IDC_PROXYSERVERS97_TEXT5           4016
#define IDC_NEWPROFILENAME_TEXT1           4017
#define IDC_NEWPROFILENAME_TEXT2           4018
#define IDC_SECURITY_CHECK_TEXT1           4019
#define IDC_SECURITY_CHECK_TEXT2           4020
#define IDC_SECURITY_CHECK_TEXT3           4021
#define IDC_DNS_WARNING_TEXT1              4022
#define IDC_DNS_WARNING_TEXT2              4023
#define IDC_DNS_WARNING_TEXT3              4024
#define IDC_CONNECTEDOK97_TEXT1            4025 
#define IDC_CONNECTEDOK97_TEXT2            4026
#define IDC_CONNECTEDOK97_TEXT3            4027
#define IDC_CONNECTIONNAME_TEXT1           4025
#define IDC_CONNECTIONNAME_TEXT2           4026
#define IDC_CONNECTIONNAME_TEXT3           4027
#define IDC_CONNECTEDOK_TEXT1              4028
#define IDC_CONNECTEDOK_TEXT2              4029
#define IDC_CONNECTEDOK_TEXT3              4030
#define IDC_CHOOSEMODEM97_TEXT1            4031
#define IDC_CHOOSEMODEM97_TEXT2            4032
#define IDC_CHOOSEMODEM_TEXT1              4033
#define IDC_CHOOSEMODEM_TEXT2              4034
#define IDC_PHONENUMBER_TEXT1              4035
#define IDC_PHONENUMBER_TEXT2              4036
#define IDC_NAMEANDPASSWORD97_TEXT3        4037
#define IDC_NAMEANDPASSWORD_TEXT1          4038
#define IDC_NAMEANDPASSWORD_TEXT2          4039
#define IDC_NAMEANDPASSWORD_TEXT3          4040
#define IDC_PROXYSERVERS_TEXT1             4041
#define IDC_PROXYSERVERS_TEXT2             4042
#define IDC_PROXYSERVERS_TEXT3             4043
#define IDC_PROXYSERVERS_TEXT4             4044
#define IDC_PROXYSERVERS_TEXT5             4045
#define IDC_CHOOSEMODEMNAME_TEXT1          4046
#define IDC_CHOOSEMODEMNAME_TEXT2          4047
#define IDC_LOGINSCRIPT_TEXT1              4048
#define IDC_LOGINSCRIPT_TEXT2              4049
#define IDC_AUTODISCOVERY_TEXT             4050
#define IDS_SETUP_PROXY_INTRO              4051

// bitmap IDs
#define IDB_WATERMARK256                2290
#define IDB_WATERMARK16                 2291
#define IDB_BANNER256                   2292
#define IDB_BANNER16                    2293
#define IDB_BMP_WELCOME                 2294


// icon IDs
#define IDI_WORLD                     2300
#define IDI_MODEM                     2303

// Wait dialog constants
#define IDC_LBLWAITCFG                2375
#define IDA_WAITINGCONFIG             2376
#define IDD_CONFIGWAIT                2377
#define IDC_ANIMATE                   2378
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\icwextsn.cpp ===
/****************************************************************************
 *
 *	ICWESTSN.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) Microsoft Corporation 1992-1997
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the CICWExtension class.
 *
 *	4/24/97	jmazner	Created
 *
 ***************************************************************************/

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

// in propmgr.cpp
extern BOOL DialogIDAlreadyInUse( UINT uDlgID );
extern BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

/*** Class definition, for reference only ***
  (actual definition is in icwextsn.h)

  class CICWExtension : public IICWExtension
{
	public:
		virtual BOOL	STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID);
		virtual BOOL	STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type);
		virtual BOOL	STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID);

		virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
		virtual ULONG	STDMETHODCALLTYPE AddRef( void );
		virtual ULONG	STDMETHODCALLTYPE Release( void );

		HWND m_hWizardHWND;

	private:
		LONG	m_lRefCount;
};
****/

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::AddExternalPage
//
//	Synopsis	Adds a page created via CreatePropertySheetPage to the main
//				property sheet/wizard.
//
//
//	Arguments	hPage -- page handle returned from CreatePropertySheetPage
//				uDlgID -- the dialog ID of the page to be added, as defined
//						  the resource file of the page's owner.
//
//
//	Returns		FALSE is the dlgID is already in use in the Wizard
//				TRUE otherwise
//
//	Notes:		PropSheet_AddPage does not return a usefull error code.  Thus
//				the assumption here is that every AddPage will succeed.  But, even
//				though it is not enforced by PropSheet_AddPage, every page in the
//				PropSheet must have a unique dialog ID.  Thus, if the uDlgID passed
//				in has previously been added to the PropSheet, we'll return FALSE.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::AddExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
	LRESULT lResult= 0;

	if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: uDlgID %d is out of range!", uDlgID);
		return( FALSE );
	}

	if( !DialogIDAlreadyInUse(uDlgID) )
	{

		SetDialogIDInUse( uDlgID, TRUE );
		lResult = PropSheet_AddPage(m_hWizardHWND, hPage);
		DEBUGMSG("propmgr: PS_AddPage DlgID %d", uDlgID);

		return(TRUE);
	}
	else
	{
		DEBUGMSG("AddExternalPage DlgID %d is already in use, rejecting this page!", uDlgID);
		return(FALSE);
	}
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::RemoveExternalPage
//
//	Synopsis	Removes a page added via ::AddExternalPage to the main
//				property sheet/wizard.
//
//
//	Arguments	hPage -- page handle returned from CreatePropertySheetPage
//				uDlgID -- the dialog ID of the page to be removed, as defined
//						  the resource file of the page's owner.
//
//
//	Returns		FALSE is the dlgID is not already in use in the Wizard
//				TRUE otherwise
//
//	Notes:		PropSheet_RemovePage does not return a usefull error code.  Thus
//				the assumption here is that every RemovePage will succeed if that
//				dialog id is currently in the property sheet
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::RemoveExternalPage( HPROPSHEETPAGE hPage, UINT uDlgID )
{
	if ( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: uDlgID %d is out of range!", uDlgID);
		return( FALSE );
	}

	if( DialogIDAlreadyInUse(uDlgID) )
	{
		SetDialogIDInUse( uDlgID, FALSE );
		PropSheet_RemovePage(m_hWizardHWND, NULL, hPage);
		DEBUGMSG("propmgr: PS_RemovePage DlgID %d", uDlgID);

		return(TRUE);
	}
	else
	{
		DEBUGMSG("RemoveExternalPage: DlgID %d was not marked as in use!", uDlgID);
		return(FALSE);
	}
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::ExternalCancel
//
//	Synopsis	Notifies the wizard that the user has cancelled while in the
//				apprentice pages
//
//
//	Arguments	uCancelType -- tells the wizard whether it should immediately
//								quit out, or whether it should show the confirmation
//								dialog (as though the user had hit Cancel within the
//								wizard itself.)
//
//
//	Returns		TRUE if we're about to exit the wizard
//				FALSE if not.
//
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::ExternalCancel( CANCELTYPE uCancelType )
{
	DEBUGMSG("propmgr.cpp: received ExternalCancel callback");
	switch( uCancelType )
	{
		case CANCEL_PROMPT:
			gfUserCancelled = (MsgBox(m_hWizardHWND,IDS_QUERYCANCEL,
							MB_ICONQUESTION,MB_YESNO |
							MB_DEFBUTTON2) == IDYES);
	
			if( gfUserCancelled )
			{
				PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
				gfQuitWizard = TRUE;
				return( TRUE );
			}
			else
			{
				return( FALSE );
			}
			break;

		case CANCEL_SILENT:
			PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
			gfQuitWizard = TRUE;
			return( TRUE );
			break;

		case CANCEL_REBOOT:
			PropSheet_PressButton( m_hWizardHWND, PSBTN_CANCEL );
			gfQuitWizard = TRUE;
			gpWizardState->fNeedReboot = TRUE;
			return( TRUE );
			break;

		default:
			DEBUGMSG("ExternalCancel got an unkown CancelType!");
			return( FALSE );
	}
	
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::SetFirstLastPage
//
//	Synopsis	Lets the apprentice notify the wizard of the dialog IDs of the
//				first and last pages in the apprentice
//
//
//	Arguments	uFirstPageDlgID -- DlgID of first page in apprentice.
//				uLastPageDlgID -- DlgID of last page in apprentice
//
//
//	Returns		FALSE if the parameters passed in are out of range
//				TRUE if the update succeeded.
//
//	Notes:		If either variable is set to 0, the function will not update
//				that information, i.e. a value of 0 means "ignore me".  If both
//				variables are 0, the function immediately returns FALSE.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
BOOL CICWExtension::SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID)
{

	// validation code galore!
	if( (0 == uFirstPageDlgID) && (0 == uLastPageDlgID) )
	{
		DEBUGMSG("SetFirstLastPage: both IDs are 0!");
		return( FALSE );
	}

	if( (0 != uFirstPageDlgID) )
	{
		if ( (uFirstPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uFirstPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uFirstPageDlgID %d is out of range!", uFirstPageDlgID);
			return( FALSE );
		}

		if( !DialogIDAlreadyInUse(uFirstPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uFirstPageDlgID %d not marked as in use!", uFirstPageDlgID);
			return( FALSE );
		}
	}

	if( (0 != uLastPageDlgID) )
	{
		if ( (uLastPageDlgID < EXTERNAL_DIALOGID_MINIMUM) || (EXTERNAL_DIALOGID_MAXIMUM < uLastPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uLastPageDlgID %d is out of range!", uFirstPageDlgID);
			return( FALSE );
		}

		if( !DialogIDAlreadyInUse(uLastPageDlgID) )
		{
			DEBUGMSG("SetFirstLastPage: uLastPageDlgID %d not marked as in use!", uFirstPageDlgID);
			return( FALSE );
		}
	}
	
	if( 0 != uFirstPageDlgID )
		g_uAcctMgrUIFirst = uFirstPageDlgID;
	if( 0 != uLastPageDlgID )
		g_uAcctMgrUILast = uLastPageDlgID;
	DEBUGMSG("SetFirstLastPage: updating mail, first = %d, last = %d",
		uFirstPageDlgID, uLastPageDlgID);

	return TRUE;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::QueryInterface
//
//	Synopsis	This is the standard QI, with support for
//				IID_Unknown, IICW_Extension and IID_ICWApprentice
//				(Taken from Inside COM, chapter 7)
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
HRESULT CICWExtension::QueryInterface( REFIID riid, void** ppv )
{

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	// IID_IICWApprentice
	if (IID_IICWApprentice == riid)
		*ppv = (void *)(IICWApprentice *)this;
	// IID_IICWApprenticeEx
	else if (IID_IICWApprenticeEx == riid)
		*ppv = (void *)(IICWApprenticeEx *)this;
    // IID_IICWExtension
    else if (IID_IICWExtension == riid)
        *ppv = (void *)(IICWExtension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
		*ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::AddRef
//
//	Synopsis	This is the standard AddRef
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::AddRef( void )
{
	DEBUGMSG("CICWExtension::AddRef called %d", m_lRefCount + 1);

	return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::Release
//
//	Synopsis	This is the standard Release
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
ULONG CICWExtension::Release( void )
{

	ASSERT( m_lRefCount > 0 );

	InterlockedDecrement(&m_lRefCount);

	DEBUGMSG("CICWExtension::Release called %d", m_lRefCount);

	if( 0 == m_lRefCount )
	{
		delete( this );
		return( 0 );
	}
	else
	{
		return( m_lRefCount );
	}
	
}


//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::CICWExtension
//
//	Synopsis	The constructor.  Initializes member variables to NULL.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWExtension::CICWExtension( void )
{
	DEBUGMSG("CICWExtension constructor called");
	m_lRefCount = 0;
	m_hWizardHWND = NULL;
}


//+----------------------------------------------------------------------------
//
//	Function	CICWExtension::CICWExtension
//
//	Synopsis	The constructor.  Since there was no fancy initialization,
//				there's nothing to do here.
//
//	History		4/23/97	jmazner		created
//
//-----------------------------------------------------------------------------
CICWExtension::~CICWExtension( void )
{
	DEBUGMSG("CICWExtension destructor called with ref count of %d", m_lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\ienews.cpp ===
//****************************************************************************
//
//  Module:     INETCFG.DLL
//  File:       ienews.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          this code started its life as ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

#include "wizard.h"
#include "inetcfg.h"
extern "C" {
#include <netmpr.h>
}


#pragma data_seg(".rdata")

#define REGSTR_PATH_IE_SERVICES         REGSTR_PATH_IEXPLORER TEXT("\\Services")

static const TCHAR cszRegPathIEServices[] =      REGSTR_PATH_IE_SERVICES;
static const TCHAR cszRegValNNTPEnabled[] =      TEXT("NNTP_Enabled");
static const TCHAR cszRegValNNTPUseAuth[] =      TEXT("NNTP_Use_Auth");
static const TCHAR cszRegValNNTPServer[] =       TEXT("NNTP_Server");
static const TCHAR cszRegValNNTPMailName[] =     TEXT("NNTP_MailName");
static const TCHAR cszRegValNNTPMailAddress[] =  TEXT("NNTP_MailAddr");
static const TCHAR cszYes[] = TEXT("yes");
static const TCHAR cszNo[] = TEXT("no");

#pragma data_seg()

#define PCE_WWW_BASIC 0x13
TCHAR szNNTP_Resource[] = TEXT("NNTP");
typedef DWORD (APIENTRY *PFNWNETGETCACHEDPASSWORD)(LPTSTR,WORD,LPTSTR,LPWORD,BYTE);

DWORD MyWNetGetCachedPassword(LPTSTR pbResource,WORD cbResource,LPTSTR pbPassword,
    LPWORD pcbPassword,BYTE   nType)
{
	HINSTANCE hInst = NULL;
	FARPROC fp = NULL;
	DWORD dwRet = 0;
	
	hInst = LoadLibrary(TEXT("MPR.DLL"));
	if (hInst)
	{
		fp = GetProcAddress(hInst,"WNetGetCachedPassword");
		if (fp)
			dwRet = ((PFNWNETGETCACHEDPASSWORD)fp) (pbResource, cbResource, pbPassword, pcbPassword, nType);
		else
			dwRet = GetLastError();
		FreeLibrary(hInst);
		hInst = NULL;
	} else {
		dwRet = GetLastError();
	}
	return dwRet;
}


BOOL
GetAuthInfo( TCHAR *szUsername, int cbUser, TCHAR *szPassword, int cbPass )
{
    int     wnet_status;
    TCHAR   szUserInfo[256];
    WORD    cbUserInfo = sizeof(szUserInfo);
    TCHAR   *p;

    if (cbUser && szUsername)
        *szUsername = '\0';
    if (cbPass && szPassword)
        *szPassword = '\0';

    wnet_status = MyWNetGetCachedPassword (szNNTP_Resource, sizeof(szNNTP_Resource) - 1, szUserInfo, &cbUserInfo, PCE_WWW_BASIC);
    switch (wnet_status)  {
        case WN_NOT_SUPPORTED:
            return( FALSE );    // Cache not enabled
            break;
        case WN_CANCEL:
            return( TRUE );     // Cache enabled but no password set
            break;
        case WN_SUCCESS:
            p = _tcschr(szUserInfo,':');
            if (p)  {
                *p = 0;
                lstrcpyn(szUsername, szUserInfo, cbUser - 1);
                szUserInfo[cbUser - 1] = '\0';
                lstrcpyn(szPassword, p+1, cbPass - 1);
                szPassword[cbPass - 1] = '\0';
            }
            return( TRUE );
            break;
        default:
////            XX_Assert((0),("Unexpected Return from WNetGetCachedPassword: %d", wnet_status ));
            return( FALSE );
    }

    /*NOTREACHED*/
    return(FALSE);
}

typedef DWORD (APIENTRY *PFNWNETCACHEPASSWORD)(LPTSTR,WORD,LPTSTR,WORD,BYTE,UINT);

DWORD MyWNetCachePassword(
    LPTSTR pbResource,
    WORD   cbResource,
    LPTSTR pbPassword,
    WORD   cbPassword,
    BYTE   nType,
    UINT   fnFlags
    )
{
	HINSTANCE hInst = NULL;
	FARPROC fp = NULL;
	DWORD dwRet = 0;
	hInst = LoadLibrary(TEXT("MPR.DLL"));
	if (hInst)
	{
		fp = GetProcAddress(hInst,"WNetCachePassword");
		if (fp)
			dwRet = ((PFNWNETCACHEPASSWORD)fp)(pbResource,cbResource,pbPassword,cbPassword,nType,fnFlags);
		else
			dwRet = GetLastError();
		FreeLibrary(hInst);
		hInst = NULL;
		fp = NULL;
	} else {
		dwRet = GetLastError();
	}
	return dwRet;
}


BOOL
SetAuthInfo( TCHAR *szUsername,  TCHAR *szPassword)
{
    int     wnet_status;
    TCHAR   szUserInfo[256];
    WORD    cbUserInfo = sizeof(szUserInfo);

    if (_tcschr(szUsername, ':'))  {
////        XX_Assert((0),("SetAuthInfo(): Username has ':' in it!: %s", szUsername ));
        return(FALSE);
    }

    lstrcpy( szUserInfo, szUsername );
    lstrcat( szUserInfo, TEXT(":") );
    lstrcat( szUserInfo, szPassword );

     wnet_status = MyWNetCachePassword (szNNTP_Resource, sizeof(szNNTP_Resource) - 1, szUserInfo, (USHORT)lstrlen( szUserInfo ), PCE_WWW_BASIC, 0);

    return( wnet_status == WN_SUCCESS );
}

DWORD SetIEClientInfo(LPINETCLIENTINFO lpClientInfo)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;

    dwRet = RegCreateKey(HKEY_CURRENT_USER, cszRegPathIEServices, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    dwSize = max(sizeof(cszYes), sizeof(cszNo));
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPEnabled,
            0L,
            dwType,
            (LPBYTE)(*lpClientInfo->szNNTPServer ? cszYes : cszNo),
            dwSize);

    dwSize = max(sizeof(cszYes), sizeof(cszNo));
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPUseAuth,
            0L,
            dwType,
            (LPBYTE)((lpClientInfo->dwFlags & INETC_LOGONNEWS) ? cszYes : cszNo),
            dwSize);


    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPMailName,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPMailAddress,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            dwSize);


    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            dwSize);

    RegCloseKey(hKey);

    SetAuthInfo(lpClientInfo->szNNTPLogonName,  lpClientInfo->szNNTPLogonPassword);
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\imnact.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Mar 27 05:46:37 1997
 */
/* Compiler settings for imnact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imnact_h__
#define __imnact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IImnAdviseAccount_FWD_DEFINED__
#define __IImnAdviseAccount_FWD_DEFINED__
typedef interface IImnAdviseAccount IImnAdviseAccount;
#endif 	/* __IImnAdviseAccount_FWD_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_FWD_DEFINED__
#define __IImnAdviseMigrateServer_FWD_DEFINED__
typedef interface IImnAdviseMigrateServer IImnAdviseMigrateServer;
#endif 	/* __IImnAdviseMigrateServer_FWD_DEFINED__ */


#ifndef __IImnEnumAccounts_FWD_DEFINED__
#define __IImnEnumAccounts_FWD_DEFINED__
typedef interface IImnEnumAccounts IImnEnumAccounts;
#endif 	/* __IImnEnumAccounts_FWD_DEFINED__ */


#ifndef __IImnAccountManager_FWD_DEFINED__
#define __IImnAccountManager_FWD_DEFINED__
typedef interface IImnAccountManager IImnAccountManager;
#endif 	/* __IImnAccountManager_FWD_DEFINED__ */


#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


#ifndef __IImnAccount_FWD_DEFINED__
#define __IImnAccount_FWD_DEFINED__
typedef interface IImnAccount IImnAccount;
#endif 	/* __IImnAccount_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 



//=--------------------------------------------------------------------------=
// Imnact.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Mail and News Account Manager Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {8D4B04E1-1331-11d0-81B8-00C04FD85AB4}
DEFINE_GUID(CLSID_ImnAccountManager, 0x8d4b04e1, 0x1331, 0x11d0, 0x81, 0xb8, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465481-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccountManager, 0xfd465481, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465482-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccount, 0xfd465482, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465483-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnEnumAccounts, 0xfd465483, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {8D0AED11-1638-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseMigrateServer, 0x8d0aed11, 0x1638, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0A06BD31-166F-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseAccount, 0xa06bd31, 0x166f, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Exported C Functions
// --------------------------------------------------------------------------------
#if !defined(_IMNACCT_)
#define IMNACCTAPI DECLSPEC_IMPORT HRESULT WINAPI
#else
#define IMNACCTAPI HRESULT WINAPI
#endif
#ifdef __cplusplus
extern "C" {
#endif

IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager);
#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(0xCD00)
#define E_RegQueryInfoKeyFailed      HR_E(0xCD01)
#define E_UserCancel                 HR_E(0xCD02)
#define E_RegOpenKeyFailed           HR_E(0xCD03)
#define E_RegSetValueFailed          HR_E(0xCD04)
#define E_RegDeleteKeyFailed         HR_E(0xCD05)
#define E_DuplicateAccountName       HR_E(0xCD06)
#define S_NonStandardValue           HR_S(0xCD07)
#define E_InvalidValue               HR_E(0xCD08)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(0xCDA0)
#define E_BufferTooSmall             HR_E(0xCDA1)
#define E_BadPropType                HR_E(0xCDA2)
#define E_BufferSizeMismatch         HR_E(0xCDA3)
#define E_InvalidBooleanValue        HR_E(0xCDA4)
#define E_InvalidMinMaxValue         HR_E(0xCDA5)
#define E_PropNotFound               HR_E(0xCDA6)
#define E_InvalidPropTag             HR_E(0xCDA7)
#define E_InvalidPropertySet         HR_E(0xCDA8)
#define E_EnumFinished               HR_E(0xCDA9)
#define S_NoSaveNeeded               HR_S(0xCDAA)
#define S_PasswordDeleted            HR_S(0xCDAB)
#define S_PasswordNotFound           HR_S(0xCDAC)

// --------------------------------------------------------------------------------
// ImnAccountManager errors
// --------------------------------------------------------------------------------
#define E_NoAccounts                 HR_E(0xCDD0)
#define E_BadFriendlyName            HR_E(0xCDD1)

// --------------------------------------------------------------------------------
// RAS Connection Types
// --------------------------------------------------------------------------------
#define CF_MAIL_DISCONNECT       FLAG01 // Disconnect after send and recv
#define CF_AUTO_CONNECT          FLAG02 // Automatically connect

// --------------------------------------------------------------------------------
// Property Macros
// --------------------------------------------------------------------------------
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)	    (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)

// --------------------------------------------------------------------------------
// IImnAccount Properties
// --------------------------------------------------------------------------------
#define AP_FIRST                    0X1234
// per account properties
#define AP_ACCOUNT_NAME             PROPTAG(TYPE_STRING,    AP_FIRST+1)
#define AP_ACCOUNT_FIRST            AP_ACCOUNT_NAME
#define AP_TEMP_ACCOUNT             PROPTAG(TYPE_DWORD,     AP_FIRST+3)
#define AP_LAST_UPDATED             PROPTAG(TYPE_FILETIME,  AP_FIRST+4)
#define AP_RAS_CONNECTION_TYPE      PROPTAG(TYPE_DWORD,     AP_FIRST+5)
#define AP_RAS_CONNECTOID           PROPTAG(TYPE_STRING,    AP_FIRST+6)
#define AP_RAS_CONNECTION_FLAGS     PROPTAG(TYPE_DWORD,     AP_FIRST+7)
#define AP_RAS_CONNECTED            PROPTAG(TYPE_BOOL,      AP_FIRST+8)
#define AP_ACCOUNT_LAST             AP_RAS_CONNECTED

// IMAP properties
#define AP_IMAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+100)
#define AP_IMAP_FIRST               AP_IMAP_SERVER
#define AP_IMAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+101)
#define AP_IMAP_PASSWORD            PROPTAG(TYPE_PASS,     AP_FIRST+102)
#define AP_IMAP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+104)
#define AP_IMAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+105)
#define AP_IMAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+106)
#define AP_IMAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+107)
#define AP_IMAP_ROOT_FOLDER         PROPTAG(TYPE_STRING,    AP_FIRST+108)
#define AP_IMAP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+109)
#define AP_IMAP_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+110)
#define AP_IMAP_LAST                AP_IMAP_SKIP

// LDAP properties
#define AP_LDAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+200)
#define AP_LDAP_FIRST               AP_LDAP_SERVER
#define AP_LDAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+201)
#define AP_LDAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+202)
#define AP_LDAP_AUTHENTICATION      PROPTAG(TYPE_DWORD,     AP_FIRST+203)
#define AP_LDAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+204)
#define AP_LDAP_SEARCH_RETURN       PROPTAG(TYPE_DWORD,     AP_FIRST+205)
#define AP_LDAP_SEARCH_BASE         PROPTAG(TYPE_STRING,    AP_FIRST+206)
#define AP_LDAP_SERVER_ID           PROPTAG(TYPE_DWORD,     AP_FIRST+207)
#define AP_LDAP_RESOLVE_FLAG        PROPTAG(TYPE_DWORD,     AP_FIRST+208)
#define AP_LDAP_URL                 PROPTAG(TYPE_STRING,    AP_FIRST+209)
#define AP_LDAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+210)
#define AP_LDAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+211)
#define AP_LDAP_LOGO                PROPTAG(TYPE_STRING,    AP_FIRST+212)
#define AP_LDAP_LAST                AP_LDAP_LOGO

// NNTP properties
#define AP_NNTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+300)
#define AP_NNTP_FIRST               AP_NNTP_SERVER
#define AP_NNTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+301)
#define AP_NNTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+302)
#define AP_NNTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+304)
#define AP_NNTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+305)
#define AP_NNTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+306)
#define AP_NNTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+307)
#define AP_NNTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+308)
#define AP_NNTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+309)
#define AP_NNTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+310)
#define AP_NNTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+311)
#define AP_NNTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+312)
#define AP_NNTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+313)
#define AP_NNTP_USE_DESCRIPTIONS    PROPTAG(TYPE_BOOL,      AP_FIRST+314)
#define AP_NNTP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+315)
#define AP_NNTP_LAST                AP_NNTP_DATA_DIR

// POP3 properties
#define AP_POP3_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+400)
#define AP_POP3_FIRST               AP_POP3_SERVER
#define AP_POP3_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+401)
#define AP_POP3_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+402)
#define AP_POP3_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+404)
#define AP_POP3_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+405)
#define AP_POP3_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+406)
#define AP_POP3_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+407)
#define AP_POP3_LEAVE_ON_SERVER     PROPTAG(TYPE_BOOL,      AP_FIRST+408)
#define AP_POP3_REMOVE_DELETED      PROPTAG(TYPE_BOOL,      AP_FIRST+409)
#define AP_POP3_REMOVE_EXPIRED      PROPTAG(TYPE_BOOL,      AP_FIRST+410)
#define AP_POP3_EXPIRE_DAYS         PROPTAG(TYPE_DWORD,     AP_FIRST+411)
#define AP_POP3_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+412)
#define AP_POP3_LAST                AP_POP3_SKIP

// SMTP properties
#define AP_SMTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+500)
#define AP_SMTP_FIRST               AP_SMTP_SERVER
#define AP_SMTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+501)
#define AP_SMTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+502)
#define AP_SMTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+504)
#define AP_SMTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+505)
#define AP_SMTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+506)
#define AP_SMTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+507)
#define AP_SMTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+508)
#define AP_SMTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+509)
#define AP_SMTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+510)
#define AP_SMTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+511)
#define AP_SMTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+512)
#define AP_SMTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+513)
#define AP_SMTP_LAST                AP_SMTP_SPLIT_SIZE

// --------------------------------------------------------------------------------
// Account Flags
// --------------------------------------------------------------------------------
#define ACCT_FLAG_NEWS           ((DWORD)1)
#define ACCT_FLAG_MAIL           ((DWORD)2)
#define ACCT_FLAG_DIR_SERV       ((DWORD)4)
#define ACCT_FLAG_ALL            (ACCT_FLAG_NEWS | ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV)

// --------------------------------------------------------------------------------
// Server Types
// --------------------------------------------------------------------------------
#define SRV_NNTP                 ((DWORD)1)
#define SRV_IMAP                 ((DWORD)2)
#define SRV_POP3                 ((DWORD)4)
#define SRV_SMTP                 ((DWORD)8)
#define SRV_LDAP                 ((DWORD)16)
#define SRV_MAIL                 ((DWORD)(SRV_IMAP | SRV_POP3 | SRV_SMTP))
#define SRV_ALL                  ((DWORD)(SRV_NNTP | SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_LDAP))

// --------------------------------------------------------------------------------
// LDAP Authentication Types
// --------------------------------------------------------------------------------
#define LDAP_AUTH_ANONYMOUS      ((DWORD)0)
#define LDAP_AUTH_PASSWORD       ((DWORD)1)
#define LDAP_AUTH_MEMBER_SYSTEM  ((DWORD)2)
#define LDAP_AUTH_MAX            ((DWORD)2)

// -----------------------------------------------------------------------------
// Account Manager Notification Types
// -----------------------------------------------------------------------------
#define AN_ACCOUNT_DELETED           WM_USER + 1
#define AN_ACCOUNT_ADDED             WM_USER + 2
#define AN_ACCOUNT_CHANGED           WM_USER + 3
#define AN_DEFAULT_CHANGED           WM_USER + 4
#define AN_SERVERTYPES_CHANGED       WM_USER + 5

// IImnAccountManager::AccountListDialog flags
// IImnAccount::ShowProperties flags
#define ACCTDLG_NO_IMAP          0x0001
#define ACCTDLG_NO_REMOVEDELETE  0x0002
#define ACCTDLG_NO_BREAKMESSAGES 0x0004
#define ACCTDLG_NO_REMOVEAFTER   0x0008
#define ACCTDLG_NO_SENDRECEIVE   0x0010
#define ACCTDLG_ALL              0x001f

// AP_RAS_CONNECTION_TYPE values
#define CONNECTION_TYPE_LAN      0
#define CONNECTION_TYPE_MANUAL   1
#define CONNECTION_TYPE_RAS      2

#define	CCHMAX_ORG_NAME	( 256 )

#define	CCHMAX_DISPLAY_NAME	( 256 )

#define	CCHMAX_ACCOUNT_NAME	( 256 )

#define	CCHMAX_SERVER_NAME	( 256 )

#define	CCHMAX_PASSWORD	( 256 )

#define	CCHMAX_USERNAME	( 256 )

#define	CCHMAX_EMAIL_ADDRESS	( 256 )

#define	CCHMAX_CONNECTOID	( 256 )

#define	CCHMAX_SEARCH_BASE	( 256 )



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IImnAdviseAccount_INTERFACE_DEFINED__
#define __IImnAdviseAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseAccount
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public][public][public][public][public][public][public] */ 
enum __MIDL_IImnAdviseAccount_0001
    {	ACCT_NEWS	= 0,
	ACCT_MAIL	= ACCT_NEWS + 1,
	ACCT_DIR_SERV	= ACCT_MAIL + 1,
	ACCT_LAST	= ACCT_DIR_SERV + 1
    }	ACCTTYPE;


EXTERN_C const IID IID_IImnAdviseAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAdviseAccount : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseAccount( 
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACCTTYPE AcctType,
            /* [in] */ LPTSTR pszAccountNameBefore,
            /* [in] */ LPTSTR pszAccountNameAfter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseAccount )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACCTTYPE AcctType,
            /* [in] */ LPTSTR pszAccountNameBefore,
            /* [in] */ LPTSTR pszAccountNameAfter);
        
        END_INTERFACE
    } IImnAdviseAccountVtbl;

    interface IImnAdviseAccount
    {
        CONST_VTBL struct IImnAdviseAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseAccount_AdviseAccount(This,dwAdviseType,AcctType,pszAccountNameBefore,pszAccountNameAfter)	\
    (This)->lpVtbl -> AdviseAccount(This,dwAdviseType,AcctType,pszAccountNameBefore,pszAccountNameAfter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseAccount_AdviseAccount_Proxy( 
    IImnAdviseAccount __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseType,
    /* [in] */ ACCTTYPE AcctType,
    /* [in] */ LPTSTR pszAccountNameBefore,
    /* [in] */ LPTSTR pszAccountNameAfter);


void __RPC_STUB IImnAdviseAccount_AdviseAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseAccount_INTERFACE_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_INTERFACE_DEFINED__
#define __IImnAdviseMigrateServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseMigrateServer
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAdviseMigrateServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAdviseMigrateServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MigrateServer( 
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseMigrateServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MigrateServer )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount);
        
        END_INTERFACE
    } IImnAdviseMigrateServerVtbl;

    interface IImnAdviseMigrateServer
    {
        CONST_VTBL struct IImnAdviseMigrateServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseMigrateServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseMigrateServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseMigrateServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseMigrateServer_MigrateServer(This,dwSrvType,pAccount)	\
    (This)->lpVtbl -> MigrateServer(This,dwSrvType,pAccount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseMigrateServer_MigrateServer_Proxy( 
    IImnAdviseMigrateServer __RPC_FAR * This,
    /* [in] */ DWORD dwSrvType,
    /* [in] */ IImnAccount __RPC_FAR *pAccount);


void __RPC_STUB IImnAdviseMigrateServer_MigrateServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseMigrateServer_INTERFACE_DEFINED__ */


#ifndef __IImnEnumAccounts_INTERFACE_DEFINED__
#define __IImnEnumAccounts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnEnumAccounts
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnEnumAccounts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnEnumAccounts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SortByAccountName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnEnumAccountsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortByAccountName )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        END_INTERFACE
    } IImnEnumAccountsVtbl;

    interface IImnEnumAccounts
    {
        CONST_VTBL struct IImnEnumAccountsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnEnumAccounts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnEnumAccounts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnEnumAccounts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnEnumAccounts_GetCount(This,pcItems)	\
    (This)->lpVtbl -> GetCount(This,pcItems)

#define IImnEnumAccounts_SortByAccountName(This)	\
    (This)->lpVtbl -> SortByAccountName(This)

#define IImnEnumAccounts_GetNext(This,ppAccount)	\
    (This)->lpVtbl -> GetNext(This,ppAccount)

#define IImnEnumAccounts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetCount_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IImnEnumAccounts_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_SortByAccountName_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_SortByAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetNext_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnEnumAccounts_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_Reset_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnEnumAccounts_INTERFACE_DEFINED__ */


#ifndef __IImnAccountManager_INTERFACE_DEFINED__
#define __IImnAccountManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccountManager
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAccountManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAccountManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAccountObject( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountCount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAccount( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccountName( 
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessNotification( 
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateDefaultSendAccount( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AccountListDialog( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwAcctFlags,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccountManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccountObject )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountCount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccountName )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessNotification )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateDefaultSendAccount )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccountListDialog )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwAcctFlags,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IImnAccountManagerVtbl;

    interface IImnAccountManager
    {
        CONST_VTBL struct IImnAccountManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccountManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccountManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccountManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccountManager_Init(This,pAdviseMigrateServer,pAdviseAccount)	\
    (This)->lpVtbl -> Init(This,pAdviseMigrateServer,pAdviseAccount)

#define IImnAccountManager_CreateAccountObject(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> CreateAccountObject(This,AcctType,ppAccount)

#define IImnAccountManager_Enumerate(This,dwSrvTypes,ppEnumAccounts)	\
    (This)->lpVtbl -> Enumerate(This,dwSrvTypes,ppEnumAccounts)

#define IImnAccountManager_GetAccountCount(This,AcctType,pcServers)	\
    (This)->lpVtbl -> GetAccountCount(This,AcctType,pcServers)

#define IImnAccountManager_FindAccount(This,dwPropTag,pszSearchData,ppAccount)	\
    (This)->lpVtbl -> FindAccount(This,dwPropTag,pszSearchData,ppAccount)

#define IImnAccountManager_GetDefaultAccount(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> GetDefaultAccount(This,AcctType,ppAccount)

#define IImnAccountManager_GetDefaultAccountName(This,AcctType,pszAccount,cchMax)	\
    (This)->lpVtbl -> GetDefaultAccountName(This,AcctType,pszAccount,cchMax)

#define IImnAccountManager_ProcessNotification(This,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> ProcessNotification(This,uMsg,wParam,lParam)

#define IImnAccountManager_ValidateDefaultSendAccount(This)	\
    (This)->lpVtbl -> ValidateDefaultSendAccount(This)

#define IImnAccountManager_AccountListDialog(This,hwnd,dwAcctFlags,dwFlags)	\
    (This)->lpVtbl -> AccountListDialog(This,hwnd,dwAcctFlags,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccountManager_Init_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer,
    /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount);


void __RPC_STUB IImnAccountManager_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_CreateAccountObject_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_CreateAccountObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Enumerate_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwSrvTypes,
    /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);


void __RPC_STUB IImnAccountManager_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetAccountCount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ ULONG __RPC_FAR *pcServers);


void __RPC_STUB IImnAccountManager_GetAccountCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_FindAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPTSTR pszSearchData,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_FindAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_GetDefaultAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccountName_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [ref][in] */ LPTSTR pszAccount,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IImnAccountManager_GetDefaultAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ProcessNotification_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IImnAccountManager_ProcessNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ValidateDefaultSendAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This);


void __RPC_STUB IImnAccountManager_ValidateDefaultSendAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_AccountListDialog_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwAcctFlags,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccountManager_AccountListDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccountManager_INTERFACE_DEFINED__ */


#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyContainer
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_PASS	= TYPE_BOOL + 1,
	TYPE_LAST	= TYPE_PASS + 1
    }	PROPTYPE;


EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_GetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_GetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][in] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_GetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_SetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_SetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


#ifndef __IImnAccount_INTERFACE_DEFINED__
#define __IImnAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccount
 * at Thu Mar 27 05:46:37 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IImnAccount : public IPropertyContainer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Exist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAsDefault( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountType( 
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerTypes( 
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateProperty( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exist )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsDefault )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountType )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerTypes )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateProperty )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IImnAccountVtbl;

    interface IImnAccount
    {
        CONST_VTBL struct IImnAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccount_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IImnAccount_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IImnAccount_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IImnAccount_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IImnAccount_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IImnAccount_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)


#define IImnAccount_Exist(This)	\
    (This)->lpVtbl -> Exist(This)

#define IImnAccount_SetAsDefault(This)	\
    (This)->lpVtbl -> SetAsDefault(This)

#define IImnAccount_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IImnAccount_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IImnAccount_GetAccountType(This,pAcctType)	\
    (This)->lpVtbl -> GetAccountType(This,pAcctType)

#define IImnAccount_GetServerTypes(This,pdwSrvTypes)	\
    (This)->lpVtbl -> GetServerTypes(This,pdwSrvTypes)

#define IImnAccount_ShowProperties(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd,dwFlags)

#define IImnAccount_ValidateProperty(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> ValidateProperty(This,dwPropTag,pb,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccount_Exist_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Exist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SetAsDefault_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SetAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_Delete_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SaveChanges_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetAccountType_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);


void __RPC_STUB IImnAccount_GetAccountType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetServerTypes_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);


void __RPC_STUB IImnAccount_GetServerTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ShowProperties_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ValidateProperty_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IImnAccount_ValidateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccount_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\imnext.h ===
/******************************************************

  IMNEXT.H 

  Contains external declarations for global variables
  used for Internet Mail and News setup as well as
  forward declarations for supporting functions.

  9/30/96	valdonb	Created

 ******************************************************/

#ifndef __IMNACT_H__
#define __IMNACT_H__

#include "imnact.h"

extern IICWApprentice	*gpImnApprentice;	// Mail/News account manager object

extern BOOL LoadAcctMgrUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags );

// in propmgr.cpp
extern BOOL DialogIDAlreadyInUse( UINT uDlgID );

// in icwaprtc.cpp
extern UINT	g_uExternUIPrev, g_uExternUINext;


/**
 * 
 *  No longer used after switch to wizard/apprentice model
 *
 * 4/23/97	jmazner	Olympus #3136
 *
extern IImnAccountManager	*gpImnAcctMgr;		// Mail/News account manager object
extern IImnEnumAccounts		*gpMailAccts;		// Enumerator object for mail accounts
extern IImnEnumAccounts		*gpNewsAccts;		// Enumerator object for news accounts
extern IImnEnumAccounts		*gpLDAPAccts;		// Enumerator object for news accounts


VOID InitAccountList(HWND hLB, IImnEnumAccounts *pAccts, ACCTTYPE accttype);
BOOL GetAccount(LPSTR szAcctName, ACCTTYPE accttype);
BOOL AccountNameExists(LPSTR szAcctName);
DWORD ValidateAccountName(LPSTR szAcctName, ACCTTYPE accttype);
BOOL SaveAccount(ACCTTYPE accttype, BOOL fSetAsDefault);
BOOL IsStringWhiteSpaceOnly(LPSTR szString);

**/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\interwiz.h ===
// Internet Setup Wizard Help ID; JeremyS

#define INTERNET_SETUP_MAIN       1000
#define INTERNET_SETUP_LAN        1001
#define INTERNET_SETUP_MSN        1002
#define INTERNET_SETUP_OTHERISP   1003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\inetapi.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  INETAPI.C - APIs for external components to use to configure system
//      
//

//  HISTORY:
//  
//  3/9/95    jeremys  Created.
//  96/02/26  markdu  Moved ClearConnectoidIPParams functionality 
//            into CreateConnectoid, so SetPhoneNumber only makes the
//            call to CreateConnectoid
//  96/03/09  markdu  Added LPRASENTRY parameter to CreateConnectoid()
//            and SetPhoneNumber
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Copy phone number info into the RASENTRY struct
//            in SetPhoneNumber().
//  96/03/10  markdu  Set TCP/IP info and autodial info per-connectoid.
//  96/03/21  markdu  Set RASEO flags appropriately.
//  96/03/22  markdu  Validate pointers before using them.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/24  markdu  Replaced lstrcpy with lstrcpyn where appropriate.
//  96/03/25  markdu  Replaced ApplyGlobalTcpInfo with ClearGlobalTcpInfo.
//            and replaced GetGlobalTcpInfo with IsThereGlobalTcpInfo.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/03/26  markdu  Use MAX_ISP_NAME instead of RAS_MaxEntryName 
//            because of bug in RNA.
//  96/04/04  markdu  Added phonebook name param to CreateConnectoid.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/26  markdu  Use lpIcfgTurnOffFileSharing and lpIcfgIsFileSharingTurnedOn,
//            lpIsGlobalDNS and lpIcfgRemoveGlobalDNS.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/06/04  markdu  OSR  BUG 7246 If no area code supplied, turn off
//            RASEO_UseCountryAndAreaCodes flag.
//

#include "wizard.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  #include "inetapi.h"

  // avoid name mangling
  VOID WINAPI InetPerformSecurityCheck(HWND hWnd,BOOL * pfNeedRestart);


#define ERROR_ALREADY_DISPLAYED  -1

BOOL ConfigureSystemForInternet_W(LPINTERNET_CONFIG lpInternetConfig,
  BOOL fPromptIfConfigNeeded);

#ifdef __cplusplus
}
#endif // __cplusplus

DWORD SetPhoneNumber(LPTSTR pszEntryName,UINT cbEntryName,LPRASENTRY lpRasEntry,
  PHONENUM * pPhoneNum,
  LPCTSTR pszUserName,LPCTSTR pszPassword,UINT uDefNameID);
INT_PTR CALLBACK SecurityCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL CenterWindow (HWND hwndChild, HWND hwndParent);
BOOL CALLBACK WarningDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGISGLOBALDNS              lpIcfgIsGlobalDNS;
extern ICFGREMOVEGLOBALDNS          lpIcfgRemoveGlobalDNS;
extern ICFGTURNOFFFILESHARING       lpIcfgTurnOffFileSharing;
extern ICFGISFILESHARINGTURNEDON    lpIcfgIsFileSharingTurnedOn;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;


typedef struct tagWARNINGDLGINFO {
  BOOL fResult;      // TRUE if user chose yes/OK to warning
  BOOL fDisableWarning;  // TRUE if user wants to disable warning in future
} WARNINGDLGINFO;

#ifdef UNICODE
PWCHAR ToUnicodeWithAlloc(LPCSTR);
#endif

/*******************************************************************

  NAME:    ConfigureSystemForInternet

  SYNOPSIS:  Performs all necessary configuration to set system up
        to use Internet.

  ENTRY:    lpInternetConfig - pointer to structure with configuration
        information.

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

        If the output flag ICOF_NEEDREBOOT is set, the caller
        must restart the system before continuing.

  NOTES:    Will install TCP/IP, RNA, PPPMAC as necessary; will
        create or modify an Internet RNA connectoid.

        This API displays error messages itself rather than
        passing back an error code because there is a wide range of
        possible error codes from different families, it is difficult
        for the caller to obtain text for all of them.

        Calls worker function ConfigureSystemForInternet_W.
    
********************************************************************/
#ifdef UNICODE
extern "C" BOOL WINAPI ConfigureSystemForInternetA
(
  LPINTERNET_CONFIGA lpInternetConfig
)
{
    HRESULT  hr;

    LPTSTR pszModemNameW = ToUnicodeWithAlloc(lpInternetConfig->pszModemName);
    LPTSTR pszUserNameW  = ToUnicodeWithAlloc(lpInternetConfig->pszUserName);
    LPTSTR pszPasswordW  = ToUnicodeWithAlloc(lpInternetConfig->pszPassword);
    LPTSTR pszEntryNameW = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName);
    LPTSTR pszEntryName2W = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName2);
    LPTSTR pszDNSServerW = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer);
    LPTSTR pszDNSServer2W = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer2);
    LPTSTR pszAutodialDllNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialDllName);
    LPTSTR pszAutodialFcnNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialFcnName);

    INTERNET_CONFIGW InternetConfigW;
    InternetConfigW.cbSize        = sizeof(INTERNET_CONFIGW);
    InternetConfigW.hwndParent    = lpInternetConfig->hwndParent;
    InternetConfigW.pszModemName  = pszModemNameW;
    InternetConfigW.pszUserName   = pszUserNameW;
    InternetConfigW.pszEntryName  = pszEntryNameW;
    InternetConfigW.pszEntryName2 = pszEntryName2W;
    InternetConfigW.pszDNSServer  = pszDNSServerW;
    InternetConfigW.pszDNSServer2 = pszDNSServer2W;
    InternetConfigW.pszAutodialDllName = pszAutodialDllNameW;
    InternetConfigW.pszAutodialFcnName = pszAutodialFcnNameW;
    InternetConfigW.dwInputFlags  = lpInternetConfig->dwInputFlags;
    InternetConfigW.dwOutputFlags = lpInternetConfig->dwOutputFlags;

    InternetConfigW.PhoneNum.dwCountryID = lpInternetConfig->PhoneNum.dwCountryID;
    InternetConfigW.PhoneNum.dwCountryCode = lpInternetConfig->PhoneNum.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum.szAreaCode,
             lpInternetConfig->PhoneNum.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum.szLocal,
             lpInternetConfig->PhoneNum.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum.szExtension,
             lpInternetConfig->PhoneNum.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum.szExtension)+1);

    InternetConfigW.PhoneNum2.dwCountryID = lpInternetConfig->PhoneNum2.dwCountryID;
    InternetConfigW.PhoneNum2.dwCountryCode = lpInternetConfig->PhoneNum2.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum2.szAreaCode,
             lpInternetConfig->PhoneNum2.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum2.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szLocal,
             lpInternetConfig->PhoneNum2.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum2.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szExtension,
             lpInternetConfig->PhoneNum2.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum2.szExtension)+1);

    hr = ConfigureSystemForInternetW(&InternetConfigW);

    // Free all allocated WCHAR.
    if(pszModemNameW)
        GlobalFree(pszModemNameW);
    if(pszUserNameW)
        GlobalFree(pszUserNameW);
    if(pszEntryNameW)
        GlobalFree(pszEntryNameW);
    if(pszEntryName2W)
        GlobalFree(pszEntryName2W);
    if(pszDNSServerW)
        GlobalFree(pszDNSServerW);
    if(pszDNSServer2W)
        GlobalFree(pszDNSServer2W);
    if(pszAutodialDllNameW)
        GlobalFree(pszAutodialDllNameW);
    if(pszAutodialFcnNameW)
        GlobalFree(pszAutodialFcnNameW);

    return hr;
}

extern "C" BOOL WINAPI ConfigureSystemForInternetW
#else
extern "C" BOOL WINAPI ConfigureSystemForInternetA
#endif
(
  LPINTERNET_CONFIG lpInternetConfig
)
{
  BOOL fRet;
  // call worker function
  fRet = ConfigureSystemForInternet_W(lpInternetConfig,FALSE);


  if (fRet)
  {
    // make sure "The Internet" icon on desktop points to web browser
    // (it may initially be pointing at internet wizard) (for versions < IE 4)
	
	//	//10/24/96 jmazner Normandy 6968
	//	//No longer neccessary thanks to Valdon's hooks for invoking ICW.
	// 11/21/96 jmazner Normandy 11812
	// oops, it _is_ neccessary, since if user downgrades from IE 4 to IE 3,
	// ICW 1.1 needs to morph the IE 3 icon.

    SetDesktopInternetIconToBrowser();
  }

  return fRet;
}


/*******************************************************************

  NAME:    SetInternetPhoneNumber

  SYNOPSIS:  Sets the phone number used to auto-dial to the Internet.

        If the system is not fully configured when this API is called,
        this API will do the configuration after checking with the user.
        (This step is included for extra robustness, in case the user has
        removed something since the system was configured.)
  
  ENTRY:    lpPhonenumConfig - pointer to structure with configuration
        information.

        If the input flag ICIF_NOCONFIGURE is set, then if the system
        is not already configured properly, this API will display an
        error message and return FALSE.  (Otherwise this API will
        ask the user if it's OK to configure the system, and do it.)

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

        If the output flag ICOF_NEEDREBOOT is set, the caller
        must restart the system before continuing.  (

  NOTES:    Will create a new connectoid if a connectoid for the internet
        does not exist yet, otherwise modifies existing internet
        connectoid.

        This API displays error messages itself rather than
        passing back an error code because there is a wide range of
        possible error codes from different families, it is difficult
        for the caller to obtain text for all of them.

        Calls worker function ConfigureSystemForInternet_W.

********************************************************************/
#ifdef UNICODE
extern "C" BOOL WINAPI SetInternetPhoneNumberA
(
  LPINTERNET_CONFIGA lpInternetConfig
)
{
    HRESULT  hr;

    LPTSTR pszModemNameW = ToUnicodeWithAlloc(lpInternetConfig->pszModemName);
    LPTSTR pszUserNameW  = ToUnicodeWithAlloc(lpInternetConfig->pszUserName);
    LPTSTR pszPasswordW  = ToUnicodeWithAlloc(lpInternetConfig->pszPassword);
    LPTSTR pszEntryNameW = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName);
    LPTSTR pszEntryName2W = ToUnicodeWithAlloc(lpInternetConfig->pszEntryName2);
    LPTSTR pszDNSServerW = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer);
    LPTSTR pszDNSServer2W = ToUnicodeWithAlloc(lpInternetConfig->pszDNSServer2);
    LPTSTR pszAutodialDllNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialDllName);
    LPTSTR pszAutodialFcnNameW = ToUnicodeWithAlloc(lpInternetConfig->pszAutodialFcnName);

    INTERNET_CONFIGW InternetConfigW;
    InternetConfigW.cbSize        = sizeof(INTERNET_CONFIGW);
    InternetConfigW.hwndParent    = lpInternetConfig->hwndParent;
    InternetConfigW.pszModemName  = pszModemNameW;
    InternetConfigW.pszUserName   = pszUserNameW;
    InternetConfigW.pszEntryName  = pszEntryNameW;
    InternetConfigW.pszEntryName2 = pszEntryName2W;
    InternetConfigW.pszDNSServer  = pszDNSServerW;
    InternetConfigW.pszDNSServer2 = pszDNSServer2W;
    InternetConfigW.pszAutodialDllName = pszAutodialDllNameW;
    InternetConfigW.pszAutodialFcnName = pszAutodialFcnNameW;
    InternetConfigW.dwInputFlags  = lpInternetConfig->dwInputFlags;
    InternetConfigW.dwOutputFlags = lpInternetConfig->dwOutputFlags;

    InternetConfigW.PhoneNum.dwCountryID = lpInternetConfig->PhoneNum.dwCountryID;
    InternetConfigW.PhoneNum.dwCountryCode = lpInternetConfig->PhoneNum.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum.szAreaCode,
             lpInternetConfig->PhoneNum.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum.szLocal,
             lpInternetConfig->PhoneNum.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum.szExtension,
             lpInternetConfig->PhoneNum.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum.szExtension)+1);

    InternetConfigW.PhoneNum2.dwCountryID = lpInternetConfig->PhoneNum2.dwCountryID;
    InternetConfigW.PhoneNum2.dwCountryCode = lpInternetConfig->PhoneNum2.dwCountryCode;
    mbstowcs(InternetConfigW.PhoneNum2.szAreaCode,
             lpInternetConfig->PhoneNum2.szAreaCode,
             lstrlenA(lpInternetConfig->PhoneNum2.szAreaCode)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szLocal,
             lpInternetConfig->PhoneNum2.szLocal,
             lstrlenA(lpInternetConfig->PhoneNum2.szLocal)+1);
    mbstowcs(InternetConfigW.PhoneNum2.szExtension,
             lpInternetConfig->PhoneNum2.szExtension,
             lstrlenA(lpInternetConfig->PhoneNum2.szExtension)+1);

    hr = SetInternetPhoneNumberW(&InternetConfigW);

    // Free all allocated WCHAR.
    if(pszModemNameW)
        GlobalFree(pszModemNameW);
    if(pszUserNameW)
        GlobalFree(pszUserNameW);
    if(pszEntryNameW)
        GlobalFree(pszEntryNameW);
    if(pszEntryName2W)
        GlobalFree(pszEntryName2W);
    if(pszDNSServerW)
        GlobalFree(pszDNSServerW);
    if(pszDNSServer2W)
        GlobalFree(pszDNSServer2W);
    if(pszAutodialDllNameW)
        GlobalFree(pszAutodialDllNameW);
    if(pszAutodialFcnNameW)
        GlobalFree(pszAutodialFcnNameW);

    return hr;
}

extern "C" BOOL WINAPI SetInternetPhoneNumberW
#else
extern "C" BOOL WINAPI SetInternetPhoneNumberA
#endif
(
  LPINTERNET_CONFIG lpInternetConfig
)
{
  // call worker function
  return ConfigureSystemForInternet_W(lpInternetConfig,TRUE);
}

/*******************************************************************

  NAME:    ConfigureSystemForInternet_W

  SYNOPSIS:  worker function to do system configuration for Internet

  ENTRY:    lpInternetConfig - pointer to structure with configuration
          information.

        fPromptIfConfigNeeded - if TRUE, then if any system
          configuration is needed the user will be prompted and
          asked if it's OK to reconfigure the system

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

        If the output flag ICOF_NEEDREBOOT is set, the caller
        must restart the system before continuing.

  NOTES:    Will install TCP/IP, RNA, PPPMAC as necessary; will
        create or modify an Internet RNA connectoid.

        This API displays error messages itself rather than
        passing back an error code because there is a wide range of
        possible error codes from different families, it is difficult
        for the caller to obtain text for all of them.
    
********************************************************************/
BOOL ConfigureSystemForInternet_W(LPINTERNET_CONFIG lpInternetConfig,
  BOOL fPromptIfConfigNeeded)
{
  UINT   uErr=ERROR_SUCCESS,uErrMsgID=IDS_ERRSetPhoneNumber;
  DWORD dwErrCls = ERRCLS_STANDARD;
  BOOL  fNeedDrivers = FALSE;
  BOOL  fRet = FALSE;
  BOOL  fNeedReboot = FALSE;
  TCHAR szEntryName[MAX_ISP_NAME+1]=TEXT("");
  BOOL  fNeedToDeInitRNA = FALSE;
  DWORD dwfInstallOptions;

  DEBUGMSG("inetapi.c::ConfigureSystemForInternet_W()");

  // validate parameters
  ASSERT(lpInternetConfig);
  if (!lpInternetConfig)
    return FALSE;
  ASSERT(lpInternetConfig->cbSize == sizeof(INTERNET_CONFIG));
  if (lpInternetConfig->cbSize != sizeof(INTERNET_CONFIG))
    return FALSE;

  // clear output flags
  lpInternetConfig->dwOutputFlags = 0;

  HWND hwndParent = lpInternetConfig->hwndParent;

  WAITCURSOR WaitCursor;  // set an hourglass cursor

  // Also allocate a RASENTRY struct for connectoid data
  LPRASENTRY  pRasEntry = new RASENTRY;
  ASSERT(pRasEntry);

  if (!pRasEntry)
  {
    // out of memory!
    uErr = ERROR_NOT_ENOUGH_MEMORY;
    dwErrCls = ERRCLS_STANDARD;
    goto exit;
  }

  InitRasEntry(pRasEntry);

  // based on config and preferences, find out if we need to install 
  // drivers/files or not
  dwfInstallOptions = ICFG_INSTALLTCP | ICFG_INSTALLRAS;
  if (!(lpInternetConfig->dwInputFlags & ICIF_NOCONFIGURE))
  {
    uErr = lpIcfgNeedInetComponents(dwfInstallOptions, &fNeedDrivers);

    if (ERROR_SUCCESS != uErr)
    {
      TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
      
      // Get the text of the error message and display it.
      if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
      {
        MsgBoxSz(NULL,szErrorText,MB_ICONEXCLAMATION,MB_OK);
        uErr = (UINT) ERROR_ALREADY_DISPLAYED;
      }
      goto exit;
    }
  }
  else
  {
    fNeedDrivers = FALSE;
  }

  if (fNeedDrivers && fPromptIfConfigNeeded) {
    // if this API is just getting called to set a new phone number,
    // we check the configuration anyway in case the user has accidentally
    // changed something.  Since we noticed we need to do something
    // to user's config and fPromptIfConfigNeeded is TRUE, we will ask
    // the user if it's OK to change the machine's config.

    if (MsgBox(hwndParent,IDS_OKTOCHANGECONFIG,MB_ICONQUESTION,MB_YESNO)
      != IDYES) {
      // user elected not to have us do necessary setup, so just set
      // fNeedDrivers flag to FALSE so we don't do setup.  We will
      // stil try to set internet phone # below... this may fail
      // if part of the required setup was to do something like install
      // RNA
      fNeedDrivers = FALSE;
    }
  }

  if (fNeedDrivers) {
    // yes, need to install some drivers

    // warn user that we're about to do stuff that may need win 95 disks.
    // also let user cancel this part

    // the message is long and takes up two string resources, allocate
    // memory to build the string
    BUFFER MsgBuf(MAX_RES_LEN*2+1),Msg1(MAX_RES_LEN),Msg2(MAX_RES_LEN);
    ASSERT(MsgBuf);
    ASSERT(Msg1);
    ASSERT(Msg2);
    if (!MsgBuf || !Msg1 || !Msg2) {
      // out of memory!
      uErr = ERROR_NOT_ENOUGH_MEMORY;
      dwErrCls = ERRCLS_STANDARD;
      goto exit;
    }
    LoadSz(IDS_ABOUTTOCHANGECONFIG1,Msg1.QueryPtr(),Msg1.QuerySize());
    LoadSz(IDS_ABOUTTOCHANGECONFIG2,Msg2.QueryPtr(),Msg2.QuerySize());
    wsprintf(MsgBuf.QueryPtr(),Msg1.QueryPtr(),Msg2.QueryPtr());

    if (MsgBoxSz(hwndParent,MsgBuf.QueryPtr(),MB_ICONINFORMATION,
      MB_OKCANCEL) != IDOK) {
      // user cancelled, stop
      uErr = (UINT) ERROR_ALREADY_DISPLAYED;
      goto exit;
    }

    WAITCURSOR WaitCursor;  // construct a wait cursor since MessageBox
                            // destroys the hourglass cursor

    // install the drivers we need
    uErr = lpIcfgInstallInetComponents(hwndParent, dwfInstallOptions, &fNeedReboot);
   
    if (ERROR_SUCCESS != uErr)
    {
      TCHAR   szErrorText[MAX_ERROR_TEXT+1]=TEXT("");
      
      // Get the text of the error message and display it.
      if (lpIcfgGetLastInstallErrorText(szErrorText, MAX_ERROR_TEXT+1))
      {
        MsgBoxSz(hwndParent,szErrorText,MB_ICONEXCLAMATION,MB_OK);
        uErr = (UINT) ERROR_ALREADY_DISPLAYED;
      }
      goto exit;
    }

    // set "need reboot" output flag if appropriate
    if (fNeedReboot)
      lpInternetConfig->dwOutputFlags |= ICOF_NEEDREBOOT;
  }

  // MSN dial-in points dynamically assign DNS (as of this writing)... if
  // DNS is set statically in registry, dynamic DNS assignment will not
  // work and user may be hosed.  Check, warn user and offer to remove if
  // set...

  if (!(lpInternetConfig->dwInputFlags & (ICIF_NOCONFIGURE | ICIF_NODNSCHECK))) {
    if (DoDNSCheck(lpInternetConfig->hwndParent,&fNeedReboot)) {
      // set "need reboot" output flag if appropriate
      if (fNeedReboot)
        lpInternetConfig->dwOutputFlags |= ICOF_NEEDREBOOT;
    }
  }

  // create or modify connectoid(s)
  // make sure RNA is loaded
  fRet = InitRNA(hwndParent);
  if (!fRet) {
    uErr = (UINT) ERROR_ALREADY_DISPLAYED;
    goto exit;
  }

  fNeedToDeInitRNA = TRUE;  // set a flag so we know to free RNA later

  // Copy the modem name into the rasentry struct
  if (lpInternetConfig->pszModemName)
  {
    lstrcpyn(pRasEntry->szDeviceName,lpInternetConfig->pszModemName,
      sizeof(pRasEntry->szDeviceName));
  }

  // set autodial handler dll if specified by caller
  // only do anything if both DLL and function name are set
  if (lpInternetConfig && lpInternetConfig->pszAutodialDllName && 
    lpInternetConfig->pszAutodialFcnName &&
    lpInternetConfig->pszAutodialDllName[0] &&
    lpInternetConfig->pszAutodialFcnName[0])
  {
    lstrcpyn(pRasEntry->szAutodialDll,lpInternetConfig->pszAutodialDllName,
      sizeof(pRasEntry->szAutodialDll));
    lstrcpyn(pRasEntry->szAutodialFunc,lpInternetConfig->pszAutodialFcnName,
      sizeof(pRasEntry->szAutodialFunc));
  }

  // Default to not show terminal window after dial.  
  pRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;    

  // Don't use specific IP addresses.
  pRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;    

  // set DNS information if specified
  if (lpInternetConfig->pszDNSServer && lstrlen(lpInternetConfig->pszDNSServer))
  {
    IPADDRESS dwDNSAddr;
    if (IPStrToLong(lpInternetConfig->pszDNSServer,&dwDNSAddr))
    {
      CopyDw2Ia(dwDNSAddr, &pRasEntry->ipaddrDns);

      // Turn on Specific name servers
      pRasEntry->dwfOptions |= RASEO_SpecificNameServers;    
    }
  }
      
  if (lpInternetConfig->pszDNSServer2 && lstrlen(lpInternetConfig->pszDNSServer2))
  {
    IPADDRESS dwDNSAddr;
    if (IPStrToLong(lpInternetConfig->pszDNSServer2,&dwDNSAddr))
    {
      CopyDw2Ia(dwDNSAddr, &pRasEntry->ipaddrDnsAlt);
    }
  }

  // set first phone number
  // should always have a real phone number for first phone number
  ASSERT(lstrlen(lpInternetConfig->PhoneNum.szLocal));
  if (lstrlen(lpInternetConfig->PhoneNum.szLocal))
  {
    if (lpInternetConfig->pszEntryName)
    {
      lstrcpyn(szEntryName,lpInternetConfig->pszEntryName,
        sizeof(szEntryName));
    }
    else
    {
      szEntryName[0] = '\0';
    }

    uErr = SetPhoneNumber(szEntryName,sizeof(szEntryName),pRasEntry,
      &lpInternetConfig->PhoneNum,lpInternetConfig->pszUserName,
      lpInternetConfig->pszPassword,IDS_DEF_CONNECTION_NAME_1);
    dwErrCls = ERRCLS_RNA;

    if (uErr == ERROR_SUCCESS)
    {
      if (!(lpInternetConfig->dwInputFlags & ICIF_DONTSETASINTERNETENTRY))
      {
        // set this number as the number used to autodial to the Internet
        //  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
        InetSetAutodial(TRUE, szEntryName);
      }
    }
  }

  // set 2nd (backup) phone number
  if ((uErr == ERROR_SUCCESS) && (lpInternetConfig->PhoneNum2.szLocal) &&
    (lstrlen(lpInternetConfig->PhoneNum2.szLocal)))
  {
    TCHAR   szEntryNameTmp[MAX_ISP_NAME+1];
    if (lpInternetConfig->pszEntryName2)
    {
      lstrcpyn(szEntryNameTmp,lpInternetConfig->pszEntryName2,
        sizeof(szEntryNameTmp));
    }
    else
    {
      szEntryNameTmp[0] = '\0';
    }

    uErr = SetPhoneNumber(szEntryNameTmp,sizeof(szEntryNameTmp),
      pRasEntry,&lpInternetConfig->PhoneNum2,lpInternetConfig->pszUserName,
      lpInternetConfig->pszPassword,IDS_DEF_CONNECTION_NAME_2);
    dwErrCls = ERRCLS_RNA;

    if (uErr == ERROR_SUCCESS)
    {
      if (!(lpInternetConfig->dwInputFlags & ICIF_DONTSETASINTERNETENTRY))
      {
        // set this number as the backup number used to autodial to the Internet
        SetBackupInternetConnectoid(szEntryNameTmp);
      }
    }
  }


exit:
  // free memory
  if (pRasEntry)
    delete pRasEntry;

  // display error message if error occurred
  if (uErr != ERROR_SUCCESS && uErr != ERROR_ALREADY_DISPLAYED) {
    DisplayErrorMessage(hwndParent,uErrMsgID,uErr,dwErrCls,MB_ICONEXCLAMATION);
  }

  // free RNA if need be.  Note we must do this *after* the call to
  // DisplayErrorMessage, because DisplayErrorMessage needs to call RNA
  // to get error description if an RNA error was generated.
  if (fNeedToDeInitRNA) {
    DeInitRNA();
  }

  return (uErr == ERROR_SUCCESS);
}

/*******************************************************************

  NAME:    SetPhoneNumber

  SYNOPSIS:  Creates or modifies a connectoid with specified information

  ENTRY:    pszEntryName - name to use for the connectoid.  If empty, the
          default name stored in string resource specified by
          uDefNameID will be used.  On exit, this buffer is filled
          in with the actual name used.
        cbEntryName - size of buffer pointed to by szEntryName
        pPhoneNum - pointer to struct with phone number
        pszUserName - user name to populate connectoid with.  Ignored
          if NULL.
        pszPassword - password to populate connectoid with.  Ignored
          if NULL.
        uDefNameID - ID of string resource with default name to use
          if pszEntryName is NULL.

  EXIT:    returns an RNA error code

  NOTES:    This is a wrapper to call CreateConnectoid, to avoid duplicating
        code to load default name out of resource.

        Since the pszEntryName buffer is filled at exit with the
        actual name used, callers should be careful not to pass in buffers
        from API callers, since apps using API won't expect their own
        buffers to be modified.

********************************************************************/
DWORD SetPhoneNumber(LPTSTR pszEntryName,UINT cbEntryName,
  LPRASENTRY lpRasEntry, PHONENUM * pPhoneNum,
  LPCTSTR pszUserName,LPCTSTR pszPassword,UINT uDefNameID)
{
  ASSERT(pszEntryName);
  ASSERT(pPhoneNum);  
  ASSERT(lpRasEntry);  
  // (all other parameters may be  NULL)

  // if a connectoid name was specified, use it; if NULL, use a default
  // name.
  if (!lstrlen(pszEntryName))
  {
    LoadSz(uDefNameID,pszEntryName,cbEntryName);
  }

  // 96/06/04 markdu  OSR  BUG 7246
  // If no area code was specified, turn off area code flag
	if (lstrlen(pPhoneNum->szAreaCode))
	{
    lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
	}
  else
	{
    lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;
	}


  // copy the phone number data
  lpRasEntry->dwCountryID = pPhoneNum->dwCountryID;
  lpRasEntry->dwCountryCode = pPhoneNum->dwCountryCode;
  lstrcpyn (lpRasEntry->szAreaCode, pPhoneNum->szAreaCode,
     sizeof(lpRasEntry->szAreaCode));
  lstrcpyn (lpRasEntry->szLocalPhoneNumber, pPhoneNum->szLocal,
     sizeof(lpRasEntry->szLocalPhoneNumber));

  // create/update the connectoid
  DWORD dwRet = CreateConnectoid(NULL, pszEntryName,lpRasEntry,
    pszUserName,pszPassword);

  return dwRet;
}


/*******************************************************************

  NAME:    InetPerformSecurityCheck

  SYNOPSIS:  Checks to make sure win 95 file/print sharing is not
        bound to TCP/IP used for the internet

    ENTRY:    hWnd - parent window (if any)
        pfNeedRestart - on exit, set to TRUE if restart is needed.

  NOTES:    If we warn user about file/print sharing and user tells us
        to fix, then a reboot is necessary.  Caller is responsible
        for checking *pfNeedRestart on return and restarting system
        if necessary.

********************************************************************/
VOID WINAPI InetPerformSecurityCheck(HWND hWnd,BOOL * pfNeedRestart)
{
  ASSERT(pfNeedRestart);
  *pfNeedRestart = FALSE;

  // see if the server is bound to internet instance
  BOOL  fSharingOn;
  HRESULT hr = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingOn);

  //
  // 5/12/97 jmazner Olympus #3442  IE #30886
  // TEMP TODO at the moment, icfgnt doesn't implement FileSharingTurnedOn
  // Until it does, assume that on NT file sharing is always off.
  //
  if( IsNT() )
  {
	  DEBUGMSG("Ignoring return code from IcfgIsFileSharingTurnedOn");
	  fSharingOn = FALSE;
  }


  if ((ERROR_SUCCESS == hr) && (TRUE == fSharingOn))
  {
    // ask user if we can disable file/print sharing on TCP/IP instance
    // to the Internet
    BOOL fRet=(BOOL)DialogBox(ghInstance,MAKEINTRESOURCE(IDD_SECURITY_CHECK),
      hWnd,SecurityCheckDlgProc);

    if (fRet) {
      // user OK'd it, go ahead and unbind the server from the instance
      // in question
      HRESULT hr = lpIcfgTurnOffFileSharing(INSTANCE_PPPDRIVER, hWnd);
      ASSERT(hr == ERROR_SUCCESS);

      if (hr == ERROR_SUCCESS) {
        // we need to restart for the changes to take effect
        *pfNeedRestart = TRUE;
      }
    }
  }
}

/*******************************************************************

  NAME:    SecurityCheckDlgProc

  SYNOPSIS:  Dialog proc for security check dialog

  NOTES:    This is basically just a yes/no dialog, so we could
        almost just use MessageBox, except we also need a "don't
        do this any more" checkbox.

********************************************************************/
INT_PTR CALLBACK SecurityCheckDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  switch (uMsg) {

    case WM_INITDIALOG:
      CenterWindow(hDlg,GetDesktopWindow());
      SetFocus(GetDlgItem(hDlg,IDOK));
      return TRUE;
      break;

    case WM_COMMAND:

      switch (wParam) {

        case IDOK:
          // dismiss the dialog
          EndDialog(hDlg,TRUE);

          break;

        case IDCANCEL:
          // if "don't display this in the future" is checked, then
          // turn off registry switch for security check
          if (IsDlgButtonChecked(hDlg,IDC_DISABLE_CHECK)) {
            RegEntry re(szRegPathInternetSettings,HKEY_CURRENT_USER);
            ASSERT(re.GetError() == ERROR_SUCCESS);
            if (re.GetError() == ERROR_SUCCESS) {
              re.SetValue(szRegValEnableSecurityCheck,
                (DWORD) 0 );
              ASSERT(re.GetError() == ERROR_SUCCESS);
            }
          }

          // dismiss the dialog          
          EndDialog(hDlg,FALSE);
          break;

        case IDC_DISABLE_CHECK:

          // if "don't do this in the future" is checked, then
          // disable 'OK' button
          EnableDlgItem(hDlg,IDOK,!IsDlgButtonChecked(hDlg,
            IDC_DISABLE_CHECK));

          break;

      }
      break;
      
  }

  return FALSE;
}

/****************************************************************************

  FUNCTION: CenterWindow (HWND, HWND)

  PURPOSE:  Center one window over another

  COMMENTS:

  Dialog boxes take on the screen position that they were designed at,
  which is not always appropriate. Centering the dialog over a particular
  window usually results in a better position.

****************************************************************************/
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
  RECT    rChild, rParent;
  int     wChild, hChild, wParent, hParent;
  int     wScreen, hScreen, xNew, yNew;
  HDC     hdc;

  // Get the Height and Width of the child window
  GetWindowRect (hwndChild, &rChild);
  wChild = rChild.right - rChild.left;
  hChild = rChild.bottom - rChild.top;

  // Get the Height and Width of the parent window
  GetWindowRect (hwndParent, &rParent);
  wParent = rParent.right - rParent.left;
  hParent = rParent.bottom - rParent.top;

  // Get the display limits
  hdc = GetDC (hwndChild);
  wScreen = GetDeviceCaps (hdc, HORZRES);
  hScreen = GetDeviceCaps (hdc, VERTRES);
  ReleaseDC (hwndChild, hdc);

  // Calculate new X position, then adjust for screen
  xNew = rParent.left + ((wParent - wChild) /2);
  if (xNew < 0) {
    xNew = 0;
  } else if ((xNew+wChild) > wScreen) {
    xNew = wScreen - wChild;
  }

  // Calculate new Y position, then adjust for screen
  yNew = rParent.top  + ((hParent - hChild) /2);
  if (yNew < 0) {
    yNew = 0;
  } else if ((yNew+hChild) > hScreen) {
    yNew = hScreen - hChild;
  }

  // Set it, and return
  return SetWindowPos (hwndChild, NULL,
    xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

/*******************************************************************

  NAME:    DoDNSCheck

  SYNOPSIS:  Checks to see if DNS is configured statically in the
        registry.  If it is, then displays a dialog offering
        to remove it, and removes it if user chooses.

  ENTRY:    hwndParent - parent window
        pfNeedRestart - filled in on exit with TRUE if restart
          is necessary, FALSE otherwise

  NOTES:    Need to do this to work around Win 95 bug where
        dynamically assigned DNS servers are ignored if static
        DNS servers are set.

        Note that the UI is MSN specific and contains MSN
        references!

********************************************************************/
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart)
{
  ASSERT(pfNeedRestart);
  *pfNeedRestart = FALSE;

/******** ChrisK 10/24/96 Normandy 3722 - see bug for LONG discussion on this
  // see if this warning has already been disabled
  RegEntry re(szRegPathWarningFlags,HKEY_CURRENT_USER);
  if (re.GetError() == ERROR_SUCCESS) {
    if (re.GetNumber(szRegValDisableDNSWarning,0) > 0) {
      // user has asked for warning to be disabled, nothing to do
      return TRUE;
    }
  }

  // if there are DNS servers set statically (e.g. in net setup),
  // warn the user and ask if we should remove
  BOOL  fGlobalDNS;
  HRESULT hr = lpIcfgIsGlobalDNS(&fGlobalDNS);

  if ((ERROR_SUCCESS == hr) && (TRUE == fGlobalDNS))
  {
    WARNINGDLGINFO WarningDlgInfo;
    ZeroMemory(&WarningDlgInfo,sizeof(WARNINGDLGINFO));

    DialogBoxParam(ghInstance,MAKEINTRESOURCE(IDD_DNS_WARNING),
      hwndParent,WarningDlgProc,(LPARAM) &WarningDlgInfo);

    // one field or the other can be TRUE, but not both...
    ASSERT(!(WarningDlgInfo.fResult && WarningDlgInfo.fDisableWarning));
    if (WarningDlgInfo.fResult)
    {
      // remove static DNS servers from registry
      HRESULT hr = lpIcfgRemoveGlobalDNS();
      ASSERT(hr == ERROR_SUCCESS);
      if (hr != ERROR_SUCCESS)
      {
        DisplayErrorMessage(hwndParent,IDS_ERRWriteDNS,hr,
          ERRCLS_STANDARD,MB_ICONEXCLAMATION);
      }
      else
      {
        *pfNeedRestart = TRUE;
      }

    }
    else if (WarningDlgInfo.fDisableWarning)
    {
      // disable warning switch in registry
      re.SetValue(szRegValDisableDNSWarning,(DWORD) TRUE);
    }
  }
ChrisK 10/24/96 Normandy 3722 - see bug for LONG discussion on this ********/
  return TRUE;
}


/*******************************************************************

  NAME:    WarningDlgProc

  SYNOPSIS:  Dialog proc for DNS warning dialog

********************************************************************/
BOOL CALLBACK WarningDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
  WARNINGDLGINFO * pWarningDlgInfo;

  switch (uMsg) {
    case WM_INITDIALOG:
      // center dialog on screen if we're not owned
      if (!GetParent(hDlg)) {
        CenterWindow(hDlg,GetDesktopWindow());
      }
      SetFocus(GetDlgItem(hDlg,IDOK));

      // lParam should point to WARNINGDLGINFO struct
      ASSERT(lParam);
      if (!lParam)
        return FALSE;
      // store pointer in window data
      SetWindowLongPtr(hDlg,DWLP_USER,lParam);
      return TRUE;
      break;

    case WM_COMMAND:

      pWarningDlgInfo = (WARNINGDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
      ASSERT(pWarningDlgInfo);

      switch (wParam) {

        case IDOK:
          pWarningDlgInfo->fResult=TRUE;
          pWarningDlgInfo->fDisableWarning=FALSE;
          EndDialog(hDlg,TRUE);
          break;


        case IDC_CANCEL:
          pWarningDlgInfo->fResult=FALSE;
          pWarningDlgInfo->fDisableWarning=
            IsDlgButtonChecked(hDlg,IDC_DISABLE_WARNING);
          EndDialog(hDlg,FALSE);
          break;


        case IDC_DISABLE_WARNING:
          // when 'disable warning' is checked, disable the 'yes'
          // button
          EnableDlgItem(hDlg,IDOK,!IsDlgButtonChecked(hDlg,
            IDC_DISABLE_WARNING));
          break;

      }
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\imnext.cpp ===
/******************************************************

  IMNEXT.CPP 

  Contains definitions for global variables and
  functions used for Internet Mail and News setup.

 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1996
 *  All rights reserved


  9/30/96   valdonb Created

 ******************************************************/

#include "wizard.h"
#include "initguid.h"   // Make DEFINE_GUID declare an instance of each GUID
#include "icwextsn.h"
#include "imnext.h"
#include "inetcfg.h"
#include <icwcfg.h>


IICWApprentice  *gpImnApprentice = NULL;    // Mail/News account manager object

//+----------------------------------------------------------------------------
//
//  Function    LoadAcctMgrUI
//
//  Synopsis    Loads in the Account Manager's apprentice pages for configuring
//              accounts (mail, news, directory service/LDAP).
//
//              If the UI has previously been loaded, the function will simply
//              update the Next and Back pages for the apprentice.
//
//              Uses global variable g_fAcctMgrUILoaded.
//
//
//  Arguments   hWizHWND -- HWND of main property sheet
//              uPrevDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Back
//              uNextDlgID -- Dialog ID apprentice should go to when user leaves
//                            apprentice by clicking Next
//              dwFlags -- Flags variable that should be passed to
//                          IICWApprentice::AddWizardPages
//
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------

BOOL LoadAcctMgrUI( HWND hWizHWND, UINT uPrevDlgID, UINT uNextDlgID, DWORD dwFlags )
{
    HRESULT hResult = E_NOTIMPL;

    // If we should not run Internet Mail and New setup, then just return FALSE
    if (gpWizardState->dwRunFlags & RSW_NOIMN)
        return FALSE;
        
    if( g_fAcctMgrUILoaded )
    {
        ASSERT( g_pCICWExtension );
        ASSERT( gpImnApprentice );

        DEBUGMSG("LoadAcctMgrUI: UI already loaded, just reset first (%d) and last (%d) pages",
                uPrevDlgID, uNextDlgID);

        // If We are ICW, the Mail account manager is our last page.
        if (g_fIsICW) 
            uNextDlgID = g_uExternUINext;

        hResult = gpImnApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );
        goto LoadAcctMgrUIExit;
    }


    if( !hWizHWND )
    {
        DEBUGMSG("LoadAcctMgrUI got a NULL hWizHWND!");
        return FALSE;
    }

    if( gpImnApprentice )
    {
        if( NULL == g_pCICWExtension )
        {
            DEBUGMSG("Instantiating ICWExtension and using it to initialize Acct Mgr's IICWApprentice");
            g_pCICWExtension = new( CICWExtension );
            g_pCICWExtension->AddRef();
            g_pCICWExtension->m_hWizardHWND = hWizHWND;
            gpImnApprentice->Initialize( g_pCICWExtension );
        }

        hResult = gpImnApprentice->AddWizardPages(dwFlags);

        if( !SUCCEEDED(hResult) )
        {
            goto LoadAcctMgrUIExit;
        }

        // If We are ICW, the Mail account manager is our last page.
        if (g_fIsICW) 
            uNextDlgID = g_uExternUINext;
        hResult = gpImnApprentice->SetPrevNextPage( uPrevDlgID, uNextDlgID );
    }


LoadAcctMgrUIExit:
    if( SUCCEEDED(hResult) )
    {
        g_fAcctMgrUILoaded = TRUE;
        return TRUE;
    }
    else
    {
        DEBUGMSG("LoadAcctMgrUI failed with (hex) hresult %x", hResult);
        return FALSE;
    }
}


/****
 *
 * The rest of the functions in this file are no longer used since switching to
 * the apprentice/wizard model
 *
 * 4/23/97 jmazner Olympus #3136

/*****************************************************************

  NAME:     InitAccountList

  SYNOPSIS: Fills a list box with the account names in the account list.

  PARAMETERS:

            hLB         HWND to the list box to be filled
            pEnumAccts  Pointer the the account list
            accttype    Type of accounts in the account list

  RETURN:   none

 *****************************************************************/
/**
VOID InitAccountList(HWND hLB, IImnEnumAccounts *pEnumAccts, ACCTTYPE accttype)
{
    IImnAccount *pAcct = NULL;
    CHAR szDefAcct[CCHMAX_ACCOUNT_NAME+1];
    CHAR szBuf[CCHMAX_ACCOUNT_NAME+1];
    HRESULT hr;
    DWORD index;
    BOOL fSelected = FALSE;

    ListBox_ResetContent(hLB);

    if (NULL == pEnumAccts)
        return;

    szDefAcct[0] = '\0';

    // Get the default so we can highlight it in the list
    gpImnAcctMgr->GetDefaultAccountName(accttype,szDefAcct,CCHMAX_ACCOUNT_NAME);
    
    // 2/20/97  jmazner Olympus #262
    // Reset back to the first acct. so that when we walk through the GetNext loop,
    // we're sure to get every account
    pEnumAccts->Reset();

    // Populate the account list box
    while (SUCCEEDED(pEnumAccts->GetNext(&pAcct)))
    {
        hr = pAcct->GetPropSz(AP_ACCOUNT_NAME,szBuf,sizeof(szBuf));
        if (SUCCEEDED(hr))
        {
            index = ListBox_AddString(hLB,szBuf);
            if (!lstrcmp(szBuf,szDefAcct))
            {
                fSelected = TRUE;
                ListBox_SetCurSel(hLB, index);
            }
        }
        pAcct->Release();
        pAcct = NULL;
    }

    // If nothing was selected as the default,
    // select the first in the list
    if (!fSelected)
        // oops, SetSel is for multiple choice list boxes
        // we want SetCurSel
        //ListBox_SetSel(hLB, TRUE, 0);
        ListBox_SetCurSel(hLB, 0);
}
**/
/*****************************************************************

  NAME:     GetAccount

  SYNOPSIS: Gets a mail or news account by name and sets the
            property information structure.

  PARAMETERS:

            szAcctName  Name of the account to load
            accttype    Type of account to load

  RETURN:   BOOL        TRUE if account was found and loaded
                        FALSE if not found

 *****************************************************************/
/**
BOOL GetAccount(LPSTR szAcctName, ACCTTYPE accttype)
{
    IImnAccount *pAcct = NULL;
    HRESULT hr;
    DWORD dwTemp = 0;
    DWORD dwServerTypes = 0;
    BOOL fRet = TRUE;

    if (NULL == gpImnAcctMgr)
        return FALSE;
    // Get the account information and move it into our
    // structure.
    hr = gpImnAcctMgr->FindAccount(AP_ACCOUNT_NAME,szAcctName,
                                     &pAcct);
    if (FAILED(hr) || !pAcct)
        return FALSE;

    // 12/3/96  jmazner Normandy #8504
    // 2/7/96   jmazner Athena changed things around a bit
    //pAcct->GetPropDw(AP_SERVER_TYPES, &dwServerTypes);
    pAcct->GetServerTypes( &dwServerTypes );

    // 2/17/96  jmazner Olympus #1063
    //                  need to clearAccount before loading new stuff
    ClearUserInfo( gpUserInfo, accttype);


    switch( accttype )
    {
        case ACCT_NEWS:
            // 12/16/96 jmazner  This is not a valid assert; sometimes we'll load
            //  in an account for mail, and later check whether it also has news
            //  Also, the macro causes a GPF in retail builds...
            //ASSERT( dwServerTypes & SRV_NNTP );

            // 2/12/97  jmazner Athena changed things around in their build 0511;
            //                  one of the changes is that now an account can only
            //                  hold one ACCT type  (see Normandy #13710)
            if( !(SRV_NNTP & dwServerTypes) )
            {
                fRet = FALSE;
                goto GetAccountExit;
            }

            pAcct->GetPropSz(AP_NNTP_DISPLAY_NAME, gpUserInfo->inc.szNNTPName, MAX_EMAIL_NAME);
            pAcct->GetPropSz(AP_NNTP_EMAIL_ADDRESS, gpUserInfo->inc.szNNTPAddress, MAX_EMAIL_ADDRESS);
            pAcct->GetPropSz(AP_NNTP_USERNAME, gpUserInfo->inc.szNNTPLogonName, MAX_LOGON_NAME);
            pAcct->GetPropSz(AP_NNTP_PASSWORD, gpUserInfo->inc.szNNTPLogonPassword, MAX_LOGON_PASSWORD);
            pAcct->GetPropSz(AP_NNTP_SERVER, gpUserInfo->inc.szNNTPServer, MAX_SERVER_NAME);
            // 12/17/96 jmazner Normandy 12871
            //pAcct->GetPropDw(AP_NNTP_USE_SICILY, &dwTemp);
            //gpUserInfo->fNewsAccount = !(BOOL)dwTemp;
            pAcct->GetPropDw(AP_NNTP_USE_SICILY, (DWORD *)&(gpUserInfo->inc.fNewsLogonSPA));
            gpUserInfo->fNewsLogon = (gpUserInfo->inc.fNewsLogonSPA || gpUserInfo->inc.szNNTPLogonName[0]);
            break;

        case ACCT_MAIL:
            if( !( (SRV_SMTP & dwServerTypes) ||
                   (SRV_POP3 & dwServerTypes) ||
                   (SRV_IMAP & dwServerTypes) ))
            {
                fRet = FALSE;
                goto GetAccountExit;
            }

            pAcct->GetPropSz(AP_SMTP_SERVER, gpUserInfo->inc.szSMTPServer, MAX_SERVER_NAME);
            pAcct->GetPropSz(AP_SMTP_DISPLAY_NAME, gpUserInfo->inc.szEMailName, MAX_EMAIL_NAME);
            pAcct->GetPropSz(AP_SMTP_EMAIL_ADDRESS, gpUserInfo->inc.szEMailAddress, MAX_EMAIL_ADDRESS);



            if( dwServerTypes & SRV_POP3 )
            {
                pAcct->GetPropSz(AP_POP3_USERNAME, gpUserInfo->inc.szIncomingMailLogonName, MAX_LOGON_NAME);
                pAcct->GetPropSz(AP_POP3_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword, MAX_LOGON_PASSWORD);
                pAcct->GetPropSz(AP_POP3_SERVER, gpUserInfo->inc.szIncomingMailServer, MAX_SERVER_NAME);
                pAcct->GetPropDw(AP_POP3_USE_SICILY, (DWORD *)&(gpUserInfo->inc.fMailLogonSPA));

                gpUserInfo->inc.iIncomingProtocol = SRV_POP3;
            }
            else
            {
                pAcct->GetPropSz(AP_IMAP_USERNAME, gpUserInfo->inc.szIncomingMailLogonName, MAX_LOGON_NAME);
                pAcct->GetPropSz(AP_IMAP_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword, MAX_LOGON_PASSWORD);
                pAcct->GetPropSz(AP_IMAP_SERVER, gpUserInfo->inc.szIncomingMailServer, MAX_SERVER_NAME);
                pAcct->GetPropDw(AP_IMAP_USE_SICILY, (DWORD *)&(gpUserInfo->inc.fMailLogonSPA));

                gpUserInfo->inc.iIncomingProtocol = SRV_IMAP;

            }
            break;

        case ACCT_DIR_SERV:
            if( !(SRV_LDAP & dwServerTypes) )
            {
                fRet = FALSE;
                goto GetAccountExit;
            }
            {
                DWORD dwLDAPAuth = 0;
                pAcct->GetPropDw(AP_LDAP_AUTHENTICATION, &dwLDAPAuth);
                switch( dwLDAPAuth )
                {
                    case LDAP_AUTH_ANONYMOUS:
                        gpUserInfo->inc.fLDAPLogonSPA = FALSE;
                        gpUserInfo->fLDAPLogon = FALSE;
                        break;
                    case LDAP_AUTH_MEMBER_SYSTEM:
                        gpUserInfo->inc.fLDAPLogonSPA = TRUE;
                        gpUserInfo->fLDAPLogon = TRUE;
                        break;
                    case LDAP_AUTH_PASSWORD:
                        gpUserInfo->inc.fLDAPLogonSPA = FALSE;
                        gpUserInfo->fLDAPLogon = TRUE;
                        pAcct->GetPropSz(AP_LDAP_USERNAME, gpUserInfo->inc.szLDAPLogonName, MAX_LOGON_NAME);
                        pAcct->GetPropSz(AP_LDAP_PASSWORD, gpUserInfo->inc.szLDAPLogonPassword, MAX_LOGON_PASSWORD);
                        break;
                }
            }



                pAcct->GetPropSz(AP_LDAP_SERVER, gpUserInfo->inc.szLDAPServer, MAX_SERVER_NAME);
                pAcct->GetPropDw(AP_LDAP_RESOLVE_FLAG, (DWORD *)&(gpUserInfo->inc.fLDAPResolve));
            break;

        default:
            fRet = FALSE;
            break;

    }

GetAccountExit:
    pAcct->Release();
    pAcct = NULL;

    return fRet;
}
**/
/*****************************************************************

  NAME:     ValidateAccountName

  SYNOPSIS: Validates that a string can be used as an account
            name.  It will also check if the account exists and
            load the information by calling GetAccount.

  PARAMETERS:

            szAcctName  String to use for the name of the account
            accttype    Type of account

  RETURN:   DWORD       0 if successful
                        Resource id of error string if an error
                        occurs.

 *****************************************************************/
/**
DWORD ValidateAccountName(LPSTR szAcctName, ACCTTYPE accttype)
{
    LPSTR sz = szAcctName;
    BOOL fBlank = TRUE;

    // Make sure the name is not blank and
    // does not contain a backslash
    while (*sz && '\\' != *sz)
    {
        if (' ' != *sz)
            fBlank = FALSE;
        sz++;
    }

    // 12/17/96 jmazner Normandy #12851
    // check for backslash first to correctly handle the string "\"
    if ('\\' == *sz)
        return IDS_ERRInvalidAcctName;
    if (fBlank)
        return IDS_NEED_ACCTNAME;

    // Check if this account already exists
    // 2/10/97  jmazner Normandy #13710
    //          If the account already exists, notify the user and force a new acct name.
    if ( AccountNameExists(szAcctName) )
    {
        return IDS_DUP_ACCTNAME;
    }

    return ERROR_SUCCESS;
}
**/
/*******************************************************************

  NAME:     SaveAccount

  SYNOPSIS: Save the changes to the mail or news account.

  PARAMETERS:

            accttype        Type of account to save (ACCT_SMTP or ACCT_NNTP)
            bSetAsDefault   Set this account to be the default

  RETURN:   BOOL    TRUE if changes saved
                    FALSE if an error occured

********************************************************************/
/**
BOOL SaveAccount(ACCTTYPE accttype, BOOL fSetAsDefault)
{
    IImnAccount *pAcct = NULL;
    LPSTR lpszAcctName = NULL;
    DWORD     dwConnectionType;
    BOOL fRet = FALSE;
    HRESULT hr;

    ASSERT (gpImnAcctMgr);
    if (NULL == gpImnAcctMgr)
        goto CommitAccountExit;

    dwConnectionType = gpUserInfo->fConnectOverLAN ? 0L : 2L;

    switch( accttype )
    {
        case ACCT_NEWS:
            lpszAcctName = gpUserInfo->szNewsAcctName;
            break;
        case ACCT_MAIL:
            lpszAcctName = gpUserInfo->szMailAcctName;
            break;
        case ACCT_DIR_SERV:
            lpszAcctName = gpUserInfo->szDirServiceName;
            break;
    }

    //  lpszAcctName = gpUserInfo->szNewsAcctName;
    //else
    //  lpszAcctName = gpUserInfo->szMailAcctName;

    // First try and get existing account info to change
    hr = gpImnAcctMgr->FindAccount(AP_ACCOUNT_NAME,
                                     lpszAcctName,
                                     &pAcct);
    if (FAILED(hr) || !pAcct)
    {
        // Create a new account
        hr = gpImnAcctMgr->CreateAccountObject(accttype, &pAcct);
        if (FAILED(hr) || !pAcct)
            goto CommitAccountExit;
    }

    // Fill in the account information that we have
    pAcct->SetPropSz(AP_ACCOUNT_NAME, lpszAcctName);
    //pAcct->SetPropSz(AP_RAS_CONNECTOID, gpUserInfo->szISPName);
    //pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dwConnectionType);

    switch( accttype )
    {
        case ACCT_NEWS:
            pAcct->SetPropSz(AP_RAS_CONNECTOID, gpUserInfo->szISPName);
            pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dwConnectionType);

            pAcct->SetPropSz(AP_NNTP_DISPLAY_NAME, gpUserInfo->inc.szNNTPName);
            pAcct->SetPropSz(AP_NNTP_EMAIL_ADDRESS, gpUserInfo->inc.szNNTPAddress);
            // 12/17/96 jmazner Normandy #12871
            //pAcct->SetPropDw(AP_NNTP_USE_SICILY, gpUserInfo->fNewsLogon && !gpUserInfo->fNewsAccount);
            pAcct->SetPropDw(AP_NNTP_USE_SICILY, gpUserInfo->inc.fNewsLogonSPA);
            if (gpUserInfo->fNewsLogon && !gpUserInfo->inc.fNewsLogonSPA)
            {
                pAcct->SetPropSz(AP_NNTP_USERNAME, gpUserInfo->inc.szNNTPLogonName);
                pAcct->SetPropSz(AP_NNTP_PASSWORD, gpUserInfo->inc.szNNTPLogonPassword);
            }
            else
            {
                // 1/15/96 jmazner Normandy #13162
                // clear out logon name and password, so that if we load in this account
                // in the future, we won't be confused about whether to set fNewsLogon
                pAcct->SetProp(AP_NNTP_USERNAME, NULL, 0);
                pAcct->SetProp(AP_NNTP_PASSWORD, NULL, 0);
            }


            pAcct->SetPropSz(AP_NNTP_SERVER, gpUserInfo->inc.szNNTPServer);
            break;

        case ACCT_MAIL:
            pAcct->SetPropSz(AP_RAS_CONNECTOID, gpUserInfo->szISPName);
            pAcct->SetPropDw(AP_RAS_CONNECTION_TYPE, dwConnectionType);

            pAcct->SetPropSz(AP_SMTP_SERVER, gpUserInfo->inc.szSMTPServer);
            pAcct->SetPropSz(AP_SMTP_DISPLAY_NAME, gpUserInfo->inc.szEMailName);
            pAcct->SetPropSz(AP_SMTP_EMAIL_ADDRESS, gpUserInfo->inc.szEMailAddress);

            // 12/3/96  jmazner Normandy #8504
            if( SRV_POP3 == gpUserInfo->inc.iIncomingProtocol )
            {
                pAcct->SetPropSz(AP_POP3_SERVER, gpUserInfo->inc.szIncomingMailServer);
                // 12/17/96 jmazner Normandy #12871
                pAcct->SetPropDw(AP_POP3_USE_SICILY, gpUserInfo->inc.fMailLogonSPA);
                if( !gpUserInfo->inc.fMailLogonSPA )
                {
                    pAcct->SetPropSz(AP_POP3_USERNAME, gpUserInfo->inc.szIncomingMailLogonName);
                    pAcct->SetPropSz(AP_POP3_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword);
                }

                pAcct->SetProp(AP_IMAP_USERNAME, NULL, 0);
                pAcct->SetProp(AP_IMAP_SERVER, NULL, 0);
                pAcct->SetProp(AP_IMAP_PASSWORD, NULL, 0);

            }
            else
            {
                pAcct->SetPropSz(AP_IMAP_SERVER, gpUserInfo->inc.szIncomingMailServer);
                // 12/17/96 jmazner Normandy #12871
                pAcct->SetPropDw(AP_IMAP_USE_SICILY, gpUserInfo->inc.fMailLogonSPA);
                if( !gpUserInfo->inc.fMailLogonSPA )
                {
                    pAcct->SetPropSz(AP_IMAP_USERNAME, gpUserInfo->inc.szIncomingMailLogonName);
                    pAcct->SetPropSz(AP_IMAP_PASSWORD, gpUserInfo->inc.szIncomingMailLogonPassword);
                }

                pAcct->SetProp(AP_POP3_USERNAME, NULL, 0);
                pAcct->SetProp(AP_POP3_SERVER, NULL, 0);
                pAcct->SetProp(AP_POP3_PASSWORD, NULL, 0);
            }
            break;

        case ACCT_DIR_SERV:
            pAcct->SetPropSz(AP_LDAP_SERVER, gpUserInfo->inc.szLDAPServer);
            pAcct->SetPropDw(AP_LDAP_RESOLVE_FLAG, gpUserInfo->inc.fLDAPResolve);

            if( gpUserInfo->inc.szLDAPLogonName[0] && gpUserInfo->fLDAPLogon )
            {
                // if we have a user name, then we're using
                // LDAP_AUTH_PASSWORD
                ASSERT( !gpUserInfo->inc.fLDAPLogonSPA );
                pAcct->SetPropSz(AP_LDAP_USERNAME, gpUserInfo->inc.szLDAPLogonName);
                pAcct->SetPropSz(AP_LDAP_PASSWORD, gpUserInfo->inc.szLDAPLogonPassword);
                pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, LDAP_AUTH_PASSWORD);
            }
            else
            {
                //we know there's no username/password, so clear out those fields
                pAcct->SetProp(AP_LDAP_USERNAME, NULL, 0);
                pAcct->SetProp(AP_LDAP_PASSWORD, NULL, 0);

                //now determine whether there's no logon required, or if we're using SPA
                if( gpUserInfo->inc.fLDAPLogonSPA )
                {
                    pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, LDAP_AUTH_MEMBER_SYSTEM);
                }
                else
                {
                    pAcct->SetPropDw(AP_LDAP_AUTHENTICATION, LDAP_AUTH_ANONYMOUS);
                }
            }
            break;


    }

    // Save the changes
    hr = pAcct->SaveChanges();
    if (FAILED(hr))
        goto CommitAccountExit;

    if (fSetAsDefault)
    {
        // Set this account as the default
        // Ignore failure since it isn't fatal
        pAcct->SetAsDefault();
    }

    // If we need to return the settings, put them in the global struct
    if (gpMailNewsInfo && ( (ACCT_MAIL==accttype) || (ACCT_NEWS==accttype) ) )
    {
        ASSERT(sizeof(*gpMailNewsInfo) == gpMailNewsInfo->dwSize);
        
        if (ACCT_NEWS == accttype)
        {
            lstrcpy(gpMailNewsInfo->szAccountName, gpUserInfo->szNewsAcctName);
            lstrcpy(gpMailNewsInfo->szUserName, gpUserInfo->inc.szNNTPLogonName);
            lstrcpy(gpMailNewsInfo->szPassword, gpUserInfo->inc.szNNTPLogonPassword);
            lstrcpy(gpMailNewsInfo->szNNTPServer, gpUserInfo->inc.szNNTPServer);
            lstrcpy(gpMailNewsInfo->szDisplayName, gpUserInfo->inc.szNNTPName);
            lstrcpy(gpMailNewsInfo->szEmailAddress, gpUserInfo->inc.szNNTPAddress);

            // 12/17/96 jmazner Normandy #12871
            // fNewsLogon and fNewsAccount flags have been superceeded by fNewsLogonSPA
            //gpMailNewsInfo->fUseSicily = (gpUserInfo->fNewsLogon && !gpUserInfo->fNewsAccount);
            gpMailNewsInfo->fUseSicily = (gpUserInfo->inc.fNewsLogonSPA);
        }
        else
        {
            lstrcpy(gpMailNewsInfo->szAccountName, gpUserInfo->szMailAcctName);
            lstrcpy(gpMailNewsInfo->szUserName, gpUserInfo->inc.szIncomingMailLogonName);
            lstrcpy(gpMailNewsInfo->szPassword, gpUserInfo->inc.szIncomingMailLogonPassword);
            lstrcpy(gpMailNewsInfo->szSMTPServer, gpUserInfo->inc.szSMTPServer);

            if( SRV_POP3 == gpUserInfo->inc.iIncomingProtocol )
                lstrcpy(gpMailNewsInfo->szPOP3Server, gpUserInfo->inc.szIncomingMailServer);
            else
                lstrcpy(gpMailNewsInfo->szIMAPServer, gpUserInfo->inc.szIncomingMailServer);

            lstrcpy(gpMailNewsInfo->szDisplayName, gpUserInfo->inc.szEMailName);
            lstrcpy(gpMailNewsInfo->szEmailAddress, gpUserInfo->inc.szEMailAddress);

            gpMailNewsInfo->fUseSicily = (gpUserInfo->inc.fMailLogonSPA);
        }

        gpMailNewsInfo->dwConnectionType = dwConnectionType;
        lstrcpy(gpMailNewsInfo->szConnectoid, gpUserInfo->szISPName);
    }
    else if( gpDirServiceInfo && (ACCT_DIR_SERV == accttype) )
    {
        ASSERT(sizeof(*gpDirServiceInfo) == gpDirServiceInfo->dwSize);

        lstrcpy(gpDirServiceInfo->szServiceName, gpUserInfo->szDirServiceName);
        lstrcpy(gpDirServiceInfo->szUserName, gpUserInfo->inc.szLDAPLogonName);
        lstrcpy(gpDirServiceInfo->szPassword, gpUserInfo->inc.szLDAPLogonPassword);
        lstrcpy(gpDirServiceInfo->szLDAPServer, gpUserInfo->inc.szLDAPServer);
        gpDirServiceInfo->fUseSicily = (gpUserInfo->inc.fMailLogonSPA);
        gpDirServiceInfo->fLDAPResolve = (gpUserInfo->inc.fLDAPResolve);
    }


    fRet = TRUE;

CommitAccountExit:
    
    if (pAcct)
    {
        pAcct->Release();
        pAcct = NULL;
    }

    return fRet;
}
**/

/*****************************************************************

  NAME:     IsStringWhiteSpaceOnly

  SYNOPSIS: Checks whether a string has non space characters

  PARAMETERS:

            szString    String to check


  RETURN:   BOOL        TRUE if no characters other than ' '
                        FALSE otherwise

 *****************************************************************/
/**
BOOL IsStringWhiteSpaceOnly(LPSTR szString)
{
    LPSTR sz = szString;

    while (*sz)
    {
        if (' ' != *sz)
            return FALSE;
        sz++;
    }
    
    return TRUE;
}
**/

/*****************************************************************

  NAME:     AccountNameExists

  SYNOPSIS: Checks whether a given string is currently in use as
            an Account Manager (inetcomm) account name

  PARAMETERS:

            szAcctName  Name of the account to load

  RETURN:   BOOL        TRUE if account name is in use
                        FALSE if not

  HISTORY:  2/10/96     jmazner Created

 *****************************************************************/
/**
BOOL AccountNameExists(LPSTR szAcctName)
{
    IImnAccount *pAcct = NULL;
    HRESULT hr;

    if (NULL == gpImnAcctMgr)
        return FALSE;

    if (NULL == szAcctName)
        return FALSE;


    hr = gpImnAcctMgr->FindAccount(AP_ACCOUNT_NAME,szAcctName,
                                     &pAcct);
    if (FAILED(hr) || !pAcct)
    {
        return FALSE;
    }
    else
    {
        pAcct->Release();
        pAcct = NULL;
        return TRUE;
    }
}
**/
//+----------------------------------------------------------------------------
//
//  Function    ClearUserInfo
//
//  Synopsis    Sets the fields in a USERINFO struct to NULL.
//
//  Arguments   lpUserinfo - the struct to clear out.
//              accttype - determines whether Mail or News fields are cleared out
//
//  Returns     TRUE if all went well
//              FALSE otherwise
//
//  History     1/21/96 jmazner     created
//
//-----------------------------------------------------------------------------
/**
BOOL ClearUserInfo( USERINFO *lpUserInfo, ACCTTYPE accttype )
{
    if( NULL == lpUserInfo )
        return FALSE;

    switch( accttype ){
    case ACCT_NEWS:
        //lpUserInfo->szNewsAcctName[0] = '\0';
        lpUserInfo->inc.szNNTPLogonName[0] = '\0';
        lpUserInfo->inc.szNNTPLogonPassword[0] = '\0';
        lpUserInfo->inc.szNNTPServer[0] = '\0';
        lpUserInfo->inc.szNNTPName[0] = '\0';
        lpUserInfo->inc.szNNTPAddress[0] = '\0';
        lpUserInfo->inc.fNewsLogonSPA = FALSE;
        lpUserInfo->fNewsLogon = FALSE;
        return TRUE;
        break;
    case ACCT_MAIL:
        //lpUserInfo->szMailAcctName[0] = '\0';
        lpUserInfo->inc.szIncomingMailLogonName[0] = '\0';
        lpUserInfo->inc.szIncomingMailLogonPassword[0] = '\0';
        lpUserInfo->inc.szSMTPServer[0] = '\0';
        lpUserInfo->inc.iIncomingProtocol = SRV_POP3;
        lpUserInfo->inc.szIncomingMailServer[0] = '\0';
        lpUserInfo->inc.szEMailName[0] = '\0';
        lpUserInfo->inc.szEMailAddress[0] = '\0';
        lpUserInfo->inc.fMailLogonSPA = FALSE;
        return TRUE;
        break;
    case ACCT_DIR_SERV:
        //lpUserInfo->szDirServiceName[0] = '\0';
        lpUserInfo->inc.szLDAPLogonName[0] = '\0';
        lpUserInfo->inc.szLDAPLogonPassword[0] = '\0';
        lpUserInfo->inc.szLDAPServer[0] = '\0';
        lpUserInfo->inc.fLDAPResolve = FALSE;
        lpUserInfo->inc.fLDAPLogonSPA = FALSE;
        lpUserInfo->fLDAPLogon = FALSE;

    default:
        return FALSE;
        break;
    }
}
**/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\ispupgui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPUPGUI.C - Functions for Wizard pages to use existing Internet Service Provider
//        (ISP) -- e.g. upgrade
//

//  HISTORY:
//  
//  1/6/95    jeremys  Created.
//  96/03/09  markdu  Moved all references to 'need terminal window after
//            dial' into RASENTRY.dwfOptions.
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/10  markdu  Moved all references to phone number into RASENTRY.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/03/26  markdu  Store values from UI even when back is pressed.
//  96/04/04  markdu  Added phonebook name param to ValidateConnectoidName.
//  96/04/07  markdu  NASH BUG 15645 Enable phone number controls based on
//            user's selection for dial-as-is checkbox.  Don't require an
//            area code when dial-as-is selected.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//

#include "wizard.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"
#include "pagefcns.h"

#define TAB_PAGES 2   
INT_PTR CALLBACK TabConnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK TabAddrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

VOID EnableWizard(HWND hDlg,BOOL fEnable);
VOID EnableConnectionControls(HWND hDlg);
VOID EnablePhoneNumberControls(HWND hDlg);
VOID EnableScriptControls(HWND hDlg);
DWORD BrowseScriptFile(HWND hDlg);
BOOL CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);

// This flag is used to indicate that gpRasEntry has been filled with
// data from a connectoid at some point.
BOOL  fEntryHasBeenLoaded = FALSE;
DWORD gdwDefCountryID = 0;

/*******************************************************************

  NAME:    ConnectionInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

        Note that code in HowToConnectOKProc ensures that if we make it
        here, there is at least one connectoid on the system

********************************************************************/
BOOL CALLBACK ConnectionInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // populate the connectoid list box with list of connectoids
    InitConnectoidList(GetDlgItem(hDlg,IDC_ISPNAME),gpUserInfo->szISPName);

    ProcessDBCS(hDlg, IDC_ISPNAME);

//  // Set fields
//  CheckDlgButton(hDlg,IDC_NEWCONNECTION,gpUserInfo->fNewConnection);
//  CheckDlgButton(hDlg,IDC_EXISTINGCONNECTION,!gpUserInfo->fNewConnection);

    // store a default selection in the listbox if there isn't
    // currently a default
    if( LB_ERR == ListBox_GetCurSel(GetDlgItem(hDlg,IDC_ISPNAME)) )
    {
        ListBox_SetCurSel(GetDlgItem(hDlg,IDC_ISPNAME), 0);

        //
        // ChrisK Olympus 7509 6/25/97
        // If the default was not set, then don't select Existing connection
        //
        // Set fields
        CheckDlgButton(hDlg,IDC_NEWCONNECTION,TRUE);
        CheckDlgButton(hDlg,IDC_EXISTINGCONNECTION,FALSE);
    }
    else
    {
        //
        // If there is a default already selected, then select "Use an
        // existing connection".
        //
        CheckDlgButton(hDlg,IDC_NEWCONNECTION,FALSE);
        CheckDlgButton(hDlg,IDC_EXISTINGCONNECTION,TRUE);
    }

    EnableConnectionControls(hDlg);

    // load in strings for the description paragraph
    TCHAR szWhole[ (2 * MAX_RES_LEN) + 1] = TEXT("\0");
    TCHAR szTemp[ MAX_RES_LEN + 1] = TEXT("nothing\0");
    LoadSz(IDS_CONNECTION_DESC1,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 
    LoadSz(IDS_CONNECTION_DESC2,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 

    SetWindowText (GetDlgItem(hDlg,IDC_DESC), szWhole);

  }
  
  // if we've travelled through external apprentice pages,
  // it's easy for our current page pointer to get munged,
  // so reset it here for sanity's sake.
  gpWizardState->uCurrentPage = ORD_PAGE_CONNECTION;


  return FALSE;
}

/*******************************************************************

  NAME:    ConnectionOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);

  if (fForward)
  {
    gpUserInfo->fNewConnection = IsDlgButtonChecked(hDlg, IDC_NEWCONNECTION);
    if (gpUserInfo->fNewConnection)
    {
        if (gfFirstNewConnection)
        {
            // The first time through we want to set everything to default
            // for the novice user.  If the user backs up and returns to
            // create new connection, we want to leave whatever was there
            // from before.
            gfFirstNewConnection = FALSE;

            // set the connectoid entries to their defaults
            InitRasEntry(gpRasEntry);
            gpUserInfo->fModifyConnection = FALSE;
            gpUserInfo->fModifyAdvanced = FALSE;
            gpUserInfo->fAutoDNS = TRUE;
            gpUserInfo->szISPName[0] = '\0';
        }
        // 5/8/97 jmazner Olympus #4108
        // move connectionName to the end
        //*puNextPage = ORD_PAGE_CONNECTIONNAME;

        *puNextPage = ORD_PAGE_PHONENUMBER;
    }
    else
    {
        // Copy the current name into a temp for comparison purposes
        TCHAR szISPNameTmp[MAX_ISP_NAME + 1];
        lstrcpy(szISPNameTmp, gpUserInfo->szISPName);

        // get ISP name from UI
        ListBox_GetText(GetDlgItem(hDlg,IDC_ISPNAME),
                        ListBox_GetCurSel(GetDlgItem(hDlg,IDC_ISPNAME)),
                        gpUserInfo->szISPName);

        // If the entry we pulled from the UI does NOT match our 
        // string, we want to process this entry name 
        // since we have not seen this entry yet.  
        // If we have already loaded the data for this entry, though,
        // we don't want to mess with it since the user may have gone ahead.
        // changed something, and then come back.
        // Note:  The first time through, the entry will match even
        // though we haven't yet loaded the data, so we have to check the flag.
        if ((FALSE == fEntryHasBeenLoaded) ||
          lstrcmp(gpUserInfo->szISPName, szISPNameTmp))
        {
          // Since we are going to either reinit the RASENTRY struct
          // or load an existing one over top, we need to store
          // all info we have collected so far
          TCHAR szDeviceNameTmp[RAS_MaxDeviceName + 1];
          TCHAR szDeviceTypeTmp[RAS_MaxDeviceType + 1];
          lstrcpy(szDeviceNameTmp, gpRasEntry->szDeviceName);
          lstrcpy(szDeviceTypeTmp, gpRasEntry->szDeviceType);

          // Get dialing params for this connectoid
          DWORD dwRet = GetEntry(&gpRasEntry, &gdwRasEntrySize, gpUserInfo->szISPName);
          if (ERROR_SUCCESS != dwRet)
          {
            // For some reason we failed, initialize back to defaults and
            // ask user to select a different one
            InitRasEntry(gpRasEntry);
            DisplayFieldErrorMsg(hDlg,IDC_ISPNAME,IDS_ERRCorruptConnection);
            return FALSE;
          }
        
          GetConnectoidUsername(gpUserInfo->szISPName,gpUserInfo->szAccountName,
              sizeof(gpUserInfo->szAccountName),gpUserInfo->szPassword,
              sizeof(gpUserInfo->szPassword));

          // Restore the data from temporary variables.
          lstrcpy(gpRasEntry->szDeviceName, szDeviceNameTmp);
          lstrcpy(gpRasEntry->szDeviceType, szDeviceTypeTmp);

          // Set the flag to indicate that we have done this once
          fEntryHasBeenLoaded = TRUE;
    }

        // set next page to go to
        if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
        {
            // we're about to jump back to the external wizard, and we don't want
            // this page to show up in our history list
            *pfKeepHistory = FALSE;

            *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTION97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTION);
            
            g_fConnectionInfoValid = TRUE;

        }
        else
            *puNextPage = ORD_PAGE_MODIFYCONNECTION;
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    ConnectionCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK ConnectionCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case IDC_NEWCONNECTION:
    case IDC_EXISTINGCONNECTION:
        // if check box selected, enable controls appropriately
        EnableConnectionControls(hDlg);
        break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    EnableConnectionControls

  SYNOPSIS:  If "Use existing connection" is checked, enable controls
             existing connections.  If not, disable them.

********************************************************************/
VOID EnableConnectionControls(HWND hDlg)
{
    static int iSelection = -1;
    static BOOL bCurStateNew = FALSE;

    BOOL fNew = IsDlgButtonChecked(hDlg,IDC_NEWCONNECTION);
  
    // jmazner 11/9/96 Normandy #8469 and #8293
    if (fNew)
    {
        // if user uses the keybd arrows to go from "new" to "existing",
        // we get called _twice_ here; once when "new" is still checked,
        // and then again when we're expecting it.  This screws us up,
        // because in the first call, the list box is disabled and cur
        // sel is set to -1, and that gets written into iSelection,
        // obliterating the value we were saving.  So use the bCurStateNew
        // flag to prevent this.
        if( bCurStateNew )
          return;

        bCurStateNew = TRUE;
        // save, and then clear out current selection before disabling
        // note that if there's no selection, GetCurSel returns LB_ERR,
        // but we want to save -1, since that's what we use in SetCurSel
        // to remove all selections.
        iSelection = ListBox_GetCurSel(GetDlgItem(hDlg,IDC_ISPNAME));
        if( LB_ERR == iSelection )
          iSelection = -1;

        ListBox_SetCurSel(GetDlgItem(hDlg,IDC_ISPNAME), -1);
        EnableDlgItem(hDlg,IDC_ISPNAME,FALSE);
    }
    else
    {
        bCurStateNew = FALSE;
        EnableDlgItem(hDlg,IDC_ISPNAME,TRUE);
        ListBox_SetCurSel(GetDlgItem(hDlg,IDC_ISPNAME), iSelection);
    }
}

/*******************************************************************

  NAME:    ModifyConnectionInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ModifyConnectionInitProc(HWND hDlg,BOOL fFirstInit)
{
  static TCHAR szCurConnectoid[MAX_ISP_NAME + 1] = TEXT("");

  if (fFirstInit)
  {

    TCHAR szMsg[MAX_RES_LEN + MAX_ISP_NAME + 1];
    TCHAR szFmt[MAX_RES_LEN+1];
    LoadSz(IDS_MODIFYCONNECTION,szFmt,sizeof(szFmt));
    wsprintf(szMsg,szFmt,gpUserInfo->szISPName);

    ProcessDBCS(hDlg, IDC_LBLMODIFYCONNECTION);
    SetDlgItemText(hDlg,IDC_LBLMODIFYCONNECTION,szMsg);

    // keep track of current connectoid name for future compares
    lstrcpyn( szCurConnectoid, gpUserInfo->szISPName, MAX_ISP_NAME );

    CheckDlgButton(hDlg,IDC_MODIFYCONNECTION,gpUserInfo->fModifyConnection);
    CheckDlgButton(hDlg,IDC_NOMODIFYCONNECTION,!(gpUserInfo->fModifyConnection));
  }
  else
  {
    // jmazner 11/9/96 Normandy #10605
    // if the user changed connectoids, update the dialog text
    if( lstrcmp(szCurConnectoid, gpUserInfo->szISPName) )
    {
        TCHAR szMsg[MAX_RES_LEN + MAX_ISP_NAME + 1];
        TCHAR szFmt[MAX_RES_LEN+1];
        LoadSz(IDS_MODIFYCONNECTION,szFmt,sizeof(szFmt));
        wsprintf(szMsg,szFmt,gpUserInfo->szISPName);
        SetDlgItemText(hDlg,IDC_LBLMODIFYCONNECTION,szMsg);

        // store new connectoid name for future compares
        lstrcpyn( szCurConnectoid, gpUserInfo->szISPName, MAX_ISP_NAME );
    }
  }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_MODIFYCONNECTION;

  return TRUE;
}

/*******************************************************************

  NAME:    ModifyConnectionOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ModifyConnectionOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);
  OSVERSIONINFO osver;

  if (fForward)
  {

      // we can not programatically alter a CSLIP connection.  So if they picked
      // one, do not allow them to continue down the "modify" path.
      if ( (RASFP_Slip == gpRasEntry->dwFramingProtocol) 
          && (RASEO_IpHeaderCompression & gpRasEntry->dwfOptions) &&
          IsDlgButtonChecked(hDlg, IDC_MODIFYCONNECTION))
      {
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        GetVersionEx(&osver);
        if (VER_PLATFORM_WIN32_WINDOWS == osver.dwPlatformId)
        {
          MsgBox(hDlg,IDS_ERRModifyCSLIP,MB_ICONEXCLAMATION,MB_OK);
          return FALSE;
        }
      }

      gpUserInfo->fModifyConnection = IsDlgButtonChecked(hDlg, IDC_MODIFYCONNECTION);
      if (gpUserInfo->fModifyConnection)
      {
        *puNextPage = ORD_PAGE_PHONENUMBER;
      }
      else
      {
          if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
          {
              // we're about to jump back to the external wizard, and we don't want
              // this page to show up in our history list
              *pfKeepHistory = FALSE;

              *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_MODIFYCONNECTION97);
            else                
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_MODIFYCONNECTION);

            g_fConnectionInfoValid = TRUE;


          }
          else if( LoadAcctMgrUI(GetParent(hDlg), 
                                 g_fIsWizard97 ? IDD_PAGE_MODIFYCONNECTION97 : IDD_PAGE_MODIFYCONNECTION, 
                                 g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                                 g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
          {
              if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
              {
                  // we're about to jump into the external apprentice, and we don't want
                  // this page to show up in our history list
                  *pfKeepHistory = FALSE;

                  *puNextPage = g_uAcctMgrUIFirst;
              }
              else
              {
                  DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                            g_uAcctMgrUIFirst);
                  *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
              }
          }
          else
          {
              DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

          }
      }

  }
  
  return TRUE;
}

/*******************************************************************

  NAME:    ConnectionNameInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ConnectionNameInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // limit text fields appropriately
    SendDlgItemMessage(hDlg,IDC_CONNECTIONNAME,EM_LIMITTEXT,
      MAX_ISP_NAME,0L);

    ProcessDBCS(hDlg, IDC_CONNECTIONNAME);

  }

  // fill text fields
  //
  // 5/17/97 jmazner Olympus #4608 and 4108
  // do this in all cases to pick up any changes from the
  // PhoneNumber pae.
  //
  SetDlgItemText(hDlg,IDC_CONNECTIONNAME,gpUserInfo->szISPName);

  return TRUE;
}

/*******************************************************************

  NAME:    ConnectionNameOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectionNameOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  ASSERT(puNextPage);

  // 5/8/97 jmazner Olympus #4108
  // reworked this function to take into acct that this page is now
  // at the _end_ of the series of dialogs, so it shouln't try to
  // fill in defaults.

  //
  // get ISP name from UI
  //
  // 5/17/97 jmazner Olympus #4108 update (see also #4608)
  // Do this even if we're going backwards so that the default name code in
  // PhoneNumberOKProc will know if the user has changed the connectoid name.
  //
  GetDlgItemText(hDlg,IDC_CONNECTIONNAME,gpUserInfo->szISPName,
  sizeof(gpUserInfo->szISPName));

 if (fForward)
  {
    // Copy the current name into a temp for comparison purposes
    //CHAR szISPNameTmp[MAX_ISP_NAME + 1];
    //lstrcpy(szISPNameTmp, gpUserInfo->szISPName);


    // make sure user typed a service provider name
    if (!lstrlen(gpUserInfo->szISPName))
    {
      DisplayFieldErrorMsg(hDlg,IDC_CONNECTIONNAME,IDS_NEED_ISPNAME);
      return FALSE;
    }

    // validate the ISP name, which will be used later as the
    // name of an RNA connectoid
    DWORD dwRet = ValidateConnectoidName(NULL, gpUserInfo->szISPName);
    if (dwRet == ERROR_ALREADY_EXISTS)
    {
        DisplayFieldErrorMsg(hDlg,IDC_CONNECTIONNAME,IDS_ERRDuplicateConnectoidName);
        return FALSE;
    }
    else if (dwRet != ERROR_SUCCESS)
    {
        // 12/19/96 jmazner Normandy #12890
        // Legal connectoid names are different under w95 and NT
        if( IsNT() )
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidNameNT,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }
        else
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidName95,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }

        // 12/17/96 jmazner Normandy #12851
        // if the validate failed, remove the name from the UserInfo struct
        gpUserInfo->szISPName[0] = '\0';

        // select ISP name in dialog and fail the OK command
        SetFocus(GetDlgItem(hDlg,IDC_CONNECTIONNAME));
        SendDlgItemMessage(hDlg,IDC_CONNECTIONNAME,EM_SETSEL,0,-1);
        return FALSE;
    }


    /**
    if ((FALSE == fEntryHasBeenLoaded) ||
      lstrcmp(gpUserInfo->szISPName, szISPNameTmp))
    {
      // Since we are going to either reinit the RASENTRY struct
      // or load an existing one over top, we need to store
      // all info we have collected so far
      TCHAR szDeviceNameTmp[RAS_MaxDeviceName + 1];
      TCHAR szDeviceTypeTmp[RAS_MaxDeviceType + 1];
      lstrcpy(szDeviceNameTmp, gpRasEntry->szDeviceName);
      lstrcpy(szDeviceTypeTmp, gpRasEntry->szDeviceType);

      // validate the ISP name, which will be used later as the
      // name of an RNA connectoid
      DWORD dwRet = ValidateConnectoidName(NULL, gpUserInfo->szISPName);

      if (dwRet == ERROR_ALREADY_EXISTS)
      {
        // this connectoid already exists.  Re-use it, and get
        // dialing params for this connectoid
        dwRet = GetEntry(&gpRasEntry, &gdwRasEntrySize, gpUserInfo->szISPName);
        if (ERROR_SUCCESS != dwRet)
        {
          // For some reason we failed, so just re-init to default
          InitRasEntry(gpRasEntry);
        }
        
        GetConnectoidUsername(gpUserInfo->szISPName,gpUserInfo->szAccountName,
          sizeof(gpUserInfo->szAccountName),gpUserInfo->szPassword,
          sizeof(gpUserInfo->szPassword));

      }
      else if (dwRet != ERROR_SUCCESS)
      {
        // 12/19/96 jmazner Normandy #12890
        // Legal connectoid names are different under w95 and NT
        if( IsNT() )
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidNameNT,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }
        else
        {
            MsgBoxParam(hDlg,IDS_ERRConnectoidName95,MB_ICONEXCLAMATION,MB_OK,
                gpUserInfo->szISPName);
        }

        // 12/17/96 jmazner Normandy #12851
        // if the validate failed, remove the name from the UserInfo struct
        gpUserInfo->szISPName[0] = '\0';

        // select ISP name in dialog and fail the OK command
        SetFocus(GetDlgItem(hDlg,IDC_CONNECTIONNAME));
        SendDlgItemMessage(hDlg,IDC_CONNECTIONNAME,EM_SETSEL,0,-1);
        return FALSE;
      }
      else
      {
        // Normandy 13018 - ChrisK 1-9-97
        // Default username has been set to <blank>
        //// this connectoid doesn't exist yet.  Clear out connectoid-specifc
        //// information from user struct, because we might have
        //// info from other connectoids in struct if user chose a connectoid,
        //// then backed up and typed a different name
        //GetDefaultUserName(gpUserInfo->szAccountName,sizeof(gpUserInfo->szAccountName));
        gpUserInfo->szAccountName[0] = '\0';
        gpUserInfo->szPassword[0] = '\0';

        // initialize the rasentry structure
        InitRasEntry(gpRasEntry);
      }

      // Restore the data from temporary variables.
      lstrcpy(gpRasEntry->szDeviceName, szDeviceNameTmp);
      lstrcpy(gpRasEntry->szDeviceType, szDeviceTypeTmp);

      // Set the flag to indicate that we have done this once
      fEntryHasBeenLoaded = TRUE;
    }
    **/

    // set next page to go to
    //*puNextPage = ORD_PAGE_PHONENUMBER;
    if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
    {
          // we're about to jump back to the external wizard, and we don't want
          // this page to show up in our history list
          *pfKeepHistory = FALSE;

          *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTIONNAME97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_CONNECTIONNAME);

            g_fConnectionInfoValid = TRUE;

    }
    else if( LoadAcctMgrUI(GetParent(hDlg), 
                           g_fIsWizard97 ? IDD_PAGE_CONNECTIONNAME97 : IDD_PAGE_CONNECTIONNAME, 
                           g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                           g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
    {
          if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
          {
              // we're about to jump into the external apprentice, and we don't want
              // this page to show up in our history list
              *pfKeepHistory = FALSE;

              *puNextPage = g_uAcctMgrUIFirst;
          }
          else
          {
              DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                        g_uAcctMgrUIFirst);
              *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
          }
      }
      else
      {
          DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
          *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

    }

  }

  return TRUE;
}

/*******************************************************************

  NAME:    PhoneNumberInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK PhoneNumberInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (IsNT5())
    {
        TCHAR szTemp[ MAX_RES_LEN + 1] = TEXT("\0");
        LoadSz(IDS_USEDIALRULES, szTemp, sizeof(szTemp));
        SetWindowText(GetDlgItem(hDlg, IDC_USEDIALRULES), szTemp);
    }

    if (fFirstInit)
    {
        // limit text fields appropriately
        SendDlgItemMessage(hDlg,IDC_AREACODE,EM_LIMITTEXT,
          MAX_UI_AREA_CODE,0L);
        SendDlgItemMessage(hDlg,IDC_PHONENUMBER,EM_LIMITTEXT,
          MAX_UI_PHONENUM,0L);

        // initialize text fields
        SetDlgItemText(hDlg,IDC_AREACODE,gpRasEntry->szAreaCode);
        SetDlgItemText(hDlg,IDC_PHONENUMBER,gpRasEntry->szLocalPhoneNumber);

        // initialize dial-as-is checkbox
        CheckDlgButton(hDlg,IDC_USEDIALRULES,
        gpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes);

    }
    else
    {

        ProcessDBCS(hDlg, IDC_COUNTRYCODE);

        //
        // 5/17/97 jmazner Olympus #4608
        // if user didn't have a modem when they started down the manual path,
        // then InitRasEntry couldn't fill in an area code.  If it looks
        // like that happened, try calling InitRasEntry again.
        //
        // 6/3/97 jmazner Olympus #5657
        // Ah, but if Dial-as-is is selected, there probably won't be an area
        // code.  So don't re-init in that case.
        //
        // 7/16/97 jmazner Olympus #9571
        // the saga continues -- there are some cases (eg: Kuwait) where it's
        // perfectly valid to have an empty area code but still use TAPI
        // dialing rules.  To make life easier, move this code into HowToConnectOKProc
        // so that we call it _before_ any user information has been entered into the
        // gpRasEntry struct.
        //
        //if( (NULL == gpRasEntry->szAreaCode[0]) &&
        //  (gpRasEntry->dwfOptions & RASEO_UseCountryAndAreaCodes) )
        //{
        //  InitRasEntry( gpRasEntry );
        //}

        HWND hwndCB = GetDlgItem(hDlg,IDC_COUNTRYCODE);

        // put default RNA country code in combo box
        InitCountryCodeList(hwndCB);

        // Normandy 13097 - ChrisK 1/8/97
        // The default selection should be based on the Country ID not the code

        // select country ID if we already have a default

        if (gdwDefCountryID) 
        {
            gpRasEntry->dwCountryID = gdwDefCountryID;
            if (!SetCountryIDSelection(hwndCB, gdwDefCountryID)) 
            {
                // country code for default connectoid is not the same
                // as default RNA country code, fill in the listbox with
                // all country codes and then try selection again
                FillCountryCodeList(hwndCB);
                // if this one fails, then just give up
                BOOL fRet=SetCountryIDSelection(hwndCB, gdwDefCountryID);
                ASSERT(fRet);
            }
        }

        // enable controls appropriately
        EnablePhoneNumberControls(hDlg);
    }
    gpWizardState->uCurrentPage = ORD_PAGE_PHONENUMBER;

    return TRUE;
}

/*******************************************************************

  NAME:    PhoneNumberOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK PhoneNumberOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
  static TCHAR s_szPreviousDefaultName[MAX_ISP_NAME+1] = TEXT("\0uninitialized");
  TCHAR szNewDefaultName[MAX_ISP_NAME + 1] = TEXT("\0");

  ASSERT(puNextPage);

  // get area code and phone number out of dialog
  GetDlgItemText(hDlg,IDC_AREACODE,gpRasEntry->szAreaCode,
    sizeof(gpRasEntry->szAreaCode));
  GetDlgItemText(hDlg,IDC_PHONENUMBER,gpRasEntry->szLocalPhoneNumber,
    sizeof(gpRasEntry->szLocalPhoneNumber));

  // get selected country code from combo box
  LPCOUNTRYCODE lpCountryCode;
  GetCountryCodeSelection(GetDlgItem(hDlg,IDC_COUNTRYCODE),&lpCountryCode);

  // Store country code info in our struct
  gpRasEntry->dwCountryCode = lpCountryCode->dwCountryCode;
  gpRasEntry->dwCountryID =   lpCountryCode->dwCountryID;
  gdwDefCountryID = gpRasEntry->dwCountryID;

  // set the dial-as-is flag appropriately;
  if (IsDlgButtonChecked(hDlg,IDC_USEDIALRULES))
  {
    gpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;    
  }
  else
  {
    gpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;    
  }

  if (fForward)
  {
    // make sure user typed in a phone number
    if (!lstrlen(gpRasEntry->szLocalPhoneNumber))
    {
      DisplayFieldErrorMsg(hDlg,IDC_PHONENUMBER,IDS_NEED_PHONENUMBER);
      return FALSE;
    }

    // 11/11/96 jmazner Normandy #7623
    // make sure phone number has only valid chars
    //
    // 5/17/97  jmazner Olympus #137
    // that includes checking for DBCS chars.

#if !defined(WIN16)
    if (!IsSBCSString(gpRasEntry->szLocalPhoneNumber))
    {
        DisplayFieldErrorMsg(hDlg,IDC_PHONENUMBER,IDS_SBCSONLY);
        return FALSE;
    }
#endif
    if( !IsDialableString(gpRasEntry->szLocalPhoneNumber) )
    {
      DisplayFieldErrorMsg(hDlg,IDC_PHONENUMBER,IDS_INVALIDPHONE);
      return FALSE;
    }

    // 11/11/96 jmazner Normandy #7623
    // make sure area code has only valid chars
#if !defined(WIN16)
    if( gpRasEntry->szAreaCode[0] && !IsSBCSString(gpRasEntry->szAreaCode))
    {
        DisplayFieldErrorMsg(hDlg,IDC_AREACODE,IDS_SBCSONLY);
        return FALSE;
    }
#endif

    if( gpRasEntry->szAreaCode[0] && !IsDialableString(gpRasEntry->szAreaCode) )
    {
      DisplayFieldErrorMsg(hDlg,IDC_AREACODE,IDS_INVALIDPHONE);
      return FALSE;
    }
    // make sure user typed in an area code unless dial-as-is was chosen
/*    if ((!lstrlen(gpRasEntry->szAreaCode)) &&
      (!IsDlgButtonChecked(hDlg,IDC_DIALASIS)))
    {
      DisplayFieldErrorMsg(hDlg,IDC_AREACODE,IDS_NEED_AREACODE);
      return FALSE;
    }
*/

      // 5/8/97 jmazner Olympus #4108
      // prepopulate connectoid name with "Connection to xxx-xxxx"
      if( gpUserInfo->szISPName )
      {
          TCHAR szFmt[MAX_ISP_NAME + 1];
          ZeroMemory(&szFmt, MAX_ISP_NAME + 1);
          LoadSz(IDS_CONNECTIONTO,szFmt, MAX_ISP_NAME + 1);
          wsprintf(szNewDefaultName, szFmt, gpRasEntry->szLocalPhoneNumber );

          if( (NULL == gpUserInfo->szISPName[0]) ||
              (0 == lstrcmp(s_szPreviousDefaultName, gpUserInfo->szISPName)) )
          {
              lstrcpy( gpUserInfo->szISPName, szNewDefaultName );
              lstrcpy( s_szPreviousDefaultName, szNewDefaultName );
          }
      }

    *puNextPage = ORD_PAGE_NAMEANDPASSWORD;
  }

  // free country code list buffer
  DeInitCountryCodeList();

  return TRUE;
}

BOOL RunAdvDlg(HWND hDlg)
{
    HPROPSHEETPAGE  hWizPage[TAB_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE   psPage;    // struct used to create prop sheet pages
    PROPSHEETHEADER psHeader;  // struct used to run wizard property sheet
    INT_PTR             iRet;
    TCHAR           szTemp[MAX_RES_LEN + 1];
    
    // zero out structures
    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));
    ZeroMemory(&psHeader,sizeof(PROPSHEETHEADER));

    // fill out common data property sheet page struct
    psPage.dwSize    = sizeof(PROPSHEETPAGE);
    psPage.hInstance = ghInstance;
    psPage.dwFlags = PSP_DEFAULT | PSP_USETITLE;

    // create a property sheet page for each page in the wizard
    // create a property sheet page for the connection tab 
    psPage.pszTemplate = MAKEINTRESOURCE(IDD_ADVANCE_TAB_CONN);
    LoadSz(IDS_CONNECTION, szTemp, MAX_RES_LEN);
    psPage.pszTitle = szTemp;
    psPage.pfnDlgProc = TabConnDlgProc;
    hWizPage[0] = CreatePropertySheetPage(&psPage);
   
    // create a property sheet page for the address tab 
    psPage.pszTemplate = MAKEINTRESOURCE(IDD_ADVANCE_TAB_ADDR);
    LoadSz(IDS_ADDRESS, szTemp, MAX_RES_LEN);
    psPage.pszTitle = szTemp;
    psPage.pfnDlgProc = TabAddrDlgProc;
    hWizPage[1] = CreatePropertySheetPage(&psPage);

    if (!hWizPage[1]) 
        DestroyPropertySheetPage(hWizPage[0]);

    // fill out property sheet header struct
    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_NOAPPLYNOW;
    psHeader.hwndParent = hDlg;
    psHeader.hInstance = ghInstance;
    psHeader.nPages = TAB_PAGES;
    psHeader.phpage = hWizPage;
    LoadSz(IDS_ADVANCE_PROPERTIES, szTemp, MAX_RES_LEN);
    psHeader.pszCaption = szTemp;
    psHeader.nStartPage = 0;

    
    HINSTANCE hComCtl = LoadLibrary(TEXT("comctl32.dll"));
    if (hComCtl)
    {
        PFNInitCommonControlsEx pfnInitCommonControlsEx = NULL;

        if (pfnInitCommonControlsEx = (PFNInitCommonControlsEx)GetProcAddress(hComCtl,"InitCommonControlsEx"))
        {
            //register the Native font control so the dialog won't fail
            INITCOMMONCONTROLSEX iccex;
            iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
            iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
            if (!pfnInitCommonControlsEx(&iccex))
                return FALSE;
        }
        FreeLibrary(hComCtl);
    }

    // run the Wizard
    iRet = PropertySheet(&psHeader);

    return (iRet > 0);
}

/*******************************************************************

  NAME:    PhoneNumberCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK PhoneNumberCmdProc(HWND hDlg,WPARAM wParam,LPARAM lParam)
{   
  switch (GET_WM_COMMAND_ID(wParam, lParam)) {

    case IDC_USEDIALRULES:
      // if check box selected, enable controls appropriately
      EnablePhoneNumberControls(hDlg);
      break;

    case IDC_COUNTRYCODE:
      FillCountryCodeList(GetDlgItem(hDlg,IDC_COUNTRYCODE));
      break;

    case IDC_MODIFYADVANCED:
        // if check box selected, enable controls appropriately
        RASENTRY pRasEntry;
        // Store the current setting now.  If later user canceled we can reset them all back
        // We are doing this because at this moment we don't want to break up the
        // the verifying and saving code into 2 big steps because the verifcation and the saving
        // are self contained in 4 individual ok procs. ( originally in 4 different advance pages )
        // It is too much work to regroup them into
        // two separate operations.
        memcpy(&pRasEntry, gpRasEntry, sizeof(RASENTRY));
        if (!RunAdvDlg(hDlg))
        {
            memcpy(gpRasEntry, &pRasEntry, sizeof(RASENTRY));
        }
        break;
  }
  return TRUE;
}

/*******************************************************************

  NAME:    EnablePhoneNumberControls

  SYNOPSIS:  If "Don't use country code..." is checked, disable controls for
            area code and country code.  If not, enable them.

********************************************************************/
VOID EnablePhoneNumberControls(HWND hDlg)
{
  BOOL fUseDialRules = IsDlgButtonChecked(hDlg,IDC_USEDIALRULES);
  
  EnableDlgItem(hDlg,IDC_AREACODE,fUseDialRules);
  EnableDlgItem(hDlg,IDC_TX_AREACODE,fUseDialRules);
  EnableDlgItem(hDlg,IDC_TX_SEPARATOR,fUseDialRules);
  EnableDlgItem(hDlg,IDC_COUNTRYCODE,fUseDialRules);
  EnableDlgItem(hDlg,IDC_TX_COUNTRYCODE,fUseDialRules);
}
                                    
/*******************************************************************

  NAME:    NameAndPasswordInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK NameAndPasswordInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    //
    // 7/30/97 jmazner Olympus 1111
    //
    ProcessDBCS( hDlg, IDC_USERNAME );

    // limit text fields appropriately
    SendDlgItemMessage(hDlg,IDC_USERNAME,EM_LIMITTEXT,
      MAX_ISP_USERNAME,0L);
    SendDlgItemMessage(hDlg,IDC_PASSWORD,EM_LIMITTEXT,
      MAX_ISP_PASSWORD,0L);
      SetDlgItemText(hDlg,IDC_USERNAME,gpUserInfo->szAccountName);
      SetDlgItemText(hDlg,IDC_PASSWORD,gpUserInfo->szPassword);
  }


  return TRUE;
}

/*******************************************************************

  NAME:    NameAndPasswordOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK NameAndPasswordOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage,
  BOOL * pfKeepHistory)
{
    ASSERT(puNextPage);

    // get user name and password from UI
    GetDlgItemText(hDlg,IDC_USERNAME,gpUserInfo->szAccountName,
    sizeof(gpUserInfo->szAccountName));
    GetDlgItemText(hDlg,IDC_PASSWORD,gpUserInfo->szPassword,
    sizeof(gpUserInfo->szPassword));

    if (fForward)
    {
        // warn (but allow user to proceed) if username is blank
        if (!lstrlen(gpUserInfo->szAccountName))
        {
          if (!WarnFieldIsEmpty(hDlg,IDC_USERNAME,IDS_WARN_EMPTY_USERNAME))
            return FALSE;  // stay on this page if user heeds warning
        } 

        //
        // 5/17/97  jmazner Olympus #248
        // warn if password is empty
        //
        if (!lstrlen(gpUserInfo->szPassword))
        {
          if (!WarnFieldIsEmpty(hDlg,IDC_PASSWORD,IDS_WARN_EMPTY_PASSWORD))
            return FALSE;  // stay on this page if user heeds warning
        } 


        // set next page to go to
        if (gpUserInfo->fNewConnection)
        {
            *puNextPage = ORD_PAGE_CONNECTIONNAME;
        }
        else if( gpWizardState->dwRunFlags & RSW_APPRENTICE )
        {
            // we're about to jump back to the external wizard, and we don't want
            // this page to show up in our history list
            *pfKeepHistory = FALSE;

            *puNextPage = g_uExternUINext;

            //Notify the main Wizard that this was the last page
            ASSERT( g_pExternalIICWExtension )
            if (g_fIsExternalWizard97)
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_NAMEANDPASSWORD97);
            else
                g_pExternalIICWExtension->SetFirstLastPage(0, IDD_PAGE_NAMEANDPASSWORD);
            g_fConnectionInfoValid = TRUE;

        }
        else if( LoadAcctMgrUI(GetParent(hDlg), 
                             g_fIsWizard97 ? IDD_PAGE_NAMEANDPASSWORD97 : IDD_PAGE_NAMEANDPASSWORD, 
                             g_fIsWizard97 ? IDD_PAGE_CONNECTEDOK97FIRSTLAST : IDD_PAGE_CONNECTEDOK, 
                             g_fIsWizard97 ? WIZ_USE_WIZARD97 : 0) )
        {
            if( DialogIDAlreadyInUse( g_uAcctMgrUIFirst) )
            {
                // we're about to jump into the external apprentice, and we don't want
                // this page to show up in our history list
                *pfKeepHistory = FALSE;
                *puNextPage = g_uAcctMgrUIFirst;
            }
            else
            {
                DEBUGMSG("hmm, the first acctMgr dlg id is supposedly %d, but it's not marked as in use!",
                        g_uAcctMgrUIFirst);
                *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);
            }
        }
        else
        {
            DEBUGMSG("LoadAcctMgrUI returned false, guess we'd better skip over it!");
            *puNextPage = (g_fIsICW ? g_uExternUINext : ORD_PAGE_CONNECTEDOK);

        }
    }
    return TRUE;
}


/*******************************************************************

  NAME:    TabConnDlgProc

  SYNOPSIS:  Dialog proc for Connection advanced button

********************************************************************/
INT_PTR CALLBACK TabConnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
    
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            //Remove the system menu from the window's style
            LONG window_style = GetWindowLong(GetParent(hDlg), GWL_EXSTYLE);
            window_style &= ~WS_EX_CONTEXTHELP;
            //set the style attribute of the main frame window
            SetWindowLong(GetParent(hDlg), GWL_EXSTYLE, window_style);

            ConnectionProtocolInitProc(hDlg, TRUE);
            LoginScriptInitProc(hDlg, TRUE);

            break;
        }
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDC_BROWSE:
                    BrowseScriptFile(hDlg);
                    break;
                case IDC_PROTOCOLPPP:
                case IDC_PROTOCOLSLIP:
                case IDC_PROTOCOLCSLIP:
                    // set next page to go to
                    EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), FALSE);
                    if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLPPP))
                    {
                        OSVERSIONINFO osver;
                        ZeroMemory(&osver,sizeof(osver));
                        osver.dwOSVersionInfoSize = sizeof(osver);
                        GetVersionEx(&osver);

                        // LCP extensions only effect PPP connections in NT
                        if (VER_PLATFORM_WIN32_NT == osver.dwPlatformId)
                            EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), TRUE);
                    }
                    break;

                default:
                    LoginScriptCmdProc(hDlg, LOWORD(wParam));
                    break;
            }
            break;

        }
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code) 
            { 
                case PSN_KILLACTIVE:
                {
                    if (!ConnectionProtocolOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                    if (!LoginScriptOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                }
            }
            break;
        }
    }
    
    return FALSE;
}


/*******************************************************************

  NAME:    TabConnDlgProc

  SYNOPSIS:  Dialog proc for Connection advanced button

********************************************************************/
INT_PTR CALLBACK TabAddrDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam)
{
    
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            IPAddressInitProc(hDlg, TRUE);
            DNSAddressInitProc(hDlg, TRUE);
            break;
        }
        case WM_COMMAND:
        {
            IPAddressCmdProc(hDlg, LOWORD(wParam));
            DNSAddressCmdProc(hDlg, LOWORD(wParam));
            break;
        }
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code) 
            { 
                case PSN_KILLACTIVE:
                {
                    if (!IPAddressOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                    if (!DNSAddressOKProc(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        return TRUE;
                    }
                }
            }
            break;
        }

    }
    return FALSE;
}


/*******************************************************************

  NAME:    ConnectionProtocolInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg        - dialog window
            fFirstInit  - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ConnectionProtocolInitProc(HWND hDlg,BOOL fFirstInit)
{
    if (fFirstInit)
    {
        OSVERSIONINFO osver;
        ZeroMemory(&osver,sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        GetVersionEx(&osver);
        if (VER_PLATFORM_WIN32_WINDOWS == osver.dwPlatformId)
        {
            RECT    Rect;
            RECT    OriginalRect;
            ShowWindow(GetDlgItem(hDlg,IDC_PROTOCOLCSLIP),SW_HIDE);
            EnableWindow(GetDlgItem(hDlg,IDC_PROTOCOLCSLIP), FALSE);
            ShowWindow(GetDlgItem(hDlg,IDC_DISABLELCP),SW_HIDE);
            EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), FALSE);

            GetWindowRect(GetDlgItem(hDlg,IDC_PROTOCOLSLIP), &Rect);
            GetWindowRect(GetDlgItem(hDlg,IDC_PROTOCOLCSLIP), &OriginalRect);

            // assume that if it's Japanese, and it's not NT, it must be win95J!
            RECT itemRect;
            POINT thePoint;
            HWND hwndItem = GetDlgItem(hDlg,IDC_PROTOCOLSLIP);

            GetWindowRect(hwndItem, &itemRect);

            // need to convert the coords from global to local client,
            // since MoveWindow below will expext client coords.

            thePoint.x = itemRect.left;
            thePoint.y = itemRect.top;
            ScreenToClient(hDlg, &thePoint );
            itemRect.left = thePoint.x;
            itemRect.top = thePoint.y;

            thePoint.x = itemRect.right;
            thePoint.y = itemRect.bottom;
            ScreenToClient(hDlg, &thePoint );
            itemRect.right = thePoint.x;
            itemRect.bottom = thePoint.y;

            MoveWindow(hwndItem,
	            itemRect.left,
	            itemRect.top - (OriginalRect.top - Rect.top),
	            (itemRect.right - itemRect.left),
	            (itemRect.bottom - itemRect.top), TRUE);
        }

        // initialize radio buttons, default to PPP
        CheckDlgButton(hDlg,IDC_PROTOCOLPPP,RASFP_Ppp == gpRasEntry->dwFramingProtocol);
        EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), FALSE);
        if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLPPP))
        {
            OSVERSIONINFO osver;
            ZeroMemory(&osver,sizeof(osver));
            osver.dwOSVersionInfoSize = sizeof(osver);
            GetVersionEx(&osver);
            if ((RASFP_Ppp == gpRasEntry->dwFramingProtocol) &&
                (VER_PLATFORM_WIN32_NT == osver.dwPlatformId))
            {
                // LCP extensions only effect PPP connections
                EnableWindow(GetDlgItem(hDlg,IDC_DISABLELCP), TRUE);
            }

        }
        CheckDlgButton(hDlg,IDC_DISABLELCP,(RASEO_DisableLcpExtensions & gpRasEntry->dwfOptions));

        CheckDlgButton(hDlg,IDC_PROTOCOLSLIP,(RASFP_Slip == gpRasEntry->dwFramingProtocol)
            && !(gpRasEntry->dwfOptions & RASEO_IpHeaderCompression));
        CheckDlgButton(hDlg,IDC_PROTOCOLCSLIP,(RASFP_Slip == gpRasEntry->dwFramingProtocol)
            && (gpRasEntry->dwfOptions & RASEO_IpHeaderCompression));
    }

    return TRUE;
}

/*******************************************************************

  NAME:    ConnectionProtocolOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ConnectionProtocolOKProc(HWND hDlg)
{
    ASSERT(puNextPage);

    // read radio button state
    if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLPPP))
    {
        // Set entry for PPP
        gpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        gpRasEntry->dwFramingProtocol = RASFP_Ppp;
        if (IsDlgButtonChecked(hDlg, IDC_DISABLELCP))
        {
            gpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
        }
        else
        {
            gpRasEntry->dwfOptions &= ~(RASEO_DisableLcpExtensions);
        }
    }
    else if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLSLIP))
    {
        // Set entry for SLIP
        gpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
        gpRasEntry->dwFramingProtocol = RASFP_Slip;
    }
    else if (IsDlgButtonChecked(hDlg, IDC_PROTOCOLCSLIP))
    {
        // Set entry for C-SLIP
        gpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
        gpRasEntry->dwFramingProtocol = RASFP_Slip;
    }

    return TRUE;
}

/*******************************************************************

  NAME:    LoginScriptInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK LoginScriptInitProc(HWND hDlg,BOOL fFirstInit)
{
  if (fFirstInit)
  {
    // Set limit on edit box
    SendDlgItemMessage(hDlg,IDC_SCRIPTFILE,EM_LIMITTEXT,
      MAX_PATH,0L);

    ProcessDBCS(hDlg, IDC_SCRIPTFILE);

    // If there is a script file, default to use script
    // If no script file, base selection on whether or not
    // a post-dial terminal window is desired.
    if (lstrlen(gpRasEntry->szScript))
    {
      CheckDlgButton(hDlg,IDC_NOTERMINALAFTERDIAL,FALSE);
      CheckDlgButton(hDlg,IDC_TERMINALAFTERDIAL,FALSE);
      CheckDlgButton(hDlg,IDC_SCRIPT,TRUE);

      SetDlgItemText(hDlg,IDC_SCRIPTFILE,gpRasEntry->szScript);

      // set focus to the script text field
      SetFocus(GetDlgItem(hDlg,IDC_SCRIPTFILE));
    }
    else
    {
      BOOL fTerminalWindow = (gpRasEntry->dwfOptions & RASEO_TerminalAfterDial);
      CheckDlgButton(hDlg,IDC_NOTERMINALAFTERDIAL,!fTerminalWindow);
      CheckDlgButton(hDlg,IDC_TERMINALAFTERDIAL,fTerminalWindow);
      CheckDlgButton(hDlg,IDC_SCRIPT,FALSE);
    }
  }
  
  // enable script controls appropriately
  EnableScriptControls(hDlg);

  return TRUE;
}

/*******************************************************************

  NAME:    LoginScriptOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK LoginScriptOKProc(HWND hDlg)
{
  ASSERT(puNextPage);

  // read radio button state
  if (IsDlgButtonChecked(hDlg, IDC_NOTERMINALAFTERDIAL))
  {
    // Set entry for no terminal window or script
    gpRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;
    lstrcpy(gpRasEntry->szScript, szNull);
  }
  else if (IsDlgButtonChecked(hDlg, IDC_TERMINALAFTERDIAL))
  {
    // Set entry for terminal window and no script
    gpRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
    lstrcpy(gpRasEntry->szScript, szNull);
  }
  else if (IsDlgButtonChecked(hDlg, IDC_SCRIPT))
  {
    // Set entry for script, but no terminal window
    gpRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;
    GetDlgItemText(hDlg,IDC_SCRIPTFILE,gpRasEntry->szScript,
      sizeof(gpRasEntry->szScript));
  }

  if(IsDlgButtonChecked(hDlg, IDC_SCRIPT))
  {
      if( 0xFFFFFFFF == GetFileAttributes(gpRasEntry->szScript))
      {
          DisplayFieldErrorMsg(hDlg,IDC_SCRIPTFILE,IDS_LOGINSCRIPTINVALID);
          return FALSE;
      }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    LoginScriptCmdProc

  SYNOPSIS:  Called when dlg control pressed on page

  ENTRY:    hDlg - dialog window
        uCtrlID - control ID of control that was touched
        
********************************************************************/
BOOL CALLBACK LoginScriptCmdProc(HWND hDlg,UINT uCtrlID)
{
  switch (uCtrlID)
  {

    case IDC_NOTERMINALAFTERDIAL:
    case IDC_TERMINALAFTERDIAL:
    case IDC_SCRIPT:
      // if radio buttons pushed, enable script controls appropriately
      EnableScriptControls(hDlg);
      break;

    case IDC_BROWSE:
      BrowseScriptFile(hDlg);
      break;
  }

  return TRUE;
}

/*******************************************************************

  NAME:    EnableScriptControls

  SYNOPSIS:  If "Use this script" is checked, enable controls for
            browsing.  If not, disable them.

********************************************************************/
VOID EnableScriptControls(HWND hDlg)
{
  BOOL fUseScript = IsDlgButtonChecked(hDlg,IDC_SCRIPT);
  
  EnableDlgItem(hDlg,IDC_SCRIPT_LABEL,fUseScript);
  EnableDlgItem(hDlg,IDC_SCRIPTFILE,fUseScript);
  EnableDlgItem(hDlg,IDC_BROWSE,fUseScript);
}

//****************************************************************************
// DWORD BrowseScriptFile (HWND)
//
// This function taken from RNA
//
// History:
//  Tue 08-Nov-1994 09:14:13  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD BrowseScriptFile(HWND hDlg)
{
  OPENFILENAME  ofn;
  LPTSTR        pszFiles, szFileName, szFilter;
  DWORD         dwRet;

  // Allocate filename buffer
  //
  if ((pszFiles = (LPTSTR)LocalAlloc(LPTR, 2*MAX_PATH*sizeof(TCHAR))) == NULL)
    return ERROR_OUTOFMEMORY;
  szFileName = pszFiles;
  szFilter   = szFileName+MAX_PATH;

  // Start file browser dialog
  //
  LoadString(ghInstance, IDS_SCRIPT_FILE_FILTER, szFilter, MAX_PATH);

  *szFileName     = '\0';
  ofn.lStructSize = sizeof(ofn);
  ofn.hwndOwner   = hDlg;
  ofn.hInstance   = ghInstance;
  ofn.lpstrFilter = szFilter;
  ofn.lpstrCustomFilter = NULL;
  ofn.nMaxCustFilter    = 0;
  ofn.nFilterIndex      = 2;
  ofn.lpstrFile         = szFileName;
  ofn.nMaxFile          = MAX_PATH;
  ofn.lpstrFileTitle    = NULL;
  ofn.nMaxFileTitle     = 0;
  ofn.lpstrInitialDir   = NULL;
  ofn.lpstrTitle        = NULL;
  ofn.Flags             = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
  ofn.nFileOffset       = 0;
  ofn.nFileExtension    = 0;
  ofn.lpstrDefExt       = NULL;
  ofn.lCustData         = 0;
  ofn.lpfnHook          = NULL;
  ofn.lpTemplateName    = NULL;

  if (GetOpenFileName(&ofn))
  {
    // Set the filename to a new name
    //
    SetDlgItemText(hDlg,IDC_SCRIPTFILE,szFileName);
    dwRet = ERROR_SUCCESS;
  }
  else
  {
    dwRet = ERROR_OPEN_FAILED;
  };

  LocalFree(pszFiles);
  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\init.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  INIT.C - WinMain and initialization code for Internet setup/signup wizard
//

//  HISTORY:
//  
//  11/20/94  jeremys  Created.
//  96/03/07  markdu  Added gpEnumModem
//  96/03/09  markdu  Added gpRasEntry
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/26  markdu  Put #ifdef __cplusplus around extern "C"
//  96/04/24  markdu  NASH BUG 19289 Added /NOMSN command line flag
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//  96/05/14  markdu  NASH BUG 22681 Took out mail and news pages.
//

#include "wizard.h"
#include "icwextsn.h"
#include "imnext.h"

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//
// The LaunchSignupWizard APIs have a PBOOL argument also which gets
// info to the calling APP whether they need to reboot
// MKarki (5/4/97) - Fix for Bug #3111
//
  VOID WINAPI LaunchSignupWizard(LPTSTR lpCmdLine,int nCmdShow, PBOOL pReboot);
  DWORD WINAPI LaunchSignupWizardEx(LPTSTR lpCmdLine,int nReserved, PBOOL pReboot);

#ifdef __cplusplus
}
#endif // __cplusplus

BOOL ParseCommandLine(LPTSTR lpszCommandLine,DWORD * pdwFlags);
TCHAR * GetTextToNextSpace(LPTSTR pszText,TCHAR * pszOutBuf,UINT cbOutBuf);

#pragma data_seg(".data")

WIZARDSTATE *     gpWizardState=NULL;   // pointer to global wizard state struct
USERINFO *        gpUserInfo=NULL;        // pointer to global user info struct
ENUM_MODEM *      gpEnumModem=NULL;  // pointer modem enumeration object
LPRASENTRY        gpRasEntry = NULL;  // pointer to RASENTRY struct to hold all data
DWORD             gdwRasEntrySize = 0;
BOOL              gfFirstNewConnection = TRUE;

//
// set the reboot flag to FALSE
// MKarki - 5/2/97 - Fix for Bug#3111
//
BOOL g_bReboot = FALSE;
BOOL g_bRebootAtExit = FALSE;
#pragma data_seg()

/*******************************************************************

  NAME:    LaunchSignupWizard

  SYNOPSIS:  Entry point for Internet Setup Wizard UI

********************************************************************/
extern "C" VOID WINAPI 
LaunchSignupWizard (
            LPTSTR lpCmdLine,
            int nCmdShow,
            PBOOL pReboot
            )
{
  BOOL fOK=TRUE;

  // allocate global structures
  gpWizardState = new WIZARDSTATE;
  gpUserInfo = new USERINFO;
  gdwRasEntrySize = sizeof(RASENTRY);
  gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);

  if (!gpWizardState ||
    !gpUserInfo ||
    !gpRasEntry)
  {
    // display an out of memory error
    MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
    fOK = FALSE;
    // fall through and clean up any successful allocs below
  }

  if (fOK) {
    DWORD dwFlags = 0;

    ParseCommandLine(lpCmdLine,&dwFlags);

    if (dwFlags & RSW_UNINSTALL) {
      // do uninstall if we got /uninstall on command line
      DoUninstall();  

    } else {

      RunSignupWizard(dwFlags);

    }
  }

  // free global structures
  if (gpWizardState) 
    delete gpWizardState;

  if (gpUserInfo)
    delete gpUserInfo;

  if (gpEnumModem)
    delete gpEnumModem;

  if (gpRasEntry)
    GlobalFree(gpRasEntry);

  //
  // pass back the info, that the app needs to reboot or not
  // MKarki - 5/2/97 - Fix for Bug#3111
  //
  *pReboot = g_bReboot;
  
    
} //end of LaunchSignupWizard API call

/*******************************************************************

  NAME:    LaunchSignupWizardEx

  SYNOPSIS:  Entry point for Internet Setup Wizard UI with back
			 capabilities.  It will retain previous information
			 if called multiple times.  The caller *MUST* call
			 FreeSignupWizard when done.

  PARAMETERS:
			lpCmdLine - Command line with instructions
			nReserved - Reserved for future use

  RETURNS:	ERROR_SUCCESS	Everything's okay, wizard finished
			ERROR_CONTINUE	User pressed back on first page
			ERROR_CANCELLED	User cancelled out of wizard
			<other>			Deadly error (message already displayed)
********************************************************************/
extern "C" DWORD WINAPI 
LaunchSignupWizardEx (
        LPTSTR   lpCmdLine,
        int     nReserved,
        PBOOL   pReboot
        )
{
	DWORD dwRet = ERROR_SUCCESS;
	BOOL fFirstTime = FALSE;

	// allocate global structures if needed
	if (!gpWizardState)
	{
		gpWizardState = new WIZARDSTATE;
		fFirstTime = TRUE;
	}
	else
	{
		gpWizardState->uCurrentPage = ORD_PAGE_HOWTOCONNECT;
		gpWizardState->uPagesCompleted = 0;
	}

	if (!gpUserInfo)
	{
		gpUserInfo = new USERINFO;
		fFirstTime = TRUE;
	}
	if (!gpRasEntry)
	{
		gdwRasEntrySize = sizeof(RASENTRY);
		gpRasEntry = (LPRASENTRY) GlobalAlloc(GPTR,gdwRasEntrySize);
		fFirstTime = TRUE;
	}

	if (!gpWizardState || !gpUserInfo || !gpRasEntry)
	{
		MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
		dwRet = ERROR_NOT_ENOUGH_MEMORY;
	}

	if (ERROR_SUCCESS == dwRet)
	{
	    DWORD dwFlags = 0;

		ParseCommandLine(lpCmdLine,&dwFlags);


		if (dwFlags & RSW_UNINSTALL)
		{
			// do uninstall if we got /uninstall on command line
			DoUninstall();  

		}
		else
		{
			gfUserFinished = FALSE;
			gfUserBackedOut = FALSE;
			gfUserCancelled = FALSE;
			gfQuitWizard = FALSE;

			// On the first call, don't free the globals, we
			// may be called again.  On subsequent calls, don't
			// initialize the globals either.
			dwFlags |= RSW_NOFREE;
			if (!fFirstTime)
				dwFlags |= RSW_NOINIT;

			RunSignupWizard(dwFlags);

			if (gfUserFinished)
				dwRet = ERROR_SUCCESS;
			else if (gfUserBackedOut)
				dwRet = ERROR_CONTINUE;
			else if (gfUserCancelled)
				dwRet = ERROR_CANCELLED;
			else
				dwRet = ERROR_GEN_FAILURE;
		}
	}

  //
  // pass back the info, that the app needs to reboot or not
  // MKarki (5/2/97) Fix for Bug #3111
  //
  *pReboot = g_bReboot;

	return dwRet;
} // end of LaunchSignupWizardEx API 

/****************************************************************************

  NAME:     FreeSignupWizard

  SYNOPSIS: Frees the global structures explicitely.  This must be called
			if LaunchSignupWizardEx is used.

****************************************************************************/
extern "C" VOID WINAPI FreeSignupWizard(VOID)
{
	if (gpWizardState)
	{
		delete gpWizardState;
		gpWizardState = NULL;
	}
	if (gpUserInfo)
	{
		delete gpUserInfo;
		gpUserInfo = NULL;
	}
	if (gpRasEntry)
	{
		GlobalFree(gpRasEntry);
		gpRasEntry = NULL;
		gdwRasEntrySize = 0;
	}
	if (gpEnumModem)
	{
		delete gpEnumModem;
		gpEnumModem = NULL;
	}
	if (gpImnApprentice)
	{
		gpImnApprentice->Release();
		gpImnApprentice = NULL;
	}
	if (gfOleInitialized)
		CoUninitialize();

}


/****************************************************************************

  NAME:     ParseCommandLine

  SYNOPSIS:  Parses command line 

****************************************************************************/
BOOL ParseCommandLine(LPTSTR lpszCommandLine,DWORD * pdwFlags)
{
  if (!lpszCommandLine || !*lpszCommandLine)
    return TRUE;  // nothing to do

  ASSERT(pdwFlags);
  *pdwFlags = 0;

  while (*lpszCommandLine) {
    TCHAR szCommand[SMALL_BUF_LEN+1];

    lpszCommandLine = GetTextToNextSpace(lpszCommandLine,
      szCommand,sizeof(szCommand));

    if (!lstrcmpi(szCommand,szNOREBOOT)) {
      DEBUGMSG("Got /NOREBOOT command line switch");
      *pdwFlags |= RSW_NOREBOOT;      
    }

    if (!lstrcmpi(szCommand,szUNINSTALL)) {
      DEBUGMSG("Got /UNINSTALL command line switch");
      *pdwFlags |= RSW_UNINSTALL;      
    }

    if (!lstrcmpi(szCommand,szNOMSN)) {
      DEBUGMSG("Got /NOMSN command line switch");
      *pdwFlags |= RSW_NOMSN;      
    }
    
    if (!lstrcmpi(szCommand,szNOIMN)) {
      DEBUGMSG("Got /NOIMN command line switch");
      *pdwFlags |= RSW_NOIMN;      
    }
    
  }

  return TRUE;
}

/****************************************************************************

  NAME:     GetTextToNextSpace

  SYNOPSIS:  Gets text up to next space or end of string, places in
        output buffer

****************************************************************************/
TCHAR * GetTextToNextSpace(LPTSTR pszText,TCHAR * pszOutBuf,UINT cbOutBuf)
{
  ASSERT(pszText);
  ASSERT(pszOutBuf);

  lstrcpy(pszOutBuf,szNull);
  
  if (!pszText)
    return NULL;

  // advance past spaces
  while (*pszText == ' ')
    pszText ++;

  while (*pszText && (*pszText != ' ') && cbOutBuf>1) {
    *pszOutBuf = *pszText;    
    pszOutBuf ++;
    cbOutBuf --;
    pszText ++;
   }

  if (cbOutBuf)
    *pszOutBuf = '\0';  // null-terminate

  while (*pszText == ' ')
    pszText++;      // advance past spaces

  return pszText;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\pch.cpp ===
#include "wizard.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\mapicall.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  MAPICALL.C - Functions to call MAPI for internet mail profile configuration
//      
//

//  HISTORY:
//  
//  1/25/95    jeremys    Created.
//  96/03/09  markdu    Added a wait cursor during loading of MAPI
//

#include "wizard.h"

/**********************************************************************

  Terminology:

  profile - a collection of settings for Exchange that determine
    the services that are used and the address book and message store
  service - a MAPI plug-in that talks to a mail back end
    (or address book or message store)

  There can be a number of profiles installed on a particular machine.
  Each profile contains a set of services.

  Stategy:

  To configure Microsoft Exchange, we need to do the following:

  1) Establish a profile to modify
    - If any profiles currently exist, find the default profile.
    Otherwise create a profile, which will be initially empty.

  2) Populate the profile with the required services.
    - The profile needs to contain the Internet Mail service, an
    address book and a message store.  If any of these items are
    not present, we add them to the profile.

  3) Configure the internet mail service for this profile.
    - stick in the user's email address, email server, etc.

**********************************************************************/

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE hInstMAPIDll=NULL;  // handle to MAPI dll we load explicitly
DWORD dwMAPIRefCount = 0;

// global function pointers for MAPI apis
LPMAPIINITIALIZE     lpMAPIInitialize     = NULL;
LPMAPIADMINPROFILES   lpMAPIAdminProfiles   = NULL;
LPMAPIUNINITIALIZE     lpMAPIUninitialize     = NULL;
LPMAPIALLOCATEBUFFER  lpMAPIAllocateBuffer  = NULL;
LPMAPIFREEBUFFER    lpMAPIFreeBuffer     = NULL;
LPHRQUERYALLROWS    lpHrQueryAllRows    = NULL;

#define NUM_MAPI_PROCS   6
// API table for function addresses to fetch
APIFCN MAPIApiList[NUM_MAPI_PROCS] = {
  { (PVOID *) &lpMAPIInitialize,szMAPIInitialize},
  { (PVOID *) &lpMAPIUninitialize,szMAPIUninitialize},
  { (PVOID *) &lpMAPIAdminProfiles,szMAPIAdminProfiles},
  { (PVOID *) &lpMAPIAllocateBuffer,szMAPIAllocateBuffer},
  { (PVOID *) &lpMAPIFreeBuffer,szMAPIFreeBuffer},
  { (PVOID *) &lpHrQueryAllRows,szHrQueryAllRows}};

#pragma data_seg(DATASEG_DEFAULT)

// function prototypes
HRESULT GetProfileList(LPPROFADMIN lpProfAdmin,LPSRowSet * ppRowSet);
HRESULT GetServicesList(LPSERVICEADMIN lpServiceAdmin, LPSRowSet *ppRowSet);
HRESULT CreateProfileIfNecessary(LPPROFADMIN lpProfAdmin,TCHAR * pszSelProfileName);
HRESULT InstallRequiredServices(LPSERVICEADMIN pServiceAdmin,
  LPSRowSet pServiceRowSet);
VOID FreeSRowSet(LPSRowSet prws);
BOOL ValidateProperty(LPSPropValue pval, ULONG cVal, ULONG ulPropTag);
BOOL DoesFileExist(TCHAR * pszPath,TCHAR * pszFileName);
HRESULT ConfigInternetService(MAILCONFIGINFO * pMailConfigInfo,
  LPSERVICEADMIN lpServiceAdmin);
HRESULT   GetServiceUID(TCHAR * pszName,LPSERVICEADMIN lpServiceAdmin,
  LPMAPIUID *ppMapiUID);
BOOL MakeUniqueFilename(UINT uIDFilename,UINT uIDAltFilename,
  TCHAR * pszFilename,DWORD cbFilename);
extern BOOL GetApiProcAddresses(HMODULE hModDLL,APIFCN * pApiProcList,
  UINT nApiProcs);
HRESULT ConfigNewService(LPSERVICEADMIN lpServiceAdmin,LPMAPIUID lpMapiUID,
  UINT uIDFilename,UINT uIDFilename1,UINT uPropValID);

// enums
enum { ivalDisplayName, ivalServiceName, ivalResourceFlags, ivalServiceDllName,
  ivalServiceEntryName, ivalServiceUID, ivalServiceSupportFiles,
  cvalMsgSrvMax };

/*******************************************************************

  NAME:    InitMAPI

  SYNOPSIS:  Loads the MAPI dll, gets proc addresses and initializes
        MAPI

  EXIT:    TRUE if successful, or FALSE if fails.  Displays its
        own error message upon failure.

  NOTES:    We load MAPI explicitly because the DLL may not be installed
        when we begin the wizard... we may have to install it and
        then load it.
        

********************************************************************/
BOOL InitMAPI(HWND hWnd)
{
  TCHAR szMAPIDll[SMALL_BUF_LEN+1];
  HRESULT hr;

  // load MAPI only if not already loaded... otherwise just increment
  // reference count

  if (!hInstMAPIDll) {

    // set an hourglass cursor
    WAITCURSOR WaitCursor;

    // get the filename (MAPI32.DLL) out of resource
    LoadSz(IDS_MAPIDLL_FILENAME,szMAPIDll,sizeof(szMAPIDll));
    // load the MAPI dll
    DEBUGMSG("Loading MAPI DLL");
    hInstMAPIDll = LoadLibrary(szMAPIDll);
    if (!hInstMAPIDll) {
      UINT uErr = GetLastError();
      DisplayErrorMessage(hWnd,IDS_ERRLoadMAPIDll1,uErr,ERRCLS_STANDARD,
        MB_ICONSTOP,szMAPIDll);
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    BOOL fSuccess = GetApiProcAddresses(hInstMAPIDll,MAPIApiList,NUM_MAPI_PROCS);

    if (!fSuccess) {
      MsgBoxParam(hWnd,IDS_ERRLoadMAPIDll2,MB_ICONSTOP,MB_OK,szMAPIDll);
      DeInitMAPI();
      return FALSE;
    }

    // initialize MAPI
    ASSERT(lpMAPIInitialize);
    hr = lpMAPIInitialize(NULL);
    if (HR_FAILED(hr)) {
       MsgBox(hWnd,IDS_ERRInitMAPI,MB_ICONSTOP,MB_OK);
      DeInitMAPI();
      return FALSE;
    }

    gpWizardState->fMAPIActive = TRUE;
  }

  dwMAPIRefCount ++;

   return TRUE;
}

/*******************************************************************

  NAME:    DeInitMAPI

  SYNOPSIS:  Uninitializes MAPI and unloads MAPI dlls

********************************************************************/
VOID DeInitMAPI(VOID)
{
  // decrease reference count
  if (dwMAPIRefCount) {
    dwMAPIRefCount--;
  }

  // shut down and unload MAPI if reference count hits zero
  if (!dwMAPIRefCount) {
    // uninitialize MAPI
    if (gpWizardState->fMAPIActive && lpMAPIUninitialize) {
      lpMAPIUninitialize();
      gpWizardState->fMAPIActive = FALSE;
    }

    // free the MAPI dll
    if (hInstMAPIDll) {
      DEBUGMSG("Unloading MAPI DLL");
      FreeLibrary(hInstMAPIDll);
      hInstMAPIDll = NULL;
    }
  
    // set function pointers to NULL
    for (UINT nIndex = 0;nIndex<NUM_MAPI_PROCS;nIndex++) 
      *MAPIApiList[nIndex].ppFcnPtr = NULL;
  }
}

/*******************************************************************

  NAME:    SetMailProfileInformation

  SYNOPSIS:  Sets up MAPI profile for internet mail and sets
        user information in profile.

  ENTRY:    pMailConfigInfo - pointer to struct with configuration info

  EXIT:    returns an HRESULT
  
  NOTES:    See strategy statement above
  
********************************************************************/
HRESULT SetMailProfileInformation(MAILCONFIGINFO * pMailConfigInfo)
{
  HRESULT hr;
  LPPROFADMIN   pProfAdmin=NULL;  // interface to administer profiles
  LPSERVICEADMIN  pServiceAdmin=NULL; // interface to administer services
  LPSRowSet    pServiceRowSet=NULL;
  TCHAR      szSelProfileName[cchProfileNameMax+1]=TEXT("");

  ASSERTSZ(gpWizardState->fMAPIActive,"MAPI not initialized!");
  ASSERT(pMailConfigInfo);

  // get a pointer to the interface to administer profiles
  ASSERT(lpMAPIAdminProfiles);
  hr = lpMAPIAdminProfiles(0,&pProfAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("MAPIAdminProfiles returned 0x%lx",hr);
    return (hr);
  }
  ASSERT(pProfAdmin);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

  // get profile name from passed-in struct, if specified
  if (pMailConfigInfo->pszProfileName && lstrlen(pMailConfigInfo->pszProfileName)) {
    lstrcpy(szSelProfileName,pMailConfigInfo->pszProfileName);
  } else {
    // no profile specified, use default name
    LoadSz(IDS_DEFAULT_PROFILE_NAME,szSelProfileName,sizeof(szSelProfileName));
  }

  // create profile if we need to
  hr = CreateProfileIfNecessary(pProfAdmin,szSelProfileName);
  if (HR_FAILED(hr))
    return hr;

  // set this profile as default if appropriate
  if (pMailConfigInfo->fSetProfileAsDefault) {
    hr = pProfAdmin->SetDefaultProfile(szSelProfileName,0);
    if (HR_FAILED(hr))
      return hr;
  }

  ASSERT(lstrlen(szSelProfileName));  // should have profile name at this point
  DEBUGMSG("Modifying MAPI profile: %s",szSelProfileName);

  // get a pointer to the interface to administer services for this profile
  hr = pProfAdmin->AdminServices(szSelProfileName,NULL,NULL,0,
    &pServiceAdmin);

  if (HR_FAILED(hr))
    return hr;
  ASSERT(pServiceAdmin);
  // release pServiceAdmin interface when done
  RELEASE_ME_LATER rlServiceAdmin(pServiceAdmin);  

  // get a list of services for this profile
  hr = GetServicesList(pServiceAdmin,&pServiceRowSet);
  if (HR_FAILED(hr))
    return hr;
  ASSERT(pServiceRowSet);

  // install any services we need which aren't already present in the profile
  hr = InstallRequiredServices(pServiceAdmin,pServiceRowSet);
    // done with profile row set, free the table
  FreeSRowSet(pServiceRowSet);
  pServiceRowSet = NULL;
  if (HR_FAILED(hr))
    return hr;

  // configure the internet mail service with the passed in email name,
  // server, etc.
  hr = ConfigInternetService(pMailConfigInfo,pServiceAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("ConfigInternetService returned 0x%x" , hr);
    return hr;
  }

  return hr;
}

/*******************************************************************

  NAME:    GetProfileList

  SYNOPSIS:  retrieves a list of MAPI profiles 

  ENTRY:    lpProfAdmin - pointer to profile admin interface
        ppRowSet - pointer to an SRowSet pointer that is filled in

  EXIT:    returns an HRESULT.  If successful, *ppRowSet contains
        pointer to SRowSet with profile list.

  NOTES:    Cloned from MAPI profile control panel code.
        Caller MUST call MAPIFreeBuffer to free *ppRowSet when done.
          
********************************************************************/
HRESULT GetProfileList(LPPROFADMIN lpProfAdmin,LPSRowSet * ppRowSet)
{
  HRESULT hr;
  LPMAPITABLE   pMapiTable=NULL;
  SPropTagArray   TagArray= {3,{PR_DISPLAY_NAME,
            PR_COMMENT,PR_DEFAULT_PROFILE}};

  ASSERT(lpProfAdmin);
  ASSERT(ppRowSet);

  // call the lpProfAdmin interface to get the MAPI profile table
  hr = lpProfAdmin->GetProfileTable(0,&pMapiTable);
  if (HR_FAILED(hr))
    return hr;
  ASSERT(pMapiTable);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseMapiTableLater(pMapiTable);

  // set properties of table columns
  hr = pMapiTable->SetColumns(&TagArray,0);
  if (!HR_FAILED(hr)) {
    // get row set information from table
    hr = pMapiTable->QueryRows(4000,0,ppRowSet);
  }

  return hr;
}

/*******************************************************************

  NAME:    GetServicesList

  SYNOPSIS:  retrieves a list of MAPI services in a profile

  ENTRY:    lpProfAdmin - pointer to service admin interface
        ppRowSet - pointer to an SRowSet pointer that is filled in

  EXIT:    returns an HRESULT.  If successful, *ppRowSet contains
        pointer to SRowSet with service list.

  NOTES:    Cloned from MAPI profile control panel code.
        Caller MUST call MAPIFreeBuffer to free *ppRowSet when done.
          
********************************************************************/
HRESULT GetServicesList(LPSERVICEADMIN lpServiceAdmin, LPSRowSet *ppRowSet)
{
  HRESULT      hr;
  ULONG      iRow;
  LPMAPITABLE    pMapiTable   = NULL;
  SCODE      sc    = S_OK;
  static SPropTagArray taga  = {7, { PR_DISPLAY_NAME,
                    PR_SERVICE_NAME,
                    PR_RESOURCE_FLAGS,
                    PR_SERVICE_DLL_NAME,
                    PR_SERVICE_ENTRY_NAME,
                    PR_SERVICE_UID,
                    PR_SERVICE_SUPPORT_FILES }};

  *ppRowSet = NULL;

  hr = lpServiceAdmin->GetMsgServiceTable(0, &pMapiTable);
  if (HR_FAILED(hr))
    return hr;
  // free this interface when function exits
  RELEASE_ME_LATER rlTable(pMapiTable);


  hr = pMapiTable->SetColumns(&taga, 0);
  if (!HR_FAILED(hr)) {
    // BUGBUG get rid of 'magic number' (appears in MAPI
    // ctrl panel code, need to find out what it is)  jeremys 1/30/95
    hr = pMapiTable->QueryRows(4000,0,ppRowSet);
  }
  if (HR_FAILED(hr))
    return hr;

  for(iRow = 0; iRow < (*ppRowSet)->cRows; iRow++)
  {
    // make sure properties are valid, if not then slam something in
    ValidateProperty((*ppRowSet)->aRow[iRow].lpProps, 0, PR_DISPLAY_NAME);
    ValidateProperty((*ppRowSet)->aRow[iRow].lpProps, 1, PR_SERVICE_NAME);
  }

  return hr;
}

/*******************************************************************

  NAME:    CreateProfileIfNecessary

  SYNOPSIS:  Creates profile if it doesn't already exist

  ENTRY:    lpProfAdmin - pointer to profile admin interface
        pszSelProfileName - name of profile to create

  EXIT:    returns an HRESULT. 

********************************************************************/
HRESULT CreateProfileIfNecessary(LPPROFADMIN pProfAdmin,TCHAR * pszSelProfileName)
{
  HRESULT hr = hrSuccess;
  LPTSTR lpProfileName=NULL;
  BOOL  fDefault;

  ASSERT(pProfAdmin);
  ASSERT(pszSelProfileName);

  ENUM_MAPI_PROFILE EnumMAPIProfile;

  // walk through the profile names, see if we have a match
  while (EnumMAPIProfile.Next(&lpProfileName,&fDefault)) {
    ASSERT(lpProfileName);

    if (!lstrcmpi(lpProfileName,pszSelProfileName)) {
      return hrSuccess;  // found a match, nothing to do
    }
  }

  // no match, need to create profile
  DEBUGMSG("Creating MAPI profile: %s",pszSelProfileName);
  // call MAPI to create the profile
  hr = pProfAdmin->CreateProfile(pszSelProfileName,
    NULL, (ULONG) 0, (ULONG) 0);

  return hr;
}


/*******************************************************************

  NAME:    InstallRequiredServices

  SYNOPSIS:  Installs the 3 services we need (message store,
        address book, internet mail) in the profile
        if they're not already present.  Calls functions to configure
        message store and address book (they both need a filename
        to use) if we're adding them.

  ENTRY:    lpServiceAdmin - pointer to service admin interface
        pServiceRowSet - MAPI table with list of installed services
        
  EXIT:    returns an HRESULT. 

  NOTES:    We deliberately don't configure internet mail service here--
        we do that in the main routine.  The reason is that we
        need to configure internet mail whether it's already installed
        or not, address book and message store we only need to configure
        if they're brand new.

********************************************************************/
HRESULT InstallRequiredServices(LPSERVICEADMIN pServiceAdmin,
  LPSRowSet pServiceRowSet)
{
  ULONG       iRow,iService;
  TCHAR       szServiceName[SMALL_BUF_LEN+1];
  LPMAPIUID     pMapiUID=NULL;
  HRESULT      hr=hrSuccess;

  // table for MAPI services we need to make sure are installed in profile
  MSGSERVICE MAPIServiceList[NUM_SERVICES] = {
    { FALSE, IDS_INTERNETMAIL_SERVICENAME, IDS_INTERNETMAIL_DESCRIPTION,FALSE, 0,0,0},
    { FALSE, IDS_MESSAGESTORE_SERVICENAME, IDS_MESSAGESTORE_DESCRIPTION,TRUE,
      IDS_MESSAGESTORE_FILENAME,IDS_MESSAGESTORE_FILENAME1,PR_PST_PATH},
    { FALSE, IDS_ADDRESSBOOK_SERVICENAME, IDS_ADDRESSBOOK_DESCRIPTION,TRUE,
      IDS_ADDRESSBOOK_FILENAME,IDS_ADDRESSBOOK_FILENAME1,PR_PAB_PATH}};

  // walk through the list of services
  for (iRow = 0;iRow < pServiceRowSet->cRows;iRow ++) {
    DEBUGMSG("Profile contains service: %s (%s)",
      pServiceRowSet->aRow[iRow].lpProps[ivalDisplayName].Value.LPSZ,
      pServiceRowSet->aRow[iRow].lpProps[ivalServiceName].Value.LPSZ);

    // for each service, walk through our array of required services,
    // and see if there's a match
    for (iService = 0;iService < NUM_SERVICES;iService ++) {
      // load the name for this service out of resource
      LoadSz(MAPIServiceList[iService].uIDServiceName,
        szServiceName,sizeof(szServiceName));

      // compare it to the service name in the table of
      // installed services for this profile
      if (!lstrcmpi(szServiceName,
        pServiceRowSet->aRow[iRow].lpProps[ivalServiceName].Value.LPSZ)) {
         // this is a match!
        MAPIServiceList[iService].fPresent = TRUE;
        break;  // break the inner 'for' loop
      }
    }
  }


  // install any services we need which are not already present
  for (iService = 0;iService < NUM_SERVICES;iService ++) {

    if (!MAPIServiceList[iService].fPresent) {
      TCHAR szServiceDesc[MAX_RES_LEN+1];
      MSGSERVICE * pMsgService = &MAPIServiceList[iService];        

      // load the service name and description
      LoadSz(pMsgService->uIDServiceName,
        szServiceName,sizeof(szServiceName));
      LoadSz(pMsgService->uIDServiceDescription,
        szServiceDesc,sizeof(szServiceDesc));
      DEBUGMSG("Adding service: %s (%s)",
        szServiceDesc,szServiceName);

      // create the service
      hr = pServiceAdmin->CreateMsgService(szServiceName,
        szServiceDesc,0,0);
      if (HR_FAILED(hr))
        return hr;

      // call a creation-time config procedure if specified
      if (pMsgService->fNeedConfig) {

        // get the UID (identifier) for this service
        // based on service name, APIs downstream need this
        hr = GetServiceUID(szServiceName,pServiceAdmin,
          &pMapiUID);
        if (HR_FAILED(hr))
          return hr;
        ASSERT(pMapiUID);

        // call the proc to configure newly-created service
        hr = ConfigNewService(pServiceAdmin,pMapiUID,
          pMsgService->uIDStoreFilename,pMsgService->uIDStoreFilename1,
          pMsgService->uPropID);

        // free the buffer with the UID
        ASSERT(lpMAPIFreeBuffer);
        lpMAPIFreeBuffer(pMapiUID);
        pMapiUID = NULL;
      }
    }
  }

  return hr;
}

#define NUM_MAIL_PROPS   11
/*******************************************************************

  NAME:    ConfigInternetService

  SYNOPSIS:  Configures the Internet Mail service (route 66) with
        user's email name, email server, etc.

  ENTRY:    pMailConfigInfo - pointer to struct with configuration info
        pServiceAdmin - pointer to service admin interface

  EXIT:    returns an HRESULT

  NOTES:    will stomp any existing settings for properties that it
        sets.

********************************************************************/
HRESULT ConfigInternetService(MAILCONFIGINFO * pMailConfigInfo,
  LPSERVICEADMIN pServiceAdmin)
{
  HRESULT     hr;
  SPropValue  PropValue[NUM_MAIL_PROPS];
  TCHAR       szServiceName[SMALL_BUF_LEN+1];
  LPMAPIUID   pMapiUID=NULL;
  UINT        nProps = NUM_MAIL_PROPS;

  ASSERT(pMailConfigInfo);
  ASSERT(pServiceAdmin);

  // get service UID for internet mail service
  LoadSz(IDS_INTERNETMAIL_SERVICENAME,szServiceName,sizeof(szServiceName));
  hr = GetServiceUID(szServiceName,pServiceAdmin,&pMapiUID);
  if (HR_FAILED(hr)) {
    return hr;
  }
  ASSERT(pMapiUID);


  // set the property value for each property.  Note that the order
  // of items in the array doesn't mattter. The ulPropTag member indicates
  // what property the PropValue item is for, and the lpszA, b or l member
  // contains the data for that property.

  // need to "encrypt" mail account password with xor bit mask.  Mail client
  // expects it to be thusly "encrypted" when it reads it out.  It's stored
  // in the registry in this securely "encrypted" format.  Somebody pretty
  // smart must have thought of this.

  // configure mail service properties
  PropValue[0].ulPropTag  = PR_CFG_EMAIL_ADDRESS;
  PropValue[0].Value.LPSZ = pMailConfigInfo->pszEmailAddress;
  PropValue[1].ulPropTag  = PR_CFG_EMAIL_DISPLAY_NAME;
  PropValue[1].Value.LPSZ = pMailConfigInfo->pszEmailDisplayName;
  PropValue[2].ulPropTag  = PR_CFG_SERVER_PATH;
  PropValue[2].Value.LPSZ = pMailConfigInfo->pszEmailServer;
  PropValue[3].ulPropTag  = PR_CFG_EMAIL_ACCOUNT;
  PropValue[3].Value.LPSZ = pMailConfigInfo->pszEmailAccountName;
  PropValue[4].ulPropTag  = PR_CFG_PASSWORD;
  PropValue[4].Value.LPSZ = (LPTSTR) szNull;
  PropValue[5].ulPropTag  = PR_CFG_REMEMBER;
  PropValue[5].Value.b    = (USHORT) TRUE;
  // configure for RNA or LAN as appropriate
  PropValue[6].ulPropTag  = PR_CFG_RNA_PROFILE;
  PropValue[7].ulPropTag  = PR_CFG_CONN_TYPE;
  PropValue[8].ulPropTag  = PR_CFG_DELIVERY_OPTIONS;
  if (pMailConfigInfo->pszConnectoidName &&
    lstrlen(pMailConfigInfo->pszConnectoidName)) {
    PropValue[6].Value.LPSZ = pMailConfigInfo->pszConnectoidName;
    PropValue[7].Value.l = (long) CONNECT_TYPE_REMOTE;
    // set transfer mode for "selective"..
    PropValue[8].Value.l = DOWNLOAD_OPTION_HEADERS;
  } else {
    PropValue[6].Value.LPSZ = (LPTSTR) szNull;
    PropValue[7].Value.l = (long) CONNECT_TYPE_LAN;
    // set automatic transfer mode... mail guys made up the weird
    // define name, not me!
    PropValue[8].Value.l = DOWNLOAD_OPTION_MAIL_DELETE;
  }
  PropValue[9].ulPropTag   = PR_CFG_REMOTE_USERNAME;
  PropValue[9].Value.LPSZ  = pMailConfigInfo->pszEmailAccountName;
  PropValue[10].ulPropTag  = PR_CFG_REMOTE_PASSWORD;
  PropValue[10].Value.LPSZ = pMailConfigInfo->pszEmailAccountPwd;

  // call the service admin interface to configure the service with these
  // properties
  hr = pServiceAdmin->ConfigureMsgService(pMapiUID,NULL,0,
    nProps,PropValue);
  if (HR_FAILED(hr)) {
    DEBUGMSG("ConfigureMsgService returned 0x%x", hr);
  }

  // free the buffer with the UID
  ASSERT(lpMAPIFreeBuffer);
  lpMAPIFreeBuffer(pMapiUID);
  pMapiUID = NULL;

  return hr;
}

/*******************************************************************

  NAME:    ConfigMessageStore

  SYNOPSIS:  Generates a unique filename and sets it as the
        message store

  ENTRY:    lpServiceAdmin - pointer to service admin interface
        lpMapiUID - UID for this service (message store)

  EXIT:    returns an HRESULT

  NOTES:    This code expects to be called only when the service is
        newly created.  Calling it on an existing service will
        cause it to stomp existing settings.
  
********************************************************************/
HRESULT ConfigNewService(LPSERVICEADMIN lpServiceAdmin,LPMAPIUID lpMapiUID,
  UINT uIDFilename,UINT uIDFilename1,UINT uPropValID)
{
  TCHAR szMsgStorePath[MAX_PATH+1];
  HRESULT hr=hrSuccess;

  ASSERT(lpServiceAdmin);
  ASSERT(lpMapiUID);

  // build a path for the message store
  if (!MakeUniqueFilename(uIDFilename,uIDFilename1,
    szMsgStorePath,sizeof(szMsgStorePath))) {
     DEBUGTRAP("Unable to create unique filename");
    return MAPI_E_COLLISION;
  }
  DEBUGMSG("Creating MAPI store %s",szMsgStorePath);

  // set this filename for the message store
  SPropValue PropVal;
  PropVal.ulPropTag = uPropValID;
  PropVal.Value.LPSZ = szMsgStorePath;
  hr = lpServiceAdmin->ConfigureMsgService(lpMapiUID,NULL,0,1,&PropVal);
  if (HR_FAILED(hr)) {
    DEBUGMSG("ConfigureMsgService returned 0x%x", hr);
  }

  return hr;
}

/*******************************************************************

  NAME:    FindInternetMailService

  SYNOPSIS:  Detects if internet mail is installed, returns
        email address and email server if it is.
  
********************************************************************/
BOOL FindInternetMailService(TCHAR * pszEmailAddress,DWORD cbEmailAddress,
  TCHAR * pszEmailServer, DWORD cbEmailServer)
{
  ASSERT(pszEmailAddress);
  ASSERT(pszEmailServer);

  if (!hInstMAPIDll && !InitMAPI(NULL))
    return FALSE;

  // look through all profiles.  For each profile, look through all
  // services.  If we find an instance of the internet mail service,
  // then return email address and password to caller.  If there is
  // more than one profile with the internet mail service, we
  // will return the first one we find.

  ENUM_MAPI_PROFILE EnumMAPIProfile;
  LPTSTR lpProfileName,lpServiceName;
  BOOL fDefault;
  // walk through the list of profiles...
  while (EnumMAPIProfile.Next(&lpProfileName,&fDefault)) {
    ASSERT(lpProfileName);

    DEBUGMSG("Found profile: %s",lpProfileName);
    
    // for each profile, walk through the list of services...
    ENUM_MAPI_SERVICE EnumMAPIService(lpProfileName);
    while (EnumMAPIService.Next(&lpServiceName)) {
      TCHAR szSmallBuf[SMALL_BUF_LEN+1];

      DEBUGMSG("Found service: %s",lpServiceName);

      if (!lstrcmpi(lpServiceName,LoadSz(IDS_INTERNETMAIL_SERVICENAME,
        szSmallBuf,sizeof(szSmallBuf)))) {

//BUGBUG 21-May-1995 jeremys Get e-mail server & address from MAPI profile

        return TRUE;
      }
    }
  }

  return FALSE;
}               

ENUM_MAPI_PROFILE::ENUM_MAPI_PROFILE(VOID)
{
  LPPROFADMIN   pProfAdmin=NULL;  // interface to administer profiles
  HRESULT hr;

  ASSERTSZ(gpWizardState->fMAPIActive,"MAPI not initialized!");

  _pProfileRowSet = NULL;
  _nEntries = 0;
  _iRow = 0;

  // get a pointer to the interface to administer profiles
  ASSERT(lpMAPIAdminProfiles);
  hr = lpMAPIAdminProfiles(0,&pProfAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("MAPIAdminProfiles returned 0x%lx",hr);
    return;
  }
  ASSERT(pProfAdmin);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

  // get the rows in the profile table
  hr = GetProfileList(pProfAdmin,&_pProfileRowSet);
  if (HR_FAILED(hr))
    return;
  ASSERT(_pProfileRowSet);

  _nEntries = _pProfileRowSet->cRows;

}

ENUM_MAPI_PROFILE::~ENUM_MAPI_PROFILE(VOID)
{
  if (_pProfileRowSet) {
    // done with profile row set, free the table
    FreeSRowSet(_pProfileRowSet);
    _pProfileRowSet = NULL;
  }
}

BOOL ENUM_MAPI_PROFILE::Next(LPTSTR * ppProfileName,BOOL * pfDefault)
{
  ASSERT(pfDefault);

  if (!_pProfileRowSet)
    return FALSE;

  if (_iRow < _pProfileRowSet->cRows) {
    LPSPropValue pPropVal = _pProfileRowSet->aRow[_iRow].lpProps;
    ASSERT(pPropVal);

    // get pointer to profile name
    *ppProfileName = pPropVal[0].Value.LPSZ;
    ASSERT(*ppProfileName);
    // set 'this profile is default' flag
    *pfDefault = pPropVal[2].Value.b;

    _iRow++;
    return TRUE;
  }
  
  return FALSE;
}

ENUM_MAPI_SERVICE::ENUM_MAPI_SERVICE(LPTSTR pszProfileName)
{
  LPPROFADMIN   pProfAdmin=NULL;  // interface to administer profiles
  LPSERVICEADMIN  pServiceAdmin=NULL;  // interface to administer services
  HRESULT hr;

  ASSERT(pszProfileName);
  ASSERTSZ(gpWizardState->fMAPIActive,"MAPI not initialized!");

  _pServiceRowSet = NULL;
  _nEntries = 0;
  _iRow = 0;

  // get a pointer to the interface to administer profiles
  ASSERT(lpMAPIAdminProfiles);
  hr = lpMAPIAdminProfiles(0,&pProfAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("MAPIAdminProfiles returned 0x%lx",hr);
    return;
  }
  ASSERT(pProfAdmin);
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseProfAdminLater(pProfAdmin);

  // get a pointer to the interface to administer services for this profile
  hr = pProfAdmin->AdminServices(pszProfileName,NULL,NULL,0,
    &pServiceAdmin);
  if (HR_FAILED(hr)) {
    DEBUGMSG("AdminServices returned 0x%lx",hr);
    return;
  }
  // release this interface when we leave the function
  RELEASE_ME_LATER ReleaseServiceAdminLater(pServiceAdmin);

  // get the rows in the profile table
  hr = GetServicesList(pServiceAdmin,&_pServiceRowSet);
  if (HR_FAILED(hr))
    return;
  ASSERT(_pServiceRowSet);

  _nEntries = _pServiceRowSet->cRows;

}

ENUM_MAPI_SERVICE::~ENUM_MAPI_SERVICE(VOID)
{
  if (_pServiceRowSet) {
    // done with profile row set, free the table
    FreeSRowSet(_pServiceRowSet);
    _pServiceRowSet = NULL;
  }
}

BOOL ENUM_MAPI_SERVICE::Next(LPTSTR * ppServiceName)
{
  if (!_pServiceRowSet)
    return FALSE;

  if (_iRow < _pServiceRowSet->cRows) {
    LPSPropValue pPropVal = _pServiceRowSet->aRow[_iRow].lpProps;
    ASSERT(pPropVal);

    // get pointer to profile name
    *ppServiceName = pPropVal[ivalServiceName].Value.LPSZ;
    ASSERT(*ppServiceName);

    _iRow++;
    return TRUE;
  }
  
  return FALSE;
}

/*******************************************************************

  NAME:    MakeUniqueFilename

  SYNOPSIS:  Generates a filename in the Windows directory that
        does not already exist

  ENTRY:    uIDFilename - ID of string resource for desired name
          for the file
        uIDAltFilename - ID of string resource with template
          for filename to use if file with uIDFilename's name
          already exists.  Template should contain %u into
          which numbers will be inserted to make filename unique.
        pszFilename - buffer to return path and filename into
        cbFilename - size of pszFilename buffer

  EXIT:    returns TRUE if successful, FALSE if couldn't make
        unique filename within MAX_FILENAME_TRIES tries
  
********************************************************************/
// number of times we'll try to create a unique filename before giving up
#define MAX_MAKEFILENAME_TRIES  20
BOOL MakeUniqueFilename(UINT uIDFilename,UINT uIDAltFilename,
  TCHAR * pszFilename,DWORD cbFilename)
{
  TCHAR szFileName[SMALL_BUF_LEN+1];
  BOOL fSuccess = FALSE;

  ASSERT(pszFilename);

  // build a path for the filename
  UINT uRet=GetWindowsDirectory(pszFilename,cbFilename);
  ASSERTSZ(uRet,"GetWindowsDirectory failed");

  // choose a file name that doesn't already exist

  // first, try using the string resource specified by uIDFilename
  LoadSz(uIDFilename,szFileName,sizeof(szFileName));
  if (DoesFileExist(pszFilename,szFileName)) {

    // if that file exists, then use the string resource uIDAltFilename
    // which has a replacable parameter.  We'll try adding numbers to
    // the filename to make it unique.
    
    TCHAR szFileFmt[SMALL_BUF_LEN+1];
    LoadSz(uIDAltFilename,szFileFmt,sizeof(szFileFmt));

    for (UINT nIndex = 0; nIndex < MAX_MAKEFILENAME_TRIES; nIndex ++) {
      // make a name e.g. "mailbox4.pst"
      wsprintf(szFileName,szFileFmt,nIndex);
      if (!DoesFileExist(pszFilename,szFileName)) {
        // OK, found a filename that doesn't exist
        fSuccess = TRUE;
        break;
      }
    }
  } else {
    // first try succeeded  
    fSuccess = TRUE;
  }

  if (fSuccess) {
    // now we have unique filename, build the full path

    lstrcat(pszFilename,szSlash);
    lstrcat(pszFilename,szFileName);
  }

  return fSuccess;
}

/*******************************************************************

  NAME:    DoesFileExist

  SYNOPSIS:  Checks to see whether the specified file exists

  ENTRY:    pszPath - path to directory
        pszFilename - name of file

  EXIT:    returns TRUE if file exists, FALSE if it doesn't
  
********************************************************************/
BOOL DoesFileExist(TCHAR * pszPath,TCHAR * pszFileName)
{
  CHAR      szPath[MAX_PATH+1];
  OFSTRUCT  of;

  ASSERT(pszPath);
  ASSERT(pszFileName);

  // concatenate the path and file name
#ifdef UNICODE
  TCHAR     szTmp[MAX_PATH+1];

  lstrcpy(szTmp,pszPath);
  lstrcat(szTmp,szSlash);
  lstrcat(szTmp,pszFileName);
  
  wcstombs(szPath, szTmp, MAX_PATH+1);
#else
  lstrcpy(szPath,pszPath);
  lstrcat(szPath,szSlash);
  lstrcat(szPath,pszFileName);
#endif

  // find out if this file exists
  return (OpenFile(szPath,&of,OF_EXIST) != HFILE_ERROR);
}

/*******************************************************************

  NAME:    GetServiceUID

  SYNOPSIS:  Given a MAPI service name, gets the MAPIUID associated
        with it.

  ENTRY:    pszServiceName - name of MAPI service (e.g. "IMAIL","MSPST AB")
        lpServiceAdmin - pointer to service admin interface
        ppMapiUID - pointer to pointer for MAPIUID struct
  
  EXIT:    returns an HRESULT

  NOTES:    Cloned from MAPI profile wizard code, if you think this
        function is big and ugly now you should have seen it before
        I cleaned it up.

        This function allocates a MAPIUID, the caller is responsible
        for freeing this (use MAPIFreeBuffer) when done.
  
********************************************************************/
HRESULT   GetServiceUID(TCHAR * pszServiceName,LPSERVICEADMIN lpServiceAdmin,
  LPMAPIUID *ppMapiUID)
{
  HRESULT      hr =hrSuccess;
  LPSPropValue  pTblProp =NULL;
  DWORD         iRow,iColumn;
  LPMAPITABLE     pTable =NULL;
  LPSRowSet    pRowSet =NULL;
  LPSRow      pRow =NULL;
  int        nFound =0;
  LPMAPIUID    pMapiUID =NULL;
  BOOL      fContinue = TRUE;
  SizedSPropTagArray(2, Tbltaga) = { 2, { PR_SERVICE_NAME,
                      PR_SERVICE_UID }};

  ASSERT(pszServiceName);
  ASSERT(lpServiceAdmin);
  ASSERT(ppMapiUID);

  // get table of message services
  hr = lpServiceAdmin->GetMsgServiceTable(0, &pTable);
  if (HR_FAILED(hr))
  {
    DEBUGMSG("GetMsgServiceTable returned 0x%x", hr);
    return hr;
  }
  ASSERT(pTable);
  // release this table when we exit this function
  RELEASE_ME_LATER rlTable(pTable);

  ASSERT(lpHrQueryAllRows);
  hr = lpHrQueryAllRows(pTable, (LPSPropTagArray) &Tbltaga, NULL, NULL, 0, &pRowSet);
  if (HR_FAILED(hr))
  {
    DEBUGMSG("HrQueryAllRows returned 0x%x", hr);
    return hr;
  }
  ASSERT(pRowSet);

  iRow =0;
  while (fContinue && iRow< pRowSet->cRows)
  {
    pRow = &pRowSet->aRow[iRow];
    pTblProp = pRow->lpProps;
    nFound = 0;
    for (iColumn=0; iColumn<pRow->cValues; iColumn++)
    {   //Check each property
      if (pTblProp->ulPropTag ==PR_SERVICE_UID)
      {
        nFound++;
        ASSERT(lpMAPIAllocateBuffer);
        lpMAPIAllocateBuffer(pTblProp->Value.bin.cb, (LPVOID FAR *) &pMapiUID);
        if (!pMapiUID)
        {
          hr = MAPI_E_NOT_ENOUGH_MEMORY;
          fContinue = FALSE;
          break;
        }
        memcpy(pMapiUID, pTblProp->Value.bin.lpb, (size_t) pTblProp->Value.bin.cb);
        *ppMapiUID = pMapiUID;
      }
      else if ((pTblProp->ulPropTag ==PR_SERVICE_NAME) &&
           !lstrcmpi(pTblProp->Value.LPSZ, pszServiceName))
      {
        nFound++;
      }
      pTblProp++;

      if (nFound == 2) {
        // found it!
        fContinue = FALSE;
        break;
      }
    }
    iRow++;

    if (nFound < 2) {    
    // if one but not both items matched above, then deallocate buffer
      if (pMapiUID) {
        ASSERT(lpMAPIFreeBuffer);
        lpMAPIFreeBuffer(pMapiUID);
        pMapiUID =NULL;
      }
      if (*ppMapiUID)
        *ppMapiUID = NULL;
    }
  }

  if (HR_FAILED(hr) || nFound < 2) {
    // free buffer if we didn't find the UID
    if (pMapiUID) {
      ASSERT(lpMAPIFreeBuffer);
      lpMAPIFreeBuffer(pMapiUID);
    }
    if (*ppMapiUID)
      *ppMapiUID = NULL;
  }

  if (pRowSet)
    FreeSRowSet(pRowSet);

  return hr;
}

/*******************************************************************

  NAME:    FreeSRowSet

  SYNOPSIS:  Frees an SRowSet structure and the rows therein

  ENTRY:    prws - the row set to free

  NOTES:    Cloned from MAPI profile ctrl panel code

********************************************************************/
VOID FreeSRowSet(LPSRowSet prws)
{
  ULONG irw;

  if (!prws)
    return;

  ASSERT(lpMAPIFreeBuffer);

  // Free each row
  for (irw = 0; irw < prws->cRows; irw++)
    lpMAPIFreeBuffer(prws->aRow[irw].lpProps);

  // Free the top level structure
  lpMAPIFreeBuffer(prws);
}

/*
 *  ValidateProperty
 *
 *  Purpose:
 *    Given a string prop, make sure it contains a valid string.
 *
 *  Arguments:
 *    pval
 *    cVal
 *    ulPropTag
 *
 *  Returns:
 *    BOOL
 */
TCHAR szUnk[] = TEXT("???");
BOOL ValidateProperty(LPSPropValue pval, ULONG cVal, ULONG ulPropTag)
{
  if(pval[cVal].ulPropTag != ulPropTag)
  {
    // make sure we're not stomping on good properties.
    ASSERT(PROP_TYPE(pval[cVal].ulPropTag) == PT_ERROR);

    pval[cVal].ulPropTag = ulPropTag;
    pval[cVal].Value.LPSZ = szUnk;

    return TRUE;
  }

  return FALSE;
}

#pragma data_seg(DATASEG_READONLY)
// note: this array depends on errors in rc file being in this order
// starting with S_OK.  Don't rearrange one without rearranging the other.
static SCODE mpIdsScode[] =
{
    S_OK,
    MAPI_E_NO_ACCESS,
    E_NOINTERFACE,
    E_INVALIDARG,
    MAPI_E_CALL_FAILED,
    MAPI_E_NOT_FOUND,
    MAPI_E_NO_SUPPORT,
    MAPI_W_ERRORS_RETURNED,
    MAPI_W_PARTIAL_COMPLETION,
    MAPI_E_BAD_CHARWIDTH,
    MAPI_E_BAD_VALUE,
    MAPI_E_BUSY,
    MAPI_E_COLLISION,
    MAPI_E_COMPUTED,
    MAPI_E_CORRUPT_DATA,
    MAPI_E_CORRUPT_STORE,
    MAPI_E_DISK_ERROR,
    MAPI_E_HAS_FOLDERS,
    MAPI_E_HAS_MESSAGES,
    MAPI_E_INVALID_ENTRYID,
    MAPI_E_INVALID_OBJECT,
    MAPI_E_LOGON_FAILED,
    MAPI_E_NETWORK_ERROR,
    MAPI_E_NON_STANDARD,
    MAPI_E_NOT_ENOUGH_DISK,
    MAPI_E_NOT_ENOUGH_MEMORY,
    MAPI_E_NOT_ENOUGH_RESOURCES,
    MAPI_E_NOT_IN_QUEUE,
    MAPI_E_OBJECT_CHANGED,
    MAPI_E_OBJECT_DELETED,
    MAPI_E_STRING_TOO_LONG,
    MAPI_E_SUBMITTED,
    MAPI_E_TOO_BIG,
    MAPI_E_UNABLE_TO_ABORT,
    MAPI_E_UNCONFIGURED,
    MAPI_E_UNEXPECTED_TYPE,
    MAPI_E_UNKNOWN_FLAGS,
    MAPI_E_USER_CANCEL,
    MAPI_E_VERSION
};
#pragma data_seg()

/*******************************************************************

  NAME:    GetMAPIErrorText

  SYNOPSIS:  Gets text string corresponding to MAPI error code

  ENTRY:    uErr - MAPI error code
        pszErrText - buffer to retrieve error text description
        cbErrText - size of pszErrText buffer

  NOTES:    based on MapScodeSz from MAPI SDK.  There is, alas,
        no function built into MAPI to do this.  Every app
        must include all text strings for every error code,
        and will be broken on any error codes MAPI invents
        after the app ships.  Numbskulls.

********************************************************************/
VOID GetMAPIErrorText(UINT uErr,TCHAR * pszErrText,DWORD cbErrText)
{
  ASSERT(pszErrText);
  
  SCODE scErr = (SCODE) uErr;
  UINT nIndex,nMax;

  // get facility code, facility is bits 17-30 in scode
  DWORD dwFacility = (scErr >> 16) & (0x7FFF);

  // if this is a WIN32 code wrapped in an scode, call GetErrorDescription
  // to get the text, which will get the text out of Windows and do a much
  // better job than this crappy little function will
  if (dwFacility == FACILITY_WIN32) 
    GetErrorDescription(pszErrText,cbErrText,
      (scErr & 0xFFFF),ERRCLS_STANDARD);

    /* Linear search in mpIdsScode for scArg.  When found, index is IDS. */
    nMax = sizeof mpIdsScode / sizeof mpIdsScode[0];
    for (nIndex = 0; nIndex < nMax; nIndex++)
    {
        if (mpIdsScode[nIndex] == scErr)
            break;
    }

  if (nIndex < nMax) {
    // found the code in the table
    LoadSz(IDS_MAPIERROR_BASE + nIndex,pszErrText,cbErrText);
  } else {
    // didn't find the code in the table, make a generic string
    // with the error number
    TCHAR szFmt[SMALL_BUF_LEN+1];
    LoadSz(IDS_GENERIC_MAPI_ERROR,szFmt,sizeof(szFmt));
    wsprintf(pszErrText,szFmt,scErr);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\connectionwizard\inetcfg\introui.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  INTROUI.C - Functions for introductory Wizard pages
//

//  HISTORY:
//  
//  12/22/94  jeremys  Created.
//  96/03/07  markdu  Use global modem enum object (gpEnumModem) for
//            all modem stuff (only need to enum once unless we add a modem)
//  96/03/10  markdu  Moved all references to modem name into RASENTRY.
//  96/03/11  markdu  Check new CLIENTCONFIG flags before installing
//            RNA and TCP.
//  96/03/16  markdu  Use ReInit member function to re-enumerate modems.
//  96/03/22  markdu  Work around problem with fInstallMail to allow the
//            user to decide whether to install mail.
//  96/03/22  markdu  Always display both modem and LAN options, regardless
//            of what hardware is present.
//  96/03/22  markdu  Remove IP setup from LAN path.
//  96/03/23  markdu  Replaced CLIENTINFO references with CLIENTCONFIG.
//  96/03/24  markdu  Return error values from EnumerateModems().
//  96/03/25  markdu  If a fatal error occurs, set gfQuitWizard.
//  96/04/04  markdu  Added pfNeedsRestart to WarnIfServerBound
//  96/04/06  markdu  Moved CommitConfigurationChanges call to last page.
//  96/05/06  markdu  NASH BUG 15637 Removed unused code.
//  96/05/06  markdu  NASH BUG 21165 Reordered page logic.
//  96/05/14  markdu  NASH BUG 21704 Do not install TCP/IP on LAN path.
//  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing
//            PPPMAC and TCP/IP.
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Use lpIcfgInstallInetComponents and lpIcfgNeedInetComponents.
//  96/09/13  valdonb Remove welcome dialog
//

#include "wizard.h"
#include "interwiz.h"
#include "icwextsn.h"
#include "icwaprtc.h"
#include "imnext.h"

UINT GetModemPage(HWND hDlg);
VOID EnableWizard(HWND hDlg,BOOL fEnable);
HRESULT EnumerateModems(HWND hwndParent, ENUM_MODEM** ppEnumModem);
BOOL IsMoreThanOneModemInstalled(ENUM_MODEM* pEnumModem);
BOOL IsModemInstalled(ENUM_MODEM* pEnumModem);
extern ICFGINSTALLSYSCOMPONENTS     lpIcfgInstallInetComponents;
extern ICFGNEEDSYSCOMPONENTS        lpIcfgNeedInetComponents;
extern ICFGGETLASTINSTALLERRORTEXT  lpIcfgGetLastInstallErrorText;
BOOL FGetSystemShutdownPrivledge();
BOOL g_bSkipMultiModem = FALSE;
int  nCurrentModemSel = 0;

// from commctrl defines...
#define IDD_BACK    0x3023
#define IDD_NEXT    0x3024


//*******************************************************************
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had
//                already picked
//
//    Arguements  szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return      TRUE - success
//
//    History     10/21/96    VYung    Created
//*******************************************************************
BOOL GetDeviceSelectedByUser (LPTSTR szKey, LPTSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,ISIGNUP_KEY,&hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey,szKey,0,&dwType,
            (LPBYTE)szBuf,&dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

/*******************************************************************

  NAME:    HowToConnectInitProc

  SYNOPSIS:  Called when "How to Connect" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK HowToConnectInitProc(HWND hDlg,BOOL fFirstInit)
{
  // If we were started by inetwiz.exe, there is nothing to
  // go back to, so only show the "next" button
  // (actually, this will only disable the back button, not hide it.)
  if (!(gpWizardState->dwRunFlags & (RSW_NOFREE | RSW_APPRENTICE) ))
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);

  if (fFirstInit)
  {
    // initialize radio buttons
    CheckDlgButton(hDlg,IDC_CONNECT_BY_PHONE,
                    CONNECT_RAS == gpUserInfo->uiConnectionType);
    CheckDlgButton(hDlg,IDC_CONNECT_BY_LAN,
                    CONNECT_LAN == gpUserInfo->uiConnectionType);
    CheckDlgButton(hDlg,IDC_CONNECT_MANUAL,
                    CONNECT_MANUAL == gpUserInfo->uiConnectionType);

    // Normandy 11970 ChrisK - we need a different title if launched from
    // mail or news configuration
    if ( (gpWizardState->dwRunFlags & RSW_APPRENTICE))
    {
        if (!g_fIsExternalWizard97)
        {
            TCHAR szTitle[MAX_RES_LEN+1];
            if (LoadSz(IDS_BEGINMANUAL_ALTERNATE,szTitle,sizeof(szTitle)))
                SetWindowText (GetDlgItem(hDlg,IDC_LBLTITLE), szTitle);
        }                
    }
    else
    {
        // if we're not here via the apprentice interface, hide the
        // manual connect option
        ASSERT( CONNECT_MANUAL != gpUserInfo->uiConnectionType );
        ShowWindow( GetDlgItem(hDlg,IDC_CONNECT_MANUAL), SW_HIDE);
    }

    // load in strings for the description paragraph
    TCHAR szWhole[ (2 * MAX_RES_LEN) + 1] = TEXT("\0");
    TCHAR szTemp[ MAX_RES_LEN + 1] = TEXT("nothing\0");
    LoadSz(IDS_HOWTOCONNECT_DESC1,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 
    LoadSz(IDS_HOWTOCONNECT_DESC2,szTemp,sizeof(szTemp));
    lstrcat( szWhole, szTemp ); 

    SetWindowText (GetDlgItem(hDlg,IDC_DESC), szWhole);


  }

  // if we've travelled through external apprentice pages,
  // it's easy for our current page pointer to get munged,
  // so reset it here for sanity's sake.
  gpWizardState->uCurrentPage = ORD_PAGE_HOWTOCONNECT;


  return TRUE;
}

/*******************************************************************

  NAME:    HowToConnectOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "How to
        Connect" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
   