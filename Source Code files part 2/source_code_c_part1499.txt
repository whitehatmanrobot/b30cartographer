 over.
					//
					// So, to avoid that, we need to make mappings
					// deterministic, such that if the same internal client
					// tries to map the same internal port, it should ask
					// for the same external port every time.  That way, if
					// there happens to be a virtual connection hanging
					// around from a previous attempt, we'll reuse it
					// instead of clashing and getting the packet dropped.
					//
					// Our actual algorithm:
					//	1. start with the internal client IP.
					//	2. combine in the internal port being mapped.
					//	3. add 1025 if necessary to get it out of the
					//		reserved range.
					//

					inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();

					wOriginalExternalPortHostOrder = inaddrTemp.S_un.S_un_w.s_w1;
					wOriginalExternalPortHostOrder ^= inaddrTemp.S_un.S_un_w.s_w2;
					wOriginalExternalPortHostOrder ^= psaddrinTemp[dwTemp].sin_port;
					
					if (wOriginalExternalPortHostOrder <= MAX_RESERVED_PORT)
					{
						wOriginalExternalPortHostOrder += MAX_RESERVED_PORT + 1;
					}


					//
					// This is the starting point, we'll increment by one
					// as we go.
					//
					wExternalPortHostOrder = wOriginalExternalPortHostOrder;
				}
				else
				{
					//
					// Go to the next sequential port.  If we've wrapped
					// around to 0, move to the first non reserved range
					// port.
					//
					wExternalPortHostOrder++;
					if (wExternalPortHostOrder == 0)
					{
						wExternalPortHostOrder = MAX_RESERVED_PORT + 1;
					}


					//
					// If we wrapped all the way back around to the first
					// port we tried, we have to fail.
					//
					if (wExternalPortHostOrder == wOriginalExternalPortHostOrder)
					{
						DPFX(DPFPREP, 0, "All ports were exhausted (before index %u), marking port as unavailable.",
							dwTemp);


						//
						// Delete all mappings successfully made up until
						// now.
						//
						DNASSERT(dwTemp > 0);

						hr = this->UnmapUPnPPort(pRegisteredPort, dwTemp, TRUE);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Failed deleting %u previously mapped ports after getting failure response 0x%lx!",
								dwTemp, RespInfo.hrErrorCode);
							goto Failure;
						}


						//
						// The port is unavailable.
						//
						pRegisteredPort->NoteUPnPPortUnavailable();


						//
						// We're done here.  Ideally we would goto Exit, but
						// we want to execute the public address array
						// cleanup code.  hr will == DPNH_OK.
						//
						goto Failure;
					}
				} // end if (haven't selected first port yet)
			}
		}
		else
		{
			//
			// Use the fixed port.
			//
			wExternalPortHostOrder = NTOHS(psaddrinTemp[dwTemp].sin_port);
		}

		wsprintf(tszInternalPort, _T("%u"),
				NTOHS(psaddrinTemp[dwTemp].sin_port));


Retry:

		//
		// Because the UPnP spec allows a device to overwrite existing
		// mappings if they are for the same client, we have to make sure
		// that no local DPNHUPNP instances, including this one, have an
		// active mapping for that public port.
		// Rather than having the retry code in multiple places, I'll use
		// the somewhat ugly 'goto' to jump straight to the existing port
		// unavailable handling.
		//
		if (this->IsNATPublicPortInUseLocally(wExternalPortHostOrder))
		{
			DPFX(DPFPREP, 1, "Port %u is already in use locally.");
			RespInfo.hrErrorCode = DPNHERR_PORTUNAVAILABLE;
			goto PortUnavailable;
		}


		//
		// If the control socket got disconnected after the last message,
		// then reconnect.
		//
		if (! pUPnPDevice->IsConnected())
		{
			hr = this->ReconnectUPnPControlSocket(pUPnPDevice);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't reconnect UPnP control socket!");
				goto Failure;
			}
		}

		DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);


		wsprintf(tszExternalPort, _T("%u"), wExternalPortHostOrder);



		//
		// Generate a description for this mapping.  The format is:
		//
		//     [executable_name] (nnn.nnn.nnn.nnn:nnnnn) nnnnn {"TCP" | "UDP"}
		//
		// That way nothing needs to be localized.
		//

		dwDescriptionLength = GetModuleFileName(NULL,
												tszDescription,
												(MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1));
		if (dwDescriptionLength != 0)
		{
			//
			// Be paranoid and make sure the description string is valid.
			//
			tszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1] = 0;

			//
			// Get just the executable name from the path.
			//
#ifdef WINCE
			GetExeName(tszDescription);
#else // ! WINCE
#ifdef UNICODE
			_wsplitpath(tszDescription, NULL, NULL, tszDescription, NULL);
#else // ! UNICODE
			_splitpath(tszDescription, NULL, NULL, tszDescription, NULL);
#endif // ! UNICODE
#endif // ! WINCE


			dwDescriptionLength = _tcslen(tszDescription)		// executable name
								+ 2								// " ("
								+ _tcslen(tszInternalClient)	// private IP address
								+ 1								// ":"
								+ _tcslen(tszInternalPort)		// private port
								+ 2								// ") "
								+ _tcslen(tszExternalPort)		// public port
								+ 4;							// " TCP" | " UDP"

			//
			// Make sure the long string will fit.  If not, use the
			// abbreviated version.
			//
			if (dwDescriptionLength > MAX_UPNP_MAPPING_DESCRIPTION_SIZE)
			{
				dwDescriptionLength = 0;
			}
		}

		if (dwDescriptionLength == 0)
		{
			//
			// Use the abbreviated version we know will fit.
			//
			wsprintf(tszDescription,
					_T("(%s:%s) %s %s"),
					tszInternalClient,
					tszInternalPort,
					tszExternalPort,
					((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
		}
		else
		{
			//
			// There's enough room, tack on the rest of the description.
			//
			wsprintf((tszDescription + _tcslen(tszDescription)),
					_T(" (%s:%s) %s %s"),
					tszInternalClient,
					tszInternalPort,
					tszExternalPort,
					((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
		}


		DPFX(DPFPREP, 6, "Requesting mapping \"%s\".", tszDescription);


		iContentLength = strlen("<s:Envelope" EOL)
						+ strlen("    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL)
						+ strlen("    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL)
						+ strlen("  <s:Body>" EOL)
						+ strlen("    <u:" ACTION_ADDPORTMAPPING_A " xmlns:u=\"") + pUPnPDevice->GetStaticServiceURILength() + strlen("\">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWREMOTEHOST_A ">" UPNP_WILDCARD "</" ARG_ADDPORTMAPPING_NEWREMOTEHOST_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A ">") + _tcslen(tszExternalPort) + strlen("</" ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWPROTOCOL_A ">") + 3 + strlen("</" ARG_ADDPORTMAPPING_NEWPROTOCOL_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWINTERNALPORT_A ">") + _tcslen(tszInternalPort) + strlen("</" ARG_ADDPORTMAPPING_NEWINTERNALPORT_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWINTERNALCLIENT_A ">") + _tcslen(tszInternalClient) + strlen("</" ARG_ADDPORTMAPPING_NEWINTERNALCLIENT_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWENABLED_A ">" UPNP_BOOLEAN_TRUE "</" ARG_ADDPORTMAPPING_NEWENABLED_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWPORTMAPPINGDESCRIPTION_A ">") + _tcslen(tszDescription) + strlen("</" ARG_ADDPORTMAPPING_NEWPORTMAPPINGDESCRIPTION_A ">" EOL)
						+ strlen("      <" ARG_ADDPORTMAPPING_NEWLEASEDURATION_A ">") + _tcslen(tszLeaseDuration) + strlen("</" ARG_ADDPORTMAPPING_NEWLEASEDURATION_A ">" EOL)
						+ strlen("    </u:" ACTION_ADDPORTMAPPING_A ">" EOL)
						+ strlen("  </s:Body>" EOL)
						+ strlen("</s:Envelope>" EOL)
						+ strlen(EOL);

		wsprintf(tszContentLength, _T("%i"), iContentLength);

		iMsgSize = strlen("POST ") + strlen(pUPnPDevice->GetServiceControlURL()) + strlen(" " HTTP_VERSION EOL)
					+ strlen("HOST: ") + _tcslen(tszHost) + strlen(EOL)
					+ strlen("CONTENT-LENGTH: ") + _tcslen(tszContentLength) + strlen(EOL)
					+ strlen("CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL)
					+ strlen("SOAPACTION: ") + pUPnPDevice->GetStaticServiceURILength() + strlen("#" ACTION_ADDPORTMAPPING_A EOL)
					+ strlen(EOL)
					+ iContentLength;


		//
		// Allocate (or reallocate) the message buffer.
		//
		if (iMsgSize > iPrevMsgSize)
		{
			if (pszMessage != NULL)
			{
				DNFree(pszMessage);
				pszMessage = NULL;
			}

			pszMessage = (char*) DNMalloc(iMsgSize + 1); // include room for NULL termination that isn't actually sent
			if (pszMessage == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			iPrevMsgSize = iMsgSize;
		}

		strcpy(pszMessage, "POST ");
		strcat(pszMessage, pUPnPDevice->GetServiceControlURL());
		strcat(pszMessage, " " HTTP_VERSION EOL);
		strcat(pszMessage, "HOST: ");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszHost,
						(_tcslen(tszHost) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszHost);
#endif // ! UNICODE
		strcat(pszMessage, EOL);
		strcat(pszMessage, "CONTENT-LENGTH: ");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszContentLength,
						(_tcslen(tszContentLength) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszContentLength);
#endif // ! UNICODE
		strcat(pszMessage, EOL);
		strcat(pszMessage, "CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL);
		strcat(pszMessage, "SOAPACTION: ");
		strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
		strcat(pszMessage, "#" ACTION_ADDPORTMAPPING_A EOL);
		strcat(pszMessage, EOL);


		strcat(pszMessage, "<s:Envelope" EOL);
		strcat(pszMessage, "    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL);
		strcat(pszMessage, "    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL);
		strcat(pszMessage, "  <s:Body>" EOL);
		strcat(pszMessage, "    <u:" ACTION_ADDPORTMAPPING_A " xmlns:u=\"");
		strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
		strcat(pszMessage, "\">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWREMOTEHOST_A ">" UPNP_WILDCARD "</" ARG_ADDPORTMAPPING_NEWREMOTEHOST_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszExternalPort,
						(_tcslen(tszExternalPort) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszExternalPort);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWPROTOCOL_A ">");
		strcat(pszMessage, ((pRegisteredPort->IsTCP()) ? "TCP" : "UDP"));
		strcat(pszMessage, "</" ARG_ADDPORTMAPPING_NEWPROTOCOL_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWINTERNALPORT_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszInternalPort,
						(_tcslen(tszInternalPort) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszInternalPort);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_ADDPORTMAPPING_NEWINTERNALPORT_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWINTERNALCLIENT_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszInternalClient,
						(_tcslen(tszInternalClient) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszInternalClient);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_ADDPORTMAPPING_NEWINTERNALCLIENT_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWENABLED_A ">" UPNP_BOOLEAN_TRUE "</" ARG_ADDPORTMAPPING_NEWENABLED_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWPORTMAPPINGDESCRIPTION_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszDescription,
						(_tcslen(tszDescription) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszDescription);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_ADDPORTMAPPING_NEWPORTMAPPINGDESCRIPTION_A ">" EOL);

		strcat(pszMessage, "      <" ARG_ADDPORTMAPPING_NEWLEASEDURATION_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszLeaseDuration,
						(_tcslen(tszLeaseDuration) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszLeaseDuration);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_ADDPORTMAPPING_NEWLEASEDURATION_A ">" EOL);

		strcat(pszMessage, "    </u:" ACTION_ADDPORTMAPPING_A ">" EOL);
		strcat(pszMessage, "  </s:Body>" EOL);
		strcat(pszMessage, "</s:Envelope>" EOL);
		strcat(pszMessage, EOL);


#ifdef DBG
		this->PrintUPnPTransactionToFile(pszMessage,
										iMsgSize,
										"Outbound add port mapping request",
										pDevice);
#endif // DBG

		iReturn = this->m_pfnsend(pUPnPDevice->GetControlSocket(),
									pszMessage,
									iMsgSize,
									0);

		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u when sending control request to UPnP device!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		if (iReturn != iMsgSize)
		{
			DPFX(DPFPREP, 0, "Didn't send entire message (%i != %i)?!", iReturn, iMsgSize);
			DNASSERT(FALSE);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// We have the lock so no one could have tried to receive data from
		// the control socket yet.  Mark the device as waiting for a
		// response.
		//
		ZeroMemory(&RespInfo, sizeof(RespInfo));
		pUPnPDevice->StartWaitingForControlResponse(CONTROLRESPONSETYPE_ADDPORTMAPPING,
													&RespInfo);
		fStartedWaitingForControlResponse = TRUE;


		//
		// Actually wait for the response.
		//
		dwStartTime = GETTIMESTAMP();
		dwTimeout = g_dwUPnPResponseTimeout;
		do
		{
			hr = this->CheckForReceivedUPnPMsgsOnDevice(pUPnPDevice, dwTimeout);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed receiving UPnP messages!");
				goto Failure;
			}

			//
			// We either timed out or got some data.  Check if we got the
			// response we need.
			//
			if (! pUPnPDevice->IsWaitingForControlResponse())
			{
				if (RespInfo.hrErrorCode != DPNH_OK)
				{
					//
					// Make sure it's not the "I can't handle asymmetric
					// mappings" error.  If it is, note the fact that this
					// device is going to force us to have worse behavior
					// and try again.
					//
					if (RespInfo.hrErrorCode == (HRESULT) UPNPERR_IGD_SAMEPORTVALUESREQUIRED)
					{
						DPFX(DPFPREP, 1, "UPnP device 0x%p does not support asymmetric mappings.",
							pUPnPDevice);

						//
						// Make sure we're not getting this error from a bad
						// device.  Otherwise we might get caught in a loop.
						//
						if ((! pUPnPDevice->DoesNotSupportAsymmetricMappings()) &&
							(! pRegisteredPort->IsFixedPort()) &&
							(dwTemp == 0))
						{
							//
							// Remember that this device is unfriendly.
							//
							pUPnPDevice->NoteDoesNotSupportAsymmetricMappings();

							//
							// Use the same port externally next time.
							//
							DNASSERT(wExternalPortHostOrder != NTOHS(psaddrinTemp[dwTemp].sin_port));
							wExternalPortHostOrder = NTOHS(psaddrinTemp[dwTemp].sin_port);

							//
							// Try again.
							//
							goto Retry;
						}

						DPFX(DPFPREP, 1, "DoesNotSupportAsymmetricMappings = %i, fixed port = %i, port index = %u",
							pUPnPDevice->DoesNotSupportAsymmetricMappings(),
							pRegisteredPort->IsFixedPort(),
							dwTemp);
						DNASSERTX(! "Getting UPNPERR_IGD_SAMEPORTVALUESREQUIRED from bad device!", 2);

						//
						// Continue through to failure case...
						//
					}


					//
					// Make sure it's not the "I can't handle lease times"
					// error.  If it is, note the fact that this device is
					// going to force us to have worse behavior and try
					// again.
					//
					if (RespInfo.hrErrorCode == (HRESULT) UPNPERR_IGD_ONLYPERMANENTLEASESSUPPORTED)
					{
						DPFX(DPFPREP, 1, "UPnP device 0x%p does not support non-INFINITE lease durations.",
							pUPnPDevice);

						//
						// Make sure we're not getting this error from a bad
						// device.  Otherwise we might get caught in a loop.
						//
						if ((! pUPnPDevice->DoesNotSupportLeaseDurations()) &&
							(dwTemp == 0))
						{
							//
							// Remember that this device is unfriendly.
							//
							pUPnPDevice->NoteDoesNotSupportLeaseDurations();

							//
							// Use an INFINITE lease next time around.
							//
							DNASSERT(_tcscmp(tszLeaseDuration, _T("0")) != 0);
							_tcscpy(tszLeaseDuration, _T("0"));
							pRegisteredPort->NotePermanentUPnPLease();

							//
							// Try again.
							//
							goto Retry;
						}

						DPFX(DPFPREP, 1, "DoesNotSupportLeaseDurations = %i, port index = %u",
							pUPnPDevice->DoesNotSupportLeaseDurations(), dwTemp);
						DNASSERTX(! "Getting UPNPERR_IGD_ONLYPERMANENTLEASESSUPPORTED from bad device!", 2);

						//
						// Continue through to failure case...
						//
					}


#ifdef DBG
					if (RespInfo.hrErrorCode == DPNHERR_PORTUNAVAILABLE)
					{
						DPFX(DPFPREP, 2, "Port %u (for address index %u) is reportedly unavailable.",
							wExternalPortHostOrder, dwTemp);
					}
#endif // DBG


PortUnavailable:

					//
					// If it's the port-unavailable error but we're able to
					// try a different port, go for it.
					//
					if ((RespInfo.hrErrorCode == DPNHERR_PORTUNAVAILABLE) &&
						(! pRegisteredPort->IsFixedPort()) &&
						(! pUPnPDevice->DoesNotSupportAsymmetricMappings()))
					{
						//
						// Go to the next sequential port.  If we've wrapped
						// around to 0, move to the first non reserved range
						// port.
						//
						wExternalPortHostOrder++;
						if (wExternalPortHostOrder == 0)
						{
							wExternalPortHostOrder = MAX_RESERVED_PORT + 1;
						}


						//
						// If we haven't wrapped all the way back around to
						// the first port we tried, try again.
						//
						if (wExternalPortHostOrder != wOriginalExternalPortHostOrder)
						{
							DPFX(DPFPREP, 2, "Retrying next port (%u) for index %u.",
								wExternalPortHostOrder, dwTemp);
							goto Retry;
						}


						DPFX(DPFPREP, 0, "All ports were exhausted (after index %u), marking port as unavailable.",
							dwTemp);
					}


					//
					// If it's not the port-unavailable error, it's
					// serious.  Bail.
					//
					if (RespInfo.hrErrorCode != DPNHERR_PORTUNAVAILABLE)
					{
						DPFX(DPFPREP, 1, "Port index %u got failure response 0x%lx.",
							dwTemp, RespInfo.hrErrorCode);

						hr = DPNHERR_SERVERNOTRESPONDING;
						goto Failure;
					}


					//
					// The port is unavailable.
					//
					pRegisteredPort->NoteUPnPPortUnavailable();


					//
					// We're done here.  Ideally we would goto Exit, but we
					// want to execute the public address array cleanup
					// code.  hr should == DPNH_OK.
					//
					DNASSERT(hr == DPNH_OK);
					goto Failure;
				}


				//
				// If we got here, we successfully registered this port.
				//


				//
				// UPnP Internet Gateway Device mapping protocol doesn't
				// hand you the external IP address in the success response
				// message.  We had to have known it through other means
				// (querying the ExternalIPAddress variable).
				//

				DPFX(DPFPREP, 2, "Port index %u got success response.", dwTemp);

				pRegisteredPort->SetUPnPPublicV4Address(dwTemp,
														pUPnPDevice->GetExternalIPAddressV4(),
														HTONS(wExternalPortHostOrder));


				//
				// If the lease is permanent and it's not for a shared
				// port, we need to remember it, in case we crash before
				// cleaning it up in this session.  That we can clean it up
				// next time we launch.
				//
				if ((pRegisteredPort->HasPermanentUPnPLease()) &&
					(! pRegisteredPort->IsSharedPort()))
				{
					CRegistry				RegObject;
					DPNHACTIVENATMAPPING	dpnhanm;
#ifndef UNICODE
					WCHAR					wszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
#endif // ! UNICODE


					DPFX(DPFPREP, 7, "Remembering NAT lease \"%s\" in case of crash.",
						tszDescription);

					if (! RegObject.Open(HKEY_LOCAL_MACHINE,
										DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVENATMAPPINGS,
										FALSE,
										TRUE,
										TRUE,
										DPN_KEY_ALL_ACCESS))
					{
						DPFX(DPFPREP, 0, "Couldn't open active NAT mapping key, unable to save in case of crash!");
					}
					else
					{
#ifndef UNICODE
						dwDescriptionLength = strlen(tszDescription) + 1;
						hr = STR_jkAnsiToWide(wszDescription, tszDescription, dwDescriptionLength);
						if (hr != S_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't convert NAT mapping description to Unicode (err = 0x%lx), unable to save in case of crash!",
								hr);

							//
							// Ignore error and continue.
							//
							hr = S_OK;
						}
						else
#endif // ! UNICODE
						{
							DNASSERT(this->m_dwInstanceKey != 0);


							ZeroMemory(&dpnhanm, sizeof(dpnhanm));
							dpnhanm.dwVersion				= ACTIVE_MAPPING_VERSION;
							dpnhanm.dwInstanceKey			= this->m_dwInstanceKey;
							dpnhanm.dwUPnPDeviceID			= pUPnPDevice->GetID();
							dpnhanm.dwFlags					= pRegisteredPort->GetFlags();
							dpnhanm.dwInternalAddressV4		= pDevice->GetLocalAddressV4();
							dpnhanm.wInternalPort			= psaddrinTemp[dwTemp].sin_port;
							dpnhanm.dwExternalAddressV4		= pUPnPDevice->GetExternalIPAddressV4();
							dpnhanm.wExternalPort			= HTONS(wExternalPortHostOrder);


#ifdef UNICODE
							RegObject.WriteBlob(tszDescription,
#else // ! UNICODE
							RegObject.WriteBlob(wszDescription,
#endif // ! UNICODE
												(LPBYTE) (&dpnhanm),
												sizeof(dpnhanm));
						}

						RegObject.Close();
					}
				}


				//
				// Break out of the wait loop.
				//
				break;
			}


			//
			// Make sure our device is still connected.
			//
			if (! pUPnPDevice->IsConnected())
			{
				DPFX(DPFPREP, 0, "UPnP device 0x%p disconnected while adding port index %u!",
					pUPnPDevice, dwTemp);
				
				pUPnPDevice->StopWaitingForControlResponse();
				
				hr = DPNHERR_SERVERNOTRESPONDING;
				goto Failure;
			}


			//
			// Calculate how long we have left to wait.  If the calculation
			// goes negative, it means we're done.
			//
			dwTimeout = g_dwUPnPResponseTimeout - (GETTIMESTAMP() - dwStartTime);
		}
		while (((int) dwTimeout > 0));


		//
		// If we never got the response, stop waiting for it.
		//
		if (pUPnPDevice->IsWaitingForControlResponse())
		{
			pUPnPDevice->StopWaitingForControlResponse();

			DPFX(DPFPREP, 0, "Port index %u didn't get response in time!", dwTemp);
			hr = DPNHERR_SERVERNOTRESPONDING;
			goto Failure;
		}

		//
		// Continue on to the next port.
		//
	}


	//
	// If we're here, all ports were successfully registered.
	//

	if (pRegisteredPort->HasPermanentUPnPLease())
	{
		DPFX(DPFPREP, 3, "All %u ports successfully registered with UPnP device (no expiration).",
			dwTemp);
	}
	else
	{
		pRegisteredPort->SetUPnPLeaseExpiration(dwLeaseExpiration);

		DPFX(DPFPREP, 3, "All %u ports successfully registered with UPnP device, expiration = %u.",
			dwTemp, dwLeaseExpiration);


		//
		// Remember this expiration time if it's the one that's going to expire
		// soonest.
		//
		if ((fFirstLease) ||
			((int) (dwLeaseExpiration - this->m_dwEarliestLeaseExpirationTime) < 0))
		{
			if (fFirstLease)
			{
				DPFX(DPFPREP, 1, "Registered port 0x%p's UPnP lease is the first lease (expires at %u).",
					pRegisteredPort, dwLeaseExpiration);
			}
			else
			{
				DPFX(DPFPREP, 1, "Registered port 0x%p's UPnP lease expires at %u which is earlier than the next earliest lease expiration (%u).",
					pRegisteredPort,
					dwLeaseExpiration,
					this->m_dwEarliestLeaseExpirationTime);
			}

			this->m_dwEarliestLeaseExpirationTime = dwLeaseExpiration;


#ifndef DPNBUILD_NOWINSOCK2
			//
			// Ping the event if there is one so that the user's GetCaps
			// interval doesn't miss this new, shorter lease.
			//
			if (this->m_hAlertEvent != NULL)
			{
				fResult = SetEvent(this->m_hAlertEvent);
#ifdef DBG
				if (! fResult)
				{
					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Couldn't set alert event 0x%p!  err = %u",
						this->m_hAlertEvent, dwError);

					//
					// Ignore failure...
					//
				}
#endif // DBG
			}


			//
			// Ping the I/O completion port if there is one so that the user's
			// GetCaps interval doesn't miss this new, shorter lease.
			//
			if (this->m_hAlertIOCompletionPort != NULL)
			{
				fResult = PostQueuedCompletionStatus(this->m_hAlertIOCompletionPort,
													0,
													this->m_dwAlertCompletionKey,
													NULL);
#ifdef DBG
				if (! fResult)
				{
					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Couldn't queue key %u on alert IO completion port 0x%p!  err = %u",
						this->m_dwAlertCompletionKey,
						this->m_hAlertIOCompletionPort,
						dwError);

					//
					// Ignore failure...
					//
				}
#endif // DBG
			}
#endif // ! DPNBUILD_NOWINSOCK2
		}
		else
		{
			//
			// Not first or shortest lease.
			//
		}
	} // end if (not permanent UPnP lease)


Exit:

	if (pszMessage != NULL)
	{
		DNFree(pszMessage);
		pszMessage = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// If we allocated the array, clean it up.
	//
	if (pRegisteredPort->HasUPnPPublicAddresses())
	{
		//
		// If we started waiting for a response, clear that.
		//
		if (fStartedWaitingForControlResponse)
		{
			pUPnPDevice->StopWaitingForControlResponse();
		}


		//
		// Delete all mappings successfully made up until now.
		//
		if (dwTemp > 0)
		{
			temphr = this->UnmapUPnPPort(pRegisteredPort, dwTemp, TRUE);
			if (temphr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed deleting %u previously mapped ports!  Err = 0x%lx",
					dwTemp, temphr);

				if (hr == DPNH_OK)
				{
					hr = temphr;
				}
			}
		}
		else
		{
			//
			// Remove the addresses array we created.
			//
			pRegisteredPort->DestroyUPnPPublicAddressesArray();


			//
			// Remove the lease counter.
			//
			DNASSERT(this->m_dwNumLeases > 0);
			this->m_dwNumLeases--;

			DPFX(DPFPREP, 7, "UPnP lease for 0x%p removed, total num leases = %u.",
				pRegisteredPort, this->m_dwNumLeases);
		}
	}

	//
	// Turn off the permanent lease flag we may have turned on at the top of
	// this function.
	//
	pRegisteredPort->NoteNotPermanentUPnPLease();


	goto Exit;
} // CNATHelpUPnP::MapPortsOnUPnPDevice





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::InternalUPnPQueryAddress"
//=============================================================================
// CNATHelpUPnP::InternalUPnPQueryAddress
//-----------------------------------------------------------------------------
//
// Description:    Queries a port mapping with a UPnP device.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice				- Pointer to UPnP device that
//												should be queried.
//	SOCKADDR_IN * psaddrinQueryAddress		- Address to look up.
//	SOCKADDR_IN * psaddrinResponseAddress	- Place to store public address, if
//												one exists.
//	DWORD dwFlags							- Flags to use when querying.
//
// Returns: HRESULT
//	DPNH_OK							- The query was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_NOMAPPING				- The server did not have a mapping for the
//										given address.
//	DPNHERR_NOMAPPINGBUTPRIVATE		- The server indicated that no mapping was
//										found, but it is a private address.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpUPnP::InternalUPnPQueryAddress(CUPnPDevice * const pUPnPDevice,
												const SOCKADDR_IN * const psaddrinQueryAddress,
												SOCKADDR_IN * const psaddrinResponseAddress,
												const DWORD dwFlags)
{
	HRESULT						hr;
	BOOL						fStartedWaitingForControlResponse = FALSE;
	BOOL						fNoPortMapping = FALSE;
	CDevice *					pDevice;
	CBilink *					pblCachedMaps;
	DWORD						dwCurrentTime;
	CBilink *					pBilink;
	CCacheMap *					pCacheMap;
	SOCKADDR_IN *				psaddrinTemp;
	TCHAR						tszExternalPort[32];
	int							iContentLength;
	TCHAR						tszContentLength[32];
	TCHAR						tszHost[22]; // "xxx.xxx.xxx.xxx:xxxxx" + NULL termination
	char *						pszMessage = NULL;
	int							iMsgSize;
	int							iPrevMsgSize = 0;
	int							iReturn;
	UPNP_CONTROLRESPONSE_INFO	RespInfo;
	DWORD						dwStartTime;
	DWORD						dwTimeout;
	DWORD						dwCacheMapFlags;
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%lx)",
		this, pUPnPDevice, psaddrinQueryAddress, psaddrinResponseAddress, dwFlags);


	DNASSERT(pUPnPDevice != NULL);

	pDevice = pUPnPDevice->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	DNASSERT(pUPnPDevice->IsReady());
	DNASSERT(psaddrinQueryAddress != NULL);
	DNASSERT(psaddrinResponseAddress != NULL);

	DNASSERT(this->m_dwFlags & (NATHELPUPNPOBJ_INITIALIZED | NATHELPUPNPOBJ_USEUPNP));


	DPFX(DPFPREP, 7, "Querying for address %u.%u.%u.%u:%u %hs.",
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b1,
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b2,
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b3,
		psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b4,
		NTOHS(psaddrinQueryAddress->sin_port),
		((dwFlags & DPNHQUERYADDRESS_TCP) ? "TCP" : "UDP"));


	//
	// First, check if we've looked this address up recently and already have
	// the result cached.
	// The lock is already held.
	//
	pblCachedMaps = pUPnPDevice->GetCachedMaps();
	dwCurrentTime = GETTIMESTAMP();

	pBilink = pblCachedMaps->GetNext();
	while (pBilink != pblCachedMaps)
	{
		DNASSERT(! pBilink->IsEmpty());
		pCacheMap = CACHEMAP_FROM_BILINK(pBilink);
		pBilink = pBilink->GetNext();


		//
		// Make sure this cached mapping hasn't expired.
		//
		if ((int) (pCacheMap->GetExpirationTime() - dwCurrentTime) < 0)
		{
			DPFX(DPFPREP, 5, "Cached mapping 0x%p has expired.", pCacheMap);

			pCacheMap->m_blList.RemoveFromList();
			delete pCacheMap;
		}
		else
		{
			//
			// If this mapping is for the right address and type of address,
			// then we've already got our answer.
			//
			if (pCacheMap->DoesMatchQuery(psaddrinQueryAddress, dwFlags))
			{
				if (pCacheMap->IsNotFound())
				{
					if ((dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED) &&
						(pCacheMap->IsPrivateButUnmapped()))
					{
						DPFX(DPFPREP, 5, "Address was already determined to not have a mapping but still be private.");
						hr = DPNHERR_NOMAPPINGBUTPRIVATE;
					}
					else
					{
						DPFX(DPFPREP, 5, "Address was already determined to not have a mapping.");
						hr = DPNHERR_NOMAPPING;
					}
				}
				else
				{
					pCacheMap->GetResponseAddressV4(psaddrinResponseAddress);

					DPFX(DPFPREP, 5, "Address was already determined to have a mapping.");
					hr = DPNH_OK;
				}

				goto Exit;
			}
		}
	}


	//
	// If the address we're querying isn't the NAT's public address, it can't
	// possibly be mapped.  So only perform the actual query if it's
	// appropriate.
	//
	if (psaddrinQueryAddress->sin_addr.S_un.S_addr == pUPnPDevice->GetExternalIPAddressV4())
	{
		//
		// If we're here, we haven't already cached the answer.  Query the UPnP
		// device.
		//
	
		DNASSERT(pUPnPDevice->GetServiceControlURL() != NULL);

		//
		// If the control socket got disconnected after the last message,
		// then reconnect.
		//
		if (! pUPnPDevice->IsConnected())
		{
			hr = this->ReconnectUPnPControlSocket(pUPnPDevice);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't reconnect UPnP control socket!");
				goto Failure;
			}
		}

		DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);


		wsprintf(tszExternalPort, _T("%u"),
				NTOHS(psaddrinQueryAddress->sin_port));
		
		psaddrinTemp = pUPnPDevice->GetHostAddress();
		wsprintf(tszHost, _T("%u.%u.%u.%u:%u"),
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
				psaddrinTemp->sin_addr.S_un.S_un_b.s_b4,
				NTOHS(psaddrinTemp->sin_port));



		iContentLength = strlen("<s:Envelope" EOL)
						+ strlen("    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL)
						+ strlen("    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL)
						+ strlen("  <s:Body>" EOL)
						+ strlen("    <u:" ACTION_GETSPECIFICPORTMAPPINGENTRY_A " xmlns:u=\"") + pUPnPDevice->GetStaticServiceURILength() + strlen("\">" EOL)
						+ strlen("      <" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWREMOTEHOST_A ">" UPNP_WILDCARD "</" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWREMOTEHOST_A ">" EOL)
						+ strlen("      <" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWEXTERNALPORT_A ">") + _tcslen(tszExternalPort) + strlen("</" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWEXTERNALPORT_A ">" EOL)
						+ strlen("      <" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPROTOCOL_A ">") + 3 + strlen("</" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPROTOCOL_A ">" EOL)
						+ strlen("    </u:" ACTION_GETSPECIFICPORTMAPPINGENTRY_A ">" EOL)
						+ strlen("  </s:Body>" EOL)
						+ strlen("</s:Envelope>" EOL)
						+ strlen(EOL);

		wsprintf(tszContentLength, _T("%i"), iContentLength);

		iMsgSize = strlen("POST ") + strlen(pUPnPDevice->GetServiceControlURL()) + strlen(" " HTTP_VERSION EOL)
					+ strlen("HOST: ") + _tcslen(tszHost) + strlen(EOL)
					+ strlen("CONTENT-LENGTH: ") + _tcslen(tszContentLength) + strlen(EOL)
					+ strlen("CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL)
					+ strlen("SOAPACTION: ") + pUPnPDevice->GetStaticServiceURILength() + strlen("#" ACTION_GETSPECIFICPORTMAPPINGENTRY_A EOL)
					+ strlen(EOL)
					+ iContentLength;


		//
		// Allocate (or reallocate) the message buffer.
		//
		if (iMsgSize > iPrevMsgSize)
		{
			if (pszMessage != NULL)
			{
				DNFree(pszMessage);
				pszMessage = NULL;
			}

			pszMessage = (char*) DNMalloc(iMsgSize + 1); // include room for NULL termination that isn't actually sent
			if (pszMessage == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			iPrevMsgSize = iMsgSize;
		}

		strcpy(pszMessage, "POST ");
		strcat(pszMessage, pUPnPDevice->GetServiceControlURL());
		strcat(pszMessage, " " HTTP_VERSION EOL);
		strcat(pszMessage, "HOST: ");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszHost,
						(_tcslen(tszHost) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszHost);
#endif // ! UNICODE
		strcat(pszMessage, EOL);
		strcat(pszMessage, "CONTENT-LENGTH: ");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszContentLength,
						(_tcslen(tszContentLength) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszContentLength);
#endif // ! UNICODE
		strcat(pszMessage, EOL);
		strcat(pszMessage, "CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL);
		strcat(pszMessage, "SOAPACTION: ");
		strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
		strcat(pszMessage, "#" ACTION_GETSPECIFICPORTMAPPINGENTRY_A EOL);
		strcat(pszMessage, EOL);


		strcat(pszMessage, "<s:Envelope" EOL);
		strcat(pszMessage, "    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL);
		strcat(pszMessage, "    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL);
		strcat(pszMessage, "  <s:Body>" EOL);
		strcat(pszMessage, "    <u:" ACTION_GETSPECIFICPORTMAPPINGENTRY_A " xmlns:u=\"");
		strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
		strcat(pszMessage, "\">" EOL);
		
		strcat(pszMessage, "      <" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWREMOTEHOST_A ">" UPNP_WILDCARD "</" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWREMOTEHOST_A ">" EOL);

		strcat(pszMessage, "      <" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWEXTERNALPORT_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszExternalPort,
						(_tcslen(tszExternalPort) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszExternalPort);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWEXTERNALPORT_A ">" EOL);

		strcat(pszMessage, "      <" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPROTOCOL_A ">");
		strcat(pszMessage, ((dwFlags & DPNHQUERYADDRESS_TCP) ? "TCP" : "UDP"));
		strcat(pszMessage, "</" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPROTOCOL_A ">" EOL);

		strcat(pszMessage, "    </u:" ACTION_GETSPECIFICPORTMAPPINGENTRY_A ">" EOL);
		strcat(pszMessage, "  </s:Body>" EOL);
		strcat(pszMessage, "</s:Envelope>" EOL);
		strcat(pszMessage, EOL);


#ifdef DBG
		this->PrintUPnPTransactionToFile(pszMessage,
										iMsgSize,
										"Outbound get port mapping request",
										pDevice);
#endif // DBG

		iReturn = this->m_pfnsend(pUPnPDevice->GetControlSocket(),
									pszMessage,
									iMsgSize,
									0);

		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u when sending control request to UPnP device!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		if (iReturn != iMsgSize)
		{
			DPFX(DPFPREP, 0, "Didn't send entire message (%i != %i)?!", iReturn, iMsgSize);
			DNASSERT(FALSE);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// We have the lock so no one could have tried to receive data from
		// the control socket yet.  Mark the device as waiting for a response.
		//
		ZeroMemory(&RespInfo, sizeof(RespInfo));
		pUPnPDevice->StartWaitingForControlResponse(CONTROLRESPONSETYPE_GETSPECIFICPORTMAPPINGENTRY,
													&RespInfo);
		fStartedWaitingForControlResponse = TRUE;


		//
		// Actually wait for the response.
		//
		dwStartTime = GETTIMESTAMP();
		dwTimeout = g_dwUPnPResponseTimeout;
		do
		{
			hr = this->CheckForReceivedUPnPMsgsOnDevice(pUPnPDevice, dwTimeout);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed receiving UPnP messages!");
				goto Failure;
			}

			//
			// We either timed out or got some data.  Check if we got a
			// response of some type.
			//
			if (! pUPnPDevice->IsWaitingForControlResponse())
			{
				break;
			}


			//
			// Make sure our device is still connected.
			//
			if (! pUPnPDevice->IsConnected())
			{
				DPFX(DPFPREP, 0, "UPnP device 0x%p disconnected while querying port!",
					pUPnPDevice);
				
				pUPnPDevice->StopWaitingForControlResponse();
				
				hr = DPNHERR_SERVERNOTRESPONDING;
				goto Failure;
			}


			//
			// Calculate how long we have left to wait.  If the calculation
			// goes negative, it means we're done.
			//
			dwTimeout = g_dwUPnPResponseTimeout - (GETTIMESTAMP() - dwStartTime);
		}
		while (((int) dwTimeout > 0));


		//
		// If we never got the response, stop waiting for it.
		//
		if (pUPnPDevice->IsWaitingForControlResponse())
		{
			pUPnPDevice->StopWaitingForControlResponse();

			DPFX(DPFPREP, 0, "Server didn't respond in time!");
			hr = DPNHERR_SERVERNOTRESPONDING;
			goto Failure;
		}


		//
		// If we're here, then we've gotten a valid response from the server.
		//

		if (RespInfo.hrErrorCode != DPNH_OK)
		{
			DPFX(DPFPREP, 1, "Server returned failure response 0x%lx, assuming no port mapping.",
				RespInfo.hrErrorCode);
			fNoPortMapping = TRUE;
		}
	}
	else
	{
		DPFX(DPFPREP, 1, "Address %u.%u.%u.%u doesn't match NAT's external IP address, not querying.",
			psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinQueryAddress->sin_addr.S_un.S_un_b.s_b4);

		fNoPortMapping = TRUE;
	}


	dwCacheMapFlags = QUERYFLAGSMASK(dwFlags);


	//
	// Determine address locality (if requested) and cache the no-mapping
	// result.
	//
	if (fNoPortMapping)
	{
		//
		// Try determining if the address is local, if allowed.
		//
		if (dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED)
		{
			if (this->IsAddressLocal(pDevice, psaddrinQueryAddress))
			{
				DPFX(DPFPREP, 5, "Address appears to be local, returning NOMAPPINGBUTPRIVATE.");

				dwCacheMapFlags |= CACHEMAPOBJ_PRIVATEBUTUNMAPPED;

				hr = DPNHERR_NOMAPPINGBUTPRIVATE;
			}
			else
			{
				DPFX(DPFPREP, 5, "Address does not appear to be local, returning NOMAPPING.");

				hr = DPNHERR_NOMAPPING;
			}
		}
		else
		{
			hr = DPNHERR_NOMAPPING;
		}


		//
		// Cache the fact that we could not determine a mapping for that
		// address, if allowed.
		//
		if (dwFlags & DPNHQUERYADDRESS_CACHENOTFOUND)
		{
			pCacheMap = new CCacheMap(psaddrinQueryAddress,
									(GETTIMESTAMP() + g_dwCacheLifeNotFound),
									(dwCacheMapFlags | CACHEMAPOBJ_NOTFOUND));
			if (pCacheMap == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			pCacheMap->m_blList.InsertBefore(pblCachedMaps);
		}

		goto Failure;
	}


	DPFX(DPFPREP, 1, "Server returned a private mapping (%u.%u.%u.%u:%u).",
		((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b1,
		((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b2,
		((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b3,
		((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b4,
		NTOHS(RespInfo.wInternalPort));


	//
	// Convert the loopback address to the device address.
	//
	if (RespInfo.dwInternalClientV4 == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		RespInfo.dwInternalClientV4 = pDevice->GetLocalAddressV4();

		DPFX(DPFPREP, 1, "Converted private loopback address to device address (%u.%u.%u.%u).",
			((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b1,
			((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b2,
			((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b3,
			((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b4);
	}

	//
	// If the UPnP device doesn't support asymmetric mappings and thus didn't
	// return a port, or it did return one but it's the bogus port 0, assume
	// the internal port is the same port as the external one.
	//
	if (RespInfo.wInternalPort == 0)
	{
		RespInfo.wInternalPort = psaddrinQueryAddress->sin_port;

		DPFX(DPFPREP, 2, "Converted invalid internal port to the query address public port (%u).",
			NTOHS(psaddrinQueryAddress->sin_port));
	}


	//
	// Ensure that we're not getting something bogus.
	//
	SOCKADDR_IN		saddrinTemp;
	saddrinTemp.sin_addr.S_un.S_addr = RespInfo.dwInternalClientV4;
	if ((RespInfo.dwInternalClientV4 == 0) ||
		(! this->IsAddressLocal(pDevice, &saddrinTemp)))
	{
		//
		// If the returned address is the same as the NAT's public address,
		// it's probably Windows ICS returning an ICF mapping.  We still treat
		// it as an invalid mapping, but we will cache the results since there
		// are legimitate cases where we can see this.
		//
		if (RespInfo.dwInternalClientV4 == pUPnPDevice->GetExternalIPAddressV4())
		{
			DPFX(DPFPREP, 1, "UPnP device returned its public address as the private address (%u.%u.%u.%u:%u).  Probably ICS + ICF, but treating as no mapping.",
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b1,
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b2,
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b3,
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b4,
				NTOHS(RespInfo.wInternalPort));
			DNASSERTX(! "UPnP device returned public address as the private address!", 3);
		
			//
			// Cache the fact that we did not get a valid mapping for that
			// address, if allowed.
			//
			if (dwFlags & DPNHQUERYADDRESS_CACHENOTFOUND)
			{
				pCacheMap = new CCacheMap(psaddrinQueryAddress,
										(GETTIMESTAMP() + g_dwCacheLifeNotFound),
										(dwCacheMapFlags | CACHEMAPOBJ_NOTFOUND));
				if (pCacheMap == NULL)
				{
					hr = DPNHERR_OUTOFMEMORY;
					goto Failure;
				}

				pCacheMap->m_blList.InsertBefore(pblCachedMaps);
			}
		}
		else
		{
			DPFX(DPFPREP, 0, "UPnP device returned an invalid private address (%u.%u.%u.%u:%u)!  Assuming no mapping.",
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b1,
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b2,
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b3,
				((IN_ADDR*) (&RespInfo.dwInternalClientV4))->S_un.S_un_b.s_b4,
				NTOHS(RespInfo.wInternalPort));
			DNASSERTX(! "Why is UPnP device returning invalid private address?", 2);
		}
		
		hr = DPNHERR_NOMAPPING;
		goto Failure;
	}


	//
	// Return the address mapping to our caller.
	//
	ZeroMemory(psaddrinResponseAddress, sizeof(SOCKADDR_IN));
	psaddrinResponseAddress->sin_family			= AF_INET;
	psaddrinResponseAddress->sin_addr.s_addr	= RespInfo.dwInternalClientV4;
	psaddrinResponseAddress->sin_port			= RespInfo.wInternalPort;


	//
	// Cache the fact that we found a mapping for that address, if allowed.
	//
	if (dwFlags & DPNHQUERYADDRESS_CACHEFOUND)
	{
		pCacheMap = new CCacheMap(psaddrinQueryAddress,
								(GETTIMESTAMP() + g_dwCacheLifeFound),
								dwCacheMapFlags);
		if (pCacheMap == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		pCacheMap->SetResponseAddressV4(psaddrinResponseAddress->sin_addr.S_un.S_addr,
										psaddrinResponseAddress->sin_port);

		pCacheMap->m_blList.InsertBefore(pblCachedMaps);
	}


Exit:

	if (pszMessage != NULL)
	{
		DNFree(pszMessage);
		pszMessage = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// If we started waiting for a response, clear that.
	//
	if (fStartedWaitingForControlResponse)
	{
		pUPnPDevice->StopWaitingForControlResponse();
	}

	goto Exit;
} // CNATHelpUPnP::InternalUPnPQueryAddress




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ExtendUPnPLease"
//=============================================================================
// CNATHelpUPnP::ExtendUPnPLease
//-----------------------------------------------------------------------------
//
// Description:    Asks the UPnP server to extend a port mapping lease.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference if it's using the
//				pointer.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port object mapping to
//											extend.
//
// Returns: HRESULT
//	DPNH_OK							- The extension was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpUPnP::ExtendUPnPLease(CRegisteredPort * const pRegisteredPort)
{
	HRESULT			hr;
	CDevice *		pDevice;
	CUPnPDevice *	pUPnPDevice;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pRegisteredPort);


	DNASSERT(pRegisteredPort != NULL);

	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	pUPnPDevice = pDevice->GetUPnPDevice();
	DNASSERT(pUPnPDevice != NULL);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);
	DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);

#ifdef DBG
	if (pRegisteredPort->HasPermanentUPnPLease())
	{
		DPFX(DPFPREP, 1, "Extending already permanent UPnP lease for registered port 0x%p.",
			pRegisteredPort);
	}
#endif // DBG


	//
	// UPnP devices don't have port extension per se, you just reregister the
	// mapping.
	//
	hr = this->MapPortsOnUPnPDevice(pUPnPDevice, pRegisteredPort);


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CNATHelpUPnP::ExtendUPnPLease





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UnmapUPnPPort"
//=============================================================================
// CNATHelpUPnP::UnmapUPnPPort
//-----------------------------------------------------------------------------
//
// Description:    Asks the UPnP server to release a port mapping.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference if it's using the
//				device.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port object mapping to
//											release.
//	DWORD dwMaxValidPort				- Highest address index in array to
//											try freeing.  This may be one more
//											than the actual number to indicate
//											all should be freed.
//	BOOL fNeedToDeleteRegValue			- Whether the corresponding crash
//											recovery registry value needs to
//											be deleted as well.
//
// Returns: HRESULT
//	DPNH_OK							- The extension was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpUPnP::UnmapUPnPPort(CRegisteredPort * const pRegisteredPort,
									const DWORD dwMaxValidPort,
									const BOOL fNeedToDeleteRegValue)
{
	HRESULT						hr = DPNH_OK;
	BOOL						fStartedWaitingForControlResponse = FALSE;
	CDevice *					pDevice;
	CUPnPDevice *				pUPnPDevice;
	SOCKADDR_IN *				psaddrinPublic;
	SOCKADDR_IN *				psaddrinPrivate;
	TCHAR						tszExternalPort[32];
	int							iContentLength;
	TCHAR						tszContentLength[32];
	TCHAR						tszHost[22]; // "xxx.xxx.xxx.xxx:xxxxx" + NULL termination
	char *						pszMessage = NULL;
	int							iMsgSize;
	int							iPrevMsgSize = 0;
	int							iReturn;
	DWORD						dwTemp;
	UPNP_CONTROLRESPONSE_INFO	RespInfo;
	DWORD						dwStartTime;
	DWORD						dwTimeout;
	SOCKADDR_IN *				psaddrinHostAddress;
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, %i)",
		this, pRegisteredPort, ((int) dwMaxValidPort), fNeedToDeleteRegValue);


	DNASSERT(pRegisteredPort != NULL);
	DNASSERT(dwMaxValidPort != 0); 
	DNASSERT(dwMaxValidPort <= pRegisteredPort->GetNumAddresses());

	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	pUPnPDevice = pDevice->GetUPnPDevice();
	DNASSERT(pUPnPDevice != NULL);
	//
	// GetUPnPDevice did not add a reference to pUPnPDevice for us.
	//
	pUPnPDevice->AddRef();

	DNASSERT(pUPnPDevice->IsReady());


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);



	//
	// Prevent trying to remove the lease twice.
	//
	pRegisteredPort->NoteRemovingUPnPLease();


	if (dwMaxValidPort == pRegisteredPort->GetNumAddresses())
	{
		DPFX(DPFPREP, 7, "Unmapping all %u addresses for registered port 0x%p on UPnP device 0x%p.",
			dwMaxValidPort, pRegisteredPort, pUPnPDevice);
	}
	else
	{
		DPFX(DPFPREP, 7, "Error cleanup code, only unmapping first %u addresses (of %u possible) for registered port 0x%p on UPnP device 0x%p.",
			dwMaxValidPort, pRegisteredPort->GetNumAddresses(),
			pRegisteredPort, pUPnPDevice);
	}


	//
	// Set up variables we'll need.
	//
	DNASSERT(pUPnPDevice->GetServiceControlURL() != NULL);

	psaddrinHostAddress = pUPnPDevice->GetHostAddress();
	wsprintf(tszHost, _T("%u.%u.%u.%u:%u"),
			psaddrinHostAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinHostAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinHostAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinHostAddress->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(psaddrinHostAddress->sin_port));


	//
	// Get the array of ports we're releasing.
	//
	psaddrinPublic = pRegisteredPort->GetUPnPPublicAddressesArray();
	psaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();


	//
	// Loop through each port that we're unmapping.
	//
	for(dwTemp = 0; dwTemp < dwMaxValidPort; dwTemp++)
	{
		//
		// The UPnP Internet Gateway Device spec does not require reference
		// counting for mapped ports.  If you register something that had
		// already been registered, it will succeed silently.
		//
		// This means that we will never be able to tell which NAT client was
		// the last person to use a given shared port.  You could try detecting
		// any other users at the app level (above DPNATHLP), but there is
		// always a race condition.  You could also have a concept of shared-
		// port owner, but then you'd have to implement owner migration a la
		// DPlay host migration.  That is sooo not worth it.
		//
		// The other option is to just never unmap shared ports.  You can
		// probably imagine the implications of this solution, but it's what we
		// have to do.
		//

		if (pRegisteredPort->IsSharedPort())
		{
			DPFX(DPFPREP, 1, "Registered port 0x%p address index %u (private address %u.%u.%u.%u:%u) is shared, not unmapping.",
				pRegisteredPort, dwTemp,
				psaddrinPublic[dwTemp].sin_addr.S_un.S_un_b.s_b1,
				psaddrinPublic[dwTemp].sin_addr.S_un.S_un_b.s_b2,
				psaddrinPublic[dwTemp].sin_addr.S_un.S_un_b.s_b3,
				psaddrinPublic[dwTemp].sin_addr.S_un.S_un_b.s_b4,
				NTOHS(psaddrinPublic[dwTemp].sin_port));
			continue;
		}


		//
		// If the control socket got disconnected after the last message,
		// then reconnect.
		//
		if (! pUPnPDevice->IsConnected())
		{
			hr = this->ReconnectUPnPControlSocket(pUPnPDevice);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't reconnect UPnP control socket!");
				goto Failure;
			}
		}

		DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);


		wsprintf(tszExternalPort, _T("%u"),
				NTOHS(psaddrinPublic[dwTemp].sin_port));


		iContentLength = strlen("<s:Envelope" EOL)
						+ strlen("    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL)
						+ strlen("    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL)
						+ strlen("  <s:Body>" EOL)
						+ strlen("    <u:" ACTION_DELETEPORTMAPPING_A " xmlns:u=\"") + pUPnPDevice->GetStaticServiceURILength() + strlen("\">" EOL)
						+ strlen("      <" ARG_DELETEPORTMAPPING_NEWREMOTEHOST_A ">" UPNP_WILDCARD "</" ARG_DELETEPORTMAPPING_NEWREMOTEHOST_A ">" EOL)
						+ strlen("      <" ARG_DELETEPORTMAPPING_NEWEXTERNALPORT_A ">") + _tcslen(tszExternalPort) + strlen("</" ARG_DELETEPORTMAPPING_NEWEXTERNALPORT_A ">" EOL)
						+ strlen("      <" ARG_DELETEPORTMAPPING_NEWPROTOCOL_A ">") + 3 + strlen("</" ARG_DELETEPORTMAPPING_NEWPROTOCOL_A ">" EOL)
						+ strlen("    </u:" ACTION_DELETEPORTMAPPING_A ">" EOL)
						+ strlen("  </s:Body>" EOL)
						+ strlen("</s:Envelope>" EOL)
						+ strlen(EOL);

		wsprintf(tszContentLength, _T("%i"), iContentLength);

		iMsgSize = strlen("POST ") + strlen(pUPnPDevice->GetServiceControlURL()) + strlen(" " HTTP_VERSION EOL)
					+ strlen("HOST: ") + _tcslen(tszHost) + strlen(EOL)
					+ strlen("CONTENT-LENGTH: ") + _tcslen(tszContentLength) + strlen(EOL)
					+ strlen("CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL)
					+ strlen("SOAPACTION: ") + pUPnPDevice->GetStaticServiceURILength() + strlen("#" ACTION_DELETEPORTMAPPING_A EOL)
					+ strlen(EOL)
					+ iContentLength;


		//
		// Allocate (or reallocate) the message buffer.
		//
		if (iMsgSize > iPrevMsgSize)
		{
			if (pszMessage != NULL)
			{
				DNFree(pszMessage);
				pszMessage = NULL;
			}

			pszMessage = (char*) DNMalloc(iMsgSize + 1); // include room for NULL termination that isn't actually sent
			if (pszMessage == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			iPrevMsgSize = iMsgSize;
		}

		strcpy(pszMessage, "POST ");
		strcat(pszMessage, pUPnPDevice->GetServiceControlURL());
		strcat(pszMessage, " " HTTP_VERSION EOL);
		strcat(pszMessage, "HOST: ");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszHost,
						(_tcslen(tszHost) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszHost);
#endif // ! UNICODE
		strcat(pszMessage, EOL);
		strcat(pszMessage, "CONTENT-LENGTH: ");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszContentLength,
						(_tcslen(tszContentLength) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszContentLength);
#endif // ! UNICODE
		strcat(pszMessage, EOL);
		strcat(pszMessage, "CONTENT-TYPE: text/xml; charset=\"utf-8\"" EOL);
		strcat(pszMessage, "SOAPACTION: ");
		strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
		strcat(pszMessage, "#" ACTION_DELETEPORTMAPPING_A EOL);
		strcat(pszMessage, EOL);

		strcat(pszMessage, "<s:Envelope" EOL);
		strcat(pszMessage, "    xmlns:s=\"" URL_SOAPENVELOPE_A "\"" EOL);
		strcat(pszMessage, "    s:encodingStyle=\"" URL_SOAPENCODING_A "\">" EOL);
		strcat(pszMessage, "  <s:Body>" EOL);
		strcat(pszMessage, "    <u:" ACTION_DELETEPORTMAPPING_A " xmlns:u=\"");
		strcat(pszMessage, pUPnPDevice->GetStaticServiceURI());
		strcat(pszMessage, "\">" EOL);

		strcat(pszMessage, "      <" ARG_DELETEPORTMAPPING_NEWREMOTEHOST_A ">" UPNP_WILDCARD "</" ARG_DELETEPORTMAPPING_NEWREMOTEHOST_A ">" EOL);

		strcat(pszMessage, "      <" ARG_DELETEPORTMAPPING_NEWEXTERNALPORT_A ">");
#ifdef UNICODE
		STR_jkWideToAnsi((pszMessage + strlen(pszMessage)),
						tszExternalPort,
						(_tcslen(tszExternalPort) + 1));
#else // ! UNICODE
		strcat(pszMessage, tszExternalPort);
#endif // ! UNICODE
		strcat(pszMessage, "</" ARG_DELETEPORTMAPPING_NEWEXTERNALPORT_A ">" EOL);

		strcat(pszMessage, "      <" ARG_DELETEPORTMAPPING_NEWPROTOCOL_A ">");
		strcat(pszMessage, ((pRegisteredPort->IsTCP()) ? "TCP" : "UDP"));
		strcat(pszMessage, "</" ARG_DELETEPORTMAPPING_NEWPROTOCOL_A ">" EOL);

		strcat(pszMessage, "    </u:" ACTION_DELETEPORTMAPPING_A ">" EOL);
		strcat(pszMessage, "  </s:Body>" EOL);
		strcat(pszMessage, "</s:Envelope>" EOL);
		strcat(pszMessage, EOL);


#ifdef DBG
		this->PrintUPnPTransactionToFile(pszMessage,
										iMsgSize,
										"Outbound delete port mapping request",
										pDevice);
#endif // DBG

		iReturn = this->m_pfnsend(pUPnPDevice->GetControlSocket(),
									pszMessage,
									iMsgSize,
									0);

		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u when sending control request to UPnP device!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		if (iReturn != iMsgSize)
		{
			DPFX(DPFPREP, 0, "Didn't send entire message (%i != %i)?!", iReturn, iMsgSize);
			DNASSERT(FALSE);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// We have the lock so no one could have tried to receive data from
		// the control socket yet.  Mark the device as waiting for a
		// response.
		//
		ZeroMemory(&RespInfo, sizeof(RespInfo));
		pUPnPDevice->StartWaitingForControlResponse(CONTROLRESPONSETYPE_DELETEPORTMAPPING,
													&RespInfo);
		fStartedWaitingForControlResponse = TRUE;


		//
		// Actually wait for the response.
		//
		dwStartTime = GETTIMESTAMP();
		dwTimeout = g_dwUPnPResponseTimeout;
		do
		{
			hr = this->CheckForReceivedUPnPMsgsOnDevice(pUPnPDevice, dwTimeout);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed receiving UPnP messages!");
				goto Failure;
			}

			//
			// We either timed out or got some data.  Check if we got a
			// response of some type.
			//
			if (! pUPnPDevice->IsWaitingForControlResponse())
			{
				break;
			}


			//
			// Make sure our device is still connected.
			//
			if (! pUPnPDevice->IsConnected())
			{
				DPFX(DPFPREP, 0, "UPnP device 0x%p disconnected while deleting port index %u!",
					pUPnPDevice, dwTemp);
				
				pUPnPDevice->StopWaitingForControlResponse();
				
				hr = DPNHERR_SERVERNOTRESPONDING;
				goto Failure;
			}


			//
			// Calculate how long we have left to wait.  If the calculation
			// goes negative, it means we're done.
			//
			dwTimeout = g_dwUPnPResponseTimeout - (GETTIMESTAMP() - dwStartTime);
		}
		while (((int) dwTimeout > 0));


		//
		// If we never got the response, stop waiting for it.
		//
		if (pUPnPDevice->IsWaitingForControlResponse())
		{
			pUPnPDevice->StopWaitingForControlResponse();

			DPFX(DPFPREP, 0, "Server didn't respond in time for port index %u!",
				dwTemp);
			hr = DPNHERR_SERVERNOTRESPONDING;
			goto Failure;
		}


		//
		// If we're here, then we've gotten a valid response (success or
		// failure) from the server.  If it's a failure, print out a note
		// but continue.
		//
#ifdef DBG
		switch (RespInfo.hrErrorCode)
		{
			case DPNH_OK:
			{
				//
				// Succeeded.
				//
				break;
			}

			case DPNHERR_NOMAPPING:
			{
				//
				// UPnP device didn't know what we were talking about.
				//
				DPFX(DPFPREP, 1, "Server didn't recognize mapping for port index %u, continuing.",
					dwTemp);
				break;
			}

			default:
			{
				//
				// Something else happened.
				//
				DPFX(DPFPREP, 0, "Server returned failure response 0x%lx for port index %u!  Ignoring.",
					RespInfo.hrErrorCode, dwTemp);
				break;
			}
		}
#endif // DBG


		//
		// If the lease is permanent, we need to remove the reference from
		// the registry.
		//
		if (pRegisteredPort->HasPermanentUPnPLease())
		{
			IN_ADDR		inaddrTemp;
			TCHAR		tszInternalClient[16]; // "xxx.xxx.xxx.xxx" + NULL termination
			TCHAR		tszInternalPort[32];
			DWORD		dwDescriptionLength;
			CRegistry	RegObject;
			WCHAR		wszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
#ifdef UNICODE
			TCHAR *		ptszDescription = wszDescription;
#else // ! UNICODE
			char		szDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
			TCHAR *		ptszDescription = szDescription;
#endif // ! UNICODE


			//
			// Note that the device address is not necessarily the same as
			// the address the user originally registered, particularly the
			// 0.0.0.0 wildcard address will get remapped.
			//
			inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
			wsprintf(tszInternalClient, _T("%u.%u.%u.%u"),
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);

			wsprintf(tszInternalPort, _T("%u"),
					NTOHS(psaddrinPrivate[dwTemp].sin_port));


			//
			// Generate a description for this mapping.  The format is:
			//
			//     [executable_name] (nnn.nnn.nnn.nnn:nnnnn) nnnnn {"TCP" | "UDP"}
			//
			// That way nothing needs to be localized.
			//

			dwDescriptionLength = GetModuleFileName(NULL,
													ptszDescription,
													(MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1));
			if (dwDescriptionLength != 0)
			{
				//
				// Be paranoid and make sure the description string is valid.
				//
				ptszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1] = 0;

				//
				// Get just the executable name from the path.
				//
#ifdef WINCE
				GetExeName(ptszDescription);
#else // ! WINCE
#ifdef UNICODE
				_wsplitpath(ptszDescription, NULL, NULL, ptszDescription, NULL);
#else // ! UNICODE
				_splitpath(ptszDescription, NULL, NULL, ptszDescription, NULL);
#endif // ! UNICODE
#endif // ! WINCE


				dwDescriptionLength = _tcslen(ptszDescription)		// executable name
									+ 2								// " ("
									+ _tcslen(tszInternalClient)	// private IP address
									+ 1								// ":"
									+ _tcslen(tszInternalPort)		// private port
									+ 2								// ") "
									+ _tcslen(tszExternalPort)		// public port
									+ 4;							// " TCP" | " UDP"

				//
				// Make sure the long string will fit.  If not, use the
				// abbreviated version.
				//
				if (dwDescriptionLength > MAX_UPNP_MAPPING_DESCRIPTION_SIZE)
				{
					dwDescriptionLength = 0;
				}
			}

			if (dwDescriptionLength == 0)
			{
				//
				// Use the abbreviated version we know will fit.
				//
				wsprintf(ptszDescription,
						_T("(%s:%s) %s %s"),
						tszInternalClient,
						tszInternalPort,
						tszExternalPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
			else
			{
				//
				// There's enough room, tack on the rest of the
				// description.
				//
				wsprintf((ptszDescription + _tcslen(ptszDescription)),
						_T(" (%s:%s) %s %s"),
						tszInternalClient,
						tszInternalPort,
						tszExternalPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}



			if (fNeedToDeleteRegValue)
			{
				DPFX(DPFPREP, 7, "Removing NAT lease \"%s\" crash cleanup registry entry.",
					ptszDescription);


				if (! RegObject.Open(HKEY_LOCAL_MACHINE,
									DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVENATMAPPINGS,
									FALSE,
									TRUE,
									TRUE,
									DPN_KEY_ALL_ACCESS))
				{
					DPFX(DPFPREP, 0, "Couldn't open active NAT mapping key, unable to remove crash cleanup reference!");
				}
				else
				{
#ifndef UNICODE
					dwDescriptionLength = strlen(szDescription) + 1;
					hr = STR_jkAnsiToWide(wszDescription, szDescription, dwDescriptionLength);
					if (hr != S_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't convert NAT mapping description to Unicode (err = 0x%lx), unable to remove crash cleanup reference!",
							hr);

						//
						// Ignore error and continue.
						//
						hr = S_OK;
					}
					else
#endif // ! UNICODE
					{
						BOOL	fResult;


						//
						// Ignore error.
						//
						fResult = RegObject.DeleteValue(wszDescription);
						if (! fResult)
						{
							DPFX(DPFPREP, 0, "Couldn't delete NAT mapping value \"%s\"!  Continuing.",
								ptszDescription);
						}
					}

					RegObject.Close();
				}
			}
			else
			{
				DPFX(DPFPREP, 6, "No need to remove NAT lease \"%s\" crash cleanup registry entry.",
					ptszDescription);
			}
		}
		else
		{
			//
			// Registered port doesn't have a permanent UPnP lease.
			//
		}

		//
		// Move on to next port.
		//
	}

	
	//
	// If we're here, everything was successful.
	//

	DPFX(DPFPREP, 8, "Registered port 0x%p mapping successfully deleted from UPnP device (0x%p).",
		pRegisteredPort, pUPnPDevice);


Exit:

	if (pszMessage != NULL)
	{
		DNFree(pszMessage);
		pszMessage = NULL;
	}

	//
	// No matter whether we succeeded or failed, remove the UPnP public addresses
	// array and decrement the total lease count.
	//
	pRegisteredPort->DestroyUPnPPublicAddressesArray();

	DNASSERT(this->m_dwNumLeases > 0);
	this->m_dwNumLeases--;

	DPFX(DPFPREP, 7, "UPnP lease for 0x%p removed, total num leases = %u.",
		pRegisteredPort, this->m_dwNumLeases);

	
	pRegisteredPort->NoteNotPermanentUPnPLease();

	pRegisteredPort->NoteNotRemovingUPnPLease();



	pUPnPDevice->DecRef();

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// If we started waiting for a response, clear that.
	//
	if (fStartedWaitingForControlResponse)
	{
		pUPnPDevice->StopWaitingForControlResponse();
	}

	goto Exit;
} // CNATHelpUPnP::UnmapUPnPPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CleanupInactiveNATMappings"
//=============================================================================
// CNATHelpUPnP::CleanupInactiveNATMappings
//-----------------------------------------------------------------------------
//
// Description:    Looks for any mappings previously made by other DPNHUPNP
//				instances that are no longer active (because of a crash), and
//				unmaps them.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference if it's using the
//				device.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device to use.
//
// Returns: HRESULT
//	DPNH_OK							- The extension was successful.
//	DPNHERR_GENERIC					- An error occurred.
//	DPNHERR_SERVERNOTRESPONDING		- The server did not respond to the
//										message.
//=============================================================================
HRESULT CNATHelpUPnP::CleanupInactiveNATMappings(CUPnPDevice * const pUPnPDevice)
{
	HRESULT					hr = DPNH_OK;
	CDevice *				pDevice;
	CRegistry				RegObject;
	BOOL					fOpenedRegistry = FALSE;
	DWORD					dwIndex;
	WCHAR					wszValueName[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DWORD					dwValueNameSize;
	DPNHACTIVENATMAPPING	dpnhanm;
	DWORD					dwValueSize;
	CBilink *				pBilink;
	CUPnPDevice *			pUPnPDeviceTemp = NULL;	// NULLed out because PREfast has been hassling me for a while, even though the code is safe
	TCHAR					tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	DNHANDLE				hNamedObject = NULL;
	CRegisteredPort *		pRegisteredPort = NULL;
	BOOL					fSetPrivateAddresses = FALSE;
	SOCKADDR_IN				saddrinPrivate;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pUPnPDevice);


	DNASSERT(pUPnPDevice != NULL);

	pDevice = pUPnPDevice->GetOwningDevice();
	DNASSERT(pDevice != NULL);



	if (! RegObject.Open(HKEY_LOCAL_MACHINE,
						DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVENATMAPPINGS,
						FALSE,
						TRUE,
						TRUE,
						DPN_KEY_ALL_ACCESS))
	{
		DPFX(DPFPREP, 1, "Couldn't open active NAT mapping key, not performing crash cleanup.");
		DNASSERT(hr == DPNH_OK);
		goto Exit;
	}

	fOpenedRegistry = TRUE;


	//
	// Walk the list of active mappings.
	//
	dwIndex = 0;
	do
	{
		dwValueNameSize = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
		if (! RegObject.EnumValues(wszValueName, &dwValueNameSize, dwIndex))
		{
			//
			// There was an error or there aren't any more keys.  We're done.
			//
			break;
		}


		//
		// Try reading that mapping's data.
		//
		dwValueSize = sizeof(dpnhanm);
		if (! RegObject.ReadBlob(wszValueName, (LPBYTE) (&dpnhanm), &dwValueSize))
		{
			//
			// We don't have a lock protecting the registry, so some other
			// instance could have deleted the key between when we enumerated
			// it and now.  We'll stop trying (and hopefully that other
			// instance will cover the rest of the items).
			//
			DPFX(DPFPREP, 0, "Couldn't read \"%ls\" mapping value!  Done with cleanup.",
				wszValueName);

			DNASSERT(hr == DPNH_OK);
			goto Exit;
		}

		//
		// Validate the data read.
		//
		if ((dwValueSize != sizeof(dpnhanm)) ||
			(dpnhanm.dwVersion != ACTIVE_MAPPING_VERSION))
		{
			DPFX(DPFPREP, 0, "The \"%ls\" mapping value is invalid!  Done with cleanup.",
				wszValueName);

			//
			// Move to next item.
			//
			dwIndex++;
			continue;
		}


		//
		// See if it's owned by the local NATHelp instance.
		//
		if (dpnhanm.dwInstanceKey == this->m_dwInstanceKey)
		{
			//
			// We own(ed) it.  See if it was associated with a UPnP device
			// that's now gone.
			//
			pBilink = this->m_blUPnPDevices.GetNext();
			while (pBilink != &this->m_blUPnPDevices)
			{
				DNASSERT(! pBilink->IsEmpty());
				pUPnPDeviceTemp = UPNPDEVICE_FROM_BILINK(pBilink);

				if (pUPnPDeviceTemp->GetID() == dpnhanm.dwUPnPDeviceID)
				{
					//
					// This mapping truly is active, leave it alone.
					//
					break;
				}

				pBilink = pBilink->GetNext();
			}

			//
			// If we found the mapping, go on to the next one.
			//
			if (pBilink != &this->m_blUPnPDevices)
			{
				//
				// Note that despite what PREfast v1.0.1195 says,
				// pUPnPDeviceTemp will always be valid if we get here.
				// However, I gave in and NULLed out the pointer up top.
				//
				DPFX(DPFPREP, 4, "NAT mapping \"%ls\" belongs to current instance (%u)'s UPnP device 0x%p.",
					wszValueName, dpnhanm.dwInstanceKey, pUPnPDeviceTemp);

				//
				// Move to next item.
				//
				dwIndex++;
				continue;
			}


			//
			// Otherwise, we gave up on this mapping earlier.
			//

			DNASSERT((this->m_dwNumDeviceRemoves > 0) || (this->m_dwNumServerFailures > 0));

			DPFX(DPFPREP, 4, "NAT mapping \"%ls\" was owned by current instance (%u)'s UPnP device ID %u that no longer exists.",
				wszValueName, dpnhanm.dwInstanceKey, dpnhanm.dwUPnPDeviceID);
		}
		else
		{
			//
			// See if that DPNHUPNP instance is still around.
			//

#ifndef WINCE
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
			{
				wsprintf(tszObjectName, _T( "Global\\" ) INSTANCENAMEDOBJECT_FORMATSTRING, dpnhanm.dwInstanceKey);
			}
			else
#endif // ! WINCE
			{
				wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, dpnhanm.dwInstanceKey);
			}

			hNamedObject = DNOpenEvent(SYNCHRONIZE, FALSE, tszObjectName);
			if (hNamedObject != NULL)
			{
				//
				// This is still an active mapping.
				//

				DPFX(DPFPREP, 4, "NAT mapping \"%ls\" belongs to instance %u, which is still active.",
					wszValueName, dpnhanm.dwInstanceKey);

				DNCloseHandle(hNamedObject);
				hNamedObject = NULL;

				//
				// Move to next item.
				//
				dwIndex++;
				continue;
			}


			DPFX(DPFPREP, 4, "NAT mapping \"%ls\" belongs to instance %u, which no longer exists.",
				wszValueName, dpnhanm.dwInstanceKey);
		}


		//
		// Delete the value now that we have the information we need.
		//
		if (! RegObject.DeleteValue(wszValueName))
		{
			//
			// See ReadBlob comments.  Stop trying to cleanup.
			//
			DPFX(DPFPREP, 0, "Couldn't delete \"%ls\"!  Done with cleanup.",
				wszValueName);

			DNASSERT(hr == DPNH_OK);
			goto Exit;
		}


		//
		// Create a fake registered port that we will deregister.  Ignore the
		// firewall state flags.
		//
		pRegisteredPort = new CRegisteredPort(0, (dpnhanm.dwFlags & REGPORTOBJMASK_UPNP));
		if (pRegisteredPort == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Assert that the other UPnP information/state flags are not set.
		//
		DNASSERT(! pRegisteredPort->IsUPnPPortUnavailable());
		DNASSERT(! pRegisteredPort->IsRemovingUPnPLease());


		//
		// Temporarily associate the registered port with the device.
		//
		pRegisteredPort->MakeDeviceOwner(pDevice);


		
		ZeroMemory(&saddrinPrivate, sizeof(saddrinPrivate));
		saddrinPrivate.sin_family				= AF_INET;
		saddrinPrivate.sin_addr.S_un.S_addr		= dpnhanm.dwInternalAddressV4;
		saddrinPrivate.sin_port					= dpnhanm.wInternalPort;


		//
		// Store the private address.
		//
		hr = pRegisteredPort->SetPrivateAddresses(&saddrinPrivate, 1);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed creating UPnP address array!");
			goto Failure;
		}

		fSetPrivateAddresses = TRUE;
		

		//
		// Create the public address array.
		//
		hr = pRegisteredPort->CreateUPnPPublicAddressesArray();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed creating UPnP address array!");
			goto Failure;
		}


		//
		// Fake increase the number of leases we have.  It will just get
		// decremented in UnmapUPnPPort.
		//
		DPFX(DPFPREP, 7, "Creating temporary UPnP lease 0x%p, total num leases = %u.",
			pRegisteredPort, this->m_dwNumLeases);
		this->m_dwNumLeases++;


		//
		// Store the public port.
		//
		pRegisteredPort->SetUPnPPublicV4Address(0,
												dpnhanm.dwExternalAddressV4,
												dpnhanm.wExternalPort);


		//
		// Actually free the port.
		//
		hr = this->UnmapUPnPPort(pRegisteredPort, 1, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed deleting temporary UPnP port!");
			goto Failure;
		}


		pRegisteredPort->ClearPrivateAddresses();
		fSetPrivateAddresses = FALSE;

		pRegisteredPort->ClearDeviceOwner();

		delete pRegisteredPort;
		pRegisteredPort = NULL;


		//
		// Move to the next mapping.  Don't increment index since we just
		// deleted the previous entry and everything shifts down one.
		//
	}
	while (TRUE);


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pRegisteredPort != NULL)
	{
		if (pRegisteredPort->HasUPnPPublicAddresses())
		{
			pRegisteredPort->DestroyUPnPPublicAddressesArray();

			//
			// Remove the lease counter.
			//
			DNASSERT(this->m_dwNumLeases > 0);
			this->m_dwNumLeases--;

			DPFX(DPFPREP, 7, "UPnP lease for 0x%p removed, total num leases = %u.",
				pRegisteredPort, this->m_dwNumLeases);
		}

		if (fSetPrivateAddresses)
		{
			pRegisteredPort->ClearPrivateAddresses();
			fSetPrivateAddresses = FALSE;
		}

		pRegisteredPort->ClearDeviceOwner();

		delete pRegisteredPort;
		pRegisteredPort = NULL;
	}

	if (fOpenedRegistry)
	{
		RegObject.Close();
	}

	goto Exit;
} // CNATHelpUPnP::CleanupInactiveNATMappings





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::IsNATPublicPortInUseLocally"
//=============================================================================
// CNATHelpUPnP::IsNATPublicPortInUseLocally
//-----------------------------------------------------------------------------
//
// Description:    Looks for any mappings previously made by DPNHUPNP instances
//				that are still active that use the given public port.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	WORD wPortHostOrder		- Port to check, in host byte order.
//
// Returns: BOOL
//=============================================================================
BOOL CNATHelpUPnP::IsNATPublicPortInUseLocally(const WORD wPortHostOrder)
{
	BOOL					fResult = FALSE;
	WORD					wExternalPort;
	CRegistry				RegObject;
	BOOL					fOpenedRegistry = FALSE;
	DWORD					dwIndex;
	WCHAR					wszValueName[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DWORD					dwValueNameSize;
	DPNHACTIVENATMAPPING	dpnhanm;
	CBilink *				pBilink;
	CUPnPDevice *			pUPnPDevice = NULL;	// NULLed out because PREfast has been hassling me for a while, even though the code is safe
	DWORD					dwValueSize;
	TCHAR					tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	DNHANDLE				hNamedObject = NULL;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (%u)", this, wPortHostOrder);


	wExternalPort = HTONS(wPortHostOrder);


	if (! RegObject.Open(HKEY_LOCAL_MACHINE,
						DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVENATMAPPINGS,
						FALSE,
						TRUE,
						TRUE,
						DPN_KEY_ALL_ACCESS))
	{
		DPFX(DPFPREP, 1, "Couldn't open active NAT mapping key, assuming port not in use.");
		goto Exit;
	}

	fOpenedRegistry = TRUE;


	//
	// Walk the list of active mappings.
	//
	dwIndex = 0;
	do
	{
		dwValueNameSize = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
		if (! RegObject.EnumValues(wszValueName, &dwValueNameSize, dwIndex))
		{
			//
			// There was an error or there aren't any more keys.  We're done.
			//
			break;
		}


		//
		// Try reading that mapping's data.
		//
		dwValueSize = sizeof(dpnhanm);
		if (! RegObject.ReadBlob(wszValueName, (LPBYTE) (&dpnhanm), &dwValueSize))
		{
			//
			// We don't have a lock protecting the registry, so some other
			// instance could have deleted the key between when we enumerated
			// it and now.  We'll stop trying (and hopefully that other
			// instance will cover the rest of the items).
			//
			DPFX(DPFPREP, 0, "Couldn't read \"%ls\" mapping value, assuming port not in use.",
				wszValueName);
			goto Exit;
		}

		//
		// Validate the data read.
		//
		if ((dwValueSize != sizeof(dpnhanm)) ||
			(dpnhanm.dwVersion != ACTIVE_MAPPING_VERSION))
		{
			DPFX(DPFPREP, 0, "The \"%ls\" mapping value is invalid, assuming port not in use.",
				wszValueName);

			//
			// Move to next item.
			//
			dwIndex++;
			continue;
		}


		//
		// Is this the right port?
		//
		if (dpnhanm.wExternalPort == wExternalPort)
		{
			//
			// See if it's owned by the local NATHelp instance.
			//
			if (dpnhanm.dwInstanceKey == this->m_dwInstanceKey)
			{
				//
				// We own(ed) it.  See if it was associated with a UPnP device
				// that's now gone.
				//
				pBilink = this->m_blUPnPDevices.GetNext();
				while (pBilink != &this->m_blUPnPDevices)
				{
					DNASSERT(! pBilink->IsEmpty());
					pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);

					if (pUPnPDevice->GetID() == dpnhanm.dwUPnPDeviceID)
					{
						//
						// This mapping truly still active.
						//
						fResult = TRUE;
						break;
					}

					pBilink = pBilink->GetNext();
				}


				if (pBilink != &this->m_blUPnPDevices)
				{
					//
					// Note that despite what PREfast v1.0.1195 says,
					// pUPnPDevice will always be valid if we get here.
					// However, I gave in and NULLed out the pointer up top.
					//
					DPFX(DPFPREP, 4, "NAT mapping \"%ls\" belongs to current instance (%u)'s UPnP device 0x%p.",
						wszValueName, dpnhanm.dwInstanceKey, pUPnPDevice);
				}
				else
				{
					DPFX(DPFPREP, 4, "NAT mapping \"%ls\" was owned by current instance (%u)'s UPnP device ID %u that no longer exists.",
						wszValueName, dpnhanm.dwInstanceKey, dpnhanm.dwUPnPDeviceID);
				}
			}
			else
			{
				//
				// See if that DPNHUPNP instance is still around.
				//

#ifndef WINCE
				if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
				{
					wsprintf(tszObjectName, _T( "Global\\" ) INSTANCENAMEDOBJECT_FORMATSTRING, dpnhanm.dwInstanceKey);
				}
				else
#endif // ! WINCE
				{
					wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, dpnhanm.dwInstanceKey);
				}

				hNamedObject = DNOpenEvent(SYNCHRONIZE, FALSE, tszObjectName);
				if (hNamedObject != NULL)
				{
					//
					// This is still an active instance.  Since we can't walk
					// his list of UPnP devices, we have to assume the port is
					// still in use.
					//

					DPFX(DPFPREP, 4, "NAT mapping \"%ls\" belongs to instance %u, which is still active.  Assuming port in use.",
						wszValueName, dpnhanm.dwInstanceKey);

					DNCloseHandle(hNamedObject);
					hNamedObject = NULL;

					fResult = TRUE;
				}
				else
				{
					DPFX(DPFPREP, 4, "NAT mapping \"%ls\" belongs to instance %u, which no longer exists.",
						wszValueName, dpnhanm.dwInstanceKey);
				}
			}


			//
			// We found the mapping.  We have our result now.
			//
			goto Exit;
		}

		
		//
		// If we're here, this is not the external port we're looking for.
		//
		DPFX(DPFPREP, 8, "NAT mapping \"%ls\" does not use external port %u.",
			wszValueName, wPortHostOrder);


		//
		// Move to the next mapping.
		//
		dwIndex++;
	}
	while (TRUE);


	//
	// If we're here, we didn't find the mapping.
	//
	DPFX(DPFPREP, 4, "Didn't find any local NAT mappings that use external port %u.",
		wPortHostOrder);


Exit:

	if (fOpenedRegistry)
	{
		RegObject.Close();
	}

	DPFX(DPFPREP, 6, "(0x%p) Returning: [%i]", this, fResult);

	return fResult;
} // CNATHelpUPnP::IsNATPublicPortInUseLocally





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForUPnPAnnouncements"
//=============================================================================
// CNATHelpUPnP::CheckForUPnPAnnouncements
//-----------------------------------------------------------------------------
//
// Description:    Receives any UPnP announcement messages sent to this control
//				point.  The entire timeout period will elapse, unless all
//				devices get responses earlier.
//
//				   This will only send discovery requests for local devices
//				unless fSendRemoteGatewayDiscovery is TRUE.  However, we may
//				still detect new ones if we got a straggling response from the
//				last time we were allowed to send remotely.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	DWORD dwTimeout						- How long to wait for messages to
//											arrive.
//	BOOL fSendRemoteGatewayDiscovery	- Whether we can search remotely or
//											not.
//
// Returns: HRESULT
//	DPNH_OK				- Messages were received successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForUPnPAnnouncements(const DWORD dwTimeout,
												const BOOL fSendRemoteGatewayDiscovery)
{
	HRESULT			hr;
	DWORD			dwNumberOfTimes = 0;
	DWORD			dwCurrentTime;
	DWORD			dwEndTime;
	DWORD			dwNextSearchMessageTime;
	FD_SET			fdsRead;
	DWORD			dwNumDevicesSearchingForUPnPDevices;
	timeval			tv;
	CBilink *		pBilink;
	CDevice *		pDevice;
	int				iReturn;
	int				iRecvAddressSize;
	char			acBuffer[UPNP_DGRAM_RECV_BUFFER_SIZE];
	SOCKADDR_IN		saddrinRecvAddress;
	DWORD			dwError;
	BOOL			fInitiatedConnect = FALSE;
#ifdef DBG
	BOOL			fGotData = FALSE;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters:(%u, %i)",
		this, dwTimeout, fSendRemoteGatewayDiscovery);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);


	dwCurrentTime = GETTIMESTAMP();
	dwEndTime = dwCurrentTime + dwTimeout;
	dwNextSearchMessageTime = dwCurrentTime;

	//
	// Keep looping until the timeout elapses.
	//
	do
	{
		FD_ZERO(&fdsRead);
		dwNumDevicesSearchingForUPnPDevices = 0;


		//
		// Build an FD_SET for all the sockets and send out search messages for
		// all devices.
		//
		DNASSERT(! this->m_blDevices.IsEmpty());
		pBilink = this->m_blDevices.GetNext();
		while (pBilink != &this->m_blDevices)
		{
			DNASSERT(! pBilink->IsEmpty());
			pDevice = DEVICE_FROM_BILINK(pBilink);


			//
			// We add it to the set whether we search or not, since if we're
			// not searching, we're going to be clearing straggling messages.
			//
			DNASSERT(pDevice->GetUPnPDiscoverySocket() != INVALID_SOCKET);
			FD_SET(pDevice->GetUPnPDiscoverySocket(), &fdsRead);


			//
			// Don't send search messages if we already have a UPnP device or
			// this is the loopback adapter.
			//
			if ((pDevice->GetUPnPDevice() == NULL) &&
				(pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK))
			{
				//
				// If this is the first time through the loop, clear the
				// CONNRESET warning flags.
				//
				if (dwNumberOfTimes == 0)
				{
					pDevice->NoteNotGotRemoteUPnPDiscoveryConnReset();
					pDevice->NoteNotGotLocalUPnPDiscoveryConnReset();
				}


				//
				// Send out search messages if it's time.
				//
				if ((int) (dwNextSearchMessageTime - dwCurrentTime) <= 0)
				{
					hr = this->SendUPnPSearchMessagesForDevice(pDevice,
																fSendRemoteGatewayDiscovery);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't send UPnP search messages via every device!");
						goto Failure;
					}
				}
				else
				{
					//
					// Not time to send search messages.
					//
				}


				//
				// For subsequent times through the loop, make sure we didn't
				// get a CONNRESET earlier telling us not to try again.
				// The "attempt?" flags got set in
				// SendUPnPSearchMessagesForDevice, and the CONNRESET flags
				// were cleared the first time we entered here.
				//
				if ((pDevice->IsOKToPerformRemoteUPnPDiscovery()) ||
					(pDevice->IsOKToPerformLocalUPnPDiscovery()))
				{
					//
					// Remember that we're trying to detect an Internet Gateway
					// for this device.  See caveat immediately following, and
					// below for this variable's usage.
					//
					dwNumDevicesSearchingForUPnPDevices++;


					//
					// Minor optimization:
					//
					// If we're only supposed to be trying locally, and we're
					// the public address for a local gateway, assume that we
					// actually shouldn't be trying locally.  This is because
					// Windows XP ICS keeps port 1900 open even on the public
					// adapter, so we think we need to look for a local one
					// even though we won't find one.  So once the remote
					// lookup comes back with a CONNRESET, we no longer need to
					// bother trying.
					//
					// So first check if we're only trying locally.
					//
					if ((pDevice->IsOKToPerformLocalUPnPDiscovery()) &&
						(! pDevice->IsOKToPerformRemoteUPnPDiscovery()))
					{
						CBilink *		pBilinkPrivateDevice;
						CDevice *		pPrivateDevice;
						CUPnPDevice *	pUPnPDevice;


						//
						// Then loop through every device.
						//
						pBilinkPrivateDevice = this->m_blDevices.GetNext();
						while (pBilinkPrivateDevice != &this->m_blDevices)
						{
							pPrivateDevice = DEVICE_FROM_BILINK(pBilinkPrivateDevice);
							pUPnPDevice = pPrivateDevice->GetUPnPDevice();


							//
							// If it's not the device we're querying and it has
							// a ready UPnP device, dig deeper.
							//
							if ((pPrivateDevice != pDevice) &&
								(pUPnPDevice != NULL) &&
								(pUPnPDevice->IsReady()))
							{
								//
								// If its a local UPnP device and its public
								// address is this device's address, we found a
								// match.
								//
								if ((pUPnPDevice->IsLocal()) &&
									(pUPnPDevice->GetExternalIPAddressV4() == pDevice->GetLocalAddressV4()))
								{
									DPFX(DPFPREP, 4, "Device 0x%p is the public address for device 0x%p's local UPnP device 0x%p, not including in search.",
										pDevice, pPrivateDevice, pUPnPDevice);
									
									//
									// Remove the count we added above.
									//
									dwNumDevicesSearchingForUPnPDevices--;

									//
									// Stop searching.
									//
									break;
								}
								
								//
								// Otherwise keep going.
								//
								DPFX(DPFPREP, 8, "Skipping device 0x%p, UPnP device 0x%p not local (%i, control addr = %u.%u.%u.%u) or its public address doesn't match device 0x%p's address.",
									pPrivateDevice,
									pUPnPDevice,
									(! pUPnPDevice->IsLocal()),
									pUPnPDevice->GetControlAddress()->sin_addr.S_un.S_un_b.s_b1,
									pUPnPDevice->GetControlAddress()->sin_addr.S_un.S_un_b.s_b2,
									pUPnPDevice->GetControlAddress()->sin_addr.S_un.S_un_b.s_b3,
									pUPnPDevice->GetControlAddress()->sin_addr.S_un.S_un_b.s_b4,
									pDevice);
							}
							else
							{
								DPFX(DPFPREP, 8, "Skipping device 0x%p, it's the one we're looking for (matched 0x%p), it doesn't have a UPnP device (0x%p is NULL), and/or its UPnP device is not ready.",
									pPrivateDevice, pDevice, pUPnPDevice);
							}


							//
							// Go on to next device.
							//
							pBilinkPrivateDevice = pBilinkPrivateDevice->GetNext();
						}
					}
					else
					{
						//
						// Either not searching locally, or searching both
						// locally and remotely.
						//
						DPFX(DPFPREP, 8, "Device 0x%p local search OK = %i, remote search OK = %i.",
							pDevice,
							pDevice->IsOKToPerformLocalUPnPDiscovery(),
							pDevice->IsOKToPerformRemoteUPnPDiscovery());
					}
				}
				else
				{
					DPFX(DPFPREP, 3, "Device 0x%p should not perform UPnP discovery.",
						pDevice);
				}
			}
			else
			{
				DPFX(DPFPREP, 8, "Device 0x%p already has UPnP device (0x%p) or is loopback address.",
					pDevice, pDevice->GetUPnPDevice());
			}

			
			pBilink = pBilink->GetNext();
		}


		//
		// Wait for any data, unless all devices already have an Internet
		// Gateway, in which case we only want to clear the receive queue for
		// the sockets.
		//
		if (dwNumDevicesSearchingForUPnPDevices == 0)
		{
			DPFX(DPFPREP, 7, "No devices need to search for UPnP devices, clearing straggling messages from sockets.");

			tv.tv_usec		= 0;
		}
		else
		{
			//
			// Calculate the next time to send if we just sent search messages.
			//
			if ((int) (dwNextSearchMessageTime - dwCurrentTime) <= 0)
			{
				dwNextSearchMessageTime += UPNP_SEARCH_MESSAGE_INTERVAL;

				//
				// If we took way longer than expected in a previous loop
				// (because of stress or Win9x errata), the next search time
				// may have already passed.  Just search right now if that's
				// the case.
				//
				if ((int) (dwNextSearchMessageTime - dwCurrentTime) <= 0)
				{
					dwNextSearchMessageTime = dwCurrentTime;
				}
			}


			//
			// See how long we should wait for responses.  Choose the total end
			// time or the next search message time, whichever is shorter.
			//
			if ((int) (dwEndTime - dwNextSearchMessageTime) < 0)
			{
				DPFX(DPFPREP, 7, "Waiting %u ms for incoming responses.",
					(dwEndTime - dwCurrentTime));

				tv.tv_usec	= (dwEndTime - dwCurrentTime) * 1000;
			}
			else
			{
				DPFX(DPFPREP, 7, "Waiting %u ms for incoming responses, and then might send search messages again.",
					(dwNextSearchMessageTime - dwCurrentTime));

				tv.tv_usec	= (dwNextSearchMessageTime - dwCurrentTime) * 1000;
			}
		}

		tv.tv_sec			= 0;


		iReturn = this->m_pfnselect(0, &fdsRead, NULL, NULL, &tv);
		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u trying to select on UPnP discovery sockets!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// See if any sockets were selected.
		//
		if (iReturn > 0)
		{
			//
			// Loop through all devices, looking for those that have data.
			//
			pBilink = this->m_blDevices.GetNext();
			while (pBilink != &this->m_blDevices)
			{
				DNASSERT(! pBilink->IsEmpty());
				pDevice = DEVICE_FROM_BILINK(pBilink);


				//
				// If this device's socket is set there's data to read.
				//
				//if (FD_ISSET(pDevice->GetUPnPDiscoverySocket(), &fdsRead))
				if (this->m_pfn__WSAFDIsSet(pDevice->GetUPnPDiscoverySocket(), &fdsRead))
				{
#ifdef DBG
					fGotData = TRUE;
#endif // DBG


					iRecvAddressSize = sizeof(saddrinRecvAddress);

					iReturn = this->m_pfnrecvfrom(pDevice->GetUPnPDiscoverySocket(),
												acBuffer,
												(sizeof(acBuffer) - 1), // -1 to allow string termination
												0,
												(SOCKADDR*) (&saddrinRecvAddress),
												&iRecvAddressSize);

					if ((iReturn == 0) || (iReturn == SOCKET_ERROR))
					{
						dwError = this->m_pfnWSAGetLastError();


						//
						// WSAENOBUFS means WinSock is out of memory.
						//
						if (dwError == WSAENOBUFS)
						{
							DPFX(DPFPREP, 0, "WinSock returned WSAENOBUFS while receiving discovery response!");
							hr = DPNHERR_OUTOFMEMORY;
							goto Failure;
						}


						//
						// All other errors besides WSAECONNRESET are
						// unexpected and mean we should bail.
						//
						if (dwError != WSAECONNRESET)
						{
							DPFX(DPFPREP, 0, "Got sockets error %u trying to receive on device 0x%p!",
								dwError, pDevice);
							hr = DPNHERR_GENERIC;
							goto Failure;
						}


						//
						// If we're here, it must be WSAECONNRESET.  Correlate
						// it with the outbound message that generated it so we
						// don't bother waiting for a response from that
						// location.
						// Validate that it's for the port to which the message
						// should have been sent.
						//
						if (saddrinRecvAddress.sin_port == HTONS(UPNP_PORT))
						{
							if (saddrinRecvAddress.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4())
							{
								DPFX(DPFPREP, 1, "Got CONNRESET for local discovery attempt on device 0x%p (%u.%u.%u.%u:%u).",
									pDevice,
									saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b1,
									saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b2,
									saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b3,
									saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b4,
									NTOHS(saddrinRecvAddress.sin_port));

								//
								// Note the local error.
								//
								pDevice->NoteGotLocalUPnPDiscoveryConnReset();
							}
							else
							{
								if (! g_fUseMulticastUPnPDiscovery)
								{
									IN_ADDR		inaddrGateway;


									if ((! this->GetAddressToReachGateway(pDevice, &inaddrGateway)) ||
										(inaddrGateway.S_un.S_addr == INADDR_BROADCAST) ||
										(saddrinRecvAddress.sin_addr.S_un.S_addr == inaddrGateway.S_un.S_addr))
									{
										DPFX(DPFPREP, 2, "Got CONNRESET for remote discovery attempt on device 0x%p (%u.%u.%u.%u:%u).",
											pDevice,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b1,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b2,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b3,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b4,
											NTOHS(saddrinRecvAddress.sin_port));

										//
										// Note the remote error.
										//
										pDevice->NoteGotRemoteUPnPDiscoveryConnReset();
									}
									else
									{
										DPFX(DPFPREP, 1, "Ignoring CONNRESET on device 0x%p, sender %u.%u.%u.%u is not gateway %u.%u.%u.%u.",
											pDevice,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b1,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b2,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b3,
											saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b4,
											inaddrGateway.S_un.S_un_b.s_b1,
											inaddrGateway.S_un.S_un_b.s_b2,
											inaddrGateway.S_un.S_un_b.s_b3,
											inaddrGateway.S_un.S_un_b.s_b4);
									}
								}
								else
								{
									DPFX(DPFPREP, 1, "Ignoring CONNRESET on device 0x%p from sender %u.%u.%u.%u, we are using multicast discovery.",
										pDevice,
										saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b1,
										saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b2,
										saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b3,
										saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b4);
								}
							}
						}
						else
						{
							DPFX(DPFPREP, 1, "Ignoring CONNRESET on device 0x%p for invalid port (%u.%u.%u.%u:%u).",
								pDevice,
								saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b1,
								saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b2,
								saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b3,
								saddrinRecvAddress.sin_addr.S_un.S_un_b.s_b4,
								NTOHS(saddrinRecvAddress.sin_port));
						}
					}
					else
					{
						DNASSERT(iRecvAddressSize == sizeof(saddrinRecvAddress));
						DNASSERT(iReturn < sizeof(acBuffer));


						hr = this->HandleUPnPDiscoveryResponseMsg(pDevice,
																&saddrinRecvAddress,
																acBuffer,
																iReturn,
																&fInitiatedConnect);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't handle UPnP discovery response message (err = 0x%lx), ignoring.",
								hr);
						}
					}
				}
				
				pBilink = pBilink->GetNext();
			}


			//
			// Make sure we actually found a socket with data.
			//
			DNASSERT(fGotData);
		}
		else
		{
			//
			// We timed out.  If we were just clearing receive buffers for the
			// socket(s), we're done.
			//
			if (dwNumDevicesSearchingForUPnPDevices == 0)
			{
				break;
			}
		}


		//
		// Increase the counter.
		//
		dwNumberOfTimes++;


		//
		// Get current time for figuring out how much longer to wait.
		//
		dwCurrentTime = GETTIMESTAMP();
	}
	while ((int) (dwEndTime - dwCurrentTime) > 0);


	hr = DPNH_OK;


	//
	// If we initiated connections to any UPnP devices, wait for them to
	// complete.
	//
	if (fInitiatedConnect)
	{
		hr = this->WaitForUPnPConnectCompletions();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't wait for UPnP connect completions!");
			goto Failure;
		}
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::CheckForUPnPAnnouncements





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::WaitForUPnPConnectCompletions"
//=============================================================================
// CNATHelpUPnP::WaitForUPnPConnectCompletions
//-----------------------------------------------------------------------------
//
// Description:    Waits for completions for pending TCP connects to UPnP
//				Internet gateway devices.
//
//				   UPnP devices may get removed from list if a failure occurs.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- Connects were handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::WaitForUPnPConnectCompletions(void)
{
	HRESULT			hr;
	int				iNumSockets;
	FD_SET			fdsWrite;
	FD_SET			fdsExcept;
	CBilink *		pBilink;
	CUPnPDevice *	pUPnPDevice;
	timeval			tv;
	int				iReturn;
	BOOL			fRequestedDescription = FALSE;
	DWORD			dwStartTime;
	DWORD			dwTimeout;
	CDevice *		pDevice;
#ifdef DBG
	BOOL			fFoundCompletion;
	DWORD			dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);


	//
	// Loop until all sockets are connected or there's a timeout.
	//
	do
	{
		//
		// Check for any connect completions.  Start by building two FD_SETs
		// for all the sockets with pending connects.
		//

		FD_ZERO(&fdsWrite);
		FD_ZERO(&fdsExcept);
		iNumSockets = 0;

		pBilink = this->m_blUPnPDevices.GetNext();
		while (pBilink != &this->m_blUPnPDevices)
		{
			DNASSERT(! pBilink->IsEmpty());
			pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);

			if (pUPnPDevice->IsConnecting())
			{
				DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);

				FD_SET(pUPnPDevice->GetControlSocket(), &fdsWrite);
				FD_SET(pUPnPDevice->GetControlSocket(), &fdsExcept);
				iNumSockets++;
			}
			
			pBilink = pBilink->GetNext();
		}


		//
		// If there weren't any sockets that had pending connections, then
		// we're done here.
		//
		if (iNumSockets <= 0)
		{
			DPFX(DPFPREP, 7, "No more UPnP device control sockets with pending connections.");
			break;
		}


		DPFX(DPFPREP, 7, "There are %i UPnP device control sockets with pending connections.",
			iNumSockets);


		//
		// Wait for connect completions.  We don't wait for the full TCP/IP
		// timeout (which is why we made it non-blocking).
		//

		tv.tv_usec	= 0;
		tv.tv_sec	= g_dwUPnPConnectTimeout;

		iReturn = this->m_pfnselect(0, NULL, &fdsWrite, &fdsExcept, &tv);
		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u trying to select on UPnP device sockets!",
				dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// If no sockets were selected, that means the connections timed out.
		// Remove all the devices that were waiting.
		//
		if (iReturn == 0)
		{
			DPFX(DPFPREP, 3, "Select for %u seconds timed out.", g_dwUPnPConnectTimeout);

			pBilink = this->m_blUPnPDevices.GetNext();
			while (pBilink != &this->m_blUPnPDevices)
			{
				DNASSERT(! pBilink->IsEmpty());
				pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);
				pBilink = pBilink->GetNext();

				if (pUPnPDevice->IsConnecting())
				{
					DPFX(DPFPREP, 7, "UPnP device 0x%p is still connecting, removing.",
						pUPnPDevice);


					//
					// Dump this unusable UPnP device and continue.
					//

					pDevice = pUPnPDevice->GetOwningDevice();
					DNASSERT(pUPnPDevice->GetOwningDevice() != NULL);

					DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);
					this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
					pUPnPDevice->SetControlSocket(INVALID_SOCKET);


					//
					// This may cause our pUPnPDevice pointer to become
					// invalid.
					//
					this->ClearDevicesUPnPDevice(pDevice);


#ifdef DBG
					iNumSockets--;
#endif // DBG
				}
				else
				{
					DPFX(DPFPREP, 7, "UPnP device 0x%p is not trying to connect or has safely connected.",
						pUPnPDevice);
				}
			}

			//
			// We should have destroyed the same number of devices that were
			// waiting.
			//
			DNASSERT(iNumSockets == 0);

			//
			// Continue on to handling any sockets succeeded previously.
			//
			break;
		}


		//
		// If we're here, some sockets were signalled.
		//

#ifdef DBG
		DPFX(DPFPREP, 7, "There are %i sockets with connect activity.", iReturn);
		fFoundCompletion = FALSE;
#endif // DBG

		pBilink = this->m_blUPnPDevices.GetNext();
		while (pBilink != &this->m_blUPnPDevices)
		{
			DNASSERT(! pBilink->IsEmpty());
			pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();

			if (pUPnPDevice->IsConnecting())
			{
				DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);


				//
				// If this UPnP device's socket is in the write set it
				// connected successfully.
				//
				//if (FD_ISSET(pUPnPDevice->GetControlSocket(), &fdsWrite))
				if (this->m_pfn__WSAFDIsSet(pUPnPDevice->GetControlSocket(), &fdsWrite))
				{
					pUPnPDevice->NoteConnected();

#ifdef DBG
					fFoundCompletion = TRUE;
#endif // DBG

					if (! pUPnPDevice->IsReady())
					{
						DPFX(DPFPREP, 2, "UPnP device object 0x%p now connected to Internet gateway device.",
							pUPnPDevice);

						hr = this->SendUPnPDescriptionRequest(pUPnPDevice);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't send UPnP description request to device object 0x%p!  Disconnecting.",
								pUPnPDevice);


							//
							// Dump this unusable UPnP device and continue.
							//

							pDevice = pUPnPDevice->GetOwningDevice();
							DNASSERT(pUPnPDevice->GetOwningDevice() != NULL);

							//
							// This may cause our pUPnPDevice pointer to become
							// invalid.
							//
							this->ClearDevicesUPnPDevice(pDevice);
						}
						else
						{
							fRequestedDescription = TRUE;
						}
					}
					else
					{
						DPFX(DPFPREP, 2, "UPnP device object 0x%p successfully reconnected to Internet gateway device.",
							pUPnPDevice);
					}
				}
				else
				{
					//
					// If this UPnP device's socket is in the except set it
					// failed to connect.
					//
					//if (FD_ISSET(pUPnPDevice->GetControlSocket(), &fdsExcept))
					if (this->m_pfn__WSAFDIsSet(pUPnPDevice->GetControlSocket(), &fdsExcept))
					{
#ifdef DBG
						int		iError;
						int		iErrorSize;


						fFoundCompletion = TRUE;

						//
						// Print out the reason why it couldn't connect.
						// Ignore the direct return code from getsockopt.
						//
						iError = 0;
						iErrorSize = sizeof(iError);
						this->m_pfngetsockopt(pUPnPDevice->GetControlSocket(),
											SOL_SOCKET,
											SO_ERROR,
											(char*) (&iError),
											&iErrorSize);
						DPFX(DPFPREP, 1, "Connecting to UPnP device object 0x%p failed with error %i, removing from list.",
							pUPnPDevice, iError);
#endif // DBG

						//
						// This UPnP device is useless if it doesn't respond.
						// Throw it out.
						//

						pDevice = pUPnPDevice->GetOwningDevice();
						DNASSERT(pUPnPDevice->GetOwningDevice() != NULL);

						this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
						pUPnPDevice->SetControlSocket(INVALID_SOCKET);

						//
						// This may cause our pUPnPDevice pointer to become
						// invalid.
						//
						this->ClearDevicesUPnPDevice(pDevice);
					}
					else
					{
						//
						// Socket is still connecting.
						//
					}
				}
			}
			else
			{
				//
				// This socket is already connected.
				//
			}
		}


		//
		// Make sure we actually found a socket with a connect completion this
		// time through.
		//
		DNASSERT(fFoundCompletion);
	}
	while (TRUE);


	//
	// If we're here, all UPnP devices are connected or have since been
	// destroyed.
	//
	if (fRequestedDescription)
	{
		//
		// Wait for the description responses to come back.
		//
		dwStartTime = GETTIMESTAMP();
		dwTimeout = g_dwUPnPResponseTimeout;
		do
		{
			hr = this->CheckForReceivedUPnPMsgsOnAllDevices(dwTimeout);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed receiving UPnP messages!");
				goto Failure;
			}

			//
			// We either timed out or got some data.  Check if we got the
			// response(s) we need.  Reuse the fRequestedDescription
			// boolean.
			//

			fRequestedDescription = FALSE;

			pBilink = this->m_blUPnPDevices.GetNext();
			while (pBilink != &this->m_blUPnPDevices)
			{
				DNASSERT(! pBilink->IsEmpty());
				pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);

				if (! pUPnPDevice->IsReady())
				{
					if (pUPnPDevice->IsConnected())
					{
						DPFX(DPFPREP, 7, "UPnP device 0x%p is not ready yet.",
							pUPnPDevice);
						fRequestedDescription = TRUE;
					}
					else
					{
						DPFX(DPFPREP, 4, "UPnP device 0x%p got disconnected before receiving description response.",
							pUPnPDevice);
					}

					break;
				}

				pBilink = pBilink->GetNext();
			}

			if (! fRequestedDescription)
			{
				DPFX(DPFPREP, 6, "All UPnP devices are ready or disconnected now.");

				//
				// Break out of the wait loop.
				//
				break;
			}


			//
			// Calculate how long we have left to wait.  If the calculation
			// goes negative, it means we're done.
			//
			dwTimeout = g_dwUPnPResponseTimeout - (GETTIMESTAMP() - dwStartTime);
		}
		while (((int) dwTimeout > 0));


		//
		// Any devices that still aren't ready yet were either disconnected or
		// are taking too long and should be removed.
		//
		pBilink = this->m_blUPnPDevices.GetNext();
		while (pBilink != &this->m_blUPnPDevices)
		{
			DNASSERT(! pBilink->IsEmpty());
			pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();

			if (! pUPnPDevice->IsReady())
			{
				DPFX(DPFPREP, 1, "UPnP device 0x%p got disconnected or took too long to get ready, removing.",
					pUPnPDevice);


				pDevice = pUPnPDevice->GetOwningDevice();
				DNASSERT(pUPnPDevice->GetOwningDevice() != NULL);

				//
				// This may cause our pUPnPDevice pointer to become
				// invalid.
				//
				this->ClearDevicesUPnPDevice(pDevice);
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "Did not request any descriptions.");
	}


	//
	// If we're here, everything is successful and we're done.
	//
	hr = DPNH_OK;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::WaitForUPnPConnectCompletions





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForReceivedUPnPMsgsOnAllDevices"
//=============================================================================
// CNATHelpUPnP::CheckForReceivedUPnPMsgsOnAllDevices
//-----------------------------------------------------------------------------
//
// Description:    Handles any incoming data on the TCP sockets connect to UPnP
//				Internet gateway devices.
//
//				   UPnP devices with failures may get removed from the list.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	DWORD dwTimeout		- How long to wait for messages to arrive, or 0 to just
//							poll.
//
// Returns: HRESULT
//	DPNH_OK				- Messages were handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForReceivedUPnPMsgsOnAllDevices(const DWORD dwTimeout)
{
	HRESULT			hr;
	int				iNumSockets;
	FD_SET			fdsRead;
	CBilink *		pBilink;
	CUPnPDevice *	pUPnPDevice;
	timeval			tv;
	int				iReturn;
#ifdef DBG
	BOOL			fFoundData = FALSE;
	DWORD			dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (%u)", this, dwTimeout);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);


Rewait:

	iNumSockets = 0;


	//
	// Check for any data.  Start by building an FD_SET for all the sockets
	// with completed connections.
	//

	FD_ZERO(&fdsRead);

	pBilink = this->m_blUPnPDevices.GetNext();
	while (pBilink != &this->m_blUPnPDevices)
	{
		DNASSERT(! pBilink->IsEmpty());
		pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);

		if (pUPnPDevice->IsConnected())
		{
			DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);

			FD_SET(pUPnPDevice->GetControlSocket(), &fdsRead);
			iNumSockets++;
		}
		
		pBilink = pBilink->GetNext();
	}


	//
	// If there weren't any sockets that were connected, then we're done here.
	//
	if (iNumSockets <= 0)
	{
		DPFX(DPFPREP, 7, "No connected UPnP device control sockets.");
		hr = DPNH_OK;
		goto Exit;
	}


	DPFX(DPFPREP, 7, "There are %i connected UPnP device control sockets.",
		iNumSockets);


	//
	// Wait for received data.
	//

	tv.tv_usec	= dwTimeout * 1000;
	tv.tv_sec	= 0;

	iReturn = this->m_pfnselect(0, &fdsRead, NULL, NULL, &tv);
	if (iReturn == SOCKET_ERROR)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Got sockets error %u trying to select on UPnP device sockets!",
			dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// If no sockets were selected, we're done.
	//
	if (iReturn == 0)
	{
		DPFX(DPFPREP, 7, "Timed out waiting for data on %i sockets.",
			iNumSockets);
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// If we're here, some sockets were signalled.
	//

	pBilink = this->m_blUPnPDevices.GetNext();
	while (pBilink != &this->m_blUPnPDevices)
	{
		DNASSERT(! pBilink->IsEmpty());
		pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilink);
		pBilink = pBilink->GetNext();

		if (pUPnPDevice->IsConnected())
		{
			DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);


			//
			// If this UPnP device's socket is in the read set it has data.
			//
			//if (FD_ISSET(pUPnPDevice->GetControlSocket(), &fdsRead))
			if (this->m_pfn__WSAFDIsSet(pUPnPDevice->GetControlSocket(), &fdsRead))
			{
#ifdef DBG
				fFoundData = TRUE;
#endif // DBG

				//
				// Grab a reference, since ReceiveUPnPDataStream may clear the
				// device.
				//
				pUPnPDevice->AddRef();


				hr = this->ReceiveUPnPDataStream(pUPnPDevice);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't receive UPnP stream from device object 0x%p (err = 0x%lx)!  Disconnecting.",
						pUPnPDevice, hr);

					//
					// Dump this unusable UPnP device and continue.
					//
					if (pUPnPDevice->GetOwningDevice() != NULL)
					{
						this->ClearDevicesUPnPDevice(pUPnPDevice->GetOwningDevice());
					}
					else
					{
						DPFX(DPFPREP, 1, "UPnP device 0x%p's has already been removed from owning device.",
							pUPnPDevice);
					}

					hr = DPNH_OK;
				}

				//
				// Remove the reference we added.
				//
				pUPnPDevice->DecRef();
			}
			else
			{
				//
				// Socket does not have any data.
				//
				DPFX(DPFPREP, 8, "Skipping UPnP device 0x%p because it does not have any data.",
					pUPnPDevice);
			}
		}
		else
		{
			//
			// This socket is not connected yet/anymore.
			//
			DPFX(DPFPREP, 7, "Skipping unconnected UPnP device 0x%p.", pUPnPDevice);
		}
	}


	//
	// Make sure we actually found a socket with data.
	//
	DNASSERT(fFoundData);


	//
	// We found data, so see if there's more.  Connection should be closed
	// after responses.
	//
	DPFX(DPFPREP, 7, "Waiting for more data on the sockets.");
	goto Rewait;



Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::CheckForReceivedUPnPMsgsOnAllDevices





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForReceivedUPnPMsgsOnDevice"
//=============================================================================
// CNATHelpUPnP::CheckForReceivedUPnPMsgsOnDevice
//-----------------------------------------------------------------------------
//
// Description:    Handles any incoming data on the TCP socket for the given
//				UPnP device.
//
//				   If the UPnP device encounters a failure, it may get removed
//				from the list.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device to receive data.
//	DWORD dwTimeout				- How long to wait for messages to arrive, or 0
//									to just poll.
//
// Returns: HRESULT
//	DPNH_OK				- Messages were handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForReceivedUPnPMsgsOnDevice(CUPnPDevice * const pUPnPDevice,
														const DWORD dwTimeout)
{
	HRESULT			hr;
	FD_SET			fdsRead;
	timeval			tv;
	int				iReturn;
#ifdef DBG
	DWORD			dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %u)", this, pUPnPDevice, dwTimeout);


	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED);
	DNASSERT(pUPnPDevice != NULL);
	DNASSERT(pUPnPDevice->IsConnected());
	DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);


	do
	{
		//
		// Create an FD_SET for the socket in question.
		//

		FD_ZERO(&fdsRead);
		FD_SET(pUPnPDevice->GetControlSocket(), &fdsRead);


		//
		// Wait for received data.
		//

		tv.tv_usec	= dwTimeout * 1000;
		tv.tv_sec	= 0;

		iReturn = this->m_pfnselect(0, &fdsRead, NULL, NULL, &tv);
		if (iReturn == SOCKET_ERROR)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Got sockets error %u trying to select on UPnP device sockets!",
				dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// If no sockets were selected, we're done.
		//
		if (iReturn == 0)
		{
			DPFX(DPFPREP, 7, "Timed out waiting for data on UPnP device 0x%p's socket.",
				pUPnPDevice);
			break;
		}


		DNASSERT(iReturn == 1);
		//DNASSERT(FD_ISSET(pUPnPDevice->GetControlSocket(), &fdsRead));
		DNASSERT(this->m_pfn__WSAFDIsSet(pUPnPDevice->GetControlSocket(), &fdsRead));


		hr = this->ReceiveUPnPDataStream(pUPnPDevice);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't receive UPnP stream from device object 0x%p!  Disconnecting.",
				pUPnPDevice);

			//
			// Dump this unusable UPnP device and continue.
			//
			if (pUPnPDevice->GetOwningDevice() != NULL)
			{
				this->ClearDevicesUPnPDevice(pUPnPDevice->GetOwningDevice());
			}
			else
			{
				DPFX(DPFPREP, 1, "UPnP device 0x%p's has already been removed from owning device.",
					pUPnPDevice);
			}

			break;
		}

		//
		// If the UPnP device is no longer connected, we're done.
		//
		if (! pUPnPDevice->IsConnected())
		{
			DPFX(DPFPREP, 7, "UPnP device 0x%p no longer connected.", pUPnPDevice);
			break;
		}
		

		//
		// We found data, so see if there's more.  Connection should be closed
		// after responses.
		//
		DPFX(DPFPREP, 7, "Waiting for more data on the UPnP device 0x%p's socket.", pUPnPDevice);
	}
	while (TRUE);


	//
	// If we're here, we're no worse for wear.
	//
	hr = DPNH_OK;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::CheckForReceivedUPnPMsgsOnDevice





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::HandleUPnPDiscoveryResponseMsg"
//=============================================================================
// CNATHelpUPnP::HandleUPnPDiscoveryResponseMsg
//-----------------------------------------------------------------------------
//
// Description:    Handles a UPnP discovery response message sent to this
//				control point.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice				- Pointer to device which received message.
//	SOCKADDR_IN * psaddrinSource	- Pointer to address that sent the response
//										message.
//	char * pcMsg					- Pointer to buffer containing the UPnP
//										message.  It will be modified.
//	int iMsgSize					- Size of message buffer in bytes.  There
//										must be an extra byte after the end of
//										the message.
//	BOOL * pfInitiatedConnect		- Pointer to boolean to set to TRUE if a
//										new UPnP device was found and a
//										connection to it was begun.
//
// Returns: HRESULT
//	DPNH_OK				- Message was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::HandleUPnPDiscoveryResponseMsg(CDevice * const pDevice,
													const SOCKADDR_IN * const psaddrinSource,
													char * const pcMsg,
													const int iMsgSize,
													BOOL * const pfInitiatedConnect)
{
	HRESULT				hr = DPNH_OK;
	char *				pszToken;
	UPNP_HEADER_INFO	HeaderInfo;
	SOCKADDR_IN			saddrinHost;
	char *				pszRelativePath;
	SOCKET				sTemp = INVALID_SOCKET;
	SOCKADDR_IN			saddrinLocal;
	CUPnPDevice *		pUPnPDevice = NULL;
	DWORD				dwError;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i, 0x%p)",
		this, pDevice, psaddrinSource, pcMsg, iMsgSize, pfInitiatedConnect);


#ifdef DBG
	//
	// Log the message.
	//
	this->PrintUPnPTransactionToFile(pcMsg,
									iMsgSize,
									"Inbound UPnP datagram headers",
									pDevice);
#endif // DBG


	//
	// Any errors we get while analyzing the message will cause us to jump to
	// the Exit label with hr == DPNH_OK.  Once we start trying to connect to
	// the UPnP device, that will change.  See below.
	//


	//
	// First of all, if this device already has a UPnP device, then we'll just
	// ignore this response.  Either it's a duplicate of an earlier response,
	// a cache-refresh, or it's from a different device.  Duplicates we should
	// ignore.  Cache-refresh is essentially a duplicate.  We can't handle any
	// information changes, so ignore those too.  And finally, we don't handle
	// multiple Internet gateway UPnP devices, so ignore those, too.
	//
	pUPnPDevice = pDevice->GetUPnPDevice();
	if (pUPnPDevice != NULL)
	{
		DPFX(DPFPREP, 6, "Already have UPnP device (0x%p) ignoring message.",
			pUPnPDevice);

		//
		// GetUPnPDevice did not add a reference to pUPnPDevice.
		//

		goto Exit;
	}

	//
	// Make sure the sender of this response is valid.  It should be either
	// the local device address, or the address of the gateway.  If we
	// broadcasted or multicasted, we'll need to be more lenient.  We'll just
	// ensure that the response came from someone local (it doesn't make sense
	// that in order to make mappings for our private network we would need to
	// contact something outside).
	//
	if (psaddrinSource->sin_addr.S_un.S_addr != pDevice->GetLocalAddressV4())
	{
		if (g_fUseMulticastUPnPDiscovery)
		{
			if (! this->IsAddressLocal(pDevice, psaddrinSource))
			{
				DPFX(DPFPREP, 1, "Multicast search responding device (%u.%u.%u.%u:%u) is not local, ignoring message.",
					psaddrinSource->sin_addr.S_un.S_un_b.s_b1,
					psaddrinSource->sin_addr.S_un.S_un_b.s_b2,
					psaddrinSource->sin_addr.S_un.S_un_b.s_b3,
					psaddrinSource->sin_addr.S_un.S_un_b.s_b4,
					NTOHS(psaddrinSource->sin_port));
				goto Exit;
			}
		}
		else
		{
			//
			// Retrieve the gateway's address (using saddrinHost as a temporary
			// variable.  If that fails or returns the broadcast address, just
			// make sure the address is local.  Otherwise, expect an exact
			// match.
			//
			if ((! this->GetAddressToReachGateway(pDevice, &saddrinHost.sin_addr)) ||
				(saddrinHost.sin_addr.S_un.S_addr == INADDR_BROADCAST))
			{
				if (! this->IsAddressLocal(pDevice, psaddrinSource))
				{
					DPFX(DPFPREP, 1, "No gateway/broadcast search responding device (%u.%u.%u.%u:%u) is not local, ignoring message.",
						psaddrinSource->sin_addr.S_un.S_un_b.s_b1,
						psaddrinSource->sin_addr.S_un.S_un_b.s_b2,
						psaddrinSource->sin_addr.S_un.S_un_b.s_b3,
						psaddrinSource->sin_addr.S_un.S_un_b.s_b4,
						NTOHS(psaddrinSource->sin_port));
					goto Exit;
				}
			}
			else
			{
				if (psaddrinSource->sin_addr.S_un.S_addr != saddrinHost.sin_addr.S_un.S_addr)
				{
					DPFX(DPFPREP, 1, "Unicast search responding device (%u.%u.%u.%u:%u) is not gateway (%u.%u.%u.%u), ignoring message.",
						psaddrinSource->sin_addr.S_un.S_un_b.s_b1,
						psaddrinSource->sin_addr.S_un.S_un_b.s_b2,
						psaddrinSource->sin_addr.S_un.S_un_b.s_b3,
						psaddrinSource->sin_addr.S_un.S_un_b.s_b4,
						NTOHS(psaddrinSource->sin_port),
						saddrinHost.sin_addr.S_un.S_un_b.s_b1,
						saddrinHost.sin_addr.S_un.S_un_b.s_b2,
						saddrinHost.sin_addr.S_un.S_un_b.s_b3,
						saddrinHost.sin_addr.S_un.S_un_b.s_b4);
					goto Exit;
				}
			}
		} // end else (not multicasting search)
	}
	else
	{
		//
		// Response was from the local device.
		//
	}


	//
	// Ensure the buffer is NULL terminated to prevent buffer overruns when
	// using the string routines.
	//
	pcMsg[iMsgSize] = '\0';



	//
	// Find the version string.
	//
	pszToken = strtok(pcMsg, " \t\n");
	if (pszToken == NULL)
	{
		DPFX(DPFPREP, 9, "Could not locate first white-space separator.");
		goto Exit;
	}


	//
	// Check the version string, case insensitive.
	//
	if ((_stricmp(pszToken, HTTP_VERSION) != 0) &&
		(_stricmp(pszToken, HTTP_VERSION_ALT) != 0))
	{
		DPFX(DPFPREP, 1, "The version specified in the response message is not \"" HTTP_VERSION "\" or \"" HTTP_VERSION_ALT "\" (it's \"%hs\").",
			pszToken);
		goto Exit;
	}


	//
	// Find the response code string.
	//
	pszToken = strtok(NULL, " ");
	if (pszToken == NULL)
	{
		DPFX(DPFPREP, 1, "Could not find the response code space.");
		goto Exit;
	}

	//
	// Make sure it's the success result, case insensitive.
	//
	if (_stricmp(pszToken, "200") != 0)
	{
		DPFX(DPFPREP, 1, "The response code specified is not \"200\" (it's \"%hs\").",
			pszToken);
		goto Exit;
	}


	//
	// Find the response code message.
	//
	pszToken = strtok(NULL, " \t\r");
	if (pszToken == NULL)
	{
		DPFX(DPFPREP, 9, "Could not locate response code message white-space separator.");
		goto Exit;
	}

	//
	// Make sure it's the right string, case insensitive.
	//
	if (_stricmp(pszToken, "OK") != 0)
	{
		DPFX(DPFPREP, 1, "The response code message specified is not \"OK\" (it's \"%hs\").",
			pszToken);
		goto Exit;
	}


	//
	// Parse the header information.
	//
	ZeroMemory(&HeaderInfo, sizeof(HeaderInfo));
	this->ParseUPnPHeaders((pszToken + strlen(pszToken) + 1),
							&HeaderInfo);


	//
	// Skip responses which don't include the required headers.
	//
	if ((HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CACHECONTROL] == NULL) ||
		(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_EXT] == NULL) ||
		(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_LOCATION] == NULL) ||
		(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_SERVER] == NULL) ||
		(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_ST] == NULL) ||
		(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_USN] == NULL))
	{
		DPFX(DPFPREP, 1, "One of the expected headers was not specified, ignoring message.");
		goto Exit;
	}


	//
	// Make sure the service type is correct.
	//
	if ((_stricmp(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_ST], URI_SERVICE_WANIPCONNECTION_A) != 0) &&
		(_stricmp(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_ST], URI_SERVICE_WANPPPCONNECTION_A) != 0))
	{
		DPFX(DPFPREP, 1, "Service type \"%hs\" is not desired \"" URI_SERVICE_WANIPCONNECTION_A "\" or \"" URI_SERVICE_WANPPPCONNECTION_A "\", ignoring message.",
			HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_ST]);
		goto Exit;
	}


	//
	// Parse the location header into an address and port.
	//
	hr = this->GetAddressFromURL(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_LOCATION],
								&saddrinHost,
								&pszRelativePath);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't get address from URL (err = 0x%lx), ignoring message.",
			hr);
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// Don't accept responses that refer to addresses other than the one that
	// sent this response.
	//
	if (psaddrinSource->sin_addr.S_un.S_addr != saddrinHost.sin_addr.S_un.S_addr)
	{
		DPFX(DPFPREP, 1, "Host IP address designated (%u.%u.%u.%u:%u) is not the same as source of response (%u.%u.%u.%u:%u), ignoring message.",
			saddrinHost.sin_addr.S_un.S_un_b.s_b1,
			saddrinHost.sin_addr.S_un.S_un_b.s_b2,
			saddrinHost.sin_addr.S_un.S_un_b.s_b3,
			saddrinHost.sin_addr.S_un.S_un_b.s_b4,
			NTOHS(saddrinHost.sin_port),
			psaddrinSource->sin_addr.S_un.S_un_b.s_b1,
			psaddrinSource->sin_addr.S_un.S_un_b.s_b2,
			psaddrinSource->sin_addr.S_un.S_un_b.s_b3,
			psaddrinSource->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(psaddrinSource->sin_port));
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// Don't accept responses that refer to ports in the reserved range (less
	// than or equal to 1024), other than the standard HTTP port.
	//
	if ((NTOHS(saddrinHost.sin_port) <= MAX_RESERVED_PORT) &&
		(saddrinHost.sin_port != HTONS(HTTP_PORT)))
	{
		DPFX(DPFPREP, 1, "Host address designated invalid port %u, ignoring message.",
			NTOHS(saddrinHost.sin_port));
		hr = DPNH_OK;
		goto Exit;
	}

	
	//
	// Any errors we get from here on out will cause us to jump to the Failure
	// label, instead of going straight to Exit.
	//


	//
	// Create a socket to connect to that address.
	//

	ZeroMemory(&saddrinLocal, sizeof(saddrinLocal));
	saddrinLocal.sin_family				= AF_INET;
	saddrinLocal.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

	sTemp = this->CreateSocket(&saddrinLocal, SOCK_STREAM, 0);
	if (sTemp == INVALID_SOCKET)
	{
		DPFX(DPFPREP, 0, "Couldn't create stream socket!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Initiate the connection to the UPnP device.  It is expected that connect
	// will return WSAEWOULDBLOCK.
	//
	if (this->m_pfnconnect(sTemp,
							(SOCKADDR*) (&saddrinHost),
							sizeof(saddrinHost)) != 0)
	{
		dwError = this->m_pfnWSAGetLastError();

		if (dwError != WSAEWOULDBLOCK)
		{
#ifdef DBG
			DPFX(DPFPREP, 0, "Couldn't connect socket, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}
	}
	else
	{
		//
		// connect() on non-blocking sockets is explicitly documented as
		// always returning WSAEWOULDBLOCK, but CE seems to do it anyway.
		//
		DPFX(DPFPREP, 8, "Socket connected right away.");
	}


	//
	// Create a new object to represent the UPnP device to which we're trying
	// to connect.
	//
	pUPnPDevice = new CUPnPDevice(this->m_dwCurrentUPnPDeviceID++);
	if (pUPnPDevice == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	hr = pUPnPDevice->SetLocationURL(pszRelativePath);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set UPnP device's location URL!");
		goto Failure;
	}

	pUPnPDevice->SetHostAddress(&saddrinHost);

	hr = pUPnPDevice->SetUSN(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_USN]);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set UPnP device's USN!");
		goto Failure;
	}

	hr = pUPnPDevice->CreateReceiveBuffer(UPNP_STREAM_RECV_BUFFER_INITIAL_SIZE);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create UPnP device's receive buffer!");
		goto Failure;
	}


	DPFX(DPFPREP, 7, "Created new UPnP device object 0x%p ID %u.",
		pUPnPDevice, pUPnPDevice->GetID());


	//
	// It's connecting...
	//
	pUPnPDevice->NoteConnecting();


	//
	// See if we need to avoid trying asymmetric port mappings.
	//
	if (g_fNoAsymmetricMappings)
	{
		DPFX(DPFPREP, 1, "Preventing asymmetric port mappings on new UPnP device 0x%p.",
			pUPnPDevice);
		pUPnPDevice->NoteDoesNotSupportAsymmetricMappings();
	}


	//
	// Transfer ownership of the socket to the object.
	//
	pUPnPDevice->SetControlSocket(sTemp);


	//
	// Associate it with the device.
	//
	pUPnPDevice->MakeDeviceOwner(pDevice);

	//
	// Add it to the global list, and transfer ownership of the reference.
	//
	pUPnPDevice->m_blList.InsertBefore(&this->m_blUPnPDevices);
	pUPnPDevice = NULL;


	//
	// Inform the caller that there's a new connection pending.
	//
	(*pfInitiatedConnect) = TRUE;


	//
	// Clear the device's discovery flags, now that we have a device, we're not
	// going to be searching anymore.
	//
	pDevice->NoteNotPerformingRemoteUPnPDiscovery();
	pDevice->NoteNotPerformingLocalUPnPDiscovery();


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pUPnPDevice != NULL)
	{
		//pUPnPDevice->DestroyReceiveBuffer();
		pUPnPDevice->ClearUSN();
		pUPnPDevice->ClearLocationURL();

		pUPnPDevice->DecRef();
	}

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	goto Exit;
} // CNATHelpUPnP::HandleUPnPDiscoveryResponseMsg





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ReconnectUPnPControlSocket"
//=============================================================================
// CNATHelpUPnP::ReconnectUPnPControlSocket
//-----------------------------------------------------------------------------
//
// Description:    Re-establishes a UPnP device TCP/IP connection.
//
//				   UPnP devices may get removed from list if a failure occurs.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device to reconnect.
//
// Returns: HRESULT
//	DPNH_OK				- Message was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::ReconnectUPnPControlSocket(CUPnPDevice * const pUPnPDevice)
{
	HRESULT			hr = DPNH_OK;
	SOCKET			sTemp = INVALID_SOCKET;
	CDevice *		pDevice;
	SOCKADDR_IN		saddrinLocal;
	DWORD			dwError;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pUPnPDevice);


	DNASSERT(pUPnPDevice->GetControlSocket() == INVALID_SOCKET);


	//
	// Create a socket to connect to that address.
	//

	pDevice = pUPnPDevice->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	ZeroMemory(&saddrinLocal, sizeof(saddrinLocal));
	saddrinLocal.sin_family				= AF_INET;
	saddrinLocal.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

	sTemp = this->CreateSocket(&saddrinLocal, SOCK_STREAM, 0);
	if (sTemp == INVALID_SOCKET)
	{
		DPFX(DPFPREP, 0, "Couldn't create stream socket!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Initiate the connection to the UPnP device.  It is expected that connect
	// will return WSAEWOULDBLOCK.
	//
	if (this->m_pfnconnect(sTemp,
							(SOCKADDR*) (pUPnPDevice->GetControlAddress()),
							sizeof(SOCKADDR_IN)) != 0)
	{
		dwError = this->m_pfnWSAGetLastError();

		if (dwError != WSAEWOULDBLOCK)
		{
#ifdef DBG
			DPFX(DPFPREP, 0, "Couldn't connect socket, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}
	}
	else
	{
		//
		// connect() on non-blocking sockets is explicitly documented as
		// always returning WSAEWOULDBLOCK, but CE seems to do it anyway.
		//
		DPFX(DPFPREP, 8, "Socket connected right away.");
	}


	//
	// It's reconnecting...
	//
	pUPnPDevice->NoteConnecting();


	//
	// Transfer ownership of the socket to the object.
	//
	pUPnPDevice->SetControlSocket(sTemp);
	sTemp = INVALID_SOCKET;


	//
	// Wait for the connect to complete.
	//
	hr = this->WaitForUPnPConnectCompletions();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't wait for UPnP connect completions!");
		goto Failure;
	}

	//
	// Make sure the connect completed successfully.
	//
	if (! pUPnPDevice->IsConnected())
	{
		DPFX(DPFPREP, 0, "UPnP device 0x%p failed reconnecting!", pUPnPDevice);

		//
		// Note that the device is cleaned up and is not in any lists anymore.
		//
		hr = DPNHERR_SERVERNOTRESPONDING;
		goto Exit;
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	goto Exit;
} // CNATHelpUPnP::ReconnectUPnPControlSocket





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ReceiveUPnPDataStream"
//=============================================================================
// CNATHelpUPnP::ReceiveUPnPDataStream
//-----------------------------------------------------------------------------
//
// Description:    Receives incoming data from a UPnP TCP connection.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device with data to receive.
//
// Returns: HRESULT
//	DPNH_OK				- Data was received successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::ReceiveUPnPDataStream(CUPnPDevice * const pUPnPDevice)
{
	HRESULT				hr = DPNH_OK;
	char *				pszDeChunkedBuffer = NULL;
	int					iReturn;
	DWORD				dwError;
	char *				pszCurrent;
	char *				pszEndOfBuffer;
	UPNP_HEADER_INFO	HeaderInfo;
	DWORD				dwContentLength;
	char *				pszToken;
	DWORD				dwHTTPResponseCode;
	int					iHeaderLength;
	DWORD				dwBufferRemaining;
	char *				pszChunkData;
	DWORD				dwChunkSize;
	char *				pszDestination;
#ifdef DBG
	char *				pszPrintIfFailed = NULL;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pUPnPDevice);

	
	do
	{
		//
		// Make sure there's room in the buffer to actually get the data.
		//
		if (pUPnPDevice->GetRemainingReceiveBufferSize() == 0)
		{
			DPFX(DPFPREP, 7, "Increasing receive buffer size prior to receiving.");

			hr = pUPnPDevice->IncreaseReceiveBufferSize();
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't increase receive buffer size prior to receiving!");
				goto Failure;
			}
		}


		//
		// Actually get the data that was indicated.
		//

		iReturn = this->m_pfnrecv(pUPnPDevice->GetControlSocket(),
								pUPnPDevice->GetCurrentReceiveBufferPtr(),
								pUPnPDevice->GetRemainingReceiveBufferSize(),
								0);
		switch (iReturn)
		{
			case 0:
			{
				//
				// Since the connection has been broken, shutdown the socket.
				//
				this->m_pfnshutdown(pUPnPDevice->GetControlSocket(), 0); // ignore error
				this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
				pUPnPDevice->SetControlSocket(INVALID_SOCKET);


				//
				// Mark the socket as not connected.
				//
				pUPnPDevice->NoteNotConnected();

				
				//
				// There may have been HTTP success/error information sent
				// before the connection was closed.
				//
				if (pUPnPDevice->GetUsedReceiveBufferSize() == 0)
				{
					DPFX(DPFPREP, 3, "UPnP device 0x%p shut down connection (no more data).",
						pUPnPDevice);

					//
					// Hopefully we got what we needed, but we're done now.
					//
					goto Exit;
				}


				DPFX(DPFPREP, 3, "UPnP device 0x%p gracefully closed connection after sending data.",
					pUPnPDevice);


				//
				// Continue through and parse what data we have.
				//
				break;
			}

			case SOCKET_ERROR:
			{
				dwError = this->m_pfnWSAGetLastError();
				switch (dwError)
				{
					case WSAEMSGSIZE:
					{
						//
						// There's not enough room in the buffer.  Double the
						// buffer and try again.
						//

						DPFX(DPFPREP, 7, "Increasing receive buffer size after WSAEMSGSIZE error.");

						hr = pUPnPDevice->IncreaseReceiveBufferSize();
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't increase receive buffer size!");
							goto Failure;
						}

						break;
					}

					case WSAECONNABORTED:
					case WSAECONNRESET:
					{
						DPFX(DPFPREP, 1, "UPnP device shutdown connection (err = %u).", dwError);

						//
						// Our caller should remove this device.
						//

						hr = DPNHERR_GENERIC;
						goto Failure;
						break;
					}

					case WSAENOBUFS:
					{
						DPFX(DPFPREP, 0, "WinSock returned WSAENOBUFS while receiving!");

						//
						// Our caller should remove this device.
						//

						hr = DPNHERR_OUTOFMEMORY;
						goto Failure;
						break;
					}

					default:
					{
						DPFX(DPFPREP, 0, "Got unknown sockets error %u while receiving data!", dwError);
						hr = DPNHERR_GENERIC;
						goto Failure;
						break;
					}
				}
				break;
			}

			default:
			{
				DPFX(DPFPREP, 2, "Received %i bytes of data from UPnP device 0%p.",
					iReturn, pUPnPDevice);

				pUPnPDevice->UpdateUsedReceiveBufferSize(iReturn);

				//
				// We'll also break out of the do-while loop below.
				//
				break;
			}
		}
	}
	while (iReturn == SOCKET_ERROR);


	//
	// If we're here, we've gotten the data that has currently arrived.
	//

	//
	// If we have all the headers, specifically the content length header, we
	// can tell whether we have the whole message or not.  If not, we can't do
	// anything until the rest of the data comes in.
	//
	if (pUPnPDevice->IsWaitingForContent())
	{
		dwContentLength = pUPnPDevice->GetExpectedContentSize();

		if (dwContentLength == -1)
		{
			//
			// We have all the headers, but a faulty server implementation did
			// not send a content-length header.  We're going to wait until the
			// socket is closed by the other side, and then consider all of the
			// data received at that time to be the content.  NOTE: It is
			// expected that there will be a higher level timeout preventing us
			// from waiting forever.
			//
			// So if the device is still connected, keep waiting.
			//
			// If we're using chunked transfer we won't get a content-length
			// header or a total size legitimately.  We will know the sizes of
			// individual chunks, but that doesn't help us much.  We basically
			// need to scan for the "last chunk" indicator (or socket
			// shutdown).
			//
			if (pUPnPDevice->IsConnected())
			{
				//
				// If we're using chunked transfer, see if we have enough
				// information already to determine if we're done.
				//
				if (pUPnPDevice->IsUsingChunkedTransferEncoding())
				{
					//
					// Walk all of the chunks we have so far to see if we have
					// the last one (the zero terminator).
					//
					pszCurrent = pUPnPDevice->GetReceiveBufferStart();
					dwBufferRemaining = pUPnPDevice->GetUsedReceiveBufferSize();
					do
					{
						if (! this->GetNextChunk(pszCurrent,
												dwBufferRemaining,
												&pszChunkData,
												&dwChunkSize,
												&pszCurrent,
												&dwBufferRemaining))
						{
							DPFX(DPFPREP, 1, "Body contains invalid chunk (at offset %u)!  Disconnecting.",
								(DWORD_PTR) (pszCurrent - pUPnPDevice->GetReceiveBufferStart()));
							goto Failure;
						}

						if (pszChunkData == NULL)
						{
							DPFX(DPFPREP, 1, "Did not receive end of chunked data (%u bytes received so far), continuing to waiting for data.",
								pUPnPDevice->GetUsedReceiveBufferSize());
							goto Exit;
						}
					}
					while (dwChunkSize != 0);
				}
				else
				{
					DPFX(DPFPREP, 1, "Waiting for connection to be shutdown (%u bytes received).",
						pUPnPDevice->GetUsedReceiveBufferSize());
					goto Exit;
				}
			}


			DPFX(DPFPREP, 1, "Socket closed with %u bytes received, parsing.",
				pUPnPDevice->GetUsedReceiveBufferSize());
		}
		else
		{
			if (dwContentLength > pUPnPDevice->GetUsedReceiveBufferSize())
			{
				//
				// We still haven't received all the data yet.  Keep waiting
				// (unless the socket is closed).
				//
				if (pUPnPDevice->IsConnected())
				{
					DPFX(DPFPREP, 1, "Still waiting for all content (%u bytes of %u total received).",
						pUPnPDevice->GetUsedReceiveBufferSize(), dwContentLength);
					goto Exit;
				}

				DPFX(DPFPREP, 1, "Socket closed before all content received (%u bytes of %u total), parsing anyway.",
					pUPnPDevice->GetUsedReceiveBufferSize(), dwContentLength);

				//
				// Try parsing it anyway.
				//
			}
		}


		//
		// Retrieve the HTTP response code stored earlier.
		//
		dwHTTPResponseCode = pUPnPDevice->GetHTTPResponseCode();


		//
		// All of the content that's going to arrive, has.
		//
		pUPnPDevice->NoteNotWaitingForContent();


		//
		// Make sure the buffer is NULL terminated.  But first ensure the
		// buffer can hold a new NULL termination character.
		//
		if (pUPnPDevice->GetRemainingReceiveBufferSize() == 0)
		{
			DPFX(DPFPREP, 7, "Increasing receive buffer size to hold NULL termination (for content).");

			hr = pUPnPDevice->IncreaseReceiveBufferSize();
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't increase receive buffer size to accommodate NULL termination (for content)!");
				goto Failure;
			}
		}


		//
		// Move to the end of the buffer and NULL terminate it for string ops.
		//
		pszEndOfBuffer = pUPnPDevice->GetReceiveBufferStart()
						+ pUPnPDevice->GetUsedReceiveBufferSize();
		(*pszEndOfBuffer) = '\0';


#ifdef DBG
		//
		// Print from the start of the buffer if we fail.
		//
		pszPrintIfFailed = pUPnPDevice->GetReceiveBufferStart();
#endif // DBG


		//
		// We now have all the data in a string buffer.  Continue...
		//
	}
	else
	{
		//
		// We haven't already received the headers.  The data we just got
		// should be those headers.
		//
		pszCurrent = pUPnPDevice->GetReceiveBufferStart();

		//
		// Quick check to make sure the buffer starts with something reasonable
		// in hopes of catching completely bogus responses earlier.  Note that
		// the buffer is not necessarily NULL terminated or completely
		// available yet.
		//
		if ((pUPnPDevice->GetUsedReceiveBufferSize() >= strlen(HTTP_PREFIX)) &&
			(_strnicmp(pszCurrent, HTTP_PREFIX, strlen(HTTP_PREFIX)) != 0))
		{
			DPFX(DPFPREP, 1, "Headers do not begin with \"" HTTP_PREFIX "\"!  Disconnecting.");
			goto Failure;
		}

		//
		// We don't want to walk off the end of the buffer, so only search up
		// to the last possible location for the sequence, which is the end of
		// the buffer minus the double EOL sequence.
		//
		pszEndOfBuffer = pszCurrent
						+ pUPnPDevice->GetUsedReceiveBufferSize()
						- strlen(EOL EOL);
		while (pszCurrent < pszEndOfBuffer)
		{
			if (_strnicmp(pszCurrent, EOL EOL, strlen(EOL EOL)) == 0)
			{
				//
				// Found end of headers.
				//

				//
				// Possible loss of data on 64-bit is okay, we're just saving
				// this for logging purposes.
				//
				iHeaderLength = (int) ((INT_PTR) (pszCurrent - pUPnPDevice->GetReceiveBufferStart()));
				break;
			}

			pszCurrent++;
		}

		//
		// If we didn't find the end of the headers, we're done (for now).
		//
		if (pszCurrent >= pszEndOfBuffer)
		{
			//
			// We still haven't received all the data yet.  Keep waiting
			// (unless the socket is closed).
			//
			if (pUPnPDevice->IsConnected())
			{
				//
				// Make sure the length is still within reason.
				//
				if (pUPnPDevice->GetUsedReceiveBufferSize() > MAX_UPNP_HEADER_LENGTH)
				{
					DPFX(DPFPREP, 1, "Headers are too large (%u > %u)!  Disconnecting.",
						pUPnPDevice->GetUsedReceiveBufferSize(), MAX_UPNP_HEADER_LENGTH);
					goto Failure;
				}
				
				DPFX(DPFPREP, 1, "Have not detected end of headers yet (%u bytes received).",
					pUPnPDevice->GetUsedReceiveBufferSize());
				goto Exit;
			}

			DPFX(DPFPREP, 1, "Socket closed before end of headers detected (%u bytes received), parsing anyway.",
				pUPnPDevice->GetUsedReceiveBufferSize());


			//
			// Consider the whole buffer the headers length.
			//
			iHeaderLength = pUPnPDevice->GetUsedReceiveBufferSize();


			//
			// Try parsing it anyway.
			//
		}


#ifdef DBG
		//
		// Log the headers.
		//
		this->PrintUPnPTransactionToFile(pUPnPDevice->GetReceiveBufferStart(),
										iHeaderLength,
										"Inbound UPnP stream headers",
										pUPnPDevice->GetOwningDevice());
#endif // DBG


		//
		// Make sure the buffer is NULL terminated.  But first ensure the
		// buffer can hold a new NULL termination character.
		//
		if (pUPnPDevice->GetRemainingReceiveBufferSize() == 0)
		{
			DPFX(DPFPREP, 7, "Increasing receive buffer size to hold NULL termination (for headers).");

			hr = pUPnPDevice->IncreaseReceiveBufferSize();
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't increase receive buffer size to accommodate NULL termination (for headers)!");
				goto Failure;
			}

			//
			// Find the end of the new buffer, and make sure it's NULL
			// terminated for string ops.
			//
			pszEndOfBuffer = pUPnPDevice->GetReceiveBufferStart()
							+ pUPnPDevice->GetUsedReceiveBufferSize();
		}
		else
		{
			//
			// Move to the end of the buffer and NULL terminate it for string
			// ops.
			//
			pszEndOfBuffer += strlen(EOL EOL);
		}

		(*pszEndOfBuffer) = '\0';



		//
		// Make sure the buffer is a valid response.  Find the version string.
		//
		pszToken = strtok(pUPnPDevice->GetReceiveBufferStart(), " \t\n");
		if (pszToken == NULL)
		{
			DPFX(DPFPREP, 1, "Could not locate first white-space separator!  Disconnecting.");
			goto Failure;
		}


		//
		// Check the version string, case insensitive.
		//
		if ((_stricmp(pszToken, HTTP_VERSION) != 0) &&
			(_stricmp(pszToken, HTTP_VERSION_ALT) != 0))
		{
			DPFX(DPFPREP, 1, "The version specified in the response message is not \"" HTTP_VERSION "\" or \"" HTTP_VERSION_ALT "\" (it's \"%hs\")!  Disconnecting.",
				pszToken);
			goto Failure;
		}


		//
		// Find the response code number string.
		//
		pszToken = strtok(NULL, " ");
		if (pszToken == NULL)
		{
			DPFX(DPFPREP, 1, "Could not find the response code number space!  Disconnecting.");
			goto Failure;
		}


		//
		// Retrieve the success/failure code value.
		//
		dwHTTPResponseCode = atoi(pszToken);


		//
		// Find the response code message.
		//
		pszToken = strtok(NULL, "\t\r");
		if (pszToken == NULL)
		{
			DPFX(DPFPREP, 1, "Could not locate response code message white-space separator!  Disconnecting.");
			goto Failure;
		}


		DPFX(DPFPREP, 1, "Received HTTP response %u \"%hs\".",
			dwHTTPResponseCode, pszToken);


		
		//
		// Try parsing the headers (after the response status line).
		//
		ZeroMemory(&HeaderInfo, sizeof(HeaderInfo));
		this->ParseUPnPHeaders((pszToken + strlen(pszToken) + 1),
								&HeaderInfo);


#ifdef DBG
		//
		// Print from the start of the message body if we fail.
		//
		pszPrintIfFailed = HeaderInfo.pszMsgBody;
#endif // DBG


		if ((HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_TRANSFERENCODING] != NULL) &&
			(_strnicmp(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_TRANSFERENCODING], "chunked", strlen("chunked")) == 0))
		{
			pUPnPDevice->NoteUsingChunkedTransferEncoding();
		}


		//
		// We're pretty lenient about missing headers...
		//
		if (HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTLENGTH] == NULL)
		{
			DPFX(DPFPREP, 1, "Content-length header was not specified in response (chunked = %i).",
				pUPnPDevice->IsUsingChunkedTransferEncoding());

			//
			// May be because we're using chunked transfer encoding, or it
			// could be a bad device.  Either way, we'll continue...
			//
			dwContentLength = -1;
		}
		else
		{
			dwContentLength = atoi(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTLENGTH]);
#ifdef DBG
			if (dwContentLength == 0)
			{
				DPFX(DPFPREP, 1, "Content length (\"%hs\") is zero.",
					HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTLENGTH]);
			}
#endif // DBG


			if (HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTTYPE] == NULL)
			{
				DPFX(DPFPREP, 1, "Expected content-type header was not specified in response, continuing.");
			}
			else
			{
				if (_strnicmp(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTTYPE], "text/xml", strlen("text/xml")) != 0)
				{
					DPFX(DPFPREP, 1, "Content type does not start with \"text/xml\" (it's \"%hs\")!  Disconnecting.",
						HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTTYPE]);
					goto Failure;
				}


#ifdef DBG
				//
				// Note whether the content type is qualified with
				// "charset=utf-8" or not.
				//
				if (_stricmp(HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTTYPE], "text/xml; charset=\"utf-8\"") != 0)
				{
					DPFX(DPFPREP, 1, "Content type is xml, but it's not \"text/xml; charset=\"utf-8\"\" (it's \"%hs\"), continuing.",
						HeaderInfo.apszHeaderStrings[RESPONSEHEADERINDEX_CONTENTTYPE]);

					//
					// The check was just for information purposes, continue.
					//
				}
#endif // DBG
			}
		}


		//
		// Content length may be valid, or the special value -1 at this
		// point.
		//


		DPFX(DPFPREP, 7, "Moving past 0x%p bytes of header.",
			HeaderInfo.pszMsgBody - pUPnPDevice->GetReceiveBufferStart());


		//
		// Forget about all the headers, we only care about data now.
		//
		pUPnPDevice->UpdateReceiveBufferStart(HeaderInfo.pszMsgBody);


		//
		// The buffer has been destroyed up to the end of the headers (meaning
		// that calling ParseUPnPHeaders won't work on the same buffer again),
		// so if we don't have all the content yet, we need to save the
		// response code, remember the fact that we're not done yet, and
		// continue waiting for the rest of the data.
		// Of course, if there wasn't a content-length header, we have to wait
		// for the socket to shutdown before we can parse.
		//
		// Also, if we're using chunked transfer we won't get a content-length
		// header or a total size legitimately.  We will know the sizes of
		// individual chunks, but that doesn't help us much.  We basically need
		// to scan for the "last chunk" indicator (or socket shutdown).
		//
		if (dwContentLength == -1)
		{
			if (pUPnPDevice->IsConnected())
			{
				//
				// If we're using chunked transfer, see if we have enough
				// information already to determine if we're done.
				//
				if (pUPnPDevice->IsUsingChunkedTransferEncoding())
				{
					//
					// Walk all of the chunks we have so far to see if we have
					// the last one (the zero terminator).
					//
					pszCurrent = pUPnPDevice->GetReceiveBufferStart();
					dwBufferRemaining = pUPnPDevice->GetUsedReceiveBufferSize();
					do
					{
						if (! this->GetNextChunk(pszCurrent,
												dwBufferRemaining,
												&pszChunkData,
												&dwChunkSize,
												&pszCurrent,
												&dwBufferRemaining))
						{
							DPFX(DPFPREP, 1, "Body contains invalid chunk (at offset %u)!  Disconnecting.",
								(DWORD_PTR) (pszCurrent - pUPnPDevice->GetReceiveBufferStart()));
							goto Failure;
						}

						if (pszChunkData == NULL)
						{
							DPFX(DPFPREP, 1, "Did not receive end of chunked data (%u bytes received so far), continuing to waiting for data.",
								pUPnPDevice->GetUsedReceiveBufferSize());

							pUPnPDevice->NoteWaitingForContent(dwContentLength, dwHTTPResponseCode);

							goto Exit;
						}
					}
					while (dwChunkSize != 0);
				}
				else
				{
					DPFX(DPFPREP, 1, "Unknown content length (%u bytes received so far), waiting for connection to close before parsing.",
						pUPnPDevice->GetUsedReceiveBufferSize());

					pUPnPDevice->NoteWaitingForContent(dwContentLength, dwHTTPResponseCode);

					goto Exit;
				}
			}
		}
		else
		{
			if ((pUPnPDevice->IsConnected()) &&
				(dwContentLength > pUPnPDevice->GetUsedReceiveBufferSize()))
			{
				DPFX(DPFPREP, 1, "Not all content has been received (%u bytes of %u total), waiting for remainder of message.",
					pUPnPDevice->GetUsedReceiveBufferSize(), dwContentLength);

				pUPnPDevice->NoteWaitingForContent(dwContentLength, dwHTTPResponseCode);

				goto Exit;
			}
		}


		//
		// We have all the data already (and it's in string form).
		// Continue...
		//
	}


	//
	// If we got here, it means we have all the data that we're expecting.
	// Shutdown the socket if it hasn't been already.
	//
	if (pUPnPDevice->IsConnected())
	{
		DPFX(DPFPREP, 7, "Forcing UPnP device 0x%p socket disconnection.",
			pUPnPDevice);

		DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);

		this->m_pfnshutdown(pUPnPDevice->GetControlSocket(), 0); // ignore error
		this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
		pUPnPDevice->SetControlSocket(INVALID_SOCKET);

		pUPnPDevice->NoteNotConnected();
	}
	else
	{
		DNASSERT(pUPnPDevice->GetControlSocket() == INVALID_SOCKET);
	}


	//
	// If the sender used chunked-transfer encoding, copy each of the chunks
	// into a contiguous "dechunked" buffer.
	//
	if (pUPnPDevice->IsUsingChunkedTransferEncoding())
	{
		//
		// Prepare a dechunked buffer.
		//
		pszDeChunkedBuffer = (char*) DNMalloc(pUPnPDevice->GetUsedReceiveBufferSize());
		if (pszDeChunkedBuffer == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		pszDestination = pszDeChunkedBuffer;


		//
		// Walk all of the chunks.
		//
		pszCurrent = pUPnPDevice->GetReceiveBufferStart();
		dwBufferRemaining = pUPnPDevice->GetUsedReceiveBufferSize();
		do
		{
			if (! this->GetNextChunk(pszCurrent,
									dwBufferRemaining,
									&pszChunkData,
									&dwChunkSize,
									&pszCurrent,
									&dwBufferRemaining))
			{
				DPFX(DPFPREP, 1, "Body contains invalid chunk (at offset %u)!",
					(DWORD_PTR) (pszCurrent - pUPnPDevice->GetReceiveBufferStart()));
				goto Failure;
			}

			//
			// If this chunk is unfinished, bail.
			//
			if (pszChunkData == NULL)
			{
				DPFX(DPFPREP, 1, "Did not receive complete chunked data!",
					pUPnPDevice->GetUsedReceiveBufferSize());
				goto Failure;
			}

			//
			// If this is the last chunk, terminate the string here and stop.
			//
			if (dwChunkSize == 0)
			{
				(*pszDestination) = '\0';
				break;
			}

			//
			// Otherwise copy the chunk data to the dechunked buffer.
			//
			memcpy(pszDestination, pszChunkData, dwChunkSize);
			pszDestination += dwChunkSize;
		}
		while (TRUE);

		//
		// Turn off the flag since it's no longer relevant.
		//
		pUPnPDevice->NoteNotUsingChunkedTransferEncoding();

		//
		// Parse the dechunked version of the message.
		//
		pszCurrent = pszDeChunkedBuffer;
	}
	else
	{
		//
		// Get a pointer to the start of the message body.
		//
		pszCurrent = pUPnPDevice->GetReceiveBufferStart();
	}


	//
	// Clear the buffer for the next message.  Note that this does not
	// invalidate the pszMessageBody pointer we just retrieved because
	// ClearReceiveBuffer just resets the pointers back to the beginning (it
	// does not zero out the buffer).  We need to reset the buffer because the
	// handler we're about to call may try to receive data as well.  The buffer
	// must be "empty" (reset) at that time.  Of course, if the handler does do
	// that, then it had better have saved off copies of any strings it needs
	// because they will get overwritten once receiving starts.
	//
	// Content length of -1 means we never detected a valid CONTENT-LENGTH
	// header, so we will assume the rest of the data that has been received up
	// to now is (all of) the content.
	//

#ifdef DBG
	if ((dwContentLength != -1) &&
		(dwContentLength < pUPnPDevice->GetUsedReceiveBufferSize()))
	{
		//
		// The string was terminated before this data, so the handler will
		// never even see it.
		//
		DPFX(DPFPREP, 1, "Ignoring %u bytes of extra data after response from UPnP device 0x%p.",
			(pUPnPDevice->GetUsedReceiveBufferSize() - dwContentLength),
			pUPnPDevice);
	}

	//
	// HandleUPnPControlResponseBody or HandleUPnPDescriptionResponseBody might
	// print out the body or overwrite the data, so we can't print it out if
	// they fail.
	//
	pszPrintIfFailed = NULL;
#endif // DBG

	pUPnPDevice->ClearReceiveBuffer();



	if (pUPnPDevice->IsWaitingForControlResponse())
	{
		//
		// It looks like it's a control response, because someone is waiting
		// for one.
		//
		hr = this->HandleUPnPControlResponseBody(pUPnPDevice,
												dwHTTPResponseCode,
												pszCurrent);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't handle control response!", hr);
			goto Failure;
		}
	}
	else
	{
		//
		// Not waiting for a control response, assume it's a description
		// response.
		//
		hr = this->HandleUPnPDescriptionResponseBody(pUPnPDevice,
													dwHTTPResponseCode,
													pszCurrent);
		if (hr != DPNH_OK)
		{
			//
			// UPnP device may have been removed from list.
			//

			DPFX(DPFPREP, 0, "Couldn't handle description response!", hr);
			goto Failure;
		}
	}


Exit:

	if (pszDeChunkedBuffer != NULL)
	{
		DNFree(pszDeChunkedBuffer);
		pszDeChunkedBuffer = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// Something went wrong, break the connection if it exists.
	//
	if (pUPnPDevice->IsConnected())
	{
		this->m_pfnshutdown(pUPnPDevice->GetControlSocket(), 0); // ignore error
		this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
		pUPnPDevice->SetControlSocket(INVALID_SOCKET);


		//
		// Mark the socket as not connected.
		//
		pUPnPDevice->NoteNotConnected();
	}


#ifdef DBG
	if (pszPrintIfFailed != NULL)
	{
		this->PrintUPnPTransactionToFile(pszPrintIfFailed,
										strlen(pszPrintIfFailed),
										"Inbound ignored data",
										pUPnPDevice->GetOwningDevice());
	}
#endif // DBG


	//
	// Forget all data received.
	//
	pUPnPDevice->ClearReceiveBuffer();

	goto Exit;
} // CNATHelpUPnP::ReceiveUPnPDataStream





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ParseUPnPHeaders"
//=============================================================================
// CNATHelpUPnP::ParseUPnPHeaders
//-----------------------------------------------------------------------------
//
// Description:    Parses UPnP header information out of a message buffer.
//
// Arguments:
//	char * pszMsg					- Pointer to string containing the UPnP
//										message.  It will be modified.
//	UPNP_HEADER_INFO * pHeaderInfo	- Structure used to return parsing results.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::ParseUPnPHeaders(char * const pszMsg,
									UPNP_HEADER_INFO * pHeaderInfo)
{
	char *	pszCurrent;
	char *	pszLineStart;
	char *	pszHeaderDelimiter;
	int		i;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pszMsg, pHeaderInfo);


	//
	// Loop until we reach the last SSDP header (indicated by a blank line).
	//
	pszCurrent = pszMsg;
	pszLineStart = pszMsg;
	do
	{
		//
		// Find the end of the current line (CR LF).
		//
		while ((*pszCurrent) != '\n')
		{
			if ((*pszCurrent) == '\0')
			{
				//
				// We hit the end of the buffer.  Bail.
				//
				DPFX(DPFPREP, 1, "Hit end of buffer, parsing terminated.");
				return;
			}

			pszCurrent++;
		}


		//
		// Assuming this is the last header line, update the message body
		// pointer to be after this line.
		//
		pHeaderInfo->pszMsgBody = pszCurrent + 1;


		//
		// If it's a valid line, then a CR will precede the LF we just found.
		// If so, truncate the string there.  If not, we'll just continue.  The
		// wacky newline in the middle of nowhere will probably just be
		// ignored.
		//
		if ((pszCurrent > (pszMsg + 1)) &&
			(*(pszCurrent - 1)) == '\r')
		{
			//
			// Truncate the string at the effective end of the line (i.e.
			// replace the CR with NULL terminator).
			//
			*(pszCurrent - 1) = '\0';


			//
			// If this is the empty line denoting the end of the headers, we're
			// done here.
			//
			if (strlen(pszLineStart) == 0)
			{
				//
				// Stop looping.
				//
				break;
			}
		}
		else
		{
			//
			// Truncate the string here.
			//
			(*pszCurrent) = '\0';

			DPFX(DPFPREP, 9, "Line has a newline in it (offset 0x%p) that isn't preceded by a carriage return.",
				(pszCurrent - pszMsg));
		}
	

		//
		// Whitespace means continuation of previous line, so if this line
		// starts that way, erase the termination for the previous line (unless
		// this is the first line).
		//
		if (((*pszLineStart) == ' ') || ((*pszLineStart) == '\t'))
		{
			if (pszLineStart >= (pszMsg + 2))
			{
				//
				// The previous line should have ended with {CR, LF}, which
				// gets modified to {NULL termination, LF}.
				//
				if ((*(pszLineStart - 2) != '\0') ||
					(*(pszLineStart - 1) != '\n'))
				{
					DPFX(DPFPREP, 7, "Ignoring line \"%hs\" because previous character sequence was not {NULL terminator, LF}.",
						pszLineStart);
				}
				else
				{
					DPFX(DPFPREP, 7, "Appending line \"%hs\" to previous line.",
						pszLineStart);

					//
					// Replace the NULL terminator/LF pair with spaces so
					// future parsing sees the previous line and this one as
					// one string.
					//
					*(pszLineStart - 2) = ' ';
					*(pszLineStart - 1) = ' ';
				}
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring initial line \"%hs\" that starts with whitespace.",
					pszLineStart);
			}
		}


		//
		// Find the colon separating the header.
		//
		pszHeaderDelimiter = strchr(pszLineStart, ':');
		if (pszHeaderDelimiter != NULL)
		{
			//
			// Truncate the string at the end of the header.
			//
			(*pszHeaderDelimiter) = '\0';


			//
			// Remove the white space surrounding the header name.
			//
			strtrim(&pszLineStart);


			//
			// Parse the header type.
			//
			for(i = 0; i < NUM_RESPONSE_HEADERS; i++)
			{
				if (_stricmp(c_szResponseHeaders[i], pszLineStart) == 0)
				{
					//
					// Found the header.  Save it if it's not a duplicate.
					//
					if (pHeaderInfo->apszHeaderStrings[i] == NULL)
					{
						char *	pszTrimmedValue;


						//
						// Skip leading and trailing whitespace in the value.
						//
						pszTrimmedValue = pszHeaderDelimiter + 1;
						strtrim(&pszTrimmedValue);

						pHeaderInfo->apszHeaderStrings[i] = pszTrimmedValue;


						DPFX(DPFPREP, 7, "Recognized header %i:\"%hs\", data = \"%hs\".",
							i, pszLineStart, pHeaderInfo->apszHeaderStrings[i]);
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring duplicate header %i:\"%hs\", data = \"%hs\".",
							i, pszLineStart, (pszHeaderDelimiter + 1));
					}

					break;
				}
			}

#ifdef DBG
			//
			// Print unrecognized headers. 
			//
			if (i >= NUM_RESPONSE_HEADERS)
			{
				DPFX(DPFPREP, 7, "Ignoring unrecognized header \"%hs\", data = \"%hs\".",
					pszLineStart, (pszHeaderDelimiter + 1));
			}
#endif // DBG
		}
		else
		{
			DPFX(DPFPREP, 7, "Ignoring line \"%hs\", no header delimiter.",
				pszLineStart);
		}


		//
		// Go to the next UPnP header (if any).
		//
		pszCurrent++;
		pszLineStart = pszCurrent;
	}
	while (TRUE);


	//
	// At this point pHeaderInfo->apszHeaderStrings should contain pointers to
	// the data for all the headers that were found, and
	// pHeaderInfo->pszMsgBody should point to the end of the headers.
	//
} // CNATHelpUPnP::ParseUPnPHeaders





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetAddressFromURL"
//=============================================================================
// CNATHelpUPnP::GetAddressFromURL
//-----------------------------------------------------------------------------
//
// Description: Parses a UPnP URL into a SOCKADDR_IN structure.  Only "http://"
//				URLs are parsed.  The string passed in may be temporarily
//				modified.
//
// Arguments:
//	char * pszLocation				- Pointer to buffer containing the Location
//										header.  It will be modified.
//	SOCKADDR_IN * psaddrinLocation	- Place to store address contained in
//										header string.
//	char ** ppszRelativePath		- Place to store pointer to rest of path
//										(stuff after hostname and optional
//										port).
//
// Returns: HRESULT
//	DPNH_OK				- String was parsed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::GetAddressFromURL(char * const pszLocation,
										SOCKADDR_IN * psaddrinLocation,
										char ** ppszRelativePath)
{
	HRESULT		hr;
	BOOL		fModifiedDelimiterChar = FALSE;
	char *		pszStart;
	char *		pszDelimiter;
	char		cTempChar;
	PHOSTENT	phostent;


	//
	// Initialize the address.  Default to the standard HTTP port.
	//
	ZeroMemory(psaddrinLocation, sizeof(SOCKADDR_IN));
	psaddrinLocation->sin_family = AF_INET;
	psaddrinLocation->sin_port = HTONS(HTTP_PORT);


	//
	// Clear the relative path pointer.
	//
	(*ppszRelativePath) = NULL;


	//
	// Skip past "http://".  If it's not "http://", then fail.
	//
	if (_strnicmp(pszLocation, "http://", strlen("http://")) != 0)
	{
		DPFX(DPFPREP, 1, "Location URL (\"%hs\") does not start with \"http://\".",
			pszLocation);
		hr = DPNHERR_GENERIC;
		goto Exit;
	}

	pszStart = pszLocation + strlen("http://");

	//
	// See if there's a port specified or any extraneous junk after an IP
	// address or hostname to figure out the string to use.  Search from the
	// start of the string until we hit the end of the string or a reserved URL
	// character.
	//

	pszDelimiter = pszStart + 1;

	while (((*pszDelimiter) != '\0') &&
			((*pszDelimiter) != '/') &&
			((*pszDelimiter) != '?') &&
			((*pszDelimiter) != '=') &&
			((*pszDelimiter) != '#'))
	{
		if ((*pszDelimiter) == ':')
		{
			char *	pszPortEnd;


			//
			// We found the start of a port, search for the end.  It must
			// contain only numeric characters.
			//
			pszPortEnd = pszDelimiter + 1;
			while (((*pszPortEnd) >= '0') && ((*pszPortEnd) <= '9'))
			{
				pszPortEnd++;
			}


			//
			// Temporarily truncate the string.
			//
			cTempChar = (*pszPortEnd);
			(*pszPortEnd) = '\0';


			DPFX(DPFPREP, 7, "Found port \"%hs\".", (pszDelimiter + 1));

			psaddrinLocation->sin_port = HTONS((u_short) atoi(pszDelimiter + 1));


			//
			// Restore the character.
			//
			(*pszPortEnd) = cTempChar;


			//
			// Save the relative path
			//
			(*ppszRelativePath) = pszPortEnd;

			break;
		}

		pszDelimiter++;
	}


	//
	// Remember the character that stopped the search, and then temporarily
	// truncate the string.
	//
	cTempChar = (*pszDelimiter);
	(*pszDelimiter) = '\0';
	fModifiedDelimiterChar = TRUE;


	//
	// Save the relative path if we haven't already (because of a port).
	//
	if ((*ppszRelativePath) == NULL)
	{
		(*ppszRelativePath) = pszDelimiter;
	}

	DPFX(DPFPREP, 7, "Relative path = \"%hs\".", (*ppszRelativePath));


	
	//
	// Convert the hostname.
	//
	psaddrinLocation->sin_addr.S_un.S_addr = this->m_pfninet_addr(pszStart);

	//
	// If it's bogus, give up.
	//
	if (psaddrinLocation->sin_addr.S_un.S_addr == INADDR_ANY)
	{
		DPFX(DPFPREP, 0, "Host name \"%hs\" is invalid!",
			pszStart);
		hr = DPNHERR_GENERIC;
		goto Exit;
	}

	if (psaddrinLocation->sin_addr.S_un.S_addr == INADDR_NONE)
	{
		//
		// It's not a straight IP address.  Lookup the hostname.
		//
		phostent = this->m_pfngethostbyname(pszStart);
		if (phostent == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't lookup host name \"%hs\"!",
				pszStart);
			hr = DPNHERR_GENERIC;
			goto Exit;
		}

		if (phostent->h_addr_list[0] == NULL)
		{
			DPFX(DPFPREP, 0, "Host name \"%hs\" has no address entries!",
				pszStart);
			hr = DPNHERR_GENERIC;
			goto Exit;
		}


		//
		// Pick the first address returned.
		//

#ifdef DBG
		{
			IN_ADDR **	ppinaddr;
			DWORD		dwNumAddrs;


			ppinaddr = (IN_ADDR**) phostent->h_addr_list;
			dwNumAddrs = 0;

			while ((*ppinaddr) != NULL)
			{
				ppinaddr++;
				dwNumAddrs++;
			}

			DPFX(DPFPREP, 7, "Picking first (of %u IP addresses) for \"%hs\".",
				dwNumAddrs, pszStart);
		}
#endif // DBG

		psaddrinLocation->sin_addr.S_un.S_addr = ((IN_ADDR*) phostent->h_addr_list[0])->S_un.S_addr;
	}
	else
	{
		DPFX(DPFPREP, 7, "Successfully converted IP address \"%hs\".", pszStart);
	}


	hr = DPNH_OK;


Exit:


	//
	// If we found a port, restore the string.  If not, use the default port.
	//
	if (fModifiedDelimiterChar)
	{
		//
		// Note that PREfast reported this as being used before being
		// initialized for a while.  For some reason it didn't notice that I
		// key off of fModifiedDelimiterChar.  This appeared to get fixed, but
		// PREfast is still giving me a false hit for a similar reason
		// elsewhere.
		//
		(*pszDelimiter) = cTempChar;
	}


	DPFX(DPFPREP, 8, "Returning %u.%u.%u.%u:%u, hr = 0x%lx.",
		psaddrinLocation->sin_addr.S_un.S_un_b.s_b1,
		psaddrinLocation->sin_addr.S_un.S_un_b.s_b2,
		psaddrinLocation->sin_addr.S_un.S_un_b.s_b3,
		psaddrinLocation->sin_addr.S_un.S_un_b.s_b4,
		NTOHS(psaddrinLocation->sin_port),
		hr);


	return hr;
} // CNATHelpUPnP::GetAddressFromURL





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::HandleUPnPDescriptionResponseBody"
//=============================================================================
// CNATHelpUPnP::HandleUPnPDescriptionResponseBody
//-----------------------------------------------------------------------------
//
// Description:    Handles a UPnP device description response.  The string will
//				be modified.
//
//				   The UPnP device may get removed from list if a failure
//				occurs, the caller needs to have a reference.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice	- Pointer to UPnP device being described.
//	DWORD dwHTTPResponseCode	- HTTP header response code.
//	char * pszDescriptionXML	- UPnP device description XML string.
//
// Returns: HRESULT
//	DPNH_OK				- Description response was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::HandleUPnPDescriptionResponseBody(CUPnPDevice * const pUPnPDevice,
														const DWORD dwHTTPResponseCode,
														char * const pszDescriptionXML)
{
	HRESULT					hr;
	PARSEXML_SUBELEMENT		aSubElements[MAX_NUM_DESCRIPTION_XML_SUBELEMENTS];
	PARSEXML_ELEMENT		ParseElement;
	CDevice *				pDevice;
	CBilink *				pBilink;
	CRegisteredPort *		pRegisteredPort;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %u, 0x%p)",
		this, pUPnPDevice, dwHTTPResponseCode, pszDescriptionXML);


	//
	// Make sure it was the success result.
	//
	if (dwHTTPResponseCode != 200)
	{
		DPFX(DPFPREP, 0, "Got error response %u from UPnP description request!",
			 dwHTTPResponseCode);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	ZeroMemory(aSubElements, sizeof(aSubElements));
	
	ZeroMemory(&ParseElement, sizeof(ParseElement));
	ParseElement.papszElementStack				= (char**) (&c_szElementStack_service);
	ParseElement.dwElementStackDepth			= sizeof(c_szElementStack_service) / sizeof(char*);
	ParseElement.paSubElements					= (PARSEXML_SUBELEMENT*) (aSubElements);
	ParseElement.dwMaxNumSubElements			= MAX_NUM_DESCRIPTION_XML_SUBELEMENTS;
	//ParseElement.dwNumSubElements				= 0;
	//ParseElement.fFoundMatchingElement			= FALSE;

	hr = this->ParseXML(pszDescriptionXML,
						&ParseElement,
						PARSECALLBACK_DESCRIPTIONRESPONSE,
						pUPnPDevice);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't parse XML!");
		goto Failure;
	}


	//
	// If we did not find a WANIPConnection or WANPPPConnection service, then
	// this response was not valid.
	//
	if (pUPnPDevice->GetServiceControlURL() == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't find WANIPConnection or WANPPPConnection service in XML description!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// The UPnP device is now controllable.
	//
	pUPnPDevice->NoteReady();



	//
	// Find out what the device's external IP address is.  Note that calling
	// UpdateUPnPExternalAddress will overwrite the buffer containing the
	// pszDescriptionXML string.  That's fine, because we've saved all the
	// stuff in there that we need already.
	//
	hr = this->UpdateUPnPExternalAddress(pUPnPDevice, FALSE);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't update new UPnP device 0x%p's external address!",
			pUPnPDevice);
		goto Failure;
	}


	//
	// Map existing registered ports with this new UPnP device.
	//
	pDevice = pUPnPDevice->GetOwningDevice();
	DNASSERT(pDevice != NULL);

	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

		//
		// Note that calling MapPortsOnUPnPDevice will overwrite the buffer
		// containing the pszDescriptionXML string.  That's fine, because
		// we've saved all the stuff in there that we need already.
		//
		hr = this->MapPortsOnUPnPDevice(pUPnPDevice, pRegisteredPort);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't map existing ports on new UPnP device 0x%p!",
				pUPnPDevice);
			goto Failure;
		}


		//
		// Let the user know the addresses changed next time GetCaps is
		// called.
		//
		DPFX(DPFPREP, 8, "Noting that addresses changed (for registered port 0x%p).",
			pRegisteredPort);
		this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;


		pBilink = pBilink->GetNext();
	}


	//
	// Try to remove any mappings that were not freed earlier because we
	// crashed.
	//
	hr = this->CleanupInactiveNATMappings(pUPnPDevice);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Failed cleaning up inactive mappings with new UPnP device 0x%p!",
			pUPnPDevice);
		goto Failure;
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::HandleUPnPDescriptionResponseBody





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::HandleUPnPControlResponseBody"
//=============================================================================
// CNATHelpUPnP::HandleUPnPControlResponseBody
//-----------------------------------------------------------------------------
//
// Description:    Handles a UPnP control response.  The string will be
//				modified.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CUPnPDevice * pUPnPDevice		- Pointer to UPnP device being described.
//	DWORD dwHTTPResponseCode		- HTTP header response code.
//	char * pszControlResponseSOAP	- UPnP device response SOAP XML string.
//
// Returns: HRESULT
//	DPNH_OK				- Description response was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::HandleUPnPControlResponseBody(CUPnPDevice * const pUPnPDevice,
													const DWORD dwHTTPResponseCode,
													char * const pszControlResponseSOAP)
{
	HRESULT							hr = DPNH_OK;
	CONTROLRESPONSEPARSECONTEXT		crpc;
	PARSEXML_SUBELEMENT				aSubElements[MAX_NUM_UPNPCONTROLOUTARGS];
	PARSEXML_ELEMENT				ParseElement;


	DNASSERT(pUPnPDevice->IsWaitingForControlResponse());


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %u, 0x%p)",
		this, pUPnPDevice, dwHTTPResponseCode, pszControlResponseSOAP);



	ZeroMemory(&crpc, sizeof(crpc));
	crpc.ControlResponseType	= pUPnPDevice->GetControlResponseType();
	crpc.pUPnPDevice			= pUPnPDevice;
	crpc.dwHTTPResponseCode		= dwHTTPResponseCode;
	crpc.pControlResponseInfo	= pUPnPDevice->GetControlResponseInfo();



	ZeroMemory(aSubElements, sizeof(aSubElements));
	

	ZeroMemory(&ParseElement, sizeof(ParseElement));

	if (dwHTTPResponseCode == 200)
	{
		switch (crpc.ControlResponseType)
		{
			/*
			case CONTROLRESPONSETYPE_QUERYSTATEVARIABLE_EXTERNALIPADDRESS:
			{
				ParseElement.papszElementStack			= (char**) (&c_szElementStack_QueryStateVariableResponse);
				ParseElement.dwElementStackDepth		= sizeof(c_szElementStack_QueryStateVariableResponse) / sizeof(char*);
				break;
			}
			*/
			case CONTROLRESPONSETYPE_GETEXTERNALIPADDRESS:
			{
				ParseElement.papszElementStack			= (char**) (&c_szElementStack_GetExternalIPAddressResponse);
				ParseElement.dwElementStackDepth		= sizeof(c_szElementStack_GetExternalIPAddressResponse) / sizeof(char*);
				break;
			}

			case CONTROLRESPONSETYPE_ADDPORTMAPPING:
			{
				ParseElement.papszElementStack			= (char**) (&c_szElementStack_AddPortMappingResponse);
				ParseElement.dwElementStackDepth		= sizeof(c_szElementStack_AddPortMappingResponse) / sizeof(char*);
				break;
			}

			case CONTROLRESPONSETYPE_GETSPECIFICPORTMAPPINGENTRY:
			{
				ParseElement.papszElementStack			= (char**) (&c_szElementStack_GetSpecificPortMappingEntryResponse);
				ParseElement.dwElementStackDepth		= sizeof(c_szElementStack_GetSpecificPortMappingEntryResponse) / sizeof(char*);
				break;
			}

			case CONTROLRESPONSETYPE_DELETEPORTMAPPING:
			{
				ParseElement.papszElementStack			= (char**) (&c_szElementStack_DeletePortMappingResponse);
				ParseElement.dwElementStackDepth		= sizeof(c_szElementStack_DeletePortMappingResponse) / sizeof(char*);
				break;
			}

			default:
			{
				DNASSERT(FALSE);
				hr = DPNHERR_GENERIC;
				goto Failure;
				break;
			}
		}
	}
	else
	{
		ParseElement.papszElementStack			= (char**) (&c_szElementStack_ControlResponseFailure);
		ParseElement.dwElementStackDepth		= sizeof(c_szElementStack_ControlResponseFailure) / sizeof(char*);
	}

	ParseElement.paSubElements				= (PARSEXML_SUBELEMENT*) (aSubElements);
	ParseElement.dwMaxNumSubElements		= MAX_NUM_UPNPCONTROLOUTARGS;
	//ParseElement.dwNumSubElements			= 0;
	//ParseElement.fFoundMatchingElement	= FALSE;

	hr = this->ParseXML(pszControlResponseSOAP,
						&ParseElement,
						PARSECALLBACK_CONTROLRESPONSE,
						&crpc);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't parse XML!");
		goto Failure;
	}


	//
	// If we didn't a matching item, map it to a generic failure.
	//
	if (! ParseElement.fFoundMatchingElement)
	{
		if (dwHTTPResponseCode == 200)
		{
			DPFX(DPFPREP, 1, "Didn't find XML items in success response, mapping to generic failure.");
		}
		else
		{
			DPFX(DPFPREP, 1, "Didn't find failure XML items, using generic failure.");
		}

		crpc.pControlResponseInfo->hrErrorCode = DPNHERR_GENERIC;
	}


	pUPnPDevice->StopWaitingForControlResponse();



Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::HandleUPnPControlResponseBody





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ParseXML"
//=============================================================================
// CNATHelpUPnP::ParseXML
//-----------------------------------------------------------------------------
//
// Description:    Parses an XML string for a specific element, and calls a
//				helper function for each instance found.
//
//				   Subelement values cannot themselves contain subelements.  If
//				they do, the sub-subelements will be ignored.
//
//				   The string buffer is modified.
//
// Arguments:
//	char * pszXML						- XML string to parse.
//	PARSEXML_ELEMENT * pParseElement	- Pointer to element whose sub element
//											values should be retrieved.
//	PARSECALLBACK ParseCallback			- Enum indicating what helper function
//											to use.
//	PVOID pvContext						- Pointer to context value to pass to
//											helper function.
//
// Returns: HRESULT
//	DPNH_OK				- Description response was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::ParseXML(char * const pszXML,
								PARSEXML_ELEMENT * const pParseElement,
								const PARSECALLBACK ParseCallback,
								PVOID pvContext)
{
	HRESULT					hr = DPNH_OK;
	PARSEXML_STACKENTRY		aElementStack[MAX_XMLELEMENT_DEPTH];
	DWORD					dwCurrentElementDepth = 0;
	char *					pszElementTagStart = NULL;
	BOOL					fInElement = FALSE;
	BOOL					fEmptyElement = FALSE;
	char *					pszCurrent;
	DWORD					dwStackDepth;
	PARSEXML_SUBELEMENT *	pSubElement;



	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pszXML, pParseElement);


	//
	// Need room for entire stack + at least one subelement level.
	//
	DNASSERT(pParseElement->dwElementStackDepth < MAX_XMLELEMENT_DEPTH);


#ifdef DBG
	this->PrintUPnPTransactionToFile(pszXML,
									strlen(pszXML),
									"Inbound XML Body",
									NULL);
#endif // DBG


	//
	// Loop through the XML looking for the given elements.
	//
	pszCurrent = pszXML;
	while ((*pszCurrent) != '\0')
	{
		switch (*pszCurrent)
		{
			case '<':
			{
				//
				// If we're in an element tag already, this is bogus XML or a
				// CDATA section (which we don't handle).  Fail.
				//
				if (pszElementTagStart != NULL)
				{
					DPFX(DPFPREP, 0, "Encountered '<' character in element tag, XML parsing failed.");
					goto Failure;
				}

				//
				// Truncate the string here in case this is the start of an
				// element end tag.  This delimits a value string.
				//
				(*pszCurrent) = '\0';


				pszElementTagStart = pszCurrent + 1;
				if ((*pszElementTagStart) == '\0')
				{
					DPFX(DPFPREP, 0, "Encountered '<' character at end of string, XML parsing failed.");
					goto Failure;
				}

				break;
			}

			case '>':
			{
				//
				// If we're not in an element tag, this is bogus XML or a CDATA
				// section (which we don't handle).  Fail.
				//
				if (pszElementTagStart == NULL)
				{
					DPFX(DPFPREP, 0, "Encountered '>' character outside of element tag, XML parsing failed.");
					goto Failure;
				}

				//
				// Truncate the string here.
				//
				(*pszCurrent) = '\0';

				//
				// This could either be a start or an end tag.  If the first
				// character of the tag is '/', then it's an end tag.
				//
				// Note that empty element tags begin by being parsed like a
				// start tag, but then jump into the end tag clause.
				//
				if ((*pszElementTagStart) == '/')
				{
					pszElementTagStart++;


					//
					// Make sure the element tag stack is valid.  The name of
					// this end tag should match the start tag at the top of
					// the stack.  XML elements are case sensitive.
					//
					if (dwCurrentElementDepth == 0)
					{
						DPFX(DPFPREP, 0, "Encountered extra element end tag \"%hs\", XML parsing failed.",
							pszElementTagStart);
						goto Failure;
					}

					if (strcmp(pszElementTagStart, aElementStack[dwCurrentElementDepth - 1].pszName) != 0)
					{
						DPFX(DPFPREP, 0, "Encountered non-matching element end tag (\"%hs\" != \"%hs\"), XML parsing failed.",
							pszElementTagStart,
							aElementStack[dwCurrentElementDepth - 1].pszName);
						goto Failure;
					}

TagEnd:

					//
					// If we're here, then we have a complete element.  If we
					// were in the element, then it's either:
					//	the end of a sub-sub element,
					//	the end of a sub element, or
					//	the end of the element itself.
					//
					if (fInElement)
					{
						switch (dwCurrentElementDepth - pParseElement->dwElementStackDepth)
						{
							case 0:
							{
								//
								// It's the end of the element.  Call the
								// helper function.  Reuse fInElement as the
								// fContinueParsing BOOL.
								//

								switch (ParseCallback)
								{
									case PARSECALLBACK_DESCRIPTIONRESPONSE:
									{
										hr = this->ParseXMLCallback_DescriptionResponse(pParseElement,
																						pvContext,
																						aElementStack,
																						&fInElement);
										if (hr != DPNH_OK)
										{
											DPFX(DPFPREP, 0, "Description response parse helper function failed!");
											goto Failure;
										}
										break;
									}

									case PARSECALLBACK_CONTROLRESPONSE:
									{
										hr = this->ParseXMLCallback_ControlResponse(pParseElement,
																					pvContext,
																					aElementStack,
																					&fInElement);
										if (hr != DPNH_OK)
										{
											DPFX(DPFPREP, 0, "Control response parse helper function failed!");
											goto Failure;
										}
										break;
									}

									default:
									{
										DNASSERT(FALSE);
										break;
									}
								}

								if (! fInElement)
								{
									DPFX(DPFPREP, 1, "Parse callback function discontinued parsing.");
									goto Exit;
								}

								//
								// Keep parsing, but we're no longer in the
								// element.  Reset the sub element counter in
								// case we found entries.
								//
								fInElement = FALSE;
								pParseElement->dwNumSubElements = 0;
								break;
							}

							case 1:
							{
								//
								// It's the end of a subelement.  Complete this
								// instance, if there's room.
								//
								if (pParseElement->dwNumSubElements < pParseElement->dwMaxNumSubElements)
								{
									pSubElement = &pParseElement->paSubElements[pParseElement->dwNumSubElements];



									pSubElement->pszNameFound = pszElementTagStart;


									pSubElement->dwNumAttributes = aElementStack[dwCurrentElementDepth - 1].dwNumAttributes;
									if (pSubElement->dwNumAttributes > 0)
									{
										memcpy(pSubElement->apszAttributeNames,
												aElementStack[dwCurrentElementDepth - 1].apszAttributeNames,
												(pSubElement->dwNumAttributes * sizeof(char*)));

										memcpy(pSubElement->apszAttributeValues,
												aElementStack[dwCurrentElementDepth - 1].apszAttributeValues,
												(pSubElement->dwNumAttributes * sizeof(char*)));
									}


									pSubElement->pszValueFound = aElementStack[dwCurrentElementDepth - 1].pszValue;



									pParseElement->dwNumSubElements++;

									DPFX(DPFPREP, 7, "Completed subelement instance #%u, name = \"%hs\", %u attributes, value = \"%hs\".",
										pParseElement->dwNumSubElements,
										pSubElement->pszNameFound,
										pSubElement->dwNumAttributes,
										pSubElement->pszValueFound);
								}
								else
								{
									DPFX(DPFPREP, 0, "Ignoring subelement instance \"%hs\" (%u attributes, value = \"%hs\"), no room in array.",
										pszElementTagStart,
										aElementStack[dwCurrentElementDepth - 1].dwNumAttributes,
										aElementStack[dwCurrentElementDepth - 1].pszValue);
								}
								break;
							}
							
							default:
							{
								//
								// It's the end of a sub-subelement.
								//
								DPFX(DPFPREP, 1, "Ignoring sub-sub element \"%hs\" (%u attributes, value = \"%hs\").",
									pszElementTagStart,
									aElementStack[dwCurrentElementDepth - 1].dwNumAttributes,
									aElementStack[dwCurrentElementDepth - 1].pszValue);
								break;
							}
						}
					}

					//
					// Pop the element off the stack.
					//
					dwCurrentElementDepth--;
				}
				else
				{
					//
					// It's not an end tag, but it might be an empty element
					// (i.e. "<tag/>").
					//
					if (*(pszCurrent - 1) == '/')
					{
						//
						// Truncate the string early.
						//
						*(pszCurrent - 1) = '\0';

						//
						// Remember this state so we can parse it properly.
						//
						fEmptyElement = TRUE;

						DPFX(DPFPREP, 7, "XML element \"%hs\" is empty (i.e. is both a start and end tag).",
							pszElementTagStart);
					}

					//
					// Push the element on the tag stack, if there's room.
					//
					if (dwCurrentElementDepth >= MAX_XMLELEMENT_DEPTH)
					{
						DPFX(DPFPREP, 0, "Too many nested element tags (%u), XML parsing failed.",
							dwCurrentElementDepth);
						goto Failure;
					}

					aElementStack[dwCurrentElementDepth].pszName = pszElementTagStart;

					//
					// If there are attributes to this element, separate them
					// into a different array.  They will not be parsed,
					// though.
					// Attributes are delimited by whitespace.
					//
					while ((*pszElementTagStart) != '\0')
					{
						pszElementTagStart++;

						//
						// If it's whitespace, that's the end of the element
						// name.  Truncate the string and break out of the
						// loops.
						//
						if (((*pszElementTagStart) == ' ') ||
							((*pszElementTagStart) == '\t') ||
							((*pszElementTagStart) == '\r') ||
							((*pszElementTagStart) == '\n'))
						{
							(*pszElementTagStart) = '\0';
							pszElementTagStart++;

							DPFX(DPFPREP, 8, "Attribute whitespace found at offset 0x%p, string length = %i.",
								(pszElementTagStart - aElementStack[dwCurrentElementDepth].pszName),
								strlen(pszElementTagStart));

							break;
						}
					}

					//
					// If there weren't any attributes, pszElementTagStart will
					// just point to an empty (but not NULL) string.
					//
					// So save the start of the value string.
					//
					aElementStack[dwCurrentElementDepth].pszValue = pszElementTagStart + strlen(pszElementTagStart) + 1;


					//
					// Then parse out the attributes.
					//
					this->ParseXMLAttributes(pszElementTagStart,
											aElementStack[dwCurrentElementDepth].apszAttributeNames,
											aElementStack[dwCurrentElementDepth].apszAttributeValues,
											MAX_XMLNAMESPACES_PER_ELEMENT,
											&(aElementStack[dwCurrentElementDepth].dwNumAttributes));


					//
					// The <?xml> tag is considered optional by this parser,
					// and will be ignored.
					//
					if (_stricmp(aElementStack[dwCurrentElementDepth].pszName, "?xml") != 0)
					{
						//
						// Bump the stack pointer.
						//
						dwCurrentElementDepth++;


						//
						// See if this the right element.  If the stack depth
						// isn't right, it can't be the desired item.
						// Otherwise, make sure the stack matches.
						//
						if (dwCurrentElementDepth == pParseElement->dwElementStackDepth)
						{
							//
							// Work through the entire element stack, making
							// sure each name matches.
							//
							for(dwStackDepth = 0; dwStackDepth < dwCurrentElementDepth; dwStackDepth++)
							{
								if (! this->MatchesXMLStringWithoutNamespace(aElementStack[dwStackDepth].pszName,
																			pParseElement->papszElementStack[dwStackDepth],
																			aElementStack,
																			NULL,
																			(dwStackDepth + 1)))
								{
									//
									// It didn't match.  Stop looping.
									//
									break;
								}
							}

							//
							// If they all matched, we found the value desired.
							//
							if (dwStackDepth == dwCurrentElementDepth)
							{
								fInElement = TRUE;

								DPFX(DPFPREP, 7, "Found requested element \"%hs\" at depth %u, has %u attributes.",
									aElementStack[dwCurrentElementDepth - 1].pszName,
									dwCurrentElementDepth,
									aElementStack[dwCurrentElementDepth - 1].dwNumAttributes);
							}
						}
					}
					else
					{
						DPFX(DPFPREP, 7, "Ignoring element \"%hs\" at depth %u that has %u attributes.",
							aElementStack[dwCurrentElementDepth].pszName,
							dwCurrentElementDepth,
							aElementStack[dwCurrentElementDepth].dwNumAttributes);

						//
						// If this assertion fails and it is an empty element,
						// dwCurrentElementDepth will be off by -1 when we jump
						// to TagEnd.
						//
						DNASSERT(! fInElement);
					}


					//
					// If this is an empty element, go immediately to handling
					// the tag closure.
					//
					if (fEmptyElement)
					{
						fEmptyElement = FALSE;
						goto TagEnd;
					}
				}


				//
				// Search for another element tag.
				//
				pszElementTagStart = NULL;
				break;
			}

			default:
			{
				//
				// Ordinary character, continue.
				//
				break;
			}
		}

		//
		// Move to the next character
		//
		pszCurrent++;
	}

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	hr = DPNHERR_GENERIC;

	goto Exit;
} // CNATHelpUPnP::ParseXML






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ParseXMLAttributes"
//=============================================================================
// CNATHelpUPnP::ParseXMLAttributes
//-----------------------------------------------------------------------------
//
// Description: Parses any XML attributes out of the given string.  The input
//				string buffer will be modified.
//
// Arguments:
//	char * pszString				- Pointer to attributes string to parse.
//										This will be modified.
//	char ** apszAttributeNames		- Array in which to store attribute name
//										string pointers.
//	char ** apszAttributeValues		- Matching array in which to store cor-
//										responding attribute value strings.
//	DWORD dwMaxNumAttributes		- Maximum number of entries allowed in
//										previous arrays.
//	DWORD * pdwNumAttributes		- Place to store number of attributes that
//										were found.
//
// Returns: HRESULT
//	DPNH_OK				- Description response was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
void CNATHelpUPnP::ParseXMLAttributes(char * const pszString,
									char ** const apszAttributeNames,
									char ** const apszAttributeValues,
									const DWORD dwMaxNumAttributes,
									DWORD * const pdwNumAttributes)
{
	char *	pszStart;
	char *	pszCurrent;
	char *	pszEndOfString;
	BOOL	fInValueString = FALSE;
	BOOL	fInQuotes = FALSE;
	BOOL	fEmptyString = FALSE;


#ifdef EXTRA_PARSING_SPEW
	DPFX(DPFPREP, 8, "(0x%p) Parameters: (\"%hs\", 0x%p, 0x%p, %u, 0x%p)",
		this, pszString, apszAttributeNames, apszAttributeValues,
		dwMaxNumAttributes, pdwNumAttributes);
#endif // EXTRA_PARSING_SPEW


	//
	// Start at the beginning with no entries.
	//
	(*pdwNumAttributes) = 0;
	pszStart = pszString;
	pszCurrent = pszStart;
	pszEndOfString = pszString + strlen(pszString);


	//
	// Skip empty strings.
	//
	if (pszEndOfString == pszStart)
	{
		return;
	}


	//
	// Loop through the entire string.
	//
	while (pszCurrent <= pszEndOfString)
	{
		switch (*pszCurrent)
		{
			case '=':
			{
				//
				// If we're not in quotes or a value string, this is the end of
				// the attribute name and the start of a value string.
				//
				if ((! fInQuotes) && (! fInValueString))
				{
					(*pszCurrent) = '\0';
					apszAttributeNames[(*pdwNumAttributes)] = pszStart;
					pszStart = pszCurrent + 1;
					fInValueString = TRUE;
				}
				break;
			}

			case '\0':
			case ' ':
			case '\t':
			case '\r':
			case '\n':
			{
				//
				// Whitespace or the end of the string.  If we're not in
				// quotes, that means it's the end of an attribute.  Of course
				// if it's the end of the string, then we force the end of the
				// attribute/value.
				//
				if ((! fInQuotes) || ((*pszCurrent) == '\0'))
				{
					(*pszCurrent) = '\0';

					if (fInValueString)
					{
						//
						// End of the value string.
						//

						apszAttributeValues[(*pdwNumAttributes)] = pszStart;
						fInValueString = FALSE;

						DPFX(DPFPREP, 7, "Found attribute \"%hs\" with value \"%hs\".",
							apszAttributeNames[(*pdwNumAttributes)],
							apszAttributeValues[(*pdwNumAttributes)]);
					}
					else
					{
						//
						// This may be another whitespace character immediately
						// following a previous one.  If so, ignore it.  If
						// not, save the attribute.
						//
						if (pszCurrent == pszStart)
						{
							fEmptyString = TRUE;

#ifdef EXTRA_PARSING_SPEW
							DPFX(DPFPREP, 9, "Ignoring extra whitespace at offset 0x%p.",
								(pszCurrent - pszString));
#endif // EXTRA_PARSING_SPEW
						}
						else
						{
							//
							// End of the attribute.  Force an empty value string.
							//

							apszAttributeNames[(*pdwNumAttributes)] = pszStart;
							apszAttributeValues[(*pdwNumAttributes)] = pszCurrent;

							DPFX(DPFPREP, 7, "Found attribute \"%hs\" with no value string.",
								apszAttributeNames[(*pdwNumAttributes)]);
						}
					}


					//
					// Update the pointer for the start of the next attribute.
					//
					pszStart = pszCurrent + 1;


					//
					// Move to next attribute storage location, if this is not
					// an empty string.  If that was the last storage slot,
					// we're done here.
					//
					if (fEmptyString)
					{
						fEmptyString = FALSE;
					}
					else
					{
						(*pdwNumAttributes)++;
						if ((*pdwNumAttributes) >= dwMaxNumAttributes)
						{
							DPFX(DPFPREP, 1, "Maximum number of attributes reached, discontinuing attribute parsing.");
							pszCurrent = pszEndOfString;
						}
					}
				}
				break;
			}

			case '"':
			{
				//
				// Make sure it's not an escaped quote character.
				//
				if ((pszCurrent == pszString) || (*(pszCurrent - 1) != '\\'))
				{
					//
					// Toggle the quote state.
					//
					if (fInQuotes)
					{
						//
						// Force the string to terminate here so we skip the
						// trailing quote character.
						//
						fInQuotes = FALSE;
						(*pszCurrent) = '\0';
					}
					else
					{
						fInQuotes = TRUE;

						//
						// This should be the start of a (value) string.  Skip
						// this quote character.
						//
						if (pszCurrent == pszStart)
						{
							pszStart++;
						}
						else
						{
							DPFX(DPFPREP, 1, "Found starting quote that wasn't at the beginning of the string!  Continuing.");
						}
					}
				}
				else
				{
					//
					// It's an escaped quote character.
					//
				}
				break;
			}

			default:
			{
				//
				// Ignore the character and move on.
				//
				break;
			}
		}
		

		//
		// Move to next character.
		//
		pszCurrent++;
	}


#ifdef EXTRA_PARSING_SPEW
	DPFX(DPFPREP, 8, "(0x%p) Leave (found %u items)", this, (*pdwNumAttributes));
#endif // EXTRA_PARSING_SPEW
} // CNATHelpUPnP::ParseXMLNamespaceAttributes






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::MatchesXMLStringWithoutNamespace"
//=============================================================================
// CNATHelpUPnP::MatchesXMLStringWithoutNamespace
//-----------------------------------------------------------------------------
//
// Description: Determines whether the szCompareString matches szMatchString
//				when all namespace prefixes in szCompareString are ignored.
//				TRUE is returned if they do match, FALSE if not.
//
// Arguments:
//	char * szCompareString				- String that may contain namespace
//											prefixes to be ignored.
//	char * szMatchString				- Shortened string without any
//											namespace prefixes to be matched.
//	PARSEXML_STACKENTRY * aElementStack	- Array of nested elements whose
//											attributes may define XML namespace
//											aliases.
//	PARSEXML_SUBELEMENT * pSubElement	- Optional subelement entry with
//											additional attributes to check.
//	DWORD dwElementStackDepth			- Number of entries in previous array.
//
// Returns: BOOL
//=============================================================================
BOOL CNATHelpUPnP::MatchesXMLStringWithoutNamespace(const char * const szCompareString,
													const char * const szMatchString,
													const PARSEXML_STACKENTRY * const aElementStack,
													const PARSEXML_SUBELEMENT * const pSubElement,
													const DWORD dwElementStackDepth)
{
	BOOL	fResult;
	char *	pszCompareStringNoNamespace;


	//
	// First, do a straight-forward string comparison.
	//
	if (_stricmp(szCompareString, szMatchString) == 0)
	{
		DPFX(DPFPREP, 7, "\"%hs\" exactly matches the short string.",
			szCompareString);

		fResult = TRUE;
	}
	else
	{
		//
		// Skip past any namespace prefixes.
		//
		pszCompareStringNoNamespace = this->GetStringWithoutNamespacePrefix(szCompareString,
																			aElementStack,
																			pSubElement,
																			dwElementStackDepth);
		DNASSERT((pszCompareStringNoNamespace >= szCompareString) && (pszCompareStringNoNamespace <= (szCompareString + strlen(szCompareString))));


		//
		// Now try comparing again, if we found any prefixes.
		//
		if (pszCompareStringNoNamespace > szCompareString)
		{
			if (_stricmp(pszCompareStringNoNamespace, szMatchString) == 0)
			{
				DPFX(DPFPREP, 7, "\"%hs\" matches the short string \"%hs\" starting at offset 0x%p.",
					szCompareString, szMatchString,
					(pszCompareStringNoNamespace - szCompareString));

				fResult = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 8, "\"%hs\" does not match the short string \"%hs\" (starting at offset 0x%p).",
					szCompareString, szMatchString,
					(pszCompareStringNoNamespace - szCompareString));

				fResult = FALSE;
			}
		}
		else
		{
			DPFX(DPFPREP, 8, "\"%hs\" does not have any namespace prefixes and does not match \"%hs\".",
				szCompareString, szMatchString);

			fResult = FALSE;
		}
	}

	return fResult;
} // CNATHelpUPnP::MatchesXMLStringWithoutNamespace






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetStringWithoutNamespacePrefix"
//=============================================================================
// CNATHelpUPnP::GetStringWithoutNamespacePrefix
//-----------------------------------------------------------------------------
//
// Description: Returns a pointer to the first part of the string after any
//				prefixes found.  This will be the start of the string if none
//				are found.
//
// Arguments:
//	char * szString						- String that may contain namespace
//											prefixes to be skipped.
//	PARSEXML_STACKENTRY * aElementStack	- Array of nested elements whose
//											attributes may define XML namespace
//											aliases.
//	PARSEXML_SUBELEMENT * pSubElement	- Optional subelement entry with
//											additional attributes to check.
//	DWORD dwElementStackDepth			- Number of entries in previous array.
//
// Returns: char *
//=============================================================================
char * CNATHelpUPnP::GetStringWithoutNamespacePrefix(const char * const szString,
													const PARSEXML_STACKENTRY * const aElementStack,
													const PARSEXML_SUBELEMENT * const pSubElement,
													const DWORD dwElementStackDepth)
{
	char *	pszResult;
	UINT	uiXMLNSPrefixLength;
	DWORD	dwAttribute;
	UINT	uiNamespaceNameLength;
	UINT	uiNamespaceValueLength;
	DWORD	dwStackDepth;



	//
	// Store the prefix value since we use it frequently in this function.
	//
	uiXMLNSPrefixLength = strlen(XML_NAMESPACEDEFINITIONPREFIX);


	//
	// Search the stack for an XML namespace definition that matches.  Start at
	// the bottom and work up, since later definitions take precendence over
	// earlier ones.
	//
	// In fact, if this is a subelement, there are attributes associated with
	// this item that need to be checked, too.  Do that first.
	//
	if (pSubElement != NULL)
	{
		//
		// Search each attribute
		//
		for(dwAttribute = 0; dwAttribute < pSubElement->dwNumAttributes; dwAttribute++)
		{
			//
			// Work with this attribute if it's a valid XML namespace
			// definition.  It needs to start with the prefix, plus have one
			// extra character for the actual name.
			//
			uiNamespaceNameLength = strlen(pSubElement->apszAttributeNames[dwAttribute]);
			if ((uiNamespaceNameLength >= (uiXMLNSPrefixLength + 1)) &&
				(_strnicmp(pSubElement->apszAttributeNames[dwAttribute], XML_NAMESPACEDEFINITIONPREFIX, uiXMLNSPrefixLength) == 0))
			{
				uiNamespaceNameLength -= uiXMLNSPrefixLength;

				//
				// Only work with the item's value if it's valid.
				//
				uiNamespaceValueLength = strlen(pSubElement->apszAttributeValues[dwAttribute]);
				if (uiNamespaceValueLength > 0)
				{
					//
					// Okay, here's an item.  See if the name prefixes the
					// passed in string.
					//
					if (_strnicmp(szString, (pSubElement->apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength), uiNamespaceNameLength) == 0)
					{
						DPFX(DPFPREP, 8, "\"%hs\" begins with prefix \"%hs\" (subelement).",
							szString,
							(pSubElement->apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength));

						//
						// Cast to lose the const.
						//
						pszResult = ((char*) szString) + uiNamespaceNameLength;

						//
						// Skip the colon delimiter.
						//
						if ((*pszResult) == ':')
						{
							pszResult++;
						}
						else
						{
							DPFX(DPFPREP, 1, "\"%hs\" begins with prefix \"%hs\" but does not have colon separator (subelement)!  Continuing.",
								szString,
								(pSubElement->apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength));
						}

						goto Exit;
					}

					//
					// Namespace doesn't match
					//
#ifdef EXTRA_PARSING_SPEW
					DPFX(DPFPREP, 9, "\"%hs\" does not begin with prefix \"%hs\" (subelement).",
						szString,
						(pSubElement->apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength));
#endif // EXTRA_PARSING_SPEW
				}
				else
				{
					//
					// Namespace value is bogus, ignore it.
					//
					DPFX(DPFPREP, 1, "Ignoring namespace definition \"%hs\" with empty value string (subelement).",
						pSubElement->apszAttributeNames[dwAttribute]);
				}
			}
			else
			{
				//
				// Not an XML namespace definition.
				//

#ifdef EXTRA_PARSING_SPEW
				DPFX(DPFPREP, 9, "Attribute \"%hs\" is not a valid namespace definition (subelement).",
					pSubElement->apszAttributeNames[dwAttribute]);
#endif // EXTRA_PARSING_SPEW
			}
		} // end for (each attribute)
	}
	else
	{
		//
		// No subelement to check.
		//
	}


	//
	// Do the same thing for the all items above this one.
	//
	dwStackDepth = dwElementStackDepth;
	while (dwStackDepth > 0)
	{
		dwStackDepth--;

		//
		// Search each attribute
		//
		for(dwAttribute = 0; dwAttribute < aElementStack[dwStackDepth].dwNumAttributes; dwAttribute++)
		{
			//
			// Work with this attribute if it's a valid XML namespace
			// definition.  It needs to start with the prefix, plus have one
			// extra character for the actual name.
			//
			uiNamespaceNameLength = strlen(aElementStack[dwStackDepth].apszAttributeNames[dwAttribute]);
			if ((uiNamespaceNameLength >= (uiXMLNSPrefixLength + 1)) &&
				(_strnicmp(aElementStack[dwStackDepth].apszAttributeNames[dwAttribute], XML_NAMESPACEDEFINITIONPREFIX, uiXMLNSPrefixLength) == 0))
			{
				uiNamespaceNameLength -= uiXMLNSPrefixLength;

				//
				// Only work with the item's value if it's valid.
				//
				uiNamespaceValueLength = strlen(aElementStack[dwStackDepth].apszAttributeValues[dwAttribute]);
				if (uiNamespaceValueLength > 0)
				{
					//
					// Okay, here's an item.  See if the value prefixes the
					// passed in string.
					//
					if (_strnicmp(szString, (aElementStack[dwStackDepth].apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength), uiNamespaceNameLength) == 0)
					{
						DPFX(DPFPREP, 8, "\"%hs\" begins with prefix \"%hs\" (stack depth %u).",
							szString,
							(aElementStack[dwStackDepth].apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength),
							dwStackDepth);

						//
						// Cast to lose the const.
						//
						pszResult = ((char*) szString) + uiNamespaceNameLength;

						//
						// Skip the colon delimiter.
						//
						if ((*pszResult) == ':')
						{
							pszResult++;
						}
						else
						{
							DPFX(DPFPREP, 1, "\"%hs\" begins with prefix \"%hs\" but does not have colon separator (stack depth %u)!  Continuing.",
								szString,
								(aElementStack[dwStackDepth].apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength),
								dwStackDepth);
						}

						goto Exit;
					}

					//
					// Namespace doesn't match
					//
#ifdef EXTRA_PARSING_SPEW
					DPFX(DPFPREP, 9, "\"%hs\" does not begin with prefix \"%hs\" (stack depth %u).",
						szString,
						(aElementStack[dwStackDepth].apszAttributeNames[dwAttribute] + uiXMLNSPrefixLength),
						dwStackDepth);
#endif // EXTRA_PARSING_SPEW
				}
				else
				{
					//
					// Namespace value is bogus, ignore it.
					//
					DPFX(DPFPREP, 1, "Ignoring namespace definition \"%hs\" with empty value string (stack depth %u).",
						aElementStack[dwStackDepth].apszAttributeNames[dwAttribute],
						dwStackDepth);
				}
			}
			else
			{
				//
				// Not an XML namespace definition.
				//

#ifdef EXTRA_PARSING_SPEW
				DPFX(DPFPREP, 9, "Attribute \"%hs\" is not a valid namespace definition (stack depth %u).",
					aElementStack[dwStackDepth].apszAttributeNames[dwAttribute],
					dwStackDepth);
#endif // EXTRA_PARSING_SPEW
			}
		} // end for (each attribute)
	}


	//
	// If we're here, it didn't match, even with namespace expansion.
	//

	DPFX(DPFPREP, 8, "\"%hs\" does not contain any namespace prefixes.",
		szString);

	//
	// Cast to lose the const.
	//
	pszResult = (char*) szString;


Exit:

	return pszResult;
} // CNATHelpUPnP::GetStringWithoutNamespacePrefix






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetNextChunk"
//=============================================================================
// CNATHelpUPnP::GetNextChunk
//-----------------------------------------------------------------------------
//
// Description:    Attempts to parse the next chunk out of a message buffer.
//				If invalid data is encountered, this function returns FALSE.
//				If not enough data has been received to complete the chunk,
//				TRUE is returned, but NULL is returned in ppszChunkData.
//				Otherwise, a pointer to the start of the chunk data is placed
//				in ppszChunkData, the size of the chunk is placed in
//				pdwChunkSize, ppszBufferRemaining is set to the start of the
//				next potential chunk, and pdwBufferSizeRemaining is set to the
//				amount of the buffer remaining starting at the returned
//				ppszBufferRemaining value.
//
//				   Note that the chunk size may be zero, in which case the
//				pointer in ppszChunkData & ppszBufferRemaining will be non-
//				NULL, but useless.
//
// Arguments:
//	char * pszBuffer				- Pointer to string containing the message
//										received so far.
//	DWORD dwBufferSize				- Size of the message buffer.
//	char ** ppszChunkData			- Place to store pointer to chunk data, or
//										NULL if full chunk is not available.
//	DWORD * pdwChunkSize			- Place to store size of chunk.
//	char ** ppszBufferRemaining		- Place to store pointer to end of chunk
//										if full chunk is available.
//	DWORD * pdwBufferSizeRemaining	- Place to store size of buffer remaining
//										after returned chunk.
//
// Returns: None.
//=============================================================================
BOOL CNATHelpUPnP::GetNextChunk(char * const pszBuffer,
								const DWORD dwBufferSize,
								char ** const ppszChunkData,
								DWORD * const pdwChunkSize,
								char ** const ppszBufferRemaining,
								DWORD * const pdwBufferSizeRemaining)
{
	BOOL	fReturn = TRUE;
	char *	pszCurrent;
	char *	pszEndOfBuffer;
	BOOL	fFoundChunkSizeEnd;
	BOOL	fExtensions;
	BOOL	fInQuotedString;


	DPFX(DPFPREP, 8, "(0x%p) Parameters: (0x%p, %u, 0x%p, 0x%p, 0x%p, 0x%p)",
		this, pszBuffer, dwBufferSize, ppszChunkData, pdwChunkSize,
		ppszBufferRemaining, pdwBufferSizeRemaining);


	pszCurrent = pszBuffer;
	pszEndOfBuffer = pszCurrent + dwBufferSize;
	fFoundChunkSizeEnd = FALSE;
	fExtensions = FALSE;
	fInQuotedString = FALSE;
	(*ppszChunkData) = NULL;
	(*pdwChunkSize) = 0;


	//
	// The buffer must be large enough to hold 1 hex digit, CR LF chunk size
	// terminator, and CR LF chunk trailer.
	//
	if (dwBufferSize < 5)
	{
		DPFX(DPFPREP, 3, "Buffer is not large enough (%u bytes) to hold one valid chunk.",
			dwBufferSize);
		goto Exit;
	}

	//
	// Be paranoid to make sure we're not going to having wrap problems.
	//
	if (pszEndOfBuffer < pszCurrent)
	{
		DPFX(DPFPREP, 0, "Buffer pointer 0x%p cannot have size %u!",
			pszBuffer, dwBufferSize);
		goto Failure;
	}

	while (pszCurrent < pszEndOfBuffer)
	{
		//
		// Make sure we have a valid hex chunk size string and convert it
		// as we go.
		//
		if (((*pszCurrent) >= '0') && ((*pszCurrent) <= '9'))
		{
			(*pdwChunkSize) = ((*pdwChunkSize) * 16) + ((*pszCurrent) - '0');
		}
		else if (((*pszCurrent) >= 'a') && ((*pszCurrent) <= 'f'))
		{
			(*pdwChunkSize) = ((*pdwChunkSize) * 16) + ((*pszCurrent) - 'a' + 10);
		}
		else if (((*pszCurrent) >= 'A') && ((*pszCurrent) <= 'F'))
		{
			(*pdwChunkSize) = ((*pdwChunkSize) * 16) + ((*pszCurrent) - 'A' + 10);
		}
		else if ((*pszCurrent) == '\r')
		{
			//
			// This should be the end of the chunk size string.
			//
			fFoundChunkSizeEnd = TRUE;
			break;
		}
		else if ((*pszCurrent) == ';')
		{
			//
			// This should be the end of the chunk size string, and the
			// beginning of extensions.  Loop until we find the true end.
			//
			while ((*pszCurrent) != '\r')
			{
				pszCurrent++;
				if (pszCurrent >= pszEndOfBuffer)
				{
					DPFX(DPFPREP, 5, "Buffer stops in middle of chunk extension.");
					goto Exit;
				}

				//
				// We do not support quoted extension value strings that
				// theoretically contain CR characters...
				//
			}

			fFoundChunkSizeEnd = TRUE;
			break;
		}
		else
		{
			//
			// There's a bogus character.  This can't be a validly encoded
			// message.
			//
			DPFX(DPFPREP, 1, "Chunk size string contains invalid character 0x%x at offset %u!",
				(*pszCurrent), (DWORD_PTR) (pszCurrent - pszBuffer));
			goto Failure;
		}

		//
		// Validate the chunk size we have so far.
		//
		if ((*pdwChunkSize) > MAX_RECEIVE_BUFFER_SIZE)
		{
			DPFX(DPFPREP, 1, "Chunk size %u is too large!",
				(*pdwChunkSize));
			goto Failure;
		}

		pszCurrent++;
	}

	//
	// If we're here, see if we found the end of the chunk size string.
	// Make sure we've received enough data, and then validate that the CR
	// stopping character is followed by the LF character.
	//
	if (fFoundChunkSizeEnd)
	{
		pszCurrent++;
		if (pszCurrent < pszEndOfBuffer)
		{
			if ((*pszCurrent) != '\n')
			{
				DPFX(DPFPREP, 1, "Chunk size string did not end with CRLF sequence (offset %u)!",
					(DWORD_PTR) (pszCurrent - pszBuffer));
				goto Failure;
			}

			//
			// Otherwise we got a complete chunk size string.
			//
			pszCurrent++;

			//
			// If we have received all of the chunk already, make sure we have
			// the trailing CR LF sequence before returning the pointer to the
			// caller.
			if (((*pdwChunkSize) + 2) <= ((DWORD_PTR) (pszEndOfBuffer - pszCurrent)))
			{
				if ((*(pszCurrent + (*pdwChunkSize)) != '\r') ||
					(*(pszCurrent + (*pdwChunkSize) + 1) != '\n'))
				{
					DPFX(DPFPREP, 1, "Chunk data did not end with CRLF sequence (offset %u)!",
						(DWORD_PTR) (pszCurrent - pszBuffer + (*pdwChunkSize)));
					goto Failure;
				}

				//
				// Return the data pointers to the caller.  In the case of the
				// zero size terminating chunk, the ppszChunkData pointer will
				// actually be useless, but the caller should recognize that.
				//
				(*ppszChunkData) = pszCurrent;
				(*ppszBufferRemaining) = pszCurrent + ((*pdwChunkSize) + 2);
				(*pdwBufferSizeRemaining) = (DWORD) ((DWORD_PTR) (pszEndOfBuffer - (*ppszBufferRemaining)));
			}
		}
	}

	//
	// If we're here, we didn't encounter invalid data.
	//

Exit:

	DPFX(DPFPREP, 8, "(0x%p) Returning: [%i]", this, fReturn);

	return fReturn;


Failure:

	fReturn = FALSE;

	goto Exit;
} // CNATHelpUPnP::GetNextChunk





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ParseXMLCallback_DescriptionResponse"
//=============================================================================
// CNATHelpUPnP::ParseXMLCallback_DescriptionResponse
//-----------------------------------------------------------------------------
//
// Description: Handles a completed parsed element in the description response
//				XML.
//
// Arguments:
//	PARSEXML_ELEMENT * pParseElement	- Pointer to element which was found.
//	PVOID pvContext						- Pointer to parsing context.
//	PARSEXML_STACKENTRY * aElementStack	- Array of parent elements containing
//											the completed element. 
//	BOOL * pfContinueParsing			- Pointer to BOOL that should be set
//											to FALSE if the calling function
//											should stop parsing the XML.
//
// Returns: HRESULT
//	DPNH_OK				- Description response was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::ParseXMLCallback_DescriptionResponse(PARSEXML_ELEMENT * const pParseElement,
															PVOID pvContext,
															PARSEXML_STACKENTRY * const aElementStack,
															BOOL * const pfContinueParsing)
{
	HRESULT					hr = DPNH_OK;
	CUPnPDevice *			pUPnPDevice;
	char *					pszServiceType = NULL;
	char *					pszServiceId = NULL;
	char *					pszControlURL = NULL;
	DWORD					dwSubElement;
	PARSEXML_SUBELEMENT *	pSubElement;
	SOCKADDR_IN				saddrinControl;
	SOCKADDR_IN	*			psaddrinHost;
	char *					pszRelativePath;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p,  0x%p, 0x%p)",
		this, pParseElement, pvContext, aElementStack, pfContinueParsing);


	pUPnPDevice = (CUPnPDevice *) pvContext;


	DNASSERT(pUPnPDevice != NULL);
	DNASSERT(pParseElement->papszElementStack == (char **) (&c_szElementStack_service));


	//
	// Look for the subelements we want.
	//
	for(dwSubElement = 0; dwSubElement < pParseElement->dwNumSubElements; dwSubElement++)
	{
		pSubElement = &pParseElement->paSubElements[dwSubElement];

		if (_stricmp(pSubElement->pszNameFound, XML_DEVICEDESCRIPTION_SERVICETYPE) == 0)
		{
			if (pszServiceType == NULL)
			{
				pszServiceType = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" XML_DEVICEDESCRIPTION_SERVICETYPE "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (_stricmp(pSubElement->pszNameFound, XML_DEVICEDESCRIPTION_SERVICEID) == 0)
		{
			if (pszServiceId == NULL)
			{
				pszServiceId = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" XML_DEVICEDESCRIPTION_SERVICEID "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (_stricmp(pSubElement->pszNameFound, XML_DEVICEDESCRIPTION_CONTROLURL) == 0)
		{
			if (pszControlURL == NULL)
			{
				pszControlURL = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" XML_DEVICEDESCRIPTION_CONTROLURL "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else
		{
			DPFX(DPFPREP, 7, "Ignoring subelement \"%hs\" (value = \"%hs\").",
				pSubElement->pszNameFound, pSubElement->pszValueFound);
		}
	}


	//
	// If one of those elements was not specified, then this element is not
	// helpful.
	//
	if ((pszServiceType == NULL) || (pszServiceId == NULL) || (pszControlURL == NULL))
	{
		DPFX(DPFPREP, 1, "Couldn't find either \"" XML_DEVICEDESCRIPTION_SERVICETYPE "\", \"" XML_DEVICEDESCRIPTION_SERVICEID "\", or \"" XML_DEVICEDESCRIPTION_CONTROLURL "\" in XML description, ignoring element.");
		goto Exit;
	}


	//
	// If the service type is not one of the ones we want, ignore the element.
	//
	if (_stricmp(pszServiceType, URI_SERVICE_WANIPCONNECTION_A) == 0)
	{
		DPFX(DPFPREP, 7, "Found \"" URI_SERVICE_WANIPCONNECTION_A "\".");

		DNASSERT(! pUPnPDevice->IsWANPPPConnection());
	}
	else if (_stricmp(pszServiceType, URI_SERVICE_WANPPPCONNECTION_A) == 0)
	{
		DPFX(DPFPREP, 7, "Found \"" URI_SERVICE_WANPPPCONNECTION_A "\".");

		pUPnPDevice->NoteWANPPPConnection();
	}
	else
	{
		DPFX(DPFPREP, 1, "Ignoring unknown service type \"%hs\".", pszServiceType);
		goto Exit;
	}
	

	pParseElement->fFoundMatchingElement = TRUE;
	(*pfContinueParsing) = FALSE;



	//
	// Validate and store the service control URL.
	//

	hr = this->GetAddressFromURL(pszControlURL,
								&saddrinControl,
								&pszRelativePath);
	if (hr != DPNH_OK)
	{
		psaddrinHost = pUPnPDevice->GetHostAddress();

		DPFX(DPFPREP, 1, "No control address in URL, using host address %u.%u.%u.%u:%u and full URL as relative path (\"%hs\").",
			psaddrinHost->sin_addr.S_un.S_un_b.s_b1,
			psaddrinHost->sin_addr.S_un.S_un_b.s_b2,
			psaddrinHost->sin_addr.S_un.S_un_b.s_b3,
			psaddrinHost->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(psaddrinHost->sin_port),
			pszControlURL);

		memcpy(&saddrinControl, psaddrinHost, sizeof(SOCKADDR_IN));
		pszRelativePath = pszControlURL;
	}
	else
	{
#if 0
		//
		// Ensure that the address to use is local.  It doesn't make sense that
		// in order to make mappings for our private network we would need to
		// contact something outside.
		//
		if (! this->IsAddressLocal(pUPnPDevice->GetOwningDevice(), &saddrinControl))
		{
			DPFX(DPFPREP, 1, "Control address designated (%u.%u.%u.%u:%u) is not local, ignoring message.",
				saddrinControl.sin_addr.S_un.S_un_b.s_b1,
				saddrinControl.sin_addr.S_un.S_un_b.s_b2,
				saddrinControl.sin_addr.S_un.S_un_b.s_b3,
				saddrinControl.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinControl.sin_port));
			goto Exit;
		}
#else
		psaddrinHost = pUPnPDevice->GetHostAddress();

		//
		// Don't accept responses that refer to addresses other than the one
		// that sent this response.
		//
		if (saddrinControl.sin_addr.S_un.S_addr != psaddrinHost->sin_addr.S_un.S_addr)
		{
			DPFX(DPFPREP, 1, "Control IP address designated (%u.%u.%u.%u:%u) is not the same as host IP address (%u.%u.%u.%u:%u), ignoring message.",
				saddrinControl.sin_addr.S_un.S_un_b.s_b1,
				saddrinControl.sin_addr.S_un.S_un_b.s_b2,
				saddrinControl.sin_addr.S_un.S_un_b.s_b3,
				saddrinControl.sin_addr.S_un.S_un_b.s_b4,
				NTOHS(saddrinControl.sin_port),
				psaddrinHost->sin_addr.S_un.S_un_b.s_b1,
				psaddrinHost->sin_addr.S_un.S_un_b.s_b2,
				psaddrinHost->sin_addr.S_un.S_un_b.s_b3,
				psaddrinHost->sin_addr.S_un.S_un_b.s_b4,
				NTOHS(psaddrinHost->sin_port));
			goto Exit;
		}
#endif

		//
		// Don't accept responses that refer to ports in the reserved range
		// (less than or equal to 1024) other than the standard HTTP port.
		//
		if ((NTOHS(saddrinControl.sin_port) <= MAX_RESERVED_PORT) &&
			(saddrinControl.sin_port != HTONS(HTTP_PORT)))
		{
			DPFX(DPFPREP, 1, "Control address designated invalid port %u, ignoring message.",
				NTOHS(saddrinControl.sin_port));
			goto Exit;
		}
	}

	pUPnPDevice->SetControlAddress(&saddrinControl);


	//
	// Save the service control URL.
	//
	hr = pUPnPDevice->SetServiceControlURL(pszRelativePath);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't store service control URL!");
		goto Failure;
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	hr = DPNHERR_GENERIC;

	goto Exit;
} // CNATHelpUPnP::ParseXMLCallback_DescriptionResponse





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ParseXMLCallback_ControlResponse"
//=============================================================================
// CNATHelpUPnP::ParseXMLCallback_ControlResponse
//-----------------------------------------------------------------------------
//
// Description: Handles a completed parsed element in a control SOAP response.
//
// Arguments:
//	PARSEXML_ELEMENT * pParseElement	- Pointer to element which was found.
//	PVOID pvContext						- Pointer to parsing context.
//	PARSEXML_STACKENTRY * aElementStack	- Array of parent elements containing
//											the completed element. 
//	BOOL * pfContinueParsing			- Pointer to BOOL that should be set
//											to FALSE if the calling function
//											should stop parsing the XML.
//
// Returns: HRESULT
//	DPNH_OK				- Description response was handled successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::ParseXMLCallback_ControlResponse(PARSEXML_ELEMENT * const pParseElement,
														PVOID pvContext,
														PARSEXML_STACKENTRY * const aElementStack,
														BOOL * const pfContinueParsing)
{
	HRESULT							hr = DPNH_OK;
	PCONTROLRESPONSEPARSECONTEXT	pContext;
	//char *							pszReturn = NULL;
	char *							pszExternalIPAddress = NULL;
	char *							pszInternalPort = NULL;
	char *							pszInternalClient = NULL;
	char *							pszEnabled = NULL;
	char *							pszPortMappingDescription = NULL;
	char *							pszLeaseDuration = NULL;
	char *							pszErrorCode = NULL;
	char *							pszErrorDescription = NULL;
	DWORD							dwSubElement;
	PARSEXML_SUBELEMENT *			pSubElement;
	int								iErrorCode;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p)",
		this, pParseElement, pvContext, aElementStack, pfContinueParsing);


	pContext = (PCONTROLRESPONSEPARSECONTEXT) pvContext;


	DNASSERT(pContext != NULL);
	DNASSERT(pContext->pUPnPDevice != NULL);


	//
	// Look for the subelements we want.
	//
	for(dwSubElement = 0; dwSubElement < pParseElement->dwNumSubElements; dwSubElement++)
	{
		pSubElement = &pParseElement->paSubElements[dwSubElement];


		/*
		if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
													ARG_CONTROL_RETURN_A,
													aElementStack,
													pSubElement,
													pParseElement->dwElementStackDepth))
		{
			if (pszReturn == NULL)
			{
				pszReturn = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_CONTROL_RETURN_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		*/
		if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
													ARG_GETEXTERNALIPADDRESS_NEWEXTERNALIPADDRESS_A,
													aElementStack,
													pSubElement,
													pParseElement->dwElementStackDepth))
		{
			if (pszExternalIPAddress == NULL)
			{
				pszExternalIPAddress = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_GETEXTERNALIPADDRESS_NEWEXTERNALIPADDRESS_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALPORT_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszInternalPort == NULL)
			{
				pszInternalPort = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALPORT_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALCLIENT_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszInternalClient == NULL)
			{
				pszInternalClient = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALCLIENT_A "\" subelement (value = \"%hs\").",
					 pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_GETSPECIFICPORTMAPPINGENTRY_NEWENABLED_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszEnabled == NULL)
			{
				pszEnabled = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWENABLED_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPORTMAPPINGDESCRIPTION_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszPortMappingDescription == NULL)
			{
				pszPortMappingDescription = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPORTMAPPINGDESCRIPTION_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_GETSPECIFICPORTMAPPINGENTRY_NEWLEASEDURATION_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszLeaseDuration == NULL)
			{
				pszLeaseDuration = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWLEASEDURATION_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_CONTROL_ERROR_ERRORCODE_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszErrorCode == NULL)
			{
				pszErrorCode = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_CONTROL_ERROR_ERRORCODE_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else if (this->MatchesXMLStringWithoutNamespace(pSubElement->pszNameFound,
														ARG_CONTROL_ERROR_ERRORDESCRIPTION_A,
														aElementStack,
														pSubElement,
														pParseElement->dwElementStackDepth))
		{
			if (pszErrorDescription == NULL)
			{
				pszErrorDescription = pSubElement->pszValueFound;
			}
			else
			{
				DPFX(DPFPREP, 7, "Ignoring duplicate \"" ARG_CONTROL_ERROR_ERRORDESCRIPTION_A "\" subelement (value = \"%hs\").",
					pSubElement->pszValueFound);
			}
		}
		else
		{
			DPFX(DPFPREP, 7, "Ignoring subelement \"%hs\" (value = \"%hs\").",
				pSubElement->pszNameFound, pSubElement->pszValueFound);
		}
	} // end for (each sub element)


	if (pContext->dwHTTPResponseCode == 200)
	{
		//
		// The action succeeded.
		//

		switch (pContext->ControlResponseType)
		{
			/*
			case CONTROLRESPONSETYPE_QUERYSTATEVARIABLE_EXTERNALIPADDRESS:
			{
				if (pszReturn == NULL)
				{
					DPFX(DPFPREP, 1, "Couldn't find \"" ARG_CONTROL_RETURN_A "\" in SOAP response, ignoring element.");
					goto Exit;
				}

				DPFX(DPFPREP, 2, "QueryStateVariable returned \"%hs\".",
					pszReturn);


				/ *
				//
				// Key off of the variable we were querying.
				//
				switch (pContext->ControlResponseType)
				{
					case CONTROLRESPONSETYPE_QUERYSTATEVARIABLE_EXTERNALIPADDRESS:
					{
				* /
						pContext->pControlResponseInfo->dwExternalIPAddressV4 = this->m_pfninet_addr(pszReturn);
						if (pContext->pControlResponseInfo->dwExternalIPAddressV4 == INADDR_NONE)
						{
							DPFX(DPFPREP, 1, "External IP address string \"%hs\" is invalid, using INADDR_ANY.");
							pContext->pControlResponseInfo->dwExternalIPAddressV4 = INADDR_ANY;
						}
				/ *
						break;
					}
				}
				* /

				break;
			}
			*/
			case CONTROLRESPONSETYPE_GETEXTERNALIPADDRESS:
			{
				if (pszExternalIPAddress == NULL)
				{
					DPFX(DPFPREP, 1, "Couldn't find \"" ARG_GETEXTERNALIPADDRESS_NEWEXTERNALIPADDRESS_A "\" in SOAP response, ignoring element.");
					goto Exit;
				}

				DPFX(DPFPREP, 2, "GetExternalIPAddress returned \"%hs\".",
					pszExternalIPAddress);


				pContext->pControlResponseInfo->dwExternalIPAddressV4 = this->m_pfninet_addr(pszExternalIPAddress);
				if ((pContext->pControlResponseInfo->dwExternalIPAddressV4 == INADDR_NONE) ||
					(IS_CLASSD_IPV4_ADDRESS(pContext->pControlResponseInfo->dwExternalIPAddressV4)))
				{
					DPFX(DPFPREP, 1, "External IP address string \"%hs\" is invalid, using INADDR_ANY.");
					pContext->pControlResponseInfo->dwExternalIPAddressV4 = INADDR_ANY;
				}

				break;
			}

			case CONTROLRESPONSETYPE_ADDPORTMAPPING:
			{
				DPFX(DPFPREP, 2, "AddPortMapping got success response.");
				break;
			}

			case CONTROLRESPONSETYPE_GETSPECIFICPORTMAPPINGENTRY:
			{
				/*
				if ((pszInternalPort == NULL) ||
					(pszInternalClient == NULL) ||
					(pszEnabled == NULL) ||
					(pszPortMappingDescription == NULL) ||
					(pszLeaseDuration == NULL))
				*/
				if (pszInternalClient == NULL)
				{
					DPFX(DPFPREP, 1, "Couldn't find \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALCLIENT_A "\" in SOAP response, ignoring element.");
					goto Exit;
				}

				if (pszInternalPort == NULL)
				{
					DPFX(DPFPREP, 1, "Couldn't find \"" ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALPORT_A "\" in SOAP response, assuming asymmetric mappings are not supported.");
					pszInternalPort = "0";
				}


				DPFX(DPFPREP, 2, "GetPortMappingPrivateIP returned \"%hs:%hs\".",
					pszInternalClient, pszInternalPort);

				pContext->pControlResponseInfo->dwInternalClientV4 = this->m_pfninet_addr(pszInternalClient);
				if (pContext->pControlResponseInfo->dwInternalClientV4 == INADDR_ANY)
				{
					DPFX(DPFPREP, 0, "Internal client address is INADDR_ANY!");
					hr = DPNHERR_GENERIC;
					goto Failure;
				}
				
				pContext->pControlResponseInfo->wInternalPort = HTONS((WORD) atoi(pszInternalPort));

				break;
			}

			case CONTROLRESPONSETYPE_DELETEPORTMAPPING:
			{
				DPFX(DPFPREP, 2, "DeletePortMapping got success response.");
				break;
			}

			default:
			{
				DNASSERT(FALSE);
				hr = DPNHERR_GENERIC;
				goto Failure;
				break;
			}
		}


		//
		// The action completed successfully.
		//
		pContext->pControlResponseInfo->hrErrorCode = DPNH_OK;
	}
	else
	{
		//
		// The action failed.
		//

		//
		// See if we found an error description that we can print for
		// informational purposes.
		//
		if ((pszErrorCode != NULL) && (pszErrorDescription != NULL))
		{
			iErrorCode = atoi(pszErrorCode);
			
			switch (iErrorCode)
			{
				case UPNPERR_IGD_NOSUCHENTRYINARRAY:
				{
					DPFX(DPFPREP, 1, "Control action was rejected with NoSuchEntryInArray error %hs (description = \"%hs\").",
						pszErrorCode, pszErrorDescription);

					pContext->pControlResponseInfo->hrErrorCode = DPNHERR_NOMAPPING;
					break;
				}

				case UPNPERR_IGD_CONFLICTINMAPPINGENTRY:
				{
					DPFX(DPFPREP, 1, "Control action was rejected with ConflictInMappingEntry error %hs (description = \"%hs\").",
						pszErrorCode, pszErrorDescription);

					pContext->pControlResponseInfo->hrErrorCode = DPNHERR_PORTUNAVAILABLE;
					break;
				}

				case UPNPERR_IGD_SAMEPORTVALUESREQUIRED:
				{
					DPFX(DPFPREP, 1, "Control action was rejected with SamePortValuesRequired error %hs (description = \"%hs\").",
						pszErrorCode, pszErrorDescription);

					pContext->pControlResponseInfo->hrErrorCode = (HRESULT) UPNPERR_IGD_SAMEPORTVALUESREQUIRED;
					break;
				}

				case UPNPERR_IGD_ONLYPERMANENTLEASESSUPPORTED:
				{
					DPFX(DPFPREP, 1, "Control action was rejected with OnlyPermanentLeasesSupported error %hs (description = \"%hs\").",
						pszErrorCode, pszErrorDescription);

					pContext->pControlResponseInfo->hrErrorCode = (HRESULT) UPNPERR_IGD_ONLYPERMANENTLEASESSUPPORTED;
					break;
				}

				default:
				{
					DPFX(DPFPREP, 1, "Control action was rejected with unknown error \"%hs\", \"%hs\", assuming generic failure.",
						pszErrorCode, pszErrorDescription);

					pContext->pControlResponseInfo->hrErrorCode = DPNHERR_GENERIC;
					break;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 1, "Couldn't find either \"" ARG_CONTROL_ERROR_ERRORCODE_A "\", or \"" ARG_CONTROL_ERROR_ERRORDESCRIPTION_A "\" in SOAP response, assuming generic failure.");
			pContext->pControlResponseInfo->hrErrorCode = DPNHERR_GENERIC;
		}
	}


	//
	// If we got here, we got the information we needed.
	//
	pParseElement->fFoundMatchingElement = TRUE;
	(*pfContinueParsing) = FALSE;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::ParseXMLCallback_ControlResponse





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ClearDevicesUPnPDevice"
//=============================================================================
// CNATHelpUPnP::ClearDevicesUPnPDevice
//-----------------------------------------------------------------------------
//
// Description:    Forcefully simulates de-registration with a UPnP device
///				without actually going to the network.  This clears all bind
//				IDs, public addresses, and cached mappings for a given device's
//				local or remote server, and should only be called after the
//				server appears to have died.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose UPnP device should be
//							removed.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::ClearDevicesUPnPDevice(CDevice * const pDevice)
{
	CUPnPDevice *	pUPnPDevice;


	DNASSERT(pDevice != NULL);


	pUPnPDevice = pDevice->GetUPnPDevice();
	if (pUPnPDevice != NULL)
	{
#ifdef DBG
		DPFX(DPFPREP, 1, "Clearing device 0x%p's UPnP device (0x%p).",
			pDevice, pUPnPDevice);

		pDevice->IncrementUPnPDeviceFailures();
		this->m_dwNumServerFailures++;
#endif // DBG

		//
		// Since there was a change in the network, go back to polling
		// relatively quickly.
		//
		this->ResetNextPollInterval();


		pUPnPDevice->ClearDeviceOwner();
		DNASSERT(pUPnPDevice->m_blList.IsListMember(&this->m_blUPnPDevices));
		pUPnPDevice->m_blList.RemoveFromList();

		//
		// Transfer list reference to our pointer, since GetUPnPDevice did not give
		// us one.
		//


		if (pUPnPDevice->IsConnected())
		{
			DNASSERT(pUPnPDevice->GetControlSocket() != INVALID_SOCKET);

			this->m_pfnshutdown(pUPnPDevice->GetControlSocket(), 0); // ignore error
			this->m_pfnclosesocket(pUPnPDevice->GetControlSocket());
			pUPnPDevice->SetControlSocket(INVALID_SOCKET);
		}
		else
		{
			DNASSERT(pUPnPDevice->GetControlSocket() == INVALID_SOCKET);
		}


		this->ClearAllUPnPRegisteredPorts(pDevice);

		pUPnPDevice->ClearLocationURL();
		pUPnPDevice->ClearUSN();
		pUPnPDevice->ClearServiceControlURL();
		pUPnPDevice->DestroyReceiveBuffer();
		pUPnPDevice->RemoveAllCachedMappings();

		pUPnPDevice->DecRef();
	}
	else
	{
		DPFX(DPFPREP, 1, "Can't clear device 0x%p's UPnP device, it doesn't exist.",
			pDevice);
	}
} // CNATHelpUPnP::ClearDevicesUPnPDevice




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ClearAllUPnPRegisteredPorts"
//=============================================================================
// CNATHelpUPnP::ClearAllUPnPRegisteredPorts
//-----------------------------------------------------------------------------
//
// Description:    Clears all bind IDs and public addresses for a given
//				device's UPnP Internet gateway.  This should only be called
//				after the UPnP device dies.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose ports should be unbound.
//	BOOL fRemote		- TRUE if clearing remote server, FALSE if clearing
//							local server.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::ClearAllUPnPRegisteredPorts(CDevice * const pDevice)
{
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DNASSERT(pDevice != NULL);


	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

		if (pRegisteredPort->HasUPnPPublicAddresses())
		{
			if (! pRegisteredPort->IsRemovingUPnPLease())
			{
				DPFX(DPFPREP, 1, "Registered port 0x%p losing UPnP public address.",
					pRegisteredPort);

				//
				// Let the user know the next time GetCaps is called.
				//
				this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;


				//
				// Note that this means the crash recovery entry will be left
				// in the registry for the next person to come along and clean
				// up.  That should be okay, since we should only be doing this
				// if we had a problem talking to the UPnP device (either it
				// went AWOL, or we lost the local network interface).  In
				// either case, we can't really clean it up now, so we have to
				// leave it for someone else to do.
				//

				pRegisteredPort->DestroyUPnPPublicAddressesArray();
				pRegisteredPort->NoteNotPermanentUPnPLease();

				DNASSERT(this->m_dwNumLeases > 0);
				this->m_dwNumLeases--;

				DPFX(DPFPREP, 7, "UPnP lease for 0x%p cleared, total num leases = %u.",
					pRegisteredPort, this->m_dwNumLeases);
			}
			else
			{
				DPFX(DPFPREP, 1, "Registered port 0x%p already has had UPnP public address removed, skipping.",
					pRegisteredPort);
			}
		}
		else
		{
			//
			// Port no longer unavailable (if it had been).
			//
			pRegisteredPort->NoteNotUPnPPortUnavailable();
		}

		pBilink = pBilink->GetNext();
	}
} // CNATHelpUPnP::ClearAllUPnPRegisteredPorts






#ifndef DPNBUILD_NOWINSOCK2


#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::RequestLocalAddressListChangeNotification"
//=============================================================================
// CNATHelpUPnP::RequestLocalAddressListChangeNotification
//-----------------------------------------------------------------------------
//
// Description:    Attempts to request asynchronous notification (via the
//				user's alert event or I/O completion port) when the local
//				address list changes.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK				- The notification request was successfully submitted.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::RequestLocalAddressListChangeNotification(void)
{
	HRESULT		hr;
	DWORD		dwTemp;
	int			iReturn;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1));
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	DNASSERT(this->m_pfnWSAIoctl != NULL);
	DNASSERT((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL));
	DNASSERT(this->m_polAddressListChange != NULL);


	do
	{
		iReturn = this->m_pfnWSAIoctl(this->m_sIoctls,				// use the special Ioctl socket
									SIO_ADDRESS_LIST_CHANGE,		//
									NULL,							// no input data
									0,								// no input data
									NULL,							// no output data
									0,								// no output data
									&dwTemp,						// ignore bytes returned
									this->m_polAddressListChange,	// overlapped structure
									NULL);							// no completion routine

		if (iReturn != 0)
		{
			dwTemp = this->m_pfnWSAGetLastError();
			if (dwTemp != WSA_IO_PENDING)
			{
				DPFX(DPFPREP, 0, "Submitting address list change notification request failed (err = %u)!", dwTemp);
				hr = DPNHERR_GENERIC;
				goto Failure;
			}


			//
			// Pending is what we want, we're set.
			//
			hr = DPNH_OK;
			break;
		}


		//
		// Address list changed right away?
		//
		DPFX(DPFPREP, 1, "Address list changed right away somehow, submitting again.");
	}
	while (TRUE);



Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::RequestLocalAddressListChangeNotification


#endif // ! DPNBUILD_NOWINSOCK2





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CreateSocket"
//=============================================================================
// CNATHelpUPnP::CreateSocket
//-----------------------------------------------------------------------------
//
// Description:    Creates a UPnP discovery socket bound to a new random port
//				on the specified IP interface.  Completely random (but non-
//				reserved) port numbers are chosen first, but if those ports are
//				in use, WinSock is allowed to choose.  The port actually
//				selected will be returned in psaddrinAddress.
//
// Arguments:
//	SOCKADDR_IN * psaddrinAddress	- Pointer to base address to use when
//										binding.  The port will be modified.
//
// Returns: SOCKET
//=============================================================================
SOCKET CNATHelpUPnP::CreateSocket(SOCKADDR_IN * const psaddrinAddress,
								int iType,
								int iProtocol)
{
	SOCKET	sTemp;
	DWORD	dwTry;
	int		iTemp;
	BOOL	fTemp;
	ULONG	ulEnable;
#ifdef DBG
	DWORD	dwError;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, %i)",
		this, psaddrinAddress, iType, iProtocol);


	//
	// Create the socket.
	//
	sTemp = this->m_pfnsocket(AF_INET, iType, iProtocol);
	if (sTemp == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create datagram socket, error = %u!", dwError);
#endif // DBG
		goto Failure;
	}


	//
	// Try binding the socket to a completely random port a few times.
	//
	for(dwTry = 0; dwTry < MAX_NUM_RANDOM_PORT_TRIES; dwTry++)
	{
		//
		// Pick a completely random port.  For the moment, the value is stored
		// in host byte order while we make sure it's not a reserved value.
		//
		do
		{
			psaddrinAddress->sin_port = (WORD) GetGlobalRand();
		}
		while ((psaddrinAddress->sin_port <= MAX_RESERVED_PORT) ||
				(psaddrinAddress->sin_port == 1900) ||	// SSDP
				(psaddrinAddress->sin_port == 2234) ||	// PAST
				(psaddrinAddress->sin_port == 6073) ||	// DPNSVR
				(psaddrinAddress->sin_port == 47624));	// DPLAYSVR

		//
		// Now try binding to the port (in network byte order).
		//
		psaddrinAddress->sin_port = HTONS(psaddrinAddress->sin_port);
		if (this->m_pfnbind(sTemp, (SOCKADDR*) psaddrinAddress, sizeof(SOCKADDR_IN)) == 0)
		{
			//
			// We successfully bound to the port.
			//
			break;
		}

		//
		// Assume that the port is in use.
		//
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 2, "Couldn't bind to port %u (err = %u), continuing.",
			NTOHS(psaddrinAddress->sin_port), dwError);
#endif // DBG

		psaddrinAddress->sin_port = 0;
	}


	//
	// If we ran out of completely random port attempts, just let WinSock
	// choose it.
	//
	if (psaddrinAddress->sin_port == 0)
	{
		if (this->m_pfnbind(sTemp, (SOCKADDR*) psaddrinAddress, sizeof(SOCKADDR_IN)) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Failed binding to any port (err = %u)!",
				dwError);
#endif // DBG
			goto Failure;
		}


		//
		// Find out what port WinSock chose.
		//
		iTemp = sizeof(SOCKADDR_IN);
		if (this->m_pfngetsockname(sTemp,
								(SOCKADDR *) psaddrinAddress,
								&iTemp) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't get the socket's address, error = %u!",
				dwError);
#endif // DBG
			goto Failure;
		}
		DNASSERT(psaddrinAddress->sin_port != 0);
	}


	//
	// Set the unicast TTL, if requested.  Use the appropriate constant for the
	// version of WinSock we're using.
	//
	if (g_iUnicastTTL != 0)
	{
		iTemp = this->m_pfnsetsockopt(sTemp,
									IPPROTO_IP,
#ifdef DPNBUILD_NOWINSOCK2
									IP_TTL,
#else // ! DPNBUILD_NOWINSOCK2
									((this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1) ? IP_TTL_WINSOCK1 : IP_TTL),
#endif // ! DPNBUILD_NOWINSOCK2
									(char *) (&g_iUnicastTTL),
									sizeof(g_iUnicastTTL));
		if (iTemp != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't set unicast TTL socket option, error = %u!  Ignoring.",
				dwError);
#endif // DBG

			//
			// Continue...
			//
		}
	}


	if (iType == SOCK_DGRAM)
	{
		if (g_fUseMulticastUPnPDiscovery)
		{
			//
			// Set the multicast interface.  Use the appropriate constant for
			// the version of WinSock we're using.
			//
			iTemp = this->m_pfnsetsockopt(sTemp,
										IPPROTO_IP,
#ifdef DPNBUILD_NOWINSOCK2
										IP_MULTICAST_IF,
#else // ! DPNBUILD_NOWINSOCK2
										((this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1) ? IP_MULTICAST_IF_WINSOCK1 : IP_MULTICAST_IF),
#endif // ! DPNBUILD_NOWINSOCK2
										(char *) (&psaddrinAddress->sin_addr.S_un.S_addr),
										sizeof(psaddrinAddress->sin_addr.S_un.S_addr));
			if (iTemp != 0)
			{
#ifdef DBG
				dwError = this->m_pfnWSAGetLastError();
				DPFX(DPFPREP, 1, "Couldn't set multicast interface socket option, error = %u, ignoring.",
					dwError);
#endif // DBG

				//
				// Continue...
				//
			}


			//
			// Set the multicast TTL, if requested.  Use the appropriate
			// constant for the version of WinSock we're using.
			//
			if (g_iMulticastTTL != 0)
			{
				iTemp = this->m_pfnsetsockopt(sTemp,
											IPPROTO_IP,
#ifdef DPNBUILD_NOWINSOCK2
											IP_MULTICAST_TTL,
#else // ! DPNBUILD_NOWINSOCK2
											((this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1) ? IP_MULTICAST_TTL_WINSOCK1 : IP_MULTICAST_TTL),
#endif // ! DPNBUILD_NOWINSOCK2
											(char *) (&g_iMulticastTTL),
											sizeof(g_iMulticastTTL));
				if (iTemp != 0)
				{
#ifdef DBG
					dwError = this->m_pfnWSAGetLastError();
					DPFX(DPFPREP, 0, "Couldn't set multicast TTL socket option, error = %u!  Ignoring.",
						dwError);
#endif // DBG

					//
					// Continue...
					//
				}
			}
		}
		else
		{
			//
			// Not using multicast.  Set the socket up to allow broadcasts in
			// case we can't determine the gateway.
			//
			fTemp = TRUE;
			if (this->m_pfnsetsockopt(sTemp,
									SOL_SOCKET,
									SO_BROADCAST,
									(char *) (&fTemp),
									sizeof(fTemp)) != 0)
			{
#ifdef DBG
				dwError = this->m_pfnWSAGetLastError();
				DPFX(DPFPREP, 0, "Couldn't set broadcast socket option, error = %u!", dwError);
#endif // DBG
				goto Failure;
			}
		}
	}
	else
	{
		//
		// Make the socket non-blocking.
		//
		ulEnable = 1;
		if (this->m_pfnioctlsocket(sTemp, FIONBIO, &ulEnable) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't make socket non-blocking, error = %u!", dwError);
#endif // DBG
			goto Failure;
		}
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%x]", this, sTemp);

	return sTemp;


Failure:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	goto Exit;
} // CNATHelpUPnP::CreateSocket







#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetAddressToReachGateway"
//=============================================================================
// CNATHelpUPnP::GetAddressToReachGateway
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the address of the gateway for the given device,
//				or the broadcast address if unable to be determined.
//
//				   This will return TRUE if the gateway's address was found, or
//				the IPHLPAPI DLL could not be used (Win95).  FALSE is returned
//				if IPHLPAPI reported that there was no gateway (ICS private
//				side adapter).
//
// Arguments:
//	CDevice * pDevice	- Pointer to device whose gateway should be retrieved.
//	IN_ADDR * pinaddr	- Place to store gateway or broadcast address.
//
// Returns: BOOL
//	TRUE	- Gateway address was found or had to use broadcast.
//	FALSE	- There is no gateway, do not attempt to use the address.
//=============================================================================
BOOL CNATHelpUPnP::GetAddressToReachGateway(CDevice * const pDevice,
											IN_ADDR * const pinaddr)
{
#ifdef DPNBUILD_NOWINSOCK2
	//
	// Fill in the default address.  This should be atomic, so don't worry
	// about locking the globals.
	//
	pinaddr->S_un.S_addr = g_dwDefaultGatewayV4;

	return TRUE;
#else // ! DPNBUILD_NOWINSOCK2
	DWORD					dwError;
	BOOL					fResult = TRUE;
	ULONG					ulSize;
	PIP_ADAPTER_INFO		pAdaptersBuffer = NULL;
	PIP_ADAPTER_INFO		pAdapterInfo;
	PIP_ADDR_STRING			pIPAddrString;
	DWORD					dwAdapterIndex;
	PMIB_IPFORWARDTABLE		pIPForwardTableBuffer = NULL;
	DWORD					dwTemp;
	PMIB_IPFORWARDROW 		pIPForwardRow;



	//
	// Fill in the default address.  This should be atomic, so don't worry
	// about locking the globals.
	//
	pinaddr->S_un.S_addr = g_dwDefaultGatewayV4;

#ifdef DBG
	pDevice->ClearGatewayFlags();
#endif // DBG


	//
	// If this is the loopback address, then don't bother looking for a
	// gateway, we won't find one.
	//
	if (pDevice->GetLocalAddressV4() == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		DPFX(DPFPREP, 8, "No gateway for loopback address (device = 0x%p).",
			pDevice);

		//
		// No gateway.
		//
#ifdef DBG
		pDevice->NoteNoGateway();
#endif // DBG
		fResult = FALSE;
		goto Exit;
	}


	//
	// If we didn't load the IP helper DLL, we can't do our fancy gateway
	// tricks.
	//
	if (this->m_hIpHlpApiDLL == NULL)
	{
		DPFX(DPFPREP, 4, "Didn't load \"iphlpapi.dll\", returning default address for device 0x%p.",
			pDevice);
		goto Exit;
	}


	//
	// Keep trying to get the list of adapters until we get ERROR_SUCCESS or a
	// legitimate error (other than ERROR_BUFFER_OVERFLOW or
	// ERROR_INSUFFICIENT_BUFFER).
	//
	ulSize = 0;
	do
	{
		dwError = this->m_pfnGetAdaptersInfo(pAdaptersBuffer, &ulSize);
		if (dwError == ERROR_SUCCESS)
		{
			//
			// We succeeded, we should be set.  But make sure there are
			// adapters for us to use.
			//
			if (ulSize < sizeof(IP_ADAPTER_INFO))
			{
				DPFX(DPFPREP, 0, "Getting adapters info succeeded but didn't return any valid adapters (%u < %u), returning default address for device 0x%p.",
					ulSize, sizeof(IP_ADAPTER_INFO), pDevice);
				goto Exit;
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "Unable to get adapters info (error = 0x%lx), returning default address for device 0x%p.",
				dwError, pDevice);
			goto Exit;
		}

		//
		// We need more adapter space.  Make sure there are adapters for us to
		// use.
		//
		if (ulSize < sizeof(IP_ADAPTER_INFO))
		{
			DPFX(DPFPREP, 0, "Getting adapters info didn't return any valid adapters (%u < %u), returning default address for device 0x%p.",
				ulSize, sizeof(IP_ADAPTER_INFO), pDevice);
			goto Exit;
		}

		//
		// If we previously had a buffer, free it.
		//
		if (pAdaptersBuffer != NULL)
		{
			DNFree(pAdaptersBuffer);
		}

		//
		// Allocate the buffer.
		//
		pAdaptersBuffer = (PIP_ADAPTER_INFO) DNMalloc(ulSize);
		if (pAdaptersBuffer == NULL)
		{
			DPFX(DPFPREP, 0, "Unable to allocate memory for adapters info, returning default address for device 0x%p.",
				pDevice);
			goto Exit;
		}
	}
	while (TRUE);


	//
	// Now find the device in the adapter list returned.  Loop through all
	// adapters.
	//
	pAdapterInfo = pAdaptersBuffer;
	while (pAdapterInfo != NULL)
	{
		//
		// Loop through all addresses for this adapter looking for the one for
		// the device we have bound.
		//
		pIPAddrString = &pAdapterInfo->IpAddressList;
		while (pIPAddrString != NULL)
		{
			if (this->m_pfninet_addr(pIPAddrString->IpAddress.String) == pDevice->GetLocalAddressV4())
			{
				pinaddr->S_un.S_addr = this->m_pfninet_addr(pAdapterInfo->GatewayList.IpAddress.String);
				if ((pinaddr->S_un.S_addr == INADDR_ANY) ||
					(pinaddr->S_un.S_addr == INADDR_NONE))
				{
					DPFX(DPFPREP, 8, "Found address for device 0x%p under adapter index %u (\"%hs\") but there is no gateway.",
						pDevice, pAdapterInfo->Index, pAdapterInfo->Description);

					//
					// Although this isn't reporting a gateway, we may still
					// want to use this adapter.  That's because this could be
					// a multihomed machine with multiple NICs on the same
					// network, where this one isn't the "default" adapter.
					// So save the index so we can search for it later.
					//
					dwAdapterIndex = pAdapterInfo->Index;

					goto CheckRouteTable;
				}


				//
				// Make sure the address doesn't match the local device.
				//
				if (pinaddr->S_un.S_addr == pDevice->GetLocalAddressV4())
				{
					DPFX(DPFPREP, 1, "Gateway address for device 0x%p (adapter index %u, \"%hs\") matches device IP address %hs!  Forcing no gateway.",
						pDevice, pAdapterInfo->Index, pAdapterInfo->Description,
						pAdapterInfo->GatewayList.IpAddress.String);

					//
					// Pretend there's no gateway, since the one we received is
					// bogus.
					//
#ifdef DBG
					pDevice->NoteNoGateway();
#endif // DBG
					fResult = FALSE;
				}
				else
				{
					DPFX(DPFPREP, 7, "Found address for device 0x%p under adapter index %u (\"%hs\"), gateway = %hs.",
						pDevice, pAdapterInfo->Index, pAdapterInfo->Description,
						pAdapterInfo->GatewayList.IpAddress.String);

#ifdef DBG
					pDevice->NotePrimaryDevice();
#endif // DBG
				}

				goto Exit;
			}

			pIPAddrString = pIPAddrString->Next;
		}

		if (! fResult)
		{
			break;
		}

		pAdapterInfo = pAdapterInfo->Next;
	}


	//
	// If we got here, then we didn't find the address.  fResult will still be
	// TRUE.
	//
	DPFX(DPFPREP, 0, "Did not find adapter with matching address, returning default address for device 0x%p.",
		pDevice);
	goto Exit;


CheckRouteTable:

	//
	// The adapter info structure said that the device doesn't have a gateway.
	// However for some reason the gateway is only reported for the "default"
	// device when multiple NICs can reach the same network.  Check the routing
	// table to determine if there's a gateway for secondary devices.
	//

	//
	// Keep trying to get the routing table until we get ERROR_SUCCESS or a
	// legitimate error (other than ERROR_BUFFER_OVERFLOW or
	// ERROR_INSUFFICIENT_BUFFER).
	//
	ulSize = 0;
	do
	{
		dwError = this->m_pfnGetIpForwardTable(pIPForwardTableBuffer, &ulSize, TRUE);
		if (dwError == ERROR_SUCCESS)
		{
			//
			// We succeeded, we should be set.  But make sure the size is
			// valid.
			//
			if (ulSize < sizeof(MIB_IPFORWARDTABLE))
			{
				DPFX(DPFPREP, 0, "Getting IP forward table succeeded but didn't return a valid buffer (%u < %u), returning \"no gateway\" indication for device 0x%p.",
					ulSize, sizeof(MIB_IPFORWARDTABLE), pDevice);
				fResult = FALSE;
				goto Exit;
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "Unable to get IP forward table (error = 0x%lx), returning \"no gateway\" indication for device 0x%p.",
				dwError, pDevice);
			fResult = FALSE;
			goto Exit;
		}

		//
		// We need more table space.  Make sure there are adapters for us to
		// use.
		//
		if (ulSize < sizeof(MIB_IPFORWARDTABLE))
		{
			DPFX(DPFPREP, 0, "Getting IP forward table didn't return any valid adapters (%u < %u), returning \"no gateway\" indication for device 0x%p.",
				ulSize, sizeof(MIB_IPFORWARDTABLE), pDevice);
			fResult = FALSE;
			goto Exit;
		}

		//
		// If we previously had a buffer, free it.
		//
		if (pIPForwardTableBuffer != NULL)
		{
			DNFree(pIPForwardTableBuffer);
		}

		//
		// Allocate the buffer.
		//
		pIPForwardTableBuffer = (PMIB_IPFORWARDTABLE) DNMalloc(ulSize);
		if (pIPForwardTableBuffer == NULL)
		{
			DPFX(DPFPREP, 0, "Unable to allocate memory for IP forward table, returning \"no gateway\" indication for device 0x%p.",
				pDevice);
			fResult = FALSE;
			goto Exit;
		}
	}
	while (TRUE);
	
	
	//
	// Now find the interface.  Note that we don't look it up as a destination
	// address.  Instead, we look for it as the interface to use for a 0.0.0.0
	// network destination.
	//
	// We're looking for a route entry:
	//
	//	Network Destination		Netmask		Gateway				Interface			Metric
	//	0.0.0.0					0.0.0.0		xxx.xxx.xxx.xxx		yyy.yyy.yyy.yyy		1
	//
	// We have yyy.yyy.yyy.yyy, we're trying to get xxx.xxx.xxx.xxx
	//
	pIPForwardRow = pIPForwardTableBuffer->table;
	for(dwTemp = 0; dwTemp < pIPForwardTableBuffer->dwNumEntries; dwTemp++)
	{
		//
		// Is this a 0.0.0.0 network destination?
		//
		if (pIPForwardRow->dwForwardDest == INADDR_ANY)
		{
			DNASSERT(pIPForwardRow->dwForwardMask == INADDR_ANY);


			//
			// Is this the right interface?
			//
			if (pIPForwardRow->dwForwardIfIndex == dwAdapterIndex)
			{
				if (pIPForwardRow->dwForwardNextHop == INADDR_ANY)
				{
					DPFX(DPFPREP, 8, "Found route table entry, but it didn't have a gateway (device = 0x%p).",
						pDevice);

					//
					// No gateway.
					//
#ifdef DBG
					pDevice->NoteNoGateway();
#endif // DBG
					fResult = FALSE;
				}
				else
				{
					//
					// Make sure the address doesn't match the local device.
					//
					if (pinaddr->S_un.S_addr == pDevice->GetLocalAddressV4())
					{
						DPFX(DPFPREP, 1, "Route table gateway for device 0x%p matches device's IP address %u.%u.%u.%u!  Forcing no gateway.",
							pDevice,
							pinaddr->S_un.S_un_b.s_b1,
							pinaddr->S_un.S_un_b.s_b2,
							pinaddr->S_un.S_un_b.s_b3,
							pinaddr->S_un.S_un_b.s_b4);

						//
						// Pretend there's no gateway, since the one we
						// received is bogus.
						//
#ifdef DBG
						pDevice->NoteNoGateway();
#endif // DBG
						fResult = FALSE;
					}
					else
					{
						pinaddr->S_un.S_addr = pIPForwardRow->dwForwardNextHop;

						DPFX(DPFPREP, 8, "Found route table entry, gateway = %u.%u.%u.%u (device = 0x%p).",
							pinaddr->S_un.S_un_b.s_b1,
							pinaddr->S_un.S_un_b.s_b2,
							pinaddr->S_un.S_un_b.s_b3,
							pinaddr->S_un.S_un_b.s_b4,
							pDevice);

						//
						// We found a gateway after all, fResult == TRUE.
						//
#ifdef DBG
						pDevice->NoteSecondaryDevice();
#endif // DBG
					}
				}

				//
				// We're done here.
				//
				goto Exit;
			}
		}

		//
		// Move to next row.
		//
		pIPForwardRow++;
	}

	
	//
	// If we got here, then we couldn't find an appropriate entry in the
	// routing table.
	//
	DPFX(DPFPREP, 1, "Did not find adapter in routing table, returning \"no gateway\" indication for device 0x%p.",
		pDevice);
#ifdef DBG
	pDevice->NoteNoGateway();
#endif // DBG
	fResult = FALSE;


Exit:

	if (pAdaptersBuffer != NULL)
	{
		DNFree(pAdaptersBuffer);
		pAdaptersBuffer = NULL;
	}

	if (pIPForwardTableBuffer != NULL)
	{
		DNFree(pIPForwardTableBuffer);
		pIPForwardTableBuffer = NULL;
	}

	return fResult;
#endif // ! DPNBUILD_NOWINSOCK2
} // CNATHelpUPnP::GetAddressToReachGateway







#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::IsAddressLocal"
//=============================================================================
// CNATHelpUPnP::IsAddressLocal
//-----------------------------------------------------------------------------
//
// Description:    Returns TRUE if the given address is local to the given
//				device; that is, if the device can send to the address directly
//				without having to go through the gateway.
//
//				   Note that if IPHLPAPI is not available (Win95), this
//				function will make an educated guess using a reasonable subnet
//				mask.
//
// Arguments:
//	CDevice * pDevice				- Pointer to device to use.
//	SOCKADDR_IN * psaddrinAddress	- Address whose locality is in question.
//
// Returns: BOOL
//	TRUE	- Address is behind the same gateway as the device.
//	FALSE	- Address is not behind the same gateway as the device.
//=============================================================================
BOOL CNATHelpUPnP::IsAddressLocal(CDevice * const pDevice,
								const SOCKADDR_IN * const psaddrinAddress)
{
	BOOL				fResult;
	DWORD				dwSubnetMaskV4;
#ifndef DPNBUILD_NOWINSOCK2
	DWORD				dwError;
	MIB_IPFORWARDROW	IPForwardRow;
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// If the address to query matches the device's local address exactly, then
	// of course it's local.
	//
	if (psaddrinAddress->sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4())
	{
		DPFX(DPFPREP, 6, "The address %u.%u.%u.%u matches device 0x%p's local address exactly.",
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			pDevice);
		fResult = TRUE;
		goto Exit;
	}

	//
	// If it's a multicast address, then it should not be considered local.
	//
	if (IS_CLASSD_IPV4_ADDRESS(psaddrinAddress->sin_addr.S_un.S_addr))
	{
		DPFX(DPFPREP, 6, "Address %u.%u.%u.%u is multicast, not considered local for device 0x%p.",
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			pDevice);
		fResult = FALSE;
		goto Exit;
	}
	

#ifndef DPNBUILD_NOWINSOCK2
	//
	// If we didn't load the IP helper DLL, we will have to guess.
	//
	if (this->m_hIpHlpApiDLL == NULL)
	{
		goto EducatedGuess;
	}


	//
	// Figure out what IPHLPAPI says about how to get there.
	//
	
	ZeroMemory(&IPForwardRow, sizeof(IPForwardRow));

	dwError = this->m_pfnGetBestRoute(psaddrinAddress->sin_addr.S_un.S_addr,
									pDevice->GetLocalAddressV4(),
									&IPForwardRow);
	if (dwError != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, 0, "Unable to get best route to %u.%u.%u.%u via device 0x%p (error = 0x%lx)!  Using subnet mask.",
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			pDevice,
			dwError);
		goto EducatedGuess;
	}


	//
	// Key off what IPHLPAPI returned.
	//
	switch (IPForwardRow.dwForwardType)
	{
		case 1:
		{
			//
			// Other.
			//
			DPFX(DPFPREP, 6, "The route from device 0x%p to %u.%u.%u.%u is unknown.",
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}

		case 2:
		{
			//
			// The route is invalid.
			//
			DPFX(DPFPREP, 6, "The route from device 0x%p to %u.%u.%u.%u is invalid.",
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}

		case 3:
		{
			//
			// The next hop is the final destination (local route).
			// Unfortunately, on multi-NIC machines querying an address
			// reachable by another device returns success... not sure why, but
			// if that's the case we need to further qualify this result.  We
			// do that by making sure the next hop address is actually the
			// device with which we're querying.
			//
			if (IPForwardRow.dwForwardNextHop == pDevice->GetLocalAddressV4())
			{
				DPFX(DPFPREP, 6, "Device 0x%p can reach %u.%u.%u.%u directly, it's local.",
					pDevice,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);

				fResult = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 6, "Device 0x%p can reach %u.%u.%u.%u but it would be routed via another device (%u.%u.%u.%u).",
					pDevice,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
					psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b1,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b2,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b3,
					((IN_ADDR*) (&IPForwardRow.dwForwardNextHop))->S_un.S_un_b.s_b4);

				fResult = FALSE;
			}
			break;
		}

		case 4:
		{
			//
			// The next hop is not the final destination (remote route).
			//
			DPFX(DPFPREP, 6, "Device 0x%p cannot reach %u.%u.%u.%u directly.",
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}

		default:
		{
			//
			// What?
			//
			DPFX(DPFPREP, 0, "Unexpected forward type %u for device 0x%p and address %u.%u.%u.%u!",
				IPForwardRow.dwForwardType,
				pDevice,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
				psaddrinAddress->sin_addr.S_un.S_un_b.s_b4);
			fResult = FALSE;
			break;
		}
	}

	goto Exit;


EducatedGuess:
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// This should be atomic, so don't worry about locking.
	//
	dwSubnetMaskV4 = g_dwSubnetMaskV4;

	if ((pDevice->GetLocalAddressV4() & dwSubnetMaskV4) == (psaddrinAddress->sin_addr.S_un.S_addr & dwSubnetMaskV4))
	{
		DPFX(DPFPREP, 4, "Didn't load \"iphlpapi.dll\", guessing that device 0x%p can reach %u.%u.%u.%u (using subnet mask 0x%08x).",
			pDevice,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			dwSubnetMaskV4);
		fResult = TRUE;
	}
	else
	{
		DPFX(DPFPREP, 4, "Didn't load \"iphlpapi.dll\", guessing that device 0x%p cannot reach %u.%u.%u.%u (using subnet mask 0x%08x).",
			pDevice,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b1,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b2,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b3,
			psaddrinAddress->sin_addr.S_un.S_un_b.s_b4,
			dwSubnetMaskV4);
		fResult = FALSE;
	}


Exit:

	return fResult;
} // CNATHelpUPnP::IsAddressLocal






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ExpireOldCachedMappings"
//=============================================================================
// CNATHelpUPnP::ExpireOldCachedMappings
//-----------------------------------------------------------------------------
//
// Description:    Removes any cached mappings for any device which has
//				expired.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::ExpireOldCachedMappings(void)
{
	DWORD			dwCurrentTime;
	CBilink *		pBilinkUPnPDevice;
	CBilink *		pCachedMaps;
	CBilink *		pBilinkCacheMap;
	CCacheMap *		pCacheMap;
	CUPnPDevice *	pUPnPDevice;


	DPFX(DPFPREP, 7, "(0x%p) Enter", this);


	dwCurrentTime = GETTIMESTAMP();


	//
	// Check the UPnP device cached mappings.
	//
	pBilinkUPnPDevice = this->m_blUPnPDevices.GetNext();
	while (pBilinkUPnPDevice != &this->m_blUPnPDevices)
	{
		DNASSERT(! pBilinkUPnPDevice->IsEmpty());
		pUPnPDevice = UPNPDEVICE_FROM_BILINK(pBilinkUPnPDevice);


		//
		// Check the actual cached mappings.
		//
		pCachedMaps = pUPnPDevice->GetCachedMaps();
		pBilinkCacheMap = pCachedMaps->GetNext();
		while (pBilinkCacheMap != pCachedMaps)
		{
			DNASSERT(! pBilinkCacheMap->IsEmpty());
			pCacheMap = CACHEMAP_FROM_BILINK(pBilinkCacheMap);
			pBilinkCacheMap = pBilinkCacheMap->GetNext();

			if ((int) (pCacheMap->GetExpirationTime() - dwCurrentTime) < 0)
			{
				DPFX(DPFPREP, 5, "UPnP device 0x%p cached mapping 0x%p has expired.",
					pUPnPDevice, pCacheMap);

				pCacheMap->m_blList.RemoveFromList();
				delete pCacheMap;
			}
		}

		pBilinkUPnPDevice = pBilinkUPnPDevice->GetNext();
	}


	DPFX(DPFPREP, 7, "(0x%p) Leave", this);
} // CNATHelpUPnP::ExpireOldCachedMappings





#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::IsUPnPServiceDisabled"
//=============================================================================
// CNATHelpUPnP::IsUPnPServiceDisabled
//-----------------------------------------------------------------------------
//
// Description:    Returns TRUE if at least one UPnP related service is
//				disabled, FALSE if no UPnP related services are disabled.
//
// Arguments:
//	char * szString			- Pointer to string to print.
//	int iStringLength		- Length of string to print.
//	char * szDescription	- Description header for the transaction.
//	CDevice * pDevice		- Device handling transaction, or NULL if not
//								known.
//
// Returns: BOOL
//	TRUE	- A UPnP related service was disabled.
//	FALSE	- No UPnP related services were disabled.
//=============================================================================
BOOL CNATHelpUPnP::IsUPnPServiceDisabled(void)
{
	BOOL					fResult = FALSE;
	SC_HANDLE				schSCManager = NULL;
	DWORD					dwTemp;
	SC_HANDLE				schService = NULL;
	QUERY_SERVICE_CONFIG *	pQueryServiceConfig = NULL;
	DWORD					dwQueryServiceConfigSize = 0;
	DWORD					dwError;


	schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (schSCManager == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't open SC Manager (err = %u)!", dwError);
#endif // DBG
		goto Exit;
	}


	//
	// Loop through each relevant service.
	//
	for(dwTemp = 0; dwTemp < (sizeof(c_tszUPnPServices) / sizeof(TCHAR*)); dwTemp++)
	{
		schService = OpenService(schSCManager, c_tszUPnPServices[dwTemp], SERVICE_QUERY_CONFIG);
		if (schService != NULL)
		{
			do
			{
				if (QueryServiceConfig(schService,
										pQueryServiceConfig,
										dwQueryServiceConfigSize,
										&dwQueryServiceConfigSize))
				{
					//
					// Make sure the size written is valid.
					//
					if (dwQueryServiceConfigSize < sizeof(QUERY_SERVICE_CONFIG))
					{
						DPFX(DPFPREP, 0, "Got invalid service config size for \"%s\" (%u < %u)!",
							c_tszUPnPServices[dwTemp], dwQueryServiceConfigSize, sizeof(QUERY_SERVICE_CONFIG));
						goto Exit;
					}

					break;
				}
				
				
				//
				// Otherwise, we failed.  Make sure it's because our buffer was
				// too small.
				//
				dwError = GetLastError();
				if (dwError != ERROR_INSUFFICIENT_BUFFER)
				{
					DPFX(DPFPREP, 0, "Couldn't query \"%s\" service config (err = %u)!",
						c_tszUPnPServices[dwTemp], dwError);
					goto Exit;
				}


				//
				// Make sure the size needed is valid.
				//
				if (dwQueryServiceConfigSize < sizeof(QUERY_SERVICE_CONFIG))
				{
					DPFX(DPFPREP, 0, "Got invalid service config size for \"%s\" (%u < %u)!",
						c_tszUPnPServices[dwTemp], dwQueryServiceConfigSize, sizeof(QUERY_SERVICE_CONFIG));
					goto Exit;
				}


				//
				// (Re)-allocate the buffer.
				//

				if (pQueryServiceConfig != NULL)
				{
					DNFree(pQueryServiceConfig);
				}

				pQueryServiceConfig = (QUERY_SERVICE_CONFIG*) DNMalloc(dwQueryServiceConfigSize);
				if (pQueryServiceConfig == NULL)
				{
					DPFX(DPFPREP, 0, "Couldn't allocate memory to query service config.");
					goto Exit;
				}
			}
			while (TRUE);


			//
			// If the service was disabled, we're done here.
			//
			if (pQueryServiceConfig->dwStartType == SERVICE_DISABLED)
			{
				DPFX(DPFPREP, 1, "The \"%s\" service has been disabled.",
					c_tszUPnPServices[dwTemp]);
				fResult = TRUE;
				goto Exit;
			}

			DPFX(DPFPREP, 7, "The \"%s\" service is not disabled (start type = %u).",
				c_tszUPnPServices[dwTemp], pQueryServiceConfig->dwStartType);
		}
		else
		{
			//
			// Win2K doesn't have these services, so it will always fail.
			//
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 1, "Couldn't open \"%s\" service (err = %u), continuing.",
				c_tszUPnPServices[dwTemp], dwError);
#endif // DBG
		}
	}


Exit:

	if (pQueryServiceConfig != NULL)
	{
		DNFree(pQueryServiceConfig);
		pQueryServiceConfig = NULL;
	}

	if (schService != NULL)
	{
		CloseServiceHandle(schService);
		schService = NULL;
	}

	if (schSCManager != NULL)
	{
		CloseServiceHandle(schSCManager);
		schSCManager = NULL;
	}

	return fResult;
} // CNATHelpUPnP::IsUPnPServiceDisabled

#endif // WINNT





#ifdef DBG

#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::PrintUPnPTransactionToFile"
//=============================================================================
// CNATHelpUPnP::PrintUPnPTransactionToFile
//-----------------------------------------------------------------------------
//
// Description:    Prints a given UPnP transaction to the file if logging is
//				enabled.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	char * szString			- Pointer to string to print.
//	int iStringLength		- Length of string to print.
//	char * szDescription	- Description header for the transaction.
//	CDevice * pDevice		- Device handling transaction, or NULL if not
//								known.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::PrintUPnPTransactionToFile(const char * const szString,
											const int iStringLength,
											const char * const szDescription,
											CDevice * const pDevice)
{
	DNHANDLE	hFile;
	DWORD		dwNumBytesWritten;
	TCHAR		tszHeaderPrefix[256];
	DWORD		dwError;
#ifdef UNICODE
	char		szHeaderPrefix[256];
#endif // UNICODE


	//
	// Lock the globals so nobody touches the string while we use it.
	//
	DNEnterCriticalSection(&g_csGlobalsLock);


	//
	// Only print it if UPnP transaction logging is turned on.
	//
	if (wcslen(g_wszUPnPTransactionLog) > 0)
	{
#ifndef UNICODE
		HRESULT		hr;
		char		szUPnPTransactionLog[sizeof(g_wszUPnPTransactionLog) / sizeof(WCHAR)];
		DWORD		dwLength;


		//
		// Convert the Unicode file name/path into ANSI.
		//

		dwLength = sizeof(szUPnPTransactionLog) / sizeof(char);

		hr = STR_WideToAnsi(g_wszUPnPTransactionLog,
							-1,								// NULL terminated
							szUPnPTransactionLog,
							&dwLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert UPnP transaction log file string from Unicode to ANSI (err = 0x%lx)!",
				hr);
			hFile = DNINVALID_HANDLE_VALUE;
		}
		else
		{
			//
			// Open the file if it exists, or create a new one if it doesn't.
			//
			hFile = DNCreateFile(szUPnPTransactionLog,
								(GENERIC_READ | GENERIC_WRITE),
								FILE_SHARE_READ,
								NULL,
								OPEN_ALWAYS,
								0,
								NULL);
		}
#else // UNICODE
		//
		// Open the file if it exists, or create a new one if it doesn't.
		//
		hFile = DNCreateFile(g_wszUPnPTransactionLog,
						(GENERIC_READ | GENERIC_WRITE),
						FILE_SHARE_READ,
						NULL,
						OPEN_ALWAYS,
						0,
						NULL);
#endif // UNICODE

		if (hFile == DNINVALID_HANDLE_VALUE)
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't open UPnP transaction log file, err = %u!",
				dwError);
		}
		else
		{
			//
			// Move the write pointer to the end of the file unless the file
			// has exceeded the maximum size, in which case just start over.
			// Ignore error.
			//
			if (GetFileSize(HANDLE_FROM_DNHANDLE(hFile), NULL) >= MAX_TRANSACTION_LOG_SIZE)
			{
				DPFX(DPFPREP, 0, "Transaction log maximum size exceeded, overwriting existing contents!");
				SetFilePointer(HANDLE_FROM_DNHANDLE(hFile), 0, NULL, FILE_BEGIN);
			}
			else
			{
				SetFilePointer(HANDLE_FROM_DNHANDLE(hFile), 0, NULL, FILE_END);
			}


			//
			// Write the descriptive header.  Ignore errors.
			//

			if (pDevice != NULL)
			{
				IN_ADDR		inaddr;


				inaddr.S_un.S_addr = pDevice->GetLocalAddressV4();

				wsprintf(tszHeaderPrefix,
						_T("%u\t0x%lx\t0x%lx\t(0x%p, %u.%u.%u.%u) UPnP transaction \""),
						GETTIMESTAMP(),
						GetCurrentProcessId(),
						GetCurrentThreadId(),
						pDevice,
						inaddr.S_un.S_un_b.s_b1,
						inaddr.S_un.S_un_b.s_b2,
						inaddr.S_un.S_un_b.s_b3,
						inaddr.S_un.S_un_b.s_b4);
			}
			else
			{
				wsprintf(tszHeaderPrefix,
						_T("%u\t0x%lx\t0x%lx\t(no device) UPnP transaction \""),
						GETTIMESTAMP(),
						GetCurrentProcessId(),
						GetCurrentThreadId());
			}

#ifdef UNICODE
			STR_jkWideToAnsi(szHeaderPrefix,
							tszHeaderPrefix,
							(_tcslen(tszHeaderPrefix) + 1));
			WriteFile(HANDLE_FROM_DNHANDLE(hFile), szHeaderPrefix, strlen(szHeaderPrefix), &dwNumBytesWritten, NULL);
#else // ! UNICODE
			WriteFile(HANDLE_FROM_DNHANDLE(hFile), tszHeaderPrefix, _tcslen(tszHeaderPrefix), &dwNumBytesWritten, NULL);
#endif // ! UNICODE

			WriteFile(HANDLE_FROM_DNHANDLE(hFile), szDescription, strlen(szDescription), &dwNumBytesWritten, NULL);

			WriteFile(HANDLE_FROM_DNHANDLE(hFile), "\"\r\n", strlen("\"\r\n"), &dwNumBytesWritten, NULL);


			//
			// Write the transaction.  Ignore error.
			//
			WriteFile(HANDLE_FROM_DNHANDLE(hFile), szString, iStringLength, &dwNumBytesWritten, NULL);


			//
			// Add blank space.  Ignore error.
			//
			WriteFile(HANDLE_FROM_DNHANDLE(hFile), "\r\n\r\n", strlen("\r\n\r\n"), &dwNumBytesWritten, NULL);


			//
			// Truncate the log at this point in case we are overwriting
			// existing contents.  Ignore error.
			//
			SetEndOfFile(HANDLE_FROM_DNHANDLE(hFile));

			//
			// Close the file.
			//
			DNCloseHandle(hFile);
		}
	}


	//
	// Drop the globals lock.
	//
	DNLeaveCriticalSection(&g_csGlobalsLock);

} // CNATHelpUPnP::PrintUPnPTransactionToFile






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DebugPrintCurrentStatus"
//=============================================================================
// CNATHelpUPnP::DebugPrintCurrentStatus
//-----------------------------------------------------------------------------
//
// Description:    Prints all the devices and mappings to the debug log
//				routines.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::DebugPrintCurrentStatus(void)
{
	CBilink *			pBilinkDevice;
	CBilink *			pBilinkRegisteredPort;
	CDevice *			pDevice;
	CRegisteredPort *	pRegisteredPort;
	IN_ADDR				inaddrTemp;
	DWORD				dwTemp;
	SOCKADDR_IN *		pasaddrinTemp;
	SOCKADDR_IN *		pasaddrinPrivate;
	CUPnPDevice *		pUPnPDevice;
	SOCKADDR_IN *		pasaddrinUPnPPublic;


	DPFX(DPFPREP, 3, "Object flags = 0x%08x", this->m_dwFlags);

	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		DNASSERT(! pBilinkDevice->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
			
		inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();

		DPFX(DPFPREP, 3, "Device 0x%p (%u.%u.%u.%u):",
			pDevice,
			inaddrTemp.S_un.S_un_b.s_b1,
			inaddrTemp.S_un.S_un_b.s_b2,
			inaddrTemp.S_un.S_un_b.s_b3,
			inaddrTemp.S_un.S_un_b.s_b4);


		//
		// Print the search information.  We should have detected it by now.
		//

		if (pDevice->IsPerformingRemoteUPnPDiscovery())
		{
			if (pDevice->GotRemoteUPnPDiscoveryConnReset())
			{
				DPFX(DPFPREP, 3, "     Performed remote UPnP discovery (from port %u), but got conn reset.",
					NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
			}
			else
			{
				DPFX(DPFPREP, 3, "     Performed remote UPnP discovery (from port %u).",
					NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
			}
		}
		else
		{
			//DPFX(DPFPREP, 3, "     Didn't perform remote UPnP discovery (from port %u).",
			//	NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
		}

		if (pDevice->IsPerformingLocalUPnPDiscovery())
		{
			if (pDevice->GotLocalUPnPDiscoveryConnReset())
			{
				DPFX(DPFPREP, 3, "     Performed local UPnP discovery (from port %u), but got conn reset.",
					NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
			}
			else
			{
				DPFX(DPFPREP, 3, "     Performed local UPnP discovery (from port %u).",
					NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
			}
		}
		else
		{
			//DPFX(DPFPREP, 3, "     Didn't perform local UPnP discovery (from port %u).",
			//	NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
		}


#ifndef DPNBUILD_NOWINSOCK2
		//
		// Print the gateway information.  We may not have detected it yet,
		// that's okay.
		//
		if (pDevice->IsPrimaryDevice())
		{
			DPFX(DPFPREP, 3, "     Primary device.");
		}
		else if (pDevice->IsSecondaryDevice())
		{
			DPFX(DPFPREP, 3, "     Secondary device.");
		}
		else if (pDevice->HasNoGateway())
		{
			DPFX(DPFPREP, 3, "     Has no gateway.");
		}
		else
		{
			DPFX(DPFPREP, 3, "     No gateway information known.");
		}
#endif // ! DPNBUILD_NOWINSOCK2


#ifndef DPNBUILD_NOHNETFWAPI
		if (pDevice->IsHNetFirewalled())
		{
			DPFX(DPFPREP, 3, "     HNet firewalled.");
		}
		else
		{
			DNASSERT(! pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall());
		}

		if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
		{
			DNASSERT(pDevice->IsHNetFirewalled());
			DPFX(DPFPREP, 3, "     UPnP discovery socket (port %u) mapped on HNet firewall.",
				NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			pasaddrinTemp = pUPnPDevice->GetControlAddress();

			DPFX(DPFPREP, 3, "     UPnP device (0x%p, ID = %u, control = %u.%u.%u.%u:%u).",
				pUPnPDevice, pUPnPDevice->GetID(),
				pasaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
				pasaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
				pasaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
				pasaddrinTemp->sin_addr.S_un.S_un_b.s_b4,
				NTOHS(pasaddrinTemp->sin_port));

			if (pasaddrinTemp->sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4())
			{
				DPFX(DPFPREP, 3, "          Is local.");
			}


			DNASSERT(pUPnPDevice->IsReady());

			if (pUPnPDevice->IsConnected())
			{
				DPFX(DPFPREP, 3, "          Is connected.");
			}

			if (pUPnPDevice->DoesNotSupportAsymmetricMappings())
			{
				DPFX(DPFPREP, 3, "          Does not support asymmetric mappings.");
			}

			if (pUPnPDevice->DoesNotSupportLeaseDurations())
			{
				DPFX(DPFPREP, 3, "          Does not support lease durations.");
			}

			inaddrTemp.S_un.S_addr = pUPnPDevice->GetExternalIPAddressV4();
			if (pUPnPDevice->GetExternalIPAddressV4() == 0)
			{
				DPFX(DPFPREP, 3, "          Does not have a valid external IP address.");
			}
			else
			{
				DPFX(DPFPREP, 3, "          Has external IP %u.%u.%u.%u.",
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);
			}
		}


		if (pDevice->m_blOwnedRegPorts.IsEmpty())
		{
			DPFX(DPFPREP, 3, "     No registered port mappings.");
		}
		else
		{
			DPFX(DPFPREP, 3, "     Registered port mappings:");


			pBilinkRegisteredPort = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilinkRegisteredPort != &pDevice->m_blOwnedRegPorts)
			{
				DNASSERT(! pBilinkRegisteredPort->IsEmpty());
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
					
				pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

				if ((pDevice->GetUPnPDevice() != NULL) &&
					(! pRegisteredPort->IsUPnPPortUnavailable()))
				{
					if (pRegisteredPort->HasUPnPPublicAddresses())
					{
						pasaddrinUPnPPublic = pRegisteredPort->GetUPnPPublicAddressesArray();
					}
					else
					{
						pasaddrinUPnPPublic = NULL;
					}
				}
				else
				{
					pasaddrinUPnPPublic = NULL;
				}


				DPFX(DPFPREP, 3, "          Registered port 0x%p:",
					pRegisteredPort);

				for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
				{
					//
					// Print private address.
					//
					DPFX(DPFPREP, 3, "               %u-\tPrivate       = %u.%u.%u.%u:%u",
						dwTemp,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b1,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b2,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b3,
						pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b4,
						NTOHS(pasaddrinPrivate[dwTemp].sin_port));

					//
					// Print flags.
					//
					DPFX(DPFPREP, 3, "                \tFlags         = 0x%lx",
						pRegisteredPort->GetFlags());

					//
					// Print UPnP information.
					//
					if (pasaddrinUPnPPublic != NULL)
					{
						if (pRegisteredPort->HasPermanentUPnPLease())
						{
							DPFX(DPFPREP, 3, "                \tUPnP          = %u.%u.%u.%u:%u, permanently leased",
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b1,
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b2,
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b3,
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b4,
								NTOHS(pasaddrinUPnPPublic[dwTemp].sin_port));
						}
						else
						{
							DPFX(DPFPREP, 3, "                \tUPnP          = %u.%u.%u.%u:%u, lease expires at %u",
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b1,
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b2,
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b3,
								pasaddrinUPnPPublic[dwTemp].sin_addr.S_un.S_un_b.s_b4,
								NTOHS(pasaddrinUPnPPublic[dwTemp].sin_port),
								pRegisteredPort->GetUPnPLeaseExpiration());
						}
					}
					else if (pRegisteredPort->IsUPnPPortUnavailable())
					{
						DPFX(DPFPREP, 3, "                \tUPnP          = port unavailable");
					}
					else if (pDevice->GetUPnPDevice() != NULL)
					{
						DPFX(DPFPREP, 3, "                \tUPnP          = not registered");
					}
					else
					{
						//
						// No UPnP gateway device.
						//
					}


#ifndef DPNBUILD_NOHNETFWAPI
					//
					// Print firewall status.
					//
					if (pRegisteredPort->IsMappedOnHNetFirewall())
					{
						DNASSERT(pDevice->IsHNetFirewalled());

						if (pRegisteredPort->IsHNetFirewallMappingBuiltIn())
						{
							DPFX(DPFPREP, 3, "                \tHNet firewall = built-in mapping");
						}
						else
						{
							DPFX(DPFPREP, 3, "                \tHNet firewall = mapped");
						}
					}
					else if (pRegisteredPort->IsHNetFirewallPortUnavailable())
					{
						DNASSERT(! pRegisteredPort->IsMappedOnHNetFirewall());

						DPFX(DPFPREP, 3, "                \tHNet firewall = port unavailable");
					}
					else
					{
						//
						// It is not mapped on the firewall.
						//
						DNASSERT(! pDevice->IsHNetFirewalled());
						DNASSERT(! pRegisteredPort->IsMappedOnHNetFirewall());
						DNASSERT(! pRegisteredPort->IsHNetFirewallMappingBuiltIn());
					}
#endif // ! DPNBUILD_NOHNETFWAPI
				}

				pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();
			}
		}


		pBilinkDevice = pBilinkDevice->GetNext();
	}



	if (this->m_blUnownedPorts.IsEmpty())
	{
		DPFX(DPFPREP, 3, "No unowned registered port mappings.");
	}
	else
	{
		DPFX(DPFPREP, 3, "Unowned registered port mappings:");


		pBilinkRegisteredPort = this->m_blUnownedPorts.GetNext();
		while (pBilinkRegisteredPort != &this->m_blUnownedPorts)
		{
			DNASSERT(! pBilinkRegisteredPort->IsEmpty());
			pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegisteredPort);
				
			pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

			DNASSERT(pRegisteredPort->GetOwningDevice() == NULL);
			DNASSERT(! (pRegisteredPort->HasUPnPPublicAddresses()));
#ifndef DPNBUILD_NOHNETFWAPI
			DNASSERT(! (pRegisteredPort->IsMappedOnHNetFirewall()));
#endif // ! DPNBUILD_NOHNETFWAPI


			DPFX(DPFPREP, 3, "     Registered port 0x%p:", pRegisteredPort);

			for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
			{
				//
				// Print private address.
				//
				DPFX(DPFPREP, 3, "          %u-\tPrivate = %u.%u.%u.%u:%u",
					dwTemp,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b1,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b2,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b3,
					pasaddrinPrivate[dwTemp].sin_addr.S_un.S_un_b.s_b4,
					NTOHS(pasaddrinPrivate[dwTemp].sin_port));

				//
				// Print flags.
				//
				DPFX(DPFPREP, 3, "           \tFlags   = 0x%lx",
					pRegisteredPort->GetFlags());
			}

			pBilinkRegisteredPort = pBilinkRegisteredPort->GetNext();
		}
	}
} // CNATHelpUPnP::DebugPrintCurrentStatus





#ifndef DPNBUILD_NOHNETFWAPI


#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DebugPrintActiveFirewallMappings"
//=============================================================================
// CNATHelpUPnP::DebugPrintActiveFirewallMappings
//-----------------------------------------------------------------------------
//
// Description:    Prints all the active firewall mapping registry entries to
//				the debug log routines.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::DebugPrintActiveFirewallMappings(void)
{
	HRESULT						hr = DPNH_OK;
	CRegistry					RegObject;
	DWORD						dwIndex;
	WCHAR						wszValueName[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DWORD						dwValueNameSize;
	DPNHACTIVEFIREWALLMAPPING	dpnhafm;
	DWORD						dwValueSize;
	TCHAR						tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	DNHANDLE					hNamedObject = NULL;


	if (! RegObject.Open(HKEY_LOCAL_MACHINE,
						DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS,
						FALSE,
						TRUE,
						TRUE,
						DPN_KEY_ALL_ACCESS))
	{
		DPFX(DPFPREP, 1, "Couldn't open active firewall mapping key, not dumping entries (local instance = %u).",
			this->m_dwInstanceKey);
	}
	else
	{
		//
		// Walk the list of active mappings.
		//
		dwIndex = 0;
		do
		{
			dwValueNameSize = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
			if (! RegObject.EnumValues(wszValueName, &dwValueNameSize, dwIndex))
			{
				//
				// There was an error or there aren't any more keys.  We're done.
				//
				break;
			}


			//
			// Try reading that mapping's data.
			//
			dwValueSize = sizeof(dpnhafm);
			if ((! RegObject.ReadBlob(wszValueName, (LPBYTE) (&dpnhafm), &dwValueSize)) ||
				(dwValueSize != sizeof(dpnhafm)) ||
				(dpnhafm.dwVersion != ACTIVE_MAPPING_VERSION))
			{
				DPFX(DPFPREP, 1, "Couldn't read \"%ls\" mapping value (index %u) or it was invalid!  Ignoring.",
					wszValueName, dwIndex);
			}
			else
			{
				//
				// See if that DPNHUPNP instance is still around.
				//

#ifndef WINCE
				if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
				{
					wsprintf(tszObjectName, _T( "Global\\" ) INSTANCENAMEDOBJECT_FORMATSTRING, dpnhafm.dwInstanceKey);
				}
				else
#endif // ! WINCE
				{
					wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, dpnhafm.dwInstanceKey);
				}

				hNamedObject = DNOpenEvent(SYNCHRONIZE, FALSE, tszObjectName);
				if (hNamedObject != NULL)
				{
					//
					// This is still an active mapping.
					//

					DPFX(DPFPREP, 5, "%u: Firewall mapping \"%ls\" belongs to instance %u (local instance = %u), which is still active.",
						dwIndex, wszValueName, dpnhafm.dwInstanceKey,
						this->m_dwInstanceKey);

					DNCloseHandle(hNamedObject);
					hNamedObject = NULL;
				}
				else
				{
					DPFX(DPFPREP, 5, "%u: Firewall mapping \"%ls\" belongs to instance %u (local instance = %u), which no longer exists.",
						dwIndex, wszValueName, dpnhafm.dwInstanceKey,
						this->m_dwInstanceKey);
				}
			}

			//
			// Move to next item.
			//
			dwIndex++;
		}
		while (TRUE);


		//
		// Close the registry object.
		//
		RegObject.Close();


		DPFX(DPFPREP, 5, "Done reading %u registry entries (local instance = %u).",
			dwIndex, this->m_dwInstanceKey);
	}
} // CNATHelpUPnP::DebugPrintActiveFirewallMappings

#endif // ! DPNBUILD_NOHNETFWAPI






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DebugPrintActiveNATMappings"
//=============================================================================
// CNATHelpUPnP::DebugPrintActiveNATMappings
//-----------------------------------------------------------------------------
//
// Description:    Prints all the active NAT mapping registry entries to the
//				debug log routines.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::DebugPrintActiveNATMappings(void)
{
	HRESULT					hr = DPNH_OK;
	CRegistry				RegObject;
	DWORD					dwIndex;
	WCHAR					wszValueName[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DWORD					dwValueNameSize;
	DPNHACTIVENATMAPPING	dpnhanm;
	DWORD					dwValueSize;
	TCHAR					tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	DNHANDLE				hNamedObject = NULL;


	if (! RegObject.Open(HKEY_LOCAL_MACHINE,
						DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVENATMAPPINGS,
						FALSE,
						TRUE,
						TRUE,
						DPN_KEY_ALL_ACCESS))
	{
		DPFX(DPFPREP, 1, "Couldn't open active NAT mapping key, not dumping entries (local instance = %u).",
			this->m_dwInstanceKey);
	}
	else
	{
		//
		// Walk the list of active mappings.
		//
		dwIndex = 0;
		do
		{
			dwValueNameSize = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
			if (! RegObject.EnumValues(wszValueName, &dwValueNameSize, dwIndex))
			{
				//
				// There was an error or there aren't any more keys.  We're done.
				//
				break;
			}


			//
			// Try reading that mapping's data.
			//
			dwValueSize = sizeof(dpnhanm);
			if ((! RegObject.ReadBlob(wszValueName, (LPBYTE) (&dpnhanm), &dwValueSize)) ||
				(dwValueSize != sizeof(dpnhanm)) ||
				(dpnhanm.dwVersion != ACTIVE_MAPPING_VERSION))
			{
				DPFX(DPFPREP, 1, "Couldn't read \"%ls\" mapping value (index %u) or it was invalid!  Ignoring.",
					wszValueName, dwIndex);
			}
			else
			{
				//
				// See if that DPNHUPNP instance is still around.
				//

#ifndef WINCE
				if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
				{
					wsprintf(tszObjectName, _T( "Global\\" ) INSTANCENAMEDOBJECT_FORMATSTRING, dpnhanm.dwInstanceKey);
				}
				else
#endif // ! WINCE
				{
					wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, dpnhanm.dwInstanceKey);
				}

				hNamedObject = DNOpenEvent(SYNCHRONIZE, FALSE, tszObjectName);
				if (hNamedObject != NULL)
				{
					//
					// This is still an active mapping.
					//

					DPFX(DPFPREP, 5, "%u: NAT mapping \"%ls\" belongs to instance %u UPnP device %u (local instance = %u), which is still active.",
						dwIndex, wszValueName, dpnhanm.dwInstanceKey,
						dpnhanm.dwUPnPDeviceID, this->m_dwInstanceKey);

					DNCloseHandle(hNamedObject);
					hNamedObject = NULL;
				}
				else
				{
					DPFX(DPFPREP, 5, "%u: NAT mapping \"%ls\" belongs to instance %u UPnP device %u (local instance = %u), which no longer exists.",
						dwIndex, wszValueName, dpnhanm.dwInstanceKey,
						dpnhanm.dwUPnPDeviceID, this->m_dwInstanceKey);
				}
			}

			//
			// Move to next item.
			//
			dwIndex++;
		}
		while (TRUE);


		//
		// Close the registry object.
		//
		RegObject.Close();


		DPFX(DPFPREP, 5, "Done reading %u registry entries (local instance = %u).",
			dwIndex, this->m_dwInstanceKey);
	}
} // CNATHelpUPnP::DebugPrintActiveNATMappings

#endif // DBG





#undef DPF_MODNAME
#define DPF_MODNAME "strtrim"
//=============================================================================
// strtrim
//-----------------------------------------------------------------------------
//
// Description: Removes surrounding white space from the given string.  Taken
//				from \nt\net\upnp\ssdp\common\ssdpparser\parser.cpp (author
//				TingCai).
//
// Arguments:
//	CHAR ** pszStr	- Pointer to input string, and place to store resulting
//						pointer.
//
// Returns: None.
//=============================================================================
VOID strtrim(CHAR ** pszStr)
{

    CHAR *end;
    CHAR *begin;

    // Empty string. Nothing to do.
    //
    if (!(**pszStr))
    {
        return;
    }

    begin = *pszStr;
    end = begin + strlen(*pszStr) - 1;

    while (*begin == ' ' || *begin == '\t')
    {
        begin++;
    }

    *pszStr = begin;

    while (*end == ' ' || *end == '\t')
    {
        end--;
    }

    *(end+1) = '\0';
} // strtrim




#ifdef WINCE


#undef DPF_MODNAME
#define DPF_MODNAME "GetExeName"
//=============================================================================
// GetExeName
//-----------------------------------------------------------------------------
//
// Description: Updates a path string to hold only the executable name
//				contained in the path.
//
// Arguments:
//	WCHAR * wszPath		- Input path string, and place to store resulting
//							string.
//
// Returns: None.
//=============================================================================
void GetExeName(WCHAR * wszPath)
{
	WCHAR *	pCurrent;


	pCurrent = wszPath + wcslen(wszPath);
	while (pCurrent > wszPath)
	{
		if ((*pCurrent) == L'\\')
		{
			break;
		}

		pCurrent--;
	}

	if (pCurrent != wszPath)
	{
		memcpy(wszPath, (pCurrent + 1), ((wcslen(pCurrent) + 1) * sizeof(WCHAR)));
	}
} // GetExeName


#endif // WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnplocals.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnplocals.h
 *
 *  Content:	Header for DPNHUPNP global variables and functions found in
 *				dpnhupnpdllmain.cpp.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Registry locations
//=============================================================================
#define REGKEY_COMPONENTSUBKEY			L"DPNHUPnP"

#ifndef DPNBUILD_NOHNETFWAPI
#define REGKEY_ACTIVEFIREWALLMAPPINGS	L"ActiveFirewallMappings"
#endif // ! DPNBUILD_NOHNETFWAPI
#define REGKEY_ACTIVENATMAPPINGS		L"ActiveNATMappings"




///=============================================================================
// External defines
//=============================================================================
#define OVERRIDEMODE_DEFAULT		0	// leave settings alone
#define OVERRIDEMODE_FORCEON		1	// force it to be on, regardless of Initialize flags
#define OVERRIDEMODE_FORCEOFF		2	// force it to be off, regardless of Initialize flags




///=============================================================================
// External variable references
//=============================================================================
extern volatile LONG		g_lOutstandingInterfaceCount;

extern DNCRITICAL_SECTION	g_csGlobalsLock;
extern CBilink				g_blNATHelpUPnPObjs;
extern DWORD				g_dwHoldRand;

extern DWORD				g_dwUPnPMode;
#ifndef DPNBUILD_NOHNETFWAPI
extern DWORD				g_dwHNetFWAPIMode;
#endif // ! DPNBUILD_NOHNETFWAPI
extern DWORD				g_dwSubnetMaskV4;
extern DWORD				g_dwNoActiveNotifyPollInterval;
extern DWORD				g_dwMinUpdateServerStatusInterval;
extern BOOL					g_fNoAsymmetricMappings;
extern BOOL					g_fUseLeaseDurations;
extern INT					g_iUnicastTTL;
extern INT					g_iMulticastTTL;
extern DWORD				g_dwUPnPAnnounceResponseWaitTime;
extern DWORD				g_dwUPnPConnectTimeout;
extern DWORD				g_dwUPnPResponseTimeout;
#ifndef DPNBUILD_NOHNETFWAPI
extern BOOL					g_fMapUPnPDiscoverySocket;
#endif // ! DPNBUILD_NOHNETFWAPI
extern BOOL					g_fUseMulticastUPnPDiscovery;
extern DWORD				g_dwDefaultGatewayV4;
extern DWORD				g_dwPollIntervalBackoff;
extern DWORD				g_dwMaxPollInterval;
extern BOOL					g_fKeepPollingForRemoteGateway;
extern DWORD				g_dwReusePortTime;
extern DWORD				g_dwCacheLifeFound;
extern DWORD				g_dwCacheLifeNotFound;
#ifdef DBG
extern WCHAR				g_wszUPnPTransactionLog[256];
#endif // DBG





//=============================================================================
// External function references
//=============================================================================
void ReadRegistrySettings(void);
DWORD GetGlobalRand(void);

#ifndef WINCE
#ifdef DBG

void SetDefaultProxyBlanket(IUnknown * pUnk, const char * const szObjectName);
#define SETDEFAULTPROXYBLANKET(p)	SetDefaultProxyBlanket(p, #p)

#else // ! DBG

void SetDefaultProxyBlanket(IUnknown * pUnk);
#define SETDEFAULTPROXYBLANKET(p)	SetDefaultProxyBlanket(p)

#endif // ! DBG
#endif // ! WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\sources.inc ===
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dpnhupnpi.h
PRECOMPILED_PCH=dpnhupnpi.pch
PRECOMPILED_OBJ=dpnhupnpi.obj

TARGETNAME=dpnhupnp
TARGETTYPE=DYNLINK

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

INCLUDES=$(DXROOT)\inc; \
	$(NET_INC_PATH); \
	..\..\common; \
	..\..\inc; \
	..\

SOURCES=..\dpnhupnp.rc \
	..\dpnhupnpclassfac.cpp \
	..\dpnhupnpdllmain.cpp \
	..\dpnhupnpintfobj.cpp

TARGETLIBS=$(TARGETLIBS) \
	..\..\guids\$(PLAT_DIR)\$(O)\guids.lib \
	..\..\common\$(PLAT_DIR)\$(O)\common.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpregport.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpregport.h
 *
 *  Content:	Header for registered port object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define REGPORTOBJ_TCP								DPNHREGISTERPORTS_TCP			// TCP ports instead of UDP
#define REGPORTOBJ_FIXEDPORTS						DPNHREGISTERPORTS_FIXEDPORTS	// the UPnP device should use same port numbers on public interface
#define REGPORTOBJ_SHAREDPORTS						DPNHREGISTERPORTS_SHAREDPORTS	// the UPnP device should allow these UDP fixed ports to be shared with other clients

#ifndef DPNBUILD_NOHNETFWAPI
#define REGPORTOBJ_MAPPEDONHNETFIREWALL				0x80000000						// the port has been mapped with the local HomeNet API aware firewall
#define REGPORTOBJ_PORTUNAVAILABLE_HNETFIREWALL		0x40000000						// the port is unavailable on the local HomeNet API aware firewall
#define REGPORTOBJ_HNETFIREWALLMAPPINGBUILTIN		0x20000000						// the mapping on the HomeNet API aware firewall was already built-in
#endif // ! DPNBUILD_NOHNETFWAPI
#define REGPORTOBJ_PORTUNAVAILABLE_UPNP				0x10000000						// the port is unavailable on the UPnP device
#define REGPORTOBJ_PERMANENTUPNPLEASE				0x08000000						// the port is permanently leased on the UPnP device
#define REGPORTOBJ_REMOVINGUPNPLEASE				0x04000000						// the port is currently losing it's UPnP lease

#define REGPORTOBJMASK_UPNP							(REGPORTOBJ_TCP | REGPORTOBJ_FIXEDPORTS | REGPORTOBJ_SHAREDPORTS)
#ifndef DPNBUILD_NOHNETFWAPI
#define REGPORTOBJMASK_HNETFWAPI					(REGPORTOBJ_TCP | REGPORTOBJ_FIXEDPORTS | REGPORTOBJ_SHAREDPORTS | REGPORTOBJ_HNETFIREWALLMAPPINGBUILTIN)
#endif // ! DPNBUILD_NOHNETFWAPI




//=============================================================================
// Macros
//=============================================================================
#define REGPORT_FROM_GLOBAL_BILINK(b)	(CONTAINING_OBJECT(b, CRegisteredPort, m_blGlobalList))
#define REGPORT_FROM_DEVICE_BILINK(b)	(CONTAINING_OBJECT(b, CRegisteredPort, m_blDeviceList))






//=============================================================================
// Registered port object class
//=============================================================================
class CRegisteredPort
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::CRegisteredPort"
		CRegisteredPort(const DWORD dwRequestedLeaseTime,
						const DWORD dwFlags)
		{
			this->m_blGlobalList.Initialize();
			this->m_blDeviceList.Initialize();

			this->m_Sig[0] = 'R';
			this->m_Sig[1] = 'E';
			this->m_Sig[2] = 'G';
			this->m_Sig[3] = 'P';

			this->m_pOwningDevice					= NULL;
			this->m_pasaddrinPrivateAddresses		= NULL;
			this->m_dwNumAddresses					= 0;
			this->m_dwRequestedLeaseTime			= dwRequestedLeaseTime;
			this->m_dwFlags							= dwFlags; // works because REGPORTOBJ_xxx == DPNHREGISTERPORTS_xxx.
			this->m_lUserRefs						= 0;

			this->m_pasaddrinUPnPPublicAddresses	= NULL;
			this->m_dwUPnPLeaseExpiration			= 0;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::~CRegisteredPort"
		~CRegisteredPort(void)
		{
			DNASSERT(this->m_blGlobalList.IsEmpty());
			DNASSERT(this->m_blDeviceList.IsEmpty());

#ifndef DPNBUILD_NOHNETFWAPI
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_MAPPEDONHNETFIREWALL));
#endif // ! DPNBUILD_NOHNETFWAPI
			DNASSERT(this->m_lUserRefs == 0);
			DNASSERT(this->m_pasaddrinPrivateAddresses == NULL);

			DNASSERT(this->m_pasaddrinUPnPPublicAddresses == NULL);


			//
			// For grins, change the signature before deleting the object.
			//
			this->m_Sig[3]	= 'p';
		};


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CRegisteredPort))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x50474552)	// 0x50 0x47 0x45 0x52 = 'PGER' = 'REGP' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};


		//
		// You must have global object lock to call this function.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::MakeDeviceOwner"
		inline void MakeDeviceOwner(CDevice * const pDevice)
		{
			DNASSERT(pDevice != NULL);
			DNASSERT(this->m_pOwningDevice == NULL);

			this->m_pOwningDevice = pDevice;
			this->m_blDeviceList.InsertAfter(&pDevice->m_blOwnedRegPorts);
		};


		//
		// You must have global object lock to call this function.
		//
		inline CDevice * GetOwningDevice(void)		{ return this->m_pOwningDevice; };


		//
		// You must have global object lock to call this function.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::ClearDeviceOwner"
		inline void ClearDeviceOwner(void)
		{
			DNASSERT(this->m_pOwningDevice != NULL);
			DNASSERT(this->m_blDeviceList.IsListMember(&this->m_pOwningDevice->m_blOwnedRegPorts));

			this->m_pOwningDevice = NULL;
			this->m_blDeviceList.RemoveFromList();
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::SetPrivateAddresses"
		HRESULT SetPrivateAddresses(const SOCKADDR_IN * const asaddrinPrivateAddresses,
									const DWORD dwNumAddresses)
		{
			DNASSERT((this->m_pasaddrinPrivateAddresses == NULL) && (this->m_dwNumAddresses == 0));

			this->m_pasaddrinPrivateAddresses = (SOCKADDR_IN *) DNMalloc(dwNumAddresses * sizeof(SOCKADDR_IN));
			if (this->m_pasaddrinPrivateAddresses == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			CopyMemory(this->m_pasaddrinPrivateAddresses, asaddrinPrivateAddresses, dwNumAddresses * sizeof(SOCKADDR_IN));
			this->m_dwNumAddresses = dwNumAddresses;

			return DPNH_OK;
		}


		inline void AddUserRef(void)	{ this->m_lUserRefs++; };

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::DecUserRef"
		inline LONG DecUserRef(void)
		{
			DNASSERT(this->m_lUserRefs >= 0);
			this->m_lUserRefs--;
			return this->m_lUserRefs;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::ClearAllUserRefs"
		inline void ClearAllUserRefs(void)
		{
			DNASSERT(this->m_lUserRefs > 0);
			this->m_lUserRefs = 0;
		};

		inline SOCKADDR_IN * GetPrivateAddressesArray(void)		{ return this->m_pasaddrinPrivateAddresses; };
		inline DWORD GetNumAddresses(void) const				{ return this->m_dwNumAddresses; };
		inline DWORD GetRequestedLeaseTime(void) const			{ return this->m_dwRequestedLeaseTime; };
		inline BOOL IsTCP(void) const							{ return ((this->m_dwFlags & REGPORTOBJ_TCP) ? TRUE : FALSE); };
		inline BOOL IsFixedPort(void) const						{ return ((this->m_dwFlags & REGPORTOBJ_FIXEDPORTS) ? TRUE : FALSE); };
		inline BOOL IsSharedPort(void) const					{ return ((this->m_dwFlags & REGPORTOBJ_SHAREDPORTS) ? TRUE : FALSE); };

		inline DWORD GetAddressesSize(void) const				{ return (this->GetNumAddresses() * sizeof(SOCKADDR_IN)); };


		inline void ClearPrivateAddresses(void)
		{
			if (this->m_pasaddrinPrivateAddresses != NULL)
			{
				DNFree(this->m_pasaddrinPrivateAddresses);
				this->m_pasaddrinPrivateAddresses = NULL;
			}
		};

		inline void UpdateRequestedLeaseTime(const DWORD dwRequestedLeaseTime)
		{
			this->m_dwRequestedLeaseTime = dwRequestedLeaseTime;
		};


		inline DWORD GetFlags(void) const						{ return this->m_dwFlags; };


#ifndef DPNBUILD_NOHNETFWAPI
		inline BOOL IsMappedOnHNetFirewall(void) const			{ return ((this->m_dwFlags & REGPORTOBJ_MAPPEDONHNETFIREWALL) ? TRUE : FALSE); };
		inline BOOL IsHNetFirewallPortUnavailable(void) const	{ return ((this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_HNETFIREWALL) ? TRUE : FALSE); };
		inline BOOL IsHNetFirewallMappingBuiltIn(void) const	{ return ((this->m_dwFlags & REGPORTOBJ_HNETFIREWALLMAPPINGBUILTIN) ? TRUE : FALSE); };
#endif // ! DPNBUILD_NOHNETFWAPI
		inline BOOL IsUPnPPortUnavailable(void) const			{ return ((this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_UPNP) ? TRUE : FALSE); };
		inline BOOL HasPermanentUPnPLease(void) const			{ return ((this->m_dwFlags & REGPORTOBJ_PERMANENTUPNPLEASE) ? TRUE : FALSE); };
		inline BOOL IsRemovingUPnPLease(void) const				{ return ((this->m_dwFlags & REGPORTOBJ_REMOVINGUPNPLEASE) ? TRUE : FALSE); };

		inline BOOL HasUPnPPublicAddresses(void) const			{ return ((this->m_pasaddrinUPnPPublicAddresses != NULL) ? TRUE : FALSE); };

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::GetUPnPLeaseExpiration"
		inline DWORD GetUPnPLeaseExpiration(void) const
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_PERMANENTUPNPLEASE));
			return this->m_dwUPnPLeaseExpiration;
		};



#ifndef DPNBUILD_NOHNETFWAPI

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NoteMappedOnHNetFirewall"
		inline void NoteMappedOnHNetFirewall(void)
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_MAPPEDONHNETFIREWALL));
			this->m_dwFlags |= REGPORTOBJ_MAPPEDONHNETFIREWALL;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NoteHNetFirewallPortUnavailable"
		inline void NoteHNetFirewallPortUnavailable(void)
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_HNETFIREWALL));
			this->m_dwFlags |= REGPORTOBJ_PORTUNAVAILABLE_HNETFIREWALL;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NoteHNetFirewallMappingBuiltIn"
		inline void NoteHNetFirewallMappingBuiltIn(void)
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_HNETFIREWALLMAPPINGBUILTIN));
			this->m_dwFlags |= REGPORTOBJ_HNETFIREWALLMAPPINGBUILTIN;
		};

#endif // ! DPNBUILD_NOHNETFWAPI

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NoteUPnPPortUnavailable"
		inline void NoteUPnPPortUnavailable(void)
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_PORTUNAVAILABLE_UPNP));
			this->m_dwFlags |= REGPORTOBJ_PORTUNAVAILABLE_UPNP;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NotePermanentUPnPLease"
		inline void NotePermanentUPnPLease(void)
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_PERMANENTUPNPLEASE));
			this->m_dwFlags |= REGPORTOBJ_PERMANENTUPNPLEASE;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::NoteRemovingUPnPLease"
		inline void NoteRemovingUPnPLease(void)
		{
			DNASSERT(! (this->m_dwFlags & REGPORTOBJ_REMOVINGUPNPLEASE));
			this->m_dwFlags |= REGPORTOBJ_REMOVINGUPNPLEASE;
		};

#ifndef DPNBUILD_NOHNETFWAPI
		inline void NoteNotMappedOnHNetFirewall(void)			{ this->m_dwFlags &= ~REGPORTOBJ_MAPPEDONHNETFIREWALL; };
		inline void NoteNotHNetFirewallPortUnavailable(void)	{ this->m_dwFlags &= ~REGPORTOBJ_PORTUNAVAILABLE_HNETFIREWALL; };
		inline void NoteNotHNetFirewallMappingBuiltIn(void)		{ this->m_dwFlags &= ~REGPORTOBJ_HNETFIREWALLMAPPINGBUILTIN; };
#endif // ! DPNBUILD_NOHNETFWAPI
		inline void NoteNotUPnPPortUnavailable(void)			{ this->m_dwFlags &= ~REGPORTOBJ_PORTUNAVAILABLE_UPNP; };
		inline void NoteNotPermanentUPnPLease(void)				{ this->m_dwFlags &= ~REGPORTOBJ_PERMANENTUPNPLEASE; };
		inline void NoteNotRemovingUPnPLease(void)				{ this->m_dwFlags &= ~REGPORTOBJ_REMOVINGUPNPLEASE; };

		inline void SetUPnPLeaseExpiration(const DWORD dwLeaseExpiration)	{ this->m_dwUPnPLeaseExpiration = dwLeaseExpiration; };

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::CreateUPnPPublicAddressesArray"
		inline HRESULT CreateUPnPPublicAddressesArray(void)
		{
			DNASSERT(! this->HasUPnPPublicAddresses());
			DNASSERT(this->GetNumAddresses() > 0);

			this->m_pasaddrinUPnPPublicAddresses = (SOCKADDR_IN*) DNMalloc(this->GetNumAddresses() * sizeof(SOCKADDR_IN));
			if (this->m_pasaddrinUPnPPublicAddresses == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			return DPNH_OK;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::GetUPnPPublicAddressesArray"
		inline SOCKADDR_IN * GetUPnPPublicAddressesArray(void)
		{
			DNASSERT(this->HasUPnPPublicAddresses());

			return (this->m_pasaddrinUPnPPublicAddresses);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::SetUPnPPublicV4Address"
		inline void SetUPnPPublicV4Address(const DWORD dwAddressIndex,
											const DWORD dwAddressV4,
											const WORD wPort)
		{
			DNASSERT(this->HasUPnPPublicAddresses());

			this->m_pasaddrinUPnPPublicAddresses[dwAddressIndex].sin_family				= AF_INET;
			this->m_pasaddrinUPnPPublicAddresses[dwAddressIndex].sin_addr.S_un.S_addr	= dwAddressV4;
			this->m_pasaddrinUPnPPublicAddresses[dwAddressIndex].sin_port				= wPort;
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::UpdateUPnPPublicV4Addresses"
		inline void UpdateUPnPPublicV4Addresses(const DWORD dwAddressV4)
		{
			DWORD	dwTemp;


			DNASSERT(this->HasUPnPPublicAddresses());

			for(dwTemp = 0; dwTemp < this->GetNumAddresses(); dwTemp++)
			{
				this->m_pasaddrinUPnPPublicAddresses[dwTemp].sin_addr.S_un.S_addr	= dwAddressV4;
			}
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CRegisteredPort::CopyUPnPPublicAddresses"
		inline void CopyUPnPPublicAddresses(SOCKADDR_IN * aPublicAddresses)
		{
			DNASSERT(this->HasUPnPPublicAddresses());

			CopyMemory(aPublicAddresses, this->m_pasaddrinUPnPPublicAddresses, this->GetAddressesSize());
		};

		inline void DestroyUPnPPublicAddressesArray(void)
		{
			if (this->m_pasaddrinUPnPPublicAddresses != NULL)
			{
				DNFree(this->m_pasaddrinUPnPPublicAddresses);
				this->m_pasaddrinUPnPPublicAddresses = NULL;
			}
		};



		CBilink		m_blGlobalList;	// list of all the ports registered
		CBilink		m_blDeviceList;	// list of ports registered for a particular device

	
	private:
		//
		// Note that all values here are protected by the global CNATHelpUPnP lock.
		//
		BYTE			m_Sig[4];							// debugging signature ('REGP')
		CDevice *		m_pOwningDevice;					// pointer to owning device object
		SOCKADDR_IN *	m_pasaddrinPrivateAddresses;		// array of private addresses registered by this object
		DWORD			m_dwNumAddresses;					// number of private (and public, if available) addresses in use by this object
		DWORD			m_dwRequestedLeaseTime;				// requested lease time for object
		DWORD			m_dwFlags;							// flags for this object
		LONG			m_lUserRefs;						// number of user references for this port mapping

		SOCKADDR_IN *	m_pasaddrinUPnPPublicAddresses;		// array of public addresses UPnP device assigned for this mapping
		DWORD			m_dwUPnPLeaseExpiration;			// time when lease expires on UPnP device
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\guids\guids.cpp ===
#include "dpnbuild.h"
#include <objbase.h>
#include <initguid.h>

#include <winsock.h>

#include "dpnathlp.h"

#ifdef WINCE
// Linking uuid.lib on WinCE pulls in more IID's than we use
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
#endif // WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\upnpdevice.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       upnpdevice.h
 *
 *  Content:	Header for UPnP device object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  02/10/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Defines
//=============================================================================
#define MAX_RECEIVE_BUFFER_SIZE		(100 * 1024)	// 100 K, must be greater than UPNP_STREAM_RECV_BUFFER_INITIAL_SIZE



//=============================================================================
// Object flags
//=============================================================================
#define UPNPDEVICE_WANPPPCONNECTION						0x01	// flag set if the device is a WANPPPConnection device, not set if it is a WANIPConnection device
#define UPNPDEVICE_CONNECTING							0x02	// flag set while the TCP connection is in progress
#define UPNPDEVICE_CONNECTED							0x04	// flag set once the TCP connection has been established
#define UPNPDEVICE_READY								0x08	// flag set once the device is capable of being used
#define UPNPDEVICE_WAITINGFORCONTROLRESPONSE			0x10	// flag set if some function is waiting for a control response
#define UPNPDEVICE_DOESNOTSUPPORTASYMMETRICMAPPINGS		0x20	// flag set when the device has indicated it does not support asymmetric mappings
#define UPNPDEVICE_DOESNOTSUPPORTLEASEDURATIONS			0x40	// flag set when the device has indicated it does not support non-INFINITE lease durations
#define UPNPDEVICE_USINGCHUNKEDTRANSFERENCODING			0x80	// flag set when device is sending current response using chunked transfer encoding



//=============================================================================
// Macros
//=============================================================================
#define UPNPDEVICE_FROM_BILINK(b)	(CONTAINING_OBJECT(b, CUPnPDevice, m_blList))




//=============================================================================
// Enums
//=============================================================================

//
// UPnP expected control response enum
//
typedef enum _CONTROLRESPONSETYPE
{
	CONTROLRESPONSETYPE_NONE,									// no handler
	//CONTROLRESPONSETYPE_QUERYSTATEVARIABLE_EXTERNALIPADDRESS,	// use the ExternalIPAddress QueryStateVariable handler
	CONTROLRESPONSETYPE_GETEXTERNALIPADDRESS,					// use the GetExternalIPAddress handler
	CONTROLRESPONSETYPE_ADDPORTMAPPING,							// use the AddPortMapping handler
	CONTROLRESPONSETYPE_GETSPECIFICPORTMAPPINGENTRY,			// use the GetSpecificPortMappingEntry handler
	CONTROLRESPONSETYPE_DELETEPORTMAPPING						// use the DeletePortMapping handler
} CONTROLRESPONSETYPE;



//=============================================================================
// Structures
//=============================================================================
typedef struct _UPNP_CONTROLRESPONSE_INFO
{
	HRESULT		hrErrorCode;			// error code returned by server
	DWORD		dwInternalClientV4;		// internal client address returned by server
	WORD		wInternalPort;			// internal client port returned by server
	DWORD		dwExternalIPAddressV4;	// external IP address returned by server
} UPNP_CONTROLRESPONSE_INFO, * PUPNP_CONTROLRESPONSE_INFO;




//=============================================================================
// UPnP device object class
//=============================================================================
class CUPnPDevice
{
	public:
		CUPnPDevice(const DWORD dwID)
		{
			this->m_blList.Initialize();

			this->m_Sig[0] = 'U';
			this->m_Sig[1] = 'P';
			this->m_Sig[2] = 'D';
			this->m_Sig[3] = 'V';

			this->m_lRefCount						= 1;	// whoever got a pointer to this has a reference
			this->m_dwFlags							= 0;
			this->m_dwID							= dwID;
			this->m_pOwningDevice					= NULL;
			this->m_pszLocationURL					= NULL;
			ZeroMemory(&this->m_saddrinHost, sizeof(this->m_saddrinHost));
			ZeroMemory(&this->m_saddrinControl, sizeof(this->m_saddrinControl));
			this->m_pszUSN							= NULL;
			this->m_pszServiceControlURL			= NULL;
			this->m_sControl						= INVALID_SOCKET;
			this->m_pcReceiveBuffer					= NULL;
			this->m_dwReceiveBufferSize				= 0;
			this->m_pcReceiveBufferStart			= NULL;
			this->m_dwUsedReceiveBufferSize			= 0;
			this->m_dwRemainingReceiveBufferSize	= 0;
			this->m_dwExternalIPAddressV4			= 0;
			this->m_blCachedMaps.Initialize();

			this->m_dwExpectedContentLength			= 0;
			this->m_dwHTTPResponseCode				= 0;

			this->m_ControlResponseType				= CONTROLRESPONSETYPE_NONE;
			this->m_pControlResponseInfo			= NULL;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::~CUPnPDevice"
		~CUPnPDevice(void)
		{
			DNASSERT(this->m_blList.IsEmpty());

			DNASSERT(this->m_lRefCount == 0);
			DNASSERT(this->m_pOwningDevice == NULL);
			DNASSERT(this->m_pszLocationURL == NULL);
			DNASSERT(this->m_pszUSN == NULL);
			DNASSERT(this->m_pszServiceControlURL == NULL);
			DNASSERT(this->m_sControl == INVALID_SOCKET);
			DNASSERT(this->m_pcReceiveBuffer == NULL);
			DNASSERT(this->m_blCachedMaps.IsEmpty());

			DNASSERT(this->m_ControlResponseType == CONTROLRESPONSETYPE_NONE);
			DNASSERT(this->m_pControlResponseInfo == NULL);
		};

		inline void AddRef(void)									{ this->m_lRefCount++; };

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::DecRef"
		inline void DecRef(void)
		{
			this->m_lRefCount--;
			DNASSERT(this->m_lRefCount >= 0);
			if (this->m_lRefCount == 0)
			{
				delete this;
			}
		};


		inline BOOL IsWANPPPConnection(void) const					{ return ((this->m_dwFlags & UPNPDEVICE_WANPPPCONNECTION) ? TRUE : FALSE); };
		inline BOOL IsConnecting(void) const						{ return ((this->m_dwFlags & UPNPDEVICE_CONNECTING) ? TRUE : FALSE); };
		inline BOOL IsConnected(void) const							{ return ((this->m_dwFlags & UPNPDEVICE_CONNECTED) ? TRUE : FALSE); };
		inline BOOL IsReady(void) const								{ return ((this->m_dwFlags & UPNPDEVICE_READY) ? TRUE : FALSE); };
		inline BOOL DoesNotSupportAsymmetricMappings(void) const	{ return ((this->m_dwFlags & UPNPDEVICE_DOESNOTSUPPORTASYMMETRICMAPPINGS) ? TRUE : FALSE); };
		inline BOOL DoesNotSupportLeaseDurations(void) const		{ return ((this->m_dwFlags & UPNPDEVICE_DOESNOTSUPPORTLEASEDURATIONS) ? TRUE : FALSE); };
		inline BOOL IsUsingChunkedTransferEncoding(void) const		{ return ((this->m_dwFlags & UPNPDEVICE_USINGCHUNKEDTRANSFERENCODING) ? TRUE : FALSE); };

		inline DWORD GetID(void) const								{ return this->m_dwID; };
		inline const char * GetStaticServiceURI(void) const			{ return ((this->m_dwFlags & UPNPDEVICE_WANPPPCONNECTION) ? URI_SERVICE_WANPPPCONNECTION_A : URI_SERVICE_WANIPCONNECTION_A); };
		inline int GetStaticServiceURILength(void) const			{ return ((this->m_dwFlags & UPNPDEVICE_WANPPPCONNECTION) ? strlen(URI_SERVICE_WANPPPCONNECTION_A) : strlen(URI_SERVICE_WANIPCONNECTION_A)); };
		inline SOCKADDR_IN * GetHostAddress(void)					{ return &this->m_saddrinHost; };
		inline SOCKADDR_IN * GetControlAddress(void)				{ return &this->m_saddrinControl; };

		inline SOCKET GetControlSocket(void) const					{ return this->m_sControl; };

		inline DWORD GetExternalIPAddressV4(void) const				{ return this->m_dwExternalIPAddressV4; };

		inline CBilink * GetCachedMaps(void)						{ return &this->m_blCachedMaps; };



#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteWANPPPConnection"
		inline void NoteWANPPPConnection(void)
		{
			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_WANPPPCONNECTION));
			this->m_dwFlags |= UPNPDEVICE_WANPPPCONNECTION;
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteConnecting"
		inline void NoteConnecting(void)
		{
			DNASSERT(! (this->m_dwFlags & (UPNPDEVICE_CONNECTING | UPNPDEVICE_CONNECTED)));
			this->m_dwFlags |= UPNPDEVICE_CONNECTING;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteConnected"
		inline void NoteConnected(void)
		{
			DNASSERT(this->m_dwFlags & UPNPDEVICE_CONNECTING);
			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_CONNECTED));
			this->m_dwFlags &= ~UPNPDEVICE_CONNECTING;
			this->m_dwFlags |= UPNPDEVICE_CONNECTED;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteNotConnected"
		inline void NoteNotConnected(void)
		{
			DNASSERT(this->m_dwFlags & UPNPDEVICE_CONNECTED);
			this->m_dwFlags &= ~UPNPDEVICE_CONNECTED;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteReady"
		inline void NoteReady(void)
		{
			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_READY));
			this->m_dwFlags |= UPNPDEVICE_READY;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteDoesNotSupportAsymmetricMappings"
		inline void NoteDoesNotSupportAsymmetricMappings(void)
		{
			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_DOESNOTSUPPORTASYMMETRICMAPPINGS));
			this->m_dwFlags |= UPNPDEVICE_DOESNOTSUPPORTASYMMETRICMAPPINGS;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteDoesNotSupportLeaseDurations"
		inline void NoteDoesNotSupportLeaseDurations(void)
		{
			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_DOESNOTSUPPORTLEASEDURATIONS));
			this->m_dwFlags |= UPNPDEVICE_DOESNOTSUPPORTLEASEDURATIONS;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteUsingChunkedTransferEncoding"
		inline void NoteUsingChunkedTransferEncoding(void)
		{
			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_USINGCHUNKEDTRANSFERENCODING));
			this->m_dwFlags |= UPNPDEVICE_USINGCHUNKEDTRANSFERENCODING;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteNotUsingChunkedTransferEncoding"
		inline void NoteNotUsingChunkedTransferEncoding(void)
		{
			DNASSERT(this->m_dwFlags & UPNPDEVICE_USINGCHUNKEDTRANSFERENCODING);
			this->m_dwFlags &= ~UPNPDEVICE_USINGCHUNKEDTRANSFERENCODING;
		};


		inline void SetHostAddress(SOCKADDR_IN * psaddrinHost)
		{
			CopyMemory(&this->m_saddrinHost, psaddrinHost, sizeof(this->m_saddrinHost));
		};

		inline void SetControlAddress(SOCKADDR_IN * psaddrinControl)
		{
			CopyMemory(&this->m_saddrinControl, psaddrinControl, sizeof(this->m_saddrinControl));
		};

		inline BOOL IsLocal(void) const		{ return ((this->m_saddrinControl.sin_addr.S_un.S_addr == this->m_pOwningDevice->GetLocalAddressV4()) ? TRUE : FALSE); };


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::SetLocationURL"
		inline HRESULT SetLocationURL(const char * const szLocationURL)
		{
			DNASSERT(this->m_pszLocationURL == NULL);

			this->m_pszLocationURL = (char*) DNMalloc((strlen(szLocationURL) + 1) * sizeof(char));
			if (this->m_pszLocationURL == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			strcpy(this->m_pszLocationURL, szLocationURL);

			return DPNH_OK;
		};

		inline char * GetLocationURL(void)	{ return this->m_pszLocationURL; };

		inline void ClearLocationURL(void)
		{
			if (this->m_pszLocationURL != NULL)
			{
				DNFree(this->m_pszLocationURL);
				this->m_pszLocationURL = NULL;
			}
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::SetUSN"
		inline HRESULT SetUSN(const char * const szUSN)
		{
			DNASSERT(this->m_pszUSN == NULL);

			this->m_pszUSN = (char*) DNMalloc((strlen(szUSN) + 1) * sizeof(char));
			if (this->m_pszUSN == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			strcpy(this->m_pszUSN, szUSN);

			return DPNH_OK;
		};

		inline char * GetUSN(void)	{ return this->m_pszUSN; };

		inline void ClearUSN(void)
		{
			if (this->m_pszUSN != NULL)
			{
				DNFree(this->m_pszUSN);
				this->m_pszUSN = NULL;
			}
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::SetServiceControlURL"
		inline HRESULT SetServiceControlURL(const char * const szServiceControlURL)
		{
			DNASSERT(this->m_pszServiceControlURL == NULL);

			this->m_pszServiceControlURL = (char*) DNMalloc((strlen(szServiceControlURL) + 1) * sizeof(char));
			if (this->m_pszServiceControlURL == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			strcpy(this->m_pszServiceControlURL, szServiceControlURL);

			return DPNH_OK;
		};

		inline char * GetServiceControlURL(void)		{ return this->m_pszServiceControlURL; };

		inline void ClearServiceControlURL(void)
		{
			if (this->m_pszServiceControlURL != NULL)
			{
				DNFree(this->m_pszServiceControlURL);
				this->m_pszServiceControlURL = NULL;
			}
		};


		inline void SetControlSocket(SOCKET sControl)	{ this->m_sControl = sControl; };


		//
		// You must have global object lock to call this function.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::MakeDeviceOwner"
		inline void MakeDeviceOwner(CDevice * const pDevice)
		{
			DNASSERT(pDevice != NULL);
			DNASSERT(pDevice->GetUPnPDevice() == NULL);
			DNASSERT(this->m_pOwningDevice == NULL);

			this->m_pOwningDevice = pDevice;

			this->AddRef();
			pDevice->SetUPnPDevice(this);
		};


		//
		// You must have global object lock to call this function.
		//
		inline CDevice * GetOwningDevice(void)		{ return this->m_pOwningDevice; };


		//
		// You must have global object lock to call this function.
		//
#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::ClearDeviceOwner"
		inline void ClearDeviceOwner(void)
		{
			DNASSERT(this->m_pOwningDevice != NULL);
			DNASSERT(this->m_pOwningDevice->GetUPnPDevice() == this);

			this->m_pOwningDevice->SetUPnPDevice(NULL);
			this->m_pOwningDevice = NULL;
			this->DecRef();
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::CreateReceiveBuffer"
		inline HRESULT CreateReceiveBuffer(const DWORD dwSize)
		{
			DNASSERT(this->m_pcReceiveBuffer == NULL);


			this->m_pcReceiveBuffer = (char*) DNMalloc(dwSize);
			if (this->m_pcReceiveBuffer == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			this->m_dwReceiveBufferSize = dwSize;
			this->m_pcReceiveBufferStart = this->m_pcReceiveBuffer;
			this->m_dwRemainingReceiveBufferSize = dwSize;

			return DPNH_OK;
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::IncreaseReceiveBufferSize"
		inline HRESULT IncreaseReceiveBufferSize(void)
		{
			DWORD	dwNewBufferSize;
			char *	pcTemp;


			DNASSERT(this->m_pcReceiveBuffer != NULL);


			//
			// Double the buffer size.  Don't let the receive buffer get to
			// unrealistic sizes to prevent DoS/resource issues, cap the buffer
			// size, and if we've already reached that limit, fail.
			//
			dwNewBufferSize = this->m_dwReceiveBufferSize * 2;
			if (dwNewBufferSize > MAX_RECEIVE_BUFFER_SIZE)
			{
				dwNewBufferSize = MAX_RECEIVE_BUFFER_SIZE;
				if (dwNewBufferSize <= this->m_dwReceiveBufferSize)
				{
					DPFX(DPFPREP, 0, "Maximum buffer size reached (%u bytes), not allocating more room!",
						this->m_dwReceiveBufferSize); 
					return DPNHERR_OUTOFMEMORY;
				}
			}

			pcTemp = (char*) DNMalloc(dwNewBufferSize);
			if (pcTemp == NULL)
			{
				return DPNHERR_OUTOFMEMORY;
			}

			//
			// If the buffer already had data in it, copy it.  The data may not
			// have come from the front of the old buffer, but it will
			// definitely be the front of the new one.
			//
			if (this->m_dwUsedReceiveBufferSize > 0)
			{
				CopyMemory(pcTemp, this->m_pcReceiveBufferStart,
							this->m_dwUsedReceiveBufferSize);
			}

			DNFree(this->m_pcReceiveBuffer);
			this->m_pcReceiveBuffer = NULL;


			this->m_pcReceiveBuffer = pcTemp;
			this->m_dwReceiveBufferSize = dwNewBufferSize;

			//
			// The buffer now starts at the beginning of the allocated memory
			// (we may have just freed up a bunch of wasted space).
			//
			this->m_pcReceiveBufferStart = this->m_pcReceiveBuffer;
			this->m_dwRemainingReceiveBufferSize = this->m_dwReceiveBufferSize - this->m_dwUsedReceiveBufferSize;

			return DPNH_OK;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::UpdateUsedReceiveBufferSize"
		inline void UpdateUsedReceiveBufferSize(const DWORD dwAdditionalSizeUsed)
		{
			DNASSERT(dwAdditionalSizeUsed <= this->m_dwRemainingReceiveBufferSize);
			DNASSERT((this->m_dwUsedReceiveBufferSize + dwAdditionalSizeUsed) <= this->m_dwReceiveBufferSize);
			this->m_dwUsedReceiveBufferSize += dwAdditionalSizeUsed;
			this->m_dwRemainingReceiveBufferSize -= dwAdditionalSizeUsed;
		};

		inline void ClearReceiveBuffer(void)
		{
			this->m_pcReceiveBufferStart = this->m_pcReceiveBuffer;
			this->m_dwUsedReceiveBufferSize = 0;
			this->m_dwRemainingReceiveBufferSize = this->m_dwReceiveBufferSize;
		};

		inline char * GetReceiveBufferStart(void)					{ return this->m_pcReceiveBufferStart; };
		inline char * GetCurrentReceiveBufferPtr(void)				{ return (this->m_pcReceiveBufferStart + this->m_dwUsedReceiveBufferSize); };
		inline DWORD GetUsedReceiveBufferSize(void) const			{ return this->m_dwUsedReceiveBufferSize; };
		inline DWORD GetRemainingReceiveBufferSize(void) const		{ return this->m_dwRemainingReceiveBufferSize; };

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::UpdateReceiveBufferStart"
		inline void UpdateReceiveBufferStart(char * pszNewStart)
		{
			DNASSERT(pszNewStart > this->m_pcReceiveBufferStart);
			DNASSERT((DWORD) ((DWORD_PTR) (pszNewStart - this->m_pcReceiveBufferStart)) < this->m_dwRemainingReceiveBufferSize);
			this->m_dwUsedReceiveBufferSize -= (DWORD) ((DWORD_PTR) (pszNewStart - this->m_pcReceiveBufferStart));
			this->m_pcReceiveBufferStart = pszNewStart;
		};

		inline void DestroyReceiveBuffer(void)
		{
			if (this->m_pcReceiveBuffer != NULL)
			{
				DNFree(this->m_pcReceiveBuffer);
				this->m_pcReceiveBuffer = NULL;
				this->m_dwReceiveBufferSize = 0;
				this->m_pcReceiveBufferStart = NULL;
				this->m_dwUsedReceiveBufferSize = 0;
				this->m_dwRemainingReceiveBufferSize = 0;
			}
		};


		inline void SetExternalIPAddressV4(const DWORD dwExternalIPAddressV4)
		{
			this->m_dwExternalIPAddressV4 = dwExternalIPAddressV4;
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::RemoveAllCachedMappings"
		inline void RemoveAllCachedMappings(void)
		{
			CBilink *		pCachedMaps;
			CBilink *		pBilink;
			CCacheMap *		pCacheMap;


			pCachedMaps = this->GetCachedMaps();
			pBilink = pCachedMaps->GetNext();
			while (pBilink != pCachedMaps)
			{
				DNASSERT(! pBilink->IsEmpty());


				pCacheMap = CACHEMAP_FROM_BILINK(pBilink);
				pBilink = pBilink->GetNext();
					
				
				DPFX(DPFPREP, 5, "Removing UPnP device 0x%p cached mapping 0x%p.",
					this, pCacheMap);

				pCacheMap->m_blList.RemoveFromList();
				delete pCacheMap;
			}
		};



#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteWaitingForContent"
		inline void NoteWaitingForContent(const DWORD dwContentLength, const DWORD dwHTTPResponseCode)
		{
			DNASSERT(this->m_dwExpectedContentLength == 0);
			this->m_dwExpectedContentLength = dwContentLength;
			this->m_dwHTTPResponseCode = dwHTTPResponseCode;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::NoteNotWaitingForContent"
		inline void NoteNotWaitingForContent(void)
		{
			DNASSERT(this->m_dwExpectedContentLength != 0);
			this->m_dwExpectedContentLength = 0;
			this->m_dwHTTPResponseCode = 0;
		};

		inline BOOL IsWaitingForContent(void) const			{ return ((this->m_dwExpectedContentLength != 0) ? TRUE : FALSE); };
		inline DWORD GetExpectedContentSize(void) const		{ return this->m_dwExpectedContentLength; };
		inline DWORD GetHTTPResponseCode(void) const		{ return this->m_dwHTTPResponseCode; };

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::StartWaitingForControlResponse"
		inline void StartWaitingForControlResponse(CONTROLRESPONSETYPE ControlResponseType,
													PUPNP_CONTROLRESPONSE_INFO pControlResponseInfo)
		{
			DNASSERT(ControlResponseType != CONTROLRESPONSETYPE_NONE);

			DNASSERT(! (this->m_dwFlags & UPNPDEVICE_WAITINGFORCONTROLRESPONSE));
			this->m_dwFlags |= UPNPDEVICE_WAITINGFORCONTROLRESPONSE;

			this->m_ControlResponseType			= ControlResponseType;
			this->m_pControlResponseInfo		= pControlResponseInfo;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CUPnPDevice::StopWaitingForControlResponse"
		inline void StopWaitingForControlResponse(void)
		{
			this->m_dwFlags &= ~UPNPDEVICE_WAITINGFORCONTROLRESPONSE;

			this->m_ControlResponseType			= CONTROLRESPONSETYPE_NONE;
			this->m_pControlResponseInfo		= NULL;
		};

		inline BOOL IsWaitingForControlResponse(void) const						{ return ((this->m_dwFlags & UPNPDEVICE_WAITINGFORCONTROLRESPONSE) ? TRUE : FALSE); };

		inline CONTROLRESPONSETYPE GetControlResponseType(void) const			{ return this->m_ControlResponseType; };
		inline PUPNP_CONTROLRESPONSE_INFO GetControlResponseInfo(void)			{ return this->m_pControlResponseInfo; };



		CBilink		m_blList;	// list of all the UPnP devices known


	private:
		BYTE			m_Sig[4];							// debugging signature ('UPDV')

		LONG			m_lRefCount;						// reference count for this object
		DWORD			m_dwFlags;							// flags indicating current state of UPnP device
		DWORD			m_dwID;								// unique identifier used to correlate crash registry entries with UPnP devices
		CDevice *		m_pOwningDevice;					// pointer to owning device object
		char *			m_pszLocationURL;					// control location URL string
		SOCKADDR_IN		m_saddrinHost;						// UPnP device host address
		SOCKADDR_IN		m_saddrinControl;					// UPnP device control address
		char *			m_pszUSN;							// device's Unique Service Name
		char *			m_pszServiceControlURL;				// URL used to control WANIPConnectionService
		SOCKET			m_sControl;							// TCP socket with connection to the UPnP device
		char *			m_pcReceiveBuffer;					// pointer to receive buffer
		DWORD			m_dwReceiveBufferSize;				// size of receive buffer
		char *			m_pcReceiveBufferStart;				// pointer to start of actual data in receive buffer (anything before this is just wasted space)
		DWORD			m_dwUsedReceiveBufferSize;			// size of receive buffer actually filled with data (beginning at m_pcReceiveBufferStart)
		DWORD			m_dwRemainingReceiveBufferSize;		// size of receive buffer that can hold more data (after m_pcReceiveBufferStart + m_dwUsedReceiveBufferSize)
		DWORD			m_dwExternalIPAddressV4;			// IP v4 external IP address of this UPnP device
		CBilink			m_blCachedMaps;						// list of cached mappings for query addresses performed on this UPnP device

		DWORD			m_dwExpectedContentLength;			// expected size of message content, or 0 if no headers have been read
		DWORD			m_dwHTTPResponseCode;				// HTTP response code previously parsed, if waiting for content

		CONTROLRESPONSETYPE			m_ControlResponseType;	// type of response expected
		PUPNP_CONTROLRESPONSE_INFO	m_pControlResponseInfo;	// place to store info from a received response
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpintfobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpintfobj.h
 *
 *  Content:	Header for DPNHUPNP main interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Defines
//=============================================================================
#define NETWORKBYTEORDER_INADDR_LOOPBACK		0x0100007f


#define MAX_XMLELEMENT_DEPTH					15
#define MAX_XMLNAMESPACES_PER_ELEMENT			5
#define MAX_NUM_DESCRIPTION_XML_SUBELEMENTS		10
#define MAX_NUM_UPNPCONTROLOUTARGS				10




//=============================================================================
// Macros
//=============================================================================
#define NATHELPUPNP_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CNATHelpUPnP, m_blList))



//=============================================================================
// Typedefs
//=============================================================================
class CNATHelpUPnP;

class CUPnPDevice;




//=============================================================================
// Object flags
//=============================================================================
#define NATHELPUPNPOBJ_NOTCREATEDWITHCOM			0x0001	// object was created through non-COM DirectPlayNATHelpCreate function
#define NATHELPUPNPOBJ_INITIALIZED					0x0002	// object has been initialized
#define NATHELPUPNPOBJ_USEUPNP						0x0004	// UPnP can be used for NAT traversal
#ifndef DPNBUILD_NOHNETFWAPI
#define NATHELPUPNPOBJ_USEHNETFWAPI					0x0008	// the HomeNet firewall port mapping API can be used for opening a local firewall
#endif // ! DPNBUILD_NOHNETFWAPI
#ifndef DPNBUILD_NOWINSOCK2
#define NATHELPUPNPOBJ_WINSOCK1						0x0010	// only WinSock 1 functionality is available
#endif // ! DPNBUILD_NOWINSOCK2
#define NATHELPUPNPOBJ_DEVICECHANGED				0x0020	// short lived flag that overrides min update server status interval when a device is added or removed
#define NATHELPUPNPOBJ_ADDRESSESCHANGED				0x0040	// flag indicating that server status changed since the last time the user checked
#define NATHELPUPNPOBJ_PORTREGISTERED				0x0080	// short lived flag that allows remote gateway check when a port has been registered
#define NATHELPUPNPOBJ_LONGLOCK						0x0100	// a thread dropped the main object lock but still needs ownership of the object during a long operation
#ifndef WINCE
#define NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX		0x0200	// use the "Global\" prefix when creating named kernel objects
#endif // ! WINCE




//=============================================================================
// Structures
//=============================================================================
//
// UPnP header information parsing structure
//
typedef struct _UPNP_HEADER_INFO
{
	char *		apszHeaderStrings[NUM_RESPONSE_HEADERS];	// place to store pointers to value strings for each header found
	char *		pszMsgBody;									// place to store pointer to message body after the end of the headers
} UPNP_HEADER_INFO, * PUPNP_HEADER_INFO;


//
// UPnP XML parsing structures
//
typedef struct _PARSEXML_SUBELEMENT
{
	char *					pszNameFound;										// name of subelement instance that was found
	char *					apszAttributeNames[MAX_XMLNAMESPACES_PER_ELEMENT];	// array of attributes for this subelement instance
	char *					apszAttributeValues[MAX_XMLNAMESPACES_PER_ELEMENT];	// matching array of values for the attributes of this subelement instance
	DWORD					dwNumAttributes;									// number of attributes contained in previous arrays
	char *					pszValueFound;										// pointer to value associated with this subelement instance
} PARSEXML_SUBELEMENT, * PPARSEXML_SUBELEMENT;

typedef struct _PARSEXML_ELEMENT
{
	char **					papszElementStack;		// array of strings indicating an item's location in the XML document
	DWORD					dwElementStackDepth;	// number of strings in previous array
	PARSEXML_SUBELEMENT *	paSubElements;			// array to store subelement instances found
	DWORD					dwMaxNumSubElements;	// maximum number of subelement instances that can be stored in previous array
	DWORD					dwNumSubElements;		// number of subelement instances actually returned in previous array
	BOOL					fFoundMatchingElement;	// whether the required subelements were found
} PARSEXML_ELEMENT, * PPARSEXML_ELEMENT;


typedef struct tagPARSEXML_STACKENTRY
{
	char *	pszName;											// name of this XML element
	char *	apszAttributeNames[MAX_XMLNAMESPACES_PER_ELEMENT];	// array of attributes for this XML element
	char *	apszAttributeValues[MAX_XMLNAMESPACES_PER_ELEMENT];	// matching array of values for the attributes of this XML element
	DWORD	dwNumAttributes;									// number of attributes contained in previous arrays
	char *	pszValue;											// value of this XML element
} PARSEXML_STACKENTRY, * PPARSEXML_STACKENTRY;


typedef enum _PARSECALLBACK
{
	PARSECALLBACK_DESCRIPTIONRESPONSE,				// use the description response parse callback
	PARSECALLBACK_CONTROLRESPONSE					// use the control response parse callback
} PARSECALLBACK;





#ifdef DPNBUILD_NOWINSOCK2
//=============================================================================
// WinSock function definitions required when winsock2.h cannot be included
//=============================================================================
#define WSAAPI		FAR PASCAL

typedef
int
(WSAAPI * LPFN_WSASTARTUP)(
    IN WORD wVersionRequested,
    OUT LPWSADATA lpWSAData
    );

typedef
int
(WSAAPI * LPFN_WSACLEANUP)(
    void
    );

typedef
int
(WSAAPI * LPFN_WSAGETLASTERROR)(
    void
    );

typedef
SOCKET
(WSAAPI * LPFN_SOCKET)(
    IN int af,
    IN int type,
    IN int protocol
    );

typedef
int
(WSAAPI * LPFN_CLOSESOCKET)(
    IN SOCKET s
    );

typedef
int
(WSAAPI * LPFN_BIND)(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    );

typedef
int
(WSAAPI * LPFN_SETSOCKOPT)(
    IN SOCKET s,
    IN int level,
    IN int optname,
    IN const char FAR * optval,
    IN int optlen
    );

typedef
int
(WSAAPI * LPFN_GETSOCKNAME)(
    IN SOCKET s,
    OUT struct sockaddr FAR * name,
    IN OUT int FAR * namelen
    );

typedef
int
(WSAAPI * LPFN_SELECT)(
    IN int nfds,
    IN OUT fd_set FAR * readfds,
    IN OUT fd_set FAR * writefds,
    IN OUT fd_set FAR *exceptfds,
    IN const struct timeval FAR * timeout
    );

typedef
int
(WSAAPI * LPFN_RECVFROM)(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags,
    OUT struct sockaddr FAR * from,
    IN OUT int FAR * fromlen
    );

typedef
int
(WSAAPI * LPFN_SENDTO)(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags,
    IN const struct sockaddr FAR * to,
    IN int tolen
    );

typedef
int
(WSAAPI * LPFN_GETHOSTNAME)(
    OUT char FAR * name,
    IN int namelen
    );

typedef
struct hostent FAR *
(WSAAPI * LPFN_GETHOSTBYNAME)(
    IN const char FAR * name
    );

typedef
unsigned long
(WSAAPI * LPFN_INET_ADDR)(
    IN const char FAR * cp
    );

typedef
int
(WSAAPI * LPFN_IOCTLSOCKET)(
    IN SOCKET s,
    IN long cmd,
    IN OUT u_long FAR * argp
    );

typedef
int
(WSAAPI * LPFN_CONNECT)(
    IN SOCKET s,
    IN const struct sockaddr FAR * name,
    IN int namelen
    );

typedef
int
(WSAAPI * LPFN_SHUTDOWN)(
    IN SOCKET s,
    IN int how
    );

typedef
int
(WSAAPI * LPFN_SEND)(
    IN SOCKET s,
    IN const char FAR * buf,
    IN int len,
    IN int flags
    );

typedef
int
(WSAAPI * LPFN_RECV)(
    IN SOCKET s,
    OUT char FAR * buf,
    IN int len,
    IN int flags
    );

typedef
int
(WSAAPI * LPFN_GETSOCKOPT)(
    IN SOCKET s,
    IN int level,
    IN int optname,
    OUT char FAR * optval,
    IN OUT int FAR * optlen
    );


//=============================================================================
// WinSock function definitions left out by winsock2.h
//=============================================================================
typedef INT (WSAAPI * LPFN___WSAFDISSET)			(SOCKET, fd_set FAR *);



//=============================================================================
// Macro redefinitions due to WinCE/Desktop differences
//=============================================================================
#undef FD_SET
#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)




#else // ! DPNBUILD_NOWINSOCK2
//=============================================================================
// WinSock function definitions left out by winsock2.h
//=============================================================================
typedef INT (WSAAPI * LPFN___WSAFDISSET)			(SOCKET, fd_set FAR *);



//=============================================================================
// IPHLPAPI function prototypes
//=============================================================================
typedef DWORD (WINAPI *PFN_GETADAPTERSINFO)			(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
typedef DWORD (WINAPI *PFN_GETIPFORWARDTABLE)		(PMIB_IPFORWARDTABLE pIpForwardTable, PULONG pdwSize, BOOL bOrder);
typedef DWORD (WINAPI *PFN_GETBESTROUTE)			(DWORD dwDestAddr, DWORD dwSourceAddr, PMIB_IPFORWARDROW pBestRoute);


//=============================================================================
// RASAPI32 function prototypes
//=============================================================================
typedef DWORD (WINAPI *PFN_RASGETENTRYHRASCONNW)	(IN LPCWSTR pszPhonebook, IN LPCWSTR pszEntry, OUT LPHRASCONN lphrasconn);
#ifdef UNICODE
typedef DWORD (WINAPI *PFN_RASGETPROJECTIONINFOW)	(HRASCONN hrasconn, RASPROJECTION rasprojection, LPVOID lpprojection, LPDWORD lpcb);
#define PFN_RASGETPROJECTIONINFO	PFN_RASGETPROJECTIONINFOW
#else // ! UNICODE
typedef DWORD (WINAPI *PFN_RASGETPROJECTIONINFOA)	(HRASCONN hrasconn, RASPROJECTION rasprojection, LPVOID lpprojection, LPDWORD lpcb);
#define PFN_RASGETPROJECTIONINFO	PFN_RASGETPROJECTIONINFOA
#endif // ! UNICODE
#endif // ! DPNBUILD_NOWINSOCK2




//=============================================================================
// Main interface object class
//=============================================================================
class CNATHelpUPnP : public IDirectPlayNATHelp
{
	public:
		CNATHelpUPnP(const BOOL fNotCreatedWithCOM);	// constructor
		~CNATHelpUPnP(void);	// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP Initialize(const DWORD dwFlags);

		STDMETHODIMP Close(const DWORD dwFlags);

		STDMETHODIMP GetCaps(DPNHCAPS * const pdpnhcaps,
							const DWORD dwFlags);

		STDMETHODIMP RegisterPorts(const SOCKADDR * const aLocalAddresses,
									const DWORD dwAddressesSize,
									const DWORD dwNumAddresses,
									const DWORD dwLeaseTime,
									DPNHHANDLE * const phRegisteredPorts,
									const DWORD dwFlags);

		STDMETHODIMP GetRegisteredAddresses(const DPNHHANDLE hRegisteredPorts,
											SOCKADDR * const paPublicAddresses,
											DWORD * const pdwPublicAddressesSize,
											DWORD * const pdwAddressTypeFlags,
											DWORD * const pdwLeaseTimeRemaining,
											const DWORD dwFlags);

		STDMETHODIMP DeregisterPorts(const DPNHHANDLE hRegisteredPorts,
									const DWORD dwFlags);

		STDMETHODIMP QueryAddress(const SOCKADDR * const pSourceAddress,
								const SOCKADDR * const pQueryAddress,
								SOCKADDR * const pResponseAddress,
								const int iAddressesSize,
								const DWORD dwFlags);

		STDMETHODIMP SetAlertEvent(const HANDLE hEvent, const DWORD dwFlags);

		STDMETHODIMP SetAlertIOCompletionPort(const HANDLE hIOCompletionPort,
											const DWORD dwCompletionKey,
											const DWORD dwNumConcurrentThreads,
											const DWORD dwFlags);

		STDMETHODIMP ExtendRegisteredPortsLease(const DPNHHANDLE hRegisteredPorts,
												const DWORD dwLeaseTime,
												const DWORD dwFlags);


		HRESULT InitializeObject(void);

		void UninitializeObject(void);


		CBilink		m_blList;	// list of all the NATHelper instances in existence


	private:
		BYTE							m_Sig[4];							// debugging signature ('NATH')
		LONG							m_lRefCount;						// reference count for this object
		DWORD							m_dwFlags;							// flags for this object
		DNCRITICAL_SECTION				m_csLock;							// lock preventing simultaneous usage
		DNHANDLE						m_hLongLockSemaphore;				// semaphore used to hold the object lock for a long period of time
		LONG							m_lNumLongLockWaitingThreads;		// number of threads waiting for the long lock to be released
		DWORD							m_dwLockThreadID;					// ID of thread currently holding the lock
#ifndef DPNBUILD_NOHNETFWAPI
		HANDLE							m_hAlertEvent;						// handle to alert event, if any
		HANDLE							m_hAlertIOCompletionPort;			// handle to alert I/O completion port, if any
		DWORD							m_dwAlertCompletionKey;				// alert completion key to use, if any
#endif // ! DPNBUILD_NOHNETFWAPI

		CBilink							m_blDevices;						// list of all IP capable devices
		CBilink							m_blRegisteredPorts;				// list of all the ports registered (may or may not be mapped with an Internet gateway)
		CBilink							m_blUnownedPorts;					// list of all the registered ports which could not be associated with specific devices

		DWORD							m_dwLastUpdateServerStatusTime;		// last time the server status was updated
		DWORD							m_dwNextPollInterval;				// next GetCaps poll interval to use
		DWORD							m_dwNumLeases;						// number of registered ports which have successfully been leased
		DWORD							m_dwEarliestLeaseExpirationTime;	// time when first registered port lease expires, if there are any

		CBilink							m_blUPnPDevices;					// list of all the UPnP devices known (may or may not be connected)
		DWORD							m_dwInstanceKey;					// instance key used for crash cleanup
		DWORD							m_dwCurrentUPnPDeviceID;			// current unique UPnP device ID
		DNHANDLE						m_hMappingStillActiveNamedObject;	// named object used to prevent subsequent objects from cleaning up mappings that are still in use

#ifndef DPNBUILD_NOWINSOCK2
		HMODULE							m_hIpHlpApiDLL;						// handle to iphlpapi.dll, if available
		PFN_GETADAPTERSINFO				m_pfnGetAdaptersInfo;				// pointer to GetAdaptersInfo function
		PFN_GETIPFORWARDTABLE			m_pfnGetIpForwardTable;				// pointer to GetIpForwardTable function
		PFN_GETBESTROUTE				m_pfnGetBestRoute;					// pointer to GetBestRoute function

		HMODULE							m_hRasApi32DLL;						// handle to rasapi32.dll, if available
		PFN_RASGETENTRYHRASCONNW		m_pfnRasGetEntryHrasconnW;			// pointer to RasGetEntryHrasconnW function
		PFN_RASGETPROJECTIONINFO		m_pfnRasGetProjectionInfo;			// pointer to RasGetProjectionInfoA/W function

		SOCKET							m_sIoctls;							// socket being used to submit Ioctls (WinSock2 only)
		WSAOVERLAPPED *					m_polAddressListChange;				// pointer overlapped structure for address list change WSAIoctl call
#endif // ! DPNBUILD_NOWINSOCK2

		HMODULE							m_hWinSockDLL;						// handle to wsock32.dll or ws2_32.dll
		LPFN_WSASTARTUP					m_pfnWSAStartup;					// pointer to WSAStartup function
		LPFN_WSACLEANUP					m_pfnWSACleanup;					// pointer to WSACleanup function
		LPFN_WSAGETLASTERROR			m_pfnWSAGetLastError;				// pointer to WSAGetLastError function
		LPFN_SOCKET						m_pfnsocket;						// pointer to socket function
		LPFN_CLOSESOCKET				m_pfnclosesocket;					// pointer to closesocket function
		LPFN_BIND						m_pfnbind;							// pointer to bind function
		LPFN_SETSOCKOPT					m_pfnsetsockopt;					// pointer to setsockopt function
		LPFN_GETSOCKNAME				m_pfngetsockname;					// pointer to getsockname function
		LPFN_SELECT						m_pfnselect;						// pointer to select function
		LPFN___WSAFDISSET				m_pfn__WSAFDIsSet;					// pointer to __WSAFDIsSet function
		LPFN_RECVFROM					m_pfnrecvfrom;						// pointer to recvfrom function
		LPFN_SENDTO						m_pfnsendto;						// pointer to sendto function
		LPFN_GETHOSTNAME				m_pfngethostname;					// pointer to gethostname function
		LPFN_GETHOSTBYNAME				m_pfngethostbyname;					// pointer to gethostbyname function
		LPFN_INET_ADDR					m_pfninet_addr;						// pointer to inet_addr function
#ifndef DPNBUILD_NOWINSOCK2
		LPFN_WSASOCKETA					m_pfnWSASocketA;					// pointer to WSASocket function
		LPFN_WSAIOCTL					m_pfnWSAIoctl;						// WinSock2 only, pointer to WSAIoctl function
		LPFN_WSAGETOVERLAPPEDRESULT		m_pfnWSAGetOverlappedResult;		// WinSock2 only, pointer to WSAGetOverlappedResult function
#endif // ! DPNBUILD_NOWINSOCK2
		LPFN_IOCTLSOCKET				m_pfnioctlsocket;					// pointer to ioctlsocket function
		LPFN_CONNECT					m_pfnconnect;						// pointer to connect function
		LPFN_SHUTDOWN					m_pfnshutdown;						// pointer to shutdown function
		LPFN_SEND						m_pfnsend;							// pointer to send function
		LPFN_RECV						m_pfnrecv;							// pointer to recv function
#ifdef DBG
		LPFN_GETSOCKOPT					m_pfngetsockopt;					// pointer to getsockopt function


		DWORD							m_dwNumDeviceAdds;					// how many times devices were added
		DWORD							m_dwNumDeviceRemoves;				// how many times devices were removed
		DWORD							m_dwNumServerFailures;				// how many times a UPnP gateway device stopped responding and had to be removed
#endif // DBG



		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CNATHelpUPnP))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x4854414E)	// 0x48 0x54 0x41 0x4E = 'HTAN' = 'NATH' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};

		inline void ResetNextPollInterval(void)
		{
			//
			// Reading this DWORD should be atomic, so no need to hold the
			// globals lock.
			//
			this->m_dwNextPollInterval = g_dwNoActiveNotifyPollInterval;
		};


		HRESULT TakeLock(void);

		void DropLock(void);

		void SwitchToLongLock(void);

		void SwitchFromLongLock(void);

		HRESULT LoadWinSockFunctionPointers(void);
		HRESULT CheckForNewDevices(BOOL * const pfFoundNewDevices);

#ifndef DPNBUILD_NOHNETFWAPI
		HRESULT CheckForLocalHNetFirewallAndMapPorts(CDevice * const pDevice,
													CRegisteredPort * const pDontAlertRegisteredPort);

		HRESULT GetIHNetConnectionForDeviceIfFirewalled(CDevice * const pDevice,
														IHNetCfgMgr * const pHNetCfgMgr,
														IHNetConnection ** const ppHNetConnection);

		HRESULT GetIPAddressGuidString(const TCHAR * const tszDeviceIPAddress,
										TCHAR * const ptszGuidString);

		HRESULT OpenDevicesUPnPDiscoveryPort(CDevice * const pDevice,
											IHNetCfgMgr * const pHNetCfgMgr,
											IHNetConnection * const pHNetConnection);

		HRESULT CloseDevicesUPnPDiscoveryPort(CDevice * const pDevice,
											IHNetCfgMgr * const pHNetCfgMgr);

		HRESULT MapUnmappedPortsOnLocalHNetFirewall(CDevice * const pDevice,
													IHNetCfgMgr * const pHNetCfgMgr,
													IHNetConnection * const pHNetConnection,
													CRegisteredPort * const pDontAlertRegisteredPort);

		HRESULT MapPortOnLocalHNetFirewall(CRegisteredPort * const pRegisteredPort,
											IHNetCfgMgr * const pHNetCfgMgr,
											IHNetConnection * const pHNetConnection,
											const BOOL fNoteAddressChange);

		HRESULT UnmapPortOnLocalHNetFirewall(CRegisteredPort * const pRegisteredPort,
											const BOOL fNeedToDeleteRegValue,
											const BOOL fNoteAddressChange);

		HRESULT UnmapPortOnLocalHNetFirewallInternal(CRegisteredPort * const pRegisteredPort,
													const BOOL fNeedToDeleteRegValue,
													IHNetCfgMgr * const pHNetCfgMgr);

		HRESULT DisableAllBindingsForHNetPortMappingProtocol(IHNetPortMappingProtocol * const pHNetPortMappingProtocol,
															IHNetCfgMgr * const pHNetCfgMgr);

		HRESULT CleanupInactiveFirewallMappings(CDevice * const pDevice,
												IHNetCfgMgr * const pHNetCfgMgr);
#endif // ! DPNBUILD_NOHNETFWAPI

		void RemoveAllItems(void);

		CDevice * FindMatchingDevice(const SOCKADDR_IN * const psaddrinMatch,
									const BOOL fUseAllInfoSources);

		HRESULT ExtendAllExpiringLeases(void);

		HRESULT UpdateServerStatus(void);

		HRESULT RegisterPreviouslyUnownedPortsWithDevice(CDevice * const pDevice,
														const BOOL fWildcardToo);

		HRESULT SendUPnPSearchMessagesForDevice(CDevice * const pDevice,
												const BOOL fRemoteAllowed);

		HRESULT SendUPnPDescriptionRequest(CUPnPDevice * const pUPnPDevice);

		HRESULT UpdateUPnPExternalAddress(CUPnPDevice * const pUPnPDevice,
										const BOOL fUpdateRegisteredPorts);

		HRESULT MapPortsOnUPnPDevice(CUPnPDevice * const pUPnPDevice,
									CRegisteredPort * const pRegisteredPort);

		HRESULT InternalUPnPQueryAddress(CUPnPDevice * const pUPnPDevice,
										const SOCKADDR_IN * const psaddrinQueryAddress,
										SOCKADDR_IN * const psaddrinResponseAddress,
										const DWORD dwFlags);

		HRESULT ExtendUPnPLease(CRegisteredPort * const pRegisteredPort);

		HRESULT UnmapUPnPPort(CRegisteredPort * const pRegisteredPort,
							const DWORD dwMaxValidPort,
							const BOOL fNeedToDeleteRegValue);

		HRESULT CleanupInactiveNATMappings(CUPnPDevice * const pUPnPDevice);

		BOOL IsNATPublicPortInUseLocally(const WORD wPortHostOrder);

		HRESULT CheckForUPnPAnnouncements(const DWORD dwTimeout,
										const BOOL fSendRemoteGatewayDiscovery);

		HRESULT WaitForUPnPConnectCompletions(void);

		HRESULT CheckForReceivedUPnPMsgsOnAllDevices(const DWORD dwTimeout);

		HRESULT CheckForReceivedUPnPMsgsOnDevice(CUPnPDevice * const pUPnPDevice,
												const DWORD dwTimeout);

		HRESULT HandleUPnPDiscoveryResponseMsg(CDevice * const pDevice,
												const SOCKADDR_IN * const psaddrinSource,
												char * const pcMsg,
												const int iMsgSize,
												BOOL * const pfInitiatedConnect);

		HRESULT ReconnectUPnPControlSocket(CUPnPDevice * const pUPnPDevice);

		HRESULT ReceiveUPnPDataStream(CUPnPDevice * const pUPnPDevice);

		void ParseUPnPHeaders(char * const pszMsg,
							UPNP_HEADER_INFO * pHeaderInfo);

		HRESULT GetAddressFromURL(char * const pszLocation,
								SOCKADDR_IN * psaddrinLocation,
								char ** ppszRelativePath);

		HRESULT HandleUPnPDescriptionResponseBody(CUPnPDevice * const pUPnPDevice,
												const DWORD dwHTTPResponseCode,
												char * const pszDescriptionXML);

		HRESULT HandleUPnPControlResponseBody(CUPnPDevice * const pUPnPDevice,
											const DWORD dwHTTPResponseCode,
											char * const pszControlResponseSOAP);

		HRESULT ParseXML(char * const pszXML,
						PARSEXML_ELEMENT * const pParseElement,
						const PARSECALLBACK ParseCallback,
						PVOID pvContext);

		static void ParseXMLAttributes(char * const pszString,
										char ** const apszAttributeNames,
										char ** const apszAttributeValues,
										const DWORD dwMaxNumAttributes,
										DWORD * const pdwNumAttributes);

		BOOL MatchesXMLStringWithoutNamespace(const char * const szCompareString,
											const char * const szMatchString,
											const PARSEXML_STACKENTRY * const aElementStack,
											const PARSEXML_SUBELEMENT * const pSubElement,
											const DWORD dwElementStackDepth);

		static char * GetStringWithoutNamespacePrefix(const char * const szString,
												const PARSEXML_STACKENTRY * const aElementStack,
												const PARSEXML_SUBELEMENT * const pSubElement,
												const DWORD dwElementStackDepth);

		BOOL GetNextChunk(char * const pszBuffer,
						const DWORD dwBufferSize,
						char ** const ppszChunkData,
						DWORD * const pdwChunkSize,
						char ** const ppszBufferRemaining,
						DWORD * const pdwBufferSizeRemaining);

		HRESULT ParseXMLCallback_DescriptionResponse(PARSEXML_ELEMENT * const pParseElement,
													PVOID pvContext,
													PARSEXML_STACKENTRY * const aElementStack,
													BOOL * const pfContinueParsing);

		HRESULT ParseXMLCallback_ControlResponse(PARSEXML_ELEMENT * const pParseElement,
												PVOID pvContext,
												PARSEXML_STACKENTRY * const aElementStack,
												BOOL * const pfContinueParsing);

		void ClearDevicesUPnPDevice(CDevice * const pDevice);

		void ClearAllUPnPRegisteredPorts(CDevice * const pDevice);

#ifndef DPNBUILD_NOWINSOCK2
		HRESULT RequestLocalAddressListChangeNotification(void);
#endif // ! DPNBUILD_NOWINSOCK2

		SOCKET CreateSocket(SOCKADDR_IN * const psaddrinAddress,
							int iType,
							int iProtocol);

		BOOL GetAddressToReachGateway(CDevice * const pDevice,
									IN_ADDR * const pinaddr);

		BOOL IsAddressLocal(CDevice * const pDevice,
							const SOCKADDR_IN * const psaddrinAddress);

		void ExpireOldCachedMappings(void);

#ifdef WINNT
		BOOL IsUPnPServiceDisabled(void);
#endif // WINNT


#ifdef DBG
		static void PrintUPnPTransactionToFile(const char * const szString,
										const int iStringLength,
										const char * const szDescription,
										CDevice * const pDevice);
#endif // DBG

#ifdef DBG
		void DebugPrintCurrentStatus(void);

#ifndef DPNBUILD_NOHNETFWAPI
		void DebugPrintActiveFirewallMappings(void);
#endif // ! DPNBUILD_NOHNETFWAPI

		void DebugPrintActiveNATMappings(void);
#endif // DBG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\guids\sources.inc ===
TARGETNAME=guids
TARGETTYPE=LIBRARY

INCLUDES=..\..\inc; \
	$(DXROOT)\inc; \
	$(NET_INC_PATH); \
	$(SDK_INC_PATH)

SOURCES=guids.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\upnpmsgs.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       upnpmsgs.h
 *
 *  Content:	Messages for UPnP (Universal Plug-and-Play).  Strings
 *				listed here are not to be localized.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  02/08/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Constant definitions
//=============================================================================
#define UPNP_DISCOVERY_MULTICAST_ADDRESS		"239.255.255.250"
#define UPNP_PORT								1900
#define UPNP_PORT_A								"1900"

#define UPNP_WILDCARD							""
#define UPNP_BOOLEAN_FALSE						"0"
#define UPNP_BOOLEAN_TRUE						"1"


#define HTTP_PREFIX								"HTTP/"
#define HTTP_VERSION							HTTP_PREFIX "1.1"
#define HTTP_VERSION_ALT						HTTP_PREFIX "1.0"
#define HTTP_PORT								80

#define EOL										"\r\n"



//=============================================================================
// XML standard names
//=============================================================================
#define XML_NAMESPACEDEFINITIONPREFIX			"xmlns:"

#define XML_DEVICEDESCRIPTION_SERVICETYPE		"serviceType"
#define XML_DEVICEDESCRIPTION_SERVICEID			"serviceId"
#define XML_DEVICEDESCRIPTION_CONTROLURL		"controlURL"




//=============================================================================
// Standard namespaces
//=============================================================================
#define URI_CONTROL_A							"urn:schemas-upnp-org:control-1-0"
#define	URL_SOAPENVELOPE_A						"http://schemas.xmlsoap.org/soap/envelope/"
#define URL_SOAPENCODING_A						"http://schemas.xmlsoap.org/soap/encoding/"




//=============================================================================
// Devices
//=============================================================================
#define URI_DEVICE_WANCONNECTIONDEVICE_W		L"urn:schemas-upnp-org:device:WANConnectionDevice:1"




//=============================================================================
// Services
//=============================================================================
#define URI_SERVICE_WANIPCONNECTION_A			"urn:schemas-upnp-org:service:WANIPConnection:1"
#define URI_SERVICE_WANPPPCONNECTION_A			"urn:schemas-upnp-org:service:WANPPPConnection:1"





//=============================================================================
// Standard control variables
//=============================================================================
#define ARG_CONTROL_ERROR_ERRORCODE_A			"errorCode"
#define ARG_CONTROL_ERROR_ERRORDESCRIPTION_A	"errorDescription"

#define CONTROL_RESPONSESUFFIX_A				"Response"




/*
//=============================================================================
// State variable querying
//=============================================================================
#define CONTROL_QUERYSTATEVARIABLE_A			"QueryStateVariable"


// Input

#define ARG_CONTROL_VARNAME_A					"varName"


// Output

#define ARG_CONTROL_RETURN_A					"return"



// Variables

#define VAR_EXTERNALIPADDRESS_A					"ExternalIPAddress"
*/





//=============================================================================
// Actions
//=============================================================================


// Action

/*

	GetExternalIPAddress?

*/
#define ACTION_GETEXTERNALIPADDRESS_A									"GetExternalIPAddress"


// In args


// Out args
#define ARG_GETEXTERNALIPADDRESS_NEWEXTERNALIPADDRESS_A					"NewExternalIPAddress"





// Action

/*
2.4.16.	AddPortMapping

	This action creates a new port mapping or overwrites an existing mapping
	with the same internal client. If the ExternalPort and PortMappingProtocol
	pair is already mapped to another internal client, an error is returned.

	NOTE: Not all NAT implementations will support: 
	*	Wildcard values for ExternalPort
	*	InternalPort values that are different from ExternalPort
	*	Dynamic port mappings i.e. with non-Infinite PortMappingLeaseDuration 
*/
#define ACTION_ADDPORTMAPPING_A											"AddPortMapping"


// In args
/*
2.2.15.	RemoteHost

	This variable represents the source of inbound IP packets. This will be a
	wildcard in most cases. NAT vendors are only required to support wildcards.
	A non-wildcard value will allow for "narrow" port mappings, which may be
	desirable in some usage scenarios.When RemoteHost is a wildcard, all
	traffic sent to the ExternalPort on the WAN interface of the gateway is
	forwarded to the InternalClient on the InternalPort. When RemoteHost is
	specified as one external IP address as opposed to a wild card, the NAT
	will only forward inbound packets from this RemoteHost to the
	InternalClient, all other packets will be dropped.
*/
#define ARG_ADDPORTMAPPING_NEWREMOTEHOST_A								"NewRemoteHost"

/*
2.2.16.	ExternalPort

	This variable represents the external port that the NAT gateway would
	"listen" on for connection requests to a corresponding InternalPort on an
	InternalClient. A value of 0 essentially implies that the gateway should
	listen on the same port as InternalPort. Inbound packets to this external
	port on the WAN interface of the gateway should be forwarded to
	InternalClient on the InternalPort on which the message was received. If
	this value is specified as a wildcard, connection request on all external
	ports will be forwarded to InternalClient. Obviously only one such entry
	can exist in the NAT at any time and conflicts are handled with a "first
	write wins" behavior.
*/
#define ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A							"NewExternalPort"

/*
2.2.18.	PortMappingProtocol

	This variable represents the protocol of the port mapping. Possible values
	are TCP or UDP.
*/
#define ARG_ADDPORTMAPPING_NEWPROTOCOL_A								"NewProtocol"

/*
2.2.17.	InternalPort

	This variable represents the port on InternalClient that the gateway should
	forward connection requests to. A value of 0 is not allowed. NAT
	implementations that do not permit different values for ExternalPort and
	InternalPort will return an error.
*/
#define ARG_ADDPORTMAPPING_NEWINTERNALPORT_A							"NewInternalPort"

/*
2.2.19.	InternalClient

	This variable represents the IP address or DNS host name of an internal
	client (on the residential LAN). Note that if the gateway does not support
	DHCP, it does not have to support DNS host names. Consequently, support for
	an IP address is mandatory and support for DNS host names is recommended.
	This value cannot be a wild card.  It must be possible to set the
	InternalClient to the broadcast IP address 255.255.255.255 for UDP
	mappings. This is to enable multiple NAT clients to use the same well-
	known port simultaneously.
*/
#define ARG_ADDPORTMAPPING_NEWINTERNALCLIENT_A							"NewInternalClient"

/*
2.2.13.	PortMappingEnabled

	This variable allows security conscious users to disable and enable NAT
	port mappings. It can also support persistence of port mappings.
*/
#define ARG_ADDPORTMAPPING_NEWENABLED_A									"NewEnabled"

/*
2.2.20.	PortMappingDescription

	This is a string representation of a port mapping and is applicable for
	static and dynamic port mappings. The format of the description string is
	not specified and is application dependent. If specified, the description
	string can be displayed to a user via the UI of a control point, enabling
	easier management of port mappings. The description string for a port
	mapping (or a set of related port mappings) may or may not be unique across
	multiple instantiations of an application on multiple nodes in the
	residential LAN.
*/
#define ARG_ADDPORTMAPPING_NEWPORTMAPPINGDESCRIPTION_A					"NewPortMappingDescription"

/*
2.2.14.	PortMappingLeaseDuration

	This variable determines the time to live in seconds of a port-mapping
	lease. A value of 0 means the port mapping is static. Non-zero values will
	allow support for dynamic port mappings.  Note that static port mappings do
	not necessarily mean persistence of these mappings across device resets or
	reboots. It is up to a gateway vendor to implement persistence as
	appropriate for their IGD device.
*/
#define ARG_ADDPORTMAPPING_NEWLEASEDURATION_A							"NewLeaseDuration"


// Out args





// Action

/*
2.4.15.	GetSpecificPortMappingEntry

	This action reports the Static Port Mapping specified by the unique tuple
	of RemoteHost, ExternalPort and PortMappingProtocol.
*/
#define ACTION_GETSPECIFICPORTMAPPINGENTRY_A							"GetSpecificPortMappingEntry"


// In args
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWREMOTEHOST_A					ARG_ADDPORTMAPPING_NEWREMOTEHOST_A
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWEXTERNALPORT_A				ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPROTOCOL_A					ARG_ADDPORTMAPPING_NEWPROTOCOL_A


// Out args
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALPORT_A				ARG_ADDPORTMAPPING_NEWINTERNALPORT_A
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWINTERNALCLIENT_A				ARG_ADDPORTMAPPING_NEWINTERNALCLIENT_A
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWENABLED_A					ARG_ADDPORTMAPPING_NEWENABLED_A
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWPORTMAPPINGDESCRIPTION_A		ARG_ADDPORTMAPPING_NEWPORTMAPPINGDESCRIPTION_A
#define ARG_GETSPECIFICPORTMAPPINGENTRY_NEWLEASEDURATION_A				ARG_ADDPORTMAPPING_NEWLEASEDURATION_A







// Action

/*
2.4.17.	DeletePortMapping

	This action deletes a previously instantiated port mapping.

	Inbound connections are no longer permitted on the port mapping being
	deleted.
*/
#define ACTION_DELETEPORTMAPPING_A										"DeletePortMapping"


// In args
#define ARG_DELETEPORTMAPPING_NEWREMOTEHOST_A							ARG_ADDPORTMAPPING_NEWREMOTEHOST_A
#define ARG_DELETEPORTMAPPING_NEWEXTERNALPORT_A							ARG_ADDPORTMAPPING_NEWEXTERNALPORT_A
#define ARG_DELETEPORTMAPPING_NEWPROTOCOL_A								ARG_ADDPORTMAPPING_NEWPROTOCOL_A


// Out args





//=============================================================================
// HTTP/SSDP/SOAP/UPnP header strings (located in intfobj.cpp)
//=============================================================================

#define RESPONSEHEADERINDEX_CACHECONTROL		0
#define RESPONSEHEADERINDEX_DATE				1
#define RESPONSEHEADERINDEX_EXT					2
#define RESPONSEHEADERINDEX_LOCATION			3
#define RESPONSEHEADERINDEX_SERVER				4
#define RESPONSEHEADERINDEX_ST					5
#define RESPONSEHEADERINDEX_USN					6

#define RESPONSEHEADERINDEX_CONTENTLANGUAGE		7
#define RESPONSEHEADERINDEX_CONTENTLENGTH		8
#define RESPONSEHEADERINDEX_CONTENTTYPE			9
#define RESPONSEHEADERINDEX_TRANSFERENCODING	10

#define RESPONSEHEADERINDEX_HOST				11
#define RESPONSEHEADERINDEX_NT					12
#define RESPONSEHEADERINDEX_NTS					13
#define RESPONSEHEADERINDEX_MAN					14
#define RESPONSEHEADERINDEX_MX					15
#define RESPONSEHEADERINDEX_AL					16
#define RESPONSEHEADERINDEX_CALLBACK			17
#define RESPONSEHEADERINDEX_TIMEOUT				18
#define RESPONSEHEADERINDEX_SCOPE				19
#define RESPONSEHEADERINDEX_SID					20
#define RESPONSEHEADERINDEX_SEQ					21

#define NUM_RESPONSE_HEADERS					22

extern const char *		c_szResponseHeaders[NUM_RESPONSE_HEADERS];




//=============================================================================
// Pre-built UPnP message strings (located in intfobj.cpp)
//=============================================================================

/*
1.2.2 Discovery: Search: Request with M-SEARCH 

(No body for request with method M-SEARCH, but note that the message must have a blank line following the last HTTP header.)

	Request line 
		M-SEARCH 
			Method defined by SSDP for search requests. 
		* 
			Request applies generally and not to a specific resource. Must be *. 
		HTTP/1.1 
			HTTP version. 

	Headers
		HOST 
			Required. Multicast channel and port reserved for SSDP by Internet Assigned Numbers Authority (IANA). Must be 239.255.255.250:1900. 
		MAN 
			Required. Unlike the NTS and ST headers, the value of the MAN header is enclosed in double quotes. Must be "ssdp:discover". 
		MX 
			Required. Maximum wait. Device responses should be delayed a random duration between 0 and this many seconds to balance load for the control point when it processes responses. This value should be increased if a large number of devices are expected to respond or if network latencies are expected to be significant.  Specified by UPnP vendor. Integer. 
		ST 
			Required header defined by SSDP. Search Target. Must be one of the following. (cf. NT header in NOTIFY with ssdp:alive above.) Single URI. 

			ssdp:all 
				Search for all devices and services. 
			upnp:rootdevice 
				Search for root devices only. 
			uuid:device-UUID 
				Search for a particular device. Device UUID specified by UPnP vendor. 
			urn:schemas-upnp-org:device:deviceType:v 
				Search for any device of this type. Device type and version defined by UPnP Forum working committee. 
			urn:schemas-upnp-org:service:serviceType:v 
				Search for any service of this type. Service type and version defined by UPnP Forum working committee.  
*/
extern const char	c_szUPnPMsg_Discover_Service_WANIPConnection[];
extern const char	c_szUPnPMsg_Discover_Service_WANPPPConnection[];


/*
1.2.3 Discovery: Search: Response

(No body for a response to a request with method M-SEARCH, but note that the message must have a blank line following the last HTTP header.)

	Response line
		HTTP/1.1 200 OK

	Headers
		CACHE-CONTROL 
			Required. Must have max-age directive that specifies number of seconds the advertisement is valid. After this duration, control points should assume the device (or service) is no longer available. Should be > 1800 seconds (30 minutes). Specified by UPnP vendor. Integer.  
		DATE 
			Recommended. When response was generated. RFC 1123 date. 
		EXT 
			Required. Confirms that the MAN header was understood. (Header only; no value.) 
		LOCATION 
			Required. Contains a URL to the UPnP description of the root device. In some unmanaged networks, host of this URL may contain an IP address (versus a domain name). Specified by UPnP vendor. Single URL.
		SERVER 
			Required. Concatenation of OS name, OS version, UPnP/1.0, product name, and product version. Specified by UPnP vendor. String. 
		ST 
			Required header defined by SSDP. Search Target. Single URI. If ST header in request was, 

			ssdp:all 
				Respond 3+2d+k times for a root device with d embedded devices and s embedded services but only k distinct service types. Value for ST header must be the same as for the NT header in NOTIFY messages with ssdp:alive. (See above.) Single URI. 
			upnp:rootdevice 
				Respond once for root device. Must be upnp:rootdevice. Single URI.	
			uuid:device-UUID
				Respond once for each device, root or embedded. Must be uuid:device-UUID. Device UUID specified by UPnP vendor. Single URI. 
			urn:schemas-upnp-org:device:deviceType:v 
				Respond once for each device, root or embedded. Must be urn:schemas-upnp-org:device:deviceType:v. Device type and version defined by UPnP Forum working committee. 
			urn:schemas-upnp-org:service:serviceType:v 
				Respond once for each service. Must be urn:schemas-upnp-org:service:serviceType:v. Service type and version defined by UPnP Forum working committee. 
		USN 
			Required header defined by SSDP. Unique Service Name. (See list of required values for USN header in NOTIFY with ssdp:alive above.) Single URI. 

*/



/*
2.9 Description: Retrieving a description: Request

(No body for request to retrieve a description, but note that the message must have a blank line following the last HTTP header.) 

	Request line
		GET 
			Method defined by HTTP. 
		path to description 
			Path component of device description URL (LOCATION header in discovery message) or of service description URL (SCPDURL element in device description). Single, relative URL. 
		HTTP/1.1 
			HTTP version. 

	Headers
		HOST 
			Required. Domain name or IP address and optional port components of device description URL (LOCATION header in discovery message) or of service description URL (SCPDURL element of device description). If the port is empty or not given, port 80 is assumed. 
		ACCEPT-LANGUAGE 
			Recommended for retrieving device descriptions. Preferred language(s) for description. If no description is available in this language, device may return a description in a default language. RFC 1766 language tag(s). 
*/


/*
2.9 Description: Retrieving a description: Response

The body of this response is a UPnP device or service XML description.

	Response line
		HTTP/1.1 200 OK

	Headers
		CONTENT-LANGUAGE 
			Required if and only if request included an ACCEPT-LANGUAGE header. Language of description. RFC 1766 language tag(s). 
		CONTENT-LENGTH 
			Required. Length of body in Bytes. Integer. 
		CONTENT-TYPE 
			Required. Must be text/xml. 
		DATE 
			Recommended. When response was generated. RFC 1123 date. 
*/

//
// Description response XML format (parts we're interested in, anyway):
//
//	<?xml version="1.0"?>
//	<root xmlns="urn:schemas-upnp-org:device-1-0">
//	  <device>
//	    <serviceList>
//	      <service>
//	        <serviceType>urn:schemas-upnp-org:service:serviceType:v</serviceType>
//	        <serviceId>urn:upnp-org:serviceId:serviceID</serviceId>
//	        <controlURL>URL for control</controlURL>
//	      </service>
//	    </serviceList>
//	  </device>
//	</root>
//
// i.e. the element stack is "?xml/root/device/serviceList/service".
//
extern const char *		c_szElementStack_service[];




/*
3.3.1 Control: Query: Invoke

	Request line
		POST 
			Method defined by HTTP. 
		path of control URL 
			Path component of URL for control for this service (controlURL sub element of service element of device description). Single, relative URL. 
		HTTP/1.1 
			HTTP version. 

	Headers
		HOST 
			Required. Domain name or IP address and optional port components of URL for control for this service (controlURL sub element of service element of device description). If the port is empty or not given, port 80 is assumed. 
		ACCEPT-LANGUAGE 
			(No ACCEPT-LANGUAGE header is used in control messages.) 
		CONTENT-LENGTH 
			Required. Length of body in bytes. Integer. 
		CONTENT-TYPE 
			Required. Must be text/xlm. Should include character coding used, e.g., utf-8. 
		MAN 
			(No MAN header in request with method POST.) 
		SOAPACTION 
			Required header defined by SOAP. Must be "urn:schemas-upnp-org:control-1-0#QueryStateVariable". If used in a request with method M-POST, header name must be qualified with HTTP name space defined in MAN header. Single URI. 

	Body
		Envelope 
			Required element defined by SOAP. xmlns namespace attribute must be "http://schemas.xmlsoap.org/soap/envelope/". Must include encodingStyle attribute with value "http://schemas.xmlsoap.org/soap/encoding/". Contains the following sub elements: 
		Body 
			Required element defined by SOAP. Should be qualified with SOAP namespace. Contains the following sub element: 

			QueryStateVariable 
				Required element defined by UPnP. Action name. xmlns namespace attribute must be "urn:schemas-upnp-org:control-1-0". Must be the first sub element of Body. Contains the following, ordered sub element: 

				varName 
					Required element defined by UPnP. Variable name. Must be qualified by QueryStateVariable namespace. Values is name of state variable to be queried. String.  
*/

/*
3.3.2 Control: Query: Response: Success

	Response line
		HTTP/1.1 
			HTTP version. 
		200 OK 
			HTTP success code. 

	Headers
		CONTENT-LANGUAGE 
			(No CONTENT-LANGUAGE header is used in control messages.) 
		CONTENT-LENGTH 
			Required. Length of body in bytes. Integer. 
		CONTENT-TYPE 
			Required. Must be text/xlm. Should include character coding used, e.g., utf-8. 
		DATE 
			Recommended. When response was generated. RFC 1123 date. 
		EXT 
			Required. Confirms that the MAN header was understood. (Header only; no value.) 
		SERVER 
			Required. Concatenation of OS name, OS version, UPnP/1.0, product name, and product version. String. 

	Body
		Envelope 
			Required element defined by SOAP. xmlns namespace attribute must be "http://schemas.xmlsoap.org/soap/envelope/". Must include encodingStyle attribute with value "http://schemas.xmlsoap.org/soap/encoding/". Contains the following sub elements: 
		Body 
			Required element defined by SOAP. Should be qualified with SOAP namespace. Contains the following sub element: 

			QueryStateVariableResponse 
				Required element defined by UPnP and SOAP. xmlns namespace attribute must be "urn:schemas-upnp-org:control-1-0". Must be the first sub element of Body. Contains the following sub element: 

				return 
					Required element defined by UPnP. (Element name not qualified by a namespace; element nesting context is sufficient.) Value is current value of the state variable specified in varName element in request. 
*/

//
// Control sucess response SOAP XML format (parts we're interested in, anyway):
//
//	<s:Envelope
//	    xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
//	    s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
//	  <s:Body>
//	    <u:QueryStateVariableResponse xmlns:u="urn:schemas-upnp-org:control-1-0">
//	      <return>variable value</return>
//	    </u:QueryStateVariableResponse>
//	  </s:Body>
//	</s:Envelope>

//
// i.e. the element stack is "s:Envelope/s:Body/u:QueryStateVariableResponse".
//
//extern const char *		c_szElementStack_QueryStateVariableResponse[];



/*
3.2.1 Control: Action: Invoke

	Request line
		POST 
			Method defined by HTTP. 
		path control URL 
			Path component of URL for control for this service (controlURL sub element of service element of device description). Single, relative URL. 
		HTTP/1.1 
			HTTP version. 

	Headers
		HOST 
			Required. Domain name or IP address and optional port components of URL for control for this service (controlURL sub element of service element of device description). If the port is empty or not given, port 80 is assumed. 
		ACCEPT-LANGUAGE 
			(No ACCEPT-LANGUAGE header is used in control messages.) 
		CONTENT-LENGTH 
			Required. Length of body in bytes. Integer. 
		CONTENT-TYPE 
			Required. Must be text/xlm. Should include character coding used, e.g., utf-8. 
		SOAPACTION 
			Required header defined by SOAP. Must be the service type, hash mark, and name of action to be invoked, all enclosed in double quotes. If used in a request with method M-POST, header name must be qualified with HTTP name space defined in MAN header. Single URI. 

	Body
		Envelope 
			Required element defined by SOAP. xmlns namespace attribute must be "http://schemas.xmlsoap.org/soap/envelope/". Must include encodingStyle attribute with value "http://schemas.xmlsoap.org/soap/encoding/". Contains the following sub elements: 

			Body 
				Required element defined by SOAP. Should be qualified with SOAP namespace. Contains the following sub element: 

				actionName 
					Required. Name of element is name of action to invoke. xmlns namespace attribute must be the service type enclosed in double quotes. Must be the first sub element of Body. Contains the following, ordered sub element(s): 

					argumentName 
						Required if and only if action has in arguments. Value to be passed to action. Repeat once for each in argument. (Element name not qualified by a namespace; element nesting context is sufficient.) Single data type as defined by UPnP service description. 
*/

/*
3.2.2 Control: Action: Response: Success

	Response line
		HTTP/1.1 
			HTTP version. 
		200 OK 
			HTTP success code. 

	Headers
		CONTENT-LANGUAGE 
			(No CONTENT-LANGUAGE header is used in control messages.) 
		CONTENT-LENGTH 
			Required. Length of body in bytes. Integer. 
		CONTENT-TYPE 
			Required. Must be text/xlm. Should include character coding used, e.g., utf-8. 
		DATE 
			Recommended. When response was generated. RFC 1123 date. 
		EXT 
			Required. Confirms that the MAN header was understood. (Header only; no value.) 
		SERVER 
			Required. Concatenation of OS name, OS version, UPnP/1.0, product name, and product version. String. 

	Body
		Envelope 
			Required element defined by SOAP. xmlns namespace attribute must be "http://schemas.xmlsoap.org/soap/envelope/". Must include encodingStyle attribute with value "http://schemas.xmlsoap.org/soap/encoding/". Contains the following sub elements: 

			Body 
				Required element defined by SOAP. Should be qualified with SOAP namespace. Contains the following sub element: 

				actionNameResponse 
					Required. Name of element is action name prepended to Response. xmlns namespace attribute must be service type enclosed in double quotes. Must be the first sub element of Body. Contains the following sub element: 

					argumentName 
						Required if and only if action has out arguments. Value returned from action. Repeat once for each out argument. If action has an argument marked as retval, this argument must be the first element. (Element name not qualified by a namespace; element nesting context is sufficient.) Single data type as defined by UPnP service description. 
*/

//
// Control sucess response SOAP XML format (parts we're interested in, anyway):
//
//	<s:Envelope
//	    xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
//	    s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
//	  <s:Body>
//	    <u:actionNameResponse xmlns:u="urn:schemas-upnp-org:service:serviceType:v">
//	      <argumentName>out arg value</argumentName>
//	    </u:actionNameResponse>
//	  </s:Body>
//	</s:Envelope>
//
// i.e. the element stack is "s:Envelope/s:Body/u:actionNameResponse".
//
extern const char *		c_szElementStack_GetExternalIPAddressResponse[];
extern const char *		c_szElementStack_AddPortMappingResponse[];
extern const char *		c_szElementStack_GetSpecificPortMappingEntryResponse[];
extern const char *		c_szElementStack_DeletePortMappingResponse[];

/*
3.2.2 Control: Action: Response: Failure

	Response line
		HTTP/1.1 
			HTTP version. 
		500 Internal Server Error 
			HTTP error code. 

	Headers
		CONTENT-LANGUAGE 
			(No CONTENT-LANGUAGE header is used in control messages.) 
		CONTENT-LENGTH 
			Required. Length of body in bytes. Integer. 
		CONTENT-TYPE 
			Required. Must be text/xlm. Should include character coding used, e.g., utf-8. 
		DATE 
			Recommended. When response was generated. RFC 1123 date. 
		EXT 
			Required. Confirms that the MAN header was understood. (Header only; no value.) 
		SERVER 
			Required. Concatenation of OS name, OS version, UPnP/1.0, product name, and product version. String. 

	Body
		Envelope 
			Required element defined by SOAP. xmlns namespace attribute must be "http://schemas.xmlsoap.org/soap/envelope/". Must include encodingStyle attribute with value "http://schemas.xmlsoap.org/soap/encoding/". Contains the following sub elements: 

			Body 
				Required element defined by SOAP. Should be qualified with SOAP namespace. Contains the following sub element: 

				Fault 
					Required element defined by SOAP. Error encountered while invoking action. Should be qualified with SOAP namespace. Contains the following sub elements: 

					faultcode 
						Required element defined by SOAP. Value must be qualified with the SOAP namespace. Must be Client. 

					faultstring 
						Required element defined by SOAP. Must be UPnPError. 

					detail 
						Required element defined by SOAP. 

						UPnPError 
							Required element defined by UPnP. 

						errorCode 
							Required element defined by UPnP. Code identifying what error was encountered. See table immediately below for values. Integer. 

						errorDescription 
							Recommended element defined by UPnP. Short description. See table immediately below for values. String. Recommend < 256 characters. 
*/

//
// Control failure response SOAP XML format (parts we're interested in, anyway):
//
//	<s:Envelope
//	    xmlns:s="http://schemas.xmlsoap.org/soap/envelope/"
//	    s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
//	  <s:Body>
//	    <s:Fault>
//	      <faultcode>s:Client</faultcode>
//	      <faultstring>UPnPError</faultstring>
//	      <detail>
//	        <UPnPError xmlns="urn:schemas-upnp-org:control-1-0">
//	          <errorCode>error code</errorCode>
//	          <errorDescription>error string</errorDescription>
//	        </UPnPError>
//	      </detail>
//	    </s:Fault>
//	  </s:Body>
//	</s:Envelope>
//
// i.e. the element stack is "s:Envelope/s:Body/s:Fault/detail/UPnPError".
//
extern const char *		c_szElementStack_ControlResponseFailure[];





//=============================================================================
// Errors
//=============================================================================

//
// See UPnP Device Architecture section on Control.
//
#define UPNPERR_INVALIDARGS								402


//
// The specified value does not exist in the array.
//
#define UPNPERR_IGD_NOSUCHENTRYINARRAY					714

//
// The source IP address cannot be wild-carded.
//
#define UPNPERR_IGD_WILDCARDNOTPERMITTEDINSRCIP			715

//
// The external port cannot be wild-carded.
//
#define UPNPERR_IGD_WILDCARDNOTPERMITTEDINEXTPORT		716



//
// The service mapping entry specified conflicts with a mapping assigned
// previously to another client.
//
#define UPNPERR_IGD_CONFLICTINMAPPINGENTRY				718


//
// Internal and External port values must be the same.
//
#define UPNPERR_IGD_SAMEPORTVALUESREQUIRED				724

//
// The NAT implementation only supports permanent lease times on port mappings.
//
#define UPNPERR_IGD_ONLYPERMANENTLEASESSUPPORTED		725
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\inc\dpnathlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnathlp.h
 *
 *  Content:	Header for using DirectPlayNATHelp interface.
//@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *  05/16/01  VanceO    Added DPNHADDRESSTYPE_GATEWAYISLOCAL.
 *  05/31/01  VanceO    Changed DPNHCAPS flags to be more specific about
 *						type of server(s) detected.
 *  06/26/01  VanceO    Added DPNHERR_REENTRANT error code.
//@@END_MSINTERNAL
 *
 ***************************************************************************/



#ifndef __DPNATHLP_H__
#define __DPNATHLP_H__



#include <ole2.h>	// for DECLARE_INTERFACE and HRESULT



#ifndef DPNATHLP_EXPORTS
#define DPNATHLPAPI DECLSPEC_IMPORT
#else
#define DPNATHLPAPI
#endif



#ifdef __cplusplus
extern "C" {
#endif





/****************************************************************************
 *
 * DirectPlay NAT Helper object class IDs
 *
 ****************************************************************************/

// {B9C2E9C4-68C1-4d42-A7A1-E76A26982AD6}
DEFINE_GUID(CLSID_DirectPlayNATHelpUPnP, 
0xb9c2e9c4, 0x68c1, 0x4d42, 0xa7, 0xa1, 0xe7, 0x6a, 0x26, 0x98, 0x2a, 0xd6);

// {963AB779-16A1-477c-A36D-CB5E711938F7}
DEFINE_GUID(CLSID_DirectPlayNATHelpPAST, 
0x963ab779, 0x16a1, 0x477c, 0xa3, 0x6d, 0xcb, 0x5e, 0x71, 0x19, 0x38, 0xf7);




/****************************************************************************
 *
 * DirectPlay NAT Helper interface ID
 *
 ****************************************************************************/

// {154940B6-2278-4a2f-9101-9BA9F431F603}
DEFINE_GUID(IID_IDirectPlayNATHelp, 
0x154940b6, 0x2278, 0x4a2f, 0x91, 0x1, 0x9b, 0xa9, 0xf4, 0x31, 0xf6, 0x3);




//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DirectPlay NAT Helper registry base
 *
 ****************************************************************************/

#define DIRECTPLAYNATHELP_REGKEY	L"Software\\Microsoft\\DirectPlayNATHelp"





//@@END_MSINTERNAL
/****************************************************************************
 *
 * DirectPlay NAT Helper interface pointer definitions
 *
 ****************************************************************************/

typedef	struct IDirectPlayNATHelp     *PDIRECTPLAYNATHELP;




/****************************************************************************
 *
 * DirectPlay NAT Helper data types
 *
 ****************************************************************************/

//
// Handles used to identify specific port binding groups.  If multiple ports
// are registered at the same time, the DPNHHANDLE refers to all ports.
//
typedef DWORD_PTR	DPNHHANDLE,	* PDPNHHANDLE;




/****************************************************************************
 *
 * DirectPlay NAT Helper constants
 *
 ****************************************************************************/

#define DPNH_MAX_SIMULTANEOUS_PORTS		16	// up to 16 ports may be specified in a single RegisterPorts call




/****************************************************************************
 *
 * DirectPlay NAT Helper API flags
 *
 ****************************************************************************/

//
// Flags that can be passed to Initialize
//
#define DPNHINITIALIZE_DISABLEGATEWAYSUPPORT				0x01	// disables Internet gateway traversal support (cannot be specified with DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
#define DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT			0x02	// disables local firewall traversal support (cannot be specified with DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)

//
// Flags that can be passed to GetCaps.
//
#define DPNHGETCAPS_UPDATESERVERSTATUS						0x01	// automatically extend expiring leases and detect changes in server status

//
// Flags that can be passed to RegisterPorts.
//
#define DPNHREGISTERPORTS_TCP								0x01	// request TCP ports instead of UDP
#define DPNHREGISTERPORTS_FIXEDPORTS						0x02	// asks the server to use the same port numbers on the public interface
#define DPNHREGISTERPORTS_SHAREDPORTS						0x04	// requests that the server allow the UDP fixed ports to be shared with other clients (must be specified with DPNHREGISTERPORTS_FIXEDPORTS and cannot be specified with DPNHREGISTERPORTS_TCP)

//
// Flags that can be passed to GetRegisteredAddresses.
//
#define DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY	0x01	// retrieve the public address for the local firewall only, even if mapped on remote Internet gateway

//
// Flags that can be passed to QueryAddress.
//
#define DPNHQUERYADDRESS_TCP								0x01	// request a TCP port instead of UDP
#define DPNHQUERYADDRESS_CACHEFOUND							0x02	// cache the discovered address if found
#define DPNHQUERYADDRESS_CACHENOTFOUND						0x04	// cache the fact that no address was found, if that is the case
#define DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED			0x08	// determine if the address is behind the same Internet gateway, but not mapped on that Internet gateway




/****************************************************************************
 *
 * DirectPlay NAT Helper structure flags
 *
 ****************************************************************************/

//
// DPNHCAPS flags
//
#define DPNHCAPSFLAG_LOCALFIREWALLPRESENT		0x01	// at least one network connection has a local firewall present
#define DPNHCAPSFLAG_GATEWAYPRESENT				0x02	// at least one network connection has an Internet gateway present
#define DPNHCAPSFLAG_GATEWAYISLOCAL				0x04	// a detected Internet gateway is local (i.e. the public address is another network interface on the same machine)
#define DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE		0x08	// at least one server has a valid public address for registered mappings
#define DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY	0x10	// at least one available server does not support an active-notification mechanisms and must be polled





/****************************************************************************
 *
 * DirectPlay NAT Helper structures
 *
 ****************************************************************************/
 
typedef struct _DPNHCAPS
{
	DWORD	dwSize;							// size of this structure, must be filled in prior to calling GetCaps
	DWORD	dwFlags;						// flags indicating capabilities of Internet gateway server(s)
	DWORD	dwNumRegisteredPorts;			// number of ports currently registered, including multiple ports registered at the same time (so this may not be equal to the number of DPNHHANDLEs given out)
	DWORD	dwMinLeaseTimeRemaining;		// approximate time remaining, in milliseconds, for the lease that will expire soonest
	DWORD	dwRecommendedGetCapsInterval;	// recommended time, in milliseconds, after which GetCaps should be called again (with DPNHGETCAPS_UPDATESERVERSTATUS flag)
} DPNHCAPS, * PDPNHCAPS;





/****************************************************************************
 *
 * Address type flags (returned by GetRegisteredAddresses)
 *
 ****************************************************************************/

#define DPNHADDRESSTYPE_TCP				0x01	// the mappings are for TCP ports instead of UDP
#define DPNHADDRESSTYPE_FIXEDPORTS		0x02	// the mappings are for ports which are the same on the Internet gateway 
#define DPNHADDRESSTYPE_SHAREDPORTS		0x04	// the mappings are for shared UDP fixed ports
#define DPNHADDRESSTYPE_LOCALFIREWALL	0x08	// the addresses are opened on a local firewall
#define DPNHADDRESSTYPE_GATEWAY			0x10	// the addresses are registered with an Internet gateway
#define DPNHADDRESSTYPE_GATEWAYISLOCAL	0x20	// the Internet gateway is local (i.e. the public address is another network interface on the same machine)




/****************************************************************************
 *
 * DirectPlay NAT Helper DLL exported functions
 *
 ****************************************************************************/

typedef HRESULT (WINAPI * PFN_DIRECTPLAYNATHELPCREATE)(const GUID * pIID, void ** ppvInterface);





/****************************************************************************
 *
 * DirectPlay NAT Helper application interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlayNATHelp
DECLARE_INTERFACE_(IDirectPlayNATHelp, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)				(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
	STDMETHOD_(ULONG,Release)				(THIS) PURE;

	/*** IDirectPlayNATHelp methods ***/
	STDMETHOD(Initialize)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(Close)						(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(GetCaps)						(THIS_ DPNHCAPS * const dpnhcaps, const DWORD dwFlags) PURE;
	STDMETHOD(RegisterPorts)				(THIS_ const SOCKADDR * const aLocalAddresses, const DWORD dwAddressesSize, const DWORD dwNumAddresses, const DWORD dwLeaseTime, DPNHHANDLE * const phRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(GetRegisteredAddresses)		(THIS_ const DPNHHANDLE hRegisteredPorts, SOCKADDR * const paPublicAddresses, DWORD * const pdwPublicAddressesSize, DWORD * const pdwAddressTypeFlags, DWORD * const pdwLeaseTimeRemaining, const DWORD dwFlags) PURE;
	STDMETHOD(DeregisterPorts)				(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwFlags) PURE;
	STDMETHOD(QueryAddress)					(THIS_ const SOCKADDR * const pSourceAddress, const SOCKADDR * const pQueryAddress, SOCKADDR * const pResponseAddress, const int iAddressesSize, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertEvent)				(THIS_ const HANDLE hEvent, const DWORD dwFlags) PURE;
	STDMETHOD(SetAlertIOCompletionPort)		(THIS_ const HANDLE hIOCompletionPort, const DWORD dwCompletionKey, const DWORD dwNumConcurrentThreads, const DWORD dwFlags) PURE;
	STDMETHOD(ExtendRegisteredPortsLease)	(THIS_ const DPNHHANDLE hRegisteredPorts, const DWORD dwLeaseTime, const DWORD dwFlags) PURE;
};




/****************************************************************************
 *
 * DirectPlay NAT Helper application interface macros
 *
 ****************************************************************************/

#if (! defined(__cplusplus) || defined(CINTERFACE))

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->lpVtbl->QueryInterface(p,a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->lpVtbl->AddRef(p)
#define	IDirectPlayNATHelp_Release(p)								(p)->lpVtbl->Release(p)
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->lpVtbl->Initialize(p,a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->lpVtbl->Close(p,a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->lpVtbl->GetCaps(p,a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->lpVtbl->RegisterPorts(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->lpVtbl->GetRegisteredAddresses(p,a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->lpVtbl->DeregisterPorts(p,a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->lpVtbl->QueryAddress(p,a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->lpVtbl->SetAlertEvent(p,a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->lpVtbl->SetAlertIOCompletionPort(p,a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->lpVtbl->ExtendRegisteredPortsLease(p,a,b,c)

#else // C++

#define	IDirectPlayNATHelp_QueryInterface(p,a,b)					(p)->QueryInterface(a,b)
#define	IDirectPlayNATHelp_AddRef(p)								(p)->AddRef()
#define	IDirectPlayNATHelp_Release(p)								(p)->Release()
#define	IDirectPlayNATHelp_Initialize(p,a)							(p)->Initialize(a)
#define	IDirectPlayNATHelp_Close(p,a)								(p)->Close(a)
#define	IDirectPlayNATHelp_GetCaps(p,a,b)							(p)->GetCaps(a,b)
#define	IDirectPlayNATHelp_RegisterPorts(p,a,b,c,d,e,f)				(p)->RegisterPorts(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_GetRegisteredAddresses(p,a,b,c,d,e,f)	(p)->GetRegisteredAddresses(a,b,c,d,e,f)
#define	IDirectPlayNATHelp_DeregisterPorts(p,a,b)					(p)->DeregisterPorts(a,b)
#define	IDirectPlayNATHelp_QueryAddress(p,a,b,c,d,e)				(p)->QueryAddress(a,b,c,d,e)
#define	IDirectPlayNATHelp_SetAlertEvent(p,a,b)						(p)->SetAlertEvent(a,b)
#define	IDirectPlayNATHelp_SetAlertIOCompletionPort(p,a,b,c,d)		(p)->SetAlertIOCompletionPort(a,b,c,d)
#define	IDirectPlayNATHelp_ExtendRegisteredPortsLease(p,a,b,c)		(p)->ExtendRegisteredPortsLease(a,b,c)

#endif



/****************************************************************************
 *
 * DirectPlay NAT Helper return codes
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DPNH_FACILITY_CODE					0x015
#define _DPNH_HRESULT_BASE					0xF000

#define MAKE_DPNHSUCCESS(code)				MAKE_HRESULT(0, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))
#define MAKE_DPNHFAILURE(code)				MAKE_HRESULT(1, _DPNH_FACILITY_CODE, (code + _DPNH_HRESULT_BASE))



#define DPNH_OK								S_OK

#define DPNHSUCCESS_ADDRESSESCHANGED		MAKE_DPNHSUCCESS(0x10)

#define DPNHERR_ALREADYINITIALIZED			MAKE_DPNHFAILURE(0x10)
#define DPNHERR_BUFFERTOOSMALL				MAKE_DPNHFAILURE(0x20)
#define DPNHERR_GENERIC						E_FAIL
#define DPNHERR_INVALIDFLAGS				MAKE_DPNHFAILURE(0x30)
#define DPNHERR_INVALIDOBJECT				MAKE_DPNHFAILURE(0x40)
#define DPNHERR_INVALIDPARAM				E_INVALIDARG
#define DPNHERR_INVALIDPOINTER				E_POINTER
#define DPNHERR_NOMAPPING					MAKE_DPNHFAILURE(0x50)
#define DPNHERR_NOMAPPINGBUTPRIVATE			MAKE_DPNHFAILURE(0x60)
#define DPNHERR_NOTINITIALIZED				MAKE_DPNHFAILURE(0x70)
#define DPNHERR_OUTOFMEMORY					E_OUTOFMEMORY
#define DPNHERR_PORTALREADYREGISTERED		MAKE_DPNHFAILURE(0x80)
#define DPNHERR_PORTUNAVAILABLE				MAKE_DPNHFAILURE(0x90)
#define DPNHERR_REENTRANT					MAKE_DPNHFAILURE(0x95)
#define DPNHERR_SERVERNOTAVAILABLE			MAKE_DPNHFAILURE(0xA0)
//@@BEGIN_MSINTERNAL
#define DPNHERR_SERVERNOTRESPONDING			MAKE_DPNHFAILURE(0xB0)
//@@END_MSINTERNAL
#define DPNHERR_UPDATESERVERSTATUS			MAKE_DPNHFAILURE(0xC0)







#ifdef __cplusplus
}
#endif

#endif // __DPNATHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvacm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvacm.h
 *  Content:    Header file for DirectPlayVoice compression provider (ACM)
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 ***************************************************************************/

#ifndef __DPVACM_H
#define __DPVACM_H

// {C0170539-0032-46bf-9223-A2463F000562}
DEFINE_GUID(CLSID_DPVCPACM, 
0xc0170539, 0x32, 0x46bf, 0x92, 0x23, 0xa2, 0x46, 0x3f, 0x0, 0x5, 0x62);

// {2ED7F7E8-1F7E-4edc-8E84-45B23631EBFE}
DEFINE_GUID(CLSID_DPVCPACM_CONVERTER, 
0x2ed7f7e8, 0x1f7e, 0x4edc, 0x8e, 0x84, 0x45, 0xb2, 0x36, 0x31, 0xeb, 0xfe);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\acmclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.  
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE!
 * 06/27/2001	rodtoll	RC2: DPVOICE: DPVACM's DllMain calls into acm -- potential hang
 *						Move global initialization to first object creation
 ***************************************************************************/

#include "dpvacmpch.h"

DNCRITICAL_SECTION g_csObjectCountLock;
LONG g_lNumObjects = 0;
HINSTANCE g_hDllInst = NULL;

LONG g_lNumLocks = 0;

#ifdef DPLAY_LOADANDCHECKTRUE
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

extern HMODULE ghRedirect;
extern PFN_DLLGETCLASSOBJECT pfnGetClassObject;
extern PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow;
#endif

#define EXP __declspec(dllexport)

typedef struct GPCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   LONG					lRefCnt;
   CLSID					clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;


/*
 * GP_QueryInterface
 */
STDMETHODIMP GP_QueryInterface(
                LPCLASSFACTORY This,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
	HRESULT hr;
	
    pcf = (LPGPCLASSFACTORY)This;
    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
		InterlockedIncrement( &pcf->lRefCnt );
        *ppvObj = This;
		hr = S_OK;
    }
    else
    { 
		hr = E_NOINTERFACE;
    }

	
	return hr;
	
} /* GP_QueryInterface */


/*
 * GP_AddRef
 */
STDMETHODIMP_(ULONG) GP_AddRef( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY pcf;

    pcf = (LPGPCLASSFACTORY)This;

    return InterlockedIncrement( &pcf->lRefCnt );
} /* GP_AddRef */



/*
 * GP_Release
 */
STDMETHODIMP_(ULONG) GP_Release( LPCLASSFACTORY This )
{
    LPGPCLASSFACTORY	pcf;
    ULONG ulResult; 

    pcf = (LPGPCLASSFACTORY)This;

    if( (ulResult = (ULONG) InterlockedDecrement( &pcf->lRefCnt ) ) == 0 )
    {
	    DNFree( pcf );
		DecrementObjectCount();
    }
    
    return ulResult;

} /* GP_Release */




/*
 * GP_CreateInstance
 *
 * Creates an instance of a DNServiceProvider object
 */
STDMETHODIMP GP_CreateInstance(
                LPCLASSFACTORY This,
                LPUNKNOWN pUnkOuter,
                REFIID riid,
    			LPVOID *ppvObj
				)
{
    HRESULT					hr = S_OK;
    LPGPCLASSFACTORY		pcf;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	pcf = (LPGPCLASSFACTORY) This;
	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(This, pUnkOuter, pcf->clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GP_CreateInstance */



/*
 * GP_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GP_LockServer(
                LPCLASSFACTORY This,
                BOOL fLock
				)
{
    if( fLock )
    {
	    InterlockedIncrement( &g_lNumLocks );    	
    }
    else
    {
	    InterlockedDecrement( &g_lNumLocks );
    }

	return S_OK;

} /* GP_LockServer */

static IClassFactoryVtbl GPClassFactoryVtbl =
{
        GP_QueryInterface,
        GP_AddRef,
        GP_Release,
        GP_CreateInstance,
        GP_LockServer
};

/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		GUID guidCLSID;

		if( IsEqualCLSID( rclsid, DPVOICE_CLSID_DPVACM ) )
		{
			memcpy( &guidCLSID, &CLSID_DPVCPACM, sizeof(GUID) );
		}
		else
		{
			memcpy( &guidCLSID, rclsid, sizeof(GUID) );
		}

		return (*pfnGetClassObject)(&guidCLSID,riid,ppvObj);
	}
#endif    

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = (LPGPCLASSFACTORY)DNMalloc( sizeof( GPCLASSFACTORY ) );
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

	pcf->lpVtbl = &GPClassFactoryVtbl;
    pcf->lRefCnt = 0;
	pcf->clsid = rclsid;

    hr = GP_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
    if( FAILED( hr ) )
    {
        DNFree ( pcf );
        *ppvObj = NULL;
    }
    else
    {
    	IncrementObjectCount();    
    }
	
    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		return (*pfnDllCanUnLoadNow)();
	}
#endif    

//	if (0 == gnObjects)
	if ( (0 == g_lNumObjects) && (0 == g_lNumLocks) )
	{
		hr = S_OK;
	}
	
    return hr;

} /* DllCanUnloadNow */


#undef DPF_MODNAME
#define DPF_MODNAME "IncrementObjectCount"
LONG IncrementObjectCount()
{
	LONG lNewCount;
	
	DNEnterCriticalSection( &g_csObjectCountLock );

	g_lNumObjects++;
	lNewCount = g_lNumObjects;

	if( g_lNumObjects == 1 )
	{
		DPFX(DPFPREP,1,"Initializing Dll Global State" );
		CDPVACMI::InitCompressionList(g_hDllInst,DPVOICE_REGISTRY_BASE DPVOICE_REGISTRY_CP DPVOICE_REGISTRY_DPVACM );		
	}

	DNLeaveCriticalSection( &g_csObjectCountLock );

	return lNewCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecrementObjectCount"
LONG DecrementObjectCount()
{
	LONG lNewCount;
	
	DNEnterCriticalSection( &g_csObjectCountLock );

	g_lNumObjects--;
	lNewCount = g_lNumObjects;

	if( g_lNumObjects == 0 )
	{
		DPFX(DPFPREP,1,"Freeing Dll Global State" );
		CDPVCPI::DeInitCompressionList();
	}

	DNLeaveCriticalSection( &g_csObjectCountLock );

	return lNewCount;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dpnathlp\inc\dpnbuild.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnbuild.h
 *
 *  Content:	DirectPlay build specific defines header.
 *
 *  History:
 *   Date	  By		Reason
 *  ========  ========  =========
 *  11/08/01  VanceO	Created to reduce the build nightmare.
 *
 ******************************************************************************/


//=============================================================================
// Global defines for all build types
//=============================================================================

//
// Use our own private class factory implementation.
//
#define DPNBUILD_NOCLASSFACTORY



#ifdef WINCE

	//========================================================================
	// Windows CE specific defines
	//========================================================================
	#ifdef WINNT
	#error("WINCE and WINNT cannot both be defined!")
	#endif // WINNT
	#ifdef WIN95
	#error("WINCE and WIN95 cannot both be defined!")
	#endif // WIN95
	#ifdef _XBOX
	#error("WINCE and _XBOX cannot both be defined!")
	#endif // _XBOX

	//
	// Windows CE builds Unicode.
	//
	#ifndef UNICODE
	#define UNICODE
	#endif // ! UNICODE

	#ifndef _UNICODE
	#define _UNICODE
	#endif // ! _UNICODE

	//
	// Eliminate unavailable components and non-CE features
	//
	#define DPNBUILD_NOCOMEMULATION
        #define DPNBUILD_NOCOMREGISTER
	#define DPNBUILD_NOHNETFWAPI
	#define DPNBUILD_NOIMAGEHLP
	#define DPNBUILD_NOIPV6
	#define DPNBUILD_NOIPX
	#define DPNBUILD_NOLEGACYDP
	#define DPNBUILD_NOLOCALNAT
	#define DPNBUILD_NOMISSEDTIMERSHINT
	#define DPNBUILD_NOMULTICAST
	#define DPNBUILD_NOSERIALSP
	#define DPNBUILD_NOSPUI
	#define DPNBUILD_NOVOICE
	#define DPNBUILD_NOWINMM
	#define DPNBUILD_NOWINSOCK2
	#define DPNBUILD_ONLYONENATHELP
	#define DPNBUILD_ONLYONEPROCESSOR


	#ifdef DBG

		//===================================================================
		// Debug CE build specific defines
		//===================================================================


	#else // ! DBG

		//===================================================================
		// Retail CE build specific defines
		//===================================================================

		//
		// Don't include parameter validation or the Protocol test interface.
		//
		#define DPNBUILD_NOPARAMVAL
		#define DPNBUILD_NOPROTOCOLTESTITF

	#endif // ! DBG

#else // ! WINCE
	#ifdef _XBOX

		//===================================================================
		// Xbox specific defines
		//===================================================================
		#ifdef WINNT
		#error("_XBOX and WINNT cannot both be defined!")
		#endif // WINNT
		#ifdef WIN95
		#error("_XBOX and WIN95 cannot both be defined!")
		#endif // WIN95


		//
		// Eliminate unavailable components and non-Xbox features
		//
		#define DPNBUILD_FIXEDMEMORYMODEL
		#define DPNBUILD_LIBINTERFACE
		#define DPNBUILD_NOCOMEMULATION
		#define DPNBUILD_NOCOMREGISTER
		#define DPNBUILD_NOHNETFWAPI
		#define DPNBUILD_NOIMAGEHLP
		#define DPNBUILD_NOIPV6
		#define DPNBUILD_NOIPX
		#define DPNBUILD_NOLEGACYDP
		#define DPNBUILD_NOLOBBY
		#define DPNBUILD_NOLOCALNAT
		#define DPNBUILD_NOMULTICAST
		#define DPNBUILD_NONATHELP
		#define DPNBUILD_NOREGISTRY
		#define DPNBUILD_NOSERIALSP
		#define DPNBUILD_NOSPUI
		#define DPNBUILD_NOVOICE
		#define DPNBUILD_NOWINMM
		#define DPNBUILD_ONLYONEADAPTER
		#define DPNBUILD_ONLYONENATHELP
		#define DPNBUILD_ONLYONEPROCESSOR
		#define DPNBUILD_ONLYONESP
		#define DPNBUILD_ONLYONETHREAD
		#define DPNBUILD_ONLYWINSOCK2
                #define DPNBUILD_SECURETRANSPORT
		#define DPNBUILD_SINGLEPROCESS


		#ifdef DBG

			//==============================================================
			// Debug Xbox build specific defines
			//==============================================================


		#else // ! DBG

			//==============================================================
			// Retail Xbox build specific defines
			//==============================================================

			//
			// Don't include parameter validation or the Protocol test
			// interface.
			//
			#define DPNBUILD_NOPARAMVAL
			#define DPNBUILD_NOPROTOCOLTESTITF

		#endif // ! DBG

	#else // ! _XBOX

		//===================================================================
		// Desktop specific defines
		//===================================================================

		//
		// _WIN32_DCOM allows us to use CoInitializeEx.
		//
                #ifndef _WIN32_DCOM
		#define _WIN32_DCOM
                #endif

		//
		// Multicast support is not ready for prime-time yet.
		//
		#define DPNBUILD_NOMULTICAST

		#ifdef WINNT

			//==============================================================
			// Windows NT specific defines
			//==============================================================
			#ifdef WIN95
			#error("WINNT and WIN95 cannot both be defined!")
			#endif // WIN95

			//
			// Windows NT builds Unicode
			//
			#define UNICODE
			#define _UNICODE

			//
			// When building under Visual C++ 6.0, we need to make sure
			// certain "advanced" features are available.  There's probably a
			// better way to tell what environment is being used, but for
			// now, we'll use ! DPNBUILD_ENV_NT.
			//
			#ifndef DPNBUILD_ENV_NT
			#define _WIN32_WINNT 0x0500
			#endif // ! DPNBUILD_ENV_NT

			//
			// 64-bit Windows never supported legacy DPlay (other than via
			// WOW).
			//
			#ifdef _WIN64
			#define DPNBUILD_NOLEGACYDP
			#endif // _WIN64

			//
			// NT doesn't need to support Winsock 1.
			//
			#define DPNBUILD_ONLYWINSOCK2

			//
			// IPv6 support is not ready for prime-time yet. 
			//
			#define DPNBUILD_NOIPV6


			#ifdef DBG

				//===========================================================
				// Debug NT build specific defines
				//===========================================================


			#else // ! DBG

				//===========================================================
				// Retail NT build specific defines
				//===========================================================
				#define DPNBUILD_NOPROTOCOLTESTITF


			#endif // ! DBG

		#else // ! WINNT

			//===============================================================
			// Windows 9x specific defines
			//===============================================================
			#ifndef WIN95
			#error("One of WINCE, _XBOX, WINNT, or WIN95 must be defined!")
			#endif // ! WIN95


			//
			// Windows 9x is single processor only.
			//
			#define DPNBUILD_ONLYONEPROCESSOR

			//
			// Windows 9x will never support IPv6.
			//
			#define DPNBUILD_NOIPV6


			#ifdef DBG

				//===========================================================
				// Debug 9x build specific defines
				//===========================================================


			#else // ! DBG

				//===========================================================
				// Retail 9x build specific defines
				//===========================================================
				#define DPNBUILD_NOPROTOCOLTESTITF


			#endif // ! DBG

		#endif // ! WINNT

	#endif // ! _XBOX

#endif // ! WINCE



//=============================================================================
// Print the current settings
//=============================================================================

#pragma message("Defines in use:")

//
// _ARM_ - Compile for ARM processors
//
#ifdef _ARM_
#pragma message("     _ARM_")
#endif

//
// _AMD64_ - Compile for AMD64 processors
//
#ifdef _AMD64_
#pragma message("     _AMD64_")
#endif

//
// DX_FINAL_RELEASE - Controls whether or not the DX time bomb is present
//
#ifdef DX_FINAL_RELEASE
#pragma message("     DX_FINAL_RELEASE")
#endif

//
// _IA64_ - Compile for IA64 processors
//
#ifdef _IA64_
#pragma message("     _IA64_")
#endif

//
// UNICODE - Set to make the build Unicode.
//
#ifdef UNICODE
#pragma message("     UNICODE")
#endif

//
// _WIN64 - 64-bit windows
//
#ifdef _WIN64
#pragma message("     _WIN64")
#endif

//
// WINCE - Not _WIN64, _XBOX, WINNT, or WIN95
//
#ifdef WINCE
#pragma message("     WINCE")
#endif

//
// WINNT - Not WINCE, _XBOX, or WIN95
//
#ifdef WINNT
#pragma message("     WINNT")
#endif

//
// WIN95 - Not WINCE, _XBOX, or WINNT
//
#ifdef WIN95
#pragma message("     WIN95")
#endif

//
// WINCE_ON_DESKTOP - Used to make a desktop CE-like build
//
#ifdef WINCE_ON_DESKTOP
#pragma message("     WINCE_ON_DESKTOP")
#endif

//
// _X86_ - Compile for Intel x86 processors
//
#ifdef _X86_
#pragma message("     _X86_")
#endif

//
// _XBOX - Not _WIN64, WINCE, WINNT, or WIN95
//
#ifdef _XBOX
#pragma message("     _XBOX")
#endif

//
// XBOX_ON_DESKTOP - Used to make a desktop Xbox-like build
//
#ifdef XBOX_ON_DESKTOP
#pragma message("     XBOX_ON_DESKTOP")
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


//
// DPNBUILD_ADVANCEDICSADAPTERSELECTIONLOGIC - Have the SP try to be smart about the adapter to use for enumerating/connecting on Internet Connection Sharing machines
//
#ifdef DPNBUILD_ADVANCEDICSADAPTERSELECTIONLOGIC
#pragma message("     DPNBUILD_ADVANCEDICSADAPTERSELECTIONLOGIC")
#endif

//
// DPNBUILD_DONTCHECKFORMISSEDTIMERS - Don't have the unified thread pool check for missed short timers
//
#ifdef DPNBUILD_DONTCHECKFORMISSEDTIMERS
#pragma message("     DPNBUILD_DONTCHECKFORMISSEDTIMERS")
#endif

//
// DPNBUILD_DYNAMICTIMERSETTINGS - Store timer settings at run time so they can be dynamically changed
//
#ifdef DPNBUILD_DYNAMICTIMERSETTINGS
#pragma message("     DPNBUILD_DYNAMICTIMERSETTINGS")
#endif

//
// DPNBUILD_ENV_NT - Building under the NT build environment
//
#ifdef DPNBUILD_ENV_NT
#pragma message("     DPNBUILD_ENV_NT")
#endif

//
// DPNBUILD_FIXEDMEMORYMODEL - Set a cap on the maximum amount of memory that can be allocated
//
#ifdef DPNBUILD_FIXEDMEMORYMODEL
#pragma message("     DPNBUILD_FIXEDMEMORYMODEL")
#endif

//
// DPNBUILD_LIBINTERFACE - Use a lib interface instead of a COM style interface
//
#ifdef DPNBUILD_LIBINTERFACE
#pragma message("     DPNBUILD_LIBINTERFACE")
#endif

//
// DPNBUILD_NOCOMEMULATION - Set for platforms that don't need the COM emulation layer
//
#ifdef DPNBUILD_NOCOMEMULATION
#pragma message("     DPNBUILD_NOCOMEMULATION")
#endif

//
// DPNBUILD_NOCOMREGISTER - Don't implement DllRegisterServer and DllUnregisterServer
//
#ifdef DPNBUILD_NOCOMREGISTER
#pragma message("     DPNBUILD_NOCOMREGISTER")
#endif

//
// DPNBUILD_NOHNETFWAPI - Used in NAT Help when Home Networking firewall traversal API isn't available
//
#ifdef DPNBUILD_NOHNETFWAPI
#pragma message("     DPNBUILD_NOHNETFWAPI")
#endif

//
// DPNBUILD_NOHOSTMIGRATE - Removes the Peer Host Migration feature
//
#ifdef DPNBUILD_NOHOSTMIGRATE
#pragma message("     DPNBUILD_NOHOSTMIGRATE")
#endif

//
// DPNBUILD_NOIMAGEHLP - Set for platforms where Imagehlp.dll is not available
//
#ifdef DPNBUILD_NOIMAGEHLP
#pragma message("     DPNBUILD_NOIMAGEHLP")
#endif

//
// DPNBUILD_NOIPX - Remove the IPX service provider
//
#ifdef DPNBUILD_NOIPX
#pragma message("     DPNBUILD_NOIPX")
#endif

//
// DPNBUILD_NOIPV6 - Remove the IPv6 service provider
//
#ifdef DPNBUILD_NOIPV6
#pragma message("     DPNBUILD_NOIPV6")
#endif

//
// DPNBUILD_NOLEGACYDP - Remove IDirectPlay4 addressing support
//
#ifdef DPNBUILD_NOLEGACYDP
#pragma message("     DPNBUILD_NOLEGACYDP")
#endif

//
// DPNBUILD_NOLOBBY - Remove lobby support from core.
//
#ifdef DPNBUILD_NOLOBBY
#pragma message("     DPNBUILD_NOLOBBY")
#endif

//
// DPNBUILD_NOLOCALNAT - Remove support for a local Internet gateway
//
#ifdef DPNBUILD_NOLOCALNAT
#pragma message("     DPNBUILD_NOLOCALNAT")
#endif

//
// DPNBUILD_NOMISSEDTIMERSHINT - Don't have the unified thread pool try to hint about possible missed short timers
//
#ifdef DPNBUILD_NOMISSEDTIMERSHINT
#pragma message("     DPNBUILD_NOMISSEDTIMERSHINT")
#endif

//
// DPNBUILD_NOMULTICAST - Used to disable multicast capabilities
//
#ifdef DPNBUILD_NOMULTICAST
#pragma message("     DPNBUILD_NOMULTICAST")
#endif

//
// DPNBUILD_NONATHELP - Remove use of NatHelp from DPlay
//
#ifdef DPNBUILD_NONATHELP
#pragma message("     DPNBUILD_NONATHELP")
#endif

//
// DPNBUILD_NOPARAMVAL - Parameter validation - ON for CE & Xbox Retail, OFF for Debug
//
#ifdef DPNBUILD_NOPARAMVAL
#pragma message("     DPNBUILD_NOPARAMVAL")
#endif

//
// DPNBUILD_NOPROTOCOLTESTITF - Removes the Protocol testing interface.  ON in Retail, OFF in Debug
//
#ifdef DPNBUILD_NOPROTOCOLTESTITF
#pragma message("     DPNBUILD_NOPROTOCOLTESTITF")
#endif

//
// DPNBUILD_NOREGISTRY - Removes registry based override parameters from DPlay
//
#ifdef DPNBUILD_NOREGISTRY
#pragma message("     DPNBUILD_NOREGISTRY")
#endif

//
// DPNBUILD_NOSERIALSP - Remove the Serial and Modem service providers
//
#ifdef DPNBUILD_NOSERIALSP
#pragma message("     DPNBUILD_NOSERIALSP")
#endif

//
// DPNBUILD_NOSERVER - Removes the IDirectPlay8Server interface, allowing only Client and Peer-to-Peer
//
#ifdef DPNBUILD_NOSERVER
#pragma message("     DPNBUILD_NOSERVER")
#endif

//
// DPNBUILD_NOSPUI - No UI in the Service Providers
//
#ifdef DPNBUILD_NOSPUI
#pragma message("     DPNBUILD_NOSPUI")
#endif

//
// DPNBUILD_NOVOICE - Removes DirectPlay Voice support from DirectPlay
//
#ifdef DPNBUILD_NOVOICE
#pragma message("     DPNBUILD_NOVOICE")
#endif

//
// DPNBUILD_NOWAITABLETIMERSON9X - Don't use waitable timer objects in Windows 9x builds
//
#ifdef DPNBUILD_NOWAITABLETIMERSON9X
#pragma message("     DPNBUILD_NOWAITABLETIMERSON9X")
#endif

//
// DPNBUILD_NOWINMM - Set for platforms where winmm.dll is not available
//
#ifdef DPNBUILD_NOWINMM
#pragma message("     DPNBUILD_NOWINMM")
#endif

//
// DPNBUILD_NOWINSOCK2 - Force the IP Service Provider to only use Winsock 1 features
//
#ifdef DPNBUILD_NOWINSOCK2
#pragma message("     DPNBUILD_NOWINSOCK2")
#endif

//
// DPNBUILD_ONLYONEADAPTER - Uses simplified code that assumes only a single adapter/device exists per SP
//
#ifdef DPNBUILD_ONLYONEADAPTER
#pragma message("     DPNBUILD_ONLYONEADAPTER")
#endif

//
// DPNBUILD_ONLYONENATHELP - Uses simplified code that assumes only a single NAT Help provider exists
//
#ifdef DPNBUILD_ONLYONENATHELP
#pragma message("     DPNBUILD_ONLYONENATHELP")
#endif

//
// DPNBUILD_ONLYONEPROCESSOR - Uses simplified code that assumes that only one processor exists
//
#ifdef DPNBUILD_ONLYONEPROCESSOR
#pragma message("     DPNBUILD_ONLYONEPROCESSOR")
#endif

//
// DPNBUILD_ONLYONESP - Uses simplified code that assumes only a single service provider exists
//
#ifdef DPNBUILD_ONLYONESP
#pragma message("     DPNBUILD_ONLYONESP")
#endif

//
// DPNBUILD_ONLYONETHREAD - Uses simplified code that assumes only one thread will ever access DPlay
//
#ifdef DPNBUILD_ONLYONETHREAD
#pragma message("     DPNBUILD_ONLYONETHREAD")
#endif

//
// DPNBUILD_ONLYWINSOCK2 - Force the IP Service Provider to only use Winsock 2 features
//
#ifdef DPNBUILD_ONLYWINSOCK2
#pragma message("     DPNBUILD_ONLYWINSOCK2")
#endif

//
// DPNBUILD_PREALLOCATEDMEMORYMODEL - Pre-allocate a fixed working set of memory up front, don't allow additional allocations
//
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
#pragma message("     DPNBUILD_PREALLOCATEDMEMORYMODEL")
#endif

//
// DPNBUILD_SINGLEPROCESS - Integrates DPNSVR code into the main DLL and assumes only a single process will use DPlay at a time
//
#ifdef DPNBUILD_SINGLEPROCESS
#pragma message("     DPNBUILD_SINGLEPROCESS")
#endif

//
// DPNBUILD_USEASSUME - Uses the __assume compiler key word for DNASSERTs in retail builds
//
#ifdef DPNBUILD_USEASSUME
#pragma message("     DPNBUILD_USEASSUME")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\acmunk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       unk.cpp
 *  Content:	IUnknown implementation
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 10/27/99 rodtoll Created (Modified from dxvoice project)
 *  12/16/99	rodtoll		Bug #123250 - Insert proper names/descriptions for codecs
 *							Codec names now based on resource entries for format and
 *							names are constructed using ACM names + bitrate
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.  
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 *  04/21/2000  rodtoll   Bug #32889 - Does not run on Win2k on non-admin account
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE!
 *  08/28/2000	masonb	Voice Merge: Removed dvosal.h
 *  06/27/2001	rodtoll	RC2: DPVOICE: DPVACM's DllMain calls into acm -- potential hang
 *						Move global initialization to first object creation 
 *
 ***************************************************************************/

#include "dpvacmpch.h"


#define EXP __declspec(dllexport)

LPVOID dvcpvACMInterface[] =
{
    (LPVOID)CDPVCPI::QueryInterface,
    (LPVOID)CDPVCPI::AddRef,
    (LPVOID)CDPVCPI::Release,
	(LPVOID)CDPVCPI::EnumCompressionTypes,
	(LPVOID)CDPVCPI::IsCompressionSupported,
	(LPVOID)CDPVCPI::I_CreateCompressor,
	(LPVOID)CDPVCPI::I_CreateDeCompressor,
	(LPVOID)CDPVCPI::GetCompressionInfo
};    

LPVOID dvconvACMInterface[] = 
{
	(LPVOID)CDPVACMConv::I_QueryInterface,
	(LPVOID)CDPVACMConv::I_AddRef,
	(LPVOID)CDPVACMConv::I_Release,
	(LPVOID)CDPVACMConv::I_InitDeCompress,
	(LPVOID)CDPVACMConv::I_InitCompress,	
	(LPVOID)CDPVACMConv::I_IsValid,
	(LPVOID)CDPVACMConv::I_GetUnCompressedFrameSize,
	(LPVOID)CDPVACMConv::I_GetCompressedFrameSize,
	(LPVOID)CDPVACMConv::I_GetNumFramesPerBuffer,
	(LPVOID)CDPVACMConv::I_Convert
	
};

#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
// these two functions are required by the generic class factory file
extern "C" HRESULT DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj)
{
	HRESULT hr;

	if( ppvObj == NULL ||
	    !DNVALID_WRITEPTR( ppvObj, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for object" );
		return DVERR_INVALIDPOINTER;
	}

	if( pUnkOuter != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object does not support aggregation" );
		return CLASS_E_NOAGGREGATION;
	}

	if( IsEqualGUID(riid,IID_IDPVCompressionProvider) )
	{
		PDPVCPIOBJECT pObject;

		pObject = new DPVCPIOBJECT;

		if( pObject == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			return DVERR_OUTOFMEMORY;
		}

		pObject->pObject = new CDPVACMI;

		if( pObject->pObject == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			delete pObject;
			return DVERR_OUTOFMEMORY;
		}

		if (!pObject->pObject->InitClass())
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			delete pObject->pObject;
			delete pObject;
			return DVERR_OUTOFMEMORY;
		}

		pObject->lpvVtble = &dvcpvACMInterface;

		hr = CDPVACMI::QueryInterface( pObject, riid, ppvObj );
		if (FAILED(hr))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "QI failed" );
			delete pObject->pObject;
			delete pObject;
		}
	}
	else if( IsEqualGUID(riid,IID_IDPVConverter) )
	{
		PDPVACMCONVOBJECT pObject;

		pObject = new DPVACMCONVOBJECT;

		if( pObject == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			return DVERR_OUTOFMEMORY;
		}

		pObject->pObject = new CDPVACMConv;

		if( pObject->pObject == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			delete pObject;
			return DVERR_OUTOFMEMORY;
		}

		if (!pObject->pObject->InitClass())
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			delete pObject->pObject;
			delete pObject;
			return DVERR_OUTOFMEMORY;
		}

		pObject->lpvVtble = &dvconvACMInterface;

		hr = CDPVACMConv::I_QueryInterface( pObject, riid, ppvObj );
		if (FAILED(hr))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "QI failed" );
			delete pObject->pObject;
			delete pObject;
		}
	}
	else if( IsEqualGUID(riid,IID_IUnknown ) )
	{
		if( rclsid == DPVOICE_CLSID_DPVACM )
		{
			PDPVCPIOBJECT pObject;

			pObject = new DPVCPIOBJECT;

			if( pObject == NULL )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
				return DVERR_OUTOFMEMORY;
			}

			pObject->pObject = new CDPVACMI;

			if(pObject->pObject == NULL)
			{
				delete pObject;
				return DVERR_OUTOFMEMORY;
			}

			pObject->lpvVtble = &dvcpvACMInterface;
 			
			if (!pObject->pObject->InitClass())
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
				delete pObject->pObject;
				delete pObject;
				return DVERR_OUTOFMEMORY;
			}

			hr = CDPVACMI::QueryInterface( pObject, riid, ppvObj );
			if (FAILED(hr))
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "QI failed" );
				delete pObject->pObject;
				delete pObject;
			}
		}
		else
		{
			PDPVACMCONVOBJECT pObject;

			pObject = new DPVACMCONVOBJECT;

			if( pObject == NULL )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
				return DVERR_OUTOFMEMORY;
			}

			pObject->pObject = new CDPVACMConv;

			if(pObject->pObject == NULL)
			{
				delete pObject;
				return DVERR_OUTOFMEMORY;
			}

			pObject->lpvVtble = &dvconvACMInterface;

			if (!pObject->pObject->InitClass())
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
				delete pObject->pObject;
				delete pObject;
				return DVERR_OUTOFMEMORY;
			}

			hr = CDPVACMConv::I_QueryInterface( pObject, riid, ppvObj );
			if (FAILED(hr))
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "QI failed" );
				delete pObject->pObject;
				delete pObject;
			}
		}
	}
	else
	{
		return E_NOINTERFACE;
	}

	if (SUCCEEDED(hr))
	{
		IncrementObjectCount();
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"
extern "C" BOOL IsClassImplemented(REFCLSID rclsid)
{
	return (IsEqualCLSID(rclsid, DPVOICE_CLSID_DPVACM) || rclsid == DPVOICE_CLSID_DPVACM_CONVERTER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 *  7/19/99		rodtoll Modified for use in directxvoice
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__

#ifdef __cplusplus
extern "C" {
#endif

// you must implement this function to create an instance of your COM object
HRESULT	DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj);

// you must implement this function.  Given a class id, you must respond
//	whether or not your DLL implements it
BOOL	IsClassImplemented(REFCLSID rclsid);

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" LONG g_lNumObjects;
extern "C" LONG g_lNumLocks;
#else 
extern LONG g_lNumObjects;
extern LONG g_lNumLocks;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\acmdllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.cpp
 *  Content:	This file contains all of the DLL exports except for DllGetClass / DllCanUnload
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 07/05/00 	rodtoll Created
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 08/28/2000	masonb	Voice Merge: Removed OSAL_* and dvosal.h
 * 06/27/2001	rodtoll	RC2: DPVOICE: DPVACM's DllMain calls into acm -- potential hang
 *						Move global initialization to first object creation 
 *
 ***************************************************************************/

#include "dpvacmpch.h"


#ifdef DPLAY_LOADANDCHECKTRUE 
HRESULT InitializeRedirectFunctionTable()
HRESULT FreeRedirectFunctionTable()
#endif

LONG lInitCount = 0;

#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT RegisterDefaultSettings()
{
	CRegistry creg;



	if( !creg.Open( HKEY_LOCAL_MACHINE, DPVOICE_REGISTRY_BASE DPVOICE_REGISTRY_CP DPVOICE_REGISTRY_DPVACM, FALSE, TRUE ) )
	{
		DPFERR( "Could not create dpvacm config key" );
		return DVERR_GENERIC;
	}
	else
	{
		if( !creg.WriteGUID( L"", DPVOICE_CLSID_DPVACM ) )
		{
			DPFERR( "Could not write dpvacm GUID" );
			return DVERR_GENERIC;
		}

		return DV_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function unregisters the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT UnRegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPVOICE_REGISTRY_BASE DPVOICE_REGISTRY_CP, FALSE, FALSE ) )
	{
		DPFERR( "Cannot remove DPVACM key, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPVOICE_REGISTRY_DPVACM)[1] ) )
		{
			DPFERR( "Could not remove DPVACM sub-key" );
		}	
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlayVoiceACM.Converter.1", L"DirectPlayVoice ACM Converter Object", 
							  L"dpvacm.dll", DPVOICE_CLSID_DPVACM_CONVERTER, L"DirectPlayVoiceACM.Converter") )
	{
		DPFERR( "Could not register converter object" );
		fFailed = TRUE;
	}
	
	if( !CRegistry::Register( L"DirectPlayVoiceACM.Provider.1", L"DirectPlayVoice ACM Provider Object", 
							  L"dpvacm.dll", DPVOICE_CLSID_DPVACM , L"DirectPlayVoiceACM.Provider") )
	{
		DPFERR( "Could not register provider object" );
		fFailed = TRUE;
	}


	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(DPVOICE_CLSID_DPVACM_CONVERTER) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to unregister server object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(DPVOICE_CLSID_DPVACM) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to unregister compat object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Could not remove default settings hr=0x%x", hr );
		fFailed = TRUE;
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}


#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
BOOL WINAPI DllMain(
              HINSTANCE hDllInst,
              DWORD fdwReason,
              LPVOID lpvReserved)
{
	if( fdwReason == DLL_PROCESS_ATTACH )
	{
		if( !lInitCount )
		{
			g_hDllInst = hDllInst;			
			
			if (!DNOSIndirectionInit())
			{
				return FALSE;
			}

			if( !DNInitializeCriticalSection( &g_csObjectCountLock ) )
			{
				DNOSIndirectionDeinit();
				return FALSE;
			}
			
#ifdef DPLAY_LOADANDCHECKTRUE			
			InitializeRedirectFunctionTable();
#endif
			DPFX(DPFPREP,  DVF_INFOLEVEL, ">>>>>>>>>>>>>>>> DPF INIT CALLED <<<<<<<<<<<<<<<" );
		}

		InterlockedIncrement( &lInitCount );
	}
	else if( fdwReason == DLL_PROCESS_DETACH )
	{
		InterlockedDecrement( &lInitCount );

		if( lInitCount == 0 )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, ">>>>>>>>>>>>>>>> DPF UNINITED <<<<<<<<<<<<<<<" );
#ifdef DPLAY_LOADANDCHECKTRUE			
			FreeRedirectFunctionTable();
#endif
			DNDeleteCriticalSection(&g_csObjectCountLock);
			DNOSIndirectionDeinit();

			// Check to ensure we're not being unloaded with objects active
			DNASSERT( g_lNumObjects == 0 && g_lNumLocks == 0 );
		}
	}

	return TRUE;
}


////////////////////////////////////////////////////////////////////////
//
// SUPPORT FUNCTIONS FOR STANDALONE DLL
//

#ifdef DPLAY_LOADANDCHECKTRUE

#undef DPF_MODNAME
#define DPF_MODNAME "CheckForPrivateBit"
BOOL CheckForPrivateBit( DWORD dwBit )
{
    CRegistry creg;
    DWORD dwValue;

    if( !creg.Open( DPLAY_LOADTREE_REGTREE, DPLAY_LOADTRUE_REGPATH, TRUE, FALSE ) )
    {
        return FALSE;
    }

    if( !creg.ReadDWORD( DPLAY_LOADTRUE_REGKEY, dwValue ) )
    {
        return FALSE;
    }

    if( dwValue & dwBit )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

extern "C" {
HMODULE ghRedirect = NULL;
PFN_DLLGETCLASSOBJECT pfnGetClassObject = NULL;
PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow = NULL;
};

HRESULT InitializeRedirectFunctionTable()
{
    LONG lLastError;
    
    if( CheckForPrivateBit( DPLAY_LOADTRUE_BIT ) )
    {
        ghRedirect = LoadLibraryA( "dpvacm.dll" );

        if( ghRedirect == NULL )
        {
            lLastError = GetLastError();
            
            DPFX(DPFPREP,  0, "Could not load dplayx.dll error = 0x%x", lLastError );
			return DVERR_GENERIC;

        }

		pfnGetClassObject = (PFN_DLLGETCLASSOBJECT) GetProcAddress( ghRedirect, "DllGetClassObject" );
		pfnDllCanUnLoadNow = (PFN_DLLCANUNLOADNOW) GetProcAddress( ghRedirect, "DllCanUnloadNow" );
    }

    return S_OK;    
}

HRESULT FreeRedirectFunctionTable()
{
    if( ghRedirect != NULL )
        FreeLibrary( ghRedirect );

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvacmpch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvacmpch.h
 *  Content:    DirectPlayVoice ACM master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DPVACMPCH_H__
#define __DPVACMPCH_H__

// 
// Public includes
//
#include <windows.h>
#include <wchar.h>

// 
// DirectPlay public includes
//
#include "dvoice.h"
#include "dpvcp.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "comutil.h"
#include "creg.h"
#include "strutils.h"

// 
// Voice includes
//
#include "dpvacm.h"
#include "dpvcpi.h"
#include "dpvacmi.h"
#include "dpvaconv.h"
#include "dpvautil.h"
#include "resource.h"
#include "wavformat.h"
#include "wiutils.h"
#include "createin.h"

#include "..\..\..\bldcfg\dpvcfg.h"

#endif // __DPVACMPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvacmi.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvacmi.cpp
 *  Content:    Definition of object which implements ACM compression provider interface
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  12/16/99	rodtoll		Bug #123250 - Insert proper names/descriptions for codecs
 *							Codec names now based on resource entries for format and
 *							names are constructed using ACM names + bitrate
 *  01/20/00	rodtoll		Removed dplay reference (DPERR_OUTOFMEMORY)
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.  
 *  03/16/2000  rodtoll   Fixed problem w/GameVoice build -- always loaded dvoice provider
 *  04/21/2000  rodtoll   Bug #32889 - Does not run on Win2k on non-admin account
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  08/28/2000	masonb	Voice Merge: Removed OSAL_* and dvosal.h added STR_* and strutils.h
 *  08/31/2000	rodtoll	Whistler Bug #171837, 171838 - Prefix Bug 
 *  04/22/2001	rodtoll	MANBUG #50058 DPVOICE: VoicePosition: No sound for couple of seconds when 
 *                      positioning bars moved.  Increased # of frames / buffer value for codecs.
 *
 ***************************************************************************/

#include "dpvacmpch.h"


#define DPVACM_NUM_DEFAULT_TYPES		4

BYTE abTrueSpeechData[] = {
	0x01, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 
};

BYTE abGSMData[] = {
	0x40, 0x01
};

BYTE abADPCMData[] = {
	0xF4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 
	0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
	0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
	0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
};

VOID *s_pvExtras[DPVACM_NUM_DEFAULT_TYPES] = {
	&abTrueSpeechData, 
	&abGSMData,
	&abADPCMData,
	NULL
};

WAVEFORMATEX s_wfxFormats[DPVACM_NUM_DEFAULT_TYPES] = 
{
	// Tag,		Chan,	SamS,	Avg,	Align,	Bits,	size 
	{ 34,		0x01,	8000,	1067,	32,		1,		sizeof( abTrueSpeechData ) }, 
	{ 49,		0x01,	8000,	1625,	65,		0,		sizeof( abGSMData ) },
	{ 2,		0x01,	8000,	4096,	256,	4,		sizeof( abADPCMData ) },
	{ 1,		0x01,	8000,	8000,	1,		8,		0 }
};

DVFULLCOMPRESSIONINFO s_dvInfoDefault[DPVACM_NUM_DEFAULT_TYPES] = 
{
	{ sizeof( DVFULLCOMPRESSIONINFO ), DPVCTGUID_TRUESPEECH.Data1, DPVCTGUID_TRUESPEECH.Data2, DPVCTGUID_TRUESPEECH.Data3, 
	  DPVCTGUID_TRUESPEECH.Data4[0], DPVCTGUID_TRUESPEECH.Data4[1], DPVCTGUID_TRUESPEECH.Data4[2], DPVCTGUID_TRUESPEECH.Data4[3], 
	  DPVCTGUID_TRUESPEECH.Data4[4], DPVCTGUID_TRUESPEECH.Data4[5], DPVCTGUID_TRUESPEECH.Data4[6], DPVCTGUID_TRUESPEECH.Data4[7], 
	  NULL, NULL, 0, 8536, NULL, 12, 1, 90, 96, 720, 993, 1986, 3972, 64, 32, 10, 1, 0, 0 },
	{ sizeof( DVFULLCOMPRESSIONINFO ), DPVCTGUID_GSM.Data1, DPVCTGUID_GSM.Data2, DPVCTGUID_GSM.Data3, 
	  DPVCTGUID_GSM.Data4[0], DPVCTGUID_GSM.Data4[1], DPVCTGUID_GSM.Data4[2], DPVCTGUID_GSM.Data4[3], 
	  DPVCTGUID_GSM.Data4[4], DPVCTGUID_GSM.Data4[5], DPVCTGUID_GSM.Data4[6], DPVCTGUID_GSM.Data4[7], 
	  NULL, NULL, 0, 13000, NULL, 13, 1, 80, 130, 640, 882, 1764, 3528, 64, 32, 10, 1, 0, 0 },
	{ sizeof( DVFULLCOMPRESSIONINFO ), DPVCTGUID_ADPCM.Data1, DPVCTGUID_ADPCM.Data2, DPVCTGUID_ADPCM.Data3, 
	  DPVCTGUID_ADPCM.Data4[0], DPVCTGUID_ADPCM.Data4[1], DPVCTGUID_ADPCM.Data4[2], DPVCTGUID_ADPCM.Data4[3], 
	  DPVCTGUID_ADPCM.Data4[4], DPVCTGUID_ADPCM.Data4[5], DPVCTGUID_ADPCM.Data4[6], DPVCTGUID_ADPCM.Data4[7], 
	  NULL, NULL, 0, 32768, NULL, 15, 1, 63, 256, 500, 690, 1380, 2760, 64, 32, 10, 1, 0, 0 },
	{ sizeof( DVFULLCOMPRESSIONINFO ), DPVCTGUID_NONE.Data1, DPVCTGUID_NONE.Data2, DPVCTGUID_NONE.Data3, 
	  DPVCTGUID_NONE.Data4[0], DPVCTGUID_NONE.Data4[1], DPVCTGUID_NONE.Data4[2], DPVCTGUID_NONE.Data4[3], 
	  DPVCTGUID_NONE.Data4[4], DPVCTGUID_NONE.Data4[5], DPVCTGUID_NONE.Data4[6], DPVCTGUID_NONE.Data4[7], 
	  NULL, NULL, 0, 64000, NULL, 20, 1, 50, 394, 394, 543, 1086, 2172, 64, 32, 10, 1, 0, 0 }
};

const wchar_t * const s_wszInfoNames[DPVACM_NUM_DEFAULT_TYPES] =
{
	L"DSP Group Truespeech(TM) (8.000 kHz, 1 Bit, Mono)",
	L"GSM 6.10 (8.000 kHz, Mono)",
	L"Microsoft ADPCM (8.000 kHz, 4 Bit, Mono)",
	L"PCM (8.000 kHz, 8 Bit, Mono" 
};

WAVEFORMATEX CDPVACMI::s_wfxInnerFormat= { 
	WAVE_FORMAT_PCM, 1,8000,16000,2,16,0 
};

#define MAX_RESOURCE_STRING_LENGTH		200

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::LoadDefaultTypes"
HRESULT CDPVACMI::LoadDefaultTypes( HINSTANCE hInst ) 
{
	HRESULT hr = DV_OK;
	CompressionNode *pNewNode;
	CWaveFormat wfxFormat;

	for( DWORD dwIndex = 0; dwIndex < DPVACM_NUM_DEFAULT_TYPES; dwIndex++ )
	{
		pNewNode = new CompressionNode;

		if( pNewNode == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}
		
		pNewNode->pdvfci = new DVFULLCOMPRESSIONINFO;

		if( pNewNode->pdvfci  == NULL )
		{
			delete pNewNode;  
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}

		// Copy main portion
		memcpy( pNewNode->pdvfci, &s_dvInfoDefault[dwIndex], sizeof( DVFULLCOMPRESSIONINFO ) );

		// Copy the waveformat 
		hr = wfxFormat.InitializeCPY( &s_wfxFormats[dwIndex], s_pvExtras[dwIndex] );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Unable to initialize built-in type %d", dwIndex );
			CN_FreeItem( pNewNode );
			continue;
		}

		pNewNode->pdvfci->lpwfxFormat = wfxFormat.Disconnect();

		DNASSERT( pNewNode->pdvfci->lpwfxFormat );

		hr = GetCompressionNameAndDescription( hInst, pNewNode->pdvfci );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error building built-in type: %d  hr=0x%x", dwIndex, hr );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Type will not be available" );
			
			CN_FreeItem( pNewNode );

			continue;
		}
	
		AddEntry( pNewNode );
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::AddEntry"
void CDPVACMI::AddEntry( CompressionNode *pNewNode )
{
	CompressionNode *pcNode, *pcPrevNode;

	pcPrevNode = NULL;
	pcNode = s_pcnList;

	// Run the list and ensure an entry doesn't already exist
	// If one does, over-ride it with this new one.  
	while( pcNode )
	{
		// A node already exists for this type
		if( pcNode->pdvfci->guidType == pNewNode->pdvfci->guidType )
		{
			// We need to drop this count because we increment it below.  
			s_dwNumCompressionTypes--;
			
			if( pcPrevNode == NULL )
			{
				s_pcnList = pcNode->pcnNext;
			}
			else
			{
				pcPrevNode->pcnNext = pcNode->pcnNext;
			}
			
			CN_FreeItem(pcNode);
			break;
		}

		pcPrevNode = pcNode;
		pcNode = pcNode->pcnNext;
	}

	pNewNode->pcnNext = s_pcnList;
	s_pcnList = pNewNode;
	s_dwNumCompressionTypes++;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::InitCompressionList"
HRESULT CDPVACMI::InitCompressionList( HINSTANCE hInst, const wchar_t *szwRegistryBase )
{
	CRegistry mainKey;
	LPWSTR keyName;
	DWORD dwIndex;
	DWORD dwSize;

	CompressionNode *pCompressionNode;
	HRESULT hr;

	hr = IsPCMConverterAvailable();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "PCM Converter is disabled hr=0x%x, no ACM compression types are available", hr );
		return hr;
	}

	if( !mainKey.Open( HKEY_LOCAL_MACHINE, szwRegistryBase, TRUE, FALSE ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading compression types from the registry.  Path doesn't exist" );
		return E_FAIL;
	}

	hr = LoadDefaultTypes( hInst );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load built-in types from registry." );
		return E_FAIL;
	}

	dwIndex = 0;
	keyName = NULL;
	dwSize = 0;
	LPSTR lpstrKeyName;

	// Enumerate the subkeys at this point in the tree
	while( 1 )
	{
		if( !mainKey.EnumKeys( keyName, &dwSize, dwIndex ) )
		{
			if( dwSize == 0 )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error enuming compression keys" );
				break;
			}

			if( keyName != NULL )
			{
				delete [] keyName;
			}

			keyName = new wchar_t[dwSize];
		}

		if( !mainKey.EnumKeys( keyName, &dwSize, dwIndex ) )
		{
			delete [] keyName;
			break;
		}

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
			break;
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Reading compression key: %s", lpstrKeyName );

		pCompressionNode = new CompressionNode;

		if( pCompressionNode == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}
		
		pCompressionNode->pdvfci = new DVFULLCOMPRESSIONINFO;

		if( pCompressionNode->pdvfci  == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory allocation failure" );
			return DVERR_OUTOFMEMORY;
		}

		// Attempt to read the record
		hr = CREG_ReadCompressionInfo( mainKey, keyName, pCompressionNode->pdvfci );

		if( FAILED( hr ) )
		{
			CN_FreeItem( pCompressionNode );
			
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading key: %s  hr=0x%x", lpstrKeyName, hr );
		}
		else
		{
			hr = GetCompressionNameAndDescription( hInst, pCompressionNode->pdvfci );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error building type: %s  hr=0x%x", lpstrKeyName, hr );

				CN_FreeItem( pCompressionNode );
			}
			else
			{
				// Insert the element into the list of supported types
				pCompressionNode->pdvfci->dwSize = sizeof( DVCOMPRESSIONINFO );

				AddEntry( pCompressionNode );
			}
		}

		delete [] lpstrKeyName;

		dwIndex++;
	}

	mainKey.Close();

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::CreateCompressor"
HRESULT CDPVACMI::CreateCompressor( DPVCPIOBJECT *This, LPWAVEFORMATEX lpwfxSrcFormat, GUID guidTargetCT, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags )
{
	HRESULT hr;

	hr = COM_CoCreateInstance( DPVOICE_CLSID_DPVACM_CONVERTER, NULL, CLSCTX_INPROC_SERVER, IID_IDPVConverter, (void **) ppCompressor );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create converter, hr = 0x%x", hr );
		return hr;
	}

	hr = (*ppCompressor)->lpVtbl->InitCompress( (*ppCompressor), lpwfxSrcFormat, guidTargetCT );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to init compressor, hr = 0x%x", hr );
		(*ppCompressor)->lpVtbl->Release((*ppCompressor));
		*ppCompressor = NULL;
		return hr;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::CreateDeCompressor"
HRESULT CDPVACMI::CreateDeCompressor( DPVCPIOBJECT *This, GUID guidTargetCT, LPWAVEFORMATEX lpwfxSrcFormat, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags )
{
	HRESULT hr;

	hr = COM_CoCreateInstance( DPVOICE_CLSID_DPVACM_CONVERTER, NULL, CLSCTX_INPROC_SERVER, IID_IDPVConverter, (void **) ppCompressor );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create decompressor, hr = 0x%x", hr );
		return hr;
	}

	hr = (*ppCompressor)->lpVtbl->InitDeCompress( (*ppCompressor), guidTargetCT, lpwfxSrcFormat );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to init decompressor, hr = 0x%x", hr );
		(*ppCompressor)->lpVtbl->Release((*ppCompressor));
		*ppCompressor = NULL;
		return hr;
	}

	return DV_OK;
}

// # of chars of extra tacked on by description
// This is equivalent to "XXXXXXX.X kbit/s"
#define DVACMCP_EXTRACHARS		80

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::GetDriverNameW"
HRESULT CDPVACMI::GetDriverNameW( HACMDRIVERID hadid, wchar_t *szwDriverName )
{
	ACMDRIVERDETAILSW acDriverDetails;	
	MMRESULT mmr;

	memset( &acDriverDetails, 0x00, sizeof( ACMDRIVERDETAILS ) );
	acDriverDetails.cbStruct = sizeof( ACMDRIVERDETAILS );	

	mmr = acmDriverDetailsW( hadid, &acDriverDetails, 0 );

	if( mmr != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get driver details mmr=0x%x", mmr );
		return DVERR_COMPRESSIONNOTSUPPORTED;
	}

	if( acDriverDetails.fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Driver is disabled!" );
		return  DVERR_COMPRESSIONNOTSUPPORTED;
	}	

	wcscpy( szwDriverName, acDriverDetails.szShortName );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::GetDriverNameA"
HRESULT CDPVACMI::GetDriverNameA( HACMDRIVERID hadid, wchar_t *szwDriverName )
{
	ACMDRIVERDETAILSA acDriverDetails;	
	MMRESULT mmr;

	memset( &acDriverDetails, 0x00, sizeof( ACMDRIVERDETAILS ) );
	acDriverDetails.cbStruct = sizeof( ACMDRIVERDETAILS );	

	mmr = acmDriverDetailsA( hadid, &acDriverDetails, 0 );

	if( mmr != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get driver details mmr=0x%x", mmr );
		return DVERR_COMPRESSIONNOTSUPPORTED;
	}

	if( acDriverDetails.fdwSupport & ACMDRIVERDETAILS_SUPPORTF_DISABLED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Driver is disabled!" );
		return  DVERR_COMPRESSIONNOTSUPPORTED;
	}	

	if( FAILED(STR_jkAnsiToWide( szwDriverName, acDriverDetails.szShortName, ACMDRIVERDETAILS_SHORTNAME_CHARS+1 )) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to convert driver name to UNICODE" );
		return DVERR_COMPRESSIONNOTSUPPORTED;
	}	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::LoadAndAllocString"
HRESULT CDPVACMI::LoadAndAllocString( HINSTANCE hInstance, UINT uiResourceID, wchar_t **lpswzString )
{
	int length;
	HRESULT hr;
	
	if( IsUnicodePlatform )
	{
		wchar_t wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		
		length = LoadStringW( hInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

		if( length == 0 )
		{
			hr = GetLastError();		
			
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
			*lpswzString = NULL;

			return hr;
		}
		else
		{
			*lpswzString = new wchar_t[length+1];

			if( *lpswzString == NULL )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Alloc failure" );
				return DVERR_OUTOFMEMORY;
			}

			wcscpy( *lpswzString, wszTmpBuffer );

			return DV_OK;
		}
	}
	else
	{
		char szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
		
		length = LoadStringA( hInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

		if( length == 0 )
		{
			hr = GetLastError();		
			
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
			*lpswzString = NULL;

			return hr;
		}
		else
		{
			*lpswzString = new wchar_t[length+1];

			if( *lpswzString == NULL )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Alloc failure" );
				return DVERR_OUTOFMEMORY;
			}

			if( FAILED(STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 )) )
			{
				hr = GetLastError();
				
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
				return hr;
			}

			return DV_OK;
		}
		
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMI::GetCompressionNameAndDescription"
HRESULT CDPVACMI::GetCompressionNameAndDescription( HINSTANCE hInst, DVFULLCOMPRESSIONINFO *pdvCompressionInfo )
{
	MMRESULT mmr;
	HACMSTREAM has = NULL;
	HACMDRIVERID acDriverID = NULL;
    wchar_t szwDriverName[ACMDRIVERDETAILS_SHORTNAME_CHARS+DVACMCP_EXTRACHARS];
	wchar_t szExtraCharsBuild[DVACMCP_EXTRACHARS+1];
	wchar_t *szwFormat;
	HRESULT hr;
	
	// Description is always NULL
	pdvCompressionInfo->lpszDescription = NULL;

	// Attempt to open a conversion using the parameters specified.  
	mmr = acmStreamOpen( &has, NULL, &s_wfxInnerFormat, pdvCompressionInfo->lpwfxFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );

	if( mmr != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed testing compression type.  mmr=0x%x", mmr );
		hr =  DVERR_COMPRESSIONNOTSUPPORTED;
		goto GETINFOERROR;
	}

	mmr = acmDriverID( (HACMOBJ) has, &acDriverID, 0 );

	if( mmr != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to determine ACM driver for type mmr=0x%x", mmr );
		hr = DVERR_COMPRESSIONNOTSUPPORTED;
		goto GETINFOERROR;
	}

	if( IsUnicodePlatform )
	{
		hr = GetDriverNameW( acDriverID, szwDriverName );
	}
	else
	{
		hr = GetDriverNameA( acDriverID, szwDriverName );
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed getting driver name hr=0x%x", hr );
		goto GETINFOERROR;
	}

	
	
	if( pdvCompressionInfo->dwMaxBitsPerSecond % 1000 == 0 )
	{
		if( FAILED( LoadAndAllocString( hInst, IDS_CODECNAME_KBITSPERSEC, &szwFormat ) ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load format for name" );
			goto GETINFOERROR;
		}
		
		swprintf( szExtraCharsBuild, szwFormat, pdvCompressionInfo->dwMaxBitsPerSecond / 1000 );
		delete [] szwFormat;
	}
	else
	{
		DWORD dwMajor, dwFraction;

		dwMajor = pdvCompressionInfo->dwMaxBitsPerSecond / 1000;
		dwFraction = (pdvCompressionInfo->dwMaxBitsPerSecond % 1000) / 100;

		if( (pdvCompressionInfo->dwMaxBitsPerSecond % 1000) > 500 )
		{
			dwFraction++;
		}

		if( dwFraction > 10 )
		{
			dwMajor++;
			dwFraction -= 10;
		}

		if( FAILED( LoadAndAllocString( hInst, IDS_CODECNAME_KBITSPERSEC_FULL, &szwFormat ) ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load format for name (full)" );
			goto GETINFOERROR;
		}

		swprintf( szExtraCharsBuild, szwFormat, dwMajor, dwFraction );
		delete [] szwFormat;
	}

	if( FAILED( LoadAndAllocString( hInst, IDS_CODECNAME_FORMAT, &szwFormat ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load format" );
		goto GETINFOERROR;
	}

	pdvCompressionInfo->lpszName = new wchar_t[wcslen(szwDriverName)+wcslen(szwFormat)+wcslen(szExtraCharsBuild)+1];

	if( pdvCompressionInfo->lpszName == NULL )
	{
		delete [] szwFormat;
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate space for compression name" );
		hr = DVERR_OUTOFMEMORY;
		goto GETINFOERROR;
	}

	swprintf( pdvCompressionInfo->lpszName, szwFormat, szwDriverName, szExtraCharsBuild );

	acmStreamClose( has, 0 );

	if( szwFormat != NULL )
		delete [] szwFormat;

	return DV_OK;

GETINFOERROR:

	if( has != NULL )
	{
		acmStreamClose( has, 0  );
	}

	return hr;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvacmi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvacmi.h
 *  Content:    Definition of object which implements ACM compression provider interface
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  12/16/99	rodtoll		Bug #123250 - Insert proper names/descriptions for codecs
 *							Codec names now based on resource entries for format and
 *							names are constructed using ACM names + bitrate 
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 06/27/2001	rodtoll	RC2: DPVOICE: DPVACM's DllMain calls into acm -- potential hang
 *						Move global initialization to first object creation 
 ***************************************************************************/

#ifndef __DPVACMI_H
#define __DPVACMI_H

extern "C" DNCRITICAL_SECTION g_csObjectCountLock;
extern "C" HINSTANCE g_hDllInst;
LONG IncrementObjectCount();
LONG DecrementObjectCount();

class CDPVACMI: public CDPVCPI
{
public:
	static HRESULT InitCompressionList( HINSTANCE hInst, const wchar_t *szwRegistryBase );
	HRESULT CreateCompressor( DPVCPIOBJECT *This, LPWAVEFORMATEX lpwfxSrcFormat, GUID guidTargetCT, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags );
	HRESULT CreateDeCompressor( DPVCPIOBJECT *This, GUID guidTargetCT, LPWAVEFORMATEX lpwfxSrcFormat, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags );
	static WAVEFORMATEX s_wfxInnerFormat;	// Inner format
	static HRESULT GetCompressionNameAndDescription( HINSTANCE hInst, DVFULLCOMPRESSIONINFO *pdvCompressionInfo );
	static HRESULT GetDriverNameW( HACMDRIVERID hadid, wchar_t *szwDriverName );
	static HRESULT GetDriverNameA( HACMDRIVERID hadid, wchar_t *szwDriverName );
	static HRESULT LoadAndAllocString( HINSTANCE hInstance, UINT uiResourceID, wchar_t **lpswzString );
	static void AddEntry( CompressionNode *pNewNode );
	static HRESULT LoadDefaultTypes( HINSTANCE hInst );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvaconv.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvaconv.cpp
 *  Content:    Header file for DirectPlayVoice compression provider (ACM)
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  02/03/2000	rodtoll		Bug #130397 - Prefix detected memory leak
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 *  04/02/2001	simonpow	Fixes for PREfast bugs #354859 (unitialised variables)
 * 06/27/2001	rodtoll	RC2: DPVOICE: DPVACM's DllMain calls into acm -- potential hang
 *						Move global initialization to first object creation 
 ***************************************************************************/

#include "dpvacmpch.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::CDPVACMConv"
CDPVACMConv::CDPVACMConv(
	): m_fDirectConvert(FALSE), m_fValid(FALSE),
	   m_pbInnerBuffer(NULL),m_dwInnerBufferSize(0),
	   m_lRefCount(0), m_hacmSource(NULL),
	   m_hacmTarget(NULL), m_pdvfci(NULL),
	   m_fCritSecInited(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::InitClass"
BOOL CDPVACMConv::InitClass( )
{
	if (DNInitializeCriticalSection( &m_csLock ))
	{
		m_fCritSecInited = TRUE;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::~CDPVACMConv"
CDPVACMConv::~CDPVACMConv()
{
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_csLock );
	}

	if( m_pdvfci != NULL )
	{
		LPBYTE pTmp = (LPBYTE) m_pdvfci;
		delete [] pTmp;
	}

	if( m_pbInnerBuffer != NULL )
	{
		delete [] m_pbInnerBuffer;
	}

	if( m_hacmSource != NULL )
	{
		acmStreamClose( m_hacmSource, 0 );
	}

	if( m_hacmTarget != NULL )
	{
		acmStreamClose( m_hacmTarget, 0 );
	}

}
	
#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_QueryInterface"
HRESULT CDPVACMConv::I_QueryInterface( DPVACMCONVOBJECT *This, REFIID riid, PVOID *ppvObj )
{
    HRESULT hr = S_OK;

	if( ppvObj == NULL ||
	    !DNVALID_WRITEPTR( ppvObj, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for object" );
		return DVERR_INVALIDPOINTER;
	}	
    
     *ppvObj=NULL;

    DNEnterCriticalSection( &This->pObject->m_csLock );

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IDPVConverter ) )
    {
		*ppvObj = This;
		This->pObject->I_AddRef( This );
    }
	else 
	{
	    hr =  E_NOINTERFACE;		
	}

	DNLeaveCriticalSection( &This->pObject->m_csLock );    	
        
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_AddRef"
HRESULT CDPVACMConv::I_AddRef( DPVACMCONVOBJECT *This )
{
	LONG rc;
	
	DNEnterCriticalSection( &This->pObject->m_csLock );

	rc = ++This->pObject->m_lRefCount;
	
	DNLeaveCriticalSection( &This->pObject->m_csLock );

	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_Release"
HRESULT CDPVACMConv::I_Release( DPVACMCONVOBJECT *This )
{
	LONG rc;

	DNEnterCriticalSection( &This->pObject->m_csLock );

	rc = --This->pObject->m_lRefCount;

	if( rc == 0 )
	{
	 	DPFX(DPFPREP,  DVF_INFOLEVEL, "Destroying object" );
		DNLeaveCriticalSection( &This->pObject->m_csLock );	

		delete This->pObject;
		delete This;

		DecrementObjectCount();		
	}
	else
	{
		DNLeaveCriticalSection( &This->pObject->m_csLock );	
	}

	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_InitDeCompress"
HRESULT CDPVACMConv::I_InitDeCompress( DPVACMCONVOBJECT *This, GUID guidSourceCT, LPWAVEFORMATEX lpwfxTargetFormat )
{
	return This->pObject->InitDeCompress( guidSourceCT, lpwfxTargetFormat );
}				 

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::InitDeCompress"
HRESULT CDPVACMConv::InitDeCompress( GUID guidSourceCT, LPWAVEFORMATEX lpwfxTargetFormat )
{
	HRESULT hr;

	DNEnterCriticalSection( &m_csLock );	

	if( m_fValid )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object already initialized" );
		DNLeaveCriticalSection( &m_csLock );			
		return DVERR_INITIALIZED;
	}

	hr = GetCompressionInfo( guidSourceCT );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "GetCTInfo Failed hr=0x%x", hr );
		DNLeaveCriticalSection( &m_csLock );			
		return hr;
	}

	hr = Initialize( m_pdvfci->lpwfxFormat, lpwfxTargetFormat, lpwfxTargetFormat );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to init ct, hr = 0x%x", hr );
		delete [] m_pdvfci;
		m_pdvfci = NULL;
		DNLeaveCriticalSection( &m_csLock );			
		return hr;
	}

	DNLeaveCriticalSection( &m_csLock );		
	
	return DV_OK;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::GetCompressionInfo"
HRESULT CDPVACMConv::GetCompressionInfo( GUID guidCT )
{
	DWORD dwSize = 0;
	HRESULT hr;
	LPBYTE pBuffer = NULL;

	hr = CDPVCPI::GetCompressionInfo( NULL, guidCT, pBuffer, &dwSize );

	if( hr != DVERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error retrieving ct info, hr =0x%x", hr );
		return hr;
	}

	pBuffer = new BYTE[dwSize];

	if( pBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
		return DVERR_OUTOFMEMORY;
	}

	hr = CDPVCPI::GetCompressionInfo( NULL, guidCT, pBuffer, &dwSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error retrieving ct info after buff, hr =0x%x", hr );
		delete [] pBuffer;
		return hr;
	}

	m_pdvfci = (LPDVFULLCOMPRESSIONINFO) pBuffer;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_InitCompress"
HRESULT CDPVACMConv::I_InitCompress( DPVACMCONVOBJECT *This, LPWAVEFORMATEX lpwfxSourceFormat, GUID guidTargetCT )
{
	return This->pObject->InitCompress( lpwfxSourceFormat, guidTargetCT );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::InitCompress"
HRESULT CDPVACMConv::InitCompress( LPWAVEFORMATEX lpwfxSourceFormat, GUID guidTargetCT )
{
	HRESULT hr;

	DNEnterCriticalSection( &m_csLock );

	if( m_fValid )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object already initialized" );
		DNLeaveCriticalSection( &m_csLock );			
		return DVERR_INITIALIZED;
	}

	hr = GetCompressionInfo( guidTargetCT );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "GetCTInfo Failed hr=0x%x", hr );
		DNLeaveCriticalSection( &m_csLock );			
		return hr;
	}

	hr = Initialize( lpwfxSourceFormat, m_pdvfci->lpwfxFormat,  lpwfxSourceFormat );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to init ct, hr = 0x%x", hr );
		delete [] m_pdvfci;
		m_pdvfci = NULL;
		DNLeaveCriticalSection( &m_csLock );			
		return hr;
	}

	DNLeaveCriticalSection( &m_csLock );		
	
	return DV_OK;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_IsValid"
HRESULT CDPVACMConv::I_IsValid( DPVACMCONVOBJECT *This, LPBOOL pfValid )
{
	DNEnterCriticalSection( &This->pObject->m_csLock );

	*pfValid = This->pObject->m_fValid;

	DNLeaveCriticalSection( &This->pObject->m_csLock );		

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_GetUnCompressedFrameSize"
HRESULT CDPVACMConv::I_GetUnCompressedFrameSize( DPVACMCONVOBJECT *This, LPDWORD lpdwFrameSize )
{
	DNEnterCriticalSection( &This->pObject->m_csLock );

	if( !This->pObject->m_fValid )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		DNLeaveCriticalSection( &This->pObject->m_csLock );			
		return DVERR_NOTINITIALIZED;
	}

	*lpdwFrameSize = This->pObject->m_dwUnCompressedFrameSize;

	DNLeaveCriticalSection( &This->pObject->m_csLock );		

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_GetCompressedFrameSize"
HRESULT CDPVACMConv::I_GetCompressedFrameSize( DPVACMCONVOBJECT *This, LPDWORD lpdwCompressedSize )
{
	DNEnterCriticalSection( &This->pObject->m_csLock );

	if( !This->pObject->m_fValid )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		DNLeaveCriticalSection( &This->pObject->m_csLock );			
		return DVERR_NOTINITIALIZED;
	}

	*lpdwCompressedSize = This->pObject->m_dwCompressedFrameSize;

	DNLeaveCriticalSection( &This->pObject->m_csLock );		

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_GetNumFramesPerBuffer"
HRESULT CDPVACMConv::I_GetNumFramesPerBuffer( DPVACMCONVOBJECT *This, LPDWORD lpdwFramesPerBuffer )
{
	DNEnterCriticalSection( &This->pObject->m_csLock );

	if( !This->pObject->m_fValid )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		DNLeaveCriticalSection( &This->pObject->m_csLock );			
		return DVERR_NOTINITIALIZED;
	}

	*lpdwFramesPerBuffer = This->pObject->m_dwNumFramesPerBuffer;

	DNLeaveCriticalSection( &This->pObject->m_csLock );		

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::I_Convert"
HRESULT CDPVACMConv::I_Convert( DPVACMCONVOBJECT *This, LPVOID lpInputBuffer, DWORD dwInputSize, LPVOID lpOutputBuffer, LPDWORD lpdwOutputSize, BOOL fSilence )
{
	return This->pObject->Convert( lpInputBuffer, dwInputSize, lpOutputBuffer, lpdwOutputSize, fSilence );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::Convert"
HRESULT CDPVACMConv::Convert( LPVOID lpInputBuffer, DWORD dwInputSize, LPVOID lpOutputBuffer, LPDWORD lpdwOutputSize, BOOL fSilence )
{
    DWORD dwLengthUsed;	// Used for storing tmp length values
    HRESULT hr;

	DNEnterCriticalSection( &m_csLock );

	if( !m_fValid )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		DNLeaveCriticalSection( &m_csLock );			
		return DVERR_NOTINITIALIZED;
	}
    
    if( fSilence )
    {
        memset( lpOutputBuffer, m_fTargetEightBit ? 0x80 : 0x00, *lpdwOutputSize );
		DNLeaveCriticalSection( &m_csLock );	        
        return true;
    }

    if( m_fDirectConvert )
    {
        // Setup the acm function
        memset( &m_ashSource, 0, sizeof( ACMSTREAMHEADER ) );
        m_ashSource.cbStruct = sizeof( ACMSTREAMHEADER );
        m_ashSource.fdwStatus = 0;
        m_ashSource.dwUser = 0;
        m_ashSource.cbSrcLength = dwInputSize;
        m_ashSource.pbSrc = (LPBYTE) lpInputBuffer;
        m_ashSource.cbSrcLengthUsed = 0;
        m_ashSource.dwSrcUser = 0;
        m_ashSource.pbDst = (LPBYTE) lpOutputBuffer;
        m_ashSource.cbDstLength = *lpdwOutputSize;
        m_ashSource.cbDstLengthUsed = 0;
        m_ashSource.dwDstUser = 0;

        // Prepare the header for conversion
        hr = acmStreamPrepareHeader( m_hacmSource, &m_ashSource , 0);

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare heade hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );	        	
        	return hr;
        }

        // Convert the data
        hr = acmStreamConvert( m_hacmSource, &m_ashSource, ACM_STREAMCONVERTF_BLOCKALIGN );

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to perform the conversion hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );	        	
        	return hr;
        }

        hr = acmStreamUnprepareHeader( m_hacmSource, &m_ashSource, 0 );

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to perform the conversion hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );	        	
        	return hr;
        }        

        dwLengthUsed = m_ashSource.cbDstLengthUsed;
    }
    else
    {
        // Setup the acm header for conversion fro mthe source to the
        // inner format
        memset( &m_ashSource, 0, sizeof( ACMSTREAMHEADER ) );
        m_ashSource.cbStruct = sizeof( ACMSTREAMHEADER );
        m_ashSource.fdwStatus = 0;
        m_ashSource.dwUser = 0;
        m_ashSource.cbSrcLength = dwInputSize;
        m_ashSource.pbSrc = (LPBYTE) lpInputBuffer;
        m_ashSource.cbSrcLengthUsed = 0;
        m_ashSource.dwSrcUser = 0;
        m_ashSource.pbDst = m_pbInnerBuffer;
        m_ashSource.cbDstLength = m_dwInnerBufferSize;
        m_ashSource.cbDstLengthUsed = 0;
        m_ashSource.dwDstUser = 0;

        // Prepare the header for conversion
        hr = acmStreamPrepareHeader( m_hacmSource, &m_ashSource , 0);

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare first stage header hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );	        	
        	return hr;
        }

        // Convert the data
        hr = acmStreamConvert( m_hacmSource, &m_ashSource, ACM_STREAMCONVERTF_BLOCKALIGN );

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to convert first stage hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );	        	
        	return hr;
        }        

        hr = acmStreamUnprepareHeader( m_hacmSource, &m_ashSource, 0 );

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to unprepare first stage header hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );	        	
        	return hr;
        }        

		DPFX(DPFPREP,  DVF_INFOLEVEL, "CONVERTER: Filling in %d bytes", m_dwInnerBufferSize -  m_ashSource.cbDstLengthUsed );

        memset( &m_ashTarget, 0, sizeof( ACMSTREAMHEADER ) );
        m_ashTarget.cbStruct = sizeof( ACMSTREAMHEADER );
        m_ashTarget.fdwStatus = 0;
        m_ashTarget.dwUser = 0;
        m_ashTarget.cbSrcLength = m_dwInnerBufferSize;
        m_ashTarget.pbSrc = m_pbInnerBuffer;
        m_ashTarget.cbSrcLengthUsed = 0;
        m_ashTarget.dwSrcUser = 0;
        m_ashTarget.pbDst = (LPBYTE) lpOutputBuffer;
        m_ashTarget.cbDstLength = *lpdwOutputSize;
        m_ashTarget.cbDstLengthUsed = 0;
        m_ashTarget.dwDstUser = 0;

        // Prepare the header for conversion
        hr = acmStreamPrepareHeader( m_hacmTarget, &m_ashTarget , 0);

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to prepare second stage header hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );		
        	return hr;
        }        

        // Convert the data
        hr = acmStreamConvert( m_hacmTarget, &m_ashTarget, ACM_STREAMCONVERTF_BLOCKALIGN );

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to convert second stage hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );		
        	return hr;
        }        

        hr = acmStreamUnprepareHeader( m_hacmTarget, &m_ashTarget, 0 );

        if( FAILED( hr ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to unprepare second stage header hr=0x%x", hr );
       		DNLeaveCriticalSection( &m_csLock );		
        	return hr;
        }        

        dwLengthUsed = m_ashTarget.cbDstLengthUsed;
    }

	DWORD offset = *lpdwOutputSize - dwLengthUsed;

	if( offset > 0 )
	{
		LPBYTE lpbTmp = (LPBYTE) lpOutputBuffer;
//		memset( &lpbTmp[*lpdwOutputSize - offset], (m_fTargetEightBit) ? 0x80 : 0x00, offset );
		memset( &lpbTmp[*lpdwOutputSize - offset], lpbTmp[*lpdwOutputSize - offset-1], offset );		
	}

	DNLeaveCriticalSection( &m_csLock );		

	// Always return the right length
    return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::Initialize"
HRESULT CDPVACMConv::Initialize( WAVEFORMATEX *pwfSrcFormat, WAVEFORMATEX *pwfTargetFormat, WAVEFORMATEX *pwfUnCompressedFormat )
{
    HRESULT retValue;

    // Attempt the conversion directly
    retValue = acmStreamOpen( &m_hacmSource, NULL, pwfSrcFormat, pwfTargetFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );

    // If it's not possible, we'll have to do a two step conversion
    if( retValue == static_cast<HRESULT>(ACMERR_NOTPOSSIBLE) )
    {
        retValue = acmStreamOpen( &m_hacmSource, NULL, pwfSrcFormat, &CDPVACMI::s_wfxInnerFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );

        if( FAILED( retValue ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Source compressor failed init hr=0x%x", retValue );
        	goto INITIALIZE_ERROR;
        }
        
        retValue = acmStreamOpen( &m_hacmTarget, NULL, &CDPVACMI::s_wfxInnerFormat, pwfTargetFormat, NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );

        if( FAILED( retValue ) )
        {
        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Target compressor failed init hr=0x%x", retValue );
        	goto INITIALIZE_ERROR;
        }        

        m_fDirectConvert = FALSE;

    } 
    // Still not possible
    else if( retValue != static_cast<HRESULT >(0))
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Compressor create error hr=0x%x", retValue );
		goto INITIALIZE_ERROR;
    }
    // Direct conversion was possible
    else
    {
        m_fDirectConvert = TRUE;
    }

    // If we're not direct converting, create an inner conversion 
    // buffer
    if( !m_fDirectConvert )
    {
		m_dwInnerBufferSize = CalcUnCompressedFrameSize( &CDPVACMI::s_wfxInnerFormat );
        m_pbInnerBuffer = new BYTE[m_dwInnerBufferSize];

        if( m_pbInnerBuffer == NULL )
        {
        	acmStreamClose( m_hacmSource, 0 );
        	acmStreamClose( m_hacmTarget, 0 );
            m_fValid = FALSE;            	
            retValue = DVERR_OUTOFMEMORY;
        }
    }
    else
    {
        m_pbInnerBuffer = NULL;
        m_dwInnerBufferSize = 0;
    }

    m_dwUnCompressedFrameSize = CalcUnCompressedFrameSize( pwfUnCompressedFormat );
    m_dwCompressedFrameSize = m_pdvfci->dwFrameLength;
    m_dwNumFramesPerBuffer = m_pdvfci->dwFramesPerBuffer;

    if( pwfTargetFormat->wBitsPerSample == 8 )
    {
	    m_fTargetEightBit = TRUE;
	}
	else
	{
		m_fTargetEightBit = FALSE;
	}

	m_fValid = TRUE;

	return DV_OK;
    
INITIALIZE_ERROR:

	if( m_hacmSource != NULL )
		acmStreamClose( m_hacmSource, 0 );

	if( m_hacmTarget != NULL )
		acmStreamClose( m_hacmTarget, 0 );

	if( m_pbInnerBuffer != NULL )
		delete [] m_pbInnerBuffer;

    m_fValid = FALSE;

    return retValue;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVACMConv::Initialize"
DWORD CDPVACMConv::CalcUnCompressedFrameSize( LPWAVEFORMATEX lpwfxFormat )
{
	DWORD frameSize;

    switch( lpwfxFormat->nSamplesPerSec )
    {
    case 8000:      frameSize = m_pdvfci->dwFrame8Khz;      break;
    case 11025:     frameSize = m_pdvfci->dwFrame11Khz;     break;
    case 22050:     frameSize = m_pdvfci->dwFrame22Khz;     break;
    case 44100:     frameSize = m_pdvfci->dwFrame44Khz;     break;
    default:        return 0;
    }

	if( lpwfxFormat->wBitsPerSample == 16 )
		frameSize *= 2;

	frameSize *= lpwfxFormat->nChannels;

	return frameSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvaconv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvaconv.h
 *  Content:    Header file for DirectPlayVoice compression provider (ACM)
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 ***************************************************************************/
#ifndef __DPVACONV_H
#define __DPVACONV_H

struct DPVACMCONVOBJECT;

class CDPVACMConv
{
public:
	CDPVACMConv();
	~CDPVACMConv();
	
	static HRESULT I_QueryInterface( DPVACMCONVOBJECT *This, REFIID riid, PVOID *ppvObj );
	static HRESULT I_AddRef( DPVACMCONVOBJECT *This );
	static HRESULT I_Release( DPVACMCONVOBJECT *This );

	static HRESULT I_InitDeCompress( DPVACMCONVOBJECT *This, GUID guidSourceCT, LPWAVEFORMATEX lpwfxTargetFormat );
	static HRESULT I_InitCompress( DPVACMCONVOBJECT *This, LPWAVEFORMATEX lpwfxSourceFormat, GUID guidTargetCT );    
	static HRESULT I_IsValid( DPVACMCONVOBJECT *This, LPBOOL pfValid );
	static HRESULT I_GetUnCompressedFrameSize( DPVACMCONVOBJECT *This, LPDWORD lpdwFrameSize );
    static HRESULT I_GetCompressedFrameSize( DPVACMCONVOBJECT *This, LPDWORD lpdwCompressedSize );
    static HRESULT I_GetNumFramesPerBuffer( DPVACMCONVOBJECT *This, LPDWORD lpdwFramesPerBuffer );
	static HRESULT I_Convert( DPVACMCONVOBJECT *This, LPVOID lpInputBuffer, DWORD dwInputSize, LPVOID lpOutputBuffer, LPDWORD lpdwOutputSize, BOOL fSilence );  

	HRESULT InitDeCompress( GUID guidSourceCT, LPWAVEFORMATEX lpwfxTargetFormat );
	HRESULT InitCompress( LPWAVEFORMATEX lpwfxSourceFormat, GUID guidTargetCT );    
	HRESULT Convert( LPVOID lpInputBuffer, DWORD dwInputSize, LPVOID lpOutputBuffer, LPDWORD lpdwOutputSize, BOOL fSilence );  	

	BOOL InitClass();

protected:

	HRESULT Initialize( WAVEFORMATEX *pwfSrcFormat, WAVEFORMATEX *pwfTargetFormat, WAVEFORMATEX *pwfUnCompressedFormat );
	HRESULT GetCompressionInfo( GUID guidCT );
	DWORD CalcUnCompressedFrameSize( LPWAVEFORMATEX lpwfxFormat );
	
    ACMSTREAMHEADER m_ashSource;
    ACMSTREAMHEADER m_ashTarget;
	HACMSTREAM      m_hacmSource;
    HACMSTREAM      m_hacmTarget;
    BOOL			m_fDirectConvert;		// Is it a direct conversion
    BOOL			m_fValid;
    BYTE			*m_pbInnerBuffer;		// Buffer for intermediate step of conversion
    DWORD			m_dwInnerBufferSize;	// Size of the buffer
    DNCRITICAL_SECTION m_csLock;
    LONG			m_lRefCount;
    LPDVFULLCOMPRESSIONINFO m_pdvfci;
	DWORD m_dwUnCompressedFrameSize;
	DWORD m_dwCompressedFrameSize;
	DWORD m_dwNumFramesPerBuffer;    
	BOOL			m_fTargetEightBit;

	BOOL m_fCritSecInited;
};

struct DPVACMCONVOBJECT
{
	LPVOID		lpvVtble;
	CDPVACMConv	*pObject;
};

typedef DPVACMCONVOBJECT *LPDPVACMCONVOBJECT, *PDPVACMCONVOBJECT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvautil.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvautil.cpp
 *  Content:    Source file for ACM utils
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 *  12/16/99	rodtoll		Bug #123250 - Insert proper names/descriptions for codecs
 *							Codec names now based on resource entries for format and
 *							names are constructed using ACM names + bitrate.
 *  04/21/2000  rodtoll   Bug #32889 - Does not run on Win2k on non-admin account
 *  06/28/2000	rodtoll		Prefix Bug #38034
 *
 ***************************************************************************/

#include "dpvacmpch.h"


#define REGISTRY_CDB_FORMAT					L"Format"
#define REGISTRY_CT_FRAMESPERBUFFER			L"FramesPerBuffer"
#define REGISTRY_CT_TRAILFRAMES				L"TrailFrames"
#define REGISTRY_CT_TIMEOUT					L"Timeout"
#define REGISTRY_CT_FRAMELENGTH				L"FrameLength"
#define REGISTRY_CT_FRAMELENGTH8KHZ			L"FrameLength8Khz"
#define REGISTRY_CT_FRAMELENGTH11KHZ		L"FrameLength11Khz"
#define REGISTRY_CT_FRAMELENGTH22KHZ		L"FrameLength22Khz"
#define REGISTRY_CT_FRAMELENGTH44KHZ		L"FrameLength44Khz"
#define REGISTRY_CT_MAXBITSPERSEC			L"MaxBitsPerSec"
#define REGISTRY_CT_FLAGS					L"Flags"
#define REGISTRY_CT_NAME					L"Name"
#define REGISTRY_CT_DESCRIPTION				L"Description"
#define REGISTRY_CT_MINCONNECT				L"MinConnect"
#define REGISTRY_CT_INNERQUEUESIZE			L"InnerQueueSize"
#define REGISTRY_CT_MAXHIGHWATERMARK		L"MaxWatermark"
#define REGISTRY_CT_MAXQUEUESIZE			L"MaxQueueSize"
#define REGISTRY_CT_GUID					L"GUID"

// Check to see if ACM's PCM converter is available
#undef DPF_MODNAME
#define DPF_MODNAME "IsPCMConverterAvailable"
HRESULT IsPCMConverterAvailable()
{
	MMRESULT mmr;
	HACMSTREAM has = NULL;
	HACMDRIVERID acDriverID = NULL;
	HRESULT hr;

	CWaveFormat wfxOuterFormat, wfxInnerFormat;

	hr = wfxOuterFormat.InitializePCM( 22050, FALSE, 8 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error building outer format PCM hr=0x%x", hr );
		return hr;
	}

	hr = wfxInnerFormat.InitializePCM( 8000, FALSE, 16 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error building inner format PCM hr=0x%x", hr );
		return hr;
	}

	// Attempt to open
	mmr = acmStreamOpen( &has, NULL, wfxOuterFormat.GetFormat(), wfxInnerFormat.GetFormat(), NULL, 0, 0, ACM_STREAMOPENF_NONREALTIME );

	if( mmr != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Compression type driver disabled or not installed.  mmr=0x%x", mmr );
		return DVERR_COMPRESSIONNOTSUPPORTED;
	}

	acmStreamClose( has, 0 );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CREG_ReadCompressionInfo"
HRESULT CREG_ReadCompressionInfo( HKEY hkeyReg, const LPWSTR lpszPath, LPDVFULLCOMPRESSIONINFO lpdvfCompressionInfo )
{
	CRegistry cregCT;
	HRESULT hr;

	DWORD dwTmp, dwTmpLength;
	BOOL fRead;

	CWaveFormat wfxFormat;

	lpdvfCompressionInfo->lpszName = NULL;
	lpdvfCompressionInfo->lpszDescription = NULL;

	if( !cregCT.Open( hkeyReg, lpszPath, TRUE, FALSE ) )
	{
		return E_FAIL;
	}

	lpdvfCompressionInfo->lpwfxFormat = NULL;

	hr = wfxFormat.InitializeREG( cregCT.GetHandle(), REGISTRY_CDB_FORMAT );

	if( FAILED( hr ) )
	{
		goto READCT_FAILURE;
	}

	lpdvfCompressionInfo->lpwfxFormat = wfxFormat.Disconnect();

	if( !cregCT.ReadDWORD( REGISTRY_CT_FRAMESPERBUFFER, lpdvfCompressionInfo->dwFramesPerBuffer ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading framesperbuffer key from registry" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_TRAILFRAMES, lpdvfCompressionInfo->dwTrailFrames ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading trailframe key from registry" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_TIMEOUT, lpdvfCompressionInfo->dwTimeout ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading timeout key from registry" );
		goto READCT_FAILURE;
	}

    if( !cregCT.ReadDWORD( REGISTRY_CT_FRAMELENGTH, lpdvfCompressionInfo->dwFrameLength ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading framelength key from registry" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_FRAMELENGTH8KHZ, lpdvfCompressionInfo->dwFrame8Khz ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading frame8 key from reg" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_FRAMELENGTH11KHZ, lpdvfCompressionInfo->dwFrame11Khz ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading frame11 key from reg" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_FRAMELENGTH22KHZ, lpdvfCompressionInfo->dwFrame22Khz ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading frame22 key from reg" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_FRAMELENGTH44KHZ, lpdvfCompressionInfo->dwFrame44Khz ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading frame44 key from reg" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_MAXBITSPERSEC, lpdvfCompressionInfo->dwMaxBitsPerSecond ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading maxbitspersec from reg" );
		goto READCT_FAILURE;
	}

	if( !cregCT.ReadDWORD( REGISTRY_CT_FLAGS, lpdvfCompressionInfo->dwFlags ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading flags from reg" );
		goto READCT_FAILURE;
	}

	dwTmpLength = 0;
	fRead = FALSE;
	lpdvfCompressionInfo->lpszDescription = NULL;

	dwTmpLength = 0;
	fRead = FALSE;
	lpdvfCompressionInfo->lpszName = NULL;

	if( !cregCT.ReadDWORD( REGISTRY_CT_MINCONNECT, dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading minconnect from reg" );
		goto READCT_FAILURE;
	}

	lpdvfCompressionInfo->bMinConnectType = (BYTE) dwTmp;

	if( !cregCT.ReadDWORD( REGISTRY_CT_INNERQUEUESIZE, dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading qs from reg" );
		goto READCT_FAILURE;
	}

	lpdvfCompressionInfo->wInnerQueueSize = (WORD) dwTmp;

	if( !cregCT.ReadDWORD( REGISTRY_CT_MAXHIGHWATERMARK, dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading highmark key from reg" );
		goto READCT_FAILURE;
	}

	lpdvfCompressionInfo->wMaxHighWaterMark = (WORD) dwTmp;

	if( !cregCT.ReadDWORD( REGISTRY_CT_MAXQUEUESIZE, dwTmp ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading maxqueue key from reg" );
		goto READCT_FAILURE;
	}

	lpdvfCompressionInfo->bMaxQueueSize = (BYTE) dwTmp;

	if( !cregCT.ReadGUID( REGISTRY_CT_GUID, lpdvfCompressionInfo->guidType ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading guid key from reg" );
		goto READCT_FAILURE;
	}

	return S_OK;

READCT_FAILURE:

	if( lpdvfCompressionInfo->lpszName != NULL )
	{
		delete [] lpdvfCompressionInfo->lpszName;
	}

	if( lpdvfCompressionInfo->lpszDescription != NULL )
	{
		delete [] lpdvfCompressionInfo->lpszDescription;
	}


	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\dpvautil.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvautil.h
 *  Content:    Header file for ACM utils
 *
 *  History:
 *	Date   		By  		Reason
 *	=========== =========== ====================
 *	10/27/99	rodtoll		created
 ***************************************************************************/

#ifndef __DPVAUTIL_H
#define __DPVAUTIL_H

#define DPF_SUBCOMP DN_SUBCOMP_VOICE

HRESULT IsPCMConverterAvailable();
HRESULT CREG_ReadAndAllocWaveFormatEx( HKEY hkeyReg, const LPWSTR path, LPWAVEFORMATEX *lpwfxFormat );
HRESULT CREG_ReadCompressionInfo( HKEY hkeyReg, const LPWSTR lpszPath, LPDVFULLCOMPRESSIONINFO lpdvfCompressionInfo );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpvacm.rc
//
#define IDS_CODECNAME_FORMAT            1
#define IDS_CODECNAME_KBITSPERSEC       2
#define IDS_CODECNAME_KBITSPERSEC_FULL  3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvcplib\dpvcpi.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvcpi.h
 *  Content:	Base class for providing compression DLL implementation
 *
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 10/27/99 rodtoll Created
 ***************************************************************************/

#ifndef __DPVCPI_H
#define __DPVCPI_H

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

struct DPVCPIOBJECT;

class CDPVCPI
{
protected:

	struct CompressionNode
	{
		DVFULLCOMPRESSIONINFO *pdvfci;
		CompressionNode		  *pcnNext;
	};
	
public:
	CDPVCPI();
	virtual ~CDPVCPI();

public: // These functions must be implemented for the compression provider
	static HRESULT I_CreateCompressor( DPVCPIOBJECT *This, LPWAVEFORMATEX lpwfxSrcFormat, GUID guidTargetCT, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags );
	static HRESULT I_CreateDeCompressor( DPVCPIOBJECT *This, GUID guidTargetCT, LPWAVEFORMATEX lpwfxSrcFormat, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags );

public: // A pre-built version 

	static HRESULT DeInitCompressionList();
	
	static HRESULT QueryInterface( DPVCPIOBJECT *This, REFIID riid, PVOID *ppvObj );
	static HRESULT AddRef( DPVCPIOBJECT *This );
	static HRESULT Release( DPVCPIOBJECT *This );

	BOOL InitClass();

	static HRESULT EnumCompressionTypes( DPVCPIOBJECT *This, PVOID pBuffer, PDWORD pdwSize, PDWORD pdwNumElements, DWORD dwFlags );
	static HRESULT IsCompressionSupported( DPVCPIOBJECT *This, GUID guidCT );
	static HRESULT GetCompressionInfo( DPVCPIOBJECT *This, GUID guidCT, PVOID pbuffer, PDWORD pdwSize );

public: // These functions must be implemented

	virtual HRESULT CreateCompressor( DPVCPIOBJECT *This, LPWAVEFORMATEX lpwfxSrcFormat, GUID guidTargetCT, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags ) = 0;
	virtual HRESULT CreateDeCompressor( DPVCPIOBJECT *This, GUID guidTargetCT, LPWAVEFORMATEX lpwfxSrcFormat, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags ) = 0;

protected: // Useful utility functions

	friend struct DPVCPIOBJECT;

	// Add an element to the internal compression types list
	static HRESULT CN_Add( DVFULLCOMPRESSIONINFO *pdvfci );

	// Retrieve pointer to the compression type specified by the GUID
	static HRESULT CN_Get( GUID guidCT, DVFULLCOMPRESSIONINFO **pdvfci );

	// Free up the list, deallocating memory.
	static HRESULT CN_FreeList();

	static void CN_FreeItem( CompressionNode *pcNode );

	// Checks to see the size (in bytes) of the specified compression info structure
	static HRESULT CI_GetSize( DVFULLCOMPRESSIONINFO *pdvfci, LPDWORD lpdwSize );

protected:

	static CompressionNode 	*s_pcnList;		// List of compression types
	static BOOL s_fIsLoaded;				// Have compression types been loaded.
	static DWORD s_dwNumCompressionTypes;	// # of valid compression types
	
	DNCRITICAL_SECTION m_csLock;			// Lock for the object.
	LONG m_lRefCount;						// Reference count for the object

	BOOL m_fCritSecInited;
};

struct DPVCPIOBJECT
{
	LPVOID		lpvVtble;
	CDPVCPI		*pObject;
};

typedef DPVCPIOBJECT *LPDPVCPIOBJECT, *PDPVCPIOBJECT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvcplib\dpvcpi.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvcpi.cpp
 *  Content:	Base class for providing compression DLL implementation
 *
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 10/27/99 rodtoll Created
 * 01/21/00	rodtoll	Moved error level debug to info
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 06/27/2001	rodtoll	RC2: DPVOICE: DPVACM's DllMain calls into acm -- potential hang
 *						Move global initialization to first object creation
 ***************************************************************************/


#include <windows.h>
#include "osind.h"
#include "dndbg.h"
#include "dpvcp.h"
#include "dpvcpi.h"

LONG IncrementObjectCount();
LONG DecrementObjectCount();
extern "C" LONG g_lNumLocks;

CDPVCPI::CompressionNode *CDPVCPI::s_pcnList = NULL;
BOOL CDPVCPI::s_fIsLoaded = FALSE;
DWORD CDPVCPI::s_dwNumCompressionTypes = 0;

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::CDPVCPI"
CDPVCPI::CDPVCPI(): m_lRefCount(0), m_fCritSecInited(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::InitClass"
BOOL CDPVCPI::InitClass()
{
	if (DNInitializeCriticalSection( &m_csLock ))
	{
		m_fCritSecInited = TRUE;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::I_CreateCompressor"
HRESULT CDPVCPI::I_CreateCompressor( DPVCPIOBJECT *This, LPWAVEFORMATEX lpwfxSrcFormat, GUID guidTargetCT, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags )
{
	return This->pObject->CreateCompressor( This, lpwfxSrcFormat, guidTargetCT, ppCompressor, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::I_CreateDeCompressor"
HRESULT CDPVCPI::I_CreateDeCompressor( DPVCPIOBJECT *This, GUID guidTargetCT, LPWAVEFORMATEX lpwfxSrcFormat, PDPVCOMPRESSOR *ppCompressor, DWORD dwFlags )
{
	return This->pObject->CreateDeCompressor( This, guidTargetCT, lpwfxSrcFormat, ppCompressor, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::~CDPVCPI"
CDPVCPI::~CDPVCPI()
{
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_csLock );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::DeInitCompressionList"
HRESULT CDPVCPI::DeInitCompressionList()
{
	return CN_FreeList();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::QueryInterface"
HRESULT CDPVCPI::QueryInterface( DPVCPIOBJECT *This, REFIID riid, PVOID *ppvObj )
{
    HRESULT hr = S_OK;

	if( ppvObj == NULL ||
	    !DNVALID_WRITEPTR( ppvObj, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for object" );
		return DVERR_INVALIDPOINTER;
	}	
    
     *ppvObj=NULL;

    DNEnterCriticalSection( &This->pObject->m_csLock );

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IDPVCompressionProvider ) )
    {
		*ppvObj = This;
		This->pObject->AddRef( This );
    }
	else 
	{
	    hr =  E_NOINTERFACE;		
	}

	DNLeaveCriticalSection( &This->pObject->m_csLock );    	
        
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::AddRef"
HRESULT CDPVCPI::AddRef( DPVCPIOBJECT *This )
{
	LONG rc;

	rc = InterlockedIncrement( &This->pObject->m_lRefCount );
	
	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::Release"
HRESULT CDPVCPI::Release( DPVCPIOBJECT *This )
{
	LONG rc;

	if( ( rc = InterlockedDecrement( &This->pObject->m_lRefCount ) ) == 0 )
	{
	 	DPFX(DPFPREP,  DVF_INFOLEVEL, "Destroying object" );

		delete This->pObject;
		delete This;

		DecrementObjectCount();
	}

	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::EnumCompressionTypes"
HRESULT CDPVCPI::EnumCompressionTypes( DPVCPIOBJECT *This, PVOID pBuffer, PDWORD pdwSize, PDWORD pdwNumElements, DWORD dwFlags )
{
	if( pdwSize == NULL || 
		!DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer specified for pdwSize" );
		return DVERR_INVALIDPOINTER;
	}

	if( *pdwSize > 0 &&
		!DNVALID_WRITEPTR( pBuffer, *pdwSize ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer specified for buffer" );
		return DVERR_INVALIDPOINTER;
	}
	
	CompressionNode *pcnWalker = s_pcnList;

	DWORD dwRequiredSize = 0, 
		  dwTmp = 0,
		  dwNumElements = 0,
		  dwStringSize = 0;
	LPBYTE pbDataPtr;

	DVFULLCOMPRESSIONINFO *pbStructPtr;
	
	HRESULT hr;

	// Walk the list and determine how much space we need
	while( pcnWalker != NULL )
	{
		hr = CI_GetSize( pcnWalker->pdvfci, &dwTmp );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get size" );
			return hr;
		}

		dwRequiredSize += dwTmp;
		
		pcnWalker = pcnWalker->pcnNext;
		dwNumElements++;
	}

	if( dwRequiredSize > *pdwSize )
	{
		*pdwSize = dwRequiredSize;
		return DVERR_BUFFERTOOSMALL;
	}

	*pdwNumElements = dwNumElements;

	*pdwSize = dwRequiredSize;
	pbDataPtr = (LPBYTE) pBuffer;
	pbStructPtr = (DVFULLCOMPRESSIONINFO *) pBuffer;

	// Move data pointer to be right after location of 
	pbDataPtr += (dwNumElements*sizeof(DVFULLCOMPRESSIONINFO));

	pcnWalker = s_pcnList;

	while( pcnWalker != NULL )
	{
		memcpy( pbStructPtr, pcnWalker->pdvfci, sizeof( DVFULLCOMPRESSIONINFO ) );

		// If there is a name, copy it at the end
		if( pcnWalker->pdvfci->lpszName != NULL && wcslen( pcnWalker->pdvfci->lpszName ) > 0 )
		{
			dwStringSize = (wcslen( pcnWalker->pdvfci->lpszName )+1)*2;
			memcpy( pbDataPtr, pcnWalker->pdvfci->lpszName, dwStringSize );
			pbStructPtr->lpszName = (wchar_t *) pbDataPtr;			
			pbDataPtr += dwStringSize;
		}

		// If there's a description, copy it at the end
		if( pcnWalker->pdvfci->lpszDescription != NULL && wcslen( pcnWalker->pdvfci->lpszDescription ) > 0 )
		{
			dwStringSize = (wcslen( pcnWalker->pdvfci->lpszDescription)+1)*2;
			memcpy( pbDataPtr, pcnWalker->pdvfci->lpszDescription, dwStringSize );
			pbStructPtr->lpszDescription = (wchar_t *) pbDataPtr;
			pbDataPtr += dwStringSize;
		}

		// If there's a format, copy it at the end
		if( pcnWalker->pdvfci->lpwfxFormat != NULL )
		{
			dwStringSize = sizeof( WAVEFORMATEX ) + pcnWalker->pdvfci->lpwfxFormat->cbSize;
			memcpy( pbDataPtr, pcnWalker->pdvfci->lpwfxFormat, dwStringSize  );		
			pbStructPtr->lpwfxFormat = (LPWAVEFORMATEX) pbDataPtr;
			pbDataPtr += dwStringSize;
		}

		pbStructPtr ++;

		pcnWalker = pcnWalker->pcnNext;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::IsCompressionSupported"
HRESULT CDPVCPI::IsCompressionSupported( DPVCPIOBJECT *This, GUID guidCT )
{
	DVFULLCOMPRESSIONINFO *pdvfci;

	if( !FAILED( CN_Get( guidCT, &pdvfci ) ) )
	{
		return DV_OK;
	}
	else
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid CT specified" );
		return DVERR_COMPRESSIONNOTSUPPORTED;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::GetCompressionInfo"
HRESULT CDPVCPI::GetCompressionInfo( DPVCPIOBJECT *This, GUID guidCT, PVOID pBuffer, PDWORD pdwSize )
{
	DVFULLCOMPRESSIONINFO *pdvfci;

	if( pdwSize == NULL || 
		!DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer specified for pdwSize" );
		return DVERR_INVALIDPOINTER;
	}

	if( *pdwSize > 0 &&
		!DNVALID_WRITEPTR( pBuffer, *pdwSize ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer specified for buffer" );
		return DVERR_INVALIDPOINTER;
	}
	
	if( FAILED( CN_Get( guidCT, &pdvfci ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid CT specified" );
		return DVERR_COMPRESSIONNOTSUPPORTED;	
	}
	else
	{
		DWORD dwSize;
		HRESULT hr;
		LPBYTE pbTmp;
		DWORD dwStringSize;
		DVFULLCOMPRESSIONINFO *pTmpInfo;

		hr = CI_GetSize( pdvfci, &dwSize );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get size of ci" );
			return hr;
		}
		
		if( dwSize > *pdwSize )
		{
			*pdwSize = dwSize;
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Buffer too small" );
			return DVERR_BUFFERTOOSMALL;
		}

		*pdwSize = dwSize;

		memcpy( pBuffer, pdvfci, sizeof( DVFULLCOMPRESSIONINFO ) );

		pbTmp = (LPBYTE) pBuffer;
		pTmpInfo = (DVFULLCOMPRESSIONINFO *) pBuffer;

		pbTmp += sizeof( DVFULLCOMPRESSIONINFO );

		// If there is a name
		if( pdvfci->lpszName != NULL && wcslen( pdvfci->lpszName ) > 0 )
		{
			dwStringSize = (wcslen( pdvfci->lpszName )+1)*2;
			memcpy( pbTmp, pdvfci->lpszName, dwStringSize );
			pTmpInfo->lpszName = (wchar_t *) pbTmp;			
			pbTmp += dwStringSize;
		}

		if( pdvfci->lpszDescription != NULL && wcslen( pdvfci->lpszDescription ) > 0 )
		{
			dwStringSize = (wcslen( pdvfci->lpszDescription)+1)*2;
			memcpy( pbTmp, pdvfci->lpszDescription, dwStringSize );
			pTmpInfo->lpszDescription = (wchar_t *) pbTmp;
			pbTmp += dwStringSize;
		}

		if( pdvfci->lpwfxFormat != NULL )
		{
			memcpy( pbTmp, pdvfci->lpwfxFormat, sizeof( WAVEFORMATEX ) + pdvfci->lpwfxFormat->cbSize );
			pTmpInfo->lpwfxFormat = (LPWAVEFORMATEX) pbTmp;
		}

		return DV_OK;
	}	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::CN_Add"
HRESULT CDPVCPI::CN_Add( DVFULLCOMPRESSIONINFO *pdvfci )
{
	CompressionNode *pcnNewNode = new CompressionNode;

	if( pcnNewNode == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
		return DVERR_OUTOFMEMORY;
	}

	pcnNewNode->pcnNext = s_pcnList;
	pcnNewNode->pdvfci = pdvfci;
	s_pcnList = pcnNewNode;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::CN_Get"
HRESULT CDPVCPI::CN_Get( GUID guidCT, DVFULLCOMPRESSIONINFO **pdvfci )
{
	CompressionNode *pcnWalker = s_pcnList;

	*pdvfci = NULL;

	while( pcnWalker != NULL )
	{
		if( pcnWalker->pdvfci->guidType == guidCT )
		{
			*pdvfci = pcnWalker->pdvfci;
			return DV_OK;
		}

		pcnWalker = pcnWalker->pcnNext;
	}

	return DVERR_COMPRESSIONNOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::CN_FreeList"
void CDPVCPI::CN_FreeItem( CompressionNode *pcNode )
{
	if( pcNode->pdvfci->lpwfxFormat != NULL )
	{
		delete [] pcNode->pdvfci->lpwfxFormat;
	}

	if( pcNode->pdvfci->lpszName != NULL )
	{
		delete [] pcNode->pdvfci->lpszName;
	}

	if( pcNode->pdvfci->lpszDescription != NULL )
	{
		delete [] pcNode->pdvfci->lpszDescription;
	}

	delete pcNode->pdvfci;

	delete pcNode;	
}

// Free up the list, deallocating memory.
#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::CN_FreeList"
HRESULT CDPVCPI::CN_FreeList()
{
	CompressionNode *pcnWalker = s_pcnList;
	CompressionNode *pcnTmp;

	while( pcnWalker != NULL )
	{
		pcnTmp = pcnWalker;
		pcnWalker = pcnWalker->pcnNext;

		CN_FreeItem( pcnTmp );
	}

	s_pcnList = NULL;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDPVCPI::CI_GetSize"
HRESULT CDPVCPI::CI_GetSize( DVFULLCOMPRESSIONINFO *pdvfci, LPDWORD lpdwSize )
{
	DWORD dwSize = sizeof( DVFULLCOMPRESSIONINFO );

	if( pdvfci->lpwfxFormat != NULL )
	{
		dwSize += sizeof( WAVEFORMATEX ) + pdvfci->lpwfxFormat->cbSize;
	}

	if( pdvfci->lpszName != NULL )
	{
		dwSize += ((wcslen( pdvfci->lpszName )+1)*2);
	}

	if( pdvfci->lpszDescription != NULL )
	{
		dwSize += ((wcslen( pdvfci->lpszDescription )+1)*2);
	}

	*lpdwSize = dwSize;

	return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxchar.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxlib.cpp
 *  Content:	Useful char utility functions lib for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 06/28/2000 rodtoll	Prefix Bug #38033
 *
 ***************************************************************************/

#include "dpvxlibpch.h"


// Conversion Functions
int DPVDX_WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL bDefault = FALSE;

	if (!lpWStr && cchStr)
	{
		DebugBreak();
		return 0;
	}
	
	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,
			"-",&bDefault);

	if (bDefault)
	{
		DebugBreak();
	}
	
	return rval;
}

HRESULT DPVDX_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPWSTR lpszWide)
{
	int iStrLen;
	
	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return S_OK;
	}

	// call wide to ansi to find out how big +1 for terminating NULL
	iStrLen = DPVDX_WideToAnsi(NULL,lpszWide,0) + 1;

	*ppszAnsi = new char[iStrLen];
	if (!*ppszAnsi)	
	{
		return E_OUTOFMEMORY;
	}
	DPVDX_WideToAnsi(*ppszAnsi,lpszWide,iStrLen);

	return S_OK;

}

int DPVDX_AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr)
{
	int rval;

	if (!lpStr && cchWStr)
	{
		return 0;
	}

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);

	return rval;
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxchar.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxchar.h
 *  Content:	Useful char utility functions for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 *
 ***************************************************************************/
#ifndef __DPVXCHAR_H
#define __DPVXCHAR_H

// Conversion Functions
extern int DPVDX_WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
extern HRESULT DPVDX_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPWSTR lpszWide);
extern int DPVDX_AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\codecs\dpvacm\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

!INCLUDE ..\..\..\..\bldcfg\dpvbld.inc

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=$(DPVOICE_BUILD_FILENAME_DPVACM)
DLLDEF=..\$(DPVOICE_BUILD_FILENAME_DPVACM).def

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dpvacmpch.h
PRECOMPILED_PCH=dpvacmpch.pch
PRECOMPILED_OBJ=dpvacmpch.obj
!endif

#required or you get the cryptic error on Win95 gold : "Expects newer version of windows"
UMTYPE=windows

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\..\..\dnet\common\obj$(BUILD_ALT_DIR)\*\common.lib \
           ..\..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
	   ..\..\dpvcplib\obj$(BUILD_ALT_DIR)\*\dpvcplib.lib \
           ..\..\..\dxvutils\obj$(BUILD_ALT_DIR)\*\dxvutils.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\msacm32.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib
	   

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\..\dnet\common;..\..\..\inc;..\..\dpvcplib;..\..\..\dxvutils;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\acmclassfac.cpp ..\dpvacm.rc ..\acmunk.cpp ..\dpvacmi.cpp ..\dpvautil.cpp ..\dpvaconv.cpp ..\acmdllmain.cpp

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DCINTERFACE \
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(VOICE_TARGET)" == "allegiance" 
	/DVOICE_BUILD_ALLEGIANCE \
!endif
	  /DDIRECTVOICE_EXPORTS

USE_NOLIBS=1

DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxdplay.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxdplay.cpp
 *  Content:	Useful dplay utility functions lib for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 10/27/99	  pnewson	Added support for application flags
 * 11/02/99	  rodtoll	Bug #116677 - Can't use lobby clients that don't hang around 
 * 12/16/99	  rodtoll	Bug #122629 - Player was being created as server player exposed
 *						by new host migration
 * 03/03/2000 rodtoll	Updated to handle alternative gamevoice build.   
 * 08/31/2000 rodtoll	Whistler Bug #171844, 171842
 *
 ***************************************************************************/

#include "dpvxlibpch.h"


// Start a session with the specified settings.
HRESULT DPVDX_DP_StartSession( 
	// Input
	LPDIRECTPLAY4A lpDirectPlay, 
	GUID guidApplicationID, 
	DWORD dwFlags, 
	LPTSTR lpszPlayerName,
	LPTSTR lpszSessionName,
	DWORD dwMaxPlayers,
	// Output
	LPDPID lpdpidServerID, 
	LPHANDLE lpReceiveEvent,
	LPGUID lpguidInstanceGUID
	)
{
	HRESULT hr;

	// Create and intialize the server
	DPSESSIONDESC2 dpSessionDesc;

	memset( &dpSessionDesc, 0, sizeof( DPSESSIONDESC2 ) );
	dpSessionDesc.dwSize = sizeof( DPSESSIONDESC2 );
	dpSessionDesc.dwFlags = DPSESSION_DIRECTPLAYPROTOCOL;
	dpSessionDesc.dwFlags |= dwFlags;

	dpSessionDesc.guidApplication = guidApplicationID;
	dpSessionDesc.dwMaxPlayers = dwMaxPlayers;
	dpSessionDesc.lpszSessionNameA = lpszSessionName;
	dpSessionDesc.lpszPasswordA = NULL;

	DPNAME tmpName;

	tmpName.dwSize = sizeof(DPNAME);
	tmpName.lpszShortNameA = lpszPlayerName;
	tmpName.lpszLongNameA = lpszPlayerName;

	hr = lpDirectPlay->Open( &dpSessionDesc, DPOPEN_CREATE );

	if( FAILED( hr ) )
	{
		goto STARTSESSION_ERROR;
	}

	*lpReceiveEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	hr = lpDirectPlay->CreatePlayer( lpdpidServerID, &tmpName, *lpReceiveEvent, NULL, 0, (dwFlags & DPSESSION_CLIENTSERVER) ? DPPLAYER_SERVERPLAYER : 0 );

	if( FAILED( hr ) )
	{
		goto STARTSESSION_ERROR;
	}

	return DV_OK;

STARTSESSION_ERROR:

	return hr;

}

HRESULT DPVDX_DP_Init( LPDIRECTPLAY4A lpDirectPlay, GUID guidServiceProvider, LPSTR lpstrAddress )
{
	if( lpDirectPlay == NULL )
		return E_POINTER;
		
	HRESULT hr = DV_OK;
    DPCOMPOUNDADDRESSELEMENT elements[2];
    BYTE *buffer = NULL;
    DWORD dwSize = 0;	
    LPDIRECTPLAYLOBBY2 directPlayLobby2 = NULL;
    DWORD dwNumElements = 1;

	hr = CoCreateInstance( DPLAY_CLSID_DPLOBBY, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayLobby2, (void **) &directPlayLobby2 );

    if( FAILED( hr ) )
    	goto DPINIT_CLEANUP;

    elements[0].guidDataType = DPAID_ServiceProvider;
    elements[0].dwDataSize = sizeof( GUID );
    elements[0].lpData = (LPVOID) &guidServiceProvider;

    if( lpstrAddress != NULL )
    {
    	dwNumElements = 2;
		elements[1].guidDataType = DPAID_INet;
		elements[1].dwDataSize = strlen( lpstrAddress );
		elements[1].lpData = lpstrAddress;
	}

    // Determine size of the buffer we need
    hr = directPlayLobby2->CreateCompoundAddress( elements, dwNumElements, NULL, &dwSize );

    if( hr != DPERR_BUFFERTOOSMALL && FAILED( hr ) )
    	goto DPINIT_CLEANUP;

    buffer = new BYTE[dwSize];

    if( buffer == NULL )
    {
    	hr = DVERR_OUTOFMEMORY;
    	goto DPINIT_CLEANUP;
    }

    // Actually allocate the connection information
    hr = directPlayLobby2->CreateCompoundAddress( elements, dwNumElements, buffer, &dwSize );       

    if( FAILED( hr ) )
    {
    	goto DPINIT_CLEANUP;
    }

	hr = lpDirectPlay->InitializeConnection( buffer, 0 );

	if( FAILED( hr ) )
	{
		goto DPINIT_CLEANUP;
	}

	hr = DV_OK;

DPINIT_CLEANUP:

	if( buffer != NULL )
	    delete [] buffer;

	if( directPlayLobby2 != NULL )
	    directPlayLobby2->Release();

	return hr;
}

BOOL FAR PASCAL DPVDX_EnumHandler(
  LPCDPSESSIONDESC2 lpThisSD,
  LPDWORD lpdwTimeOut,
  DWORD dwFlags,
  LPVOID lpContext
)
{
	LPGUID tmpGUID = (LPGUID) lpContext;

	if( lpThisSD != NULL && tmpGUID != NULL )
	{
		*tmpGUID = lpThisSD->guidInstance;
		return FALSE;
	}

	return FALSE;
}


HRESULT DPVDX_DP_FindSessionGUID( 
	LPDIRECTPLAY4A lpDirectPlay,
	// Input
	GUID guidApplicationID, 
	DWORD dwTimeout,
	// Output
	LPGUID lpguidInstance )
{
	HRESULT hr = DV_OK;
	DPSESSIONDESC2 dpSessionDesc;
	DWORD dwTime;

	if( lpguidInstance == NULL )
		return E_POINTER;

	memset( &dpSessionDesc, 0, sizeof( DPSESSIONDESC2 ) );
	dpSessionDesc.dwSize = sizeof( DPSESSIONDESC2 );
	dpSessionDesc.guidApplication = guidApplicationID;
	dpSessionDesc.lpszPassword = NULL;

	dwTime = GetTickCount();
	
	while( (GetTickCount() - dwTime) < dwTimeout )
	{
		lpDirectPlay->EnumSessions( &dpSessionDesc, 0, DPVDX_EnumHandler, &dpSessionDesc.guidInstance, DPENUMSESSIONS_ASYNC );

		if( dpSessionDesc.guidInstance != GUID_NULL )
			break;

		Sleep( 10 );
	}

//	lpDirectPlay->EnumSessions( &dpSessionDesc, 0, DPVDX_EnumHandler, NULL, DPENUMSESSIONS_STOPASYNC );

	if( dpSessionDesc.guidInstance == GUID_NULL )
	{
		return DPERR_NOSESSIONS;
	}

	*lpguidInstance = dpSessionDesc.guidInstance;

	return DV_OK;
}

HRESULT DPVDX_DP_ConnectToSession( 
	// Input
	LPDIRECTPLAY4A lpDirectPlay, 
	GUID guidApplication, 
	GUID guidInstance, 
	LPTSTR lpszPlayerName,
	// Output
	LPDPID lpdpidClientID, 
	LPHANDLE lpReceiveEvent
	)
{
	DPSESSIONDESC2 dpSessionDesc;
	HRESULT hr;
	DPNAME dpnameTmp;
	
	memset( &dpSessionDesc, 0, sizeof( DPSESSIONDESC2 ) );
	dpSessionDesc.dwSize = sizeof( DPSESSIONDESC2 );
	dpSessionDesc.guidApplication = guidApplication;
	dpSessionDesc.guidInstance = guidInstance;
	dpSessionDesc.lpszPassword = NULL;

	hr = lpDirectPlay->Open( &dpSessionDesc, DPOPEN_JOIN  );

	if( FAILED( hr ) )
		return hr;

	dpnameTmp.dwSize = sizeof(DPNAME);
	dpnameTmp.lpszShortNameA = lpszPlayerName;
	dpnameTmp.lpszLongNameA = lpszPlayerName;

	*lpReceiveEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	hr = lpDirectPlay->CreatePlayer( lpdpidClientID, NULL, *lpReceiveEvent, NULL, 0, 0 );

	return hr;
}

HRESULT DPVDX_DP_RegisterApplication( 
	LPSTR lpstrAppName, 
	GUID guidApplication, 
	LPTSTR lpstrExeName,
	LPTSTR lpstrCommandLine, 
	LPTSTR lpstrDescription, 
	DWORD dwFlags
)
{
	HRESULT hr;
	LPDIRECTPLAYLOBBY3A lpdpLobby;
	DPAPPLICATIONDESC dpappDesc;

	if( !lpstrAppName || !lpstrExeName || !lpstrCommandLine || !lpstrDescription )
	{
		return DVERR_GENERIC;
	}

	char szEXEPathname[_MAX_PATH];
	szEXEPathname[0] = 0;
	
	if( !GetModuleFileName(NULL, szEXEPathname, _MAX_PATH) )
	{
		return DVERR_GENERIC;
	}
		
	hr = CoCreateInstance( DPLAY_CLSID_DPLOBBY, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayLobby3A, (void **) &lpdpLobby );

	if( FAILED( hr ) )
    {
    	return hr;
    }

    szEXEPathname[strlen(szEXEPathname)-strlen(lpstrExeName)] = 0;

    dpappDesc.dwSize = sizeof(DPAPPLICATIONDESC);

    dpappDesc.dwFlags = dwFlags;
    dpappDesc.lpszApplicationNameA = lpstrAppName;
    dpappDesc.lpszFilenameA = lpstrExeName;    
    dpappDesc.lpszCommandLineA = lpstrCommandLine;
    dpappDesc.lpszPathA = szEXEPathname;    
    dpappDesc.lpszCurrentDirectoryA = szEXEPathname;    
    dpappDesc.lpszDescriptionA = lpstrDescription;    

    wchar_t lpwstrTmp[_MAX_PATH];

	if( DPVDX_AnsiToWide( lpwstrTmp, lpstrDescription, _MAX_PATH ) != 0 )
	{
	    dpappDesc.lpszDescriptionW = lpwstrTmp;
	}
	else
	{
	    dpappDesc.lpszDescriptionW = NULL;
	}	
    
    dpappDesc.guidApplication = guidApplication;

	hr = lpdpLobby->RegisterApplication( 0, &dpappDesc );

	lpdpLobby->Release();

	return hr;
}

HRESULT DPVDX_DP_UnRegisterApplication( GUID guidApplication )
{
	HRESULT hr;
	LPDIRECTPLAYLOBBY3A lpdpLobby;

	hr = CoCreateInstance( DPLAY_CLSID_DPLOBBY, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayLobby3A, (void **) &lpdpLobby );

	if( FAILED( hr ) )
    {
		return hr;
    }

    hr = lpdpLobby->UnregisterApplication( 0, guidApplication );

	lpdpLobby->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxdplay.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxdplay.h
 *  Content:	Useful dplay utility functions for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 11/02/99	  rodtoll	Bug #116677 - Can't use lobby clients that don't hang around
 * 01/21/00	  rodtoll	Added dplay include
 *
 ***************************************************************************/
#ifndef __DPVXDPLAY_H
#define __DPVXDPLAY_H


// DirectPlay Helper Functions
extern HRESULT DPVDX_DP_ConnectToSession( 
	// Input
	LPDIRECTPLAY4A lpDirectPlay, GUID guidApplication, GUID guidInstanceGUID, LPTSTR lpszPlayerName, 
	// Output
	LPDPID lpdpidClientID, LPHANDLE lpReceiveEvent 
	);

extern HRESULT DPVDX_DP_FindSessionGUID( 
	LPDIRECTPLAY4A lpDirectPlay,
	// Input
	GUID guidApplicationID, 
	DWORD dwTimeout,
	// Output
	LPGUID lpguidInstance );

extern HRESULT DPVDX_DP_Init( 
	LPDIRECTPLAY4A lpDirectPlay, GUID guidServiceProvider, LPTSTR lpstrAddress 
	);

extern HRESULT DPVDX_DP_StartSession( 
	// Input
	LPDIRECTPLAY4A lpDirectPlay, 
	GUID guidApplicationID, 
	DWORD dwFlags, 
	LPTSTR lpszPlayerName,
	LPTSTR lpszSessionName,
	DWORD dwMaxPlayers,
	// Output
	LPDPID lpdpidServerID, 
	LPHANDLE lpReceiveEvent,
	LPGUID lpguidInstanceGUID
	);

extern HRESULT DPVDX_DP_RegisterApplication( 
	LPSTR lpstrAppName, 
	GUID guidApplication, 
	LPTSTR lpstrExeName,
	LPTSTR lpstrCommandLine, 
	LPTSTR lpstrDescription,
	DWORD dwFlags );
	
extern HRESULT DPVDX_DP_UnRegisterApplication( GUID guidApplication );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxdump.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxdump.h
 *  Content:	Useful dump utility functions for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 *
 ***************************************************************************/
#ifndef __DPVXDUMP_H
#define __DPVXDUMP_H

// Structure -> String Conversions
extern void DPVDX_DUMP_GUID( GUID guid, LPSTR lpstrOutput, LPDWORD lpdwLength );
extern void DPVDX_DUMP_WaveFormatEx( LPWAVEFORMATEX lpwfxFormat );
extern void DPVDX_DUMP_SoundDeviceConfig( LPDVSOUNDDEVICECONFIG lpdvSoundConfig);
extern void DPVDX_DUMP_FullCompressionInfo( LPDVCOMPRESSIONINFO lpdvfCompressionInfo, DWORD dwNumElements );
extern void DPVDX_DUMP_ClientConfig( LPDVCLIENTCONFIG lpdvClientConfig );
extern void DPVDX_DUMP_SessionDesc( LPDVSESSIONDESC lpdvSessionDesc );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxlib.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxlib.h
 *  Content:	Useful utility functions for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 *
 ***************************************************************************/
#ifndef __DPVXLIB_H
#define __DPVXLIB_H

#include "dpvxchar.h"
#include "dpvxmisc.h"
#include "dpvxdump.h"
#include "dpvxdplay.h"
#include "dpvxerr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxerr.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxerr.cpp
 *  Content:	Useful Error utility functions lib for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 11/17/99	  rodtoll	Adding new error codes
 * 12/07/99	  rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *					    Added option to error display to have it be silent. 
 * 12/16/99	  rodtoll   Bug #119584 - Error code cleanup - Renamed runsetup error
 * 02/08/2000	rodtoll	Updated for API changes (overdue) 
 *
 ***************************************************************************/

#include "dpvxlibpch.h"


DPVDXLIB_ErrorInfo eiDirectPlayVoiceErrors[] = 
{
	DPVDXLIB_ErrorInfo( DV_OK, _T("DV_OK"), _T("") ),
	DPVDXLIB_ErrorInfo( DVERR_OUTOFMEMORY, _T("DVERR_OUTOFMEMORY"), _T("Out of memory") ),
	DPVDXLIB_ErrorInfo( DVERR_PENDING, _T("DVERR_PENDING"), _T("Operation is pending") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTSUPPORTED, _T("DVERR_UNSUPPORTED"), _T("Operation is not supported") ),
	DPVDXLIB_ErrorInfo( DVERR_NOINTERFACE, _T("DVERR_NOINTERFACE"), _T("Specified interface is not supported, Wrong Version of Dplay?") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDPARAM, _T("DVERR_INVALIDPARAM"), _T("One or more of the specified parameters is not valid") ),
	DPVDXLIB_ErrorInfo( DVERR_GENERIC, _T("DVERR_GENERIC"), _T("An undefined error condition occured.") ),
	DPVDXLIB_ErrorInfo( DV_FULLDUPLEX, _T("DV_FULLDUPLEX"), _T("Your soundcard is capable of full duplex operation." )),
	DPVDXLIB_ErrorInfo( DV_HALFDUPLEX, _T("DV_HALFDUPLEX"), _T("Your soundcard can only run in half duplex mode.") ),
	DPVDXLIB_ErrorInfo( DVERR_BUFFERTOOSMALL, _T("DVERR_BUFFERTOOSMALL"), _T("The supplied buffer is not large enough to contain the requested data.") ),
	DPVDXLIB_ErrorInfo( DVERR_EXCEPTION, _T("DVERR_EXCEPTION"), _T("An exception occured when processing the request.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDFLAGS, _T("DVERR_INVALIDFLAGS"), _T("The flags passed to this method are invalid.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDOBJECT, _T("DVERR_INVALIDOBJECT"), _T("The DirectPlayVoice pointer is invalid.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDPLAYER, _T("DVERR_INVALIDPLAYER"), _T("The player ID is not recognized as a valid ID for this voice session.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDGROUP, _T("DVERR_INVALIDGROUP"), _T("The group ID is not recognized as a valid group ID for the transport session.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDHANDLE, _T("DVERR_INVALIDHANDLE"), _T("The specified handle is not valid.") ),
	DPVDXLIB_ErrorInfo( DVERR_SESSIONLOST, _T("DVERR_SESSIONLOST"), _T("The transport has lost the connection to the session.") ),
	DPVDXLIB_ErrorInfo( DVERR_NOVOICESESSION, _T("DVERR_NOVOICESESSION"), _T("") ),
	DPVDXLIB_ErrorInfo( DVERR_CONNECTIONLOST, _T("DVERR_CONNECTIONLOST"), _T("") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTINITIALIZED, _T("DVERR_NOTINITIALIZED"), _T("Initialize() must be called before using this method.") ),
	DPVDXLIB_ErrorInfo( DVERR_CONNECTED, _T("DVERR_CONNECTED"), _T("The DirectPlayVoice object is connected.") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTCONNECTED, _T("DVERR_NOTCONNECTED"), _T("The DirectPlayVoice object is not connected.") ),
	DPVDXLIB_ErrorInfo( DVERR_CONNECTABORTING, _T("DVERR_CONNECTABORTING"), _T("The connection is being disconnected.") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTALLOWED, _T("DVERR_NOTALLOWED"), _T("The object does not have the permission to perform this operation.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDTARGET, _T("DVERR_INVALIDTARGET"), _T("The specified target is not a valid player ID or group ID for this voice session.") ),
	DPVDXLIB_ErrorInfo( DVERR_TRANSPORTNOTHOST, _T("DVERR_NOTTRANSPORTHOST"), _T("The object is not the host of the voice session.") ),
	DPVDXLIB_ErrorInfo( DVERR_COMPRESSIONNOTSUPPORTED, _T("DVERR_COMPRESSIONNOTSUPPORTED"), _T("The specified compression type is not supported on the local machine.") ),
	DPVDXLIB_ErrorInfo( DVERR_ALREADYPENDING, _T("DVERR_ALREADYPENDING"), _T("An ASYNC call of this type is  already pending.") ),
	DPVDXLIB_ErrorInfo( DVERR_SOUNDINITFAILURE, _T("DVERR_SOUNDINITFAILURE"), _T("A failure was encountered initializing your soundcard.") ),
	DPVDXLIB_ErrorInfo( DVERR_TIMEOUT, _T("DVERR_TIMEOUT"), _T("The operation could not be performed in the specified time.") ),
	DPVDXLIB_ErrorInfo( DVERR_CONNECTABORTED, _T("DVERR_CONNECTABORTED"), _T("The connection was aborted.") ),
	DPVDXLIB_ErrorInfo( DVERR_NO3DSOUND, _T("DVERR_NO3DSOUND"), _T("The local machine does not support 3D sound.") ),
	DPVDXLIB_ErrorInfo( DVERR_ALREADYBUFFERED, _T("DVERR_ALREADYBUFFERED"), _T("There is already a UserBuffer for the specified ID.") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTBUFFERED, _T("DVERR_NOTBUFFERED"), _T("There is no UserBuffer for the specified  ID.") ),
	DPVDXLIB_ErrorInfo( DVERR_HOSTING, _T("DVERR_HOSTING"), _T("The object is the host of the session.") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTHOSTING, _T("DVERR_NOTHOSTING"), _T("The object is not the host of the session.") ),
	DPVDXLIB_ErrorInfo( DVERR_INVALIDDEVICE, _T("DVERR_INVALIDDEVICE"), _T("The specified device is not valid.") ),
	DPVDXLIB_ErrorInfo( DVERR_RECORDSYSTEMERROR, _T("DVERR_RECORDSYSTEMERROR"), _T("An error in the recording system has occured.") ),
	DPVDXLIB_ErrorInfo( DVERR_PLAYBACKSYSTEMERROR, _T("DVERR_PLAYBACKSYSTEMERROR"), _T("An error in the playback system has occured.") ),
	DPVDXLIB_ErrorInfo( DVERR_SENDERROR, _T("DVERR_SENDERROR"), _T("An error occured while sending data.") ),
	DPVDXLIB_ErrorInfo( DVERR_USERCANCEL, _T("DVERR_USERCANCEL"), _T("") ),
	DPVDXLIB_ErrorInfo( DVERR_RUNSETUP,_T( "DVERR_RUNSETUP"), _T("") ),
	DPVDXLIB_ErrorInfo( DVERR_NOTRANSPORT,_T( "DVERR_NOTRANSPORT"), _T("The specified object is not a valid transport") ),	
	DPVDXLIB_ErrorInfo( DVERR_NOCALLBACK,_T( "DVERR_NOCALLBACK"), _T("This operation cannot be performed because no callback function was specified") ),		
	DPVDXLIB_ErrorInfo( DVERR_TRANSPORTNOTINIT,_T( "DVERR_TRANSPORTNOTINIT"), _T("Specified transport is not yet initialized") ),		
	DPVDXLIB_ErrorInfo( DVERR_TRANSPORTNOSESSION,_T( "DVERR_TRANSPORTNOSESSION"), _T("Specified transport is valid but is not connected/hosting") ),		
	DPVDXLIB_ErrorInfo( DVERR_TRANSPORTNOPLAYER,_T( "DVERR_TRANSPORTNOPLAYER"), _T("Specified transport is connected/hosting but no local player exists") ),		
	DPVDXLIB_ErrorInfo( 0xFFFFFFFF, _T(""), _T("") )	
};

DPVDXLIB_ErrorInfo eiDirectPlayErrors[] = 
{
	DPVDXLIB_ErrorInfo( DP_OK , _T("DP_OK"), _T("The request completed successfully.") ),
	DPVDXLIB_ErrorInfo( DPERR_ABORTED , _T("DPERR_ABORTED"), _T("The operation was canceled before it could be completed.") ),
	DPVDXLIB_ErrorInfo( DPERR_ACCESSDENIED , _T("DPERR_ACCESSDENIED"), _T("The session is full, or an incorrect password was supplied.") ),
	DPVDXLIB_ErrorInfo( DPERR_ACTIVEPLAYERS , _T("DPERR_ACTIVEPLAYERS"), _T("The requested operation cannot be performed because there are existing active players.") ),
	DPVDXLIB_ErrorInfo( DPERR_ALREADYINITIALIZED, _T("DPERR_ALREADYINITIALIZED"), _T("This object is already initialized.") ),
	DPVDXLIB_ErrorInfo( DPERR_APPNOTSTARTED, _T("DPERR_APPNOTSTARTED"), _T("The application has not been started yet. ") ),
	DPVDXLIB_ErrorInfo( DPERR_AUTHENTICATIONFAILED, _T("DPERR_AUTHENTICATIONFAILED"), _T("The password or credentials supplied could not be authenticated.") ),
	DPVDXLIB_ErrorInfo( DPERR_BUFFERTOOLARGE, _T("DPERR_BUFFERTOOLARGE"), _T("The data buffer is too large to store.") ),
	DPVDXLIB_ErrorInfo( DPERR_BUFFERTOOSMALL, _T("DPERR_BUFFERTOOSMALL"), _T("The supplied buffer is not large enough to contain the requested data.") ),
	DPVDXLIB_ErrorInfo( DPERR_BUSY, _T("DPERR_BUSY"), _T("A message cannot be sent because the transmission medium is busy.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANCELFAILED, _T("DPERR_CANCELFAILED"), _T("The message could not be canceled, possibly because it is a group message that has already been to sent to one or more members of the group.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANCELLED, _T("DPERR_CANCELLED"), _T("The operation was canceled.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANNOTCREATESERVER, _T("DPERR_CANNOTCREATESERVER"), _T("The server cannot be created for the new session.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTADDPLAYER, _T("DPERR_CANTADDPLAYER"), _T("The player cannot be added to the session.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTCREATEGROUP, _T("DPERR_CANTCREATEGROUP"), _T("A new group cannot be created.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTCREATEPLAYER, _T("DPERR_CANTCREATEPLAYER"), _T("A new player cannot be created.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTCREATEPROCESS, _T("DPERR_CANTCREATEPROCESS"), _T("Cannot start the application.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTCREATESESSION, _T("DPERR_CANTCREATESESSION"), _T("A new session cannot be created.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTLOADCAPI, _T("DPERR_CANTLOADCAPI"), _T("No credentials were supplied and the CryptoAPI package (CAPI) to use for cryptography services cannot be loaded.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTLOADSECURITYPACKAGE, _T("DPERR_CANTLOADSECURITYPACKAGE"), _T("The software security package cannot be loaded.") ),
	DPVDXLIB_ErrorInfo( DPERR_CANTLOADSSPI, _T("DPERR_CANTLOADSSPI"), _T("No credentials were supplied, and the Security Support Provider Interface (SSPI) that will prompt for credentials cannot be loaded.") ),
	DPVDXLIB_ErrorInfo( DPERR_CAPSNOTAVAILABLEYET, _T("DPERR_CAPSNOTAVAILABLEYET"), _T("The capabilities of the DirectPlay object have not been determined yet. This error will occur if the DirectPlay object is implemented on a connectivity solution that requires polling to determine available bandwidth and latency.") ),
	DPVDXLIB_ErrorInfo( DPERR_CONNECTING, _T("DPERR_CONNECTING"), _T("The method is in the process of connecting to the network. The application should keep using the method until it returns DP_OK, indicating successful completion, or until it returns a different error.") ),
	DPVDXLIB_ErrorInfo( DPERR_CONNECTIONLOST, _T("DPERR_CONNECTIONLOST"), _T("The service provider connection was reset while data was being sent.") ),
	DPVDXLIB_ErrorInfo( DPERR_ENCRYPTIONFAILED, _T("DPERR_ENCRYPTIONFAILED"), _T("The requested information could not be digitally encrypted. Encryption is used for message privacy. This error is only relevant in a secure session.") ),
	DPVDXLIB_ErrorInfo( DPERR_ENCRYPTIONNOTSUPPORTED, _T("DPERR_ENCRYPTIONNOTSUPPORTED"), _T("The type of encryption requested in the DPSECURITYDESC structure is not available. This error is only relevant in a secure session.") ),
	DPVDXLIB_ErrorInfo( DPERR_EXCEPTION, _T("DPERR_EXCEPTION"), _T("An exception occurred when processing the request.") ),
	DPVDXLIB_ErrorInfo( DPERR_GENERIC, _T("DPERR_GENERIC"), _T("An undefined error condition occurred.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDFLAGS, _T("DPERR_INVALIDFLAGS"), _T("The flags passed to this method are invalid.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDGROUP, _T("DPERR_INVALIDGROUP"), _T("The group ID is not recognized as a valid group ID for this game session.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDINTERFACE, _T("DPERR_INVALIDINTERFACE"), _T("The interface parameter is invalid.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDOBJECT, _T("DPERR_INVALIDOBJECT"), _T("The DirectPlay object pointer is invalid.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDPARAMS, _T("DPERR_INVALIDPARAMS"), _T("One or more of the parameters passed to the method are invalid.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDPASSWORD,  _T("DPERR_INVALIDPASSWORD"), _T("An invalid password was supplied when attempting to join a session that requires a password.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDPLAYER, _T("DPERR_INVALIDPLAYER"), _T("The player ID is not recognized as a valid player ID for this game session.") ),
	DPVDXLIB_ErrorInfo( DPERR_INVALIDPRIORITY, _T("DPERR_INVALIDPRIORITY"), _T("The specified priority is not within the range of allowed priorities, which is inclusively 0-65535.") ),
	DPVDXLIB_ErrorInfo( DPERR_LOGONDENIED, _T("DPERR_LOGONDENIED"), _T("The session could not be opened because credentials are required, and either no credentials were supplied, or the credentials were invalid.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOCAPS, _T("DPERR_NOCAPS"), _T("The communication link that DirectPlay is attempting to use is not capable of this function.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOCONNECTION, _T("DPERR_NOCONNECTION"), _T("No communication link was established.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOINTERFACE, _T("DPERR_NOINTERFACE"), _T("The interface is not supported.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOMESSAGES, _T("DPERR_NOMESSAGES"), _T("There are no messages in the receive queue.") ),
	DPVDXLIB_ErrorInfo( DPERR_NONAMESERVERFOUND, _T("DPERR_NONAMESERVERFOUND"), _T("No name server (host) could be found or created. A host must exist to create a player.") ),
	DPVDXLIB_ErrorInfo( DPERR_NONEWPLAYERS, _T("DPERR_NONEWPLAYERS"), _T("The session is not accepting any new players.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOPLAYERS, _T("DPERR_NOPLAYERS"), _T("There are no active players in the session.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOSESSIONS, _T("DPERR_NOSESSIONS"), _T("There are no existing sessions for this game.") ),
	DPVDXLIB_ErrorInfo( DPERR_NOTLOBBIED, _T("DPERR_NOTLOBBIED"), _T("Returned by the IDirectPlayLobby3::Connect method if the application was not started by using the IDirectPlayLobby3::RunApplication") ),
	DPVDXLIB_ErrorInfo( DPERR_NOTLOGGEDIN, _T("DPERR_NOTLOGGEDIN"), _T("An action cannot be performed because a player or client application is not logged on. Returned by the IDirectPlay4::Send method when the client application tries to send a secure message without being logged on.") ),
	DPVDXLIB_ErrorInfo( DPERR_OUTOFMEMORY, _T("DPERR_OUTOFMEMORY"), _T("There is insufficient memory to perform the requested operation.") ),
	DPVDXLIB_ErrorInfo( DPERR_PENDING, _T("DPERR_PENDING"), _T("Aync send has been queued") ),
	DPVDXLIB_ErrorInfo( DPERR_PLAYERLOST, _T("DPERR_PLAYERLOST"), _T("A player has lost the connection to the session.") ),
	DPVDXLIB_ErrorInfo( DPERR_SENDTOOBIG, _T("DPERR_SENDTOOBIG"), _T("The message being sent by the IDirectPlay4::Send method is too large. ") ),
	DPVDXLIB_ErrorInfo( DPERR_SESSIONLOST, _T("DPERR_SESSIONLOST"), _T("The connection to the session has been lost. ") ),
	DPVDXLIB_ErrorInfo( DPERR_SIGNFAILED, _T("DPERR_SIGNFAILED"), _T("The requested information could not be digitally signed. Digital signatures ") ),
	DPVDXLIB_ErrorInfo( DPERR_TIMEOUT, _T("DPERR_TIMEOUT"), _T("The operation could not be completed in the specified time.") ),
	DPVDXLIB_ErrorInfo( DPERR_UNAVAILABLE, _T("DPERR_UNAVAILABLE"), _T("The requested function is not available at this time.") ),
	DPVDXLIB_ErrorInfo( DPERR_UNINITIALIZED, _T("DPERR_UNINITIALIZED"), _T("The requested object has not been initialized.") ),
	DPVDXLIB_ErrorInfo( DPERR_UNKNOWNAPPLICATION, _T("DPERR_UNKNOWNAPPLICATION"), _T("An unknown application was specified. ") ),
	DPVDXLIB_ErrorInfo( DPERR_UNKNOWNMESSAGE, _T("DPERR_UNKNOWNMESSAGE"), _T("The message ID isn't valid. Returned from IDirectPlay4::CancelMessage if the ID of the message to be canceled is invalid. ") ), 
	DPVDXLIB_ErrorInfo( DPERR_USERCANCEL , _T("DPERR_USERCANCEL"), _T("Can be returned in two ways. 1) The user canceled the connection process during a call to the IDirectPlay4::Open method. 2) The user clicked Cancel in one of the DirectPlay service provider dialog boxes during a call to IDirectPlay4::EnumSessions. ") ),
	DPVDXLIB_ErrorInfo( 0xFFFFFFFF, _T(""), _T("") )
};

HRESULT DPVDX_ERRDisplay( HRESULT hrError, LPTSTR lpstrCaption, DPVDXLIB_ErrorInfo *lpeiInfo, BOOL fSilent )
{
	if( lpeiInfo == NULL )
		return E_POINTER;

	LPTSTR lpstrTextString;
	DWORD dwLength;

	dwLength = _tcsclen( lpeiInfo->lpstrName ) + _tcsclen( lpeiInfo->lpstrDescription ) + _tcsclen( lpstrCaption );
	dwLength += 4;

	lpstrTextString = new TCHAR[dwLength];

	if( lpstrTextString == NULL )
		return DVERR_OUTOFMEMORY;

	_tcscpy( lpstrTextString, lpstrCaption );
	_tcscat( lpstrTextString, _T("\n\n") );
	_tcscat( lpstrTextString, lpeiInfo->lpstrName );
	_tcscat( lpstrTextString, _T(":") );
	_tcscat( lpstrTextString, lpeiInfo->lpstrDescription );

	if( fSilent )
	{
		OutputDebugString( lpstrTextString );
	}
	else
	{
		MessageBox( NULL, lpstrTextString, _T("Error"), MB_OK );
	}

	delete [] lpstrTextString;

	return DV_OK;
}

HRESULT DPVDX_DVERRDisplay( HRESULT hrError, LPTSTR lpstrCaption, BOOL fSilent )
{
	HRESULT hr;
	DPVDXLIB_ErrorInfo eiErrorInfo(0x00,_T(""),_T(""));

	hr = DPVDX_DVERR2String( hrError, &eiErrorInfo );

	if( FAILED( hr ) )
	{ 
		return hr;
	}
	
	return DPVDX_ERRDisplay( hrError, lpstrCaption, &eiErrorInfo, fSilent );
}

HRESULT DPVDX_DPERRDisplay( HRESULT hrError, LPTSTR lpstrCaption, BOOL fSilent )
{
	HRESULT hr;
	DPVDXLIB_ErrorInfo eiErrorInfo(0x00,_T(""),_T(""));

	hr = DPVDX_DPERR2String( hrError, &eiErrorInfo );

	if( FAILED( hr ) )
	{ 
		return hr;
	}
	
	return DPVDX_ERRDisplay( hrError, lpstrCaption, &eiErrorInfo, fSilent );
}

HRESULT DPVDX_ERR2String( DPVDXLIB_ErrorInfo *lpeiInfo, HRESULT hrError, DPVDXLIB_ErrorInfo *lpeiResult )
{
	DWORD dwIndex = 0;
	BOOL fBufferTooSmall = FALSE;

	while( 1 ) 
	{
		if( lpeiInfo[dwIndex].hrValue == 0xFFFFFFFF )
		{
			return DVERR_GENERIC;
		}
		else if( lpeiInfo[dwIndex].hrValue == hrError )
		{
			memcpy( lpeiResult, &lpeiInfo[dwIndex], sizeof( DPVDXLIB_ErrorInfo ) );
			
			return DV_OK;
		}

		dwIndex++;
	}

	return DV_OK;
}

// Error Functions
HRESULT DPVDX_DVERR2String( HRESULT hrError, DPVDXLIB_ErrorInfo *lpeiResult )
{
	return DPVDX_ERR2String( eiDirectPlayVoiceErrors, hrError, lpeiResult);
}

HRESULT DPVDX_DPERR2String( HRESULT hrError, DPVDXLIB_ErrorInfo *lpeiResult )
{
	return DPVDX_ERR2String( eiDirectPlayErrors, hrError, lpeiResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxerr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxerr.h
 *  Content:	Useful Error utility functions for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 12/07/99	  rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *					    Added option to error display to have it be silent.
 *
 ***************************************************************************/
#ifndef __DPVXERR_H
#define __DPVXERR_H

#include "dvoice.h"

// Error Functions

struct DPVDXLIB_ErrorInfo
{
	DPVDXLIB_ErrorInfo( HRESULT hr, LPSTR name, LPSTR desc ):hrValue(hr), lpstrName(name), lpstrDescription(desc) {};
	HRESULT hrValue;
	const LPTSTR lpstrName;
	const LPTSTR lpstrDescription;
};

extern HRESULT DPVDX_DVERR2String( HRESULT hrError, DPVDXLIB_ErrorInfo *lpeiResult );
extern HRESULT DPVDX_DPERR2String( HRESULT hrError, DPVDXLIB_ErrorInfo *lpeiResult );
extern HRESULT DPVDX_DVERRDisplay( HRESULT hrError, LPTSTR lpstrCaption, BOOL fSilent );
extern HRESULT DPVDX_DPERRDisplay( HRESULT hrError, LPTSTR lpstrCaption, BOOL fSilent );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxdump.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxdump.cpp
 *  Content:	Useful dump utility functions lib for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 10/28/99   pnewson	bug#114176 - updates to DVSOUNDDEVICECONFIG struct
 * 11/17/99	  rodtoll	Fix: Bug #116440 - Remove unused flags 
 * 02/08/2000	rodtoll	Updated for API changes (overdue)
 * 08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *
 ***************************************************************************/

#include "dpvxlibpch.h"


// Structure -> String Conversions
void DPVDX_DUMP_GUID( GUID guid )
{
    /*
    _tprintf(_T("{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"),guid.Data1, guid.Data2, guid.Data3, 
               guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
               guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] );
               */
}

void DPVDX_DUMP_WaveFormatEx( LPWAVEFORMATEX lpwfxFormat )
{
    /*
	_tprintf(_T("> WAVEFORMATEX Dump Addr = 0x%lx\n"),lpwfxFormat );
	_tprintf(_T("> > wFormatTag = %d\n"),lpwfxFormat->wFormatTag );
	_tprintf(_T("> > nSamplesPerSec = %d\n"),lpwfxFormat->nSamplesPerSec );
	_tprintf(_T("> > nChannels = %d\n"),lpwfxFormat->nChannels );
	_tprintf(_T("> > wBitsPerSample = %d\n"),lpwfxFormat->wBitsPerSample );
	_tprintf(_T("> > nAvgBytesPerSec = %d\n"),lpwfxFormat->nAvgBytesPerSec );
	_tprintf(_T("> > nBlockAlign = %d\n"),lpwfxFormat->nBlockAlign );
	_tprintf(_T("> > cbSize = %d\n"),lpwfxFormat->cbSize );
	*/
}

void DPVDX_DUMP_SoundDeviceConfig( LPDVSOUNDDEVICECONFIG lpdvSoundConfig)
{
    /*
	DWORD dwIndex;

	_tprintf(_T("DVSOUNDDEVICECONFIG Dump Addr=0x%lx\n"),lpdvSoundConfig );
	_tprintf(_T("dwSize = %d\n"),lpdvSoundConfig->dwSize );
	_tprintf(_T("dwFlags = 0x%x\n"),lpdvSoundConfig->dwFlags );
	_tprintf(_T("          %s%s\n"),
							(lpdvSoundConfig->dwFlags & DVSOUNDCONFIG_AUTOSELECT) ? _T("DVSESSION_SERVERCONTROLTARGET,") : _T(""),
							(lpdvSoundConfig->dwFlags & DVSOUNDCONFIG_HALFDUPLEX) ? _T("DVSESSION_HALFDUPLEX,") : _T("") );

	_tprintf(_T("guidPlaybackDevice =\n") );
	DPVDX_DUMP_GUID( lpdvSoundConfig->guidPlaybackDevice );

	_tprintf(_T("guidCaptureDevice =\n") );
	DPVDX_DUMP_GUID( lpdvSoundConfig->guidCaptureDevice );

// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
#ifdef WIN95
    _tprintf(_T("lpdsPlaybackDevice = 0x%x\n"), lpdvSoundConfig->lpdsPlaybackDevice ) ;
	_tprintf(_T("lpdsCaptureDevice = 0x%x\n"), lpdvSoundConfig->lpdsCaptureDevice ) ;
#else
    _tprintf(_T("lpdsPlaybackDevice = 0x%p\n"), lpdvSoundConfig->lpdsPlaybackDevice ) ;
	_tprintf(_T("lpdsCaptureDevice = 0x%p\n"), lpdvSoundConfig->lpdsCaptureDevice ) ;
#endif
	
	*/
}

void DPVDX_DUMP_FullCompressionInfo( LPDVCOMPRESSIONINFO lpdvfCompressionInfo, DWORD dwNumElements)
{
    /*
	DWORD dwIndex;
	LPSTR lpszTmp;

	_tprintf(_T("DVFULLCOMPRESSIONINFO Array Dump Addr=0x%lx\n"),lpdvfCompressionInfo );

	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		_tprintf(_T("dwSize = %d\n"),lpdvfCompressionInfo[dwIndex].dwSize );		
		_tprintf(_T("dwFlags = 0x%x\n"),lpdvfCompressionInfo[dwIndex].dwFlags );	

		if( FAILED( DPVDX_AllocAndConvertToANSI( &lpszTmp, lpdvfCompressionInfo[dwIndex].lpszDescription ) ) )
		{
			_tprintf(_T("lpszDescription = <Unable to Convert>") );				
		}
		else
		{
			_tprintf(_T("lpszDescription = %s\n"),lpszTmp );		
			delete [] lpszTmp;
		}

		if( FAILED( DPVDX_AllocAndConvertToANSI( &lpszTmp, lpdvfCompressionInfo[dwIndex].lpszName ) ) )
		{
			_tprintf(_T("lpszName = <Unable to Convert>") );				
		}
		else
		{
			_tprintf(_T("lpszName = %s\n"),lpszTmp );		
			delete [] lpszTmp;
		}		
		
		_tprintf(_T("guidType = ") );
		DPVDX_DUMP_GUID( lpdvfCompressionInfo[dwIndex].guidType );
		_tprintf(_T("\n") );
		_tprintf(_T("dwMaxBitsPerSecond	= %d\n"),lpdvfCompressionInfo[dwIndex].dwMaxBitsPerSecond );		
	}
	*/
}

void DPVDX_DUMP_ClientConfig( LPDVCLIENTCONFIG lpdvClientConfig )
{
    /*
	_tprintf(_T("DVCLIENTCONFIG Dump Addr = 0x%lx\n"),lpdvClientConfig );
	_tprintf(_T("> dwSize = %d\n"),lpdvClientConfig->dwSize );
	_tprintf(_T("> dwFlags = 0x%x"),lpdvClientConfig->dwFlags );
	_tprintf(_T("%s%s%s%s%s%s)\n"),
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE) ? _T("DVCLIENTCONFIG_RECORDMUTE,") : _T(""),
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_PLAYBACKMUTE) ? _T("DVCLIENTCONFIG_PLAYBACKMUTE,") : _T(""),
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED) ? _T("DVCLIENTCONFIG_AUTOVOICEACTIVATED,") : _T(""),
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED) ? _T("DVCLIENTCONFIG_MANUALVOICEACTIVATED,") : _T(""),
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_MUTEGLOBAL) ? _T("DVCLIENTCONFIG_MUTEGLOBAL,") : _T(""),
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME) ? _T("DVCLIENTCONFIG_AUTORECORDVOLUME") : _T("") );

	if( lpdvClientConfig->dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		_tprintf(_T("> dwBufferAggresiveness = DEFAULT\n") );
	}
	else
	{
		_tprintf(_T("> dwBufferAggresiveness = %d\n"),lpdvClientConfig->dwBufferAggressiveness );
	}

	if( lpdvClientConfig->dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		_tprintf(_T("> dwBufferQuality = DEFAULT\n") );
	}
	else
	{
		_tprintf(_T("> dwBufferQuality = %d\n"),lpdvClientConfig->dwBufferQuality );
	}

	if( lpdvClientConfig->dwThreshold == DVTHRESHOLD_DEFAULT )
	{
		_tprintf(_T("> dwSensitivity = DEFAULT\n") );
	}
	else 
	{
		_tprintf(_T("> dwSensitivity = %d\n"),lpdvClientConfig->dwThreshold );
	}

	_tprintf(_T("> dwNotifyPeriod = %d\n"),lpdvClientConfig->dwNotifyPeriod );
	_tprintf(_T("> lPlaybackVolume = %li\n"),lpdvClientConfig->lPlaybackVolume );
	_tprintf(_T("> lRecordVolume = %li\n"),lpdvClientConfig->lRecordVolume );
*/
}

void DPVDX_DUMP_SessionDesc( LPDVSESSIONDESC lpdvSessionDesc )
{
    /*
	_tprintf(_T("DVSESSIONDESC Dump Addr=0x%lx\n"),lpdvSessionDesc );
	_tprintf(_T("> dwSize = %d\n"),lpdvSessionDesc->dwSize );
	_tprintf(_T("> dwFlags = 0x%x "),lpdvSessionDesc->dwFlags );
	_tprintf(_T("%s\n"), (lpdvSessionDesc->dwFlags & DVSESSION_SERVERCONTROLTARGET) ? _T("DVSESSION_SERVERCONTROLTARGET,") : _T("") );

	switch( lpdvSessionDesc->dwSessionType )
	{
	case DVSESSIONTYPE_PEER:
		_tprintf(_T("> dwSessionType = DVSESSIONTYPE_PEER\n") );
		break;
	case DVSESSIONTYPE_MIXING:
		_tprintf(_T("> dwSessionType = DVSESSIONTYPE_MIXING\n") );
		break;
	case DVSESSIONTYPE_FORWARDING: 
		_tprintf(_T("> dwSessionType = DVSESSIONTYPE_FORWARDING\n") );
		break;
	case DVSESSIONTYPE_ECHO: 
		_tprintf(_T("> dwSessionType = DVSESSIONTYPE_ECHO\n") );
		break;
	default:
		_tprintf(_T("> dwSessionType = Unknown\n") );
		break;
	}

	if( lpdvSessionDesc->dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		_tprintf(_T("> dwBufferAggresiveness = DEFAULT\n") );
	}
	else
	{
		_tprintf(_T("> dwBufferAggresiveness = %d\n"),lpdvSessionDesc->dwBufferAggressiveness );
	}

	if( lpdvSessionDesc->dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		_tprintf(_T("> dwBufferQuality = DEFAULT\n") );
	}
	else
	{
		_tprintf(_T("> dwBufferQuality = %d\n"),lpdvSessionDesc->dwBufferQuality );
	}

	_tprintf(_T("> guidCT = \n") );

    DPVDX_DUMP_GUID( lpdvSessionDesc->guidCT );

    _tprintf(_T("\n") );
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxlibpch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpvxlibpch.h
 *  Content:    DirectPlayVoice DPVXLIB master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DPVXLIBPCH_H__
#define __DPVXLIBPCH_H__

// 
// Public includes
//
#include <windows.h>
#include <tchar.h>

// 
// DirectPlay public includes
//
#include "dvoice.h"

// 
// DirectPlay4 public includes
//
#include "dplay.h"
#include "dplobby.h"

// 
// Voice includes
//
#include "dpvxchar.h"
#include "dpvxdplay.h"
#include "dpvxdump.h"
#include "dpvxerr.h"
#include "dpvxmisc.h"

#include "..\..\..\bldcfg\dpvcfg.h"

#endif // __DPVXLIBPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxmisc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxmisc.cpp
 *  Content:	Useful misc utility functions lib for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 * 10/15/99	    rodtoll	Plugged memory leaks
 * 01/24/2000   pnewson Prefix detected bug fix
 * 01/28/2000	rodtoll	Prefix detected bug fix
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 06/28/2000	rodtoll	Prefix Bug #38033
 * 08/31/2000	rodtoll	Prefix Bug #171842
 *
 ***************************************************************************/

#include "dpvxlibpch.h"


HRESULT DPVDX_GetCompressionName( GUID guidCT, LPTSTR lpstrName, LPDWORD lpdwNameLength )
{
	BOOL fCoCalled = FALSE;
	LPDIRECTPLAYVOICECLIENT lpdpvClient = NULL;
	LPBYTE lpBuffer = NULL;
	DWORD dwSize = 0;
	DWORD dwNumElements = 0;
	LPDVCOMPRESSIONINFO lpdvCompressionInfo;
	LPSTR lpszName;	
	HRESULT hr;
	DWORD dwIndex;

	if( lpdwNameLength == NULL )
		return DVERR_INVALIDPARAM;

	hr = CoCreateInstance( DPVOICE_CLSID_DPVOICE, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayVoiceClient, (void **) &lpdpvClient );

	if( hr == 0x800401f0 )
	{
		fCoCalled = TRUE;

		hr = CoInitialize(NULL);

		if( FAILED( hr ) )
		{
			goto ERROR_CLEANUP;
		}

		hr = CoCreateInstance( DPVOICE_CLSID_DPVOICE, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayVoiceClient, (void **) &lpdpvClient );		
	}

	if( FAILED( hr ) )
	{
		goto ERROR_CLEANUP;
	}

	hr = lpdpvClient->GetCompressionTypes( lpBuffer, &dwSize, &dwNumElements, 0 );

	if( hr != DVERR_BUFFERTOOSMALL )
	{
		goto ERROR_CLEANUP;	
	}

	lpBuffer = new BYTE[dwSize];

	if( lpBuffer == NULL )
	{
		hr = DVERR_OUTOFMEMORY;
		goto ERROR_CLEANUP;
	}

	hr = lpdpvClient->GetCompressionTypes( lpBuffer, &dwSize, &dwNumElements, 0 );

	if( FAILED( hr ) )
	{
		goto ERROR_CLEANUP;	
	}

	lpdvCompressionInfo = (LPDVCOMPRESSIONINFO) lpBuffer;

	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		if( lpdvCompressionInfo[dwIndex].guidType == guidCT )
		{
			if (lpdvCompressionInfo[dwIndex].lpszName == NULL)
			{
				hr = DVERR_GENERIC;
				goto ERROR_CLEANUP;
			}
#ifdef _UNICODE 		
			if( wcslen( lpdvCompressionInfo[dwIndex].lpszName )+1 > *lpdwNameLength )
			{
				*lpdwNameLength = wcslen( lpdvCompressionInfo[dwIndex].lpszName )+1;
				goto ERROR_CLEANUP;
			}
			else
			{
				wcscpy( lpstrName, lpdvCompressionInfo[dwIndex].lpszName );
				goto ERROR_CLEANUP;
			}
#else
			hr = DPVDX_AllocAndConvertToANSI( &lpszName, lpdvCompressionInfo[dwIndex].lpszName );

			if( FAILED( hr ) )
				return hr;

			if( lpszName == NULL )
			{
				if( lpdwNameLength > 0 )
				{
					_tcscpy( lpszName, _T("") );
					hr = DV_OK;
				}
				else
				{
					hr = DVERR_BUFFERTOOSMALL;
				}

				*lpdwNameLength = 1;
			}
			else if( *lpdwNameLength < (_tcsclen( lpszName )+1) || lpstrName == NULL )
			{
				*lpdwNameLength = _tcsclen( lpszName ) + 1;
				hr = DVERR_BUFFERTOOSMALL;
				delete [] lpszName;
				goto ERROR_CLEANUP;
			}
			else
			{
				_tcscpy( lpstrName, lpszName );
				delete [] lpszName;
				goto ERROR_CLEANUP;
			}
#endif
		}
	}

	delete [] lpBuffer;

	hr = DVERR_COMPRESSIONNOTSUPPORTED;

ERROR_CLEANUP:

	if( lpBuffer != NULL )
		delete [] lpBuffer;

	if( lpdpvClient != NULL )
		lpdpvClient->Release();

	if( fCoCalled )
		CoUninitialize();

	return hr;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\conndlg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        conndlg.cpp
 *  Content:	 Connect Dialog Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/

#include "dxvhelppch.h"


TCHAR g_lpszAddress[_MAX_PATH] = _T("");

INT_PTR CALLBACK ConnectDialog_WinProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:

			_tcscpy( g_lpszAddress, _T("localhost") );
			
			SetWindowText( GetDlgItem( hDlg, IDC_EDIT_ADDRESS), g_lpszAddress );

			return TRUE;

		case WM_COMMAND:
		
			if (LOWORD(wParam) == IDOK )
			{
				GetWindowText( GetDlgItem( hDlg, IDC_EDIT_ADDRESS), g_lpszAddress, _MAX_PATH );
			}

			if( LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}
			break;
	}
    return FALSE;
}

BOOL GetConnectSettings( HINSTANCE hInst, HWND hOwner, LPTSTR lpszAddress )
{
	_tcscpy( g_lpszAddress, lpszAddress );

	if( DialogBox( hInst, MAKEINTRESOURCE( IDD_DIALOG_CONNECT ), hOwner, ConnectDialog_WinProc ) == IDOK )
	{
		_tcscpy( lpszAddress, g_lpszAddress );
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\conndlg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        conndlg.h
 *  Content:	 Connect Dialog Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/


#ifndef __CONNDLG_H

BOOL GetConnectSettings( HINSTANCE hInst, HWND hOwner, LPTSTR lpszAddress );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dpvxlib\dpvxmisc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpvxmisc.h
 *  Content:	Useful misc utility functions for sample apps
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 10/07/99	  rodtoll	Created It
 *
 ***************************************************************************/
#ifndef __DPVXMISC_H
#define __DPVXMISC_H

// Misc.
extern HRESULT DPVDX_GetCompressionName( GUID guidCT, LPTSTR lpstrName, LPDWORD lpdwNameLength );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\dxvhelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        dxvhelp.h
 *  Content:	 Project wide structures
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *				rodtoll	Added member to track manager thread handle
 *  11/02/99	rodtoll	Bug #116677 - Can't use lobby clients that don't hang around
 *  11/12/99	rodtoll	Added support for the new waveIN/waveOut flags and the 
 *					    echo suppression flag. 
 *  12/01/99	rodtoll	Added members to allow control of microphone autoselection and
 *                      to allow user to select the recording/playback devices.
 *  12/07/99	rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *				rodtoll	Bug #122979 Make invisible to end user
 *	12/08/99	rodtoll Bug #121054 Add support for new DX71. interfaces.
 *
 ***************************************************************************/
#ifndef __DXVHELP_H


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// Parameters for the session
//
typedef struct 
{
	BOOL	fRegister;
	BOOL	fUnRegister;
	BOOL	fHost;
	BOOL	fLobbyLaunched;
	BOOL	fSilent;
	DWORD	dwSessionType;
	GUID	guidCT;
	TCHAR	lpszConnectAddress[_MAX_PATH];
	BOOL	fAGC;
	BOOL	fAdvancedUI;
	BOOL	fWaitForSettings;
	LONG 	lRecordVolume;
	BOOL	fKill;
	BOOL	fIgnoreLobbyDestroy;
	BOOL	fAllowWaveOut;
	BOOL	fForceWaveOut;
	BOOL	fAllowWaveIn;
	BOOL	fForceWaveIn;
	BOOL	fEchoSuppression;
	BOOL	fAutoSelectMic;
	GUID	guidPlaybackDevice;
	GUID	guidRecordDevice;
	BOOL    fSelectCards;
	BOOL	fStrictFocus;
	BOOL	fDisableFocus;
} DXVHELP_PARAMETERS, *PDXVHELP_PARAMETERS;

// Runtime information, handles etc.
//
typedef struct 
{
	HWND		hMainDialog;
	GUID		guidInstance;
	DPID		dpidLocalPlayer;
	HANDLE		hReceiveEvent;
	HANDLE		hLobbyEvent;
	HANDLE		hThreadDone;
	HANDLE		hShutdown;
	HANDLE		hGo;
	HANDLE		hManagerThread;
	DWORD		dwNumClients;
	HWND		hMainWnd;
	HINSTANCE	hInst;
	int			lVolumeHeight;
	LPDIRECTPLAYVOICECLIENT lpdvClient;	
	LPDIRECTPLAYVOICESERVER lpdvServer;
	LPDIRECTPLAYLOBBY3A lpdpLobby;
	LPDIRECTPLAY4A lpdpDirectPlay;
	DXVHELP_PARAMETERS dxvParameters;
} DXVHELP_RTINFO, *PDXVHELP_RTINFO;

// {D08922EF-59C1-48c8-90DA-E6BC275D5C8D}
DEFINE_GUID(DPVHELP_PRIVATE_APPID, 0xd08922ef, 0x59c1, 0x48c8, 0x90, 0xda, 0xe6, 0xbc, 0x27, 0x5d, 0x5c, 0x8d);

// {3B296900-A2E0-4d54-AEA0-BAEE895E43B3}
DEFINE_GUID(DPVHELP_PUBLIC_APPID, 
0x3b296900, 0xa2e0, 0x4d54, 0xae, 0xa0, 0xba, 0xee, 0x89, 0x5e, 0x43, 0xb3);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\dxvhelppch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxvhelppch.h
 *  Content:    DirectPlayVoice DXVHELP master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DXVHELPPCH_H__
#define __DXVHELPPCH_H__

#define _WIN32_DCOM

// 
// Public includes
//
#include <windows.h>
#include <tchar.h>
#include <commctrl.h>
#include <stdio.h>
#include <objbase.h>

// 
// DirectPlay public includes
//
#include "dvoice.h"

// 
// DirectPlay4 public includes
//
#include "dplobby.h"

// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"

// 
// DirectVoice private includes
//
#include "dpvxlib.h"

// 
// Voice includes
//
#include "dxvhelp.h"
#include "conndlg.h"
#include "misc.h"
#include "voice.h"
#include "maindlg.h"
#include "snddlg.h"
#include "hostdlg.h"
#include "resource.h"

#include "..\..\..\bldcfg\dpvcfg.h"

#endif // __DXVHELPPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\hostdlg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        hostdlg.cpp
 *  Content:	 Host Dialog Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *				rodtoll	Plugged memory leak in enumcompressiontypes
 *  12/07/99	rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  06/28/2000 rodtoll	Prefix Bug #38033, 
 *  08/31/2000	rodtoll	Prefix Bug #171843 - Out of Memory Handling Error 
 *
 ***************************************************************************/

#include "dxvhelppch.h"


GUID g_guidCT;
DWORD g_dwSessionType;

#undef DPF_MODNAME
#define DPF_MODNAME "HostDialog_FillCompressionPulldown"

void HostDialog_FillCompressionPulldown( HWND hDlg )
{
	HWND hPulldown = GetDlgItem( hDlg, IDC_COMBO_CT );

	LPDVCOMPRESSIONINFO lpdvCompressionInfo;
	LPBYTE lpBuffer = NULL;
	DWORD dwSize = 0;
	DWORD dwNumElements = 0;
	HRESULT hr;
	LPDIRECTPLAYVOICECLIENT lpdpvClient = NULL;
    LRESULT lResultIndex, lFirst;
	LPGUID lpGuid = NULL;

	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	if( FAILED( hr ) )
	{
		DPVDX_DVERRDisplay( hr, "Failure initializing COM", FALSE );
		return;
	}

	hr = CoCreateInstance( DPVOICE_CLSID_DPVOICE, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayVoiceClient, (void **) &lpdpvClient );

	if( FAILED( hr ) )
	{
		DPVDX_DVERRDisplay( hr, "Unable to create client to get ct info", FALSE );
		return;
	}

	hr = lpdpvClient->GetCompressionTypes( lpBuffer, &dwSize, &dwNumElements, 0 );

	if( hr != DVERR_BUFFERTOOSMALL )
	{
		DPVDX_DVERRDisplay( hr, "Unable to to get ct info", FALSE );	
		lpdpvClient->Release();
		return;
	}

	lpBuffer = new BYTE[dwSize];

	if( !lpBuffer )
	{
		DPVDX_DVERRDisplay( DVERR_OUTOFMEMORY, "Failed allocating memory", FALSE );			
		lpdpvClient->Release();
		return;
	}
	

	hr = lpdpvClient->GetCompressionTypes( lpBuffer, &dwSize, &dwNumElements, 0 );

	if( FAILED( hr ) )
	{
		DPVDX_DVERRDisplay( hr, "Unable to to get ct info", FALSE );	
		lpdpvClient->Release();
		return;
	}

	lpdvCompressionInfo = (LPDVCOMPRESSIONINFO) lpBuffer;

	LPSTR lpszName;

	for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		if( FAILED( DPVDX_AllocAndConvertToANSI( &lpszName, lpdvCompressionInfo[dwIndex].lpszName ) ) )
		{
			lResultIndex = SendMessage( hPulldown, CB_ADDSTRING, 0, (LPARAM) "Unable to convert" );		
		}
		else
		{
			lResultIndex = SendMessage( hPulldown, CB_ADDSTRING, 0, (LPARAM) lpszName );
			delete [] lpszName;
		}

		if( dwIndex == 0 )
			lFirst = lResultIndex;

		lpGuid = new GUID;

		if( lpGuid == NULL )
		{
			DNASSERT( FALSE );
			DPVDX_DVERRDisplay( DVERR_OUTOFMEMORY, "Error allocating memory", FALSE );
			continue;
		}

		(*lpGuid) = lpdvCompressionInfo[dwIndex].guidType;

		SendMessage( hPulldown, CB_SETITEMDATA, lResultIndex, (LPARAM) lpGuid );
	}

	delete [] lpBuffer;

	// lFirst isn't initialized if we didn't enter the 'for' loop above
	if (dwIndex > 0)
	{
		SendMessage( hPulldown, CB_SETCURSEL, 0, lFirst );
	}

	lpdpvClient->Release();

	CoUninitialize();
	
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HostDialog_FillSessionTypePulldown"

void HostDialog_FillSessionTypePulldown( HWND hDlg )
{
	HWND hPulldown = GetDlgItem( hDlg, IDC_COMBO_TYPE );

	LRESULT lIndex, lFirst;

	lFirst = SendMessage( hPulldown, CB_ADDSTRING, 0, (DWORD_PTR) "Peer To Peer" );
	SendMessage( hPulldown, CB_SETITEMDATA, lFirst, DVSESSIONTYPE_PEER );
		
	lIndex = SendMessage( hPulldown, CB_ADDSTRING, 0, (DWORD_PTR) "Mixing" );
	SendMessage( hPulldown, CB_SETITEMDATA, lIndex, DVSESSIONTYPE_MIXING );
	
	lIndex = SendMessage( hPulldown, CB_ADDSTRING, 0, (DWORD_PTR) "Multicast" );
	SendMessage( hPulldown, CB_SETITEMDATA, lIndex, DVSESSIONTYPE_FORWARDING );
	
	lIndex = SendMessage( hPulldown, CB_ADDSTRING, 0, (DWORD_PTR) "Echo" );
	SendMessage( hPulldown, CB_SETITEMDATA, lIndex, DVSESSIONTYPE_ECHO );

	SendMessage( hPulldown, CB_SETCURSEL, 0, lFirst );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CleanupCompressionGUIDs"
void CleanupCompressionGUIDs( HWND hDlg )
{
	LRESULT lCurSelection;
	LPGUID lpguidCT;

	lCurSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_CT ), CB_GETCOUNT, 0, 0 );

	if( lCurSelection != CB_ERR )
	{
		for( LRESULT lIndex = 0; lIndex < lCurSelection; lIndex++ )
		{
			lpguidCT = (LPGUID) SendMessage( GetDlgItem( hDlg, IDC_COMBO_CT ), CB_GETITEMDATA, lIndex, 0 );			

			if( lpguidCT )
				delete lpguidCT;
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "HostDialog_HandleCommandCancel"

BOOL HostDialog_HandleCommandCancel( HWND hDlg  )
{
	CleanupCompressionGUIDs( hDlg );

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "HostDialog_HandleCommandOK"

BOOL HostDialog_HandleCommandOK( HWND hDlg  )
{
	LRESULT lCurSelection;
	LPGUID lpguidCT;
	
	PDXVHELP_RTINFO prtInfo = (PDXVHELP_RTINFO) GetWindowLongPtr( hDlg, DWLP_USER );
	
	lCurSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_CT ), CB_GETCURSEL, 0, 0 );

	if( lCurSelection == CB_ERR )
	{
		MessageBox( NULL, "Select a compression type!", "Error", MB_OK );
		return FALSE;
	}

	lpguidCT = (LPGUID) SendMessage( GetDlgItem( hDlg, IDC_COMBO_CT ), CB_GETITEMDATA, lCurSelection, 0 );

	if( lpguidCT != NULL )
	{
		g_guidCT = (*lpguidCT);
	}

	CleanupCompressionGUIDs( hDlg );

	lCurSelection = SendMessage( GetDlgItem( hDlg, IDC_COMBO_TYPE ), CB_GETCURSEL, 0, 0 );

	if( lCurSelection == CB_ERR )
	{
		MessageBox( NULL,  "Select a session type!", "Error", MB_OK );
		return FALSE;				
	}

	g_dwSessionType = (DWORD) SendMessage( GetDlgItem( hDlg, IDC_COMBO_TYPE ), CB_GETITEMDATA, lCurSelection, 0 );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HostDialog_WinProc"

INT_PTR CALLBACK HostDialog_WinProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:

			HostDialog_FillCompressionPulldown( hDlg );
			HostDialog_FillSessionTypePulldown( hDlg );

			return TRUE;

		case WM_COMMAND:
		
			if (LOWORD(wParam) == IDOK )
			{
				if( !HostDialog_HandleCommandOK( hDlg ) )
				{
					return FALSE;
				}
			}
			else if( LOWORD(wParam) == IDCANCEL )
			{
				HostDialog_HandleCommandCancel( hDlg );
			}
			
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}

			break;
	}
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetHostSettings"

BOOL GetHostSettings( HINSTANCE hInst, HWND hOwner, LPGUID pguidCT, PDWORD pdwSessionType )
{
	g_dwSessionType = *pdwSessionType;
	g_guidCT = *pguidCT;

	if( DialogBox( hInst, MAKEINTRESOURCE( IDD_DIALOG_HOST ), hOwner, HostDialog_WinProc ) == IDOK )
	{
		*pdwSessionType = g_dwSessionType;
		*pguidCT = g_guidCT;
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\dxvhelp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        dvretro.c
 *  Content:	 	Retrofit functions
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  08/12/99	rodtoll	created it
 *	08/19/99	rodtoll	Updated lobby launching to support retrofit
 *  08/20/99	rodtoll	Modified to respond to shutdown request and
 *						do proper lobby launch when in client mode.
 *	08/25/99	rodtoll	Updated to use new GUID based compression selection
 *  09/14/99	rodtoll	Updated for new Init call and SoundDeviceInfo usage.
 *  09/27(8)/99 rodtoll	Updated with new interface
 *  09/28/99	rodtoll	Updated for structure changes.
 *  09/29/99	rodtoll	Updated for async enum, fixed bug with lobby launch
 *  10/15/99	rodtoll	Massive code cleanup.  Split into multiple files
 *				rodtoll	Minor fix, event was being released twice
 *  10/20/99	rodtoll	Fixed name info for helper app
 *  11/02/99	rodtoll	Bug #116677 - Can't use lobby clients that don't hang around
 *  11/04/99	pnewson Bug #115297 - launch device test if required
 *  11/12/99	rodtoll	Added support for the new waveIN/waveOut flags and the 
 *					    echo suppression flag. (Can specify them on command-line)
 *  12/01/99	rodtoll	Bug #115783 - Regardless of device specified always adjusts volume
 *						for default.  Modified dpvhelp to allow user to select play/record
 *						devices by using /SS switch.
 *  12/07/99	rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *				rodtoll	Bug #122979 Make invisible to end user
 *						Now app must be run with /A to show an interface.
 *						Also, unless /A or /L or /W are specified, the app will exit immediately.
 *						Command-line help removed.
 *						Auto-registration code removed for public version of app.
 *  02/15/2000	rodtoll	Bug #132715 Voice is not working after rejoining the session
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  06/28/2000	rodtoll	Prefix Bug #38033
 *
 ***************************************************************************/

#include "dxvhelppch.h"


#define MAX_LOADSTRING 100

#define DPVHELP_WINDOWTITLE				_T("DirectPlay Voice Chat")
#define DPVHELP_WINDOWCLASS				_T("DPVHELP")

#define DPVHELP_PRIVATE_APPNAME					_T("DirectPlay Voice Chat (Retrofit)")
#define DPVHELP_PRIVATE_DESC					_T("DirectPlay Voice Chat (Retrofit)")
#define DPVHELP_PRIVATE_EXENAME					_T("dpvhelp.exe")
#define DPVHELP_PRIVATE_COMMANDLINE				_T("/L /S /SC03")
#define DPVHELP_PRIVATE_FLAGS					0x80000002

#undef DPF_MODNAME
#define DPF_MODNAME "InitializeRunTime"

void InitializeRunTime( PDXVHELP_RTINFO prtInfo )
{
	prtInfo->hReceiveEvent = NULL;
	prtInfo->hThreadDone = CreateEvent( NULL, TRUE, FALSE, NULL );
	prtInfo->hShutdown = CreateEvent( NULL, TRUE, FALSE, NULL );
	prtInfo->hGo = CreateEvent( NULL, FALSE, FALSE, NULL );
	prtInfo->hMainDialog = NULL;
	prtInfo->dpidLocalPlayer = 0xFFFFFFFF;
	prtInfo->lVolumeHeight = 0;
	prtInfo->hInst = NULL;
	prtInfo->hMainWnd = NULL;
	prtInfo->dwNumClients = 0;
	prtInfo->lpdpLobby = NULL;
	prtInfo->lpdvClient = NULL;
	prtInfo->lpdvServer = NULL;
	prtInfo->lpdpDirectPlay = NULL;
	prtInfo->hLobbyEvent = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FreeRunTime"

void FreeRunTime( PDXVHELP_RTINFO prtInfo )
{
	CloseHandle( prtInfo->hThreadDone );
	CloseHandle( prtInfo->hShutdown );
	CloseHandle( prtInfo->hGo );
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetDefaultParameters"

void SetDefaultParameters( PDXVHELP_PARAMETERS pParameters )
{
	pParameters->fHost = FALSE;
	pParameters->fLobbyLaunched = FALSE;
	pParameters->fSilent = TRUE;
	pParameters->dwSessionType = DVSESSIONTYPE_PEER;
	pParameters->guidCT = DPVCTGUID_DEFAULT;
	pParameters->lpszConnectAddress[0] = 0;
	pParameters->fAGC = TRUE;
	pParameters->fAdvancedUI = FALSE;
	pParameters->fWaitForSettings = FALSE;
	pParameters->lRecordVolume = DSBVOLUME_MAX;
	pParameters->fRegister = FALSE;
	pParameters->fUnRegister = FALSE;
	pParameters->fKill = FALSE;
	pParameters->fIgnoreLobbyDestroy = FALSE;
	pParameters->fAllowWaveOut = FALSE;
	pParameters->fForceWaveOut = FALSE;
	pParameters->fAllowWaveIn = FALSE;
	pParameters->fForceWaveIn = FALSE;
	pParameters->fEchoSuppression = FALSE;
	pParameters->fAutoSelectMic = TRUE;
	pParameters->guidPlaybackDevice = DSDEVID_DefaultVoicePlayback;
	pParameters->guidRecordDevice = DSDEVID_DefaultVoiceCapture;
	pParameters->fSelectCards = FALSE;
	pParameters->fStrictFocus = FALSE;
	pParameters->fDisableFocus = FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessCommandLine"

BOOL ProcessCommandLine( PSTR pstrCommandLine, PDXVHELP_PARAMETERS pParameters )
{
	PSTR pNextToken = NULL;

	pNextToken = _tcstok( pstrCommandLine, _T(" ") );

	while( pNextToken != NULL )
	{
		if( _tcsicmp( pNextToken, _T("/A") ) == 0 ) 
		{
			pParameters->fAdvancedUI = TRUE;
			pParameters->fSilent = FALSE;			
		}
		else if( _tcsicmp( pNextToken, _T("/ES" ) ) == 0 )
		{
			pParameters->fEchoSuppression = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/WOF") ) == 0 )
		{
			pParameters->fForceWaveOut = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/NAS") ) == 0 )
		{
			pParameters->fAutoSelectMic = FALSE;
		}
		else if( _tcsicmp( pNextToken, _T("/WOA") ) == 0 )
		{
			pParameters->fAllowWaveOut = TRUE;
		}		
		else if( _tcsicmp( pNextToken, _T("/WIF") ) == 0 )
		{
			pParameters->fForceWaveIn = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/WIA") ) == 0 )
		{
			pParameters->fAllowWaveIn = TRUE;
		}				
		else if( _tcsicmp( pNextToken, _T("/ES") ) == 0 )
		{
			pParameters->fEchoSuppression = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/W") ) == 0 )
		{
			pParameters->fLobbyLaunched = TRUE;
			pParameters->fWaitForSettings = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/L") ) == 0 )
		{
			pParameters->fLobbyLaunched = TRUE;
			pParameters->fWaitForSettings = FALSE;
		}
		else if( _tcsicmp( pNextToken, _T("/R") ) == 0 )
		{
			pParameters->fRegister = TRUE;
			return FALSE;
		}
		else if( _tcsicmp( pNextToken, _T("/U") ) == 0 )
		{
			pParameters->fUnRegister = TRUE;
			return FALSE;
		}
		else if( _tcsicmp( pNextToken, _T("/S") ) == 0 )
		{
			pParameters->fSilent = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/K") ) == 0 )
		{
			pParameters->fKill = TRUE;
			return FALSE;
		}
		else if( _tcsicmp( pNextToken, _T("/I") ) == 0 )
		{
			pParameters->fIgnoreLobbyDestroy = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/GSM") ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_GSM;
		}
		else if( _tcsicmp( pNextToken, _T("/SC03" ) ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_SC03;
		}
		else if( _tcsicmp( pNextToken, _T("/SC06" ) ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_SC06;		
		}		
		else if( _tcsicmp( pNextToken, _T("/VR12" ) ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_VR12;				
		}				
		else if( _tcsicmp( pNextToken, _T("/ADPCM" ) ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_ADPCM;						
		}	
		else if( _tcsicmp( pNextToken, _T("/NONE" ) ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_NONE;								
		}						
		else if( _tcsicmp( pNextToken, _T("/TRUE" ) ) == 0 )
		{
			pParameters->guidCT = DPVCTGUID_TRUESPEECH;										
		}						
		else if( _tcsicmp( pNextToken, _T("/SS") ) == 0 )
		{
			pParameters->fSelectCards = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T("/FS") ) == 0 )
		{
			pParameters->fStrictFocus = TRUE;
		}
		else if( _tcsicmp( pNextToken, _T( "/FD" ) ) == 0 )
		{
			pParameters->fDisableFocus = TRUE;		
		}
		else
		{
			return FALSE;
		}
		
		pNextToken = _tcstok( NULL, _T(" ") );
	}

	if( !pParameters->fAdvancedUI && !pParameters->fLobbyLaunched )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Can only run in test mode and lobby mode" );
		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RegisterApplication"

void RegisterApplication()
{
	HRESULT hr;
	BOOL fFailed = FALSE;
	
	hr = DPVDX_DP_RegisterApplication( DPVHELP_PRIVATE_APPNAME, DPVHELP_PRIVATE_APPID, DPVHELP_PRIVATE_EXENAME, 
	                                   DPVHELP_PRIVATE_COMMANDLINE, DPVHELP_PRIVATE_DESC, DPVHELP_PRIVATE_FLAGS );

	if( FAILED( hr ) )
	{
		DPVDX_DPERRDisplay( hr, _T("Unable to register private application"), FALSE );
		MessageBox( NULL, _T("Registered Application"), DPVHELP_WINDOWTITLE, MB_OK );
	}

	if( !fFailed )
	{
		MessageBox( NULL, _T("Registered Application"), DPVHELP_WINDOWTITLE, MB_OK );
	}	
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterApplication"

void UnRegisterApplication()
{
	HRESULT hr;
	BOOL fFailed = FALSE;

	hr = DPVDX_DP_UnRegisterApplication( DPVHELP_PRIVATE_APPID );

	if( FAILED( hr ) )
	{
		DPVDX_DPERRDisplay( hr, _T("Unable to un-register private application"), FALSE );
		fFailed = TRUE;
	}

	if( !fFailed )
	{
		MessageBox( NULL, _T("Un-Registered Application"), DPVHELP_WINDOWTITLE, MB_OK );
	}	
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  WM_COMMAND	- process the application menu
//  WM_PAINT	- Paint the main window
//  WM_DESTROY	- post a quit message and return
//
//
#undef DPF_MODNAME
#define DPF_MODNAME "MainWindowProc"

LRESULT CALLBACK MainWindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;
	PAINTSTRUCT ps;
	HDC hdc;
	TCHAR szHello[MAX_LOADSTRING];

	switch (message) 
	{
		case WM_SHOWWINDOW:
			break;
		case WM_COMMAND:
			wmId    = LOWORD(wParam); 
			wmEvent = HIWORD(wParam); 
			// Parse the menu selections:
			switch (wmId)
			{
				case IDM_EXIT:
				   DestroyWindow(hWnd);
				   break;
				default:
				   return DefWindowProc(hWnd, message, wParam, lParam);
			}
			break;
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
			EndPaint(hWnd, &ps);  
			break;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}

//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//  COMMENTS:
//
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this function
//    so that the application will get 'well formed' small icons associated
//    with it.
//
#undef DPF_MODNAME
#define DPF_MODNAME "MyRegisterClass"

ATOM MyRegisterClass(HINSTANCE hInstance)
{
	WNDCLASSEX wcex;

	wcex.cbSize = sizeof(WNDCLASSEX); 

	wcex.style			= 0; 						// CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)MainWindowProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(hInstance, (LPCTSTR)IDI_DIRECTX);
	wcex.hCursor		= NULL; 					// LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
	wcex.lpszMenuName	= NULL; 					//(LPCSTR)IDC_TESTWIN;
	wcex.lpszClassName	= DPVHELP_WINDOWCLASS;
	wcex.hIconSm		= LoadIcon(wcex.hInstance, (LPCTSTR)IDI_DIRECTX);

	return RegisterClassEx(&wcex);
}

//
//   FUNCTION: InitInstance(HANDLE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CreateHiddenMainWindow"

HWND CreateHiddenMainWindow(HINSTANCE hInstance, int nCmdShow )
{
   HRESULT hr;
   HWND hWnd;

   hWnd = CreateWindow(DPVHELP_WINDOWCLASS, DPVHELP_WINDOWTITLE, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
		hr = GetLastError();
		return NULL;
   }

   ShowWindow(hWnd, SW_HIDE);
   UpdateWindow(hWnd);  

   return hWnd;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CheckFullDuplex"

BOOL CheckFullDuplex( PDXVHELP_PARAMETERS pParameters )
{
	PDIRECTPLAYVOICETEST lpdvSetup;	
	HRESULT hr;

	hr = CoCreateInstance( DPVOICE_CLSID_DPVOICE, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayVoiceTest, (void **) &lpdvSetup );

	if( FAILED( hr ) )
	{
		DPVDX_DVERRDisplay( hr, _T("Create of setup interface failed"), pParameters->fSilent );
		return FALSE;
	}	

	hr = lpdvSetup->CheckAudioSetup( &pParameters->guidPlaybackDevice, &pParameters->guidRecordDevice, NULL, DVFLAGS_QUERYONLY );

	if( FAILED( hr )  )
	{
		if( pParameters->fSilent )
		{
			lpdvSetup->Release();
			return FALSE;
		}
		
		hr = lpdvSetup->CheckAudioSetup( &pParameters->guidPlaybackDevice, &pParameters->guidRecordDevice, NULL, 0 );

		lpdvSetup->Release();		

		if( FAILED( hr ) )
		{
			return FALSE;			
		}
	}
	else
	{
		lpdvSetup->Release();
	}

	return TRUE;

}

#undef DPF_MODNAME
#define DPF_MODNAME "WinMain"

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
	DWORD                   dwThreadID;
	DXVHELP_RTINFO          rtInfo;
	BOOL                    bGotMsg = FALSE;	
	MSG                     msg;
	HRESULT                 hr;
    INITCOMMONCONTROLSEX    InitCC = {0};
    BOOL                    bOK = FALSE;
    BOOL					fRunTimeInit = FALSE;


	// Initialize COM
	hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	if( FAILED( hr ) )
	{
		return FALSE;
	}

	if( !DNOSIndirectionInit() )
	{
		CoUninitialize();
		return FALSE;
	}

	// Setup default parameters 
	SetDefaultParameters( &rtInfo.dxvParameters );

	// Process the command-line
	//
	// If this function returns false, we are to exit
	if( !ProcessCommandLine( lpCmdLine, &rtInfo.dxvParameters ) )
	{
		if( rtInfo.dxvParameters.fRegister ) 
		{
			RegisterApplication();
		}
		else if( rtInfo.dxvParameters.fUnRegister )
		{
			UnRegisterApplication();
		}

		goto EXIT;
	}

	// Load common-controls
    InitCC.dwSize = sizeof InitCC;
	bOK = InitCommonControlsEx(&InitCC);	

	// Register Window Class
	MyRegisterClass(hInstance);	

	// Initialize Events 
	InitializeRunTime( &rtInfo );	

	fRunTimeInit = TRUE;

	if( rtInfo.dxvParameters.fLobbyLaunched )
	{
		SetEvent( rtInfo.hGo );
	}

	// Perform application initialization:
	rtInfo.hMainWnd = CreateHiddenMainWindow(hInstance, nCmdShow);

	if( rtInfo.hMainWnd == NULL )
	{
		goto EXIT;
	}

	rtInfo.hInst = hInstance;

	// If user wants to select the soundcard
	if( rtInfo.dxvParameters.fSelectCards  )
	{
		GetCardSettings( rtInfo.hInst, NULL, &rtInfo.dxvParameters.guidPlaybackDevice, &rtInfo.dxvParameters.guidRecordDevice );
	}

	if( !CheckFullDuplex( &rtInfo.dxvParameters ) )
	{
		goto EXIT;
	}

	// Startup thread which handles connects etc.
	VoiceManager_Start( &rtInfo );

	// Display Dialog if Required
	if( !rtInfo.dxvParameters.fSilent )
	{
		MainDialog_Create( &rtInfo );
	}

	while( MsgWaitForMultipleObjects( 1, &rtInfo.hThreadDone, FALSE, INFINITE, QS_ALLINPUT) != WAIT_OBJECT_0 )
	{
		bGotMsg = TRUE;
		
		while( bGotMsg )
		{
			bGotMsg = PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE );

			if( bGotMsg )
			{
				if( rtInfo.hMainDialog == NULL || !IsDialogMessage(rtInfo.hMainDialog,&msg) )
				{
					TranslateMessage( &msg );
					DispatchMessage( &msg );
				}
			}
		}
	}

	VoiceManager_Stop( &rtInfo );

EXIT:

	if( fRunTimeInit )
	{
		FreeRunTime( &rtInfo );		
	}

	DNOSIndirectionDeinit();

	CoUninitialize();
	
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\hostdlg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        hostdlg.h
 *  Content:	 Host Dialog Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/


#ifndef __HOSTDLG_H

BOOL GetHostSettings( HINSTANCE hInst, HWND hOwner, LPGUID pguidCT, PDWORD pdwSessionType );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\misc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        misc.h
 *  Content:	 Misc Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/

#ifndef __MISC_H

BOOL MicrophoneGetVolume( UINT waveInDevice, LONG &volume );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\maindlg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        maindlg.h
 *  Content:	 Main Dialog Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/

#ifndef __MAINDIALOG_H

extern void MainDialog_AddVoicePlayer( HWND hDlg, DWORD dwID );
extern void MainDialog_RemoveVoicePlayer( HWND hDlg, DWORD dwID );
extern void MainDialog_AddTransportPlayer( HWND hDlg, DWORD dwID );
extern void MainDialog_RemoveTransportPlayer( HWND hDlg, DWORD dwID );
extern void MainDialog_AddToLog( HWND hDlg, LPTSTR lpstrMessage );
extern BOOL MainDialog_Create( PDXVHELP_RTINFO prtInfo );
extern void MainDialog_SetIdleState( HWND hDlg, PDXVHELP_RTINFO prtInfo );
extern void MainDialog_DisplayStatus( HWND hDlg, LPTSTR lpstrStatus );
extern void MainDialog_ShowSessionSettings( HWND hDlg, PDXVHELP_RTINFO prtInfo );
extern void MainDialog_DisplayVolumeSettings( HWND hDlg, PDXVHELP_RTINFO prtInfo );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\maindlg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        maindlg.cpp
 *  Content:	 Main Dialog Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *  10/15/99	rodtoll	Placed guards to prevent operating on window once it's gone
 *  10/20/99	rodtoll	Fix: Bug #114185 Adjusting volume while not connected causes crash
 *  11/12/99	rodtoll	Added code to handle the new "Enable Echo suppression" check box.
 *  12/07/99	rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *  7/21/2000	rodtoll	64-bit build bug -- just appeared
 *
 ***************************************************************************/
 
#include "dxvhelppch.h"


PDXVHELP_RTINFO g_prtInfo = NULL;

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_EnumPlayers"

BOOL FAR PASCAL MainDialog_EnumPlayers(
  DPID dpId,
  DWORD dwPlayerType,
  LPCDPNAME lpName,
  DWORD dwFlags,
  LPVOID lpContext
)
{
    PDXVHELP_RTINFO prtInfo = (PDXVHELP_RTINFO) lpContext;

    MainDialog_AddTransportPlayer( prtInfo->hMainDialog, dpId );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_UpdatePlayerList"

void MainDialog_UpdatePlayerList( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
    prtInfo->lpdpDirectPlay->EnumPlayers( NULL, MainDialog_EnumPlayers, prtInfo, DPENUMPLAYERS_ALL );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_AddTransportPlayer"

void MainDialog_AddTransportPlayer( HWND hDlg, DWORD dwID )
{
    TCHAR tszBuffer[100];

    _stprintf( tszBuffer, _T("0x%x"), dwID );

    SendMessage( GetDlgItem( hDlg, IDC_LIST_DPLAY ), LB_ADDSTRING, 0, (WPARAM) tszBuffer );        
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_RemoveTransportPlayer"

void MainDialog_RemoveTransportPlayer( HWND hDlg, DWORD dwID )
{
    TCHAR tszBuffer[100];

    _stprintf( tszBuffer, _T("0x%x"), dwID );

    LONG_PTR lResult;

    lResult = SendMessage( GetDlgItem( hDlg, IDC_LIST_DPLAY ), LB_FINDSTRINGEXACT, -1, (WPARAM)tszBuffer );

    if( lResult != LB_ERR )
    {
        SendMessage( GetDlgItem( hDlg, IDC_LIST_DPLAY ), LB_DELETESTRING, lResult, 0 );            
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_AddVoicePlayer"

void MainDialog_AddVoicePlayer( HWND hDlg, DWORD dwID )
{
    TCHAR tszBuffer[100];

    _stprintf( tszBuffer, _T("0x%x"), dwID );

    SendMessage( GetDlgItem( hDlg, IDC_LIST_DVOICE ), LB_ADDSTRING, 0, (WPARAM)tszBuffer );     
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_RemoveVoicePlayer"

void MainDialog_RemoveVoicePlayer( HWND hDlg, DWORD dwID )
{
    TCHAR tszBuffer[100];

    _stprintf( tszBuffer, _T("0x%x"), dwID );

    LONG_PTR lResult;

    lResult = SendMessage( GetDlgItem( hDlg, IDC_LIST_DVOICE ), LB_FINDSTRINGEXACT, -1, (WPARAM)tszBuffer );

    if( lResult != LB_ERR )
    {
        SendMessage( GetDlgItem( hDlg, IDC_LIST_DVOICE ), LB_DELETESTRING, lResult, 0 );            
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_AddToLog"

void MainDialog_AddToLog( HWND hDlg, LPTSTR lpstrMessage )
{
	LONG_PTR lResult;
    lResult = SendMessage( GetDlgItem( hDlg, IDC_LIST_OUTPUT ), LB_ADDSTRING, 0, (WPARAM)lpstrMessage );    
	SendMessage( GetDlgItem( hDlg, IDC_LIST_OUTPUT ), LB_SETTOPINDEX,lResult,  0 );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_DisplayStatus"

void MainDialog_DisplayStatus( HWND hDlg, LPTSTR lpstrStatus )
{
	if( hDlg == NULL )
		return;

	HWND hwndItem = GetDlgItem( hDlg, IDC_STATIC_STATUS );

	if( hwndItem != NULL )
	{
		SetWindowText( hwndItem, lpstrStatus );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_DisplayVolumeSettings"

void MainDialog_DisplayVolumeSettings( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	if( hDlg == NULL )
		return;

	if( prtInfo->dxvParameters.fAGC )
	{
		CheckDlgButton( hDlg, IDC_CHECK_AGC, BST_CHECKED );
		EnableWindow( GetDlgItem( hDlg, IDC_SLIDER_RECVOLUME ), FALSE );	
	}
	else
	{
		CheckDlgButton( hDlg, IDC_CHECK_AGC, BST_UNCHECKED );	
		EnableWindow( GetDlgItem( hDlg, IDC_SLIDER_RECVOLUME ), TRUE );	
	}
	
	if( prtInfo->dxvParameters.fEchoSuppression )
	{
		CheckDlgButton( hDlg, IDC_CHECK_ES, BST_CHECKED );
	}
	else
	{
		CheckDlgButton( hDlg, IDC_CHECK_ES, BST_UNCHECKED );	
	}
	
	SendMessage( GetDlgItem( hDlg, IDC_SLIDER_RECVOLUME ), TBM_SETPOS, (WPARAM) TRUE, (LPARAM) (((LONG) prtInfo->dxvParameters.lRecordVolume)*((LONG) -1)) );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleESCheck"

void MainDialog_HandleESCheck( HWND hDlg, HWND hwndControl, PDXVHELP_RTINFO prtInfo )
{
	DVCLIENTCONFIG dvClientConfig;

	dvClientConfig.dwSize = sizeof( DVCLIENTCONFIG );
	
	if( prtInfo->lpdvClient != NULL )
		prtInfo->lpdvClient->GetClientConfig( &dvClientConfig );	
	
	if( SendMessage( (HWND) hwndControl, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
	{
		dvClientConfig.dwFlags |= DVCLIENTCONFIG_ECHOSUPPRESSION;
		prtInfo->dxvParameters.fEchoSuppression = TRUE;
	}
	else
	{
		dvClientConfig.dwFlags &= ~DVCLIENTCONFIG_ECHOSUPPRESSION;				
		prtInfo->dxvParameters.fEchoSuppression = FALSE;					
	}

	if( prtInfo->lpdvClient != NULL )
		prtInfo->lpdvClient->SetClientConfig( &dvClientConfig );			

	MainDialog_DisplayVolumeSettings( hDlg, prtInfo );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleAGCCheck"

void MainDialog_HandleAGCCheck( HWND hDlg, HWND hwndControl, PDXVHELP_RTINFO prtInfo )
{
	DVCLIENTCONFIG dvClientConfig;

	dvClientConfig.dwSize = sizeof( DVCLIENTCONFIG );
	
	if( prtInfo->lpdvClient != NULL )
		prtInfo->lpdvClient->GetClientConfig( &dvClientConfig );	
	
	if( SendMessage( (HWND) hwndControl, BM_GETCHECK, 0, 0 ) == BST_CHECKED )
	{
		dvClientConfig.dwFlags |= DVCLIENTCONFIG_AUTORECORDVOLUME;
		prtInfo->dxvParameters.lRecordVolume = 0;
		prtInfo->dxvParameters.fAGC = TRUE;
	}
	else
	{
		dvClientConfig.dwFlags &= ~DVCLIENTCONFIG_AUTORECORDVOLUME;				
		prtInfo->dxvParameters.lRecordVolume = -9000;					
		prtInfo->dxvParameters.fAGC = FALSE;					
	}

	dvClientConfig.lRecordVolume = prtInfo->dxvParameters.lRecordVolume;	

	if( prtInfo->lpdvClient != NULL )
		prtInfo->lpdvClient->SetClientConfig( &dvClientConfig );			

	MainDialog_DisplayVolumeSettings( hDlg, prtInfo );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleConnect"

void MainDialog_HandleConnect( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	if( GetConnectSettings( prtInfo->hInst, hDlg, prtInfo->dxvParameters.lpszConnectAddress ) )
	{
		prtInfo->dxvParameters.fHost = FALSE;
		SetEvent( prtInfo->hGo );
		EnableWindow( GetDlgItem( hDlg, IDC_BUTTON_CONNECT ), FALSE );
		EnableWindow( GetDlgItem( hDlg, IDC_BUTTON_HOST ), FALSE );			
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleHost"

void MainDialog_HandleHost( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	if( GetHostSettings( prtInfo->hInst, hDlg, &prtInfo->dxvParameters.guidCT, &prtInfo->dxvParameters.dwSessionType ) )
	{
		prtInfo->dxvParameters.fHost = TRUE;
		SetEvent( prtInfo->hGo );	
		EnableWindow( GetDlgItem( hDlg, IDC_BUTTON_CONNECT ), FALSE );
		EnableWindow( GetDlgItem( hDlg, IDC_BUTTON_HOST ), FALSE );									
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleScroll"

void MainDialog_HandleScroll( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	DWORD dwPosition;
	DVCLIENTCONFIG dvClientConfig;

	dvClientConfig.dwSize = sizeof( DVCLIENTCONFIG );

	dwPosition = (DWORD) SendMessage( GetDlgItem( hDlg, IDC_SLIDER_RECVOLUME ), TBM_GETPOS, 0, 0 );

	prtInfo->dxvParameters.lRecordVolume = ((LONG) dwPosition) * ((LONG) -1);

	if( prtInfo->lpdvClient != NULL )
	{
		prtInfo->lpdvClient->GetClientConfig( &dvClientConfig );
	}

	dvClientConfig.lRecordVolume = prtInfo->dxvParameters.lRecordVolume;

	if( prtInfo->lpdvClient != NULL )
	{
		prtInfo->lpdvClient->SetClientConfig( &dvClientConfig );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleClose"

void MainDialog_HandleClose( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	SetEvent( prtInfo->hShutdown );

	DestroyWindow( hDlg ); 

	prtInfo->hMainDialog = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_SetIdleState"

void MainDialog_SetIdleState( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	if( hDlg == NULL )
		return;
	
	SetWindowText( GetDlgItem( hDlg, IDC_STATIC_STATUS ), _T("Idle") );
	SetWindowText( GetDlgItem( hDlg, IDC_STATIC_CT), _T("N/A")  );
	SetWindowText( GetDlgItem( hDlg, IDC_STATIC_PLAYERS ), _T("0") );
	SetWindowText( GetDlgItem( hDlg, IDC_STATIC_HOST), _T("N/A") );
	SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE), _T("N/A") );	

	SendMessage( GetDlgItem( hDlg, IDC_SLIDER_RECVOLUME ), TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG( 0, 10000 ) );
	SendMessage( GetDlgItem( hDlg, IDC_SLIDER_RECVOLUME ), TBM_SETTICFREQ, (WPARAM) 2000, (LPARAM) 0 );

	SendMessage( GetDlgItem( hDlg, IDC_PROGRESS_TX ), PBM_SETRANGE, (WPARAM) 0, MAKELPARAM( 0, 100 ) );
	SendMessage( GetDlgItem( hDlg, IDC_PROGRESS_RX ), PBM_SETRANGE, (WPARAM) 0, MAKELPARAM( 0, 100 ) );

	MainDialog_DisplayVolumeSettings( hDlg, prtInfo );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_HandleInitDialog"

void MainDialog_HandleInitDialog( HWND hDlg, PDXVHELP_RTINFO prtInfo )
{
	MainDialog_SetIdleState( hDlg, prtInfo );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_Proc"

INT_PTR  CALLBACK MainDialog_Proc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PDXVHELP_RTINFO prtInfo = g_prtInfo;
	
	switch (message)
	{
		case WM_INITDIALOG:
		
			MainDialog_HandleInitDialog( hDlg, prtInfo  );		

			return TRUE;

		case WM_COMMAND:

			if( HIWORD( wParam ) == BN_CLICKED &&
			    LOWORD( wParam ) == IDC_CHECK_AGC )
			{
				MainDialog_HandleAGCCheck( hDlg, (HWND) lParam, prtInfo );
			}
			else if( LOWORD( wParam ) == IDC_BUTTON_CONNECT &&
			         HIWORD( wParam ) == BN_CLICKED )
			{
				MainDialog_HandleConnect( hDlg, prtInfo );
			}
			else if( LOWORD( wParam ) == IDC_BUTTON_HOST &&
			         HIWORD( wParam ) == BN_CLICKED )
			{
				MainDialog_HandleHost( hDlg, prtInfo );
			}
			else if( HIWORD( wParam ) == BN_CLICKED && 
				     LOWORD( wParam ) == IDC_CHECK_ES )
			{
				MainDialog_HandleESCheck( hDlg, (HWND) lParam, prtInfo );
			}

			break;

		case WM_VSCROLL:

			MainDialog_HandleScroll( hDlg, prtInfo );
			
			break;
		case WM_CLOSE:

			MainDialog_HandleClose( hDlg, prtInfo );

			break;
	}
	
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_ShowSessionSettings"

void MainDialog_ShowSessionSettings( HWND hDlg, PDXVHELP_RTINFO prtInfo ) 
{
	DWORD dwSize;
	DVSESSIONDESC dvSessionDesc;
	HRESULT hr;
	GUID guidCT;

	dwSize = 0;

	dvSessionDesc.dwSize = sizeof( DVSESSIONDESC );
	hr = prtInfo->lpdvClient->GetSessionDesc( &dvSessionDesc );

	if( hr == DV_OK ) 
	{
		guidCT = dvSessionDesc.guidCT;

		switch( dvSessionDesc.dwSessionType )
		{
		case DVSESSIONTYPE_PEER:
			SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE ), _T("Peer") );				
			break;
		case DVSESSIONTYPE_MIXING:
			SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE ), _T("Mixing") );				
			break;		
		case DVSESSIONTYPE_FORWARDING:
			SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE ), _T("Forwarding") );				
			break;		
		case DVSESSIONTYPE_ECHO:
			SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE ), _T("Echo"));				
			break;		
		default:
			SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE ), _T("Unknown") );				
			break;				
		}

		LPTSTR lpstrCTName = NULL;
		DWORD dwLength = 0;

		hr = DPVDX_GetCompressionName( guidCT, lpstrCTName, &dwLength );

		if( hr != DVERR_BUFFERTOOSMALL )
		{
			DPVDX_DVERRDisplay( hr, _T("GetCompressionName"), FALSE );
			SetWindowText( GetDlgItem( hDlg, IDC_STATIC_CT ), _T("Unknown") );
		}
		else
		{
			lpstrCTName = new TCHAR[dwLength];

			hr = DPVDX_GetCompressionName( guidCT, lpstrCTName, &dwLength );

			if( FAILED( hr ) )
			{
				DPVDX_DVERRDisplay( hr, _T("GetCompressionName"), FALSE );
				SetWindowText( GetDlgItem( hDlg, IDC_STATIC_CT ), _T("Unknown") );
			}
			else
			{
				SetWindowText( GetDlgItem( hDlg, IDC_STATIC_CT ), lpstrCTName );						
			}

			delete [] lpstrCTName;
		}
	}
	else 
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting full session settings" );
		SetWindowText( GetDlgItem( hDlg, IDC_STATIC_TYPE ), _T("Unknown" ));				
		SetWindowText( GetDlgItem( hDlg, IDC_STATIC_CT ), _T("Unknown") );				
	}

	if( prtInfo->dxvParameters.fHost )
	{
		SetWindowText( GetDlgItem( hDlg, IDC_STATIC_HOST ), _T("Local Host") );
	}
	else
	{
		SetWindowText( GetDlgItem( hDlg, IDC_STATIC_HOST ), _T("Remote Host") );
	}

	TCHAR szTmpString[100];
	_stprintf( szTmpString, _T("0x%x"), prtInfo->dpidLocalPlayer );

	HWND hwndTmp = GetDlgItem( hDlg, IDC_STATIC_ID );

	SetWindowText( hwndTmp, szTmpString );

	MainDialog_UpdatePlayerList( hDlg, prtInfo );
		
	return;
}

// Show the main dialog box
#undef DPF_MODNAME
#define DPF_MODNAME "MainDialog_Create"

BOOL MainDialog_Create( PDXVHELP_RTINFO prtInfo )
{
	HRESULT hr;

	g_prtInfo = prtInfo;

	prtInfo->hMainDialog = CreateDialog( prtInfo->hInst, (prtInfo->dxvParameters.fLobbyLaunched) ? MAKEINTRESOURCE( IDD_DIALOG_MAIN ) : MAKEINTRESOURCE( IDD_DIALOG_MAIN_STANDALONE ), prtInfo->hMainWnd, MainDialog_Proc );

	if( prtInfo->hMainDialog == NULL )
	{
		hr = GetLastError();

		return FALSE;
	}

	if( prtInfo->dxvParameters.fAdvancedUI )
	{
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_PLAYERS_TITLE ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_HOST_TITLE ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_TYPE_TITLE ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_CT_TITLE ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_PLAYERS ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_HOST ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_TYPE ), TRUE );
		ShowWindow( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_CT ), TRUE );
		
	}

	ShowWindow( prtInfo->hMainDialog, SW_SHOW );

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dxvhelp.rc
//
#define IDC_MYICON                      2
#define IDD_TESTWIN_DIALOG              102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_DIRECTX                     107
#define IDC_TESTWIN                     109
#define IDR_MAINFRAME                   128
#define IDD_CANCELDIALOG                129
#define IDD_DIALOG_MAIN                 130
#define IDD_DIALOG_CONNECT              131
#define IDD_DIALOG_HOST                 132
#define IDD_DIALOG_MAIN_STANDALONE      133
#define IDD_DIALOG_SOUND                134
#define IDC_PROGRESS_RX                 1000
#define IDC_PROGRESS_TX                 1001
#define IDC_SLIDER_RECVOLUME            1002
#define IDC_CHECK_AGC                   1003
#define IDC_STATIC_STATUS               1004
#define IDC_STATIC_CT                   1005
#define IDC_STATIC_PLAYERS              1006
#define IDC_STATIC_HOST                 1007
#define IDC_EDIT_ADDRESS                1007
#define IDC_STATIC_TYPE                 1008
#define IDC_CHECK_VS                    1009
#define IDC_STATIC_ID                   1009
#define IDC_BUTTON_HOST                 1010
#define IDC_COMBO_CT                    1011
#define IDC_CHECK_ES                    1012
#define IDC_COMBO_TYPE                  1013
#define IDC_STATIC_CT_TITLE             1014
#define IDC_STATIC_PLAYERS_TITLE        1015
#define IDC_STATIC_HOST_TITLE           1016
#define IDC_STATIC_TYPE_TITLE           1017
#define IDC_BUTTON_CONNECT              1018
#define IDC_CHECK_ES2                   1019
#define IDC_COMBO_PLAYBACK              1020
#define IDC_COMBO_RECORD                1021
#define IDC_STATIC_TX                   1022
#define IDC_STATIC_RX                   1023
#define IDC_LIST_OUTPUT                 1024
#define IDC_LIST_DVOICE                 1025
#define IDC_LIST_DPLAY                  1026
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\snddlg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        snddlg.h
 *  Content:	 Soundcard selection dialog
 *
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	rodtoll	created it
 *
 ***************************************************************************/


#ifndef __SNDDLG_H
#define __SNDDLG_H

BOOL GetCardSettings( HINSTANCE hInst, HWND hOwner, LPGUID pguidPlayback, LPGUID pguidRecord );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\misc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        misc.cpp
 *  Content:	 Misc Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/

#include "dxvhelppch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// MicrophoneGetVolume
//
// This function retrieves the current volume of the microphone
// recording line.  
//
// Parameters:
// UINT waveInDevice -
//		This specifies the device for which we wish to get 
//      the microphone recording volume.  This is the 
//      waveIN device ID for the desired device.
//
// BYTE &volume -
//		[output] The current volume of the microphone recording
//               line for the specified device.  (DSound Range)
//
// BOOL -
//		true on success, false on failure
//
#undef DPF_MODNAME
#define DPF_MODNAME "MicrophoneGetVolume"

BOOL MicrophoneGetVolume( UINT waveInDevice, LONG &volume ) { 

    MMRESULT result;

   // Open the mixer device
   HMIXER hmx = NULL;
   LPMIXERCONTROLDETAILS_UNSIGNED pUnsigned = NULL;
   LPMIXERCONTROL pmxctrl = NULL;

   bool foundMicrophone = false;
   DWORD i;

   if( mixerOpen(&hmx, waveInDevice, 0, 0, MIXER_OBJECTF_WAVEIN) != MMSYSERR_NOERROR ) 
   	return FALSE;

   // Get the line info for the wave in destination line
   MIXERLINE mxl;
   mxl.cbStruct = sizeof(mxl);
   mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
   mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE); 

   // Now find the microphone source line connected to this wave in
   // destination
   DWORD cConnections = mxl.cConnections;

   for(i=0; i<cConnections; i++)
   {
      mxl.dwSource = i;
      mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);
      if (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mxl.dwComponentType)
      {
         foundMicrophone = true;
         break;
      }
   }

    if( !foundMicrophone )
    {
        for(i=0; i<cConnections; i++)
        {
           mxl.dwSource = i;

           if( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) != MMSYSERR_NOERROR )
           {
           	return false;
           }
           
           if (MIXERLINE_COMPONENTTYPE_SRC_LINE == mxl.dwComponentType)
           {
              foundMicrophone = true;
              break;
           }
        }   

        if( !foundMicrophone )
        {
            for(i=0; i<cConnections; i++)
            {
               mxl.dwSource = i;
               if( mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE) != MMSYSERR_NOERROR )
               {
               	return false;
               }
               if (MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY == mxl.dwComponentType)
               {
                  foundMicrophone = true;
                  break;
               }
            }   
        }
    }

    if( !foundMicrophone )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "ERROR: Unable to find microphone source" );
        return FALSE;
    }

   // Find a volume control, if any, of the microphone line
   pmxctrl = new MIXERCONTROL;

   if( pmxctrl == NULL )
   {
   		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc mixercontrol" );
   		return FALSE;
   	}

   MIXERLINECONTROLS mxlctrl = {
       sizeof(mxlctrl), mxl.dwLineID, MIXERCONTROL_CONTROLTYPE_VOLUME, 
       1, sizeof(MIXERCONTROL), pmxctrl 
   };

   if( (result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE)) == MMSYSERR_NOERROR )
   { 
      // Found!
      DWORD cChannels = mxl.cChannels;

      if (MIXERCONTROL_CONTROLF_UNIFORM & pmxctrl->fdwControl)
         cChannels = 1;

      pUnsigned = new MIXERCONTROLDETAILS_UNSIGNED[cChannels];

      if( pUnsigned == NULL )
      {
          	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc unsigneds" );
          	delete pmxctrl;
          	return FALSE;
      }

      MIXERCONTROLDETAILS mxcd = {
          sizeof(mxcd), pmxctrl->dwControlID, 
          cChannels, (HWND)0, sizeof(MIXERCONTROLDETAILS_UNSIGNED), 
          (LPVOID) pUnsigned
      };

      if( mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE) != MMSYSERR_NOERROR )
      	return false;

      volume = ((pUnsigned[0].dwValue) * (DSBVOLUME_MAX-DSBVOLUME_MIN)) / 0xFFFF;
      volume += DSBVOLUME_MIN;

      if( mixerSetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE) != MMSYSERR_NOERROR )
      	return FALSE;

	  if( mixerClose(hmx) != MMSYSERR_NOERROR )
	  	return FALSE;

      delete pmxctrl;
      delete [] pUnsigned;

      return TRUE;
   }
   else
   {
		return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\snddlg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        snddlg.cpp
 *  Content:	 Sound card selection dialog
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  12/1/99		rodtoll	created it
 *
 ***************************************************************************/

#include "dxvhelppch.h"


GUID g_guidPlayback = GUID_NULL;
GUID g_guidRecord = GUID_NULL;

typedef HRESULT (WINAPI *DSENUM)( LPDSENUMCALLBACK lpDSEnumCallback,LPVOID lpContext );

#undef DPF_MODNAME
#define DPF_MODNAME "SoundListFillCallback"

BOOL CALLBACK SoundListFillCallback(
  LPGUID lpGuid,            
  LPCSTR lpcstrDescription,  
  LPCSTR lpcstrModule,       
  LPVOID lpContext          
)
{
	DNASSERT( lpContext != NULL );
	
	HWND hwnd = *((HWND *) lpContext);

	LRESULT lIndex;

	if( lpGuid == NULL )
		return TRUE;

	LPGUID pTmpGuid = new GUID;

	if( pTmpGuid != NULL )
	{
		memcpy( pTmpGuid, lpGuid, sizeof(GUID) );
		lIndex = SendMessage( hwnd, CB_ADDSTRING, 0, (LPARAM) lpcstrDescription );	
		SendMessage( hwnd, CB_SETITEMDATA, lIndex, (LPARAM) pTmpGuid );
	}

	return TRUE;
}

struct GetGUIDParam
{
	DWORD		dwCurrentIndex;
	DWORD		dwTargetIndex;
	GUID		guidDevice;
};

#undef DPF_MODNAME
#define DPF_MODNAME "SoundGetGUIDCallback"

BOOL CALLBACK SoundGetGUIDCallback(
  LPGUID lpGuid,            
  LPCSTR lpcstrDescription,  
  LPCSTR lpcstrModule,       
  LPVOID lpContext          
)
{
	DNASSERT( lpContext != NULL );
	
	GetGUIDParam *pParam = (GetGUIDParam *) lpContext;

	if( pParam->dwCurrentIndex == pParam->dwTargetIndex )
	{
		if( lpGuid == NULL )
		{
			pParam->guidDevice = GUID_NULL;
		}
		else
		{
			pParam->guidDevice = *lpGuid;
		}

		return FALSE;
	}

	pParam->dwCurrentIndex++;

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "LoadDSAndCallEnum"

HRESULT LoadDSAndCallEnum( const TCHAR *lpszEnumFuncName, LPDSENUMCALLBACK enumCallback, LPVOID lpvContext )
{
    DSENUM enumFunc;
    HINSTANCE hinstds;
    HRESULT hr;

	hinstds = NULL;

	// Attempt to load the directsound DLL
    hinstds = LoadLibrary( _T("DSOUND.DLL") );

	// If it couldn't be loaded, this sub system is not supported
	// on this system.
    if( hinstds == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "Unable to load dsound.dll to enum devices" );
		return DVERR_GENERIC;
    }

	// Attempt to get the DirectSoundCaptureEnumerateA function from the
	// DSOUND.DLL.  If it's not available then this class assumes it's
	// not supported on this system.
    enumFunc = (DSENUM) GetProcAddress( hinstds, lpszEnumFuncName );

    if( enumFunc == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "Unable to find cap enum func for enumerate" );
        FreeLibrary( hinstds );
        return DVERR_GENERIC;
    }

    hr = (*enumFunc)( enumCallback, lpvContext );

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Enum call failed hr=0x%x", hr );
    }

    FreeLibrary( hinstds );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SoundDialog_FillPlaybackPulldown"

void SoundDialog_FillPlaybackPulldown( HWND hDlg )
{
	HWND hwndPulldown = GetDlgItem( hDlg, IDC_COMBO_PLAYBACK );

	DNASSERT( hwndPulldown != NULL );	
	
	HRESULT hr = LoadDSAndCallEnum( _T("DirectSoundEnumerateA"), SoundListFillCallback, (LPVOID) &hwndPulldown );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Load and enum of devices failed hr=0x%x", hr );
	}

	SendMessage( hwndPulldown, CB_SETCURSEL, 0, 0 );
}

#undef DPF_MODNAME
#define DPF_MODNAME "SoundDialog_FillRecordPulldown"

void SoundDialog_FillRecordPulldown( HWND hDlg )
{
	HWND hwndPulldown = GetDlgItem( hDlg, IDC_COMBO_RECORD );

	DNASSERT( hwndPulldown != NULL );
	
	HRESULT hr = LoadDSAndCallEnum( _T("DirectSoundCaptureEnumerateA"), SoundListFillCallback, (LPVOID) &hwndPulldown );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Load and enum of devices failed hr=0x%x", hr );
	}	

	SendMessage( hwndPulldown, CB_SETCURSEL, 0, 0 );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "SoundDialog_HandleCommandOK"

BOOL SoundDialog_HandleCommandOK( HWND hDlg  )
{
	LRESULT lIndex;

	lIndex = SendMessage( GetDlgItem( hDlg, IDC_COMBO_PLAYBACK ), CB_GETCURSEL, 0, 0 );

	if( lIndex == CB_ERR )
	{
		MessageBox( NULL, _T("Select a playback device!"), _T("Error"), MB_OK );
		return FALSE;
	}

	LPGUID lpguidTmp = (LPGUID) SendMessage( GetDlgItem( hDlg, IDC_COMBO_PLAYBACK ), CB_GETITEMDATA, lIndex, 0 );	
	
	if( lpguidTmp != NULL )
	{
		memcpy( &g_guidPlayback, lpguidTmp, sizeof( GUID ) );
	}
	else
	{
		memset( &g_guidPlayback, 0x00, sizeof( GUID ) );
	}

	lIndex = SendMessage( GetDlgItem( hDlg, IDC_COMBO_RECORD ), CB_GETCURSEL, 0, 0 );

	if( lIndex == CB_ERR )
	{
		MessageBox( NULL, _T("Select a playback device!"), _T("Error"), MB_OK );
		return FALSE;
	}

	lpguidTmp = (LPGUID) SendMessage( GetDlgItem( hDlg, IDC_COMBO_RECORD ), CB_GETITEMDATA, lIndex, 0 );	
	
	if( lpguidTmp != NULL )
	{
		memcpy( &g_guidRecord, lpguidTmp, sizeof( GUID ) );
	}
	else
	{
		memset( &g_guidRecord, 0x00, sizeof( GUID ) );
	}	

/*	enumParam.dwCurrentIndex = 0;
	enumParam.dwTargetIndex = lIndex;
	enumParam.guidDevice = GUID_NULL;	

	hr = LoadDSAndCallEnum( _T("DirectSoundCaptureEnumerateA"), SoundGetGUIDCallback, (LPVOID) &enumParam );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Retrieval of capture device failed hr=0x%x", hr );
	}
	else
	{
		g_guidRecord = enumParam.guidDevice;	
	}

	lIndex = SendMessage( GetDlgItem( hDlg, IDC_COMBO_RECORD ), CB_GETCURSEL, 0, 0 );

	if( lIndex == CB_ERR )
	{
		MessageBox( NULL, _T("Select a record device!"), _T("Error"), MB_OK );
		return FALSE;
	}	

	enumParam.dwCurrentIndex = 0;
	enumParam.dwTargetIndex = lIndex;
	enumParam.guidDevice = GUID_NULL;

	hr = LoadDSAndCallEnum( _T("DirectSoundEnumerateA"), SoundGetGUIDCallback, (LPVOID) &enumParam );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Retrieval of playback device failed hr=0x%x", hr );
	}
	else
	{
		g_guidPlayback = enumParam.guidDevice;
	}	*/
	
	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "SoundDialog_WinProc"

INT_PTR CALLBACK SoundDialog_WinProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		case WM_INITDIALOG:

			SoundDialog_FillPlaybackPulldown( hDlg );
			SoundDialog_FillRecordPulldown( hDlg );

			return TRUE;

		case WM_COMMAND:
		
			if (LOWORD(wParam) == IDOK )
			{
				if( !SoundDialog_HandleCommandOK( hDlg ) )
				{
					return FALSE;
				}
			}
			
			if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) 
			{
				EndDialog(hDlg, LOWORD(wParam));
				return TRUE;
			}

			break;
	}
    return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SoundDialog_GetCardSettings"

BOOL GetCardSettings( HINSTANCE hInst, HWND hOwner, LPGUID pguidPlayback, LPGUID pguidRecord )
{
	if( DialogBox( hInst, MAKEINTRESOURCE( IDD_DIALOG_SOUND ), hOwner, SoundDialog_WinProc ) == IDOK )
	{
		*pguidPlayback = g_guidPlayback;
		*pguidRecord = g_guidRecord;
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\voice.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        voice.h
 *  Content:	 Voice Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *
 ***************************************************************************/
#ifndef __VOICE_H

BOOL VoiceManager_Start( PDXVHELP_RTINFO prtInfo );
BOOL VoiceManager_Stop( PDXVHELP_RTINFO prtInfo );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\voice.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        voice.cpp
 *  Content:	 Voice Support Routines
 *  History:
 *
 *   Date		By		Reason
 *   ====		==		======
 *  10/15/99	rodtoll	created it
 *   			rodtoll	Plugged resource leak
 *  10/20/99	rodtoll	Fix: Bug #113686 Not shutting down when receiving lobby message
 *  10/25/99	rodtoll	Removed lpszVoicePassword member from sessiondesc  
 *  10/28/99	pnewson Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/02/99	rodtoll	Bug #116677 - Can't use lobby clients that don't hang around
 *  11/12/99	rodtoll	Added support for the new waveIN/waveOut flags and the 
 *					    echo suppression flag.  
 *  11/29/99	rodtoll	Bug #120249 - Modem host does not wait for connections.  Added
 *						message loop in voice thread.
 *  12/01/99	rodtoll	Updated to use user selections for playback/record device
 *  12/07/99	rodtoll	Bug #122628 Make error messages silent when running in silent mode
 *  12/08/99	rodtoll	Bug #121054 Added support for flags to control new capture focus
 *  01/10/2000	pnewson	Added support for dynamic Tx and Rx display for AGC & VA tuning
 *  01/14/2000	rodtoll	Updated with API changes
 *  01/27/2000	rodtoll	Updated with API changes
 *  01/28/2000	rodtoll	Updated so Volume Set failures don't exit app (for records w/o volume)
 *  02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  06/21/2000	rodtoll	Bug #35767 - Implement ability for Dsound effects processing if dpvoice buffers
 *						Updated DPVHELP to use new parameters
 *  06/27/2000	rodtoll	Added support for new host migration message
 *  06/28/2000 rodtoll	Prefix Bug #38033
 *  08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *  04/02/2001 	simonpow	Bug #354859 - Fixes for PREfast
 * 							(removal unecessary local vars in DVMessageHandlerClient) 
 *
 ***************************************************************************/

#include "dxvhelppch.h"


#define DVHELPER_CONNECT_TIMEOUT		15000
#define DPLSYS_LOBBYCLIENTRELEASE		0x0000000B

void VoiceManager_DisplayStatus( PDXVHELP_RTINFO prtInfo, LPTSTR lpstrStatus )
{
	if( prtInfo->hMainDialog )
	{
		MainDialog_DisplayStatus( prtInfo->hMainDialog, lpstrStatus );
	}
}

BOOL VoiceManager_LobbyConnect( PDXVHELP_RTINFO prtInfo )
{
	HRESULT hr;
	LPBYTE lpBuffer = NULL;
	DWORD dwSize = 0;
	BYTE *lpAddressBuffer = NULL; 
	DWORD dwAddressSize = 0;	
	LPDPLCONNECTION lpdplConnection = NULL;
	LPDPLMSG_GENERIC lpdlmGeneric = NULL;
	DWORD dwFlags;

	hr = CoCreateInstance( DPLAY_CLSID_DPLOBBY, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayLobby3A, (void **) &prtInfo->lpdpLobby );

	if( FAILED( hr ) )
    {
		DPVDX_DPERRDisplay( hr, _T("Unable to to get ct info"), prtInfo->dxvParameters.fSilent);		
		return FALSE;
    }
    
    dwSize = 0;

    if( prtInfo->dxvParameters.fWaitForSettings )
    {
   		VoiceManager_DisplayStatus( prtInfo, _T("Waiting for settings") );
   		
    	hr = prtInfo->lpdpLobby->WaitForConnectionSettings( 0 );

    	if( FAILED( hr ) )
    	{
    		DPVDX_DPERRDisplay( hr, _T("WaitForConnection FAILED"), prtInfo->dxvParameters.fSilent );
    		goto LOBBY_CONNECT_CLEANUP;
    	}

    	lpBuffer = new BYTE[2000];
    	lpdlmGeneric = (LPDPLMSG_GENERIC) lpBuffer;

    	while( 1 )
    	{
			if( WaitForSingleObject( prtInfo->hShutdown, 0 ) != WAIT_TIMEOUT )
			{
				goto LOBBY_CONNECT_CLEANUP;
			}

    		dwSize = 2000;
    		
    		hr = prtInfo->lpdpLobby->ReceiveLobbyMessage( 0, 0, &dwFlags, lpBuffer, &dwSize );

    		if( hr == DP_OK ) 
    		{
    			if( lpdlmGeneric->dwType == DPLSYS_NEWCONNECTIONSETTINGS )
    			{
    				break;
    			}
    		}

    		Sleep( 50 );
    	}

    	delete [] lpBuffer;
    	lpBuffer = NULL;
    }

	VoiceManager_DisplayStatus( prtInfo, _T("Getting Settings") );    

    hr = prtInfo->lpdpLobby->GetConnectionSettings( 0, NULL, &dwSize );

    if( hr != DPERR_BUFFERTOOSMALL )
    {
    	DPVDX_DPERRDisplay( hr, _T("Error retrieving connection settings size"), prtInfo->dxvParameters.fSilent );
    	goto LOBBY_CONNECT_CLEANUP;
    }

    lpBuffer = new BYTE[dwSize];

	if( lpBuffer == NULL )
	{
		DPVDX_DPERRDisplay( DVERR_OUTOFMEMORY, _T("Failure allocating memory"), prtInfo->dxvParameters.fSilent );
		goto LOBBY_CONNECT_CLEANUP;
	}

    lpdplConnection = (LPDPLCONNECTION) lpBuffer;

    hr = prtInfo->lpdpLobby->GetConnectionSettings( 0, lpBuffer, &dwSize );

    if( FAILED( hr ) )
    {
    	DPVDX_DPERRDisplay( hr, _T("Failed to retrieve settings"), prtInfo->dxvParameters.fSilent );
		goto LOBBY_CONNECT_CLEANUP;
    }

	// If we're connecting to a session we need to find the session
	if( !(lpdplConnection->dwFlags & DPLCONNECTION_CREATESESSION) )
	{
		prtInfo->dxvParameters.fHost = FALSE;
	
		VoiceManager_DisplayStatus( prtInfo, _T("Finding Session") ); 
		
	}
	else
	{

		// Over-ride protocol settings from lobby launch
		lpdplConnection->lpSessionDesc->dwFlags |= DPSESSION_DIRECTPLAYPROTOCOL | DPSESSION_KEEPALIVE | DPSESSION_MIGRATEHOST;

		prtInfo->dxvParameters.fHost = TRUE;
		
		// Launching from a session where the GetPlayerAddress on the server doesn't
		// allow getting a player's address 
		if( lpdplConnection->lpAddress == NULL )
		{
			DPCOMPOUNDADDRESSELEMENT element;

			element.guidDataType = DPAID_ServiceProvider;
			element.dwDataSize = sizeof( GUID );
			element.lpData = &lpdplConnection->guidSP;

			hr = prtInfo->lpdpLobby->CreateCompoundAddress( &element, 1, NULL, &dwAddressSize );

			if( hr != DPERR_BUFFERTOOSMALL )
			{
				DPVDX_DPERRDisplay( hr, _T("Unable to create compound address for session host"), prtInfo->dxvParameters.fSilent );
				goto LOBBY_CONNECT_CLEANUP;
			}

			lpAddressBuffer = new BYTE[dwAddressSize];

			hr = prtInfo->lpdpLobby->CreateCompoundAddress( &element, 1, lpAddressBuffer, &dwAddressSize );

			if( FAILED( hr ) )
			{
				DPVDX_DPERRDisplay( hr, _T("Unable to create compound address for session host"), prtInfo->dxvParameters.fSilent );
				goto LOBBY_CONNECT_CLEANUP;
			}			

			lpdplConnection->lpAddress = lpAddressBuffer;
			lpdplConnection->dwAddressSize = dwAddressSize;
		}
	}

	hr = prtInfo->lpdpLobby->SetConnectionSettings( 0, 0, lpdplConnection );

	if( FAILED( hr ) )
	{
		DPVDX_DPERRDisplay( hr, _T("Unable to set connection settings"), prtInfo->dxvParameters.fSilent );
		goto LOBBY_CONNECT_CLEANUP;
	}	

	prtInfo->hLobbyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	hr = prtInfo->lpdpLobby->SetLobbyMessageEvent( 0, 0, prtInfo->hLobbyEvent );

	VoiceManager_DisplayStatus( prtInfo, _T("Connect/Start") ); 	

    hr = prtInfo->lpdpLobby->ConnectEx( 0, IID_IDirectPlay4A, (void **) &prtInfo->lpdpDirectPlay, NULL );

    if( FAILED( hr ) )
    {
    	DPVDX_DPERRDisplay( hr, _T("Failed to ConnectEx"), prtInfo->dxvParameters.fSilent );
		goto LOBBY_CONNECT_CLEANUP;
    }

    prtInfo->hReceiveEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

	hr = prtInfo->lpdpDirectPlay->CreatePlayer( &prtInfo->dpidLocalPlayer, NULL, prtInfo->hReceiveEvent, NULL, 0, 0 );    

	if( FAILED( hr ) )
	{
		DPVDX_DPERRDisplay( hr, _T("CreatePlayer Failed"), prtInfo->dxvParameters.fSilent );
		goto LOBBY_CONNECT_CLEANUP;
	}	

	if( lpBuffer )
		delete [] lpBuffer;
	
    return TRUE;

LOBBY_CONNECT_CLEANUP:

	if( prtInfo->lpdpLobby != NULL )
	{
		prtInfo->lpdpLobby->Release();
	}

	if( lpAddressBuffer != NULL )
	{
		delete [] lpAddressBuffer;
	}

	if( lpBuffer != NULL )
	{
		delete [] lpBuffer;
	}

	if( prtInfo->lpdpDirectPlay != NULL )
	{
		 prtInfo->lpdpDirectPlay->Release();
	}

	return FALSE;
	
}

BOOL VoiceManager_StandardConnect( PDXVHELP_RTINFO prtInfo )
{
	HRESULT hr;
    DWORD dwFlags = 0;
    GUID guidInstance;

	VoiceManager_DisplayStatus( prtInfo, _T("Creating dplay") );

	hr = CoCreateInstance( DPLAY_CLSID_DPLAY, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlay4A, (void **) &prtInfo->lpdpDirectPlay );

	if( FAILED( hr ) )
    {
    	DPVDX_DPERRDisplay( hr, _T("Unable to Create Lobby Object"), prtInfo->dxvParameters.fSilent );
		return FALSE;
    }

    hr = DPVDX_DP_Init( prtInfo->lpdpDirectPlay, DPSPGUID_TCPIP, (prtInfo->dxvParameters.fHost) ? NULL : prtInfo->dxvParameters.lpszConnectAddress );

    if( FAILED( hr ) )
    {
    	DPVDX_DPERRDisplay( hr, _T("Initialize DirectPlay"), prtInfo->dxvParameters.fSilent );
    	return FALSE;
    }

    if( prtInfo->dxvParameters.fHost )
    {
    	dwFlags = DPSESSION_KEEPALIVE | DPSESSION_DIRECTPLAYPROTOCOL;

		if( prtInfo->dxvParameters.dwSessionType == DVSESSIONTYPE_PEER )
		{
			dwFlags |= DPSESSION_MIGRATEHOST;
		}

		VoiceManager_DisplayStatus( prtInfo, _T("Starting Session")  );		

     	hr = DPVDX_DP_StartSession( prtInfo->lpdpDirectPlay, DPVHELP_PUBLIC_APPID, dwFlags, NULL, NULL, 0, &prtInfo->dpidLocalPlayer, &prtInfo->hReceiveEvent, &guidInstance ) ;

    	if( FAILED( hr ) )
    	{
	    	DPVDX_DPERRDisplay( hr, _T("Starting Session"), prtInfo->dxvParameters.fSilent );    		
	    	return FALSE;
    	}
    }
    else
    {
		VoiceManager_DisplayStatus( prtInfo, _T("Finding Session") );
    
    	hr = DPVDX_DP_FindSessionGUID( prtInfo->lpdpDirectPlay, DPVHELP_PUBLIC_APPID, DVHELPER_CONNECT_TIMEOUT, &guidInstance );

    	if( FAILED( hr ) )
    	{
    		DPVDX_DPERRDisplay( hr, _T("Finding Session"), prtInfo->dxvParameters.fSilent );
    		return FALSE;
    	}

		VoiceManager_DisplayStatus( prtInfo, _T("Connecting") );    	
    	
    	hr = DPVDX_DP_ConnectToSession( prtInfo->lpdpDirectPlay, DPVHELP_PUBLIC_APPID, guidInstance, NULL, &prtInfo->dpidLocalPlayer, &prtInfo->hReceiveEvent );

    	if( FAILED( hr ) )
    	{
    		DPVDX_DPERRDisplay( hr, _T("Connect To Session"), prtInfo->dxvParameters.fSilent );
    		return FALSE;
    	}
    }

    VoiceManager_DisplayStatus( prtInfo, _T("Dplay started") );

    return TRUE;
}



HRESULT PASCAL DVMessageHandlerServer( 
	LPVOID 		lpvUserContext,
	DWORD 		dwMessageType,
	LPVOID    	lpMessage
)
{
    TCHAR szTmpString[180];
	PDXVHELP_RTINFO prtInfo = (PDXVHELP_RTINFO) lpvUserContext;
    
	PDVMSG_SESSIONLOST pdvSessionLost = NULL;
	PDVMSG_DELETEVOICEPLAYER pdvDeletePlayer = NULL; 
	PDVMSG_CREATEVOICEPLAYER pdvCreatePlayer = NULL;

	switch( dwMessageType )
	{
	case DVMSGID_CREATEVOICEPLAYER:

	    pdvCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) lpMessage;
		pdvCreatePlayer->pvPlayerContext = (PVOID) (DWORD_PTR) pdvCreatePlayer->dvidPlayer;

        _stprintf( szTmpString, _T("[DVMSGID_CREATEVOICEPLAYER] **SERVER** ID=0x%x"), pdvCreatePlayer->dvidPlayer );
        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );    	    
		break;
	case DVMSGID_DELETEVOICEPLAYER:

        pdvDeletePlayer = (PDVMSG_DELETEVOICEPLAYER) lpMessage;

        _stprintf( szTmpString, _T("[DVMSGID_DELETEVOICEPLAYER] **SERVER** ID=0x%x"), pdvDeletePlayer->dvidPlayer );
        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );    	    
		break;
	case DVMSGID_SESSIONLOST:

	    pdvSessionLost = (PDVMSG_SESSIONLOST) lpMessage;
	        
        _stprintf( szTmpString, _T("[DVMSGID_SESSIONLOST] **SERVER** Reason=0x%x"), pdvSessionLost->hrResult );

        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
	    
		if( !prtInfo->dxvParameters.fSilent )
		{
			MessageBox( NULL, _T("Server Session lost!"),_T("Voice Conference"),  MB_OK );
		}
		SetEvent( prtInfo->hShutdown );
		break;
	}

	return DV_OK;
}


HRESULT PASCAL DVMessageHandlerClient( 
	LPVOID 		lpvUserContext,
	DWORD 		dwMessageType,
	LPVOID  	lpMessage
)
{
    TCHAR szTmpString[180];
    
	PDXVHELP_RTINFO prtInfo = (PDXVHELP_RTINFO) lpvUserContext;
	HWND hwndItem = NULL;
	PDVMSG_INPUTLEVEL pdvInputLevel = NULL;
	PDVMSG_OUTPUTLEVEL pdvOutputLevel = NULL;
	PDVMSG_HOSTMIGRATED pdvHostMigrated = NULL;
	PDVMSG_SESSIONLOST pdvSessionLost = NULL;
	PDVMSG_DELETEVOICEPLAYER pdvDeletePlayer = NULL; 
	PDVMSG_CREATEVOICEPLAYER pdvCreatePlayer = NULL;
	PDVMSG_LOCALHOSTSETUP pdvLocalHostSetup = NULL;
	PDVMSG_PLAYERVOICESTART pdvPlayerVoiceStart = NULL;
	PDVMSG_PLAYERVOICESTOP pdvPlayerVoiceStop = NULL;
	PDVMSG_RECORDSTART pdvRecordStart = NULL;
	PDVMSG_RECORDSTOP pdvRecordStop = NULL;

	static int s_iRxCount = 0;
	
	char numBuffer[80];
	
	switch( dwMessageType )
	{
	case DVMSGID_LOCALHOSTSETUP:

		pdvLocalHostSetup = (PDVMSG_LOCALHOSTSETUP) lpMessage;

		_stprintf( szTmpString, _T("[DVMSGID_LOCALHOSTSETUP] Local client is to become host") );
		MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );

		pdvLocalHostSetup->pMessageHandler = DVMessageHandlerServer;
		pdvLocalHostSetup->pvContext = lpvUserContext; 

		break;


	case DVMSGID_CREATEVOICEPLAYER:

	    pdvCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) lpMessage;

        _stprintf( szTmpString, _T("[DVMSGID_CREATEVOICEPLAYER] ID=0x%x"), pdvCreatePlayer->dvidPlayer );
        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );    	    

        MainDialog_AddVoicePlayer( prtInfo->hMainDialog, pdvCreatePlayer->dvidPlayer );
	        
		prtInfo->dwNumClients++;
		wsprintf( numBuffer, "%d", prtInfo->dwNumClients );

		if( prtInfo->hMainDialog != NULL )
		{
			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_PLAYERS );

			if( hwndItem != NULL )
			{
				SetWindowText( hwndItem, numBuffer );
			}
		}

		pdvCreatePlayer->pvPlayerContext = (PVOID) (DWORD_PTR) pdvCreatePlayer->dvidPlayer;

		break;
	case DVMSGID_DELETEVOICEPLAYER:

        pdvDeletePlayer = (PDVMSG_DELETEVOICEPLAYER) lpMessage;

        _stprintf( szTmpString, _T("[DVMSGID_DELETEVOICEPLAYER] ID=0x%x"), pdvDeletePlayer->dvidPlayer );
        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );    	    

        MainDialog_RemoveVoicePlayer( prtInfo->hMainDialog, pdvDeletePlayer->dvidPlayer );        
	    
		prtInfo->dwNumClients--;
		wsprintf( numBuffer, "%d", prtInfo->dwNumClients );		
		if( prtInfo->hMainDialog != NULL )
		{
			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_PLAYERS );

			if( hwndItem != NULL )
			{
				SetWindowText( hwndItem, numBuffer );
			}
		}
		break;
	case DVMSGID_SESSIONLOST:

	    pdvSessionLost = (PDVMSG_SESSIONLOST) lpMessage;
	        
        _stprintf( szTmpString, _T("[DVMSGID_SESSIONLOST] Reason=0x%x"), pdvSessionLost->hrResult );

        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
	    
		if( !prtInfo->dxvParameters.fSilent )
		{
			MessageBox( NULL, _T("Session lost!"),_T("Voice Conference"),  MB_OK );
		}
		SetEvent( prtInfo->hShutdown );
		break;
	case DVMSGID_INPUTLEVEL:
		pdvInputLevel = (PDVMSG_INPUTLEVEL) lpMessage;
		
		if( prtInfo->hMainDialog != NULL )
		{
			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_PROGRESS_TX );

			if( hwndItem != NULL )
			{
				SendMessage( hwndItem, PBM_SETPOS, (WPARAM) pdvInputLevel->dwPeakLevel, 0 );
			}
		}
		break;
	case DVMSGID_OUTPUTLEVEL:
		pdvOutputLevel = (PDVMSG_OUTPUTLEVEL) lpMessage;

		if( prtInfo->hMainDialog != NULL )	
		{
			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_PROGRESS_RX );

			if( hwndItem != NULL )
			{
				SendMessage( hwndItem, PBM_SETPOS, (WPARAM) pdvOutputLevel->dwPeakLevel, 0 );
			}
		}
		break;
	case DVMSGID_RECORDSTART:
		if( prtInfo->hMainDialog != NULL )
		{
			pdvRecordStart = (PDVMSG_RECORDSTART) lpMessage;

			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_TX );

			if( hwndItem != NULL )
			{
				SendMessage( hwndItem, WM_SETTEXT, NULL, (LPARAM)"Tx" );
			}

			_stprintf( szTmpString, _T("[DVMSGID_RECORDSTART]") );
			MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
		}
		break;
	case DVMSGID_RECORDSTOP:
		if( prtInfo->hMainDialog != NULL )
		{
			pdvRecordStop = (PDVMSG_RECORDSTOP) lpMessage;

			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_TX );

			if( hwndItem != NULL )
			{
				SendMessage( hwndItem, WM_SETTEXT, NULL, (LPARAM)"" );
			}
			_stprintf( szTmpString, _T("[DVMSGID_RECORDSTOP]") );
			MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
		}
		break;
	case DVMSGID_PLAYERVOICESTART:

		pdvPlayerVoiceStart = (PDVMSG_PLAYERVOICESTART) lpMessage;

		if( prtInfo->hMainDialog != NULL )
		{
			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_RX );

			if( hwndItem != NULL )
			{
				++s_iRxCount;
				SendMessage( hwndItem, WM_SETTEXT, NULL, (LPARAM)"Rx" );
			}
			_stprintf( szTmpString, _T("[DVMSGID_PLAYERVOICESTART] ID=0x%x"), 
						pdvPlayerVoiceStart->dvidSourcePlayerID );
			MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
		}
		break;
	case DVMSGID_PLAYERVOICESTOP:

		pdvPlayerVoiceStop = (PDVMSG_PLAYERVOICESTOP) lpMessage;

		if( prtInfo->hMainDialog != NULL )
		{
			hwndItem = GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_RX );

			if( hwndItem != NULL )
			{
				--s_iRxCount;
				if (s_iRxCount <= 0)
				{
					SendMessage( hwndItem, WM_SETTEXT, NULL, (LPARAM)"" );
				}
			}

			_stprintf( szTmpString, _T("[DVMSGID_PLAYERVOICESTOP] ID=0x%x"),  
						pdvPlayerVoiceStop->dvidSourcePlayerID );
			MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
		}
		break;
	case DVMSGID_HOSTMIGRATED:
		pdvHostMigrated = (PDVMSG_HOSTMIGRATED) lpMessage;

		_stprintf( szTmpString, _T("0x%x"), pdvHostMigrated->dvidNewHostID );
		    
		SetWindowText( GetDlgItem( prtInfo->hMainDialog, IDC_STATIC_HOST ), szTmpString );

        _stprintf( szTmpString, _T("[DVMSGID_HOSTMIGRATED] New Voice Host=0x%x Local=%s"), pdvHostMigrated->dvidNewHostID, pdvHostMigrated->pdvServerInterface ? _T("Yes") : _T("No") );

        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );
		
		break;
	case DVMSGID_LOSTFOCUS:
		if( prtInfo->hMainDialog != NULL )
		{
			VoiceManager_DisplayStatus( prtInfo, _T( "Connected (Focus Lost)" ) );
		}
        _stprintf( szTmpString, _T("[DVMSGID_LOSTFOCUS]" ) );		
        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );        
		break;
	case DVMSGID_GAINFOCUS:
		if( prtInfo->hMainDialog != NULL )
		{
			VoiceManager_DisplayStatus( prtInfo, _T( "Connected" ) );
		}	
        _stprintf( szTmpString, _T("[DVMSGID_GAINFOCUS]" ));		
        MainDialog_AddToLog( prtInfo->hMainDialog, szTmpString );        
		break;
	default:
		break;
	}

	return DV_OK;
}

void VoiceManager_MessageLoop( PDXVHELP_RTINFO prtInfo )
{
	LPBYTE lpbDataBuffer = (LPBYTE) new BYTE[30000];

	if( lpbDataBuffer == NULL )
	{
		goto BREAK_OUT;
	}

	DWORD dwSize;
	HRESULT hr;
	LONG lWakeResult;
	DWORD dwFlags;
	MSG msg;
	HANDLE hEvents[3];
	LPDPLMSG_SYSTEMMESSAGE lpSysMessage;
	LPDPMSG_GENERIC lpGenericMessage;
	LPDPMSG_CREATEPLAYERORGROUP lpCreatePlayerMessage;
	LPDPMSG_DESTROYPLAYERORGROUP lpDeletePlayerMessage;
	BOOL bGotMsg;
	DPID dpidFrom, dpidTo;

	hEvents[0] = prtInfo->hShutdown;
	hEvents[1] = prtInfo->hReceiveEvent;
	hEvents[2] = prtInfo->hLobbyEvent;	

//	hr = prtInfo->lpdpDirectPlay->CreatePlayer( &prtInfo->dpidLocalPlayer, NULL, prtInfo->hReceiveEvent, NULL, 0, 0 );   	

	while( 1 )
	{
		if( !prtInfo->dxvParameters.fLobbyLaunched )
		{
			lWakeResult = MsgWaitForMultipleObjects( 2, hEvents, FALSE, INFINITE, QS_ALLINPUT);
		}
		else
		{
			lWakeResult = MsgWaitForMultipleObjects( 3, hEvents, FALSE, INFINITE, QS_ALLINPUT);
		}

		if( lWakeResult == WAIT_OBJECT_0 )
		{
			break;
		}
		else if( lWakeResult == (WAIT_OBJECT_0+1) )
		{
		    while( 1 )
		    {
		        dwSize = 30000;
		        
		        hr = prtInfo->lpdpDirectPlay->Receive( &dpidFrom, &dpidTo, DPRECEIVE_ALL, lpbDataBuffer, &dwSize );

		        if( hr == DPERR_NOMESSAGES )
		        {
		            break;
		        }

		        lpGenericMessage = (LPDPMSG_GENERIC) lpbDataBuffer;

                switch( lpGenericMessage->dwType )
                {
                case DPSYS_HOST:
                    {
                        MainDialog_AddToLog( prtInfo->hMainDialog, _T("[DPMSG_HOST] This client has just become the DPLAY host") );
                    }
                    break;
                case DPSYS_CREATEPLAYERORGROUP:
                    {
                        TCHAR tszMessage[100];
                        
                        lpCreatePlayerMessage = (LPDPMSG_CREATEPLAYERORGROUP) lpbDataBuffer;

                        if( lpCreatePlayerMessage->dwPlayerType == DPPLAYERTYPE_PLAYER )
                        {
                            _stprintf( tszMessage, _T("[DPMSG_CREATEPLAYER] Client 0x%x has just entered the session."), lpCreatePlayerMessage->dpId );
                            MainDialog_AddToLog( prtInfo->hMainDialog, tszMessage );                        
                        }

                        MainDialog_AddTransportPlayer( prtInfo->hMainDialog, lpCreatePlayerMessage->dpId );
                    }
                    break;                    
                case DPSYS_DESTROYPLAYERORGROUP:
                    {
                        TCHAR tszMessage[100];
                        
                        lpDeletePlayerMessage = (LPDPMSG_DESTROYPLAYERORGROUP) lpbDataBuffer;

                        if( lpDeletePlayerMessage->dwPlayerType == DPPLAYERTYPE_PLAYER )
                        {
                            _stprintf( tszMessage, _T("[DPMSG_DELETEPLAYER] Client 0x%x has just left the session."), lpDeletePlayerMessage->dpId );                            
                            MainDialog_AddToLog( prtInfo->hMainDialog, tszMessage );                        
                        }

                        MainDialog_RemoveTransportPlayer( prtInfo->hMainDialog, lpDeletePlayerMessage->dpId );                        
                    }
                    break;                    
                }

		    }
		}
		else if( prtInfo->dxvParameters.fLobbyLaunched && lWakeResult == (WAIT_OBJECT_0+2) )
		{
			hr = DP_OK;

			while( hr != DPERR_NOMESSAGES )
			{
				dwSize = 30000;
				
	    		hr = prtInfo->lpdpLobby->ReceiveLobbyMessage( 0, 0, &dwFlags, lpbDataBuffer, &dwSize );

				if( hr == DPERR_NOMESSAGES )
				{
					break;
				}
				else if( hr == DP_OK )
				{
					if( !prtInfo->dxvParameters.fIgnoreLobbyDestroy )
					{
				 		if( dwFlags == 0 )
			    		{
			    			goto BREAK_OUT;
			    		}			 
						else if( dwFlags && DPLMSG_SYSTEM )
						{
							lpSysMessage = (LPDPLMSG_SYSTEMMESSAGE) lpbDataBuffer;

							if( lpSysMessage->dwType == DPLSYS_LOBBYCLIENTRELEASE )
							{
								goto BREAK_OUT;
							}
						}
					}
		    	}
		    	else
		    	{
					DPVDX_DPERRDisplay( hr, _T("Receive Lobby Message Error"), prtInfo->dxvParameters.fSilent );			    	
		    	}
			}
		}
		else
		{
			bGotMsg = TRUE;
			
			while( bGotMsg )
			{
				bGotMsg = PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE );

				if( bGotMsg )
				{
					TranslateMessage( &msg );
					DispatchMessage( &msg );
				}
			}		
		}
	}

BREAK_OUT:

	if( lpbDataBuffer )
		delete [] lpbDataBuffer; 

	return;
}

void VoiceManager_Shutdown( PDXVHELP_RTINFO prtInfo )
{
	HRESULT hr;
	
	VoiceManager_DisplayStatus( prtInfo, _T("Disconnecting") ); 					

	if( prtInfo->lpdpLobby != NULL )
	{
		prtInfo->lpdpLobby->Release();
	    prtInfo->lpdpLobby = NULL;
	}

	if( prtInfo->lpdvClient != NULL )
	{
		VoiceManager_DisplayStatus( prtInfo, _T("Disconnecting") ); 						
		
		hr = prtInfo->lpdvClient->Disconnect( DVFLAGS_SYNC );

		if( FAILED( hr ) )
		{
			DPVDX_DPERRDisplay( hr, _T("Disconnect FAILED "), prtInfo->dxvParameters.fSilent );
		}
		
		prtInfo->lpdvClient->Release();
	}	

	if( prtInfo->lpdvServer != NULL )
	{
		VoiceManager_DisplayStatus( prtInfo, _T("Stopping Session") ); 						
		
		hr = prtInfo->lpdvServer->StopSession( 0 );

		if( FAILED( hr ) ) 
		{
			DPVDX_DPERRDisplay( hr, _T("StopSession FAILED "), prtInfo->dxvParameters.fSilent );
		}

		prtInfo->lpdvServer->Release();
	}

	if( prtInfo->lpdpDirectPlay != NULL )
	{
		VoiceManager_DisplayStatus( prtInfo, _T("Stopping Dplay") ); 						
		prtInfo->lpdpDirectPlay->Close();
		prtInfo->lpdpDirectPlay->Release();
	} 

	CloseHandle( prtInfo->hReceiveEvent );

	if( prtInfo->hLobbyEvent != NULL )
	{
		CloseHandle( prtInfo->hLobbyEvent );
	}

	MainDialog_SetIdleState( prtInfo->hMainDialog, prtInfo );		

}

BOOL VoiceManager_VoiceConnect( PDXVHELP_RTINFO prtInfo )
{
	DVSESSIONDESC dvSessionDesc;
	DVCLIENTCONFIG dvClientConfig;
	DVSOUNDDEVICECONFIG dvSoundDeviceConfig;
	HRESULT hr;
	DVID dvidAllPlayers = DVID_ALLPLAYERS;	

	// We're the host
    if( prtInfo->dxvParameters.fHost ) 
    {
		VoiceManager_DisplayStatus( prtInfo, _T("Start Voice Host") ); 	
    
		hr = CoCreateInstance( DPVOICE_CLSID_DPVOICE, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayVoiceServer, (void **) &prtInfo->lpdvServer );

		if( FAILED( hr ) )
		{
			DPVDX_DVERRDisplay( hr, _T("Create of voice server failed"), prtInfo->dxvParameters.fSilent );
			goto EXIT_CLEANUP;
		}

		hr = prtInfo->lpdvServer->Initialize( prtInfo->lpdpDirectPlay, DVMessageHandlerServer, prtInfo, NULL, 0 );

		if( FAILED( hr ) )
		{
			DPVDX_DVERRDisplay( hr, _T("Initialize FAILED"), prtInfo->dxvParameters.fSilent );
			goto EXIT_CLEANUP;
		}

		dvSessionDesc.dwSize = sizeof( DVSESSIONDESC );
		dvSessionDesc.dwBufferAggressiveness = DVBUFFERAGGRESSIVENESS_DEFAULT;
		dvSessionDesc.dwBufferQuality = DVBUFFERQUALITY_DEFAULT;
		dvSessionDesc.dwFlags = 0;
		dvSessionDesc.dwSessionType = prtInfo->dxvParameters.dwSessionType;
		dvSessionDesc.guidCT = prtInfo->dxvParameters.guidCT;

		hr = prtInfo->lpdvServer->StartSession( &dvSessionDesc, 0 );

		if( FAILED( hr ) )
		{
			DPVDX_DVERRDisplay( hr, _T("StartSession FAILED"), prtInfo->dxvParameters.fSilent );
			goto EXIT_CLEANUP;
		}
	}

	VoiceManager_DisplayStatus( prtInfo, _T("Start Client") ); 		

	hr = CoCreateInstance( DPVOICE_CLSID_DPVOICE, NULL, CLSCTX_INPROC_SERVER, IID_IDirectPlayVoiceClient, (void **) &prtInfo->lpdvClient );

	if( FAILED( hr ) )
	{
		DPVDX_DVERRDisplay( hr, _T("Create of client failed"), prtInfo->dxvParameters.fSilent );
		goto EXIT_CLEANUP;
	}

	hr = prtInfo->lpdvClient->Initialize( prtInfo->lpdpDirectPlay, DVMessageHandlerClient, prtInfo, NULL, 0 );

	if( FAILED( hr ) )
	{
		DPVDX_DVERRDisplay( hr, _T("Initialize FAILED"), prtInfo->dxvParameters.fSilent );
		goto EXIT_CLEANUP;
	}

	dvSoundDeviceConfig.dwSize = sizeof( DVSOUNDDEVICECONFIG );
	dvSoundDeviceConfig.hwndAppWindow = prtInfo->hMainWnd;
	dvSoundDeviceConfig.dwFlags = 0;

	if( prtInfo->dxvParameters.fForceWaveOut ) 
	{
		dvSoundDeviceConfig.dwFlags	|= DVSOUNDCONFIG_FORCEWAVEOUT;
	}
	else if( prtInfo->dxvParameters.fAllowWaveOut )
	{
		dvSoundDeviceConfig.dwFlags	|= 	DVSOUNDCONFIG_ALLOWWAVEOUT;
	}
	
	if( prtInfo->dxvParameters.fForceWaveIn ) 
	{
		dvSoundDeviceConfig.dwFlags	|= 	DVSOUNDCONFIG_FORCEWAVEIN;
	}
	else if( prtInfo->dxvParameters.fAllowWaveIn )
	{
		dvSoundDeviceConfig.dwFlags	|= 	DVSOUNDCONFIG_ALLOWWAVEIN;
	}	

	if( prtInfo->dxvParameters.fAutoSelectMic )
	{
		dvSoundDeviceConfig.dwFlags	|= 	DVSOUNDCONFIG_AUTOSELECT;	
	}

	if( prtInfo->dxvParameters.fDisableFocus )
	{
		dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_NOFOCUS;
	}
	else if( prtInfo->dxvParameters.fStrictFocus )
	{
		dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_STRICTFOCUS;
	}

	dvSoundDeviceConfig.guidCaptureDevice = prtInfo->dxvParameters.guidRecordDevice;
	dvSoundDeviceConfig.guidPlaybackDevice = prtInfo->dxvParameters.guidPlaybackDevice;
	dvSoundDeviceConfig.lpdsPlaybackDevice = NULL;
	dvSoundDeviceConfig.lpdsCaptureDevice = NULL;
	dvSoundDeviceConfig.lpdsMainBuffer = NULL;
	dvSoundDeviceConfig.dwMainBufferFlags = 0;
	dvSoundDeviceConfig.dwMainBufferPriority = 0;

	dvClientConfig.lRecordVolume = DSBVOLUME_MAX;
	
	MicrophoneGetVolume( 0, dvClientConfig.lRecordVolume );

	prtInfo->dxvParameters.lRecordVolume = dvClientConfig.lRecordVolume;

	dvClientConfig.dwFlags = DVCLIENTCONFIG_AUTOVOICEACTIVATED;

	if( prtInfo->dxvParameters.fAGC )
	{
		dvClientConfig.dwFlags |= DVCLIENTCONFIG_AUTORECORDVOLUME;	
		dvClientConfig.lRecordVolume = DVRECORDVOLUME_LAST;
	}

	if( prtInfo->dxvParameters.fEchoSuppression )
	{
		dvClientConfig.dwFlags |= DVCLIENTCONFIG_ECHOSUPPRESSION;
	}
	
	dvClientConfig.dwThreshold = DVTHRESHOLD_UNUSED;
	dvClientConfig.lPlaybackVolume = DSBVOLUME_MAX;
	dvClientConfig.dwNotifyPeriod = 51;
	dvClientConfig.dwBufferQuality = DVBUFFERQUALITY_DEFAULT;
	dvClientConfig.dwBufferAggressiveness = DVBUFFERAGGRESSIVENESS_DEFAULT;
	
	dvClientConfig.dwSize = sizeof( DVCLIENTCONFIG );

	VoiceManager_DisplayStatus( prtInfo, _T("Connecting Voice") ); 			

	hr = prtInfo->lpdvClient->Connect( &dvSoundDeviceConfig, &dvClientConfig, DVFLAGS_SYNC );

	if( hr != DV_OK && hr != DVERR_PENDING )
	{
		DPVDX_DVERRDisplay( hr, _T("Connect FAILED"), prtInfo->dxvParameters.fSilent );
		goto EXIT_CLEANUP;
	}

	MainDialog_DisplayVolumeSettings( prtInfo->hMainDialog, prtInfo );

	VoiceManager_DisplayStatus( prtInfo, _T("Connected") ); 				

	MainDialog_ShowSessionSettings( prtInfo->hMainDialog, prtInfo);	

	prtInfo->lpdvClient->SetTransmitTargets( &dvidAllPlayers, 1, 0 );

	return TRUE;

EXIT_CLEANUP:

	if( prtInfo->lpdvClient != NULL )
	{
		prtInfo->lpdvClient->Release();
	}

	if( prtInfo->lpdvServer != NULL )
	{
		prtInfo->lpdvServer->Release();
	}

	MainDialog_SetIdleState( prtInfo->hMainDialog, prtInfo );

	VoiceManager_DisplayStatus( prtInfo, _T("Aborted") ); 		

	return FALSE;
}

// ManagerThread
//
// This thread is responsible for running the session, allowing the main interface
// to remain responsive.
//
DWORD WINAPI VoiceManager_ThreadProc( LPVOID lpParameter )
{
	PDXVHELP_RTINFO prtInfo = (PDXVHELP_RTINFO) lpParameter;
	BOOL fResult;
	HANDLE hEventArray[2];

	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

	if( FAILED( hr ) )
	{
		goto EXIT_ERROR;
	}

	hEventArray[0] = prtInfo->hShutdown;	// Cancel
	hEventArray[1] = prtInfo->hGo;			// Start Session

	// Wait to be cancelled or started
	if( WaitForMultipleObjects( 2, hEventArray, FALSE, INFINITE ) != WAIT_OBJECT_0 )
	{
		if( prtInfo->dxvParameters.fLobbyLaunched )
		{
			fResult = VoiceManager_LobbyConnect( prtInfo );
		}
		else
		{
			fResult = VoiceManager_StandardConnect( prtInfo );
		}

		if( fResult )
		{
			fResult = VoiceManager_VoiceConnect( prtInfo );

			if( fResult )
			{
				VoiceManager_MessageLoop( prtInfo );
				VoiceManager_Shutdown( prtInfo );			
			}
		}
	}
	
	CoUninitialize();

EXIT_ERROR:

	SetEvent( prtInfo->hThreadDone );	

    return 0;
}

BOOL VoiceManager_Start( PDXVHELP_RTINFO prtInfo )
{
	DWORD dwThreadID = 0;
	
	prtInfo->hManagerThread = CreateThread( NULL, 0, VoiceManager_ThreadProc, prtInfo, 0, &dwThreadID );

	return TRUE;
}

BOOL VoiceManager_Stop( PDXVHELP_RTINFO prtInfo )
{
	WaitForSingleObject( prtInfo->hThreadDone, INFINITE );

	CloseHandle( prtInfo->hManagerThread );

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvhelp\sources.inc ===
!INCLUDE ..\..\..\bldcfg\dpvbld.inc

#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=$(DPVOICE_BUILD_FILENAME_DPVHELP)


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dxvhelppch.h
PRECOMPILED_PCH=dxvhelppch.pch
PRECOMPILED_OBJ=dxvhelppch.obj
!endif

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\dnet\common\obj$(BUILD_ALT_DIR)\*\common.lib \
           ..\..\dpvxlib\obj$(BUILD_ALT_DIR)\*\dpvxlib.lib \
           $(BASEDIR)\public\sdk\lib\*\comctl32.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\msacm32.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\..\inc;$(DXROOT)\inc;..\..\..\dnet\common;..\..\dpvxlib;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES=..\dxvhelp.cpp \
        ..\hostdlg.cpp \
        ..\conndlg.cpp \
        ..\misc.cpp \
        ..\maindlg.cpp \
        ..\voice.cpp \
	..\snddlg.cpp \
        ..\dxvhelp.rc 


#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_WINDOWS /DWIN32 /D_MT /D_DLL \
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(VOICE_TARGET)" == "allegiance" 
	/DVOICE_BUILD_ALLEGIANCE \
!endif
	/DDIRECTSOUND_VERSION=0x0800

USE_NOLIBS=1

USE_NATIVE_EH=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 *  7/19/99		rodtoll Modified for use in directxvoice
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__


#ifdef __cplusplus
extern "C" {
#endif


extern LONG DecrementObjectCount();
extern LONG IncrementObjectCount();

extern volatile LONG g_lNumObjects;
extern LONG g_lNumLocks;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvcleng.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvclientengine.cpp
 *  Content:	Implementation of class for DirectXVoice Client
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/19/99		rodtoll	Created
 * 07/21/99		rodtoll Added settings confirm message to protocol
 *						Added storing user flags
 * 07/22/99		rodtoll Updated to use new player class
 *                      Improved concurrency protection
 *						Added client/server support
 * 07/23/99		rodtoll	Added multicast support
 *						Modified notify loop, now checks for multicast timeouts
 *						Modified playback loop to kill timed-out users
 *						Minor fixes to client/server support
 *						Other bugfixes.
 *						Removed valid target check in multicast and client/server
 * 07/26/99		rodtoll	Updated to support IDirectXVoiceNotify interface
 * 07/29/99		pnewson Updated call to CInputQueue2 constructor
 * 07/29/99		rodtoll Removed warnings, updated for new queue, added better
 *						parameter checking.
 * 07/30/99		rodtoll	Updated InitializeSound to use the parameters passed
 *						in through the sounddeviceconfig.
 * 08/02/99		rodtoll	Fixed bug in record volume
 * 08/03/99		pnewson	Cleanup of Frame and Queue classes
 * 08/03/99		rodtoll	Fixed calls into the transport
 * 08/04/99		rodtoll	Fixed up Get/SetClientConfig
 *						Added pointer to SoundConfig for second param of connect result
 *					    Half duplex clients won't get record level notifications anymore
 *						Added connect result when error on connect
 *						Modified so that soundeviceconfig gets ptr to dsound/dsc devices
 *						Fixed bug w/sensitivity setting
 * 08/05/99		rodtoll	Fixed locking, was causing deadlock w/DirectPlay
 * 08/10/99		rodtoll	Initial support for host migration
 *				rodtoll	No longer creates a queue for ourselves
 * 08/18/99		rodtoll	Fixed bug w/multicast.  Added support for SPEECHBOUNCE
 * 						message type.
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 * 08/26/99		rodtoll	Added copy of flags when doing SetClientConfig
 *				rodtoll	Fixed playback thread to properly handle playback mute
 * 08/27/99		rodtoll	Fixed record start/stop notifications target info
 *				rodtoll	Added playervoicestart and playervoice stop messages
 * 08/30/99		rodtoll	Fixed disconnect when sound init fails
 *						Fixed disconnect when compression type unsupported
 *						Fixed notification intervals
 *						Added timeouts to connect and disconnect processes
 *						Fixed bug in disconnect code
 *						Added re-transmission of connect request
 *						Fixed host migration notifications
 *						Fixed return code on GetCompressionTypes call.
 *						Updated to use new format specifications on playback
 * 08/31/99		rodtoll	Logic re-write to fix shutdown problems.
 *						- Notify thread now starts as soon as Initialize called
 *						  and stops when object destroyed
 *						- Disconnect based on Disconnectconfirm or loss of 
 *						  connection signals event, notify thread then handles
 *						- Updated playback format to use 8Khz for playback
 * 09/01/99		rodtoll	Added check for valid pointers in func calls
 * 09/02/99		rodtoll	Added checks to handle case no local player created
 *						Re-activated and fixed old auto record volume code
 * 09/03/99		rodtoll	Re-work of playback core to support mixing to multiple buffers
 *						for 3d support.
 *						Re-worked playback to use position instead of notifications
 *						allows for simpler handling of high CPU and 3d support
 *						Implemented CreateUserBuffer/DeleteUserBuffer 
 * 09/04/99		rodtoll	Added code to delete 3d buffers for users/groups when they
 *                      are destroyed.
 * 09/07/99		rodtoll	Added support for server controlled target message
 *				rodtoll	Added support for set/get user buffer for notarget
 *				rodtoll	Fixed InitHalfDuplex call -- was defaulting to default device always 
 * 09/07/99		rodtoll	Placed some guards to fix crash when Releasing when not initialized
 * 09/07/99		rodtoll	Updated to allow buffer management on buffer for remaining users (main buffer)
 *				rodtoll	Updated return codes to use new errors (3d related)
 * 09/08/99		rodtoll	Fixed playback level checking.
 * 09/10/99		rodtoll	Implemented the DVCLIENTCONFIG_MUTEGLOBAL flag
 * 				rodtoll	Additional parameter validations
 * 09/13/99		rodtoll	Added preliminary support for new DVSOUNDDEVICECONFIG structure
 * 09/14/99		rodtoll	Added new DVMSGID_PLAYEROUTPUTLEVEL message
 *				rodtoll	Added new SetNotifyMask function
 *				rodtoll	Updated INiitalize parameters to take notification masks.
 * 				rodtoll	Implemented notification masks.  (Allows user to choose which notifications to receive)
 *				rodtoll	Added CheckShouldSendMessage
 *				rodtoll	Added SendPlayerLevels (DVMSGID_PLAYEROUTPUTLEVEL messages handler)
 * 09/15/99		rodtoll	Added DVMSGID_SETTARGET message when target is set by remote server
 * 09/16/99		rodtoll	Updated Disconnect to alllow async and sync abortions of connects
 * 09/17/99		rodtoll	Fixed bug in recordthread in error handling
 * 09/18/99		rodtoll Added HandleThreadError to be called when an internal thread dies.  
 * 09/20/99		rodtoll	Updated to return SESSIONLOST message instead of DISCONNECT when session is lost
 * 				rodtoll	Functions will return DVERR_SESSIONLOST if called after session is lost.
 *				rodtoll	Improved error checking in playback thread
 *				rodtoll	Added more checks for memory alloc failures
 *				rodtoll	Small bugfix in playeroutputlevel messages
 *				rodtoll	Stricter checks on valid notify arrays
 * 				rodtoll	Added proper error checking to SetNotifyMask
 * 09/27/99		rodtoll	Fixed playback volume control
 *				rodtoll	Fixed bug w/echo servers w/clients running on same dvid as host
 * 09/28/99		rodtoll	Fixed playervoicestart/stop notifications, now send source in the dwFrom param.
 * 				rodtoll	Double notifications of local client when host migrates fixed.
 *				rodtoll	Added queue for notifications, notifications are added to the queue and 
 *						then signalled by the notify thread.  (Prevents problems caused by notify 
 *						handlers taking a long time to return).
 *				rodtoll	Added voice suppression
 * 09/29/99		pnewson Major AGC overhaul
 * 10/04/99		rodtoll	Added usage of the DVPROTOCOL_VERSION_XXX macros
 *              rodtoll	Added comments
 *				rodtoll	Fixed crash which occurs if object released before initialized
 * 10/05/99		rodtoll	Added guards to DoDisconnect.  If recording locked up on shutdown, then 
 * 						DoDisconnect would be called twice --> Crash!  Fixed.
 *              rodtoll	Reversed order of recording/playback shutdown.  Shutting down playback
 *						before recording caused recording lockup on ESS cards.  
 * 				rodtoll	Additional documentation
 * 10/07/99		rodtoll	Updated to work in Unicode
 *				rodtoll	Modified notifications so connectresult should always be first
 *						Removed release of write locks so that connect result would be queued first.
 * 10/15/99		pnewson Added config check in Connect call
 * 10/18/99		rodtoll	Fix: Calling initialize twice doesn't fail.
 * 10/19/99		rodtoll	Fix: Bug #113904 Shutdown Issues
 *					    - Added handler for SESSIONLOST messages.  Fixes shutdown lockup.
 *                      - Changed disconnectAck event to manual reset so multiple threads can wait
 *                        on it.  Neccessary to ensure disconnect is completed before release is done
 *                      - Changed behaviour of disconnect so that if you specify SYNC and disconnect
 *                        is in progress, you wait for complete.  Required to support disconnect in releae
 * 10/25/99		rodtoll Fix: Bug #114684 - GetCaps causes lockup on shutdown
 * 				rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate
 * 10/27/99		pnewson Fix: Bug #113935 - Saved AGC values should be device specific
 * 						Fix: Bug #113936 - Wizard should reset the AGC level before loopback test 
 *						Note: this fix adds the DVCLIENTCONFIG_AUTOVOLUMERESET flag
 * 10/28/99		pnewson Bug #114176 updated DVSOUNDDEVICECONFIG struct
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.   In order to support new architecture
 *						all codecs creates were moved to threads where CoInitialize has been called.
 *				rodtoll	Fixed memory leak in multicast mode caused by new architecture
 * 11/04/99		pnewson Bug #114297 - Added HWND to SupervisorCheckAudioSetup call
 * 11/12/99		rodtoll	Updated to use new playback and record classes and remove
 *						old playback/record system (Includes waveIN/waveOut support)
 *				rodtoll	Updated to support new recording thread
 *				rodtoll	Added new echo suppression code 
 * 11/16/99		rodtoll	Recording thread now loops everytime it wakes up until it
 *						has compressed and transmitted all the data it can before
 *						going back to sleep.
 *  11/17/99	rodtoll Fix: Bug #115538 - dwSize members of > sizeof struct were accepted
 *              rodtoll Fix: Bug #115827 - Calling SetNotifyMask w/no callback should fail
 *				rodtoll Fix: Bug #117442 - Calling Disconnect with invalid flags doesn't return DVERR_INVALIDFLAGS
 *				rodtoll Fix: Bug #117447 - GetTransmitTarget has problems
 *				rodtoll Fix: Bug #117177 - Calling Connect w/o voice session never returns
 *  11/18/99	rodtoll	Updated to control echo cancellation switching code by define.
 *  11/22/99	rodtoll	Fixed problem caused by switching on echo cancellation while talking
 *  11/22/99	rodtoll Fixed Initialize() would fail incorrectly 
 *  11/23/99	rodtoll	Updated Initialize/SetNotifyMask so error checking behaviour is consistant 
 *  11/24/99	rodtoll	Adjusted Set/GetTransmit Target so locks are released before calling into dplay
 *  11/30/99	pnewson Reworked default device mapping code
 *						Adjusted some timing issues to make single stepping connect possible
 *  12/01/99	rodtoll Bug #121815 - Recording/playback may contain static.  Updated to call functions
 * 						to set conversion quality setting to high.
 *  			rodtoll	Bug #115783 - Always adjusts volume for default device.  Fixed for Win2k, Win9x w/DX7
 *						Systems w/DX5 or none will use waveIN/waveOUT and will default to default device.
 *  12/02/99	rodtoll	Bug #115783 - Will now use waveIN/waveOut object corresponding to specified GUID
 *						on DX3 systems.
 *  12/06/99	rodtoll	Bumped playback/record threads to time critical priority
 *  12/16/99	rodtoll	Bug #117405 - 3D Sound APIs misleading - 3d sound apis renamed
 *						The Delete3DSoundBuffer was re-worked to match the create
 *  			rodtoll Bug #122629 - Host migration broken in unusual configurations
 *						Implemented new host migration scheme.
 *				rodtoll	Bug #121054 - DirectX 7.1 changes must be incorporated
 *				rodtoll Implemented new DVPROTOCOLMSG_PLAYERLIST message to handle player table message.
 *				rodtoll	As part of new host migration, implemented proper handling of connection
 *						rejected message (was broken, exposed by new host migration).
 *				rodtoll	Updated Disconnect to handle inability to contact server properly which
 *						was resulting in an error message (when it should disconnect anyhow).
 * 				rodtoll	Removed voice suppression 
 *  01/10/00	pnewson AGC and VA tuning
 *  01/14/2000	rodtoll Updated for new speech packet types / packet handling
 *				rodtoll	Updated for new Get/SetTransmitTargets functions
 *				rodtoll	Added support for multiple targets
 *				rodtoll	Added use of fixed pool manager to manage memory for 
 *						notifications.
 *				rodtoll	Updated notifications to support messages with memory.
 *				rodtoll	Updated message handler calls to use new format
 *				rodtoll	Updated all notifications to use new message structures
 *				rodtoll	Updated Connect/Disconnect so that when  DVFLAGS_SYNCH is
 *						specified no completion messages will be sent.
 *				rodtoll	Added new API call GetSoundDeviceConfig
 *  01/21/2000  pnewson	Changes in support of revised wizard UI
 *						Allow concurrent AGC and user controlled volume
 *  01/24/2000	rodtoll	Bug #129427: Calling Destroy3DSoundBuffer for player who has
 *						already disconnected resulted in an incorrect DVERR_NOTBUFFERED 
 *						error code.
 *  01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC 
 *  01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus()
 *  02/01/2000	rodtoll	Disable capture focus features - Bug #129457
 *  02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected 
 *  02/15/2000	rodtoll	Fixed Connect so mapping GUIDs doesn't stomp user structure
 *  02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *						Added instrumentation 
 *  03/28/2000  rodtoll   Re-wrote nametable handling and locking -- more scalable 
 *              rodtoll   Fixed pool for players
 *              rodtoll   Bilink of "active players" and "players to notify" allows for greater
 *                      concurrency (playback and notify threads don't need to lock entire
 *                      nametable while running.
 *  03/29/2000	rodtoll	Bug #30957 - Made conversion quality slider setting optional -- new flag -- DVSOUNDCONFIG_SETCONVERSIONQUALITY
 *				rodtoll	Incorporated experimental playback handling w/lower priority and more frequent wakeup
 *				rodtoll Instead of calling ConfirmValidEntity now checks nametable
 *  04/07/2000  rodtoll Bug #32179 - Prevent registration of > 1 interface
 *              rodtoll Updated to use no copy sends, so handles pooling frames to be sent, proper
 *                      pulling of frames from pools and returns.  
 *  04/19/2000  rodtoll Re-enabled capture focus behaviour / found not working on WDM, re-disabled.
 *              rodtoll Bug #31106 - Handle sound devices w/no recording volume 
 *                      Set DVSOUNDCONFIG_NORECVOLAVAILABLE flag on DVSOUNDDEVICECONFIG and do not
 *                      perform any volume sets when this flag is present
 *  04/20/2000  rodtoll Bug #31478 - Lockup in shutdown on client who has become new host -- ref count issue
 *  04/24/2000  rodtoll Bug #33228 - Compile error reported by davidkl
 *  04/27/2000  rodtoll Fix for host migration crash turned out to be sample bug, restoring.
 *              rodtoll Fix for crash on Connect failed
 *  05/11/2000  rodtoll Bug #34852 Voice connection crashes after being in a session for a couple of minutes
 *  05/17/2000  rodtoll Bug #35110 Simultaneous playback of 2 voices results in distorted playback
 *  05/30/2000  rodtoll Bug #35476 Access violation in DPVOICE.DLL on host after client left
 *                      Host migration code was being fired because of DirectPlay8's nametable unwinding funcs.
 *  05/31/2000  rodtoll Bug #35860 - Fix VC6 compile errors for instrumented builds 
 *              rodtoll Bug #35794 - Setting targets to none results in leak.
 *  06/02/2000  rodtoll Moved host migration so it is keyed off voice message and transport messages.  
 *                      More reliable this way.
 *  06/21/2000	rodtoll	Bug #35767 - Implement ability for Dsound effects processing if dpvoice buffers
 *						Updated Connect and Create3DSoundBuffer to take buffers instead of descriptions
 *				rodtoll	Bug #36820 - Host migrates to wrong client when server is shut down before host's client disconnects
 *						Caused because client attempts to register new server when there is one already
 *				rodtoll	Bug #37045 - Race conditions prevent acknowledgement of new host
 *						Added send when new host is elected of settingsconfirm message
 *	06/27/2000	rodtoll	Fixed window where outstanding sends being returned after we have deregistered
 *						Voice now waits for all outstanding voice sends to complete before shutting down
 *				rodtoll	Added COM abstraction
 * 06/28/2000	rodtoll	Prefix Bug #38022
 *  07/01/2000	rodtoll	Bug #38280 - DVMSGID_DELETEVOICEPLAYER messages are being sent in non-peer to peer sessions
 *						Nametable will now only unravel with messages if session is peer to peer.
 *				rodtoll	Bug #38316 - HOST MIGRATION - Player fails to get HOST_MIGRATED message
 *  07/09/2000	rodtoll	Added signature bytes
 *  07/12/2000	rodtoll	Bug #39117 - Access violation while running VoicePosition.  Several issues:
 *						- Allow Destroy3DBuffer during disconnect
 *						- Move nametable cleanup to before freesoundbufferlist
 *						- Fixed code so always remove from list on DeleteSoundTarget
 *						- Removed unneeded logic
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 *				rodtoll	Bug #32841 - Renable support for capture focus
 * 07/22/2000	rodtoll	Bug #40284 - Initialize() and SetNotifyMask() should return invalidparam instead of invalidpointer  
 *				rodtoll   Bug #40296, 38858 - Crashes due to shutdown race condition
 *						Now ensures that all threads from transport have left and that
 *						all notificatinos have been processed before shutdown is complete.
 *				rodtoll	Bug #39586 - Trap 14 in DPVVOX.DLL during session of voicegroup, adding guards for overwrites  
 * 07/26/2000	rodtoll	Bug #40676 - Forwarding server is broken
 * 07/31/2000	rodtoll 	Bug #40470 - SetClientConfig() with invalid flags returns INVALIDPARAM
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE
 * 08/08/2000	rodtoll	Was missing a DNLeaveCriticalSection
 * 08/09/2000	rodtoll	Bug #41936 - No voice session message instead of compression not supported
 * 08/21/2000	rodtoll	Bug #41475 - DPVOICE: Lockup during shutdown when deleteplayer messages received
 * 08/22/2000	rodtoll	Bug #43095 - DPVOICE: DVMSGID_GAINFOCUS and DVMSGID_LOSTFOCUS are not passing NULL message parameters
 * 08/28/2000	masonb  Voice Merge: DNet FPOOLs use DNCRITICAL_SECTION, modified m_pBufferDescPool usage
 * 08/29/2000	rodtoll	Bug #43668 - DPVOICE: Asserts when exiting DPVOICE session
 * 08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold
 * 08/31/2000	rodtoll	Whistler Bug #171841 - Prefix Bug
 * 09/01/2000	masonb	Modified PlaybackThread, RecordThread, and NotifyThread to call _endthread to clean up thread handles
 * 09/14/2000	rodtoll	Bug #45001 - DVOICE: AV if client has targetted > 10 players 
 * 09/26/2000	rodtoll	Bug #45541 - DPVOICE: Client gets DVERR_TIMEOUT message when disconnecting
 * 09/28/2000	rodtoll	Fix Again: Bug #45541 - DPVOICE: Client gets DVERR_TIMEOUT message when disconnecting (Server always confirms disconnect)
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 * 11/16/2000	rodtoll	Bug #40587 - DPVOICE: Mixing server needs to use multi-processors 
 * 01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets 
 * 01/25/2001	rodtoll	WINBUG #293197 - DPVOICE: Stress applications cannot tell the difference between out of memory/invalid device/other errors
 * 01/26/2001	rodtoll	WINBUG #293197 - DPVOICE: [STRESS} Stress applications cannot tell difference between out of memory and internal errors.
 *						Remap DSERR_OUTOFMEMORY to DVERR_OUTOFMEMORY instead of DVERR_SOUNDINITFAILURE.
 *						Remap DSERR_ALLOCATED to DVERR_PLAYBACKSYSTEMERROR instead of DVERR_SOUNDINITFAILURE.
 *
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy.
 * 				rodtoll	WINBUG #356124 - STRESS: DPVLPY7 broke when Initialize() failed due to being out of memory.
 * 04/02/2001	simonpow	Bug #354859 Fixes for problems spotted by PREfast (hresult casting to bool and local variable hiding)
 * 04/06/2001	kareemc	Added Voice Defense
 * 04/12/2001	kareemc	WINBUG #360971 - Wizard Memory Leaks
 * 04/09/2001	rodtoll	WINBUG #363804 DPVOICE: Race condition in shutdown causes disconnect to timeout if session is being shutdown concurrently.
 * 04/11/2001  	rodtoll	WINBUG #221494 DPVOICE: Capped the # of queued recording events to prevent multiple wakeups resulting in false lockup
 *						detection
 * 04/12/2001		simonpow	WINBUG #322454 Removed early unlock in RemovePlayer method and added
 *							extra return code checking in DoConnectResponse
 * 04/21/2001	rodtoll	MANBUG #50058 DPVOICE: VoicePosition: No sound for couple of seconds when position bars are moved
 *						- Added StartMix() call when secondary buffers are created 
 *						- Added extra bit of debug spew, removed dead code
 * 04/21/2001	rodtoll (for Simonpow) 
 *						WINBUG #322454 DPVOICE: [STRESS] Connect() appears to be suceeding (returns S_OK) but connection is not established.
 *
 ***************************************************************************/

#include "dxvoicepch.h"

extern HRESULT DVS_Create(LPDIRECTVOICESERVEROBJECT *piDVS);

// Use high priority for playback / record threads
#define __CORE_THREAD_PRIORITY_HIGH

// Disables the sound system
//#define __DISABLE_SOUND

// Forces full duplex mode
//#define __FORCEFULLDUPLEX

// # of ms of inactivity before a multicast user is considered to have
// timed-out.
#define DV_MULTICAST_USERTIMEOUT_PERIOD		300000

// # of ms of inactivity before an incoming audio stream is considered to 
// have stopped.  Used to determine when to send PLAYERVOICESTOP 
// message.
#define PLAYBACK_RECEIVESTOP_TIMEOUT 		500

// # of ms the notify thread sleeps without notification to wakeup 
// and perform house cleaning.
#define DV_CLIENT_NOTIFYWAKEUP_TIMEOUT		100

// # of ms before a connect request is considered to have been lost
#define DV_CLIENT_CONNECT_RETRY_TIMEOUT		1250

// # of ms before we should timeout a connect request completely
#define DV_CLIENT_CONNECT_TIMEOUT			30000

// Maximum count notification semaphores can have 
#define DVCLIENT_NOTIFY_MAXSEMCOUNT			0x0FFFFFFF

//// TODO: Needs tuning.
// # of ms to wait for disconnect reply from server before timing out.
#define DV_CLIENT_DISCONNECT_TIMEOUT		10000


#define DV_CLIENT_SRCQUALITY_INVALID		((DIRECTSOUNDMIXER_SRCQUALITY) 0xFFFFFFFF)

#define CLIENT_POOLS_NUM                    3
#define CLIENT_POOLS_SIZE_MESSAGE           (sizeof(DVPROTOCOLMSG_FULLMESSAGE))
#define CLIENT_POOLS_SIZE_PLAYERLIST        DVPROTOCOL_PLAYERLIST_MAXSIZE      

// DV_CLIENT_EMULATED_LEAD_ADJUST
//
// # of buffer's worth of lead ahead of read pointer allowable to write
// in playback buffer when buffer is emulated (additional, not total)
#define DV_CLIENT_EMULATED_LEAD_ADJUST		2

// DV_CLIENT_BASE_LEAD_MAX
//
// Maximum # of buffers lead to allow
#define DV_CLIENT_BASE_LEAD_MAX				2

// MixingWakeupProc
//
// This function is called by the windows timer used by this 
// class each time the timer goes off.  The function signals
// a semaphore provided by the creator of the timer. 
//
// Parameters:
// DWORD param - A recast pointer to a HANDLE
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::MixingWakeupProc"
BOOL CDirectVoiceClientEngine::MixingWakeupProc( DWORD_PTR param )
{
    TimerHandlerParam *pParam = (TimerHandlerParam *) param;

    SetEvent( pParam->hPlaybackTimerEvent );
    SetEvent( pParam->hRecordTimerEvent );

    DNEnterCriticalSection( &pParam->csPlayCount );
    pParam->lPlaybackCount++;
    DNLeaveCriticalSection( &pParam->csPlayCount );

    return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CDirectVoiceClientEngine"
//
// Constructor
//
// Initializes object to uninitialized state.  Must call Initialize succesfully before 
// the object can be used (except GetCompressionTypes which can be called at any time).  
//
CDirectVoiceClientEngine::CDirectVoiceClientEngine( DIRECTVOICECLIENTOBJECT *lpObject
	):	m_dwSignature(VSIG_CLIENTENGINE),
		m_lpFramePool(NULL),
		m_lpObject(lpObject),
		m_lpSessionTransport(NULL),
		m_lpUserContext(NULL),
		m_dvidServer(0),
		m_pTimer(NULL),
		m_bLastPeak(0),
		m_bLastTransmitted(FALSE),
		m_bMsgNum(0),
		m_bSeqNum(0),
		m_dwActiveCount(0),
		m_dwLastConnectSent(0),
		m_audioPlaybackBuffer(NULL),
		m_audioRecordDevice(NULL),
		m_audioPlaybackDevice(NULL),
		m_audioRecordBuffer(NULL),
		m_hRecordDone(NULL),
		m_hRecordTerminate(NULL),
		m_hPlaybackDone(NULL),
		m_hPlaybackTerminate(NULL),
		m_hConnectAck(NULL),
		m_dwCurrentState(DVCSTATE_NOTINITIALIZED),
		m_hrConnectResult(DVERR_GENERIC),
		m_hrOriginalConnectResult(DVERR_GENERIC),
		m_hrDisconnectResult(DV_OK),
		m_hDisconnectAck(NULL),
		m_hNotifyDone( NULL ),
		m_hNotifyTerminate( NULL ),
		m_hNotifyChange( NULL ),
		m_bLastPlaybackPeak( 0 ),
		m_lpdvServerMigrated(NULL),
		m_hNotifyDisconnect(NULL),
		m_hNotifyConnect(NULL),
		m_pFramePool(NULL),
		m_lpstGeneralBuffer(NULL),
        m_lpstBufferList(NULL),
		m_lpdwMessageElements(NULL),
		m_dwNumMessageElements(0),
		m_fSessionLost(FALSE),
		m_fLocalPlayerNotify(FALSE),
		m_lpNotifyList(NULL),
		m_hNewNotifyElement(NULL),
		m_dwHostOrderID(DVPROTOCOL_HOSTORDER_INVALID),
		m_pdvidTargets(NULL),
		m_dwNumTargets(0),
		m_pfpNotifications(NULL),
		m_dwTargetVersion(0),
		m_fConnectAsync(false),
		m_fDisconnectAsync(false),
		m_dwOriginalRecordQuality(DV_CLIENT_SRCQUALITY_INVALID),
		m_dwOriginalPlayQuality(DV_CLIENT_SRCQUALITY_INVALID),
		m_dwPlayActiveCount(0),
		m_fLocalPlayerAvailable(FALSE),
		m_fNotifyQueueEnabled(FALSE),
		m_hRecordThreadHandle(NULL),
		m_hPlaybackThreadHandle(NULL),
		m_dwMigrateHostOrderID(DVPROTOCOL_HOSTORDER_INVALID),
		m_pStatsBlob(NULL),
		m_fCritSecInited(FALSE)
{

	m_dvSoundDeviceConfig.lpdsCaptureDevice = NULL;
	m_dvSoundDeviceConfig.lpdsPlaybackDevice = NULL;	

	memset( &m_dvCaps, 0x00, sizeof( DVCAPS ) );
	m_dvCaps.dwSize = sizeof( DVCAPS );
	m_dvCaps.dwFlags = 0;

	ClientStats_Reset();

	ZeroMemory( &m_perfInfo, sizeof( PERF_APPLICATION ) );
	ZeroMemory( &m_perfAppInfo, sizeof( PERF_APPLICATION_INFO ) );

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InitClass"
BOOL CDirectVoiceClientEngine::InitClass( )
{
	if (!DNInitializeCriticalSection( &m_csNotifyQueueLock ))
	{
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_lockPlaybackMode ))
	{
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csTargetLock ))
	{
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csCleanupProtect ))
	{
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csBufferLock ))
	{
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csPlayAddList ))
	{
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csNotifyAddList ))
	{
		DNDeleteCriticalSection( &m_csPlayAddList );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csTransmitBufferLock ))
	{
		DNDeleteCriticalSection( &m_csNotifyAddList );
		DNDeleteCriticalSection( &m_csPlayAddList );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_thTimerInfo.csPlayCount ))
	{
		DNDeleteCriticalSection( &m_csTransmitBufferLock );
		DNDeleteCriticalSection( &m_csNotifyAddList );
		DNDeleteCriticalSection( &m_csPlayAddList );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csClassLock ))
	{
		DNDeleteCriticalSection( &m_thTimerInfo.csPlayCount );
		DNDeleteCriticalSection( &m_csTransmitBufferLock );
		DNDeleteCriticalSection( &m_csNotifyAddList );
		DNDeleteCriticalSection( &m_csPlayAddList );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csNotifyLock ))
	{
		DNDeleteCriticalSection( &m_csClassLock );
		DNDeleteCriticalSection( &m_thTimerInfo.csPlayCount );
		DNDeleteCriticalSection( &m_csTransmitBufferLock );
		DNDeleteCriticalSection( &m_csNotifyAddList );
		DNDeleteCriticalSection( &m_csPlayAddList );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_lockPlaybackMode );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		return FALSE;
	}
	m_fCritSecInited = TRUE;
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::~CDirectVoiceClientEngine"
// Destructor
//
// This function requires a write lock to complete.  
//
// If the object is connected to a session, it will be disconnected
// by this function.
//
// Releases the resources associated with the object and stops the 
// notifythread.
//
// Locks Required:
// - Class Write Lock
//
// Called By:
// DVC_Release when reference count reaches 0.
//
CDirectVoiceClientEngine::~CDirectVoiceClientEngine()
{
	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	if( m_dwCurrentState != DVCSTATE_IDLE && 
		m_dwCurrentState != DVCSTATE_NOTINITIALIZED )
	{
		Cleanup();
	}

	if( m_hNotifyDone != NULL )
	{
		SetEvent( m_hNotifyTerminate );
		WaitForSingleObject( m_hNotifyDone, INFINITE );

		CloseHandle( m_hNotifyDone );
		CloseHandle( m_hNotifyTerminate );
		CloseHandle( m_hNotifyChange );
		CloseHandle( m_hNotifyDisconnect );
		CloseHandle( m_hNotifyConnect );
		m_hNotifyDone = NULL;
		m_hNotifyTerminate = NULL;
		m_hNotifyChange = NULL;
		m_hNotifyDisconnect = NULL;
		m_hNotifyConnect = NULL;
	}

	if( m_hConnectAck != NULL )
		CloseHandle( m_hConnectAck );

	if( m_hDisconnectAck != NULL )
		CloseHandle( m_hDisconnectAck );

	if( m_lpdvServerMigrated != NULL )
	{
		m_lpdvServerMigrated->Release();
		m_lpdvServerMigrated = NULL;
	}

	if( m_lpdwMessageElements != NULL )
		delete [] m_lpdwMessageElements;		

	guardLock.Unlock();

	NotifyQueue_Free();

	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_lockPlaybackMode );	
		DNDeleteCriticalSection( &m_csTargetLock );
		DNDeleteCriticalSection( &m_csCleanupProtect );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_thTimerInfo.csPlayCount );		
		DNDeleteCriticalSection( &m_csPlayAddList );
		DNDeleteCriticalSection( &m_csNotifyAddList );
		DNDeleteCriticalSection( &m_csTransmitBufferLock );	
		DNDeleteCriticalSection( &m_csClassLock );
		DNDeleteCriticalSection( &m_csNotifyQueueLock );
		DNDeleteCriticalSection( &m_csNotifyLock );
	}

	if( m_pdvidTargets != NULL )
	{
		delete [] m_pdvidTargets;
	}

	m_dwSignature = VSIG_CLIENTENGINE_FREE;
}

// InternalSetNotifyMask
//
// Sets the list of valid notifiers for this object.
//
// Locks Needed:
// - ReadLock to check status and then releases it.
// - m_csNotifyLock to update notification list
//
// Called By:
// DVC_SetNotifyMask
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InternalSetNotifyMask" 
HRESULT CDirectVoiceClientEngine::InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{
	BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();

    // Delete previous elements
	if( m_lpdwMessageElements != NULL )
	{
		delete [] m_lpdwMessageElements;
	}

	m_dwNumMessageElements = dwNumElements;

	// Make copies of the message elements into our own message array.
	if( dwNumElements > 0 )
	{
		m_lpdwMessageElements = new DWORD[dwNumElements];

		if( m_lpdwMessageElements == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize: Error allocating memory" );
			return DVERR_OUTOFMEMORY;
		}

		memcpy( m_lpdwMessageElements, lpdwMessages, sizeof(DWORD)*dwNumElements );
	}
	else
	{
		m_lpdwMessageElements = NULL;
	}	

	return DV_OK;

}


// SetNotifyMask
//
// Sets the list of valid notifiers for this object.
//
// Locks Needed:
// - ReadLock to check status and then releases it.
// - m_csNotifyLock to update notification list
//
// Called By:
// DVC_SetNotifyMask
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetNotifyMask" 
HRESULT CDirectVoiceClientEngine::SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );

	hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, FALSE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "ValidMessageArray Failed 0x%x", hr );	
		return hr;
	}	
	
	DPFX(DPFPREP,  DVF_APIPARAM, "Message IDs=%d", dwNumElements );
	
	if( lpdwMessages != NULL )
	{
		for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
		{
			DPFX(DPFPREP,  DVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
		}
	}

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();	

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	guardLock.Unlock();

	BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();	

    if( m_lpMessageHandler == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
    	return DVERR_NOCALLBACK;
    }		

	hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

	DPFX(DPFPREP,  DVF_APIPARAM, "Returning hr=0x%x", hr );

	return DV_OK;
}

// Initialize
//
// Initializes this object into a state where it can be used to Connect to a session.  Sets the 
// notification function, notification mask and the transport object that will be used.
//
// Starts the notification thread.
//
// Locks Required:
// - Class Write Lock
// 
// Called By: 
// DV_Initialize
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Initialize"
HRESULT CDirectVoiceClientEngine::Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpTransport = 0x%p lpdvHandler = 0x%p lpUserContext = 0x%p dwNumElements = %d", lpTransport, lpdvHandler, lpUserContext, dwNumElements );	

	if( lpTransport == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid transport" );
		return DVERR_INVALIDPOINTER;
	}

	hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, FALSE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "ValidMessageArray Failed hr = 0x%x", hr );	
		return hr;
	}	
	
	DPFX(DPFPREP,  DVF_APIPARAM, "Message IDs=%d", dwNumElements );
	
	if( lpdwMessages != NULL )
	{
		for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
		{
			DPFX(DPFPREP,  DVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
		}
	}

	HANDLE hThread;

	// Wait for a write lock on the object
	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();

	if( m_dwCurrentState != DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already Initialized" );
		return DVERR_INITIALIZED;
	}

	if( lpdvHandler == NULL && lpdwMessages != NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
    	return DVERR_NOCALLBACK;
    }	

	m_dwLastConnectSent = 0;
	m_dwSynchBegin = 0;
	SetCurrentState( DVCSTATE_IDLE );	

	BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();		

	m_lpMessageHandler = lpdvHandler;

	hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

	if( FAILED( hr ) )
	{
		SetCurrentState( DVCSTATE_NOTINITIALIZED );	
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "SetNotifyMask Failed hr=0x%x", hr );
		return hr;
	}

	m_lpSessionTransport = lpTransport;
	m_lpUserContext = lpUserContext;

	m_dvidLocal = 0;
	m_dwActiveCount = 0;

	m_thTimerInfo.hPlaybackTimerEvent = NULL;  
	m_thTimerInfo.lPlaybackCount = 0;
	m_thTimerInfo.hRecordTimerEvent = NULL;  

	m_hConnectAck = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hDisconnectAck = CreateEvent( NULL, TRUE, FALSE, NULL );

	m_hNotifyDone = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hNotifyTerminate = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hNotifyChange = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hNotifyDisconnect = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hNotifyConnect = CreateEvent( NULL, FALSE, FALSE, NULL );

	if( m_hConnectAck == NULL ||
		m_hDisconnectAck == NULL ||
		m_hNotifyTerminate == NULL ||
		m_hNotifyChange == NULL ||
		m_hNotifyDisconnect == NULL ||
		m_hNotifyConnect == NULL  ||
		m_hNotifyDone==NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create required events" );
		
		goto ERROR_EXIT_INIT;
	}

	if (FAILED(NotifyQueue_Init()))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to init notify queue" );
		goto ERROR_EXIT_INIT;
	}	
	
	hThread = (HANDLE) _beginthread( NotifyThread, 0, this );

	if( hThread == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create watcher thread" );
		goto ERROR_EXIT_INIT;
	}
	
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,   DVF_INFOLEVEL, "Notify Thread Started: 0x%p", hThread );

	guardLock.Unlock();
	DPFX(DPFPREP,  DVF_APIPARAM, "Returning DV_OK" );
	
	return DV_OK;
	
ERROR_EXIT_INIT:

	if( m_hConnectAck != NULL )
	{
		CloseHandle( m_hConnectAck );
		m_hConnectAck = NULL;
	}

	if( m_hDisconnectAck != NULL )
	{
		CloseHandle( m_hDisconnectAck );
		m_hDisconnectAck = NULL;
	}
	
	if( m_hNotifyTerminate != NULL )
	{
		CloseHandle( m_hNotifyTerminate );
		m_hNotifyTerminate = NULL;
	}

	if( m_hNotifyChange != NULL )
	{
		CloseHandle( m_hNotifyChange );
		m_hNotifyChange = NULL;
	}
		
	if( m_hNotifyDisconnect != NULL )
	{
		CloseHandle( m_hNotifyDisconnect );
		m_hNotifyDisconnect = NULL;
	}

	if( m_hNotifyConnect != NULL )
	{
		CloseHandle( m_hNotifyConnect );
		m_hNotifyConnect = NULL;
	}

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Returning DVERR_GENERIC" );

	return DVERR_GENERIC;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Connect"
// Connect
//
// Implements the IDirectXVoiceClient::Connect function.
//
// Locks Required:
// - Write Lock
//
// Called By:
// DVC_Connect
//
HRESULT CDirectVoiceClientEngine::Connect( LPDVSOUNDDEVICECONFIG lpSoundDeviceConfig, LPDVCLIENTCONFIG lpClientConfig, DWORD dwFlags )
{
	HRESULT hr;
	
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );

	hr = DV_ValidClientConfig( lpClientConfig );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid Client Config hr=0x%x", hr );
		return hr;
	}

	hr = DV_ValidSoundDeviceConfig( lpSoundDeviceConfig, s_lpwfxPlaybackFormat );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid Sound Device Config hr=0x%x", hr );
		return hr;
	}

	if( dwFlags & ~(DVFLAGS_SYNC|DVFLAGS_NOQUERY) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags specified" );
		return DVERR_INVALIDFLAGS;
	}

	DV_DUMP_SDC( lpSoundDeviceConfig );
	DV_DUMP_CC( lpClientConfig );

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();	

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_dwCurrentState == DVCSTATE_CONNECTING ||
		m_dwCurrentState == DVCSTATE_DISCONNECTING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already connecting or disconnecting" );
		return DVERR_ALREADYPENDING;
	}

	if( m_dwCurrentState == DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already connected" );
		return DVERR_CONNECTED;
	}

	// Copy over the parameters
	memcpy( &m_dvSoundDeviceConfig, lpSoundDeviceConfig, sizeof( DVSOUNDDEVICECONFIG ) );	

	// map the devices
	GUID guidTemp;
	hr = DV_MapCaptureDevice(&(m_dvSoundDeviceConfig.guidCaptureDevice), &guidTemp);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "DV_MapCaptureDevice failed, code: %i", hr);
		return hr;
	}
	m_dvSoundDeviceConfig.guidCaptureDevice = guidTemp;
	
	hr = DV_MapPlaybackDevice(&(m_dvSoundDeviceConfig.guidPlaybackDevice), &guidTemp);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "DV_MapPlaybackDevice failed, code: %i", hr);
		return hr;
	}
	m_dvSoundDeviceConfig.guidPlaybackDevice = guidTemp;

	// Check to ensure setup has been run on these devices
	// but only if the NOQUERY flag has not been set.
	if (!(dwFlags & DVFLAGS_NOQUERY))
	{
		hr = SupervisorCheckAudioSetup(
			&(m_dvSoundDeviceConfig.guidPlaybackDevice), 
			&(m_dvSoundDeviceConfig.guidCaptureDevice),
			NULL,
			DVFLAGS_QUERYONLY);
		switch (hr)
		{
		case DV_FULLDUPLEX:
			// great - carry on.
			DPFX(DPFPREP, DVF_INFOLEVEL, "Devices have been tested - full duplex ok");
			break;
			
		case DV_HALFDUPLEX:
			// force on the half duplex flag.
			DPFX(DPFPREP, DVF_INFOLEVEL, "Devices have been tested - half duplex only");
			m_dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_HALFDUPLEX;
			break;

		case DVERR_SOUNDINITFAILURE:
			// The devices were tested, and failed miserably.
			DPFX(DPFPREP, DVF_INFOLEVEL, "Devices have been tested - total failure");
			return DVERR_SOUNDINITFAILURE;
			break;
			
		case DVERR_RUNSETUP:
			// return the run setup code
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Devices have not been tested");
			return DVERR_RUNSETUP;

		default:
			// unexpected return code - this is a real error - propogate it back up
			DPFX(DPFPREP, DVF_ERRORLEVEL, "SupervisorCheckAudioSetup failed, code: %i", hr);
			return hr;
		}
	}

	// RESET Session flags that need to be reset on every connect
	m_fSessionLost = FALSE;
	m_hrDisconnectResult = DV_OK;
	m_fLocalPlayerNotify = FALSE;
	m_fLocalPlayerAvailable = FALSE;
	m_dwHostOrderID = DVPROTOCOL_HOSTORDER_INVALID;	
	m_hPlaybackThreadHandle = NULL;
	m_hRecordThreadHandle = NULL;
	m_thTimerInfo.hPlaybackTimerEvent = NULL;  
	m_thTimerInfo.lPlaybackCount = 0;
	m_thTimerInfo.hRecordTimerEvent = NULL;  
	m_lpdvfCompressionInfo = NULL;
	m_hrConnectResult = DVERR_GENERIC;
	m_hrOriginalConnectResult = DVERR_GENERIC;
	ClientStats_Reset();

    // Add a reference to incoming objects
	if( m_dvSoundDeviceConfig.lpdsPlaybackDevice != NULL )
	{
	    m_dvSoundDeviceConfig.lpdsPlaybackDevice->AddRef();
	}

	if( m_dvSoundDeviceConfig.lpdsMainBuffer != NULL )
	{
		m_dvSoundDeviceConfig.lpdsMainBuffer->AddRef();
	}

    // Add a reference to incoming objects
	if( m_dvSoundDeviceConfig.lpdsCaptureDevice != NULL )
	{
	    m_dvSoundDeviceConfig.lpdsCaptureDevice->AddRef();
	}

	DNEnterCriticalSection( &m_lockPlaybackMode );
	m_dwActiveCount = 0;
	m_dwEchoState = DVCECHOSTATE_IDLE;
	DNLeaveCriticalSection( &m_lockPlaybackMode );

	// Need to reset disconnect event manually
	ResetEvent( m_hDisconnectAck );

	// This was here to disable capture 
	// 
	// m_dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_NOFOCUS;
	
	m_dvSoundDeviceConfig.dwMainBufferFlags |= DSBPLAY_LOOPING;

	memcpy( &m_dvClientConfig, lpClientConfig, sizeof( DVCLIENTCONFIG ) );

	// Check for duplicate objects in the process, re-use existing object if there is one.
	// Also does some sanity checks.
	hr = CheckForDuplicateObjects();

	if( FAILED(hr) )
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Error checking dsound(cap) objects hr=0x%x", hr );
		
        goto CONNECT_ERROR;
	}	

#ifdef __FORCEFULLDUPLEX
	m_dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_HALFDUPLEX;
#endif

	if( m_dvClientConfig.dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		m_dvClientConfig.dwBufferAggressiveness = s_dwDefaultBufferAggressiveness;
	}

	if( m_dvClientConfig.dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		m_dvClientConfig.dwBufferQuality = s_dwDefaultBufferQuality;
	}

	if( m_dvClientConfig.dwThreshold == DVTHRESHOLD_DEFAULT )
	{
		m_dvClientConfig.dwThreshold = s_dwDefaultSensitivity;
	}

	m_dwMigrateHostOrderID = DVPROTOCOL_HOSTORDER_INVALID;
	m_dwLastConnectSent = 0;
	m_dwSynchBegin = 0;
	SetCurrentState( DVCSTATE_CONNECTING );

	// Initialize the name table
	m_voiceNameTable.Initialize();

	// Initialize bilinks -- if we fail on our connect things won't go south.
	m_dwPlayActiveCount = 0;
	InitBilink( &m_blPlayActivePlayers, NULL );
	InitBilink( &m_blPlayAddPlayers, NULL );
	InitBilink( &m_blNotifyActivePlayers, NULL );
	InitBilink( &m_blNotifyAddPlayers, NULL );

	ZeroMemory( &m_perfInfo, sizeof( PERF_APPLICATION_INFO ) );

	// Setup for performance entry
	// TODO: Get the GUID of the instance for the session
	m_perfInfo.dwFlags = PERF_APPLICATION_VALID | PERF_APPLICATION_VOICE;
	CoCreateGuid( &m_perfInfo.guidApplicationInstance );
	CoCreateGuid( &m_perfInfo.guidInternalInstance );
	m_perfInfo.guidIID = IID_IDirectPlayVoiceClient;
	m_perfInfo.dwProcessID = GetCurrentProcessId();
	m_perfInfo.dwMemoryBlockSize = sizeof( ClientStatistics ) + sizeof( DVSESSIONDESC );

	// Initilalize the new performance library
	hr = PERF_AddEntry( &m_perfInfo, &m_perfAppInfo );

	// This is an error, but not fatal
	if( FAILED ( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create performance tracking object 0x%x", hr );
	}

	if( m_perfAppInfo.pbMemoryBlock )
	{
		m_pStatsBlob = (ClientStatistics *) m_perfAppInfo.pbMemoryBlock;
	}
	else
	{
		m_pStatsBlob = &m_stats;
	}

	m_fpPlayers.Initialize();
	
    hr = SetupInitialBuffers();	

    if( FAILED( hr ) )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "SetupBuffersInitial Failed 0x%x", hr );
        goto CONNECT_ERROR;
    }        

	hr = m_lpSessionTransport->EnableReceiveHook( m_lpObject, DVTRANSPORT_OBJECTTYPE_CLIENT );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "EnableReceiveHook Failed 0x%x", hr );
        goto CONNECT_ERROR;
	}

	m_fConnectAsync = !(dwFlags & DVFLAGS_SYNC);

	m_dvidServer = m_lpSessionTransport->GetServerID();
	m_dvidLocal = m_lpSessionTransport->GetLocalID();

	// Send connect request to the server
	guardLock.Unlock();

	m_dwLastConnectSent = GetTickCount();
	m_dwSynchBegin = m_dwLastConnectSent;

	hr = Send_ConnectRequest();
	
	DPFX(DPFPREP,   DVF_INFOLEVEL, "DVCE::Connect() - Sending Request to server" );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,   DVF_ERRORLEVEL, "Error on send 0x%x", hr  );
        goto CONNECT_ERROR;
	}

	// If the user wants us to wait for the response, wait here.
	if( dwFlags & DVFLAGS_SYNC )
	{
		DPFX(DPFPREP,   DVF_INFOLEVEL, "Sync flag, waiting for completion." );

		// Wait until we're called with the appropriate message
		WaitForSingleObject( m_hConnectAck, INFINITE );
		DPFX(DPFPREP,   DVF_INFOLEVEL, "Server response received" );

		return GetConnectResult();
	}

	return DVERR_PENDING;
	
CONNECT_ERROR:

    // Release any objects we are holding.. if we have created a sound device
    // reference.  I.e. we've linked to an inproc sound object
	if( lpSoundDeviceConfig->lpdsPlaybackDevice == NULL && 
	    m_dvSoundDeviceConfig.lpdsPlaybackDevice != NULL )
	{
	    m_dvSoundDeviceConfig.lpdsPlaybackDevice->Release();
	    m_dvSoundDeviceConfig.lpdsPlaybackDevice = NULL;
	}

	if( m_dvSoundDeviceConfig.lpdsMainBuffer != NULL )
	{
		m_dvSoundDeviceConfig.lpdsMainBuffer->Release();
		m_dvSoundDeviceConfig.lpdsMainBuffer = NULL;
	}

    // Release any objects we are holding
    // i.e. we've linked to an inproc sound object
	if( lpSoundDeviceConfig->lpdsCaptureDevice == NULL && 
	    m_dvSoundDeviceConfig.lpdsCaptureDevice != NULL )
	{
	    m_dvSoundDeviceConfig.lpdsCaptureDevice->Release();
	    m_dvSoundDeviceConfig.lpdsCaptureDevice = NULL;
	}
    
	SetCurrentState( DVCSTATE_IDLE );	    
	
	FreeBuffers();	    
	m_voiceNameTable.DeInitialize((m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER),m_lpUserContext,m_lpMessageHandler);
	m_fpPlayers.Deinitialize();

	PERF_RemoveEntry( m_perfInfo.guidInternalInstance, &m_perfAppInfo );
	
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_SessionLost"
HRESULT CDirectVoiceClientEngine::Send_SessionLost()
{
	PDVPROTOCOLMSG_SESSIONLOST pSessionLost;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	LPVOID pvSendContext;
	HRESULT hr;

	pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_SESSIONLOST ), &pvSendContext );

	if( pBufferDesc == NULL )
	{
		return DVERR_OUTOFMEMORY;	    
	}

	pSessionLost = (PDVPROTOCOLMSG_SESSIONLOST) pBufferDesc->pBufferData;

	// Send connection request to the server
	pSessionLost->dwType = DVMSGID_SESSIONLOST;
	pSessionLost->hresReason = DVERR_SESSIONLOST;
	
	// Fixed so that it gets sent
	hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPFX(DPFPREP,  0, "Error sending connect request hr=0x%x", hr );
        ReturnTransmitBuffer( pvSendContext );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_ConnectRequest"
HRESULT CDirectVoiceClientEngine::Send_ConnectRequest()
{
	PDVPROTOCOLMSG_CONNECTREQUEST pConnectRequest;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	LPVOID pvSendContext;
	HRESULT hr;

	pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_CONNECTREQUEST ), &pvSendContext );

	if( pBufferDesc == NULL )
	{
		return DVERR_OUTOFMEMORY;	    
	}

	pConnectRequest = (PDVPROTOCOLMSG_CONNECTREQUEST) pBufferDesc->pBufferData;

	// Send connection request to the server
	pConnectRequest->dwType = DVMSGID_CONNECTREQUEST;
	pConnectRequest->ucVersionMajor = DVPROTOCOL_VERSION_MAJOR;
	pConnectRequest->ucVersionMinor = DVPROTOCOL_VERSION_MINOR;
	pConnectRequest->dwVersionBuild = DVPROTOCOL_VERSION_BUILD;	
	
	hr = m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPFX(DPFPREP,  0, "Error sending connect request hr=0x%x", hr );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_DisconnectRequest"
HRESULT CDirectVoiceClientEngine::Send_DisconnectRequest()
{
	PDVPROTOCOLMSG_GENERIC pDisconnectRequest;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	LPVOID pvSendContext;
	HRESULT hr;	

	pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_GENERIC ), &pvSendContext );

	if( pBufferDesc == NULL )
	{
		return DVERR_OUTOFMEMORY;	    
	}

	pDisconnectRequest = (PDVPROTOCOLMSG_GENERIC) pBufferDesc->pBufferData;

	// Send connection request to the server
	pDisconnectRequest->dwType = DVMSGID_DISCONNECT;
	
	hr = m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPFX(DPFPREP,  0, "Error sending connect request hr=0x%x", hr );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Send_SettingsConfirm"
HRESULT CDirectVoiceClientEngine::Send_SettingsConfirm()
{
	PDVPROTOCOLMSG_SETTINGSCONFIRM pSettingsConfirm;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	LPVOID pvSendContext;
	HRESULT hr;	

	pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_SETTINGSCONFIRM ), &pvSendContext );

	if( pBufferDesc == NULL )
	{
		return DVERR_OUTOFMEMORY;	    
	}

	pSettingsConfirm = (PDVPROTOCOLMSG_SETTINGSCONFIRM) pBufferDesc->pBufferData;

	// Send connection request to the server
	pSettingsConfirm->dwType = DVMSGID_SETTINGSCONFIRM;
	pSettingsConfirm->dwHostOrderID = m_dwHostOrderID;
	pSettingsConfirm->dwFlags = 0;

	if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX )
	{
		pSettingsConfirm->dwFlags |= DVPLAYERCAPS_HALFDUPLEX;
	}	
	
	hr = m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr != DVERR_PENDING && hr != DV_OK )
    {
        DPFX(DPFPREP,  0, "Error sending connect request hr=0x%x", hr );
    }
    // Pending = OK = expected
    else
    {
        hr = DV_OK;
    }
    
    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Disconnect"
// Disconnect
//
// Implements the IDirectXVoiceClient::Disconnect function
//
// Locks Required:
// - Global Lock
//
// Called By:
// DVC_Disconnect
//
HRESULT CDirectVoiceClientEngine::Disconnect( DWORD dwFlags )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );
	DPFX(DPFPREP,  DVF_APIPARAM, "dwFlags = 0x%x", dwFlags );

	HRESULT hr;

	if( dwFlags & ~(DVFLAGS_SYNC) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags specified" );
		return DVERR_INVALIDFLAGS;
	}

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_dwCurrentState == DVCSTATE_CONNECTING )
	{
	
		m_fDisconnectAsync = !(dwFlags & DVFLAGS_SYNC);		
		
		DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "DVCE::Disconnect() Abort connection" );

		// Handle Connect
		SetConnectResult( DVERR_CONNECTABORTED );

		SendConnectResult();

		SetEvent( m_hConnectAck );

		DoSignalDisconnect( DVERR_CONNECTABORTED );

		guardLock.Unlock();

		if( dwFlags & DVFLAGS_SYNC )
		{
			goto DISCONNECT_WAIT;
		}

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Returning DVERR_CONNECTABORTING" );
	
		return DVERR_CONNECTABORTING;
	}

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "State Good.." );	
	
	if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Already disconnecting.  Waiting on current event" );

		guardLock.Unlock();		

		if( dwFlags & DVFLAGS_SYNC )
		{
			goto DISCONNECT_WAIT;
		}
		
		return DVERR_ALREADYPENDING;
	}
	else if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Not Connected" );
		
		DPFX(DPFPREP,  DVF_APIPARAM, "Returning DVERR_NOTCONNECTED" );			
		return DVERR_NOTCONNECTED;
	}
	else
	{
		m_fDisconnectAsync = !(dwFlags & DVFLAGS_SYNC);	
		
		m_dwSynchBegin = GetTickCount();	

    	// Set current state to disconnecting before we release the lock
		SetCurrentState( DVCSTATE_DISCONNECTING );		

		guardLock.Unlock();

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Disconnect request about to be sent" );

		hr = Send_DisconnectRequest();

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Disconnect request transmitted hr=0x%x", hr );

		guardLock.Lock();

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "DVCE::Disconnect - Error on send 0x%x", hr );

			// Inform notify thread to disconnect, since send failed there won't be a confirm
			SetEvent( m_hNotifyDisconnect );
			
			hr = DV_OK;
		}
		else
		{
			DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Disconnect sent" );
		}
	}

	guardLock.Unlock();

	if( dwFlags & DVFLAGS_SYNC )
	{
		goto DISCONNECT_WAIT;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Returning DVERR_PENDING" );

	return DVERR_PENDING;

// You should have dropped the Write Loc+k by now
DISCONNECT_WAIT:

	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Sync flag, waiting for completion." );
	WaitForSingleObject( m_hDisconnectAck, INFINITE );
	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Server response received" );

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Disconnect Result = 0x%x", m_hrDisconnectResult );
	
	return m_hrDisconnectResult;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetSessionDesc"
// GetSessionDesc
//
// Retrieves the current session description.
//
// Called By:
// DVC_GetSessionDesc
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceClientEngine::GetSessionDesc( PDVSESSIONDESC lpSessionDesc )
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Enter" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "lpSessionDescBuffer = 0x%p", lpSessionDesc ); 

	if( lpSessionDesc == NULL || !DNVALID_WRITEPTR(lpSessionDesc,sizeof( DVSESSIONDESC )) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Session desc pointer bad" );
		return DVERR_INVALIDPOINTER;
	}

	if( lpSessionDesc->dwSize != sizeof( DVSESSIONDESC ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid size on session desc" );
		return DVERR_INVALIDPARAM;
	}

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initalized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not connected" );
		return DVERR_NOTCONNECTED;
	}

	memcpy( lpSessionDesc, &m_dvSessionDesc, sizeof( DVSESSIONDESC ) ); 

	DV_DUMP_SD( (LPDVSESSIONDESC) lpSessionDesc );

	DPFX(DPFPREP,  DVF_APIPARAM, "Returning DV_OK" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetSoundDeviceConfig"
// GetSoundDeviceConfig
// 
// Retrieves the current client configuration.
//
// Called By:
// DVC_GetSoundDeviceConfig
//
// Locks Required:
// - Global Read Lock
HRESULT CDirectVoiceClientEngine::GetSoundDeviceConfig( PDVSOUNDDEVICECONFIG pSoundDeviceConfig, PDWORD pdwBufferSize )
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Enter" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "pSoundDeviceConfig = 0x%p", pSoundDeviceConfig );

	DWORD dwRequiredSize = sizeof(DVSOUNDDEVICECONFIG);

	if( pdwBufferSize == NULL ||
	   !DNVALID_WRITEPTR(pdwBufferSize,sizeof(DWORD)) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( pSoundDeviceConfig != NULL &&
		!DNVALID_WRITEPTR(pSoundDeviceConfig,*pdwBufferSize ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( pSoundDeviceConfig != NULL && pSoundDeviceConfig->dwSize != sizeof( DVSOUNDDEVICECONFIG ) )
	{
		DPFX(DPFPREP,   DVF_ERRORLEVEL, "Invalid Size on clientconfig" );
		return DVERR_INVALIDPARAM;
	}

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not Connected" );		
		return DVERR_NOTCONNECTED;
	}

	if( *pdwBufferSize < dwRequiredSize || pSoundDeviceConfig == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer too small!" );
		*pdwBufferSize = dwRequiredSize;
		return DVERR_BUFFERTOOSMALL;
	}
	
	memcpy( pSoundDeviceConfig, &m_dvSoundDeviceConfig, sizeof( DVSOUNDDEVICECONFIG ) );


	DV_DUMP_SDC( pSoundDeviceConfig );

	// # of bytes written
	*pdwBufferSize = dwRequiredSize;

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "End" );
	DPFX(DPFPREP,  DVF_APIPARAM, "Returning DV_OK" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetClientConfig"
// GetClientConfig
// 
// Retrieves the current client configuration.
//
// Called By:
// DVC_GetClientConfig
//
// Locks Required:
// - Global Read Lock
HRESULT CDirectVoiceClientEngine::GetClientConfig( LPDVCLIENTCONFIG lpClientConfig )
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Enter" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "lpClientConfig = 0x%p", lpClientConfig );

	if( lpClientConfig == NULL ||
		!DNVALID_WRITEPTR(lpClientConfig,sizeof(DVCLIENTCONFIG) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}

	if( lpClientConfig->dwSize != sizeof( DVCLIENTCONFIG ) )
	{
		DPFX(DPFPREP,   DVF_ERRORLEVEL, "Invalid Size on clientconfig" );
		return DVERR_INVALIDPARAM;
	}

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not Connected" );		
		return DVERR_NOTCONNECTED;
	}

	memcpy( lpClientConfig, &m_dvClientConfig, sizeof( DVCLIENTCONFIG ) );

	if( lpClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED )
	{
		lpClientConfig->dwThreshold = DVTHRESHOLD_UNUSED;
	}

	DV_DUMP_CC( lpClientConfig );

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "End" );
	DPFX(DPFPREP,  DVF_APIPARAM, "Returning DV_OK" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetClientConfig"
// SetClientConfig
//
// Sets the current client configuration.
//
// Called By:
// DVC_SetClientConfig
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceClientEngine::SetClientConfig( LPDVCLIENTCONFIG lpClientConfig )
{
	HRESULT hr;

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Enter" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "lpClientConfig=0x%p", lpClientConfig );

	if( lpClientConfig == NULL ||
		!DNVALID_READPTR(lpClientConfig,sizeof(DVCLIENTCONFIG)))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}

	DV_DUMP_CC( lpClientConfig );

	if( lpClientConfig->dwSize != sizeof( DVCLIENTCONFIG ) )
	{
		DPFX(DPFPREP,   DVF_ERRORLEVEL, "DVCE::SetClientConfig() Error parameters" );
		return DVERR_INVALIDPARAM;
	}

	hr = DV_ValidClientConfig( lpClientConfig );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error validating Clientconfig hr=0x%x", hr );
		return hr;
	}		

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not connected" );
		return DVERR_NOTCONNECTED;
	}

	BOOL bNotifyChange = FALSE,
		 bPlaybackChange = FALSE,
		 bRecordChange = FALSE,
		 bSensitivityChange = FALSE;

	// If we're not half duplex, take care of the volume settings
	if( !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX ) && 
	    !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_NORECVOLAVAILABLE) )
	{
		if( lpClientConfig->lRecordVolume != DVRECORDVOLUME_LAST)
		{
			m_dvClientConfig.lRecordVolume = lpClientConfig->lRecordVolume;
			m_audioRecordBuffer->SetVolume( m_dvClientConfig.lRecordVolume );		
		}
	}

	if( m_dvClientConfig.lPlaybackVolume != lpClientConfig->lPlaybackVolume )
	{
		m_dvClientConfig.lPlaybackVolume = lpClientConfig->lPlaybackVolume;
		SetPlaybackVolume( m_dvClientConfig.lPlaybackVolume );		
	}

	if( m_dvClientConfig.dwNotifyPeriod != lpClientConfig->dwNotifyPeriod )
	{
		m_dvClientConfig.dwNotifyPeriod = lpClientConfig->dwNotifyPeriod;
		SetEvent( m_hNotifyChange );
	}

	if( !(lpClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED ) )
	{
		m_dvClientConfig.dwThreshold = DVTHRESHOLD_UNUSED;
	}
	else if( m_dvClientConfig.dwThreshold != lpClientConfig->dwThreshold )
	{
		if( lpClientConfig->dwThreshold == DVTHRESHOLD_DEFAULT )
		{
			m_dvClientConfig.dwThreshold = s_dwDefaultSensitivity;
		}
		else
		{
			m_dvClientConfig.dwThreshold = lpClientConfig->dwThreshold;
		}
	}

	if( (lpClientConfig->dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION) !=
		(m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION) )
	{
	
		DNEnterCriticalSection( &m_lockPlaybackMode );

		m_dwEchoState = DVCECHOSTATE_IDLE;

		DNLeaveCriticalSection( &m_lockPlaybackMode );
	}

	if( m_dvClientConfig.dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		m_dvClientConfig.dwBufferAggressiveness = s_dwDefaultBufferAggressiveness;
	}

	if( m_dvClientConfig.dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		m_dvClientConfig.dwBufferQuality = s_dwDefaultBufferQuality;
	}	

	// If we haven't specified NOFOCUS and we're not half duplex
	if( !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX) && 
	   !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_NOFOCUS) )
	{
		// If the settings have changed
		if( (m_dvClientConfig.dwFlags & DVCLIENTCONFIG_RECORDMUTE) !=
		   (lpClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE) )
		{
			if( lpClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "Record Muted: Yielding focus" );
				hr = m_audioRecordBuffer->YieldFocus();
			}
			else
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "Record Un-Muted: Attempting to reclaim focus" );			
				hr = m_audioRecordBuffer->ClaimFocus();
			}

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Focus set failed hr=0x%x", hr );
			}
		}
	}

	m_dvClientConfig.dwFlags = lpClientConfig->dwFlags;
	m_dvClientConfig.dwNotifyPeriod = lpClientConfig->dwNotifyPeriod;
	
	guardLock.Unlock();

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Returning DV_OK" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetCaps"
//
// GetCaps
//
// This function retrieves the caps structure for this DirectPlayVoiceClient 
// object.
//
// Called By:
// - DVC_GetCaps
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceClientEngine::GetCaps( LPDVCAPS lpCaps )
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::GetCaps() Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Params: lpCaps: 0x%p", lpCaps );

	CDVCSLock guardLock(&m_csClassLock);

	if( lpCaps == NULL ||
		!DNVALID_WRITEPTR(lpCaps,sizeof(DVCAPS)))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( lpCaps->dwSize != sizeof( DVCAPS ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error parameters" );
		return DVERR_INVALIDPARAM;
	}

	guardLock.Lock();

	memcpy( lpCaps, &m_dvCaps, sizeof( DVCAPS ) );

	guardLock.Unlock();

	DV_DUMP_CAPS( lpCaps );

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Done" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetCompressionTypes"
//
// GetCompressionTypes
//
// Retrieves configured compression types for this object.
//
// Called By:
// - DVC_GetCompressionTypes
//
// Locks Required:
// - Global Read Lock 
//
HRESULT CDirectVoiceClientEngine::GetCompressionTypes( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags )
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Params: lpBuffer = 0x%p lpdwSize = 0x%p lpdwNumElements = 0x%p, dwFlags = 0x%x", 
	                   lpBuffer, lpdwSize, lpdwNumElements, dwFlags );

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	HRESULT hres = DVCDB_CopyCompressionArrayToBuffer( lpBuffer, lpdwSize, lpdwNumElements, dwFlags );

	guardLock.Unlock();

	if( hres == DV_OK )
	{
		DV_DUMP_CI( (LPDVCOMPRESSIONINFO) lpBuffer, *lpdwNumElements );
	}

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Done" );

	return hres;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckForAndRemoveTarget"
//
// CheckForAndRemoveTarget
//
// Checks the current target list for the specified ID and removes it from
// the target list if it is in the target list.
//
HRESULT CDirectVoiceClientEngine::CheckForAndRemoveTarget( DVID dvidID )
{
	HRESULT hr = DV_OK;
	
	DNEnterCriticalSection( &m_csTargetLock );

	// Search the list of targets
	for( DWORD dwIndex = 0; dwIndex < m_dwNumTargets; dwIndex++ )
	{
		if( m_pdvidTargets[dwIndex] == dvidID )
		{
			if( m_dwNumTargets == 1 )
			{
				hr = InternalSetTransmitTarget( NULL, 0 );
			}
			// We'll re-use the current target array
			else
			{
				// Collapse the list by either ommiting the last element (if the
				// one we want to remove is last, or by moving last element into
				// the place in the list we're removing.
				if( dwIndex+1 != m_dwNumTargets )
				{
					m_pdvidTargets[dwIndex] = m_pdvidTargets[m_dwNumTargets-1];
				}
				
				hr = InternalSetTransmitTarget( m_pdvidTargets, m_dwNumTargets-1 );
			}
			
			break;
		}
	}

	DNLeaveCriticalSection( &m_csTargetLock );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InternalSetTransmitTarget"
//
// InternalSetTransmitTarget
//
// Does the work of setting the target.  (Assumes values have been validated).
//
// This function is safe to pass a pointer to the current target array.  It works
// on a temporary.
//
HRESULT CDirectVoiceClientEngine::InternalSetTransmitTarget( PDVID pdvidTargets, DWORD dwNumTargets )
{
	DWORD dwRequiredSize;
	PBYTE pbDataBuffer;
	PDVMSG_SETTARGETS pdvSetTarget;
	
	DNEnterCriticalSection( &m_csTargetLock );

	// No targets? set list to NULL
	if( dwNumTargets == 0 )
	{
	    // Close memory leak
	    //
	    // Hawk Bug #
	    //
		if( m_pdvidTargets != NULL )
		{
		    delete [] m_pdvidTargets;
		}

		m_pdvidTargets = NULL;		
	}
	// Otherwise allocate new list and copy
	else
	{
		PDVID pTmpTargetList;
		
		pTmpTargetList = new DVID[dwNumTargets];

		if( pTmpTargetList == NULL )
		{
			delete [] m_pdvidTargets;
			m_dwNumTargets = 0;
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
			DNLeaveCriticalSection( &m_csTargetLock );			
			return DVERR_OUTOFMEMORY;
		}

		memcpy( pTmpTargetList, pdvidTargets, dwNumTargets*sizeof(DVID) );

		// Kill off old target list
		if( m_pdvidTargets != NULL )
			delete [] m_pdvidTargets;	

		m_pdvidTargets = pTmpTargetList;
	}

	m_dwNumTargets = dwNumTargets;
	m_dwTargetVersion++;

	dwRequiredSize  = m_dwNumTargets * sizeof( DVID );
	dwRequiredSize += sizeof( DVMSG_SETTARGETS );

	pbDataBuffer = new BYTE[dwRequiredSize];

	if( pbDataBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory!" );
		DNLeaveCriticalSection( &m_csTargetLock );
		return TRUE;
	}

	pdvSetTarget = (PDVMSG_SETTARGETS) pbDataBuffer;

	pdvSetTarget->pdvidTargets = (PDVID) (pbDataBuffer+sizeof(DVMSG_SETTARGETS));
	pdvSetTarget->dwNumTargets = m_dwNumTargets;
	pdvSetTarget->dwSize = sizeof( DVMSG_SETTARGETS );

	memcpy( pdvSetTarget->pdvidTargets, m_pdvidTargets, sizeof(DVID)*m_dwNumTargets );

	NotifyQueue_Add(  DVMSGID_SETTARGETS, pdvSetTarget, dwRequiredSize );	

	delete [] pbDataBuffer;

	DNLeaveCriticalSection( &m_csTargetLock );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetTransmitTarget"
//
// SetTransmitTarget
//
// Sets the current transmit target.
//
// Called by:
// - DVC_SetTransmitTarget
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceClientEngine::SetTransmitTarget( PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Params: pdvidTargets = 0x%p dwNumTargets = %d dwFlags = 0x%x", pdvidTargets, dwNumTargets, dwFlags );

	if( dwFlags != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	HRESULT hr;

	// Check that the target list is valid
	hr = DV_ValidTargetList( pdvidTargets, dwNumTargets );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Target list is not valid" );
		return hr;
	}

	DWORD dwIndex;	

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}
	
	if( m_dwCurrentState != DVCSTATE_CONNECTED &&
	    m_dwCurrentState != DVCSTATE_CONNECTING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not connected" );
		return DVERR_NOTCONNECTED;
	}
	else
	{
		if( m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Denied.  Server controlled target" );
			return DVERR_NOTALLOWED;
		}

		if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
		{
			// Loop through target list, confirm they are valid entries
			for( dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
			{
				if( !m_voiceNameTable.IsEntry(pdvidTargets[dwIndex]) )
				{

					if( !m_lpSessionTransport->ConfirmValidGroup( pdvidTargets[dwIndex] ) )
					{
						DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid target" );
						return DVERR_INVALIDTARGET;
					}
					
				} 
			}
		}
	}

	hr = InternalSetTransmitTarget( pdvidTargets, dwNumTargets );

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetTransmitTarget"
//
// GetTransmitTarget
//
// Retrieves the current transmission target.  
//
// Called By:
// - DVC_GetTransmitTarget
//
// Locks Required: 
// - Read Lock Required
//
HRESULT CDirectVoiceClientEngine::GetTransmitTarget( LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Params: lpdvidTargets = 0x%p pdwNumElements = 0x%x dwFlags = 0x%x", lpdvidTargets, pdwNumElements, dwFlags );

	if( pdwNumElements == NULL ||
	    !DNVALID_WRITEPTR( pdwNumElements, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer to num of elements" );
		return DVERR_INVALIDPOINTER;
	}

	if( pdwNumElements != NULL && 
	    *pdwNumElements > 0 &&
	    !DNVALID_WRITEPTR( lpdvidTargets, (*pdwNumElements) * sizeof( DVID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid target list buffer specified" );
		return DVERR_INVALIDPOINTER;
	}

	if( pdwNumElements == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Must specify a ptr for # of elements" );
		return DVERR_INVALIDPARAM;
	}
	
	if( dwFlags != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}
	else if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,   DVF_ERRORLEVEL, "Not Connected" );
		
		DPFX(DPFPREP,  DVF_APIPARAM, "Returning DVERR_NOTCONNECTED" );			
		return DVERR_NOTCONNECTED;
	}

	HRESULT hr = DV_OK;

	DNEnterCriticalSection( &m_csTargetLock );

	if( *pdwNumElements < m_dwNumTargets )
	{
		hr = DVERR_BUFFERTOOSMALL;
	}
	else
	{
		memcpy( lpdvidTargets, m_pdvidTargets,m_dwNumTargets*sizeof(DVID) );
	}
	
	*pdwNumElements = m_dwNumTargets;

	DNLeaveCriticalSection( &m_csTargetLock );

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Success" );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InitSoundTargetList"
//
// InitSoundTargetList
//
// Initializes the sound target list.
//
// Called By:
// - InitializeSoundSystem
//
// Locks Required:
// - Buffer Lock
//
HRESULT CDirectVoiceClientEngine::InitSoundTargetList()
{
    DNEnterCriticalSection( &m_csBufferLock );

    m_lpstBufferList = NULL;

    DNLeaveCriticalSection( &m_csBufferLock );
    
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::FreeSoundTargetList"
//
// FreeSoundTargetList
// 
// Releases the sound target list.
//
// Also cleans up buffers not released by the user.  This must be called before the playback system
// is shutdown.
//
// Called By:
// - DeInitializeSoundSystem
//
// Locks Required:
// - Buffer Lock
//
HRESULT CDirectVoiceClientEngine::FreeSoundTargetList()
{
    CSoundTarget *lpctFinder, *lpctLast;
    LONG lRefCount;
	DVID dvid;

    DNEnterCriticalSection( &m_csBufferLock );

	lpctLast = NULL;
    lpctFinder = m_lpstBufferList;

	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: DESTROYING OPEN TARGET OBJECTS" );

	CHECKLISTINTEGRITY();

	// If we enter this loop we're in a questionable state.  
	// 
	// The user hasn't called Delete3DSoundBuffer on one or more buffers 
	// 
	// We're going to cleanup, if they attempt to access the pointers after this point
	// the app will access violate.
	//
    while( lpctFinder != NULL )
    {
        lpctLast = lpctFinder;
        lpctFinder = lpctFinder->m_lpstNext;

		lRefCount = lpctLast->GetRefCount();

		DNASSERT( lRefCount == 2 );

		CHECKLISTINTEGRITY();

		DPFX(DPFPREP,  DVF_ERRORLEVEL, "=========================================================================" );
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "3D SoundBuffer for ID 0x%x was not released, cleaning it up", lpctLast->GetTarget() );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "This is an ERROR.  You must Delete3DSoundBuffer before closing the interface." );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "DirectPlayVoice has freed the resources, so if you access them you will crash." );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "=========================================================================" );

		lpctLast->Release();

		DeleteSoundTarget( lpctLast->GetTarget() );

		CHECKLISTINTEGRITY();
    }

	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: DESTROYING GENERAL BUFFER" );

    if( m_lpstGeneralBuffer != NULL )
    {
		// Release the core's reference to the buffer
		lRefCount = m_lpstGeneralBuffer->Release();

		// User must not have freed the buffer
		if( lRefCount > 0 )
		{
			DNASSERT( lRefCount == 1 );

			DPFX(DPFPREP,  DVF_ERRORLEVEL, "=========================================================================" );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Main 3D SoundBuffer was not released, cleaning it up" );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "This is an ERROR.  You must Delete3DSoundBuffer before closing the interface." );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "DirectPlayVoice has freed the resources, so if you access them you will crash." );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "=========================================================================" );

			m_lpstGeneralBuffer->Release();
			m_lpstGeneralBuffer = NULL;
		}
		else
		{
			m_lpstGeneralBuffer = NULL;
		}

		// Releasing the buffer above released this object as well
		m_audioPlaybackBuffer = NULL;		
	}

	DNLeaveCriticalSection( &m_csBufferLock );

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::AddSoundTarget"
//
// AddSoundTarget
//
// Adds a new target to the sound target list
//
// Called By:
// - CreateUserBuffer
//
// Locks Required:
// - Buffer Lock
// 
HRESULT CDirectVoiceClientEngine::AddSoundTarget( CSoundTarget *lpcsTarget )
{
    DNEnterCriticalSection( &m_csBufferLock );

	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] ADDSOUNDTARGET", lpcsTarget->GetTarget() );

	CHECKLISTINTEGRITY();

    lpcsTarget->m_lpstNext = m_lpstBufferList;
    m_lpstBufferList = lpcsTarget;

	CHECKLISTINTEGRITY();

    DNLeaveCriticalSection( &m_csBufferLock );

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckListIntegrity"
void CDirectVoiceClientEngine::CheckListIntegrity()
{
	CSoundTarget *lpctFinder;

    DNEnterCriticalSection( &m_csBufferLock );
	
	lpctFinder = m_lpstBufferList;

	while( lpctFinder != NULL )
	{
		if( lpctFinder != NULL )
		{
			DNASSERT( lpctFinder->m_dwSignature == VSIG_SOUNDTARGET );
			DNASSERT( lpctFinder->GetRefCount() > 0 );
			DNASSERT( lpctFinder->GetRefCount() <= 3 );
			DNASSERT( lpctFinder->GetBuffer() != NULL );
		}

        lpctFinder = lpctFinder->m_lpstNext;
	}

    DNLeaveCriticalSection( &m_csBufferLock );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DeleteSoundTarget"
//
// DeleteSoundTarget
// 
// Removes the specified ID's entry from the sound target list
//
// Called By:
// - DeleteSoundTarget
//
// Locks Required:
// - Buffer lock
//
HRESULT CDirectVoiceClientEngine::DeleteSoundTarget( DVID dvidID )
{
    CSoundTarget *lpctFinder, *lpctLast, *lpctNext;
    LONG lRefCount;

    DNEnterCriticalSection( &m_csBufferLock );  
	
	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] DELETESOUNDTARGET ", dvidID );

    lpctLast = NULL;
    lpctFinder = m_lpstBufferList;

    while( lpctFinder != NULL )
    {
		CHECKLISTINTEGRITY();

        if( lpctFinder->GetTarget() == dvidID )
        {
        	// Store next pointer
        	lpctNext = lpctFinder->m_lpstNext;
        	
        	// Release the reference the core has
        	// If this is the last reference, it destroys the object
			//
			// If user is holding reference this won't destroy 
			// the object, the cleanup will.
			//
        	lRefCount = lpctFinder->Release();

			// Only remove from list if reference count is 0.
			//
			// Otherwise you end up with buffer replaying old
			// audio 
			//
			DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] REMOVING FROM LIST ", dvidID );

/*			DNASSERT( lRefCount == 0 );
			
			if( lRefCount == 0 )
			{ */
				if( lpctLast == NULL )
				{
					m_lpstBufferList = lpctNext;
				}
				else
				{
					lpctLast->m_lpstNext = lpctNext;
				}
//			}

			CHECKLISTINTEGRITY();

		    DNLeaveCriticalSection( &m_csBufferLock );
            return DV_OK;
        }

        lpctLast = lpctFinder;
        lpctFinder = lpctFinder->m_lpstNext;
    }

    DNLeaveCriticalSection( &m_csBufferLock );    

    return DVERR_INVALIDPLAYER;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::FindSoundTarget"
//
// FindSoundTarget
//
// Look for sound target buffer for the specified user.
//
// If it exists, return it in lpcsTarget
//
// Called By:
// - CreateUserBuffer
//
// Locks Required:
// - Buffer Lock
//
HRESULT CDirectVoiceClientEngine::FindSoundTarget( DVID dvidID, CSoundTarget **lpcsTarget )
{
    DNEnterCriticalSection( &m_csBufferLock );

	CHECKLISTINTEGRITY();
    
    *lpcsTarget = NULL;

    CSoundTarget *lpctFinder;

    lpctFinder = m_lpstBufferList;

    while( lpctFinder != NULL )
    {
        if( lpctFinder->GetTarget() == dvidID )
        {
            *lpcsTarget = lpctFinder;
            lpctFinder->AddRef();
		    DNLeaveCriticalSection( &m_csBufferLock );
           
            return DV_OK;
        }

        lpctFinder = lpctFinder->m_lpstNext;
    }

	CHECKLISTINTEGRITY();

    DNLeaveCriticalSection( &m_csBufferLock );    

    return DVERR_INVALIDPLAYER;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetupPlaybackBufferDesc"
void CDirectVoiceClientEngine::SetupPlaybackBufferDesc( LPDSBUFFERDESC lpdsBufferDesc, LPDSBUFFERDESC lpdsBufferSource )
{
	DV_SetupBufferDesc( lpdsBufferDesc, lpdsBufferSource, s_lpwfxPlaybackFormat, m_dwUnCompressedFrameSize*m_dwNumPerBuffer );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Create3DSoundBuffer"
//
// Create3DSoundBuffer
//
// Creates a mixing buffer (a sound target) for the specified user ID.
//
// Called By:
// - DVC_CreateUserBuffer
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceClientEngine::Create3DSoundBuffer( DVID dvidID, LPDIRECTSOUNDBUFFER lpdsBuffer, DWORD dwPriority, DWORD dwFlags, LPDIRECTSOUND3DBUFFER *lpBuffer )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Params: dvidID = 0x%x lpdsBuffer = 0x%p dwPriority = 0x%x dwFlags = 0x%x lpBuffer = 0x%p", dvidID, lpdsBuffer, dwPriority, dwFlags, lpBuffer );

	HRESULT hr;	
	
	if( lpBuffer == NULL ||
		!DNVALID_WRITEPTR( lpBuffer, sizeof( LPDIRECTSOUND3DBUFFER ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( dvidID == DVID_REMAINING )
	{
		if( lpdsBuffer != NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify a buffer for the DVID_REMAINING buffer" );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "You can set these values from the SoundDeviceConfig structure" );			
			return DVERR_INVALIDPARAM;
		}

		if( dwFlags != 0 || dwPriority != 0 )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify non-zero flags for voice management for DVID_REMAINING buffer" );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "You can set these values from the SoundDeviceConfig structure" );
			return DVERR_INVALIDFLAGS;
		}
	}
	else 
	{
		hr = DV_ValidBufferSettings( lpdsBuffer, dwPriority, dwFlags, s_lpwfxPlaybackFormat );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid settings for buffer description hr=0x%x", hr );
			return hr;
		}

		dwFlags |= DSBPLAY_LOOPING;
	}

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not initialized" );
		return DVERR_NOTINITIALIZED;
	}
	else if( m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not connected" );
		return DVERR_NOTCONNECTED;
	}

	if( this->m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING &&
	   dvidID != DVID_REMAINING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Only DVID_REMAINING can be spatialized in mixing sessions" );
		return DVERR_NOTALLOWED;
	}

	if( dvidID == m_dvidLocal )
	{
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot create buffer for local player!" );
        return DVERR_INVALIDPLAYER;
	}

	if( dvidID != DVID_ALLPLAYERS && 
		dvidID != DVID_REMAINING && 
		!m_voiceNameTable.IsEntry(dvidID)	)
	{
		guardLock.Unlock();
		
		if( !m_lpSessionTransport->ConfirmValidGroup( dvidID ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid player/group ID" );
			return DVERR_INVALIDPLAYER;
		}

		guardLock.Lock();
	}

    DWORD dwMode;

	// Handle request for 3d buffer on the main buffer
	if( dvidID == DVID_REMAINING )
	{
		LPDIRECTSOUND3DBUFFER lpds3dTmp;

		lpds3dTmp = m_lpstGeneralBuffer->Get3DBuffer();

		if( lpds3dTmp == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "No 3d support" );
			return DVERR_NO3DSOUND;
		}

		hr = lpds3dTmp->GetMode( &dwMode );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to get 3d buffer mode hr=0x%x", hr );
			return DVERR_GENERIC;
		}

		if( dwMode != DS3DMODE_DISABLE )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already have a buffer for specified user" );
			return DVERR_ALREADYBUFFERED;
		}

		// Check return code
		hr = lpds3dTmp->SetMode( DS3DMODE_NORMAL, DS3D_IMMEDIATE  );

		if( hr != DV_OK ) 
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to set the mode to activate 3d buffer hr=0x%x", hr );
			return hr;
		}

		// Add a reference for the user (core already has one)
		m_lpstGeneralBuffer->AddRef();

		DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

		*lpBuffer = lpds3dTmp;		

		return DV_OK;
	}


	LONG lResult;
	CSoundTarget *lpstTarget = NULL;

	// Check for existing buffer.. if it already exists return it
	// (Note: Adds a reference to the buffer)
	hr = FindSoundTarget( dvidID, &lpstTarget );

    if( hr == DV_OK )
    {
    	if( lpstTarget != NULL )
    	{
	        lResult = lpstTarget->Release();

			DNASSERT( lResult != 0 );
	    }
	    
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "CreateUserBuffer: Find of buffer failed. hr=0x%x", hr );
        return DVERR_ALREADYBUFFERED;
    }

	if( lpstTarget != NULL )
	{
        lResult = lpstTarget->Release();

		DNASSERT( lResult != 0 );

		DPFX(DPFPREP,  DVF_ERRORLEVEL, "CreateUserBuffer: Buffer already available" );
		return DVERR_ALREADYBUFFERED;
	}

	// If the user has given us a buffer
	if( lpdsBuffer )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Creating buffer using user buffer" );

		lpstTarget = new CSoundTarget( dvidID, m_audioPlaybackDevice, lpdsBuffer, (s_lpwfxPlaybackFormat->wBitsPerSample == 8), dwPriority, dwFlags, m_dwUnCompressedFrameSize );
	}
	else
	{
		DSBUFFERDESC dsBufferDesc;

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Creating buffer using user buffer" );

		// Fill in appropriate values for the buffer description
		SetupPlaybackBufferDesc( &dsBufferDesc, NULL );


		// Buffer and sound target ref count = 1
		lpstTarget = new CSoundTarget( dvidID, m_audioPlaybackDevice, &dsBufferDesc, dwPriority, dwFlags, m_dwUnCompressedFrameSize );
	}

    if( lpstTarget == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "CreateUserBuffer: Failed allocating sound target" );
        return DVERR_OUTOFMEMORY;
    }

    hr = lpstTarget->GetInitResult();

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "CreateUserBuffer: Init of buffer failed. hr=0x%x", hr );
        lpstTarget->Release();
        return hr;
    }

	hr = lpstTarget->StartMix();

	if( FAILED( hr ) )
	{
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to start the mix on secondary buffer hr=0x%x.", hr );
        lpstTarget->Release();
    	return hr;
	}

	// Buffer and sound target ref count = 2
    lpstTarget->AddRef();

    hr = AddSoundTarget( lpstTarget );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "CreateUserBuffer: AddTarget failed.  hr=0x%x", hr );
        // Destroy reference from above
        lResult = lpstTarget->Release();

		DNASSERT( lResult != 0 );

        // Destroy base reference
        lResult = lpstTarget->Release();

		DNASSERT( lResult == 0 );
        return hr;
    }

	*lpBuffer = lpstTarget->Get3DBuffer();

    DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Delete3DSoundBuffer"
//
// Delete3DSoundBuffer
//
// Removes the specified ID from the mixer buffer list.  Further speech from
// the specified player will be played in the remaining buffer.
//
// Called By:
// - DVC_DeleteUserBuffer
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceClientEngine::Delete3DSoundBuffer( DVID dvidID, LPDIRECTSOUND3DBUFFER *lplpBuffer )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Params: dvidID = 0x%x lpBuffer = 0x%p", dvidID, lplpBuffer );
	
	if( lplpBuffer == NULL ||
		!DNVALID_WRITEPTR( lplpBuffer, sizeof( LPDIRECTSOUND3DBUFFER ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}
	
	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();

	if( m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not initialized" );
		return DVERR_NOTINITIALIZED;
	}	
	else if( m_dwCurrentState != DVCSTATE_CONNECTED &&
			 m_dwCurrentState != DVCSTATE_DISCONNECTING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not connected" );
		return DVERR_NOTCONNECTED;
	}

    HRESULT hr;	
	DWORD dwMode;
	LONG lResult;

	// Handle request to disable 3D on the main buffer
	if( dvidID == DVID_REMAINING )
	{
		LPDIRECTSOUND3DBUFFER lpTmpBuffer;
		
		lpTmpBuffer = m_lpstGeneralBuffer->Get3DBuffer();

		if( lpTmpBuffer == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "No 3d buffer supported" );
			return DVERR_NOTBUFFERED;
		}

		if( lpTmpBuffer != *lplpBuffer )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer passed in does not belong to specified id" );
			return DVERR_INVALIDPARAM;
		}

		hr = lpTmpBuffer->GetMode( &dwMode );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to get current mode hr=0x%x", hr );
			return DVERR_GENERIC;
		}

		if( dwMode == DS3DMODE_DISABLE )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not buffered" );
			return DVERR_NOTBUFFERED;
		}

		// Check return code
		// Add reference
		hr = lpTmpBuffer->SetMode( DS3DMODE_DISABLE, DS3D_IMMEDIATE  );

		if( hr != DV_OK ) 
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to set the mode to activate 3d buffer hr=0x%x", hr );
			return DVERR_GENERIC;
		}

		hr = lpTmpBuffer->SetPosition( 0.0, 0.0, 0.0, DS3D_IMMEDIATE );

		// Not a Failure condition.
		if( hr != DV_OK )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to set the position of the 3d buffer hr=0x%x", hr );
		}

		// Remove reference the user has 
		lResult = m_lpstGeneralBuffer->Release();

		*lplpBuffer = NULL;

		return DV_OK;
	}	

	CSoundTarget *lpstTarget;

	hr = FindSoundTarget( dvidID, &lpstTarget );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "CreateUserBuffer: Find of buffer failed. hr=0x%x", hr );
        return DVERR_NOTBUFFERED;
    }

	if( lpstTarget == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "DeleteUserBuffer: Unable to retrieve user record" );
		return DVERR_NOTBUFFERED;
	}

	if( lpstTarget->Get3DBuffer() != *lplpBuffer )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer passed in does not belong to specified id" );
		
	    // Get rid of the reference this func has
	    lResult = lpstTarget->Release();		

		DNASSERT( lResult != 0 );
		return DVERR_INVALIDPARAM;
	}

	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] DESTROY3DBUFFER ", dvidID );

	// Get rid of the reference the FindSoundTarget has
	lResult = lpstTarget->Release();

	DNASSERT( lResult != 0 );

    // Get rid of the reference the user has
    lResult = lpstTarget->Release();

	DNASSERT( lResult != 0 );

	// Destroy the last reference (unless there is one outstanding)
	DeleteSoundTarget( dvidID );

	*lplpBuffer = NULL;

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return DV_OK;
	
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
//
// DIRECTPLAY/NET --> DirectXVoiceClient Interface
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ReceiveSpeechMessage"
// ReceiveSpeechMessage
//
// Called by DirectPlay/DirectNet when a DirectXVoice message is received
//
// Called By:
// - DV_ReceiveSpeechMessage
//
// Locks Required:
// - None
//
BOOL CDirectVoiceClientEngine::ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize )
{
	BOOL fResult;

	PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage;

	// if we dont' have at least one byte then we are going to bail
	if ( dwSize < 1 )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::ReceiveSpeechMessage() Ignoring zero-byte sized message from=0x%x",
			dvidSource );
		return FALSE;
	}

	lpdvFullMessage = (PDVPROTOCOLMSG_FULLMESSAGE) lpMessage;

	if( !ValidatePacketType( lpdvFullMessage ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::ReceiveSpeechMessage() Ignoring message with invalid packet type, type=0x%x, from=0x%x",
			lpdvFullMessage->dvGeneric.dwType, dvidSource );
		return FALSE;
	}
	
	switch( lpdvFullMessage->dvGeneric.dwType )
	{
	case DVMSGID_HOSTMIGRATELEAVE:
		fResult = HandleHostMigrateLeave( dvidSource, static_cast<PDVPROTOCOLMSG_HOSTMIGRATELEAVE>(lpMessage), dwSize );
		break;
	case DVMSGID_HOSTMIGRATED:
	    fResult = HandleHostMigrated( dvidSource, static_cast<PDVPROTOCOLMSG_HOSTMIGRATED>(lpMessage),dwSize );
		break;
	case DVMSGID_CONNECTREFUSE:
		fResult = HandleConnectRefuse( dvidSource, static_cast<PDVPROTOCOLMSG_CONNECTREFUSE>(lpMessage), dwSize );
		break;
	case DVMSGID_CONNECTACCEPT:
		fResult = HandleConnectAccept( dvidSource, static_cast<PDVPROTOCOLMSG_CONNECTACCEPT>(lpMessage), dwSize );
		break;
	case DVMSGID_CREATEVOICEPLAYER:
		fResult = HandleCreateVoicePlayer( dvidSource, static_cast<PDVPROTOCOLMSG_PLAYERJOIN>(lpMessage), dwSize );
		break;
	case DVMSGID_DELETEVOICEPLAYER:
		fResult = HandleDeleteVoicePlayer( dvidSource, static_cast<PDVPROTOCOLMSG_PLAYERQUIT>(lpMessage), dwSize );
		break;
	case DVMSGID_SPEECH:
		fResult = HandleSpeech( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHHEADER>(lpMessage), dwSize );
		break;
	case DVMSGID_SPEECHBOUNCE:
		fResult = HandleSpeechBounce( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHHEADER>(lpMessage), dwSize );
		break;
	case DVMSGID_SPEECHWITHFROM:
		fResult = HandleSpeechWithFrom( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHWITHFROM>(lpMessage), dwSize );
		break;
	case DVMSGID_DISCONNECTCONFIRM:
		fResult = HandleDisconnectConfirm( dvidSource, static_cast<PDVPROTOCOLMSG_DISCONNECT>(lpMessage), dwSize);
		break;
	case DVMSGID_SETTARGETS:
		fResult = HandleSetTarget( dvidSource, static_cast<PDVPROTOCOLMSG_SETTARGET>(lpMessage), dwSize );
		break;
	case DVMSGID_SESSIONLOST:
		fResult = HandleSessionLost( dvidSource, static_cast<PDVPROTOCOLMSG_SESSIONLOST>(lpMessage), dwSize );
		break;
	case DVMSGID_PLAYERLIST:
		fResult = HandlePlayerList( dvidSource, static_cast<PDVPROTOCOLMSG_PLAYERLIST>(lpMessage), dwSize );
		break;
	default:
		DPFX(DPFPREP,   DVF_WARNINGLEVEL, "DVCE::ReceiveSpeechMessage() Ignoring non-speech message id=0x%x from=0x%x", 
			 lpdvFullMessage->dvGeneric.dwType, dvidSource );
		return FALSE;
	}

	return fResult;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSetTarget"
// HandleSetTarget
//
// Handles server settarget messages.  Sets the local target.
//
BOOL CDirectVoiceClientEngine::HandleSetTarget( DVID dvidSource, PDVPROTOCOLMSG_SETTARGET lpdvSetTarget, DWORD dwSize )
{
	HRESULT hr;

	// check structure size first so that we don't crash by accessing bad data
	if ( dwSize < sizeof( DVPROTOCOLMSG_SETTARGET ) || ( dwSize != (sizeof( DVPROTOCOLMSG_SETTARGET ) + ( lpdvSetTarget->dwNumTargets * sizeof(DVID) ) ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSetTarget() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( lpdvSetTarget->dwNumTargets > DV_MAX_TARGETS )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSetTarget() Ignoring message with too many targets, targets=0x%x, from=0x%x",
			lpdvSetTarget->dwNumTargets, dvidSource );
		return FALSE;
	}
	
	hr = InternalSetTransmitTarget( (DWORD *) &lpdvSetTarget[1], lpdvSetTarget->dwNumTargets );

	DNASSERT( hr == DV_OK );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleHostMigrateLeave"
BOOL CDirectVoiceClientEngine::HandleHostMigrateLeave( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATELEAVE lpdvHostMigrateLeave, DWORD dwSize )
{
	// Call RemovePlayer with the ID of the person who sent this, 
	// which should be the host.
	
	DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Triggered by DVMSGID_HOSTMIGRATELEAVE" );
	MigrateHost_RunElection();

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleHostMigrated"
BOOL CDirectVoiceClientEngine::HandleHostMigrated( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATED lpdvHostMigrated, DWORD dwSize )
{
	HRESULT hr;

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();	

	// We're not yet connected, so we can't send our settings to the server yet.
	// However, because of the write lock we know that when the connection
	// completes we'll have the right host.  (Transparently to the client).
	//
	// We need to proceed if we're disconnecting because we need to send a new disconnect confirm 
	// 
 	if( m_dwCurrentState != DVCSTATE_CONNECTED &&
 	   m_dwCurrentState != DVCSTATE_DISCONNECTING )
 	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not respond to new host yet, not yet initialized" );
		return TRUE;
	}

	if( dvidSource != m_dvidServer )
	{
	    DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Ignoring host migration from 0x%x -- 0x%x is server", dvidSource, m_dvidServer );
	    return TRUE;
	}

	guardLock.Unlock();

	if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Sending NEW host disconnect request" );

		hr = Send_DisconnectRequest();

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Internal send failed hr=0x%x", hr );
		}
		else
		{
			hr=DV_OK;
		}
	}
	else
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Player 0x%x received host migrated message!", m_dvidLocal );
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Sending player confirm message" );
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: According to message Player 0x%x is new host", dvidSource );

		hr = Send_SettingsConfirm();

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Internal send failed hr=0x%x", hr );
		}
		else
		{
			hr=DV_OK;
		}
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleConnectRefuse"
// HandleConnectRefuse
//
// Handles connection refusals
//
BOOL CDirectVoiceClientEngine::HandleConnectRefuse( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREFUSE lpdvConnectRefuse, DWORD dwSize )
{
	if ( dwSize != sizeof( DVPROTOCOLMSG_CONNECTREFUSE ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleConnectRefuse() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	// This prevents someone from sending a connect refuse to bump off a valid player
	if( GetCurrentState() != DVCSTATE_CONNECTING )
	{

		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleConnectRefuse() Ignoring connect refuse AFTER connection from=0x%x", dvidSource );
		return FALSE;		
	}	

	// Do some brain dead error checking. Should never happen but print
	// some debug spew just in case
	if (SUCCEEDED(lpdvConnectRefuse->hresResult))
	{
		DPFX(DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "CDirectVoiceClientEngine::HandleConnectRefuse but reason given is success!" );
	}
	
	SetConnectResult( lpdvConnectRefuse->hresResult );
	SetEvent( m_hNotifyConnect );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DeInitializeClientServer"
// DeInitializeClientServer
//
// This function is responsible for pre-allocating the information
// for receiving client/server voice.
//
void CDirectVoiceClientEngine::DeInitializeClientServer()
{
	DVPROTOCOLMSG_PLAYERQUIT dvPlayerQuit;

	dvPlayerQuit.dwType = DVMSGID_DELETEVOICEPLAYER;
	dvPlayerQuit.dvidID = m_dvidServer;

	HandleDeleteVoicePlayer( 0, &dvPlayerQuit, sizeof( DVPROTOCOLMSG_PLAYERQUIT ) );		
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InitializeClientServer"
// InitializeClientServer
//
// This function is responsible for pre-allocating the information
// for receiving client/server voice
//
HRESULT CDirectVoiceClientEngine::InitializeClientServer()
{
	DPFX(DPFPREP,   DVF_INFOLEVEL, "DVCE::InitializeClientServer() - Initializing Client/Server Queues" );

	HRESULT hr;

	CVoicePlayer *pNewPlayer;
    QUEUE_PARAMS queueParams;

	pNewPlayer = m_fpPlayers.Get();

	if( pNewPlayer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate new player for client/server" );
		return DVERR_OUTOFMEMORY;
	}

	hr = pNewPlayer->Initialize( m_dvidServer, 0, 0, NULL, &m_fpPlayers );

	if( FAILED( hr ) )
	{
		pNewPlayer->Release();
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initialize server player record" );
		return hr;
	}

    queueParams.wFrameSize = m_dwCompressedFrameSize;
    queueParams.bInnerQueueSize = m_lpdvfCompressionInfo->wInnerQueueSize;
    queueParams.bMaxHighWaterMark = m_lpdvfCompressionInfo->wMaxHighWaterMark, 
    queueParams.iQuality = m_dvClientConfig.dwBufferQuality;
    queueParams.iHops = 2;
    queueParams.iAggr = m_dvClientConfig.dwBufferAggressiveness;
    queueParams.bInitHighWaterMark = 2;
    queueParams.wQueueId = -1;
    queueParams.wMSPerFrame = m_lpdvfCompressionInfo->dwTimeout,
    queueParams.pFramePool = m_pFramePool;

	hr = pNewPlayer->CreateQueue( &queueParams );

	if( FAILED( hr ) )
	{
		pNewPlayer->Release();
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not create queue hr=0x%x", hr );
		return hr;
	}

	hr = m_voiceNameTable.AddEntry( m_dvidServer, pNewPlayer );

	if( FAILED( hr ) )
	{
		// Main ref
		pNewPlayer->Release();

		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to add entry to nametable hr=0x%x", hr );
		return TRUE;
	}

	// Add a reference for the player to the "Playback Add List"
	DNEnterCriticalSection( &m_csPlayAddList );
	pNewPlayer->AddRef();
	pNewPlayer->AddToPlayList( &m_blPlayAddPlayers );
	DNLeaveCriticalSection( &m_csPlayAddList );

	// Add a reference for the player to the "Notify Add List"
	DNEnterCriticalSection( &m_csNotifyAddList );
	pNewPlayer->AddRef();
	pNewPlayer->AddToNotifyList( &m_blNotifyAddPlayers );
	DNLeaveCriticalSection( &m_csNotifyAddList );

	pNewPlayer->SetAvailable( TRUE );
	m_fLocalPlayerAvailable = TRUE;

	// Release our personal reference
	pNewPlayer->Release();

	DPFX(DPFPREP,   DVF_INFOLEVEL, "DVCE::InitializeClientServer() - Done Initializing Client/Server Queues" );

	return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoConnectResponse"
void CDirectVoiceClientEngine::DoConnectResponse()
{
	HRESULT hr = DV_OK;

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	if( m_dwCurrentState != DVCSTATE_CONNECTING )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Aborting Connection & server response arrived" );
		
		return;
	}

	// Work from the default assumption that something will screw up
	SetConnectResult( DVERR_GENERIC );

	ClientStats_Begin();

#ifndef __DISABLE_SOUND
	// Handle sound initialization
	hr = InitializeSoundSystem();

	if( FAILED(hr) )
	{
		SetConnectResult(hr);
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Sound Initialization Failed hr=0x%x", hr );
		goto EXIT_ERROR;
	}


#endif

    hr = SetupSpeechBuffer();

    if( FAILED( hr ) )
    {
		SetConnectResult(hr);
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not init speech buffers hr=0x%x", hr );
        goto EXIT_ERROR;
    }

	DPFX(DPFPREP,   DVF_INFOLEVEL, "DVCE::HandleConnectAccept() - Sound Initialized" );

	// If we're running in client/server we need to pre-create a single buffer
	// and compressor
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING ||
        m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO )
	{
		hr = InitializeClientServer();

		if( FAILED( hr ) )
		{
			SetConnectResult(hr);
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not init client/server hr=0x%x", hr );
			goto EXIT_ERROR;
		}
	}

	// We need to make player available in client/server because there will be no indication
	if( m_dvSessionDesc.dwSessionType != DVSESSIONTYPE_PEER )
	{
		m_fLocalPlayerAvailable = TRUE;
	}

#ifndef __DISABLE_SOUND
	// Start playback thread
	// Create Thread events
	m_hPlaybackTerminate = CreateEvent( NULL, FALSE, FALSE, NULL );
	m_hPlaybackDone = CreateEvent( NULL, FALSE, FALSE, NULL );

	// Create Semaphores for playback and record
	m_thTimerInfo.hPlaybackTimerEvent = CreateEvent( NULL, FALSE, FALSE, NULL );  
	m_thTimerInfo.lPlaybackCount = 0;
	m_thTimerInfo.hRecordTimerEvent = CreateEvent( NULL, FALSE, FALSE, NULL );  

	if( m_hPlaybackTerminate == NULL || m_hPlaybackDone == NULL ||
	    m_thTimerInfo.hPlaybackTimerEvent == NULL || m_thTimerInfo.hRecordTimerEvent == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Windows error, event create failure." );
		SetConnectResult( DVERR_GENERIC );
		goto EXIT_ERROR;
	}

	// Create Multimedia timer
	m_pTimer = new Timer;

	if( m_pTimer == NULL )
	{
		SetConnectResult( DVERR_OUTOFMEMORY );

		goto EXIT_ERROR;
	}

    if( !m_pTimer->Create( m_lpdvfCompressionInfo->dwTimeout / DV_CLIENT_WAKEUP_MULTIPLER, 0, (DWORD_PTR) &m_thTimerInfo, MixingWakeupProc ) )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create timer." );
    	SetConnectResult( DVERR_GENERIC );
    	goto EXIT_ERROR;
    }

	m_hPlaybackThreadHandle = (HANDLE) _beginthread( PlaybackThread, 0, this );	
#ifdef __CORE_THREAD_PRIORITY_HIGH
	SetThreadPriority( m_hPlaybackThreadHandle, THREAD_PRIORITY_TIME_CRITICAL );
#endif
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,   DVF_INFOLEVEL, "DVCE::HandleConnectAccept() - Playback Thread Started: 0x%p", m_hPlaybackThreadHandle );

	if( !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX) )
	{
		m_hRecordTerminate = CreateEvent( NULL, FALSE, FALSE, NULL );
		m_hRecordDone = CreateEvent( NULL, FALSE, FALSE, NULL );
		if (m_hRecordTerminate==NULL || m_hRecordDone==NULL)
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Windows error, event create failure. hr=0x%x", GetLastError() );
			SetConnectResult( DVERR_GENERIC );
			goto EXIT_ERROR;
		}
		// Start Record Thread
		m_hRecordThreadHandle = (HANDLE) _beginthread( RecordThread, 0, this );
#ifdef __CORE_THREAD_PRIORITY_HIGH
		SetThreadPriority( m_hRecordThreadHandle, THREAD_PRIORITY_TIME_CRITICAL );
#endif
		// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
		DPFX(DPFPREP,   DVF_INFOLEVEL, "DVCE::HandleConnectAccept() - Record Thread Started: 0x%p", m_hRecordThreadHandle );
	}
	else
	{
		m_hRecordTerminate = NULL;
		m_hRecordDone = NULL;
	} 
#endif

	SetCurrentState( DVCSTATE_CONNECTED );
	SetConnectResult(DV_OK);

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::HandleConnectAccept() Success" );

	SendConnectResult();	

///////	

	guardLock.Unlock();	

	hr = Send_SettingsConfirm();

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to send connect confirmation hr=0x%x", hr );
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Other threads will cleanup because connection must be gone" );
	}

	SetEvent( m_hConnectAck );

	return;

EXIT_ERROR:

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING ||
        m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO )
	{
		DeInitializeClientServer();
	}

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "HandleConnectAccept Failed hr=0x%x", GetConnectResult() );
	DV_DUMP_GUID( m_dvSessionDesc.guidCT );

	guardLock.Unlock();		

	Cleanup();

	SendConnectResult();	
	
	SetEvent( m_hConnectAck );		
	
	return;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleConnectAccept"
// HandleConnectAccepts
//
// Handles connect accepts.  Sets connected flag, finishes initialization, informs the 
// connect function to proceed (if it's waiting).
//
BOOL CDirectVoiceClientEngine::HandleConnectAccept( DVID dvidSource, PDVPROTOCOLMSG_CONNECTACCEPT lpdvConnectAccept, DWORD dwSize )
{
	char tmpString[100];

	if ( dwSize != sizeof( DVPROTOCOLMSG_CONNECTACCEPT ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleConnectAccept() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidateSessionType( lpdvConnectAccept->dwSessionType ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleConnectAccept() Ignoring message with invalid session type, type=0x%x, from=0x%x",
			lpdvConnectAccept->dwSessionType, dvidSource );
		return FALSE;
	}

	if( !ValidateSessionFlags( lpdvConnectAccept->dwSessionFlags ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleConnectAccept() Ignoring message with invalid session flags, flags=0x%x, from=0x%x",
			lpdvConnectAccept->dwSessionFlags, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::HandleConnectAccept() Entry" );

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	// We're already connected, server is responding to the earlier request
	if( m_dwCurrentState != DVCSTATE_CONNECTING )
	{
		return TRUE;
	}

	m_hPlaybackTerminate = NULL;
	m_hPlaybackDone = NULL;
	
	m_thTimerInfo.hPlaybackTimerEvent = NULL;
	m_thTimerInfo.hRecordTimerEvent = NULL;
	m_pTimer = NULL;

	// Inform transport layer who the server is. (So it no longer thinks it's DPID_ALL).
	m_lpSessionTransport->MigrateHost( dvidSource );
	m_dvidServer = m_lpSessionTransport->GetServerID();
	
	DVPROTOCOLMSG_FULLMESSAGE dvMessage;

	DPFX(DPFPREP,   DVF_INFOLEVEL, "Connect Accept Received" );

	m_dvSessionDesc.dwSize = sizeof( DVSESSIONDESC );
	m_dvSessionDesc.dwBufferAggressiveness = 0;
	m_dvSessionDesc.dwBufferQuality = 0;
	m_dvSessionDesc.dwFlags = lpdvConnectAccept->dwSessionFlags;
	m_dvSessionDesc.guidCT = lpdvConnectAccept->guidCT;
	m_dvSessionDesc.dwSessionType = lpdvConnectAccept->dwSessionType;

	HRESULT hr = DVCDB_GetCompressionInfo( lpdvConnectAccept->guidCT, &m_lpdvfCompressionInfo );

	if( FAILED( hr ) )
	{
		SetConnectResult( DVERR_COMPRESSIONNOTSUPPORTED );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid Compression Type" );
		SetEvent( m_hNotifyConnect );		
		return TRUE;
	}

	SetConnectResult( DV_OK );

	DV_DUMP_CIF( m_lpdvfCompressionInfo, 1 );
	
	SetEvent( m_hNotifyConnect );

	return TRUE;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandlePlayerList"
BOOL CDirectVoiceClientEngine::HandlePlayerList( DVID dvidSource, PDVPROTOCOLMSG_PLAYERLIST lpdvPlayerList, DWORD dwSize )
{
	DVPROTOCOLMSG_PLAYERJOIN dvMsgPlayerJoin;		// Used to fake out HandleCreateVoicePlayer
	DWORD dwIndex;


	// check structure size first so that we don't crash by accessing bad data
	if ( dwSize < sizeof( DVPROTOCOLMSG_PLAYERLIST ) || ( dwSize != (sizeof( DVPROTOCOLMSG_PLAYERLIST ) + ( lpdvPlayerList->dwNumEntries * sizeof(DVPROTOCOLMSG_PLAYERLIST_ENTRY ) ) ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandlePlayerList() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	DVPROTOCOLMSG_PLAYERLIST_ENTRY *pdvPlayerList = (DVPROTOCOLMSG_PLAYERLIST_ENTRY *) &lpdvPlayerList[1];

	// Get our host order ID
	m_dwHostOrderID	= lpdvPlayerList->dwHostOrderID;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Received player list.  Unpacking %d entries", lpdvPlayerList->dwNumEntries );

	for( dwIndex = 0; dwIndex < lpdvPlayerList->dwNumEntries; dwIndex++ )
	{
		dvMsgPlayerJoin.dwType = DVMSGID_CREATEVOICEPLAYER;
		dvMsgPlayerJoin.dvidID =  pdvPlayerList[dwIndex].dvidID;
		dvMsgPlayerJoin.dwFlags = pdvPlayerList[dwIndex].dwPlayerFlags;
		dvMsgPlayerJoin.dwHostOrderID = pdvPlayerList[dwIndex].dwHostOrderID;

		if( !HandleCreateVoicePlayer( dvidSource, &dvMsgPlayerJoin, sizeof( DVPROTOCOLMSG_PLAYERJOIN ) ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Handle voice player failed during unpack" );
			return FALSE;
		}
	}

	return TRUE;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyComplete_SyncWait"
//
// NotifyComplete_SyncWait
//
// This is a completion function for notifications which need to be performed synchronously.
//
void CDirectVoiceClientEngine::NotifyComplete_SyncWait( PVOID pvContext, CNotifyElement *pElement )
{
	HANDLE *pTmpHandle = (HANDLE *) pvContext;

	DNASSERT( pTmpHandle != NULL );	

	if( pTmpHandle != NULL && *pTmpHandle != NULL )
	{
		SetEvent( *pTmpHandle );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyComplete_RemotePlayer"
//
// NotifyComplete_RemotePlayer
//
// This is a completion function for when notification of a new remote player has been processed
//
void CDirectVoiceClientEngine::NotifyComplete_RemotePlayer( PVOID pvContext, CNotifyElement *pElement )
{
	CVoicePlayer *pPlayer = (CVoicePlayer *) pvContext;
	
	PDVMSG_CREATEVOICEPLAYER pCreatePlayer = NULL;

	if( pElement->m_etElementType == NOTIFY_DYNAMIC )
	{
		pCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) pElement->m_element.dynamic.m_lpData;
	}
	else
	{
		pCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) pElement->m_element.fixed.m_bFixedHolder;
	}

	DNASSERT( pPlayer != NULL );
	DNASSERT( pCreatePlayer->dwSize == sizeof( DVMSG_CREATEVOICEPLAYER ) );

	pPlayer->SetContext( pCreatePlayer->pvPlayerContext );
	pPlayer->SetAvailable( TRUE );
	
	pPlayer->Release();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyComplete_LocalPlayer"
//
// NotifyComplete_LocalPlayer
//
// This is a completion function for when notification of the local player has been processed
//
void CDirectVoiceClientEngine::NotifyComplete_LocalPlayer( PVOID pvContext, CNotifyElement *pElement )
{
	CDirectVoiceClientEngine *pvEngine = (CDirectVoiceClientEngine *) pvContext;

	PDVMSG_CREATEVOICEPLAYER pCreatePlayer = NULL;

	if( pElement->m_etElementType == NOTIFY_DYNAMIC )
	{
		pCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) pElement->m_element.dynamic.m_lpData;
	}
	else
	{
		pCreatePlayer = (PDVMSG_CREATEVOICEPLAYER) pElement->m_element.fixed.m_bFixedHolder;
	}	

	DNASSERT( pCreatePlayer->dwSize == sizeof( DVMSG_CREATEVOICEPLAYER ) );

	pvEngine->m_pvLocalPlayerContext = pCreatePlayer->pvPlayerContext;
	pvEngine->m_fLocalPlayerAvailable = TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleCreateVoicePlayer"
//
// HandleCreateVoicePlayer
//
// Performs initialization required to create the specified user's record.
//
// Players in the system will normall have a reference count of 3:
// - 1 for playback thread
// - 1 for notify thread
// - 1 for nametable
// 
// When a player is added they are added to the nametable as well as the
// pending lists for notify thread and playback thread.
//
// Both of these threads wakeup and:
// - Add any players on the "add list"
// - Remove any players who are marked disconnecting
//
BOOL CDirectVoiceClientEngine::HandleCreateVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERJOIN lpdvCreatePlayer, DWORD dwSize )
{
	if ( dwSize != sizeof( DVPROTOCOLMSG_PLAYERJOIN ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleCreateVoicePlayer() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidatePlayerFlags( lpdvCreatePlayer->dwFlags ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleCreateVoicePlayer() Ignoring message with invalid player flags, flags=0x%x, from=0x%x",
			lpdvCreatePlayer->dwFlags, dvidSource );
		return FALSE;
	}

	if( !ValidatePlayerDVID( lpdvCreatePlayer->dvidID ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleCreateVoicePlayer() Ignoring message with invalid player dvid, flags=0x%x, from=0x%x",
			lpdvCreatePlayer->dvidID, dvidSource );
		return FALSE;
	}
	
	if( m_dwCurrentState != DVCSTATE_CONNECTED )
		return TRUE;

	CVoicePlayer *newPlayer;
	HRESULT hr;
	QUEUE_PARAMS queueParams;

	hr = m_voiceNameTable.GetEntry( lpdvCreatePlayer->dvidID, &newPlayer, TRUE );

	// Ignore duplicate players
	if( hr == DV_OK )
	{
		newPlayer->Release();
		return TRUE;
	}

	DPFX(DPFPREP,  DVF_CONNECT_PROCEDURE_DEBUG_LEVEL, "Received Create for player ID 0x%x",lpdvCreatePlayer->dvidID );

	// Do not both creating a queue or a player entry for ourselves
	// Not needed
	if( lpdvCreatePlayer->dvidID != m_lpSessionTransport->GetLocalID() )
	{
		DPFX(DPFPREP,  DVF_CONNECT_PROCEDURE_DEBUG_LEVEL, "Creating player record" );

		newPlayer = m_fpPlayers.Get();

		if( newPlayer == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate new player record.  Alloc failure" );
			return TRUE;
		}

		hr = newPlayer->Initialize( lpdvCreatePlayer->dvidID, lpdvCreatePlayer->dwHostOrderID, lpdvCreatePlayer->dwFlags, NULL, &m_fpPlayers );

		if( FAILED( hr ) )
		{
			newPlayer->Release();
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initialize player record hr=0x%x", hr );
			return TRUE;
		}

        queueParams.wFrameSize = m_dwCompressedFrameSize;
        queueParams.bInnerQueueSize = m_lpdvfCompressionInfo->wInnerQueueSize;
        queueParams.bMaxHighWaterMark = m_lpdvfCompressionInfo->wMaxHighWaterMark, 
        queueParams.iQuality = m_dvClientConfig.dwBufferQuality;
        queueParams.iHops = 1;
        queueParams.iAggr = m_dvClientConfig.dwBufferAggressiveness;
        queueParams.bInitHighWaterMark = 2;
        queueParams.wQueueId = lpdvCreatePlayer->dvidID;
        queueParams.wMSPerFrame = m_lpdvfCompressionInfo->dwTimeout,
        queueParams.pFramePool = m_pFramePool;

		hr = newPlayer->CreateQueue( &queueParams );

		if( FAILED( hr ) )
		{
			newPlayer->Release();
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create queue for player hr=0x%x", hr );
			return TRUE;
		}

		hr = m_voiceNameTable.AddEntry( lpdvCreatePlayer->dvidID, newPlayer );

		if( FAILED( hr ) )
		{
			// Main ref
			newPlayer->Release();

			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to add entry to nametable hr=0x%x", hr );
			return TRUE;
		}

		if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
		{
			newPlayer->SetAvailable(TRUE);
		}

		// Add a reference for the player to the "Playback Add List"
		DNEnterCriticalSection( &m_csPlayAddList );
		newPlayer->AddRef();
		newPlayer->AddToPlayList( &m_blPlayAddPlayers );
		DNLeaveCriticalSection( &m_csPlayAddList );

		// Add a reference for the player to the "Notify Add List"
		DNEnterCriticalSection( &m_csNotifyAddList );
		newPlayer->AddRef();
		newPlayer->AddToNotifyList( &m_blNotifyAddPlayers );
		DNLeaveCriticalSection( &m_csNotifyAddList );

		// This will now be released by the callback, unless this is multicast
		//
		// Release our personal reference
		if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
		{
			newPlayer->Release();
		}
	}
	else
	{
		DPFX(DPFPREP,  DVF_CONNECT_PROCEDURE_DEBUG_LEVEL, "Local player, no player record required" );
	}

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
	{
		DVMSG_CREATEVOICEPLAYER dvCreatePlayer;		
		dvCreatePlayer.dvidPlayer = lpdvCreatePlayer->dvidID;
		dvCreatePlayer.dwFlags = lpdvCreatePlayer->dwFlags;	
		dvCreatePlayer.dwSize = sizeof( DVMSG_CREATEVOICEPLAYER );
		dvCreatePlayer.pvPlayerContext = NULL;

		// Prevents double notification for local player
		if( lpdvCreatePlayer->dvidID != m_lpSessionTransport->GetLocalID() )
		{
			NotifyQueue_Add( DVMSGID_CREATEVOICEPLAYER, &dvCreatePlayer, sizeof( DVMSG_CREATEVOICEPLAYER ), 
							newPlayer, NotifyComplete_RemotePlayer );
		} 
		else if( !m_fLocalPlayerNotify )
		{
		    // Add local player flag to notification
		    dvCreatePlayer.dwFlags |= DVPLAYERCAPS_LOCAL;

		    // Notify of local player (don't create player record)
			NotifyQueue_Add( DVMSGID_CREATEVOICEPLAYER, &dvCreatePlayer, sizeof( DVMSG_CREATEVOICEPLAYER ), 
							this, NotifyComplete_LocalPlayer );
			m_fLocalPlayerNotify = TRUE;
		} 
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::MigrateHost_RunElection"
//
// MigrateHost_RunElection
//
// Runs the host migration algorithm
//
HRESULT CDirectVoiceClientEngine::MigrateHost_RunElection(  )
{
	HRESULT hr;

	if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: We're disconnecting, no need to run algorithm" );
		return TRUE;
	}

	DWORD dwTransportSessionType, dwTransportFlags;	

	hr = m_lpSessionTransport->GetTransportSettings( &dwTransportSessionType, &dwTransportFlags );

	if( FAILED( hr ) )
	{
		DNASSERT( FALSE );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to retrieve transport settings hr=0x%x", hr );
		return DV_OK;
	}
	
	if( (m_dvSessionDesc.dwSessionType != DVSESSIONTYPE_PEER ) || 
		(m_dvSessionDesc.dwFlags & DVSESSION_NOHOSTMIGRATION) || 
		!(dwTransportFlags & DVTRANSPORT_MIGRATEHOST) )
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Host migration is disabled." );
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Host is gone.  Session will exit soon."  );

		if( m_dwCurrentState == DVCSTATE_CONNECTING )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Aborting connection..." );
			
			SendConnectResult();

			SetEvent( m_hConnectAck );			
		}

		DoSessionLost(DVERR_SESSIONLOST);

		return DV_OK;
	}	

	// This shortcut prevents problems if this is called twice.
	// But only if we're lucky enough this got set before this poin
	// We also have to guard against this case in HostMigrateCreate
	//
	//
	if( m_lpdvServerMigrated != NULL )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Skipping calling removeplayer again as host already migrated" );
		return DV_OK;
	}

	DWORD dwHostOrderID = DVPROTOCOL_HOSTORDER_INVALID;

	DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Player 0x%x is running election algorithm", this->m_dvidLocal );

	// Prevent double-create from host migration run.  This can be called by removeplayer and by hostmigrateleave
	// message.
	CDVCSLock m_guardLock(&m_csClassLock);
	m_guardLock.Lock();	

    // Trust me.  Do this.
	DVID dvidNewHost = m_dvidLocal;

	// Check everyone else in the session, see who has lowest host order ID
	dwHostOrderID = m_voiceNameTable.GetLowestHostOrderID(&dvidNewHost);

	// We're lower then everyone else.. We should become new host
	if( m_dwHostOrderID <= dwHostOrderID )
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: We're to become the new host" );
		dvidNewHost = m_dvidLocal;
	}
	
	DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: New Host is [0x%x] OrderID [0x%x] Current [0x%x]", dvidNewHost, dwHostOrderID, m_dwMigrateHostOrderID );

	if( m_dwMigrateHostOrderID != DVPROTOCOL_HOSTORDER_INVALID && dwHostOrderID <= m_dwMigrateHostOrderID )
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: No need to run algorithm again -- in progress (0x%x)", dvidNewHost );
		m_guardLock.Unlock();			
		return DV_OK;
	}

	m_dwMigrateHostOrderID = dwHostOrderID;

    m_lpSessionTransport->MigrateHost( dvidNewHost );
    m_dvidServer = m_lpSessionTransport->GetServerID();			
    DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Host is (2) [0x%x]", m_dvidServer );	

    m_guardLock.Unlock();

	// No one was found and we're not properly connected yet
	if( dwHostOrderID == DVPROTOCOL_HOSTORDER_INVALID && m_dwCurrentState != DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "There is no one to take over session.  Disconnect" );

		// We're connecting.. expected behaviour
		if( m_dwCurrentState == DVCSTATE_CONNECTING )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Aborting connection..." );
			
			SendConnectResult();

			SetEvent( m_hConnectAck );			

			DoSessionLost(DVERR_SESSIONLOST);
		}
		// We're already disconnecting
		else if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already disconnecting.." );
		}
	}
	// Candidate was found, it's us!
	else if( m_dwHostOrderID <= dwHostOrderID )
	{

		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: We think we're the host!  Our Host Order ID=0x%x", m_dwHostOrderID );
		
		hr = HandleLocalHostMigrateCreate();			

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Host migrate failed hr=0x%x", hr );
		}
	}
	// Someone was elected -- not us!
	//
	// We send a settings confirm message in case we ignored host migration message
	// during our election.  (Small, but reproducable window).
	//
	// If we do get it after this host may get > 1 settings confirm from us (which is handled).
	//
	else if( dwHostOrderID != DVPROTOCOL_HOSTORDER_INVALID )
	{
		hr = Send_SettingsConfirm();

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Settings confirm message failed! sent hr=0x%x", hr );
		}

		DVMSG_HOSTMIGRATED dvHostMigrated;
		dvHostMigrated.dvidNewHostID = m_dvidServer;
		dvHostMigrated.pdvServerInterface = NULL;
		dvHostMigrated.dwSize = sizeof( DVMSG_HOSTMIGRATED );

    		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Sending notification because of election" );		
		
		NotifyQueue_Add( DVMSGID_HOSTMIGRATED, &dvHostMigrated, sizeof( DVMSG_HOSTMIGRATED )  );	
	}

	return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleDeleteVoicePlayer"
//
// HandleDeleteVoicePlayer
//
// Handles the DVMSGID_DELETEVOICEPLAYER message.
//
BOOL CDirectVoiceClientEngine::HandleDeleteVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERQUIT lpdvDeletePlayer, DWORD dwSize )
{
	CVoicePlayer *pPlayer;
	HRESULT hr;

	if ( dwSize != sizeof( DVPROTOCOLMSG_PLAYERQUIT ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleDeleteVoicePlayer() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	hr = m_voiceNameTable.GetEntry( lpdvDeletePlayer->dvidID, &pPlayer, TRUE );

	// If there is a player entry for the given ID, 
	// Handle removing them from the local player table
	if( pPlayer != NULL )
	{
		// Remove the entry, this will also drop the reference count
		hr = m_voiceNameTable.DeleteEntry( lpdvDeletePlayer->dvidID );

		// Another thread has already remove the player -- we don't need to do the rest
		// of this.  
		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error, could not find entry 0x%x to delete hr=0x%x", dvidSource, hr );
			pPlayer->Release();
			return TRUE;
		}

		// Mark player record as disconnected
		pPlayer->SetDisconnected();

		// Wait for global object lock and then remove target
//		CDVCSLock guardLock(&m_csClassLock);
//		guardLock.Lock();
		CheckForAndRemoveTarget( lpdvDeletePlayer->dvidID );
//		guardLock.Unlock();

		// If there are any buffers for this player, delete them
		// We don't need to destroy them, we want to save them so the user can call
		// Delete3DUserBuffer
		//
	    //DeleteSoundTarget( lpdvDeletePlayer->dvidID );

		if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
		{
			DVMSG_DELETEVOICEPLAYER dvMsgDeletePlayer;
			
			// Event for doing sync wait
			HANDLE hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

			dvMsgDeletePlayer.dvidPlayer = lpdvDeletePlayer->dvidID;
			dvMsgDeletePlayer.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
			dvMsgDeletePlayer.pvPlayerContext = pPlayer->GetContext();

			pPlayer->SetContext( NULL );

			// By making this synchronous we ensure that the voice notification has completed before the dplay8 
			// callback is called. 
			// 
			NotifyQueue_Add( DVMSGID_DELETEVOICEPLAYER, &dvMsgDeletePlayer, sizeof( DVMSG_DELETEVOICEPLAYER ), &hEvent, NotifyComplete_SyncWait );

			if( hEvent )
			{
				WaitForSingleObject( hEvent, INFINITE );				
				CloseHandle( hEvent );					
			}

		}

		pPlayer->Release();
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::QueueSpeech"
//
// QueueSpeech
//
// Process and queue incoming audio
//
BOOL CDirectVoiceClientEngine::QueueSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize )
{
	CVoicePlayer *pPlayerInfo;
	HRESULT hr;

	// Only start receiving voice if the local player is active
	if( !m_fLocalPlayerAvailable )
	{
		DPFX(DPFPREP,  1, "Ignoring incoming audio, local player has not been indicated" );
		return TRUE;
	}
	
	hr = m_voiceNameTable.GetEntry( dvidSource, &pPlayerInfo, TRUE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  1, "Received speech for player who is not in nametable hr=0x%x", hr );
		return TRUE;
	}

	if( !pPlayerInfo->IsAvailable() )
	{
		DPFX(DPFPREP,  1, "Player is not yet available, ignoring speech" );
	}
	else
	{
		hr = pPlayerInfo->HandleReceive( pdvSpeechHeader, pbData, dwSize );

		if( FAILED( hr ) )
		{
			pPlayerInfo->Release();
			DPFX(DPFPREP,  1, "Received speech could not be buffered hr=0x%x", hr );
			return TRUE;
		}

		// STATSBLOCK: Begin
		m_pStatsBlob->m_dwPRESpeech++;
		// STATSBLOCK: End
	}

	// Release our reference to the player
	pPlayerInfo->Release();
		
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSpeechWithFrom"
//
// HandleSpeech
//
// Handles speech data messages
//
BOOL CDirectVoiceClientEngine::HandleSpeechWithFrom( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHFROM lpdvSpeech, DWORD dwSize )
{
	HRESULT hr;

	if ( dwSize < sizeof( DVPROTOCOLMSG_SPEECHWITHFROM ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeechWithFrom() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidateSpeechPacketSize( m_lpdvfCompressionInfo, dwSize - sizeof( DVPROTOCOLMSG_SPEECHWITHFROM ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeechWithFrom() Ignoring message with invalid speech size, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidatePlayerDVID( lpdvSpeech->dvidFrom ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeechWithFrom() Ignoring message with invalid player dvid, flags=0x%x, from=0x%x",
			lpdvSpeech->dvidFrom, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,  DVF_INFOLEVEL, "Received multicast speech!" );

	if( lpdvSpeech->dvidFrom == m_dvidLocal )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Ignoring loopback speech!" );	
		return TRUE;
	}

	CVoicePlayer *pPlayerInfo;	

	hr = m_voiceNameTable.GetEntry( lpdvSpeech->dvidFrom, &pPlayerInfo, TRUE );
	
	if( FAILED( hr ) )
	{
		DVPROTOCOLMSG_PLAYERJOIN dvPlayerJoin;
		dvPlayerJoin.dwFlags = 0;
		dvPlayerJoin.dvidID = lpdvSpeech->dvidFrom;
		HandleCreateVoicePlayer( lpdvSpeech->dvidFrom, &dvPlayerJoin, sizeof( DVPROTOCOLMSG_PLAYERJOIN ) );
	}
	else
	{
		pPlayerInfo->Release();
	}

	return QueueSpeech( lpdvSpeech->dvidFrom, &lpdvSpeech->dvHeader, (PBYTE) &lpdvSpeech[1], dwSize-sizeof(DVPROTOCOLMSG_SPEECHWITHFROM) );

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSpeechBounce"
//
// HandleSpeech
//
// Handles speech data messages
//
BOOL CDirectVoiceClientEngine::HandleSpeechBounce( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize )
{
	if ( dwSize < sizeof( DVPROTOCOLMSG_SPEECHHEADER ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeechBounce() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidateSpeechPacketSize( m_lpdvfCompressionInfo, dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeechBounce() Ignoring message with invalid speech size, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,  DVF_INFOLEVEL, "Received speech bounce!" );

	return QueueSpeech( dvidSource, lpdvSpeech, (PBYTE) &lpdvSpeech[1], dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSpeech"
//
// HandleSpeech
//
// Handles speech data messages
//
BOOL CDirectVoiceClientEngine::HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize )
{
	if ( dwSize < sizeof( DVPROTOCOLMSG_SPEECHHEADER ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeech() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidateSpeechPacketSize( m_lpdvfCompressionInfo, dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSpeech() Ignoring message with invalid speech size, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,  DVF_INFOLEVEL, "Received bare speech!" );

	// Ignore speech from ourselves
	if( dvidSource == m_dvidLocal )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Ignoring loopback speech!" );		
		return TRUE;
	}

	return QueueSpeech( dvidSource, lpdvSpeech, (PBYTE) &lpdvSpeech[1], dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::Cleanup"
//
// Cleanup
//
// WARNING: Do not call this function multiple times on the same object.
//
// This function shuts down the recording and playback threads, shuts down
// the sound system and unhooks the object from the dplay object.
// 
// Called By:
// - DoDisconnect
// - Destructor 
// - HandleConnectAccept
// - NotifyThread
//
// Locks Required:
// - Global Write Lock
//
void CDirectVoiceClientEngine::Cleanup()
{
	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Cleanup called!" );	

	// Enter cleanup critical section.  Only one instance should be in here at a time.  
	DNEnterCriticalSection( &m_csCleanupProtect );	
	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	// We only need to cleanup if we're not idle
	if( m_dwCurrentState == DVCSTATE_IDLE )
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Cleanup not required" );
		return;
	}

	if( m_hRecordThreadHandle )
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Signalling record to terminate" );
		
		// Signal record thread to shutdown
		SetEvent( m_hRecordTerminate );

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Record signalled" );

		// Release write lock, if we don't we may have a deadlock
		// because recordthread can't get dplay lock, which means
		// can't shutdown
		//
		// Part of a three way deadlock case.
		guardLock.Unlock();

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Waiting for record shutdown" );		
		
		WaitForSingleObject( m_hRecordDone, INFINITE );

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Record shutdown complete" );				

		// Re-acquire lock, we need it.
		guardLock.Lock();

		m_hRecordThreadHandle = NULL;			
	}

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Record cleanup" );						

	if( m_hRecordTerminate )
	{
		CloseHandle( m_hRecordTerminate );
		m_hRecordTerminate = NULL;
	}

	if( m_hRecordDone )
	{
		CloseHandle( m_hRecordDone );
		m_hRecordDone = NULL;
	}

	
	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Record cleanup complete" );

	if( m_hPlaybackThreadHandle != NULL )
	{
		// Signal playback thread to shutdown
		SetEvent( m_hPlaybackTerminate );

		// Release write lock to prevent deadlock.
		//
		guardLock.Unlock();
		
		WaitForSingleObject( m_hPlaybackDone, INFINITE );

		// Re-acquire lock, we need it.
		guardLock.Lock();

		m_hPlaybackThreadHandle = NULL;
	}

	if( m_hPlaybackTerminate )
	{
		CloseHandle( m_hPlaybackTerminate );
		m_hPlaybackTerminate = NULL;		
	}

	if( m_hPlaybackDone )
	{
		CloseHandle( m_hPlaybackDone );
		m_hPlaybackDone = NULL;
	}
		
	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Playback Thread Done" );

	ClientStats_End();

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Threads gone!" );

	// If we're running in client/server we need destroy the server
	// buffer.
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING ||
		m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO )
	{
		DeInitializeClientServer();
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Client/Server Gone" );
	}

	guardLock.Unlock();

	// Disable notifications, no notifications after this point can be made
	NotifyQueue_Disable();	

	// The following code is extremely sensitive.
	//
	// Be careful about the order here, it's important.

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Waiting for outstanding sends" );	
	// Wait for outstanding buffer sends to complete before
	// continuing.  Otherwise you have potential crash / leak
	// condition
	WaitForBufferReturns();

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Disconnecting transport" );
	// After this function returns DirectPlay will no longer sends
	// us indication, but some may still be in progress.
	m_lpSessionTransport->DisableReceiveHook( );

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Flushing notification queue" );
	// Ensuring that all notifications have been sent 
	NotifyQueue_Flush();

	// Waiting for transport to return all the threads it is indicating into us on.
	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Waiting for transport threads to complete" );
	m_lpSessionTransport->WaitForDetachCompletion();

	// Re-enable notifications
	NotifyQueue_Enable();

	guardLock.Lock();

	if( m_pTimer != NULL )
	{
		delete m_pTimer;
		m_pTimer = NULL;		
	}

	if( m_thTimerInfo.hPlaybackTimerEvent != NULL )
	{
		CloseHandle( m_thTimerInfo.hPlaybackTimerEvent );
		m_thTimerInfo.hPlaybackTimerEvent  = NULL;		
	}

	if( m_thTimerInfo.hRecordTimerEvent != NULL )
	{
		CloseHandle( m_thTimerInfo.hRecordTimerEvent );
		m_thTimerInfo.hRecordTimerEvent = NULL;		
	}

	CleanupPlaybackLists();
	CleanupNotifyLists();

    // Inform player of their own exit if they were connected!

    if( m_fLocalPlayerNotify )
    {
    	DVMSG_DELETEVOICEPLAYER dvMsgDelete;    
        dvMsgDelete.dvidPlayer = m_dvidLocal;
        dvMsgDelete.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
        dvMsgDelete.pvPlayerContext = m_pvLocalPlayerContext;

		m_pvLocalPlayerContext = NULL;
		m_fLocalPlayerNotify = FALSE;        
		m_fLocalPlayerAvailable = FALSE;

        TransmitMessage( DVMSGID_DELETEVOICEPLAYER, &dvMsgDelete, sizeof( DVMSG_DELETEVOICEPLAYER ) );
    }
	
	m_voiceNameTable.DeInitialize( (m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER), m_lpUserContext, m_lpMessageHandler);

	// Hold off on the shutdown of the sound system so user notifications
	// of delete players on unravel of nametable can be handled correctly. 
	// 
	ShutdownSoundSystem();

	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Sound system shutdown" );

	m_fpPlayers.Deinitialize();
    FreeBuffers();

	if( m_pFramePool != NULL )
	{
	    DNEnterCriticalSection( &CDirectVoiceEngine::s_csSTLLock );			
		delete m_pFramePool;
		m_pFramePool = NULL;
		DNLeaveCriticalSection( &CDirectVoiceEngine::s_csSTLLock );
	}

	SetCurrentState( DVCSTATE_IDLE );

	DNEnterCriticalSection( &m_csTargetLock );

	if( m_pdvidTargets != NULL )
	{
		delete [] m_pdvidTargets;
		m_pdvidTargets = NULL;
		m_dwNumTargets = 0;
		m_dwTargetVersion = 0;
	}

	DNLeaveCriticalSection( &m_csTargetLock );
	DNLeaveCriticalSection( &m_csCleanupProtect );	

	ClientStats_Dump();	

	// Remove us from the list of apps running
	PERF_RemoveEntry( m_perfInfo.guidInternalInstance, &m_perfAppInfo );
	m_pStatsBlob = NULL;

	ZeroMemory( &m_perfInfo, sizeof( PERF_APPLICATION ) );
	ZeroMemory( &m_perfAppInfo, sizeof( PERF_APPLICATION_INFO ) );

	SetEvent( m_hDisconnectAck );

	guardLock.Unlock();

	if( m_lpdvServerMigrated != NULL )
	{
		m_lpdvServerMigrated->Release();
		m_lpdvServerMigrated = NULL;
	}
}

// WaitForBufferReturns
//
// This function waits until oustanding sends have completed before continuing
// we use this to ensure we don't deregister with outstanding sends.
// 
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::WaitForBufferReturns"
void CDirectVoiceClientEngine::WaitForBufferReturns()
{
	if( m_pBufferDescPool == NULL )
		return;

	while( 1 ) 
	{
		DNEnterCriticalSection( &m_pBufferDescPool->cs );

		if( m_pBufferDescPool->nInUse == 0 )
		{
			DNLeaveCriticalSection( &m_pBufferDescPool->cs );			
			break;
		}

		DNLeaveCriticalSection( &m_pBufferDescPool->cs );

		Sleep( 20 );
	}

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoDisconnect"
//
// DoDisconnect
//
// Performs a disconnection and informs the callback function.
//
// Used for both session lost and normal disconnects.
//
// Called By:
// - NotifyThread
// 
void CDirectVoiceClientEngine::DoDisconnect()
{
	// Guard to prevent this function from being called more then once on the
	// same object
	if( m_dwCurrentState == DVCSTATE_IDLE ||
	    m_dwCurrentState == DVCSTATE_NOTINITIALIZED )
		return;
		
	m_dwCurrentState = DVCSTATE_DISCONNECTING;
	
	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "DoDisconnect called!" );
	
	Cleanup();

	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Cleanup complete" );

	if( m_fSessionLost )
	{
		DVMSG_SESSIONLOST dvSessionLost;
		dvSessionLost.hrResult = m_hrDisconnectResult;
		dvSessionLost.dwSize = sizeof( DVMSG_SESSIONLOST );
		
		NotifyQueue_Add( DVMSGID_SESSIONLOST, &dvSessionLost, sizeof( DVMSG_SESSIONLOST ) );
	}
	else
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Signalling disconnect result" );
		SendDisconnectResult();
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Done signalling disconnect" );
	}

	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Disconnect complete" );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleDisconnect"
// HandleDisconnect
//
// This function is called when a disconnect message is received from the
// server.  
//
BOOL CDirectVoiceClientEngine::HandleDisconnectConfirm( DVID dvidSource, PDVPROTOCOLMSG_DISCONNECT lpdvDisconnect, DWORD dwSize )
{
	if ( dwSize != sizeof( DVPROTOCOLMSG_DISCONNECT ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleDisconnectConfirm() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "DisconnectConfirm received, signalling worker [res=0x%x]", lpdvDisconnect->hresDisconnect );

	DoSignalDisconnect( lpdvDisconnect->hresDisconnect );

	DPFX(DPFPREP,   DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "DisconnectConfirm received, signalled worker" );	

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleSessionLost"
BOOL CDirectVoiceClientEngine::HandleSessionLost( DVID dvidSource, PDVPROTOCOLMSG_SESSIONLOST lpdvSessionLost, DWORD dwSize )
{
	if ( dwSize != sizeof( DVPROTOCOLMSG_SESSIONLOST ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVCE::HandleSessionLost() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "DVCE::HandleSessionLost() begin" );

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "<><><><><><><> Session Host has shutdown - Voice Session is gone." );

	DoSessionLost( lpdvSessionLost->hresReason );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::StartTransportSession"
HRESULT CDirectVoiceClientEngine::StartTransportSession( )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::StopTransportSession"
// StopSession
//
// This function is called when the directplay session is lost or stops
// before DirectXVoice is disconnected.
//
HRESULT CDirectVoiceClientEngine::StopTransportSession()
{
	DoSessionLost( DVERR_SESSIONLOST );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::AddPlayer"
HRESULT CDirectVoiceClientEngine::AddPlayer( DVID dvID )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleLocalHostMigrateCreate"
HRESULT CDirectVoiceClientEngine::HandleLocalHostMigrateCreate()
{
	LPDIRECTVOICESERVEROBJECT lpdvsServerObject = NULL;
	LPBYTE lpSessionBuffer = NULL;
	DWORD dwSessionSize = 0;
	HRESULT hr = DP_OK;
	CDirectVoiceDirectXTransport *pTransport;

	// Prevent double-create from host migration run.
	CDVCSLock m_guardLock(&m_csClassLock);
	m_guardLock.Lock();	

	if( m_lpdvServerMigrated )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Duplicate host create received.  Ignoring" );
		return DV_OK;
	}

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Local client has become the new host.  Creating a host" );

	hr = DVS_Create( &lpdvsServerObject );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create server object. hr=0x%x", hr );
		goto HOSTCREATE_FAILURE;
	}

	// Grab a reference local of the new host interface
	m_lpdvServerMigrated = (LPDIRECTPLAYVOICESERVER) lpdvsServerObject;	

	m_guardLock.Unlock();

	IncrementObjectCount();	

	lpdvsServerObject->lIntRefCnt++;

	DVMSG_LOCALHOSTSETUP dvMsgLocalHostSetup;
	dvMsgLocalHostSetup.dwSize = sizeof( DVMSG_LOCALHOSTSETUP );
	dvMsgLocalHostSetup.pvContext = NULL;
	dvMsgLocalHostSetup.pMessageHandler = NULL;

	TransmitMessage( DVMSGID_LOCALHOSTSETUP, &dvMsgLocalHostSetup,  sizeof( DVMSG_LOCALHOSTSETUP ) );					

	pTransport = (CDirectVoiceDirectXTransport *) m_lpSessionTransport;	

	hr = DV_Initialize( lpdvsServerObject, pTransport->GetTransportInterface(), dvMsgLocalHostSetup.pMessageHandler, dvMsgLocalHostSetup.pvContext, NULL, 0 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initialize the server object hr=0x%x", hr );
		goto HOSTCREATE_FAILURE;
	}

	hr = lpdvsServerObject->lpDVServerEngine->HostMigrateStart( &m_dvSessionDesc, m_dwHostOrderID+DVMIGRATE_ORDERID_OFFSET );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error starting server object hr=0x%x", hr );
		goto HOSTCREATE_FAILURE;
	}

	DVMSG_HOSTMIGRATED dvHostMigrated;
	dvHostMigrated.dvidNewHostID = m_lpSessionTransport->GetLocalID();
	dvHostMigrated.pdvServerInterface = (LPDIRECTPLAYVOICESERVER) lpdvsServerObject;
	dvHostMigrated.dwSize = sizeof( DVMSG_HOSTMIGRATED );

	NotifyQueue_Add( DVMSGID_HOSTMIGRATED, &dvHostMigrated, sizeof( DVMSG_HOSTMIGRATED )  );	
	
	return DV_OK;

HOSTCREATE_FAILURE:

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Informing clients of our failure to create host" );

	Send_SessionLost();

	if( lpdvsServerObject != NULL )
	{
		DVS_Release( lpdvsServerObject );
	}

	return hr;
}

// Handles remove player message
//
// This message triggers handling of host migration if the player
// who has dropped out happens to be the session host.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::RemovePlayer"
HRESULT CDirectVoiceClientEngine::RemovePlayer( DVID dvID )
{
	HRESULT hr;

	CDVCSLock m_guardLock(&m_csClassLock);
	m_guardLock.Lock();

    if( m_dwCurrentState == DVCSTATE_DISCONNECTING )
    {
        DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Ignoring transport disconnect for 0x%x -- client is disconnecting", dvID );
        return DV_OK;
    }
	m_guardLock.Unlock();


	CVoicePlayer *pVoicePlayer;

	/*hr = m_voiceNameTable.GetEntry( dvID, &pVoicePlayer, FALSE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  5, "Ignoring duplicate removeplayer hr=0x%x", hr );
		return DV_OK;
	}*/

	DVPROTOCOLMSG_PLAYERQUIT dvPlayerQuit;

	dvPlayerQuit.dwType = DVMSGID_DELETEVOICEPLAYER;
	dvPlayerQuit.dvidID = dvID;

	HandleDeleteVoicePlayer( 0, &dvPlayerQuit, sizeof( DVPROTOCOLMSG_PLAYERQUIT ) );		

	// The person who dropped out was the server
	if( dvID == m_lpSessionTransport->GetServerID() )
	{
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Checking to see if remove of 0x%x is host 0x%x", dvID, m_lpSessionTransport->GetServerID() );
		DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Triggered by Remove Player Message" );

		MigrateHost_RunElection();
	}

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetCurrentState"
// SetCurrentState
//
// Sets the current state of the client engine
// 
void CDirectVoiceClientEngine::SetCurrentState( DWORD dwState )
{
	CDVCSLock m_guardLock(&m_csClassLock);
	m_guardLock.Lock();
	m_dwCurrentState = dwState;
	m_guardLock.Unlock();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckShouldSendMessage"
//
// CheckShouldSendMessage
//
// Checks the notification mask to see if the specified message type should
// be sent to the user. 
//
BOOL CDirectVoiceClientEngine::CheckShouldSendMessage( DWORD dwMessageType )
{
	if( m_lpMessageHandler == NULL )
	{
		return FALSE;
	}
	
    BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();

	BOOL fSend = FALSE;	    

    if( m_dwNumMessageElements == 0 )
    {
    	return TRUE;
    }
    else
    {
	    for( DWORD dwIndex = 0; dwIndex < m_dwNumMessageElements; dwIndex++ )
	    {
	    	if( m_lpdwMessageElements[dwIndex] == dwMessageType )
	    	{
				return TRUE;
	    	}
	    }
	}

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::TransmitMessage"
//
// TransmitMessage
//
// Called to send a notification to the user.  
//
// Only the notify thread should call this function, all other threads should queue up 
// notifications by calling NotifyQueue_Add.
//
// Called By:
// - NotifyThread.
//
void CDirectVoiceClientEngine::TransmitMessage( DWORD dwMessageType, LPVOID lpData, DWORD dwSize )
{
	if( CheckShouldSendMessage( dwMessageType ) )
	{
		(*m_lpMessageHandler)( m_lpUserContext, dwMessageType, (!dwSize) ? NULL : lpData );	    		
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckForDuplicateObjects"
HRESULT CDirectVoiceClientEngine::CheckForDuplicateObjects()
{
	HRESULT hr;
	LPKSPROPERTYSET lpksPropSet = NULL;
    DSPROPERTY_DIRECTSOUND_OBJECTS_DATA* pDSList = NULL;
    DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA* pDSCList = NULL;
    DWORD dwIndex;
    BOOL fFound;

	hr = DirectSoundPrivateCreate( &lpksPropSet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to check for usage of duplicate devices hr=0x%x", hr );
		return DV_OK;
	}

	hr = PrvGetDirectSoundObjects( lpksPropSet, GUID_NULL, &pDSList );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve process sound objs hr=0x%x", hr );
		hr = DV_OK;
	}
	// Check list for duplicate of the one we are using.
	else
	{
		// User specified a device, be nice and print a debug message if the object doesn't
		// match the GUID
		if( m_dvSoundDeviceConfig.lpdsPlaybackDevice != NULL )
		{	
			fFound = FALSE;
			
			// Check the internal list
			for( dwIndex = 0; dwIndex < pDSList->Count; dwIndex++ )
			{
				// Check to see if object user specified matches this one.
				if( pDSList->Objects[dwIndex].DirectSound == m_dvSoundDeviceConfig.lpdsPlaybackDevice )
				{
					if( m_dvSoundDeviceConfig.guidPlaybackDevice != pDSList->Objects[dwIndex].DeviceId )
					{
						// Expected behaviour with emulated object
						DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified GUID is not correct for specified dsound object" );
						fFound = FALSE;
					}
					else
					{	
						fFound = TRUE;
						DPFX(DPFPREP,  DVF_INFOLEVEL, "GUID for device matches object.  User param valid" );
					}
					break;
				}
			}

			// We didn't find specified object in dsound's list.
			// Could be an error condition, but would prevent emulated objects from working.
			if( !fFound )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified DirectSound object does not exist" );
			}
		}
		// No object specified.
		else
		{
			// Check the internal list to see if we need to make use of an existing object
			for( dwIndex = 0; dwIndex < pDSList->Count; dwIndex++ )
			{
				// We have a winner, a matching playback device.  
				if( m_dvSoundDeviceConfig.guidPlaybackDevice == pDSList->Objects[dwIndex].DeviceId )
				{
					hr = pDSList->Objects[dwIndex].DirectSound->QueryInterface( IID_IDirectSound, (void **) &m_dvSoundDeviceConfig.lpdsPlaybackDevice );

					if( FAILED( hr ) )
					{
						DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to retrieve dsound int for existing dsound object hr=0x%x", hr );
						hr = DVERR_INVALIDDEVICE;

						goto EXIT_SOUND_CHECK;
					}

					break;
				}
			}
		}
	}

	hr = PrvGetDirectSoundCaptureObjects( lpksPropSet, GUID_NULL, &pDSCList );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve process cap objs hr=0x%x", hr );
		hr = DV_OK;
	}
	// Check list for duplicate of the one we are using
	else
	{
		// User specified a device, be nice and print a debug message if the object doesn't
		// match the GUID
		if( m_dvSoundDeviceConfig.lpdsCaptureDevice != NULL )
		{	
			fFound = FALSE;
			
			// Check the internal list
			for( dwIndex = 0; dwIndex < pDSCList->Count; dwIndex++ )
			{
				// Check to see if object user specified matches this one.
				if( pDSCList->Objects[dwIndex].DirectSoundCapture == m_dvSoundDeviceConfig.lpdsCaptureDevice )
				{
					if( m_dvSoundDeviceConfig.guidCaptureDevice != pDSCList->Objects[dwIndex].DeviceId )
					{
						// Expected behaviour with emulated object
						DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified GUID is not correct for specified dsound object" );
						fFound = FALSE;
					}
					else
					{	
						fFound = TRUE;
						DPFX(DPFPREP,  DVF_INFOLEVEL, "GUID for device matches object.  User param valid" );
					}
					break;
				}
			}

			// We didn't find specified object in dsound's list.
			// Could be an error condition, but would prevent emulated objects from working.
			if( !fFound )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified DirectSoundCap object does not exist" );
			}
		}
	
	}

EXIT_SOUND_CHECK:

	if( pDSList != NULL )
	{
		delete [] pDSList;
	}

	if( pDSCList != NULL )
	{
		delete [] pDSCList;
	}

	lpksPropSet->Release();

	return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InitializeSoundSystem"
// InitializeSoundSystem
//
// Starts up the sound system based on the parameters.
//
HRESULT CDirectVoiceClientEngine::InitializeSoundSystem()
{
	HRESULT hr;

	Diagnostics_Begin( s_fDumpDiagnostics, "dpv_main.txt" );
	DSERRTRACK_Reset();

	Diagnostics_DeviceInfo( &m_dvSoundDeviceConfig.guidPlaybackDevice, &m_dvSoundDeviceConfig.guidCaptureDevice );

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "DVCE::InitializeSoundSystem() Begin" );

	// Note: Mapping of default devices has already been performed.
	//       On Pre DX7.1 systems, all default devices map to GUID_NULL
	//       On DX7.1 and later, default device will have been mapped to their real GUIDs
	//
	m_dwCompressedFrameSize = m_lpdvfCompressionInfo->dwFrameLength;
	m_dwUnCompressedFrameSize = DVCDB_CalcUnCompressedFrameSize( m_lpdvfCompressionInfo, s_lpwfxPlaybackFormat );
	m_dwNumPerBuffer = m_lpdvfCompressionInfo->dwFramesPerBuffer;

	// Setup the description for the main playback buffer
	//
	// Needs to be after above because it depends on proper values above
	SetupPlaybackBufferDesc( &m_dsBufferDesc, NULL );

	// If they gave us an object, just use it
	if( m_dvSoundDeviceConfig.lpdsPlaybackDevice != NULL )
	{
		CDirectSoundPlaybackDevice *tmpDevice;
		
		tmpDevice = new CDirectSoundPlaybackDevice( );
		
		if( tmpDevice == NULL )
		{
			DPFX(DPFPREP,   DVF_ERRORLEVEL, "Failed to alloc memory" );
			return DVERR_OUTOFMEMORY;
		}

		hr = tmpDevice->Initialize( m_dvSoundDeviceConfig.lpdsPlaybackDevice, m_dvSoundDeviceConfig.guidPlaybackDevice );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,   DVF_ERRORLEVEL, "Error initalizing playback device from specified object hr=0x%x", hr );
			delete tmpDevice;
			return hr;
		}

		m_audioPlaybackDevice = tmpDevice;
	}

	// If they gave us an object, just use it
	if( m_dvSoundDeviceConfig.lpdsCaptureDevice != NULL )
	{
		CDirectSoundCaptureRecordDevice *tmpRecDevice;
		
		tmpRecDevice = new CDirectSoundCaptureRecordDevice( );
		
		if( tmpRecDevice == NULL )
		{
			if( m_audioPlaybackDevice != NULL )
			{
				delete m_audioPlaybackDevice;
				m_audioPlaybackDevice = NULL;
			}
			
			Diagnostics_Write( DVF_ERRORLEVEL, "Failed to alloc memory" );
			return DVERR_OUTOFMEMORY;
		}

		hr = tmpRecDevice->Initialize( m_dvSoundDeviceConfig.lpdsCaptureDevice, m_dvSoundDeviceConfig.guidCaptureDevice );

		if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "Error initializing record device from specified object hr=0x%x", hr );
			if( m_audioPlaybackDevice != NULL )
			{
				delete m_audioPlaybackDevice;
				m_audioPlaybackDevice = NULL;
			}			
			delete tmpRecDevice;
			return hr;
		}

		m_audioRecordDevice = tmpRecDevice;
	}

	// We were passed a buffer by the user
	if( m_dvSoundDeviceConfig.lpdsMainBuffer )
	{
		m_audioPlaybackBuffer = new CDirectSoundPlaybackBuffer( m_dvSoundDeviceConfig.lpdsMainBuffer );

		if( !m_audioPlaybackBuffer )
		{
			Diagnostics_Write(  DVF_ERRORLEVEL, "Error allocating memory" );

			if( m_audioPlaybackDevice )
			{
				delete m_audioPlaybackDevice;
				m_audioPlaybackDevice = NULL;
			}

			if( m_audioRecordDevice )
			{
				delete m_audioRecordDevice;
				m_audioRecordDevice = NULL;
			}

			return DVERR_OUTOFMEMORY;
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Creating a buffer using buffer user gave us." );
	}
	
	// If we haven't initialized half duplex
	if( !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX) )
	{ 
        hr = InitFullDuplex(   m_dvSoundDeviceConfig.hwndAppWindow, 
                          	m_dvSoundDeviceConfig.guidPlaybackDevice,
                          	&m_audioPlaybackDevice,
                          	&m_dsBufferDesc,
							&m_audioPlaybackBuffer,
                            m_dvSoundDeviceConfig.guidCaptureDevice,
                            &m_audioRecordDevice,
                            &m_audioRecordBuffer,
                            m_lpdvfCompressionInfo->guidType,
                            this->s_lpwfxPrimaryFormat,
                            this->s_lpwfxPlaybackFormat,
                            this->s_fASO,
                            this->m_dvSoundDeviceConfig.dwMainBufferPriority,
                            this->m_dvSoundDeviceConfig.dwMainBufferFlags,
                            m_dvSoundDeviceConfig.dwFlags );

		// Full duplex init failed, set the half duplex flag
		if( FAILED( hr ) )
        {
        	// Records are deleted here because not needed for half-duplex
        	if( m_audioRecordDevice != NULL )
			{
				delete m_audioRecordDevice;
				m_audioRecordDevice = NULL;
			}
        	if( m_audioRecordBuffer != NULL )
			{
				delete m_audioRecordBuffer;
				m_audioRecordBuffer = NULL;
			}

        	// If we got playbacks from user then let them fall through to half-duplex
        	// If we allocated them in InitFullDuplex - then it cleans up for itself on error
			m_dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_HALFDUPLEX;
        }
        // Full duplex passed
		else
		{
		}

		if( hr == E_OUTOFMEMORY )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Full duplex init received an E_OUTOFMEMORY, failing Initialization()." );			
			return DVERR_OUTOFMEMORY;
		}
		
    }

	

	if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX )
    {
        hr = InitHalfDuplex( m_dvSoundDeviceConfig.hwndAppWindow, 
                             m_dvSoundDeviceConfig.guidPlaybackDevice,
                             &m_audioPlaybackDevice,
                             &m_dsBufferDesc,
                             &m_audioPlaybackBuffer,
                             m_lpdvfCompressionInfo->guidType,
                             this->s_lpwfxPrimaryFormat,
                             this->s_lpwfxPlaybackFormat,
                             this->m_dvSoundDeviceConfig.dwMainBufferPriority,
                             this->m_dvSoundDeviceConfig.dwMainBufferFlags,                             
                             m_dvSoundDeviceConfig.dwFlags );

		if( FAILED( hr ) )
        {
        	// if user supplied these then we need to nuke them here
        	// if user didn't supply, then they were nuked on error in InitHalfDuplex
        	if( m_audioPlaybackDevice != NULL )
			{
				delete m_audioPlaybackDevice;
				m_audioPlaybackDevice = NULL;
			}
        	if( m_audioPlaybackBuffer != NULL )
			{
				delete m_audioPlaybackBuffer;
				m_audioPlaybackBuffer = NULL;
			}
            return hr;
        }
    }

	// Build the frame pool
    DNEnterCriticalSection( &CDirectVoiceEngine::s_csSTLLock );	
	m_pFramePool = new CFramePool( m_dwCompressedFrameSize );
    DNLeaveCriticalSection( &CDirectVoiceEngine::s_csSTLLock );	

    m_lpstBufferList = NULL;

	if( m_pFramePool == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate frame pool" );
		return DVERR_OUTOFMEMORY;
	}

	if (!m_pFramePool->Init())
	{
		delete m_pFramePool;
		return DVERR_OUTOFMEMORY;
	}

	if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_SETCONVERSIONQUALITY )
	{
		if( m_dvSoundDeviceConfig.guidPlaybackDevice != GUID_NULL )
		{
			hr = m_audioPlaybackDevice->GetMixerQuality( &m_dwOriginalPlayQuality );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,   1, "Unable to get current playback quality hr=0x%x", hr );
				m_dwOriginalPlayQuality = DV_CLIENT_SRCQUALITY_INVALID;
			}
			// We're already at the setting, someone else probably runinng, disable restore
			else if( m_dwOriginalPlayQuality == DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED )
			{
				DPFX(DPFPREP,   1, "Quality setting is already at correct value.  Will not set/restore" );
				m_dwOriginalPlayQuality = DV_CLIENT_SRCQUALITY_INVALID;
			}
			else
			{
				hr = m_audioPlaybackDevice->SetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED );
			}
		}
		else
		{
			hr = DVERR_NOTSUPPORTED;
		}

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set mixer quality for playback device hr=0x%x", hr );
		}
	}
	else
	{
		m_dwOriginalPlayQuality = DV_CLIENT_SRCQUALITY_INVALID;
	}

    // Add a reference for the soundconfig struct if one doesn't exist
    if( m_dvSoundDeviceConfig.lpdsPlaybackDevice == NULL )
    {
        m_dvSoundDeviceConfig.lpdsPlaybackDevice = m_audioPlaybackDevice->GetPlaybackDevice();
        m_dvSoundDeviceConfig.lpdsPlaybackDevice->AddRef();
    }

	// If we're not half duplex, do some initial sets for the recording system
	if( !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX) &&
	   m_audioRecordDevice != NULL )
	{
		if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_SETCONVERSIONQUALITY )
		{
			DPFX(DPFPREP,   DVF_INFOLEVEL, "Setting quality" );
			DV_DUMP_GUID( m_dvSoundDeviceConfig.guidCaptureDevice );

            if( m_dvSoundDeviceConfig.lpdsCaptureDevice == NULL )
            {
    			m_dvSoundDeviceConfig.lpdsCaptureDevice = m_audioRecordDevice->GetCaptureDevice();
    			m_dvSoundDeviceConfig.lpdsCaptureDevice->AddRef();
            }

			if( m_dvSoundDeviceConfig.guidCaptureDevice != GUID_NULL )
			{
				DPFX(DPFPREP,   DVF_INFOLEVEL, "Setting quality 2" );

				hr = m_audioRecordDevice->GetMixerQuality( &m_dwOriginalRecordQuality );

				if( FAILED( hr ) )
				{
					DPFX(DPFPREP,   DVF_WARNINGLEVEL, "Unable to get conversion quality hr=0x%x", hr );
					m_dwOriginalRecordQuality = DV_CLIENT_SRCQUALITY_INVALID;
				}
				// We're already at the setting, someone else probably runinng, disable restore
				else if( m_dwOriginalRecordQuality == DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED )
				{
					DPFX(DPFPREP,   1, "Play Quality setting is already at correct value.  Will not set/restore" );
					m_dwOriginalRecordQuality = DV_CLIENT_SRCQUALITY_INVALID;
				}
				else
				{
					hr = m_audioRecordDevice->SetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY_ADVANCED );
				}
			}
			else
			{
				hr = DVERR_NOTSUPPORTED;
			}

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,   DVF_WARNINGLEVEL, "Setting failed" );
				DPFX(DPFPREP,   DVF_WARNINGLEVEL, "Unable to set mixer quality for record device hr=0x%x", hr );
			}		
		}
		else
		{
			m_dwOriginalRecordQuality = DV_CLIENT_SRCQUALITY_INVALID;
		}

		// If we haven't set no focus
		if( !(m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_NOFOCUS ) )
		{
			// Recording is started muted
			if( m_dvClientConfig.dwFlags & DVCLIENTCONFIG_RECORDMUTE )
			{
				DPFX(DPFPREP,   DVF_INFOLEVEL, "Record Muted: Yielding focus" );
				hr = m_audioRecordBuffer->YieldFocus();
			}
			else
			{
				DPFX(DPFPREP,   DVF_INFOLEVEL, "Record Un-Muted: Attempting to reclaim focus" );			
				hr = m_audioRecordBuffer->ClaimFocus();
			}

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,   DVF_WARNINGLEVEL, "Focus set failed hr=0x%x", hr );
			}
		}

        LONG lVolume;
        hr = m_audioRecordBuffer->GetVolume( &lVolume );

        if( FAILED( hr ) )
        {
            Diagnostics_Write( 0, "Unable to retrieve recording volume hr=0x%x", hr );
            Diagnostics_Write(0, "Disabling recording controls" );
            m_dvSoundDeviceConfig.dwFlags |= DVSOUNDCONFIG_NORECVOLAVAILABLE;
        }
	}
	else
	{
	    m_dvSoundDeviceConfig.lpdsCaptureDevice = NULL;
	}

	// Initialize the sound target list
    InitSoundTargetList();

	hr = CreateGeneralBuffer();

	if( FAILED( hr ) )
	{
	    Diagnostics_Write( 0, "Error creating general buffer hr=0x%x", hr );
        return hr;
	}

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "DVCE::InitializeSoundSystem() End" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ShutdownSoundSystem"
// ShutdownSoundSystem
//
// Stop the sound system
//
HRESULT CDirectVoiceClientEngine::ShutdownSoundSystem()
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::ShutdownSoundSystem() Begin" );

	HRESULT hr;

    FreeSoundTargetList();

#ifndef __DISABLE_SOUND
	if( m_audioRecordBuffer != NULL )
	{
		delete m_audioRecordBuffer;
		m_audioRecordBuffer = NULL;
	}

	if( m_dvSoundDeviceConfig.lpdsMainBuffer != NULL )
	{
		m_dvSoundDeviceConfig.lpdsMainBuffer->Release();
		m_dvSoundDeviceConfig.lpdsMainBuffer = NULL;
	}	
	
	if( m_audioRecordDevice != NULL )
	{
		if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_SETCONVERSIONQUALITY )
		{
			if( m_dwOriginalRecordQuality != DV_CLIENT_SRCQUALITY_INVALID )
			{
				hr = m_audioRecordDevice->SetMixerQuality( m_dwOriginalRecordQuality );

				if( FAILED( hr ) )
				{
					DPFX(DPFPREP,  1, "Failed to restore original recording quality hr=0x%x", hr );
				}
			}
			m_dwOriginalRecordQuality = DV_CLIENT_SRCQUALITY_INVALID;
		}

		delete m_audioRecordDevice;

		m_audioRecordDevice = NULL;
	}

	if( m_audioPlaybackBuffer != NULL )
	{
		delete m_audioPlaybackBuffer;
		m_audioPlaybackBuffer = NULL;
	}

	if( m_audioPlaybackDevice != NULL )
	{
		if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_SETCONVERSIONQUALITY )
		{
			if( m_dwOriginalPlayQuality != DV_CLIENT_SRCQUALITY_INVALID )
			{
				hr = m_audioPlaybackDevice->SetMixerQuality( m_dwOriginalPlayQuality );

				if( FAILED( hr ) )
				{
					DPFX(DPFPREP,  1, "Failed to restore original playback quality hr=0x%x", hr );
				}
			}
			m_dwOriginalPlayQuality = DV_CLIENT_SRCQUALITY_INVALID;
		}

		delete m_audioPlaybackDevice;
		m_audioPlaybackDevice = NULL;
	}
#endif

    if( m_dvSoundDeviceConfig.lpdsCaptureDevice != NULL )
    {
        m_dvSoundDeviceConfig.lpdsCaptureDevice->Release();
        m_dvSoundDeviceConfig.lpdsCaptureDevice = NULL;
    }

    if( m_dvSoundDeviceConfig.lpdsPlaybackDevice != NULL )
    {
        m_dvSoundDeviceConfig.lpdsPlaybackDevice->Release();
        m_dvSoundDeviceConfig.lpdsPlaybackDevice = NULL;        
    }  
	
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::ShutdownSoundSystem() End" );

	Diagnostics_End();

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetConnectResult"
// SetConnectResult
//
// This function stores the specified connect result code in m_hrOriginalConnectResult
// and stores the "translated" error code in m_hrConnectResult.  m_hrConnectResult 
// is used to return the result to the user.  
//
// For some error codes the voice layer translates the code to a voice specific error, 
// this is why this function is required.
//
void CDirectVoiceClientEngine::SetConnectResult( HRESULT hrConnectResult )
{
	DPFX( DPFPREP, DVF_CONNECT_PROCEDURE_DEBUG_LEVEL, "CONNECT RESULT: Transition [0x%x] to [0x%x]", m_hrOriginalConnectResult, hrConnectResult  );		
	
	m_hrOriginalConnectResult = hrConnectResult;

	if( HRESULT_FACILITY( hrConnectResult ) == static_cast<HRESULT>(_FACDS) )
	{
		if( hrConnectResult == DSERR_ALLOCATED )
		{
			DPFX( DPFPREP, DVF_WARNINGLEVEL, "WARNING: Mapping DSERR_ALLOCATED --> DVERR_PLAYBACKSYSTEMERROR" );
			m_hrConnectResult = DVERR_PLAYBACKSYSTEMERROR;
		}
		else if( hrConnectResult == DSERR_OUTOFMEMORY )
		{
			DPFX( DPFPREP, DVF_WARNINGLEVEL, "WARNING: Mapping DSERR_OUTOFMEMORY --> DVERR_OUTOFMEMORY" );
			m_hrConnectResult = DVERR_OUTOFMEMORY;			
		}
		else if( hrConnectResult == DSERR_NODRIVER )
		{
			DPFX( DPFPREP, DVF_WARNINGLEVEL, "WARNING: Mapping DSERR_NODRIVER --> DVERR_INVALIDDEVICE" );
			m_hrConnectResult = DVERR_INVALIDDEVICE;
		}
		else 

		{
			DPFX( DPFPREP, DVF_WARNINGLEVEL, "WARNING: Mapping 0x%x --> DVERR_SOUNDINITFAILURE", hrConnectResult );
			m_hrConnectResult = DVERR_SOUNDINITFAILURE;
		}
	}
	else
	{
		m_hrConnectResult = hrConnectResult;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetConnectResult"
// GetConnectResult
//
// This function stores the specified connect result code in m_hrOriginalConnectResult
// and stores the "translated" error code in m_hrConnectResult.  m_hrConnectResult 
// is used to return the result to the user.  
//
// For some error codes the voice layer translates the code to a voice specific error, 
// this is why this function is required.
//
HRESULT CDirectVoiceClientEngine::GetConnectResult(  )
{
	return m_hrConnectResult;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendConnectResult"
HRESULT CDirectVoiceClientEngine::SendConnectResult()
{
	if( m_fConnectAsync )
	{
		DVMSG_CONNECTRESULT dvConnect;
		dvConnect.hrResult = GetConnectResult();
		dvConnect.dwSize = sizeof( DVMSG_CONNECTRESULT );

		return NotifyQueue_Add( DVMSGID_CONNECTRESULT, &dvConnect, sizeof( DVMSG_CONNECTRESULT ) );
	}
	else
	{
		return DV_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendDisconnectResult"
HRESULT CDirectVoiceClientEngine::SendDisconnectResult()
{
	if( m_fDisconnectAsync )
	{
		DVMSG_DISCONNECTRESULT dvDisconnect;
		dvDisconnect.hrResult = m_hrDisconnectResult;
		dvDisconnect.dwSize = sizeof( DVMSG_DISCONNECTRESULT );

		return NotifyQueue_Add( DVMSGID_DISCONNECTRESULT, &dvDisconnect, sizeof( DVMSG_DISCONNECTRESULT ) );
	}
	else
	{
		return DV_OK;
	}
}

// NotifyThread
//
// All-purpose watch/notification thread.
//
// Wakes up to:
// - Check for multicast player timeout
// - Adjust parameters on notification
// - Sends notification messages to users.  
// - Checks for timeouts on connect and disconnect calls
// - Sends level notifications
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyThread"
void CDirectVoiceClientEngine::NotifyThread( void *lpParam )
{
	CDirectVoiceClientEngine *This = (CDirectVoiceClientEngine *) lpParam;

	HANDLE eventArray[5];
	DWORD dwWaitPeriod;
	LONG lWaitResult;
	DWORD dwPowerLevel;
	DWORD dwLastLevelNotify, 
		  dwLastTimeoutCheck,
		  dwCurTime;

	DVMSG_INPUTLEVEL dvInputLevel;		  
	DVMSG_OUTPUTLEVEL dvOutputLevel;

	dvInputLevel.dwSize = sizeof( DVMSG_INPUTLEVEL );
	dvOutputLevel.dwSize = sizeof( DVMSG_OUTPUTLEVEL );

	CNotifyElement *neElement;
	
	HRESULT hr;
		  
	DVID  dvidMessageTarget;

	hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error initializing COM" );
		SetEvent( This->m_hNotifyDone );
		This->HandleThreadError( DVERR_GENERIC );
		return;
	}

	eventArray[0] = This->m_hNotifyTerminate;
	eventArray[1] = This->m_hNotifyChange;
	eventArray[2] = This->m_hNotifyDisconnect;
	eventArray[3] = This->m_hNewNotifyElement;
	eventArray[4] = This->m_hNotifyConnect;

	// Setup last times we checked to right now.
	dwLastLevelNotify = GetTickCount();
	dwLastTimeoutCheck = dwLastLevelNotify;
	
	dwWaitPeriod = DV_CLIENT_NOTIFYWAKEUP_TIMEOUT;	

	while( 1 )
	{
		lWaitResult = WaitForMultipleObjects( 5, eventArray, FALSE, dwWaitPeriod );

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Wakeing up!" );

		// If we were woken up for a reason, handle the reason first
		if( lWaitResult != WAIT_TIMEOUT )
		{
			lWaitResult -= WAIT_OBJECT_0;

			if( lWaitResult == 0 )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "Shutting down" );
				break;
			}
			else if( lWaitResult == 1 )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "Parameter Change" );
			}
			else if( lWaitResult == 2 )
			{
				DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Processing disconnect request" );
				This->DoDisconnect();	
				DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Finished processing disconnect" );
				continue;
			}
			else if( lWaitResult == 3 )
			{
				hr = This->NotifyQueue_IndicateNext();

				if( FAILED( hr ) )
				{
					DPFX(DPFPREP,  DVF_ERRORLEVEL, "NotifyQueue_Get Failed hr=0x%x", hr );
				}
			}
			else if( lWaitResult == 4 )
			{
				if( FAILED( This->GetConnectResult() ) )
				{
					This->Cleanup();					
					This->SendConnectResult();					
					SetEvent( This->m_hConnectAck );
				}
				else
				{
					This->DoConnectResponse();
				}
				continue;
			}
		}

		if( This->m_dwCurrentState == DVCSTATE_IDLE )
		{
			continue;
		}

		// If we're connecting, check for timeout on the connection
		// request.
		if( This->m_dwCurrentState == DVCSTATE_CONNECTING && This->m_dwSynchBegin != 0 )
		{
			dwCurTime = GetTickCount();
			
			if( ( dwCurTime - This->m_dwSynchBegin ) > DV_CLIENT_CONNECT_TIMEOUT )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Connection Timed-Out.  Returning NOVOICESESSION" );
				This->SetConnectResult( DVERR_NOVOICESESSION );
				This->Cleanup();				
				This->SendConnectResult();				
				SetEvent( This->m_hConnectAck );				
				continue;				
			}
			else if( ( dwCurTime - This->m_dwLastConnectSent ) > DV_CLIENT_CONNECT_RETRY_TIMEOUT )
			{
				DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Connect Request Timed-Out" );
				DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Re-sending connection request" );

				hr = This->Send_ConnectRequest();

				if( FAILED( hr ) )
				{
					DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending connection request.  Send error hr=0x%x", hr );
					This->SetConnectResult( DVERR_SENDERROR );
					This->Cleanup();					
					This->SendConnectResult();
					SetEvent( This->m_hConnectAck );
					continue;
				}
				
				This->m_dwLastConnectSent	= dwCurTime;
			}
		}
		// If we're disconnecting, check for timeout on the disconnect
		else if( This->m_dwCurrentState == DVCSTATE_DISCONNECTING )
		{
			dwCurTime = GetTickCount();
			
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Checking timeout on disconnect.  Waited %d so far", dwCurTime - This->m_dwSynchBegin );
			
			if( ( dwCurTime - This->m_dwSynchBegin ) > DV_CLIENT_DISCONNECT_TIMEOUT )
			{
				DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Disconnect Request Timed-Out" );
				This->DoSignalDisconnect( DVERR_TIMEOUT );
				continue;
			}
		}

		// Take care of the periodic checks
		if (This->m_dwCurrentState == DVCSTATE_CONNECTED)
		{
			dwCurTime = GetTickCount();

			// Update pending / other lists
			This->UpdateActiveNotifyPendingList( );
			
			// If we're running a multicast session.. check for timed-out users
			if( This->m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
			{
				if( ( dwCurTime - dwLastTimeoutCheck ) > DV_MULTICAST_USERTIMEOUT_PERIOD )
				{
					This->CheckForUserTimeout(dwCurTime);

					dwLastTimeoutCheck = dwCurTime;			
				}
			}

			// Check to see if it's time to notify about levels
			if( This->m_dvClientConfig.dwNotifyPeriod != 0 && This->m_fLocalPlayerAvailable )
			{
				if( ( dwCurTime - dwLastLevelNotify ) > This->m_dvClientConfig.dwNotifyPeriod )
				{
					dvInputLevel.pvLocalPlayerContext = This->m_pvLocalPlayerContext;	
					dvOutputLevel.pvLocalPlayerContext = This->m_pvLocalPlayerContext;
					
					if( !(This->m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX) )
					{
						dvInputLevel.dwPeakLevel = This->m_bLastPeak;

						if( This->m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_NORECVOLAVAILABLE )
						{
    						dvInputLevel.lRecordVolume = DSBVOLUME_MAX;
						}
						else
						{
    						dvInputLevel.lRecordVolume = This->m_dvClientConfig.lRecordVolume;						    
						}
						
						This->NotifyQueue_Add( DVMSGID_INPUTLEVEL, &dvInputLevel, sizeof( DVMSG_INPUTLEVEL ) );
					}

					dvOutputLevel.dwPeakLevel = This->m_bLastPlaybackPeak;
					dvOutputLevel.lOutputVolume = This->m_dvClientConfig.lPlaybackVolume;
					
					This->NotifyQueue_Add( DVMSGID_OUTPUTLEVEL, &dvOutputLevel, sizeof( DVMSG_OUTPUTLEVEL ) );			
					This->SendPlayerLevels();
			
					dwLastLevelNotify = dwCurTime;
				}
			}
		}
	}

	// Flush out any remaining notifications
	This->NotifyQueue_Flush();

	SetEvent( This->m_hNotifyDone );

	COM_CoUninitialize();

	_endthread();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendPlayerLevels"
//
// SendPlayerLevels
// 
// Send player level notifications, but only if there is a message handler
// and the player level message is active.
//
void CDirectVoiceClientEngine::SendPlayerLevels()
{
    if( CheckShouldSendMessage( DVMSGID_PLAYEROUTPUTLEVEL ) )
    {
		DPFX(DPFPREP,   DVF_INFOLEVEL, "SendPlayerLevels: Got Lock" );

		CVoicePlayer *pCurrentPlayer;
		BILINK *pblSearch;
		DVMSG_PLAYEROUTPUTLEVEL dvPlayerLevel;

		pblSearch = m_blNotifyActivePlayers.next;

		while( pblSearch != &m_blNotifyActivePlayers )
		{
			pCurrentPlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );

			if( pCurrentPlayer == NULL )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Retrieved NULL player from active list" );
				DNASSERT( FALSE );
				return;
			}

			if( pCurrentPlayer->IsReceiving() )
			{
				dvPlayerLevel.dwSize = sizeof( DVMSG_PLAYEROUTPUTLEVEL );
				dvPlayerLevel.dvidSourcePlayerID = pCurrentPlayer->GetPlayerID();
				dvPlayerLevel.dwPeakLevel = pCurrentPlayer->GetLastPeak();
				dvPlayerLevel.pvPlayerContext = pCurrentPlayer->GetContext();
				NotifyQueue_Add( DVMSGID_PLAYEROUTPUTLEVEL, &dvPlayerLevel, sizeof( DVMSG_PLAYEROUTPUTLEVEL ) );				
			}

			pblSearch = pblSearch->next;
		}
	}	

	DPFX(DPFPREP,   DVF_INFOLEVEL, "SendPlayerLevels: Done Enum" );

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CheckForUserTimeout"
//
// CheckForUserTimeout
//
// Run the list of users and check for user timeouts in multicast sessions
//
void CDirectVoiceClientEngine::CheckForUserTimeout( DWORD dwCurTime )
{
	DPFX(DPFPREP,   DVF_INFOLEVEL, "Got Lock" );

	BILINK *pblSearch;
	CVoicePlayer *pCurrentPlayer;
	DVPROTOCOLMSG_PLAYERQUIT msgPlayerQuit;

	pblSearch = m_blNotifyActivePlayers.next;

	msgPlayerQuit.dwType = DVMSGID_DELETEVOICEPLAYER;

	while( pblSearch != &m_blNotifyActivePlayers )
	{	
		pCurrentPlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );

		if( dwCurTime - pCurrentPlayer->GetLastPlayback() > DV_MULTICAST_USERTIMEOUT_PERIOD )
		{
			msgPlayerQuit.dvidID = pCurrentPlayer->GetPlayerID();
			HandleDeleteVoicePlayer( pCurrentPlayer->GetPlayerID(), &msgPlayerQuit, sizeof( DVPROTOCOLMSG_PLAYERQUIT ) );
		}

		pblSearch = pblSearch->next;
	}

	DPFX(DPFPREP,   DVF_INFOLEVEL, "Done Enum" );

	return;
}

// Cleanup any outstanding entries on the playback lists
void CDirectVoiceClientEngine::CleanupPlaybackLists(  )
{
	BILINK *pblSearch;
	CVoicePlayer *pVoicePlayer;

	DNEnterCriticalSection( &m_csPlayAddList );

	m_dwPlayActiveCount = 0;

	pblSearch = m_blPlayActivePlayers.next;

	while( pblSearch != &m_blPlayActivePlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blPlayList );
		pVoicePlayer->RemoveFromPlayList();
		pVoicePlayer->Release();
		pblSearch = m_blPlayActivePlayers.next;
	}

	pblSearch = m_blPlayAddPlayers.next;

	while( pblSearch != &m_blPlayAddPlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blPlayList );
		pVoicePlayer->RemoveFromPlayList();
		pVoicePlayer->Release();
		pblSearch = m_blPlayAddPlayers.next;
	}

	DNLeaveCriticalSection( &m_csPlayAddList );
}

// Cleanup any outstanding entries on the playback lists
void CDirectVoiceClientEngine::CleanupNotifyLists(  )
{
	BILINK *pblSearch;
	CVoicePlayer *pVoicePlayer;

	DNEnterCriticalSection( &m_csNotifyAddList );

	pblSearch = m_blNotifyActivePlayers.next;

	while( pblSearch != &m_blNotifyActivePlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );
		pVoicePlayer->RemoveFromNotifyList();
		pVoicePlayer->Release();
		pblSearch = m_blNotifyActivePlayers.next;
	}

	pblSearch = m_blNotifyAddPlayers.next;

	while( pblSearch != &m_blNotifyAddPlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );
		pVoicePlayer->RemoveFromNotifyList();
		pVoicePlayer->Release();
		pblSearch = m_blNotifyAddPlayers.next;
	}

	DNLeaveCriticalSection( &m_csNotifyAddList );
}

// UpdateActivePendingList
//
// This function looks at the pending list and moves those elements on the pending list to the active list
//
// This function also looks at the active list and removes those players who are disconnected
//
// There are three four lists in the system:
// - Playback Thread
// - Notify Thread
// - Host Migration List
//
void CDirectVoiceClientEngine::UpdateActivePlayPendingList( )
{
	BILINK *pblSearch;
	CVoicePlayer *pVoicePlayer;

	DNEnterCriticalSection( &m_csPlayAddList );

	// Add players who are pending
	pblSearch = m_blPlayAddPlayers.next;

	while( pblSearch != &m_blPlayAddPlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blPlayList );

		pVoicePlayer->RemoveFromPlayList();
		pVoicePlayer->AddToPlayList( &m_blPlayActivePlayers );
		m_dwPlayActiveCount++;

		pblSearch = m_blPlayAddPlayers.next;
	}

	DNLeaveCriticalSection( &m_csPlayAddList );

	// Remove players who have disconnected
	pblSearch = m_blPlayActivePlayers.next;

	while( pblSearch != &m_blPlayActivePlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blPlayList );

		pblSearch = pblSearch->next;

		// If current player has disconnected, remove them from active list
		// and release the reference the list has
		if( pVoicePlayer->IsDisconnected() )
		{
			m_dwPlayActiveCount--;
			pVoicePlayer->RemoveFromPlayList();
			pVoicePlayer->Release();
		}
	}

}

void CDirectVoiceClientEngine::UpdateActiveNotifyPendingList( )
{
	BILINK *pblSearch;
	CVoicePlayer *pVoicePlayer;

	DNEnterCriticalSection( &m_csNotifyAddList );

	// Add players who are pending
	pblSearch = m_blNotifyAddPlayers.next;

	while( pblSearch != &m_blNotifyAddPlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );

		pVoicePlayer->RemoveFromNotifyList();
		pVoicePlayer->AddToNotifyList( &m_blNotifyActivePlayers );

		pblSearch = m_blNotifyAddPlayers.next;
	}

	DNLeaveCriticalSection( &m_csNotifyAddList );

	// Remove players who have disconnected
	pblSearch = m_blNotifyActivePlayers.next;

	while( pblSearch != &m_blNotifyActivePlayers )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );

		pblSearch = pblSearch->next;

		// If current player has disconnected, remove them from active list
		// and release the reference the list has
		if( pVoicePlayer->IsDisconnected() )
		{
			pVoicePlayer->RemoveFromNotifyList();
			pVoicePlayer->Release();
		}
	}

}


HRESULT CDirectVoiceClientEngine::CreateGeneralBuffer( )
{
	HRESULT hr;

    m_lpstGeneralBuffer = new CSoundTarget( DVID_REMAINING, 
												m_audioPlaybackDevice,
												(CAudioPlaybackBuffer *) m_audioPlaybackBuffer, 
												&m_dsBufferDesc,
												m_dvSoundDeviceConfig.dwMainBufferPriority,
												m_dvSoundDeviceConfig.dwMainBufferFlags, 
												m_dwUnCompressedFrameSize );

	if( m_lpstGeneralBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate General Buffer" );
		return DVERR_OUTOFMEMORY;
	}
	
	hr = m_lpstGeneralBuffer->GetInitResult();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to initalize general buffer hr=0x%x", hr );
		return hr;
	}
	
	if( m_lpstGeneralBuffer->Get3DBuffer() != NULL )
	{
		// Turn off 3D by default on the general buffer
		m_lpstGeneralBuffer->Get3DBuffer()->SetMode( DS3DMODE_DISABLE, DS3D_IMMEDIATE  );
	}

	// Set General Buffer Volume
	if( m_lpstGeneralBuffer->GetBuffer() != NULL )
	{
		m_lpstGeneralBuffer->GetBuffer()->SetVolume( m_dvClientConfig.lPlaybackVolume );
	}

	hr = m_lpstGeneralBuffer->StartMix();

	if( FAILED( hr ) )
	{
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to start the mix hr=0x%x.", hr );
    	return hr;
	}

	return hr;
}

// New Playback Thread
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::PlaybackThread"
void CDirectVoiceClientEngine::PlaybackThread( void *lParam )
{

	DWORD				dwCurPlayer;
	BOOL				bContinueEnum;
	DVPROTOCOLMSG_PLAYERQUIT	dvPlayerQuit;
	DWORD				dwResultSize;
	LPBYTE				lpSourceBuffer = NULL;
	HANDLE				hEventArray[2] = { NULL, NULL };
	LONG				lWaitResult;
	Timer				*lpTimer = NULL;
    BOOL                fMixed;
    CSoundTarget        *lpstCurrent = NULL;
    BYTE				bHighPeak;
    HRESULT 			hr;
    DWORD				dwEchoState;
    DWORD				dwTmp;
    BYTE				bTmpPeak1, bTmpPeak2;
    DVMSG_PLAYERVOICESTART dvMsgPlayerVoiceStart;
    DVMSG_PLAYERVOICESTOP  dvMsgPlayerVoiceStop;
    DWORD				dwCompressStart;
    DWORD				dwCompressTime;
	CVoicePlayer		*pCurrentPlayer;
	BILINK				*pblSearch;
	BOOL				fSilence, fLost;
	DWORD				dwCurrentTime;
	DWORD				dwSeqNum, dwMsgNum;
	CFrame				*frTmpFrame;
	DWORD				dwCurrentLead = 0;
	DWORD				dwAllowedLeadBuffers = 0;
	DWORD				dwAllowedLeadBytes = 0;
	DWORD				dwHalfBufferSize = 0;
	BOOL				fDesktopCurrent = TRUE;

    dvMsgPlayerVoiceStart.dwSize = sizeof( DVMSG_PLAYERVOICESTART );
    dvMsgPlayerVoiceStop.dwSize = sizeof( DVMSG_PLAYERVOICESTOP );

	CDirectVoiceClientEngine *This = (CDirectVoiceClientEngine *) lParam;

	// Pre-calc some sizes..
	dwAllowedLeadBuffers = DV_CLIENT_BASE_LEAD_MAX;
	dwAllowedLeadBytes = This->m_dwUnCompressedFrameSize * DV_CLIENT_BASE_LEAD_MAX;
	dwHalfBufferSize = This->m_dwUnCompressedFrameSize * (This->m_dwNumPerBuffer/2);

	hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error initializing COM on playback thread" );
		This->HandleThreadError( DVERR_GENERIC );
		goto EXIT_PLAYBACK;
	}

	lpSourceBuffer = new BYTE[This->m_dwUnCompressedFrameSize];

	if( lpSourceBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate source buffer" );
		This->HandleThreadError( DVERR_OUTOFMEMORY );
		goto EXIT_PLAYBACK;
	}

	hEventArray[0] = This->m_hPlaybackTerminate;
	hEventArray[1] = This->m_thTimerInfo.hPlaybackTimerEvent;

	if( hEventArray[0] == NULL || hEventArray[1] == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initialize events" );
		This->HandleThreadError( DVERR_GENERIC );
		goto EXIT_PLAYBACK;
	}

	if( This->m_audioPlaybackDevice->IsEmulated() )
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "WARNING: DirectSound is in emulated mode" );		
		dwAllowedLeadBuffers += DV_CLIENT_EMULATED_LEAD_ADJUST;
		dwAllowedLeadBytes += DV_CLIENT_EMULATED_LEAD_ADJUST * This->m_dwUnCompressedFrameSize;
	}
	else
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "NOTE: DirectSound is in standard mode" );				
	}

    while( 1 )
    {
		lWaitResult = WaitForMultipleObjects( 2, hEventArray, FALSE, INFINITE );

		if( lWaitResult == WAIT_OBJECT_0 )
		{
			break;
		}

		hr = This->m_lpstGeneralBuffer->GetCurrentLead( &dwCurrentLead );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get current position of main buff hr=0x%x", hr );
			This->HandleThreadError( hr );
			goto EXIT_PLAYBACK;		
		}
		

		while( 1 )
		{
			if( dwCurrentLead < (dwAllowedLeadBytes) )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "PWI, Lead: %d Running a pass..", dwCurrentLead );
			}
			else  if( dwCurrentLead > dwHalfBufferSize )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "PWI, Lead: %d Running a pass (wraparound)..", dwCurrentLead );
			}
			else
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "PWI, Lead: %d NOT Running a pass..", dwCurrentLead );
				break;
			}

			DNEnterCriticalSection( &This->m_thTimerInfo.csPlayCount );

			// Only run a max of two times per iteration
			if( This->m_thTimerInfo.lPlaybackCount > dwAllowedLeadBuffers )
				This->m_thTimerInfo.lPlaybackCount = dwAllowedLeadBuffers;
			else 
				This->m_thTimerInfo.lPlaybackCount--;

			DNLeaveCriticalSection( &This->m_thTimerInfo.csPlayCount );

#ifdef WINNT
			fDesktopCurrent = ( USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId);
#endif

			bHighPeak = 0;

			// Update list 
			This->UpdateActivePlayPendingList(  );

			if( This->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION )
			{
				DNEnterCriticalSection( &This->m_lockPlaybackMode );
			
				dwEchoState = This->m_dwEchoState;

				DNLeaveCriticalSection( &This->m_lockPlaybackMode );
			}
			else
			{
				dwEchoState = DVCECHOSTATE_IDLE;
			}

			if( dwEchoState != DVCECHOSTATE_RECORDING  )
			{
				dwCurrentTime = GetTickCount();

				pblSearch = This->m_blPlayActivePlayers.next;

				while( pblSearch != &This->m_blPlayActivePlayers )
				{
					pCurrentPlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blPlayList );

					pblSearch = pblSearch->next;

					dwResultSize = This->m_dwUnCompressedFrameSize;

					dwCompressStart = GetTickCount();

					if( !pCurrentPlayer->IsInBoundConverterInitialized() )
					{
						hr = pCurrentPlayer->CreateInBoundConverter( This->m_lpdvfCompressionInfo->guidType, s_lpwfxPlaybackFormat );

						if( FAILED( hr ) )
						{
							DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get create converter for player hr=0x%x", hr );
							This->HandleThreadError( DVERR_GENERIC );
							goto EXIT_PLAYBACK;
						}
					}

					if( This->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_PLAYBACKMUTE ||
						!fDesktopCurrent )
					{
						frTmpFrame = pCurrentPlayer->Dequeue(&fLost, &fSilence);
						frTmpFrame->Return();
						continue;
					}

					hr = pCurrentPlayer->GetNextFrameAndDecompress( lpSourceBuffer, &dwResultSize, &fLost, &fSilence, &dwSeqNum, &dwMsgNum );

					if( FAILED( hr ) )
					{
						DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get frame from player hr=0x%x", hr );
						This->HandleThreadError( DVERR_GENERIC );
						goto EXIT_PLAYBACK;
					}

					dwCompressTime = GetTickCount() - dwCompressStart;

					// STATSBLOCK: Begin
					This->m_pStatsBlob->m_dwPDTTotal += dwCompressTime;

					if( dwCompressTime < This->m_pStatsBlob->m_dwPDTMin )
					{
						This->m_pStatsBlob->m_dwPDTMin = dwCompressTime;  	
					}

					if( dwCompressTime > This->m_pStatsBlob->m_dwPDTMax )
					{
						This->m_pStatsBlob->m_dwPDTMax = dwCompressTime;
					}							

					// STATSBLOCK: End
					
					// STATSBLOCK: Begin
					if( fLost )
					{
						DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Dequeue: Lost Frame" );	
						DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: Dequeue: Packet was lost.  Speech gap will occur." );
						This->m_pStatsBlob->m_dwPPDQLost++;
					}
					else if( fSilence )
					{
						DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Dequeue: Silent Frame" );	
						This->m_pStatsBlob->m_dwPPDQSilent++;
					}
					else
					{
						DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Dequeue: Msg [%d] Seq [%d]", dwMsgNum, dwSeqNum );
						This->m_pStatsBlob->m_dwPPDQSpeech++;
					}
					// STATSBLOCK: End

					// If the player sent us silence, increment the silent count
					if( fSilence )
					{
						// If we're receiving on this user
						if( pCurrentPlayer->IsReceiving() )
						{
							// If it exceeds the max.
							if( (dwCurrentTime - pCurrentPlayer->GetLastPlayback()) > PLAYBACK_RECEIVESTOP_TIMEOUT )
							{
								pCurrentPlayer->SetReceiving(FALSE);

								dvMsgPlayerVoiceStop.dwSize = sizeof( dvMsgPlayerVoiceStop );
								dvMsgPlayerVoiceStop.dvidSourcePlayerID = pCurrentPlayer->GetPlayerID();
								dvMsgPlayerVoiceStop.pvPlayerContext = pCurrentPlayer->GetContext();
								This->NotifyQueue_Add( DVMSGID_PLAYERVOICESTOP, &dvMsgPlayerVoiceStop, sizeof( dvMsgPlayerVoiceStop ) );		
								This->m_dwActiveCount--;

								if( This->m_dwActiveCount == 0 )
								{
									if( This->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION )
									{
										DNEnterCriticalSection( &This->m_lockPlaybackMode );

										if( This->m_dwEchoState == DVCECHOSTATE_PLAYBACK )
										{
											DPFX(DPFPREP,  PLAYBACK_SWITCH_DEBUG_LEVEL, "%%%% Switching to idle mode" ); 
											This->m_dwEchoState = DVCECHOSTATE_IDLE;
										}

										DNLeaveCriticalSection( &This->m_lockPlaybackMode );								
									}
								}
							}
						}
					}
					else
					{
						// We receive data and this is the first one
						if( !pCurrentPlayer->IsReceiving() )
						{
							dvMsgPlayerVoiceStart.dvidSourcePlayerID = pCurrentPlayer->GetPlayerID();
							dvMsgPlayerVoiceStart.pvPlayerContext = pCurrentPlayer->GetContext();
							This->NotifyQueue_Add( DVMSGID_PLAYERVOICESTART, &dvMsgPlayerVoiceStart, sizeof(DVMSG_PLAYERVOICESTART) );
							This->m_dwActiveCount++;						
							
							if( This->m_dwActiveCount == 1 )
							{
								if( This->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION )
								{
									DNEnterCriticalSection( &This->m_lockPlaybackMode );
									
									if( This->m_dwEchoState == DVCECHOSTATE_IDLE )
									{
										DPFX(DPFPREP,  PLAYBACK_SWITCH_DEBUG_LEVEL, "%%%% Switching to playback mode" ); 
										This->m_dwEchoState = DVCECHOSTATE_PLAYBACK;
									}

									DNLeaveCriticalSection( &This->m_lockPlaybackMode );								
								}
							}							
							pCurrentPlayer->SetReceiving(TRUE);
						}
					}

			        fMixed = FALSE;

					// If the frame was not silence, decompress it and then 
					// mix it into the mixer buffer
					if( !fSilence &&
						fDesktopCurrent && 						
						!(This->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_PLAYBACKMUTE) 
						)
					{
						DPFX(DPFPREP,   DVF_INFOLEVEL, "Player: 0x%x getting frame.. it's speech", pCurrentPlayer->GetPlayerID() );

			            // Lock the buffer list
						DNEnterCriticalSection( &This->m_csBufferLock );

			            lpstCurrent = This->m_lpstBufferList;

            			if( pCurrentPlayer->GetLastPeak() > bHighPeak )
						{
							bHighPeak = pCurrentPlayer->GetLastPeak();
						}                

			            // Loop through list looking for buffers to mix into
			            while( lpstCurrent != NULL )
			            {
			                if( lpstCurrent->GetTarget() == pCurrentPlayer->GetPlayerID() )
			                {
			                    lpstCurrent->MixInSingle( lpSourceBuffer );
			                    fMixed = TRUE;
			                }
			                else if( This->m_lpSessionTransport->IsPlayerInGroup( lpstCurrent->GetTarget(), pCurrentPlayer->GetPlayerID() ) )
			                {
			                    lpstCurrent->MixIn( lpSourceBuffer );
			                    fMixed = TRUE;
			                }

			                lpstCurrent = lpstCurrent->m_lpstNext;
			            }

				        DNLeaveCriticalSection( &This->m_csBufferLock );

			            if( !(This->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MUTEGLOBAL) )
			            {
				            // If we didn't mix into any user created buffers, then
				            // Mix into the main buffer
				            if( !fMixed )
				            {
								if( This->m_dwPlayActiveCount == 1 )
								{
									hr = This->m_lpstGeneralBuffer->MixInSingle( lpSourceBuffer );	
								}
								else
								{ 
									hr = This->m_lpstGeneralBuffer->MixIn( lpSourceBuffer );						
								}

								if( FAILED( hr ) )
								{
									DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to do mix." );

							        DNLeaveCriticalSection( &This->m_csBufferLock );																
								
									This->HandleThreadError( hr );
		
									goto EXIT_PLAYBACK;						    
								}
				            }
				        }

					}
					else
					{
						DPFX(DPFPREP,   DVF_INFOLEVEL, "Player: 0x%x getting frame.. it's silence", pCurrentPlayer->GetPlayerID() );
					}
					
				} // for each player

			} // not in the recording state and at least one talking
			else
			{
				bHighPeak = 0;
			}

	        // Lock the buffer list
			DNEnterCriticalSection( &This->m_csBufferLock );

	        lpstCurrent = This->m_lpstBufferList;
#if defined(DEBUG) || defined(DBG)
			This->CHECKLISTINTEGRITY();
#endif

	        // Loop through list looking for buffers to mix into
	        while( lpstCurrent != NULL )
	        {
#if defined(DEBUG) || defined(DBG)
				This->CHECKLISTINTEGRITY();
#endif

	            hr = lpstCurrent->Commit();

				if( FAILED( hr ) )
				{
					DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error commiting to buffer hr=0x%x -- Locked by user?", hr );
					DNLeaveCriticalSection( &This->m_csBufferLock );	

					if( hr == DSERR_NODRIVER )
					{
						hr = DVERR_INVALIDDEVICE;
					}
					else
					{
						hr = DVERR_LOCKEDBUFFER;
					}

					This->HandleThreadError( hr );
					goto EXIT_PLAYBACK;
				}

	            lpstCurrent = lpstCurrent->m_lpstNext;
	        }

	        This->m_bLastPlaybackPeak = bHighPeak;

			hr = This->m_lpstGeneralBuffer->Commit();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error commiting to buffer hr=0x%x -- Locked by user?", hr );
				DNLeaveCriticalSection( &This->m_csBufferLock );		

				if( hr == DSERR_NODRIVER )
				{
					hr = DVERR_INVALIDDEVICE;
				}
				else
				{
					hr = DVERR_LOCKEDBUFFER;
				}
				
				This->HandleThreadError( hr );
				goto EXIT_PLAYBACK;
			}

			DNLeaveCriticalSection( &This->m_csBufferLock );

			hr = This->m_lpstGeneralBuffer->GetCurrentLead( &dwCurrentLead );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get current pos of main buffer hr=0x%x", hr );
				This->HandleThreadError( hr );
				goto EXIT_PLAYBACK;
			}
		}
    }

EXIT_PLAYBACK:

	if( lpTimer != NULL )
	{
	    delete lpTimer;
	}

    DPFX(DPFPREP,   DVF_INFOLEVEL, "PT: Exiting" );

	// Stop the playback
	//This->m_audioPlaybackBuffer->Stop();
	
	// Deallocate the buffers
    DPFX(DPFPREP,   DVF_INFOLEVEL, "PT: mixer gone" );

    if( lpSourceBuffer != NULL )
    {
	    delete [] lpSourceBuffer;
	}
	
    DPFX(DPFPREP,   DVF_INFOLEVEL, "PT: source gone" );

	// Signal that thread is done.
	SetEvent( This->m_hPlaybackDone );

    DPFX(DPFPREP,   DVF_INFOLEVEL, "PT: Shutdown complete" );

    COM_CoUninitialize();

	_endthread();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetPlaybackVolume"
//
// SetPlaybackVolume
//
// Sets the playback volume of all the playback buffers
//
HRESULT CDirectVoiceClientEngine::SetPlaybackVolume( LONG lVolume )
{
	CSoundTarget *lpstCurrent;
	CAudioPlaybackBuffer *lpdsBuffer;
	
    m_audioPlaybackBuffer->SetVolume( lVolume );

    // Lock the buffer list
    DNEnterCriticalSection( &m_csBufferLock );    

    lpstCurrent = m_lpstBufferList;

    // Loop through list of buffers setting the volume
    while( lpstCurrent != NULL )
    {
        lpdsBuffer = lpstCurrent->GetBuffer();

        if( lpdsBuffer != NULL )
        {
        	lpdsBuffer->SetVolume( lVolume );
        }

        lpstCurrent = lpstCurrent->m_lpstNext;
    }

    // Lock the buffer list
    DNLeaveCriticalSection( &m_csBufferLock );    

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::HandleThreadError"
//
// HandleThreadError
//
// Handles errors within threads.  When an error occurs this function sets the 
// session lost flag and notifies the notifythread to perform a disconnect.
//
void CDirectVoiceClientEngine::HandleThreadError( HRESULT hrResult )
{
	DoSessionLost( hrResult );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::RecordThread"
// RecordThread
//
// Thread to handle compression / transmission
//
void CDirectVoiceClientEngine::RecordThread( void *lpParam ) 
{
	CDirectVoiceClientEngine *This = (CDirectVoiceClientEngine *) lpParam;

	DNASSERT( This != NULL );

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::RecordThread() Begin" );

	HANDLE hEventArray[2];
	LONG lWaitResult;
	HRESULT hr;
	BOOL fContinue = FALSE;
	DWORD dwNumRunsPerWakeup = 0;
	CClientRecordSubSystem *subSystem = NULL;

	hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error innitializing COM on record thread" );
		goto EXIT_ERROR;
	} 

    subSystem = new CClientRecordSubSystem( This );

    // Check that the converter is valid
    if( subSystem == NULL  )
    {
        DPFX(DPFPREP,   DVF_ERRORLEVEL, "Memory alloc failure" );
        goto EXIT_ERROR;
    }

    hr = subSystem->Initialize();

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Record Sub Error during init hr=0x%x", hr );
    	goto EXIT_ERROR;
    }

	hEventArray[0] = This->m_hRecordTerminate;
	hEventArray[1] = This->m_thTimerInfo.hRecordTimerEvent;

    // Loop while we're connected
    while( 1 )
    {	
		lWaitResult = WaitForMultipleObjects( 2, hEventArray, FALSE, INFINITE );

		This->m_pStatsBlob->m_recStats.m_dwNumWakeups++;

		if( lWaitResult == WAIT_OBJECT_0 )
		{
			break;
		}

		fContinue = TRUE;

		dwNumRunsPerWakeup	= 0;

		while( fContinue )
		{
	        // Wait for next frame, if this fails recording
	        // system is locked.  Return
			hr = subSystem->GetNextFrame( &fContinue );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to retrieve next frame hr = 0x%x", hr );
				goto EXIT_ERROR;
			}

			if( !fContinue )
			{
				ResetEvent( This->m_thTimerInfo.hRecordTimerEvent );
				break;
			}
				
			This->m_pStatsBlob->m_recStats.m_dwRPWTotal++;
			dwNumRunsPerWakeup++;				

			DPFX(DPFPREP,   DVF_INFOLEVEL, "> RTAR: Got" );

			hr = subSystem->RecordFSM();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to update FSM hr=0x%x", hr );
				goto EXIT_ERROR;
			}

			DPFX(DPFPREP,   DVF_INFOLEVEL, "> RTAR: FSM" );
	      
	        // Transmit the frame if need be.  
	        hr = subSystem->TransmitFrame();

	        if( FAILED( hr ) )
	        {
	        	DPFX(DPFPREP,  DVF_ERRORLEVEL, "TransmitFrame Failed hr=0x%x", hr );
	        	goto EXIT_ERROR;
	        }

			DPFX(DPFPREP,   DVF_INFOLEVEL, "> RTAR: Trans" );
		}

		if( dwNumRunsPerWakeup < This->m_pStatsBlob->m_recStats.m_dwRPWMin )
		{
			This->m_pStatsBlob->m_recStats.m_dwRPWMin = dwNumRunsPerWakeup;
		}

		if( dwNumRunsPerWakeup > This->m_pStatsBlob->m_recStats.m_dwRPWMax )
		{
			This->m_pStatsBlob->m_recStats.m_dwRPWMax = dwNumRunsPerWakeup;
		}
		
    }

    // Delete the recording subsystem
    delete subSystem;

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Record Sub Gone" );

	COM_CoUninitialize();

    SetEvent( This->m_hRecordDone );

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Record Gone" );

	return;

EXIT_ERROR:

	if( subSystem )
		delete subSystem;

	This->HandleThreadError( DVERR_RECORDSYSTEMERROR );

	COM_CoUninitialize();

	SetEvent( This->m_hRecordDone );

	_endthread();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::MigrateHost"
// MigrateHost
// 
// This function is called by DV_HostMigrate when the local client has received a host
// migration notification.  
//
//
HRESULT CDirectVoiceClientEngine::MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer )
{
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Flush"
//
// NotifyQueue_Flush
//
// This function does not return until all notifications have been indicated
//
void CDirectVoiceClientEngine::NotifyQueue_Flush()
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();
	
	while( m_lpNotifyList )
	{
		NotifyQueue_IndicateNext();	
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_IndicateNext"
HRESULT CDirectVoiceClientEngine::NotifyQueue_IndicateNext()
{
	HRESULT hr;	
	CNotifyElement *neElement;
	
	hr = NotifyQueue_Get( &neElement );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "NotifyQueue_Get Failed hr=0x%x", hr );
	}
	else
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Sending notification type=0x%x", neElement->m_dwType );

		if( neElement->m_etElementType == NOTIFY_FIXED )
		{
			TransmitMessage( neElement->m_dwType, 
								   &neElement->m_element.fixed, 
								   neElement->m_dwDataSize );					
		}
		else
		{
			TransmitMessage( neElement->m_dwType, 
								   neElement->m_element.dynamic.m_lpData, 
								   neElement->m_dwDataSize );
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Returning notification" );

		NotifyQueue_ElementFree( neElement );
	}

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Add"
// Queue up a notification for the user
HRESULT CDirectVoiceClientEngine::NotifyQueue_Add( DWORD dwMessageType, LPVOID lpData, DWORD dwDataSize, PVOID pvContext, CNotifyElement::PNOTIFY_COMPLETE pNotifyFunc )
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();

    if( !m_fNotifyQueueEnabled )
    {
    	DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Ignoring indication, queue disabled" );
    }

	CNotifyElement *lpNewElement;

	HRESULT hr;

	lpNewElement = (CNotifyElement *) m_pfpNotifications->Get( m_pfpNotifications );

	if( lpNewElement == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to get a block for a notifier" );
		return DVERR_OUTOFMEMORY;
	}

	// Setup the notification callbacks, if there are ones
	lpNewElement->pvContext = pvContext; 
	lpNewElement->pNotifyFunc = pNotifyFunc;

	if( dwMessageType == DVMSGID_PLAYERVOICESTOP )
	{
	    PDVMSG_PLAYERVOICESTOP pMsgStop = (PDVMSG_PLAYERVOICESTOP) lpData;

	    DNASSERT( pMsgStop->dwSize == sizeof( DVMSG_PLAYERVOICESTOP ) );
	    DNASSERT( dwDataSize == sizeof( DVMSG_PLAYERVOICESTOP ) );	    
	}

	if( dwMessageType == DVMSGID_PLAYERVOICESTART )
	{
	    PDVMSG_PLAYERVOICESTART pMsgStart = (PDVMSG_PLAYERVOICESTART) lpData;

	    DNASSERT( pMsgStart->dwSize == sizeof( DVMSG_PLAYERVOICESTART ) );
	    DNASSERT( dwDataSize == sizeof( DVMSG_PLAYERVOICESTART ) );	    
	}

	if( dwMessageType == DVMSGID_PLAYEROUTPUTLEVEL )
	{
	    PDVMSG_PLAYEROUTPUTLEVEL pMsgOutput = (PDVMSG_PLAYEROUTPUTLEVEL) lpData;

	    DNASSERT( pMsgOutput->dwSize == sizeof( DVMSG_PLAYEROUTPUTLEVEL ) );
	    DNASSERT( dwDataSize == sizeof( DVMSG_PLAYEROUTPUTLEVEL ) );	    
	}

	lpNewElement->m_lpNext = m_lpNotifyList;
	lpNewElement->m_dwType = dwMessageType;
	lpNewElement->m_dwDataSize = dwDataSize;

	if( dwDataSize <= DV_CLIENT_NOTIFY_ELEMENT_SIZE )
	{
		lpNewElement->m_etElementType = NOTIFY_FIXED;
	}
	else
	{
		lpNewElement->m_etElementType = NOTIFY_DYNAMIC;
	}

	if( lpNewElement->m_etElementType == NOTIFY_FIXED )
	{
		memcpy( &lpNewElement->m_element.fixed, lpData, dwDataSize );	
	}
	else if( lpNewElement->m_etElementType == NOTIFY_DYNAMIC )
	{
		lpNewElement->m_element.dynamic.m_lpData = new BYTE[dwDataSize];

		if( lpNewElement->m_element.dynamic.m_lpData == NULL )
		{
			m_pfpNotifications->Release( m_pfpNotifications, lpNewElement );

			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to alloc memory for notification" );

			return DVERR_OUTOFMEMORY;
		}

		memcpy( lpNewElement->m_element.dynamic.m_lpData, lpData, dwDataSize );
	}
	else
	{
		DNASSERT( FALSE );
	}

	// Fixups for internal pointers 
	//
	// Required for certain message types (currently only DVMSGID_SETTARGETS)
	if( dwMessageType == DVMSGID_SETTARGETS )
	{
		PDVMSG_SETTARGETS pdvSetTarget;

		if( lpNewElement->m_etElementType == NOTIFY_FIXED )
		{
			pdvSetTarget = (PDVMSG_SETTARGETS) &lpNewElement->m_element.fixed;
		}
		else
		{
			pdvSetTarget = (PDVMSG_SETTARGETS) lpNewElement->m_element.dynamic.m_lpData;
		}

		pdvSetTarget->pdvidTargets = (PDVID) &pdvSetTarget[1];
		lpNewElement->m_dwDataSize = sizeof( DVMSG_SETTARGETS );
	}

	// We're ignoring this notification, call the completion immediately.
	if( !m_fNotifyQueueEnabled )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Ignoring notification, calling completion immediately" );
		NotifyQueue_ElementFree( lpNewElement );
		return DV_OK;
	}

	m_lpNotifyList = lpNewElement;

    ReleaseSemaphore( m_hNewNotifyElement, 1, NULL );	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Get"
// Retrieve the next element in our queue.  
//
// If there is an element, return DV_OK, otherwise DVERR_GENERIC.
//
HRESULT CDirectVoiceClientEngine::NotifyQueue_Get( CNotifyElement **pneElement )
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();

    CNotifyElement *lpIterator = m_lpNotifyList;
    CNotifyElement *lpTrailIterator = NULL;

    if( lpIterator == NULL )
    	return DVERR_GENERIC;    

	// Move forward to the last element in the list
	while( lpIterator->m_lpNext != NULL )
	{
		lpTrailIterator = lpIterator;
		lpIterator = lpIterator->m_lpNext;
	}

	*pneElement = lpIterator;

	// Remove the last element in the list
	
	// Special case, only element on the list
	if( lpTrailIterator == NULL )
	{
		m_lpNotifyList = NULL;
	}
	else
	{
		lpTrailIterator->m_lpNext = NULL;		
	}

	return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Init"
HRESULT CDirectVoiceClientEngine::NotifyQueue_Init()
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();

    m_pfpNotifications = FPM_Create( sizeof( CNotifyElement ), NULL, NULL, NULL, NULL, NULL, NULL );
    
    if (m_pfpNotifications==NULL)
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create fixed pool for notify elements" );
        return DVERR_OUTOFMEMORY;
    }
    
    m_lpNotifyList = NULL;
    m_hNewNotifyElement = CreateSemaphore( NULL, 0, DVCLIENT_NOTIFY_MAXSEMCOUNT, NULL );

    if (m_hNewNotifyElement==NULL)
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create semaphore for notify elements" );
        return DVERR_GENERIC;
    }
	
    m_fNotifyQueueEnabled = TRUE;

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Enable"
void CDirectVoiceClientEngine::NotifyQueue_Enable()
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();	

    m_fNotifyQueueEnabled = TRUE;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Disable"
void CDirectVoiceClientEngine::NotifyQueue_Disable()
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();	
    
    m_fNotifyQueueEnabled = FALSE;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_ElementFree"
HRESULT CDirectVoiceClientEngine::NotifyQueue_ElementFree( CNotifyElement *lpElement )
{
	// Call the notification function, if there is one
	if( lpElement->pNotifyFunc )
	{
		(*lpElement->pNotifyFunc)(lpElement->pvContext,lpElement);
		lpElement->pNotifyFunc = NULL;
		lpElement->pvContext = NULL;
	}
		
	// If this element is dynamic free the associated memory
	if( lpElement->m_etElementType == NOTIFY_DYNAMIC )
	{
		delete [] lpElement->m_element.dynamic.m_lpData;
	}
	
	// Return notifier to the fixed pool manager
	m_pfpNotifications->Release( m_pfpNotifications, lpElement );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::NotifyQueue_Free"
HRESULT CDirectVoiceClientEngine::NotifyQueue_Free()
{
    BFCSingleLock slLock( &m_csNotifyQueueLock );
    slLock.Lock();

    CNotifyElement *lpTmpElement;
    CNotifyElement *lpIteratorElement;

    lpIteratorElement = m_lpNotifyList;

    while( lpIteratorElement != NULL )
    {
    	lpTmpElement = lpIteratorElement;
    	lpIteratorElement = lpIteratorElement->m_lpNext;

		NotifyQueue_ElementFree( lpTmpElement );
    }

	if( m_hNewNotifyElement != NULL )
	{
	    CloseHandle( m_hNewNotifyElement );
	}

	if( m_pfpNotifications != NULL )
	{
		m_pfpNotifications->Fini(m_pfpNotifications);
		m_pfpNotifications = NULL;
	}

    return DV_OK;
}

//
// HANDLERS FOR WHEN WE HANDLE REMOTE SERVERS
//
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CreateGroup"
HRESULT CDirectVoiceClientEngine::CreateGroup( DVID dvID )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DeleteGroup"
HRESULT CDirectVoiceClientEngine::DeleteGroup( DVID dvID )
{
	CheckForAndRemoveTarget( dvID );

	// If there are any buffers for this player, delete them
	//
	// Leave the buffer around so the user can call Delete3DSoundBuffer
	//
    // DeleteSoundTarget( dvID );

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::AddPlayerToGroup"
HRESULT CDirectVoiceClientEngine::AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::RemovePlayerFromGroup"
HRESULT CDirectVoiceClientEngine::RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoSessionLost"
void CDirectVoiceClientEngine::DoSessionLost( HRESULT hrDisconnectResult )
{
	if( GetCurrentState() == DVCSTATE_CONNECTED )
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "#### SESSION LOST [hr=0x%x]", hrDisconnectResult );
		m_fSessionLost = TRUE;
		DoSignalDisconnect( hrDisconnectResult );
	}
	else if( GetCurrentState() == DVCSTATE_DISCONNECTING )
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "#### Received session lost during disconnect, completing disconnect" );
		DoSignalDisconnect( m_hrDisconnectResult );		
	}
	else
	{
		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "#### Received session lost but not connected or disconnecting, ignoring" );		
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::DoSignalDisconnect"
void CDirectVoiceClientEngine::DoSignalDisconnect( HRESULT hrDisconnectResult )
{
	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "#### Disconnecting [hr=0x%x]", hrDisconnectResult );
	m_hrDisconnectResult = hrDisconnectResult;
	SetEvent( m_hNotifyDisconnect );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Reset"
void  CDirectVoiceClientEngine::ClientStats_Reset()
{
	memset( &m_stats, 0x00, sizeof( ClientStatistics ) );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Dump_Record"
void CDirectVoiceClientEngine::ClientStats_Dump_Record()
{
	if( m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_HALFDUPLEX )
	{
		DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Session was half duplex, no record stats available" );
		return;
	}

	char tmpBuffer[200];

	DWORD dwRecRunLength = m_pStatsBlob->m_recStats.m_dwTimeStop - m_pStatsBlob->m_recStats.m_dwTimeStart;

	if( dwRecRunLength == 0 )
		dwRecRunLength = 1;

	DWORD dwNumInternalRuns = m_pStatsBlob->m_recStats.m_dwNumWakeups;

	if( dwNumInternalRuns == 0 )
		dwNumInternalRuns = 1;

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Start Lag (ms)         : %u", m_pStatsBlob->m_recStats.m_dwStartLag );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Record Run Length (ms) : %u", dwRecRunLength );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Speech Size (Uncomp.)  : %u", m_pStatsBlob->m_recStats.m_dwUnCompressedSize );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Frames / Buffer        : %u", m_pStatsBlob->m_recStats.m_dwFramesPerBuffer );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Time / Frame (ms)      : %u", m_pStatsBlob->m_recStats.m_dwFrameTime );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Silence Timeout        : %u", m_pStatsBlob->m_recStats.m_dwSilenceTimeout );
	
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "# of wakeups           : %u", m_pStatsBlob->m_recStats.m_dwNumWakeups );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Runs / Wakeup          : Avg: %u [%u..%u]", 
			m_pStatsBlob->m_recStats.m_dwRPWTotal / dwNumInternalRuns,
			m_pStatsBlob->m_recStats.m_dwRPWMin, 
			m_pStatsBlob->m_recStats.m_dwRPWMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "# of messages          : %u", m_pStatsBlob->m_recStats.m_dwNumMessages );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Sent Frames            : %u", m_pStatsBlob->m_recStats.m_dwSentFrames );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Ignored Frames         : %u", m_pStatsBlob->m_recStats.m_dwIgnoredFrames );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Message Length (frames): Avg: %u [%u..%u]", 
			(m_pStatsBlob->m_recStats.m_dwNumMessages == 0) ? 0 : m_pStatsBlob->m_recStats.m_dwMLTotal / m_pStatsBlob->m_recStats.m_dwNumMessages,
			m_pStatsBlob->m_recStats.m_dwMLMin,
			m_pStatsBlob->m_recStats.m_dwMLMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Header Size (bytes)    : Avg: %u [%u..%u]",
	        (m_pStatsBlob->m_recStats.m_dwSentFrames == 0) ? 0 : m_pStatsBlob->m_recStats.m_dwHSTotal / m_pStatsBlob->m_recStats.m_dwSentFrames,
	        m_pStatsBlob->m_recStats.m_dwHSMin,
	        m_pStatsBlob->m_recStats.m_dwHSMax );
	        
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Speech Size (bytes)    : Avg: %u [%u..%u]",
	        (m_pStatsBlob->m_recStats.m_dwSentFrames == 0) ? 0 : m_pStatsBlob->m_recStats.m_dwCSTotal / m_pStatsBlob->m_recStats.m_dwSentFrames,
	        m_pStatsBlob->m_recStats.m_dwCSMin,
	        m_pStatsBlob->m_recStats.m_dwCSMax );

    DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Speech Convert (ms)    : Avg: %u [%u..%u]", 
            (m_pStatsBlob->m_recStats.m_dwSentFrames == 0) ? 0 : (m_pStatsBlob->m_recStats.m_dwCTTotal / m_pStatsBlob->m_recStats.m_dwSentFrames),
            m_pStatsBlob->m_recStats.m_dwCTMin,
            m_pStatsBlob->m_recStats.m_dwCTMax );
	
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Record Resets          : %u [Before Success %u..%u]", m_pStatsBlob->m_recStats.m_dwRRTotal, 
			m_pStatsBlob->m_recStats.m_dwRRMin, 
			m_pStatsBlob->m_recStats.m_dwRRMax );
	
	sprintf( tmpBuffer, "Rec Movement (ms)      : Avg: %u [%u..%u]", 
			m_pStatsBlob->m_recStats.m_dwRMMSTotal / dwNumInternalRuns,
			m_pStatsBlob->m_recStats.m_dwRMMSMin,
			m_pStatsBlob->m_recStats.m_dwRMMSMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Rec Movement (frames)  : Avg: %.2f [%.2f..%.2f]", 
			( ((float)m_pStatsBlob->m_recStats.m_dwRMMSTotal) / ((float) dwNumInternalRuns)) / ((float) m_pStatsBlob->m_recStats.m_dwFrameTime),
			((float) m_pStatsBlob->m_recStats.m_dwRMMSMin) / ((float) m_pStatsBlob->m_recStats.m_dwFrameTime),
			((float) m_pStatsBlob->m_recStats.m_dwRMMSMax) / ((float) m_pStatsBlob->m_recStats.m_dwFrameTime));

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Rec Movement (bytes)   : Avg: %u [%u..%u]",
			m_pStatsBlob->m_recStats.m_dwRMBTotal / dwNumInternalRuns,
			m_pStatsBlob->m_recStats.m_dwRMBMin,
			m_pStatsBlob->m_recStats.m_dwRMBMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Rec Movement (frames)  : Avg: %.2f [%.2f..%.2f]",
			(((float) m_pStatsBlob->m_recStats.m_dwRMBTotal) / ((float) dwNumInternalRuns)) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize),
			((float) m_pStatsBlob->m_recStats.m_dwRMBMin) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize),
			((float) m_pStatsBlob->m_recStats.m_dwRMBMax) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize) );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );
			
	sprintf( tmpBuffer, "Move Delta (ms)        : Avg: %u [%u..%u]", 
			m_pStatsBlob->m_recStats.m_dwRTSLMTotal / dwNumInternalRuns,
			m_pStatsBlob->m_recStats.m_dwRTSLMMin,
			m_pStatsBlob->m_recStats.m_dwRTSLMMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Move Delta (frames)    : Avg: %.2f [%.2f..%.2f]",
			(((float) m_pStatsBlob->m_recStats.m_dwRTSLMTotal) / ((float) dwNumInternalRuns)) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize),
			((float) m_pStatsBlob->m_recStats.m_dwRTSLMMin) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize),
			((float) m_pStatsBlob->m_recStats.m_dwRTSLMMax) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize) );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );
			
	sprintf( tmpBuffer, "Record Lag (bytes)     : Avg: %u [%u..%u]",
			m_pStatsBlob->m_recStats.m_dwRLTotal / dwNumInternalRuns,
			m_pStatsBlob->m_recStats.m_dwRLMin ,
			m_pStatsBlob->m_recStats.m_dwRLMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Record Lag (frames)    : Avg: %.2f [%.2f..%.2f]",
			(float) ((float) m_pStatsBlob->m_recStats.m_dwRLTotal / (float) dwNumInternalRuns) / ((float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize),
			(float) ((float) m_pStatsBlob->m_recStats.m_dwRLMin) / (float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize,
			(float) ((float) m_pStatsBlob->m_recStats.m_dwRLMax) / (float) m_pStatsBlob->m_recStats.m_dwUnCompressedSize );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Dump_Playback"
void  CDirectVoiceClientEngine::ClientStats_Dump_Playback()
{
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Playback Stats: " );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Frames (silent)        : %d", m_pStatsBlob->m_dwPPDQSilent );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Frames (lost)          : %d", m_pStatsBlob->m_dwPPDQLost );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Frames (speech)        : %d", m_pStatsBlob->m_dwPPDQSpeech );

    DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Speech Decompress (ms) : Avg: %u [%u..%u]", 
            (m_pStatsBlob->m_dwPPDQSpeech == 0) ? 0 : (m_pStatsBlob->m_dwPDTTotal / m_pStatsBlob->m_dwPPDQSpeech),
            m_pStatsBlob->m_dwPDTMin,
            m_pStatsBlob->m_dwPDTMax );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Dump_Receive"
void  CDirectVoiceClientEngine::ClientStats_Dump_Receive()
{
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Receive Stats: " );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Received Frames        : %d", m_pStatsBlob->m_dwPRESpeech );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Received But Lost      : %d", m_pStatsBlob->m_dwPRESpeech - m_pStatsBlob->m_dwPPDQSpeech );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Dump_Transmit"
void CDirectVoiceClientEngine::ClientStats_Dump_Transmit()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Dump"
void CDirectVoiceClientEngine::ClientStats_Dump()
{
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "STATS DUMP: ----------------------------------------------------[Begin] " );
	
	ClientStats_Dump_Record();
	ClientStats_Dump_Playback();
	ClientStats_Dump_Receive();
	ClientStats_Dump_Transmit();

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "STATS DUMP: ------------------------------------------------------[End] " );	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_Begin"
void CDirectVoiceClientEngine::ClientStats_Begin()
{
	m_pStatsBlob->m_dwTimeStart = GetTickCount();
	m_pStatsBlob->m_dwMaxBuffers = 1;
	m_pStatsBlob->m_dwTotalBuffers = 1;
	m_pStatsBlob->m_dwPDTMin = 0xFFFFFFFF;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientStats_End"
void CDirectVoiceClientEngine::ClientStats_End()
{
	m_pStatsBlob->m_dwTimeStop = GetTickCount();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientBufferAlloc"
PVOID CDirectVoiceClientEngine::ClientBufferAlloc( void *const pv, const DWORD dwSize )
{
    return new BYTE[dwSize];
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ClientBufferFree"
void CDirectVoiceClientEngine::ClientBufferFree( void *const pv, void *const pvBuffer )
{
    delete pvBuffer;
}

#undef DPF_MODNAME
/*#define DPF_MODNAME "CDirectVoiceClientEngine::GetTransmitBuffer"
PDVTRANSPORT_BUFFERDESC CDirectVoiceClientEngine::GetTransmitBuffer( DWORD dwSize, LPVOID *ppvSendContext )
{
    PDVTRANSPORT_BUFFERDESC pNewBuffer;

    pNewBuffer = new DVTRANSPORT_BUFFERDESC;
    pNewBuffer->pBufferData = new BYTE[dwSize];
    pNewBuffer->dwBufferSize = dwSize;
	pNewBuffer->lRefCount = 0;
	pNewBuffer->dwObjectType = DVTRANSPORT_OBJECTTYPE_CLIENT;
	pNewBuffer->dwFlags = 0;

    *ppvSendContext = pNewBuffer;

    return pNewBuffer;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ReturnTransmitBuffer"
// ReturnTransmitBuffer
//
// PDVTRANSPORT_BUFFERDESC pBufferDesc - Buffer description of buffer to return
// LPVOID lpvContext - Context value to be used when returning the buffer 
// 
void CDirectVoiceClientEngine::ReturnTransmitBuffer( PVOID pvContext )
{
    PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pvContext;
    
    delete [] pBufferDesc->pBufferData;
    delete pBufferDesc; 
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendComplete"
HRESULT CDirectVoiceClientEngine::SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete )
{
    ReturnTransmitBuffer( pSendComplete->pvUserContext );
    return DV_OK;
}*/

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::GetTransmitBuffer"
PDVTRANSPORT_BUFFERDESC CDirectVoiceClientEngine::GetTransmitBuffer( DWORD dwSize, LPVOID *ppvSendContext )
{
    PDVTRANSPORT_BUFFERDESC pNewBuffer = NULL;
    DWORD dwFPMIndex = 0xFFFFFFFF;
    DWORD dwWastedSpace = 0xFFFFFFFF;
    DWORD dwSearchFPMIndex = 0;

    DNEnterCriticalSection( &m_csTransmitBufferLock );

    pNewBuffer = (PDVTRANSPORT_BUFFERDESC) m_pBufferDescPool->Get( m_pBufferDescPool );

    DNLeaveCriticalSection( &m_csTransmitBufferLock );

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer desc address 0x%p", (void *) pNewBuffer );

    if( pNewBuffer == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting transmit buffer" );
        goto GETTRANSMITBUFFER_ERROR;
    }

	pNewBuffer->lRefCount = 0;
	pNewBuffer->dwObjectType = DVTRANSPORT_OBJECTTYPE_CLIENT;
	pNewBuffer->dwFlags = 0;
	pNewBuffer->pBufferData = NULL;

    for( dwSearchFPMIndex = 0; dwSearchFPMIndex < m_dwNumPools; dwSearchFPMIndex++ )
    {
        // Potential pool
        if( m_pdwBufferPoolSizes[dwSearchFPMIndex] >= dwSize )
        {
            if( m_pdwBufferPoolSizes[dwSearchFPMIndex] - dwSize < dwWastedSpace )
            {
                dwWastedSpace = m_pdwBufferPoolSizes[dwSearchFPMIndex] - dwSize;
                dwFPMIndex = dwSearchFPMIndex;
            }
        }
    }

    if( dwFPMIndex == 0xFFFFFFFF )
    {
        DNASSERT( FALSE );
        DPFX(DPFPREP,  0, "Could not find pool large enough for buffer" );
        goto GETTRANSMITBUFFER_ERROR;
    }
	
	pNewBuffer->pvContext = m_pBufferPools[dwFPMIndex];

    DNEnterCriticalSection( &m_csTransmitBufferLock );	
    pNewBuffer->pBufferData = (PBYTE) m_pBufferPools[dwFPMIndex]->Get(m_pBufferPools[dwFPMIndex]);
    DNLeaveCriticalSection( &m_csTransmitBufferLock );

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer value at address 0x%p", (void *) pNewBuffer->pBufferData );

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: nInUse  = %i", m_pBufferDescPool->nInUse );	

    if( pNewBuffer->pBufferData == NULL )
    {
        DPFX(DPFPREP,  0, "Error getting buffer for buffer desc" );
        goto GETTRANSMITBUFFER_ERROR;
    }
    
    pNewBuffer->dwBufferSize = dwSize;

    *ppvSendContext = pNewBuffer;

    return pNewBuffer;

GETTRANSMITBUFFER_ERROR:

    DNEnterCriticalSection( &m_csTransmitBufferLock );
    if( pNewBuffer != NULL && pNewBuffer->pBufferData != NULL )
    {
        ((PFPOOL) pNewBuffer->pvContext)->Release( ((PFPOOL) pNewBuffer->pvContext), pNewBuffer->pBufferData );
    }

    if( pNewBuffer != NULL )
    {
        m_pBufferDescPool->Release( m_pBufferDescPool, pNewBuffer );
    }
    DNLeaveCriticalSection( &m_csTransmitBufferLock );

    return NULL;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ReturnTransmitBuffer"
// ReturnTransmitBuffer
//
// PDVTRANSPORT_BUFFERDESC pBufferDesc - Buffer description of buffer to return
// LPVOID lpvContext - Context value to be used when returning the buffer 
// 
void CDirectVoiceClientEngine::ReturnTransmitBuffer( PVOID pvContext )
{
    PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pvContext;
    PFPOOL pPool = (PFPOOL) pBufferDesc->pvContext;

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer desc at address 0x%p", (void *) pBufferDesc );
	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer at address 0x%p", (void *) pBufferDesc->pBufferData );

    DNEnterCriticalSection( &m_csTransmitBufferLock );

    // Release memory
    pPool->Release( pPool, pBufferDesc->pBufferData );

    // Release buffer description
    m_pBufferDescPool->Release( m_pBufferDescPool, pvContext );
	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: nInUse  = %i", m_pBufferDescPool->nInUse );

    DNLeaveCriticalSection( &m_csTransmitBufferLock );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SendComplete"
HRESULT CDirectVoiceClientEngine::SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete )
{
    ReturnTransmitBuffer( pSendComplete->pvUserContext );
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetupInitialBuffers"
// SetupBuffersInitial
//
// This function sets up the first transmit buffers which do not vary
// in size w/the compression type.
//
HRESULT CDirectVoiceClientEngine::SetupInitialBuffers()
{
    HRESULT hr = DV_OK;
    DWORD dwIndex;

    m_dwNumPools = CLIENT_POOLS_NUM;

    m_pBufferDescPool = FPM_Create( sizeof(DVTRANSPORT_BUFFERDESC), NULL, NULL, NULL, NULL, &m_pStatsBlob->m_dwBDPOutstanding, &m_pStatsBlob->m_dwBDPAllocated );

    if( m_pBufferDescPool == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DVERR_OUTOFMEMORY;
        goto SETUPBUFFERS_ERROR;
    }

    m_pBufferPools = new PFPOOL[m_dwNumPools];

    if( m_pBufferPools == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DVERR_OUTOFMEMORY;
        goto SETUPBUFFERS_ERROR;
    }

    memset( m_pBufferPools, 0x00, sizeof( PFPOOL ) * m_dwNumPools );

    m_pdwBufferPoolSizes = new DWORD[m_dwNumPools];

    if( m_pdwBufferPoolSizes == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DVERR_OUTOFMEMORY;
        goto SETUPBUFFERS_ERROR;
    }

    m_pdwBufferPoolSizes[0] = CLIENT_POOLS_SIZE_MESSAGE;
    m_pdwBufferPoolSizes[1] = CLIENT_POOLS_SIZE_PLAYERLIST;
    m_pdwBufferPoolSizes[ m_dwNumPools-1] = 0;

    for( dwIndex = 0; dwIndex < m_dwNumPools-1; dwIndex++ )
    {
        m_pBufferPools[dwIndex] = FPM_Create( m_pdwBufferPoolSizes[dwIndex], NULL, NULL, NULL, NULL, &m_pStatsBlob->m_dwBPOutstanding[dwIndex], &m_pStatsBlob->m_dwBPAllocated[dwIndex] );

        if( m_pBufferPools == NULL )
        {
            DPFX(DPFPREP,  0, "Error creating transmit buffers" );
            goto SETUPBUFFERS_ERROR;
        }
    }

    m_pBufferPools[dwIndex] = NULL;

    return DV_OK;

SETUPBUFFERS_ERROR:

    FreeBuffers();

    return hr;
        
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetupSpeechBuffer"
// SetupSpeechBuffer
//
// This function sets up the buffer pool for speech sends, whose size will
// depend on the compression type.  Must be done after we know CT but 
// before we do first speech transmission.
//
HRESULT CDirectVoiceClientEngine::SetupSpeechBuffer()
{
    if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER || 
        m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO )
    {
        m_pdwBufferPoolSizes[m_dwNumPools-1] = sizeof( DVPROTOCOLMSG_SPEECHHEADER )+m_dwCompressedFrameSize+COMPRESSION_SLUSH;
    }
    else
    {
        m_pdwBufferPoolSizes[m_dwNumPools-1] = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) + m_dwCompressedFrameSize + 
                                  (sizeof( DVID )*CLIENT_POOLS_NUM_TARGETS_BUFFERED)+COMPRESSION_SLUSH;
    }

    m_pBufferPools[m_dwNumPools-1] = FPM_Create( m_pdwBufferPoolSizes[m_dwNumPools-1], NULL, NULL, NULL, NULL, &m_pStatsBlob->m_dwBPOutstanding[m_dwNumPools-1], &m_pStatsBlob->m_dwBPAllocated[m_dwNumPools-1] );

    if( m_pBufferPools == NULL )
    {
        DPFX(DPFPREP,  0, "Error creating transmit buffers" );
        return DVERR_OUTOFMEMORY;
    }

    return DV_OK;
}
  
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::FreeBuffers"
HRESULT CDirectVoiceClientEngine::FreeBuffers()
{
    DWORD dwIndex;

    if( m_pBufferPools != NULL )
    {
        for( dwIndex  = 0; dwIndex < m_dwNumPools; dwIndex++ )
        {
            if( m_pBufferPools[dwIndex] != NULL )
                m_pBufferPools[dwIndex]->Fini(m_pBufferPools[dwIndex],FALSE);
        }
        
        delete [] m_pBufferPools;

        m_pBufferPools = NULL;
    }

    if( m_pdwBufferPoolSizes != NULL )
    {
        delete [] m_pdwBufferPoolSizes;
        m_pdwBufferPoolSizes = 0;
    }

    if( m_pBufferDescPool != NULL )
    {
        m_pBufferDescPool->Fini( m_pBufferDescPool, FALSE );
        m_pBufferDescPool = NULL;
    }

    m_dwNumPools = 0;

    return DV_OK;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ValidateSessionType"
BOOL CDirectVoiceClientEngine::ValidateSessionType( DWORD dwSessionType )
{
	return (dwSessionType > 0 && dwSessionType < DVSESSIONTYPE_MAX);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ValidateSessionFlags"
BOOL CDirectVoiceClientEngine::ValidateSessionFlags( DWORD dwFlags )
{
	return (dwFlags < DVSESSION_MAX);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ValidatePlayerFlags"
BOOL CDirectVoiceClientEngine::ValidatePlayerFlags(DWORD dwFlags)
{
	return (dwFlags < DVPLAYERCAPS_MAX);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ValidatePlayerDVID"
BOOL CDirectVoiceClientEngine::ValidatePlayerDVID(DVID dvid)
{
	return (dvid !=  DVID_ALLPLAYERS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::ValidatePacketType"
BOOL CDirectVoiceClientEngine::ValidatePacketType( PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage )
{

	switch( lpdvFullMessage->dvGeneric.dwType )
	{
	case DVMSGID_HOSTMIGRATELEAVE:
	case DVMSGID_HOSTMIGRATED:
	case DVMSGID_CREATEVOICEPLAYER:
	case DVMSGID_DELETEVOICEPLAYER:
	case DVMSGID_PLAYERLIST:
		return ( ( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER ) );
		break;
	case DVMSGID_SPEECHWITHFROM:
		return ( ( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING) );
		break;
	case DVMSGID_SETTARGETS:
		return ( m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET );
		break;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvconfig.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvclientengine.h
 *  Content:	Definition of class for DirectXVoice Client
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/21/2000 	rodtoll	Created it
 ***************************************************************************/

#ifndef __DVCONFIG_H
#define __DVCONFIG_H

// Why is this here?  Because sometimes voxware likes to write past the last
// byte we give it.  
#define COMPRESSION_SLUSH			2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvcleng.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvclientengine.h
 *  Content:	Definition of class for DirectXVoice Client
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created it
 * 07/21/99		rodtoll Added flags field to entity data
 * 07/26/99		rodtoll	Updated to support IDirectXVoiceNotify interface
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 * 08/30/99		rodtoll	Added additional members to handle connect/disconnect timeout
 * 08/31/99		rodtoll	Added new handle for new disconnect procedure
 * 09/03/99		rodtoll	Re-work of playback core to support mixing to multiple buffers
 *						for 3d support.
 *						Re-worked playback to use position instead of notifications
 *						allows for simpler handling of high CPU and 3d support
 *						Implemented CreateUserBuffer/DeleteUserBuffer
 * 09/14/99		rodtoll	Added members to support new notify masks
 *				rodtoll	Added CheckShouldSendMessage
 *				rodtoll	Added SendPlayerLevels
 *				rodtoll	Updated initialize for new parameters
 *				rodtoll	Added SetNotifyMask function
 * 09/18/99		rodtoll Added HandleThreadError to be called when an internal thread dies.   
 * 09/27/99		rodtoll	Added playback volume control
 *              rodtoll	Added reduction of playback volume when transmitting 
 * 09/28/99		rodtoll	Double notifications of local client when host migrates fixed.
 *				rodtoll	Added queue for notifications, notifications are added to the queue and 
 *						then signalled by the notify thread.  (Prevents problems caused by notify 
 *						handlers taking a long time to return).
 * 09/29/99		pnewson Major AGC overhaul
 * 10/19/99		rodtoll	Fix: Bug #113904 Shutdown Issues
 *					    Added handler for SESSIONLOST messages
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.
 * 11/12/99		rodtoll	Updated to use new playback and record classes and remove
 *						old playback/record system.  (Includes new waveIn/waveOut support)
 *				rodtoll	Updated to support new recording thread
 *				rodtoll	Added new echo suppression code
 * 11/17/99		rodtoll Fix: Bug #117177 - Calling Connect w/o voice session never returns
 * 11/23/99		rodtoll	Updated Initialize/SetNotifyMask so error checking behaviour is consistant
 * 12/16/99	    rodtoll	Bug #117405 - 3D Sound APIs misleading - 3d sound apis renamed
 *						The Delete3DSoundBuffer was re-worked to match the create
 *  			rodtoll Bug #122629 - Host migration broken in unusual configurations
 *						Implemented new host migration scheme 
 * 01/10/00		pnewson AGC and VA tuning
 * 01/14/2000	rodtoll	Updated for new Set/GetTransmit target parameters
 *				rodtoll	Updated to support multiple targets
 *				rodtoll	Updated for new notification queueing 
 *				rodtoll	Added FPM for handling notification memory
 * 01/21/00		rodtoll	Bug #128897 - Disconnect timeout broken
 * 01/24/2000	rodtoll	Bug #129427: Calling Destroy3DSoundBuffer for player who has
 *						already disconnected resulted in an incorrect DVERR_NOTBUFFERED 
 *						error code.
 * 01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *						Added instrumentation 
 *  03/28/2000  rodtoll   Re-wrote nametable handling and locking -- more scalable  
 * 03/29/2000	rodtoll	Bug #30957 - Made conversion quality setting optional
 *				rodtoll Bug #30753 - Added volatile to the class definition
 *  04/07/2000  rodtoll Bug #32179 - Prevent registration of > 1 interface
 *              rodtoll Updated to use no copy sends, so handles pooling frames to be sent, proper
 *                      pulling of frames from pools and returns.   
 *  05/17/2000  rodtoll Bug #35110 Simultaneous playback of 2 voices results in distorted playback 
 *  06/21/2000	rodtoll	Bug #35767 - Implement ability for Dsound effects processing if dpvoice buffers
 *						Updated Connect and Create3DSoundBuffer to take buffers instead of descriptions
 *				rodtoll	Bug #36820 - Host migrates to wrong client when server is shut down before host's client disconnects
 *						Caused because client attempts to register new server when there is one already
 *				rodtoll	Bug #37045 - Race conditions prevent acknowledgement of new host
 *						Added send when new host is elected of settingsconfirm message
 *	06/27/2000	rodtoll	Fixed window where outstanding sends being returned after we have deregistered
 *						Voice now waits for all outstanding voice sends to complete before shutting down
 *				rodtoll	Added COM abstraction
 *  07/09/2000	rodtoll	Added signature bytes
 *  07/12/2000	rodtoll	Bug #39117 - Access violation while running VoicePosition.  Several issues:
 *						- Allow Destroy3DBuffer during disconnect
 *						- Move nametable cleanup to before freesoundbufferlist
 *						- Fixed code so always remove from list on DeleteSoundTarget
 *						- Removed unneeded logic
 * 07/22/20000	rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *						Now ensures that all threads from transport have left and that
 *						all notificatinos have been processed before shutdown is complete. 
 * 11/16/2000	rodtoll	Bug #40587 - DPVOICE: Mixing server needs to use multi-processors  
 * 01/26/2001	rodtoll	WINBUG #293197 - DPVOICE: [STRESS} Stress applications cannot tell difference between out of memory and internal errors.
 *						Remap DSERR_OUTOFMEMORY to DVERR_OUTOFMEMORY instead of DVERR_SOUNDINITFAILURE.
 *						Remap DSERR_ALLOCATED to DVERR_PLAYBACKSYSTEMERROR instead of DVERR_SOUNDINITFAILURE. 
 * 04/06/2001	kareemc	Added Voice Defense
 * 04/11/2001  	rodtoll	WINBUG #221494 DPVOICE: Capped the # of queued recording events to prevent multiple wakeups resulting in false lockup
 *						detection 
 * 
 ***************************************************************************/

#ifndef __DVCLIENTENGINE_H
#define __DVCLIENTENGINE_H

#define DVCSTATE_NOTINITIALIZED		0x00000000
#define DVCSTATE_IDLE				0x00000001
#define DVCSTATE_CONNECTING			0x00000002
#define DVCSTATE_CONNECTED			0x00000003
#define DVCSTATE_DISCONNECTING		0x00000004

#define DVCECHOSTATE_IDLE			0x00000000
#define DVCECHOSTATE_RECORDING		0x00000001
#define DVCECHOSTATE_PLAYBACK		0x00000002

struct DIRECTVOICECLIENTOBJECT;

// Size in bytes of the fixed size elements
#define DV_CLIENT_NOTIFY_ELEMENT_SIZE	16

// Wakeup multiplier -- how many times / time we're supposed
// to wakeup should we actually wake up
#define DV_CLIENT_WAKEUP_MULTIPLER		4

#if defined(DEBUG) || defined(DBG)
#define CHECKLISTINTEGRITY			CheckListIntegrity
#else
#define CHECKLISTINTEGRITY()		
#endif

// CDirectVoiceClientEngine
//
// This class represents the IDirectXVoiceClient interface.
//
// The class is thread safe except for construction and
// destruction.  The class is protected with a Multiple-Reader
// Single-Write lock.
//
#define VSIG_CLIENTENGINE		'ELCV'
#define VSIG_CLIENTENGINE_FREE	'ELC_'
//
volatile class CDirectVoiceClientEngine: public CDirectVoiceEngine
{
protected:

	typedef enum { NOTIFY_FIXED,   // Structure stored in fixed
				   NOTIFY_DYNAMIC  // Memory allocated in dynamic
				 } ElementType;

	struct CNotifyElement
	{
		typedef VOID (*PNOTIFY_COMPLETE)(PVOID pvContext, CNotifyElement *pElement);		
	
		DWORD			m_dwType;
		union _Element
		{
			struct 
			{
				LPVOID			m_lpData;
			} dynamic;
			struct
			{
				BYTE			m_bFixedHolder[DV_CLIENT_NOTIFY_ELEMENT_SIZE];
			} fixed;
		} 					m_element;
		DWORD				m_dwDataSize;		
		ElementType			m_etElementType;
		PVOID				pvContext;
		PNOTIFY_COMPLETE	pNotifyFunc;
		CNotifyElement 		*m_lpNext;
	};

	struct TimerHandlerParam
	{
		HANDLE			hPlaybackTimerEvent;
		volatile LONG	lPlaybackCount;
		HANDLE			hRecordTimerEvent;
		DNCRITICAL_SECTION csPlayCount;
	};

public:
	CDirectVoiceClientEngine( DIRECTVOICECLIENTOBJECT *lpObject );
	~CDirectVoiceClientEngine();

public: // IDirectXVoiceClient Interface
	HRESULT Connect( LPDVSOUNDDEVICECONFIG lpSoundDeviceConfig, LPDVCLIENTCONFIG lpClientConfig, DWORD dwFlags );
	HRESULT Disconnect( DWORD dwFlags );
	HRESULT GetSessionDesc( LPDVSESSIONDESC lpSessionDescBuffer );
	HRESULT GetClientConfig( LPDVCLIENTCONFIG lpClientConfig );
	HRESULT SetClientConfig( LPDVCLIENTCONFIG lpClientConfig );
	HRESULT GetCaps( LPDVCAPS lpCaps );
	HRESULT GetCompressionTypes( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags );
	HRESULT SetTransmitTarget( PDVID dvidTarget, DWORD dwNumTargets, DWORD dwFlags );
	HRESULT GetTransmitTarget( LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags );
	HRESULT Create3DSoundBuffer( DVID dvidID, LPDIRECTSOUNDBUFFER lpdsBufferDesc, DWORD dwPriority, DWORD dwFlags, LPDIRECTSOUND3DBUFFER *lpBuffer );
	HRESULT Delete3DSoundBuffer( DVID dvidID, LPDIRECTSOUND3DBUFFER *lpBuffer );
	HRESULT SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );
	HRESULT GetSoundDeviceConfig( PDVSOUNDDEVICECONFIG pSoundDeviceConfig, PDWORD pdwBufferSize );

public: // CDirectVoiceEngine Members
	HRESULT Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements );
	BOOL ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize );
	HRESULT StartTransportSession();
	HRESULT StopTransportSession();
	HRESULT AddPlayer( DVID dvID );
	HRESULT RemovePlayer( DVID dvID );
	HRESULT CreateGroup( DVID dvID );
	HRESULT DeleteGroup( DVID dvID );
	HRESULT AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer );

	HRESULT MigrateHost_RunElection();

	inline DWORD GetCurrentState() { return m_dwCurrentState; };	

	BOOL	InitClass();

public: // packet validation
	inline BOOL ValidateSessionType( DWORD dwSessionType );
	inline BOOL ValidateSessionFlags( DWORD dwFlags );
	inline BOOL ValidatePlayerFlags( DWORD dwFlags );
	inline BOOL ValidatePlayerDVID( DVID dvid );
	inline BOOL ValidatePacketType( PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage );
	
protected: // Message handlers

	HRESULT InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );

	BOOL QueueSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize );

	BOOL HandleConnectRefuse( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREFUSE lpdvConnectRefuse, DWORD dwSize );
	BOOL HandleCreateVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERJOIN lpdvCreatePlayer, DWORD dwSize );
	BOOL HandleDeleteVoicePlayer( DVID dvidSource, PDVPROTOCOLMSG_PLAYERQUIT lpdvDeletePlayer, DWORD dwSize );
	BOOL HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize );
	BOOL HandleSpeechWithFrom( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHFROM lpdvSpeech, DWORD dwSize );	
	BOOL HandleSpeechBounce( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize );
	BOOL HandleConnectAccept( DVID dvidSource, PDVPROTOCOLMSG_CONNECTACCEPT lpdvConnectAccept, DWORD dwSize );
	BOOL HandleDisconnectConfirm( DVID dvidSource, PDVPROTOCOLMSG_DISCONNECT lpdvDisconnect, DWORD dwSize );
	BOOL HandleSetTarget( DVID dvidSource, PDVPROTOCOLMSG_SETTARGET lpdvSetTarget, DWORD dwSize );
	BOOL HandleSessionLost( DVID dvidSource, PDVPROTOCOLMSG_SESSIONLOST lpdvSessionLost, DWORD dwSize );
	BOOL HandlePlayerList( DVID dvidSource, PDVPROTOCOLMSG_PLAYERLIST lpdvPlayerList, DWORD dwSize );
	BOOL HandleHostMigrated( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATED lpdvHostMigrated, DWORD dwSize );
	BOOL HandleHostMigrateLeave( DVID dvidSource, PDVPROTOCOLMSG_HOSTMIGRATELEAVE lpdvHostMigrateLeave, DWORD dwSize );

	friend class CClientRecordSubSystem;

protected:

	void CheckListIntegrity();

	void DoSessionLost(HRESULT hrReason);
	void DoSignalDisconnect(HRESULT hrDisconnectReason);

	void HandleThreadError( HRESULT hrResult );

	// Actually send the message to the client app
	void TransmitMessage( DWORD dwMessageType, LPVOID lpData, DWORD dwSize );

	void Cleanup();
	void DoDisconnect();
	void DoConnectResponse();
	void WaitForBufferReturns();

	void SetCurrentState( DWORD dwState );
	HRESULT InitializeSoundSystem();
	HRESULT ShutdownSoundSystem();
	HRESULT CheckForDuplicateObjects();
	HRESULT HandleLocalHostMigrateCreate();

	void SetConnectResult( HRESULT hrOriginalResult );
	HRESULT GetConnectResult();

	void SetupPlaybackBufferDesc( LPDSBUFFERDESC lpdsBufferDesc, LPDSBUFFERDESC lpdsBufferSource );

	HRESULT InitializeClientServer();
	void DeInitializeClientServer();

	void CheckForUserTimeout( DWORD dwCurTime );
	void SendPlayerLevels();

	BOOL CheckShouldSendMessage( DWORD dwMessageType );

	HRESULT CreateGeneralBuffer( );
	void UpdateActivePlayPendingList();
	void UpdateActiveNotifyPendingList();
	void CleanupNotifyLists();
	void CleanupPlaybackLists();

	static void __cdecl RecordThread( void *lpParam );
	static void __cdecl PlaybackThread( void *lpParam );
	static void __cdecl NotifyThread( void *lpParam );
	static BOOL MixingWakeupProc( DWORD_PTR param );
	static PVOID ClientBufferAlloc( void *const pv, const DWORD dwSize );
	static void ClientBufferFree( void *const pv, void *const pvBuffer );

	PDVTRANSPORT_BUFFERDESC GetTransmitBuffer( DWORD dwSize, LPVOID *ppvContext );
    HRESULT SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete );
    void ReturnTransmitBuffer( PVOID pvContext );

    HRESULT Send_ConnectRequest();
    HRESULT Send_DisconnectRequest();
    HRESULT Send_SessionLost();
    HRESULT Send_SettingsConfirm();

	HRESULT SetPlaybackVolume( LONG lVolume );

	DWORD						m_dwSignature;

    CFramePool                  *m_lpFramePool;			// Pool of frames
    CDirectVoiceTransport		*m_lpSessionTransport;	// Transport for the session
	DVSOUNDDEVICECONFIG			m_dvSoundDeviceConfig;	// Sound device config
	DVCLIENTCONFIG				m_dvClientConfig;		// Sound general config
	DVSESSIONDESC				m_dvSessionDesc;		// Session configuration
	DVCAPS						m_dvCaps;				// Caps
	LPDVMESSAGEHANDLER			m_lpMessageHandler;		// User message handler
	LPVOID						m_lpUserContext;		// User context for message handler
	DVID						m_dvidServer;			// DVID of the server

	PDVID						m_pdvidTargets;			// DVID of the current target(s) (Protected by m_csTargetLock)
	DWORD						m_dwNumTargets;			// # of targets (Protected by m_csTargetLock)
	DWORD						m_dwTargetVersion;		// Increment each time targets are changed
	DNCRITICAL_SECTION			m_csTargetLock;			// If you need write/read lock, always take it before this lock

	HRESULT						InternalSetTransmitTarget( PDVID pdvidTargets, DWORD dwNumTargets );
	HRESULT						CheckForAndRemoveTarget( DVID dvidID );
	
	volatile DWORD    			m_dwCurrentState;		// Current engine state
	CFrame						*m_tmpFrame;			// Tmp frame for receiving
	LPDIRECTPLAYVOICESERVER		m_lpdvServerMigrated;	// Stores reference to migrated host

	DWORD						m_dwActiveCount;
	DWORD						m_dwEchoState;
	DNCRITICAL_SECTION			m_lockPlaybackMode;

	DNCRITICAL_SECTION			m_csCleanupProtect;		// Used to ensure only only cleanup instance is active

protected: // Buffer maintenance

    HRESULT                     AddSoundTarget( CSoundTarget *lpcsTarget );
    HRESULT                     DeleteSoundTarget( DVID dvidID );
    HRESULT                     FindSoundTarget( DVID dvidID, CSoundTarget **lpcsTarget );
    HRESULT                     InitSoundTargetList();
    HRESULT                     FreeSoundTargetList();

protected: // Notification queue 

	// Queue up a notification for the user
	HRESULT NotifyQueue_Add( DWORD dwMessageType, LPVOID lpData, DWORD dwDataSize, PVOID pvContext = NULL, CNotifyElement::PNOTIFY_COMPLETE pNotifyFunc = NULL );
	HRESULT NotifyQueue_Get( CNotifyElement **pneElement );
	HRESULT NotifyQueue_Init();
	HRESULT NotifyQueue_Free();
	HRESULT NotifyQueue_ElementFree( CNotifyElement *lpElement );
	HRESULT NotifyQueue_IndicateNext();
	void NotifyQueue_Disable();
	void NotifyQueue_Enable();
	void NotifyQueue_Flush();

	static void NotifyComplete_SyncWait( PVOID pvContext, CNotifyElement *pElement );
	static void NotifyComplete_LocalPlayer( PVOID pvContext, CNotifyElement *pElement );
	static void NotifyComplete_RemotePlayer( PVOID pvContext, CNotifyElement *pElement );

	DNCRITICAL_SECTION			m_csNotifyQueueLock;	// Notification queue 
	BOOL						m_fNotifyQueueEnabled;
	CNotifyElement				*m_lpNotifyList;		// List of notifications
	HANDLE						m_hNewNotifyElement;	// Semaphore signalled when new event is queued	

	HRESULT						SendConnectResult();
	HRESULT						SendDisconnectResult();

protected: 

	HRESULT SetupInitialBuffers();
	HRESULT SetupSpeechBuffer();
	HRESULT FreeBuffers();

protected: // Statistics 

	void  ClientStats_Reset();
	void  ClientStats_Begin();
	void  ClientStats_End();
	void  ClientStats_Dump();
	void ClientStats_Dump_Record();
	void ClientStats_Dump_Playback();
	void ClientStats_Dump_Receive();
	void ClientStats_Dump_Transmit();
		
	ClientStatistics			m_stats;
	ClientStatistics			*m_pStatsBlob;
	
protected: // Sound System Information

	CAudioPlaybackBuffer		*m_audioPlaybackBuffer; // Audio playback buffer
	CAudioRecordDevice			*m_audioRecordDevice;	// Audio record device
	CAudioPlaybackDevice		*m_audioPlaybackDevice;	// Audio Playback Device
	CAudioRecordBuffer			*m_audioRecordBuffer;	// Audio Record Buffer;

	HANDLE						m_hNotifyDone;			// Signalled when notify thread dies
	HANDLE						m_hNotifyTerminate;		// Signalled to terminate notify thread
	HANDLE						m_hNotifyChange;		// Signalled when notification interval changes

	HANDLE						m_hRecordDone;			// Record thread done signal
	HANDLE						m_hRecordTerminate;		// Record thread stop signal

	HANDLE						m_hPlaybackDone;		// Playback thread done signal
	HANDLE						m_hPlaybackTerminate;	// Playback thread terminate signal

	HANDLE						m_hConnectAck;			// Signalled when connect complete

	HANDLE						m_hDisconnectAck;		// Signalled when disconnect complete
	HRESULT						m_hrDisconnectResult;	// Result of the disconnect result
	HRESULT						m_hrConnectResult;		// Result of the connection request
	HRESULT						m_hrOriginalConnectResult; // Original Connect Result (Untranslated)
	DVID						m_dvidLocal;			// Local DVID

	DNCRITICAL_SECTION			m_csClassLock;

	BOOL						m_fCritSecInited;

protected:
	// Compression Control Data
	LPDVFULLCOMPRESSIONINFO		m_lpdvfCompressionInfo;	// Information about current compression type
														// Memory pointed to is owned by dvcdb.cpp
	DWORD						m_dwCompressedFrameSize;
														// Size of a compressed frame
	DWORD						m_dwUnCompressedFrameSize;
														// Size of an uncompressed frame 
	DWORD						m_dwNumPerBuffer;		// # of frames / directsound buffer
	CFramePool					*m_pFramePool;			// Frame pool

	DIRECTVOICECLIENTOBJECT		*m_lpObject;			// Cached pointer to the COM interface 

	DWORD 						m_dwSynchBegin;			// GetTickCount at Connect/Disconnect start
	HANDLE						m_hNotifySynch;			// Notified when connect/disconnect completes

	HANDLE						m_hNotifyDisconnect;	// Signalled 
	HANDLE						m_hNotifyConnect;		// Connect

	HANDLE						m_hRecordThreadHandle;
	HANDLE						m_hPlaybackThreadHandle;

	DNCRITICAL_SECTION			m_csBufferLock;			// Lock to protect playback mixing buffers
	CSoundTarget				*m_lpstBufferList;		// Other Playback Mixing Buffers
	CSoundTarget				*m_lpstGeneralBuffer;	// General Playback Mixing Buffer

	LPDWORD						m_lpdwMessageElements;	// Buffer with notifiers
	DWORD						m_dwNumMessageElements;	// Number of notifiers 

	DNCRITICAL_SECTION			m_csNotifyLock;			// Lock on list of notifiers
	DSBUFFERDESC				m_dsBufferDesc;

	TimerHandlerParam			m_thTimerInfo;
	Timer						*m_pTimer;
	DWORD						m_dwLastConnectSent;
	DWORD						m_dwHostOrderID;
	DWORD						m_dwMigrateHostOrderID;	// Host Order ID of current host

	PVOID						m_pvLocalPlayerContext;

	DIRECTSOUNDMIXER_SRCQUALITY	m_dwOriginalRecordQuality;
	DIRECTSOUNDMIXER_SRCQUALITY m_dwOriginalPlayQuality;

	PFPOOL						m_pfpNotifications;		// Frame pool for notifications

	BYTE						m_bLastPeak;			// Last frame peak
	BYTE						m_bLastPlaybackPeak;	// Last peak on playback
	BYTE						m_bMsgNum;				// Last msg # transmitted
	BYTE						m_bSeqNum;				// Last sequence # transmitted
	
	BOOL						m_bLastTransmitted;		// Was last frame sent?
	BOOL						m_fSessionLost;			// Flag indicating session was lost
	BOOL						m_fLocalPlayerNotify;	// Has notification been sent for local player
	BOOL						m_fLocalPlayerAvailable;
	BOOL						m_fConnectAsync;		// Are we connecting async?
	BOOL						m_fDisconnectAsync;		// Are we disconnecting async?
    CVoiceNameTable             m_voiceNameTable;

	DWORD                       m_dwPlayActiveCount;
	BILINK						m_blPlayActivePlayers;
	BILINK						m_blPlayAddPlayers;
	DNCRITICAL_SECTION			m_csPlayAddList;

	BILINK						m_blNotifyActivePlayers;
	BILINK						m_blNotifyAddPlayers;
	DNCRITICAL_SECTION			m_csNotifyAddList;

    CLockedFixedPool<CVoicePlayer> m_fpPlayers;

    DNCRITICAL_SECTION        m_csTransmitBufferLock;
    PFPOOL                  m_pBufferDescPool;
    PFPOOL                  *m_pBufferPools;
    DWORD                   *m_pdwBufferPoolSizes;
    DWORD                   m_dwNumPools;

    PERF_APPLICATION		m_perfInfo;					// Perf info entry for this object
    PERF_APPLICATION_INFO	m_perfAppInfo;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvcsplay.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvcsplay.h
 *  Content:    Declaration of CDVCSPlayer class
 *  History:
 *	Date   By  Reason
 *	============
 *	07/22/99	rodtoll		created
 *  10/29/99	rodtoll		Bug #113726 - Integrate Voxware Codecs, updating to use new
 *							pluggable codec architecture.  
 *  01/14/2000	rodtoll		Updated to support multiple targets
 *  03/27/2000	rodtoll		Updated to use new base class for player record
 *  03/28/2000  rodtoll     Updated to use new player class as base
 *              rodtoll     Moved a bunch of logic out of server into this class
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 * 11/16/2000	rodtoll	Bug #40587 - DPVOICE: Mixing server needs to use multi-processors  
 ***************************************************************************/

#ifndef __DVCSPLAYER_H
#define __DVCSPLAYER_H

#define DPV_TARGETBUFFER_REALLOC_SIZE		10

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

// CDVCSPlayer
//
// This class extends the CDVPlayer class for client/server servers.
//
volatile class CDVCSPlayer: public CVoicePlayer
{
public:
	CDVCSPlayer();
	~CDVCSPlayer();

    HRESULT Initialize( const DVID dvidPlayer, const DWORD dwHostOrder, DWORD dwFlags, 
                        PVOID pvContext, DWORD dwCompressedSize, DWORD dwUnCompressedSize,
						CLockedFixedPool<CDVCSPlayer> *pCSOwner, DWORD dwNumMixingThreads );
    HRESULT DeInitialize();

    HRESULT HandleMixingReceive( PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize, PDVID pdvidTargets, DWORD dwNumTargets );
	HRESULT CompressOutBound( PVOID pvInputBuffer, DWORD dwInputBufferSize, PVOID pvOutputBuffer, DWORD *pdwOutputSize );

	inline HRESULT ResizeIfRequired( DWORD dwThreadIndex, DWORD dwNewMaxSize )
	{
		if( dwNewMaxSize > m_pdwMaxCanHear[dwThreadIndex] )
		{
			m_pdwMaxCanHear[dwThreadIndex] = dwNewMaxSize+DPV_TARGETBUFFER_REALLOC_SIZE;

			if( m_pppCanHear[dwThreadIndex] )
			{
				delete [] (m_pppCanHear[dwThreadIndex]);
			}

			m_pppCanHear[dwThreadIndex] = new CDVCSPlayer*[m_pdwMaxCanHear[dwThreadIndex]];

			if( m_pppCanHear[dwThreadIndex] == NULL )
			{
				return DVERR_OUTOFMEMORY;
			}

		}

		return DV_OK;
	};


	#undef DPF_MODNAME
	#define DPF_MODNAME "CDVCSPlayer::CreateOutBoundConverter"
	inline HRESULT CreateOutBoundConverter( PWAVEFORMATEX pwfxSourceFormat, const GUID &guidCT  )
	{
		HRESULT hr;

		hr = DVCDB_CreateConverter( pwfxSourceFormat, guidCT, &m_lpOutBoundAudioConverter );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  0, "Error creating audio converter hr=0x%x" , hr );
			return hr;
		}

		return hr;
	}

	inline BOOL IsOutBoundConverterInitialized()
	{
		return (m_lpOutBoundAudioConverter != NULL);
	}

	BOOL ComparePlayerMix( DWORD dwThreadIndex, CDVCSPlayer *lpdvPlayer );

	void ResetForNextRun( DWORD dwThreadIndex, BOOL fDequeue );
	void CompleteRun( DWORD dwThreadIndex );

    inline void AddToMixingList( DWORD dwThreadIndex, BILINK *pblBilink )
    {
        InsertAfter( &m_pblMixingActivePlayers[dwThreadIndex], pblBilink );
    }

    inline void RemoveFromMixingList(DWORD dwThreadIndex)
    {
        Delete( &m_pblMixingActivePlayers[dwThreadIndex] );
    }

    inline void AddToSpeakingList( DWORD dwThreadIndex, BILINK *pblBilink )
    {
        InsertAfter( &m_pblMixingSpeakingPlayers[dwThreadIndex], pblBilink );
    }

    inline void RemoveFromSpeakingList(DWORD dwThreadIndex)
    {
        Delete( &m_pblMixingSpeakingPlayers[dwThreadIndex] );
    }


    inline void AddToHearingList( DWORD dwThreadIndex, BILINK *pblBilink )
    {
        InsertAfter( &m_pblMixingHearingPlayers[dwThreadIndex], pblBilink );
    }

    inline void RemoveFromHearingList(DWORD dwThreadIndex)
    {
        Delete( &m_pblMixingHearingPlayers[dwThreadIndex] );
    }
	

public: // These variables are shared between mixing threads
	PDPVCOMPRESSOR		m_lpOutBoundAudioConverter;	

	BOOL				m_bLastSent;			// Was last frame sent to this user?
	BYTE				m_bMsgNum;				// Last msg # transmitted
	BYTE				m_bSeqNum;				// Last Sequence # transmitted
    DWORD				m_targetSize;			// Tmp to hold size of compressed data (bytes)	

	BOOL				m_lost;	// the queue detected that this frame was lost
	DWORD				m_dwNumMixingThreads;

public: // These variables are on a per/mixing thread basis

	CDVCSPlayer			**m_pReuseMixFromThisPlayer;
	BYTE				*m_pbMsgNumToSend;				// Last msg # transmitted
	BYTE				*m_pbSeqNumToSend;				// Last Sequence # transmitted
	BILINK				*m_pblMixingActivePlayers;	// Bilink of active players (per mixing thread)
	BILINK				*m_pblMixingSpeakingPlayers;	// Bilink of players speaking (per mixing thread)
	BILINK				*m_pblMixingHearingPlayers;		// Bilink of players hearing (per mixing thread)
    DWORD				*m_pdwHearCount;				// How many people can this user hear? (per mixing thread)
    BOOL				*m_pfDecompressed;			// Has the user's frame been decompressed (per mixing thread)
	BOOL				*m_pfSilence;				// Is the latest from from user silence? (per mixing thread)
	BOOL				*m_pfNeedsDecompression;	// Does this player need decompression (per mixing thread)
    CDVCSPlayer			***m_pppCanHear;			// Array of pointers to player records this player can hear (per mixing thread)
    DWORD				*m_pdwMaxCanHear;			// # of elements in the m_dwCanHead array (per mixing thread)
    CFrame				**m_pSourceFrame;			// Source frame (per mixing thread)
    BYTE				*m_sourceUnCompressed;		// Buffer to hold decompressed data (per mixing thread)
    BYTE				*m_targetCompressed;		// Has user's mix been created yet? (per mixing thread)
    BOOL				*m_pfMixed;					// Has the user's output been readied? (per mixing thread)
    DWORD				*m_pdwUnCompressedBufferOffset;
    												// Offset into uncompressed buffer for thread (per mixing thread)
    DWORD				*m_pdwCompressedBufferOffset;
    												// Offset into compressed buffer for thread (per mixing thread)
    DWORD				*m_pdwResultLength; 		// Size of compressed data (in bytes) (per mixing thread)
    BOOL				*m_pfMixToBeReused;			// Will this player's mix be re-used by another player (per mixing thread)

    CLockedFixedPool<CDVCSPlayer> *m_pCSOwner;
};

typedef CDVCSPlayer *LPDVCSPLAYER;

#undef DPF_MODNAME

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvcsplay.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvcsplay.cpp
 *  Content:    Implementation of CDVCSPlayer class
 *  History:
 *	Date   By  Reason
 *	============
 *	07/22/99	rodtoll		created
 *  10/05/99	rodtoll		Added comments, dpf's.
 *  10/29/99	rodtoll		Bug #113726 - Integrate Voxware Codecs, updating to use new
 *							pluggable codec architecture.   
 *  01/14/2000	rodtoll		Updated to support multiple targets 
 *  03/28/2000  rodtoll     Updated to use new player class as base
 *              rodtoll     Moved a bunch of logic out of server into this class 
 *  11/16/2000	rodtoll	Bug #40587 - DPVOICE: Mixing server needs to use multi-processors  
 ***************************************************************************/

#include "dxvoicepch.h"


#define IsEmpty(x)   (x.next == x.prev && x.next == &x)

#define CONVERTTORECORD(x,y,z)		((y *)(x->pvObject))->z

#undef DPF_MODNAME
#define DPF_MODNAME "CDVCSPlayer::CDVCSPlayer"
CDVCSPlayer::CDVCSPlayer( 
	):		m_lpOutBoundAudioConverter(NULL),
			m_bLastSent(NULL),
			m_bMsgNum((BYTE)-1),
			m_bSeqNum(0),
			m_targetSize(0),
			m_pblMixingActivePlayers(NULL),
			m_pblMixingSpeakingPlayers(NULL),
			m_pblMixingHearingPlayers(NULL),
			m_pdwHearCount(NULL),
			m_pfDecompressed(NULL),
			m_pfSilence(NULL),
			m_pfNeedsDecompression(NULL),
			m_pppCanHear(NULL),
			m_pdwMaxCanHear(NULL),
			m_pSourceFrame(NULL),
			m_sourceUnCompressed(NULL),
			m_targetCompressed(NULL),
			m_pfMixed(NULL),
			m_dwNumMixingThreads(0),
			m_pbMsgNumToSend(NULL),
			m_pbSeqNumToSend(NULL),
			m_pdwResultLength(NULL),
			m_pfMixToBeReused(NULL)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDVCSPlayer::~CDVCSPlayer"
CDVCSPlayer::~CDVCSPlayer()
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDVCSPlayer::ComparePlayerMix"
//
// ComparePlayerMix
//
// Compares the mix of one player to the mix of another.
//
BOOL CDVCSPlayer::ComparePlayerMix( DWORD dwThreadIndex, CDVCSPlayer *lpdvPlayer )
{
	DNASSERT( lpdvPlayer != NULL );

    if( lpdvPlayer->m_pdwHearCount[dwThreadIndex] != m_pdwHearCount[dwThreadIndex] )
    {
        return FALSE;
    }

    for( int index = 0; index < m_pdwHearCount[dwThreadIndex]; index++ )
    {
        if( lpdvPlayer->m_pppCanHear[dwThreadIndex][index] != m_pppCanHear[dwThreadIndex][index] )
        {
            return FALSE;
        }
    }

	return TRUE;
}

void CDVCSPlayer::CompleteRun( DWORD dwThreadIndex )
{
	if( m_pSourceFrame[dwThreadIndex] )
	{
		m_pSourceFrame[dwThreadIndex]->Return();
		m_pSourceFrame[dwThreadIndex] = NULL;
	}
}

void CDVCSPlayer::ResetForNextRun( DWORD dwThreadIndex, BOOL fDequeue )
{
	BOOL fLostFrame;
	m_pdwHearCount[dwThreadIndex] = 0;
	m_pfSilence[dwThreadIndex] = FALSE;
	m_pReuseMixFromThisPlayer[dwThreadIndex] = NULL;

	if( !fDequeue )
	{
		m_pSourceFrame[dwThreadIndex] = NULL;		
	}
	else
	{
		DNASSERT( !m_pSourceFrame[dwThreadIndex] );
		m_pSourceFrame[dwThreadIndex] = Dequeue(&fLostFrame, &m_pfSilence[dwThreadIndex]);			
	}
	
	m_pfMixed[dwThreadIndex] = FALSE;
	m_pfNeedsDecompression[dwThreadIndex] = FALSE;
	m_pfDecompressed[dwThreadIndex] = FALSE;
	m_pfMixToBeReused[dwThreadIndex] = FALSE;
	m_pdwResultLength[dwThreadIndex] = NULL;
	
}

HRESULT CDVCSPlayer::Initialize( const DVID dvidPlayer, const DWORD dwHostOrder, DWORD dwFlags, PVOID pvContext, 
								 DWORD dwCompressedSize, DWORD dwUnCompressedSize, 
                                  CLockedFixedPool<CDVCSPlayer> *pCSOwner,
                                  DWORD dwNumMixingThreads )
{
	HRESULT hr;
	DWORD dwIndex;

    m_pCSOwner = pCSOwner;

	hr = CVoicePlayer::Initialize( dvidPlayer, dwHostOrder, dwFlags, pvContext, NULL );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Initialize failed on player hr=0x%x", hr );
		return hr;
	}

	m_pdwHearCount = new DWORD[dwNumMixingThreads];
	m_pfSilence = new BOOL[dwNumMixingThreads];
	m_pdwMaxCanHear = new DWORD[dwNumMixingThreads];
	m_pSourceFrame = new CFrame*[dwNumMixingThreads];
	m_pfMixed = new BOOL[dwNumMixingThreads];

	m_pblMixingActivePlayers = new BILINK[dwNumMixingThreads];
	m_pblMixingHearingPlayers = new BILINK[dwNumMixingThreads];
	m_pblMixingSpeakingPlayers = new BILINK[dwNumMixingThreads];
	
	m_sourceUnCompressed = new BYTE[dwNumMixingThreads*dwUnCompressedSize];
	m_targetCompressed = new BYTE[dwNumMixingThreads*dwCompressedSize];
	m_pfNeedsDecompression = new BOOL[dwNumMixingThreads];	
	m_pfDecompressed = new BOOL[dwNumMixingThreads];
	m_dwNumMixingThreads = dwNumMixingThreads;
	m_pbMsgNumToSend = new BYTE[dwNumMixingThreads];
	m_pbSeqNumToSend = new BYTE[dwNumMixingThreads];
	m_pdwUnCompressedBufferOffset = new DWORD[dwNumMixingThreads];
	m_pdwCompressedBufferOffset = new DWORD[dwNumMixingThreads];
	m_pReuseMixFromThisPlayer = new CDVCSPlayer*[dwNumMixingThreads];
	m_pdwResultLength = new DWORD[dwNumMixingThreads];
	m_pfMixToBeReused = new BOOL[dwNumMixingThreads];

	if( !m_pblMixingActivePlayers || !m_pdwHearCount || !m_pfSilence ||
		!m_pdwMaxCanHear || !m_pSourceFrame || !m_sourceUnCompressed ||
		!m_targetCompressed || !m_pfMixed || !m_pfNeedsDecompression ||
		!m_pfDecompressed || !m_pbMsgNumToSend || !m_pbSeqNumToSend ||
		!m_pdwUnCompressedBufferOffset || !m_pdwCompressedBufferOffset ||
		!m_pReuseMixFromThisPlayer || !m_pdwResultLength || !m_pfMixToBeReused ||
		!m_pblMixingHearingPlayers || !m_pblMixingSpeakingPlayers )
	{
		DPFX(DPFPREP,  0, "Memory alloc failure" );
		hr = DVERR_OUTOFMEMORY;
		goto INITIALIZE_FAILURE;		
	}

	// Create the Can Hear arrays
	m_pppCanHear = new CDVCSPlayer**[dwNumMixingThreads];
	ZeroMemory( m_pppCanHear, sizeof(CDVCSPlayer*)*dwNumMixingThreads );

	// Resize canhear arrays and setup compressed/uncompressed offsets
	for( dwIndex = 0; dwIndex < dwNumMixingThreads; dwIndex++ )
	{
		m_pdwUnCompressedBufferOffset[dwIndex] = dwIndex * dwUnCompressedSize;
		m_pdwCompressedBufferOffset[dwIndex] = dwIndex * dwCompressedSize;	

		m_pSourceFrame[dwIndex] = 0;
		m_pdwMaxCanHear[dwIndex] = 0;

		InitBilink( &m_pblMixingActivePlayers[dwIndex], this );
		InitBilink( &m_pblMixingSpeakingPlayers[dwIndex], this );
		InitBilink( &m_pblMixingHearingPlayers[dwIndex], this );		
	
		ResetForNextRun(dwIndex,FALSE);
		
		hr = ResizeIfRequired(dwIndex,1);
		
		if( FAILED( hr ) )		
		{
			DPFX(DPFPREP,  0, "Error resizing target array hr=0x%x", hr );
			goto INITIALIZE_FAILURE;
		}
	}

    return hr;

INITIALIZE_FAILURE:

	DeInitialize();

	return hr;
    
}

HRESULT CDVCSPlayer::DeInitialize()
{
	DWORD dwIndex;
	
	if( m_pblMixingActivePlayers )
	{
#ifdef DEBUG
		for( dwIndex = 0; dwIndex < m_dwNumMixingThreads; dwIndex++ )
		{
			DNASSERT( (IsEmpty( m_pblMixingActivePlayers[dwIndex] )) );
			DNASSERT( !m_pSourceFrame[dwIndex] );
		}
#endif

		delete [] m_pblMixingActivePlayers;
		m_pblMixingActivePlayers = NULL;
	}

	if( m_pblMixingSpeakingPlayers )
	{
		delete [] m_pblMixingSpeakingPlayers;
		m_pblMixingSpeakingPlayers = NULL;		
	}

	if( m_pblMixingHearingPlayers )
	{
		delete [] m_pblMixingHearingPlayers;
		m_pblMixingHearingPlayers = NULL;		
	}	

	if( m_lpOutBoundAudioConverter )
	{
		m_lpOutBoundAudioConverter->Release();
		m_lpOutBoundAudioConverter = NULL;
	}

	if( m_pppCanHear )
	{
		for( dwIndex = 0; dwIndex < m_dwNumMixingThreads; dwIndex++ )
		{
			if( m_pppCanHear[dwIndex] )
			{
				delete [] m_pppCanHear[dwIndex];
				m_pppCanHear[dwIndex] = NULL;
			}
		}
		
		delete [] m_pppCanHear;
		m_pppCanHear = NULL;
	}

	if( m_pdwHearCount )
	{
		delete [] m_pdwHearCount;
		m_pdwHearCount = NULL;
	}

	if( m_pdwResultLength )
	{
		delete [] m_pdwResultLength;
		m_pdwResultLength = NULL;
	}

	if( m_pfSilence )
	{
		delete [] m_pfSilence;
		m_pfSilence = NULL;
	}

	if( m_pdwUnCompressedBufferOffset )
	{
		delete [] m_pdwUnCompressedBufferOffset;
		m_pdwUnCompressedBufferOffset = NULL;
	}

	if( m_pReuseMixFromThisPlayer )
	{
		delete [] m_pReuseMixFromThisPlayer;
		m_pReuseMixFromThisPlayer = NULL;
	}

	if( m_pdwCompressedBufferOffset )
	{
		delete [] m_pdwCompressedBufferOffset;
		m_pdwCompressedBufferOffset = NULL;
	}

	if( m_pdwMaxCanHear )
	{
		delete [] m_pdwMaxCanHear;
		m_pdwMaxCanHear = NULL;
	}

	if( m_sourceUnCompressed )
	{
		delete [] m_sourceUnCompressed;
		m_sourceUnCompressed = NULL;
	}

	if( m_pfMixToBeReused )
	{
		delete [] m_pfMixToBeReused;
		m_pfMixToBeReused = NULL;
	}

	if( m_pbMsgNumToSend )
	{
		delete [] m_pbMsgNumToSend;
		m_pbMsgNumToSend = NULL;
	}

	if( m_pbSeqNumToSend )
	{
		delete [] m_pbSeqNumToSend;
		m_pbSeqNumToSend = NULL;
	}

	if( m_targetCompressed )
	{
		delete [] m_targetCompressed;
		m_targetCompressed = NULL;
	}	

	if( m_pfMixed )
	{
		delete [] m_pfMixed;
		m_pfMixed = NULL;
	}	

	if( m_pfNeedsDecompression )
	{
		delete [] m_pfNeedsDecompression;
		m_pfNeedsDecompression = NULL;
	}	

	if( m_pfDecompressed )
	{
		delete [] m_pfDecompressed;
		m_pfDecompressed = NULL;
	}
	
	if( m_pSourceFrame )
	{
		delete [] m_pSourceFrame;
		m_pSourceFrame = NULL;
	}
	
	FreeResources();

    m_pCSOwner->Release( this );

    return DV_OK;
}

HRESULT CDVCSPlayer::HandleMixingReceive( 
						PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, 
						DWORD dwSize, PDVID pdvidTargets, DWORD dwNumTargets )
{
	CFrame tmpFrame;

	tmpFrame.SetSeqNum( pdvSpeechHeader->bSeqNum );
	tmpFrame.SetMsgNum( pdvSpeechHeader->bMsgNum );
	tmpFrame.SetIsSilence( FALSE );
	tmpFrame.SetFrameLength( dwSize );
	tmpFrame.UserOwn_SetData( pbData, dwSize );
	tmpFrame.UserOwn_SetTargets( pdvidTargets, dwNumTargets );

    Lock();

	// STATSBLOCK: Begin
	//m_pStatsBlob->m_dwPRESpeech++;
	// STATSBLOCK: End
		
	m_lpInputQueue->Enqueue( tmpFrame );
	m_dwLastData = GetTickCount();

	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "Received speech is buffered!" );

    m_dwNumReceivedFrames++;

    UnLock();

    return DV_OK;

}

HRESULT CDVCSPlayer::CompressOutBound( PVOID pvInputBuffer, DWORD dwInputBufferSize, PVOID pvOutputBuffer, DWORD *pdwOutputSize )
{
	HRESULT hr;

    hr = m_lpOutBoundAudioConverter->Convert( pvInputBuffer, dwInputBufferSize, pvOutputBuffer, pdwOutputSize, FALSE );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed converting audio hr=0x%x", hr );
        return hr;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvclient.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvclient.h
 *  Content:	Defines functions for the DirectXVoiceClient interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	02/07/99	rodtoll	Created It
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added new parameters to GetCompressionTypes
 *  09/03/99	rodtoll	Updated parameters for DeleteUserBuffer
 *  09/14/99	rodtoll	Added DVC_SetNotifyMask 
 *  12/16/99	rodtoll	Bug #117405 - 3D Sound APIs misleading - 3d sound apis renamed
 *						The Delete3DSoundBuffer was re-worked to match the create
 *  01/14/2000	rodtoll	Updated parameters to Get/SetTransmitTargets
 *				rodtoll	Added new API call GetSoundDeviceConfig
 *  01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC  
 *  06/21/2000	rodtoll	Bug #35767 - Update Create3DSoundBuffer to take DIRECTSOUNDBUFFERs
 *
 ***************************************************************************/

#ifndef __DVCLIENT__
#define __DVCLIENT__

class CDirectVoiceClientEngine;

volatile struct DIRECTVOICECLIENTOBJECT : public DIRECTVOICEOBJECT
{
	CDirectVoiceClientEngine	*lpDVClientEngine;
};

typedef DIRECTVOICECLIENTOBJECT *LPDIRECTVOICECLIENTOBJECT;

#ifdef __cplusplus
extern "C" {
#endif

STDAPI DVC_Release(LPDIRECTVOICECLIENTOBJECT lpDV );
STDAPI DVC_QueryInterface( LPDIRECTVOICECLIENTOBJECT lpDVC, REFIID riid, LPVOID * ppvObj );
STDAPI DVC_Connect(LPDIRECTVOICECLIENTOBJECT, LPDVSOUNDDEVICECONFIG, LPDVCLIENTCONFIG, DWORD );
STDAPI DVC_Disconnect(LPDIRECTVOICECLIENTOBJECT, DWORD );
STDAPI DVC_GetSessionDesc(LPDIRECTVOICECLIENTOBJECT, LPDVSESSIONDESC );
STDAPI DVC_GetClientConfig(LPDIRECTVOICECLIENTOBJECT, LPDVCLIENTCONFIG );
STDAPI DVC_SetClientConfig(LPDIRECTVOICECLIENTOBJECT, LPDVCLIENTCONFIG );
STDAPI DVC_GetCaps(LPDIRECTVOICECLIENTOBJECT, LPDVCAPS );
STDAPI DVC_GetCompressionTypes( LPDIRECTVOICECLIENTOBJECT, LPVOID, LPDWORD, LPDWORD, DWORD );
STDAPI DVC_SetTransmitTarget( LPDIRECTVOICECLIENTOBJECT, PDVID, DWORD, DWORD );
STDAPI DVC_GetTransmitTarget( LPDIRECTVOICECLIENTOBJECT, LPDVID, PDWORD, DWORD );
STDAPI DVC_Create3DSoundBuffer( LPDIRECTVOICECLIENTOBJECT, DVID, LPDIRECTSOUNDBUFFER, DWORD, DWORD, LPDIRECTSOUND3DBUFFER * );
STDAPI DVC_Delete3DSoundBuffer( LPDIRECTVOICECLIENTOBJECT, DVID, LPDIRECTSOUND3DBUFFER * );
STDAPI DVC_SetNotifyMask( LPDIRECTVOICECLIENTOBJECT, LPDWORD, DWORD );
STDAPI DVC_GetSoundDeviceConfig( LPDIRECTVOICECLIENTOBJECT, PDVSOUNDDEVICECONFIG, PDWORD );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvclient.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvclient.c
 *  Content:	Implements functions for the DirectXVoiceClient interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/02/99	rodtoll	Created It
 *  07/26/99	rodtoll	Updated QueryInterface to support IDirectXVoiceNotify
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added new parameter to GetCompressionTypes
 *  09/03/99	rodtoll	Updated parameters for DeleteUserBuffer
 *  09/07/99	rodtoll	Updated EnumCompressionTypes so that object doesn't
 *						need to be Initialized.
 *  09/10/99	rodtoll	Object validity checking
 *  09/14/99	rodtoll	Added DVC_SetNotifyMask  
 *  10/05/99	rodtoll	Reversed destruction order to destroy object before
 *						transport.  Fixes crash in some situations
 *  10/18/99	rodtoll	Fix: Passing NULL in QueryInterface casues crash
 *				rodtoll	Fix: Calling Initialize twice passes
 *  10/19/99	rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if disconnect should be called from release
 *  10/25/99	rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 *  11/17/99	rodtoll	Fix: Bug #117447 - Removed checks for initialization because
 *						DirectVoiceCLientEngine members already do this.
 *  12/16/99	rodtoll	Bug #117405 - 3D Sound APIs misleading - 3d sound apis renamed
 *						The Delete3DSoundBuffer was re-worked to match the create
 *  01/14/2000	rodtoll	Updated parameters to Get/SetTransmitTargets
 *				rodtoll	Added new API call GetSoundDeviceConfig 
 *  01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC  
 *  03/28/2000  rodtoll   Removed reference to removed header file.
 *  06/21/2000	rodtoll	Bug #35767 - Update Create3DSoundBuffer to take DIRECTSOUNDBUFFERs
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Release"
STDAPI DVC_Release(LPDIRECTVOICECLIENTOBJECT lpDV )
{
    HRESULT hr=S_OK;
    LONG rc;

	if( !DV_ValidDirectXVoiceClientObject( lpDV ) )
		return DVERR_INVALIDOBJECT;

	DNEnterCriticalSection( &lpDV->csCountLock );
	
	if (lpDV->lIntRefCnt == 0)
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );
		return 0;
	}

	// dec the interface count
	lpDV->lIntRefCnt--;

	// Special case: Releasing object without stopping session
	// May be more then one transport thread indicating in us 
	if( (lpDV->lIntRefCnt == 0) && lpDV->lpDVClientEngine->GetCurrentState() != DVCSTATE_IDLE  )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Releasing interface without calling Disconnect" );

		lpDV->lIntRefCnt = 0;

		// We must release the lock because stopsession may call back into this function
		DNLeaveCriticalSection( &lpDV->csCountLock );		

		hr = lpDV->lpDVClientEngine->Disconnect( DVFLAGS_SYNC );

		DNEnterCriticalSection( &lpDV->csCountLock );			

		if( hr != DV_OK && hr != DVERR_SESSIONLOST )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Disconnect Failed hr=0x%x", hr );
		}

	}

	rc = lpDV->lIntRefCnt;

	if ( lpDV->lIntRefCnt == 0 )
	{
		// Leave the critical section, we may call back into this func.
		// (Shouldn't though).
		DNLeaveCriticalSection( &lpDV->csCountLock );

		delete lpDV->lpDVClientEngine;
		lpDV->lpDVClientEngine = NULL;

		if( lpDV->lpDVTransport != 0 )
		{
			DNASSERT( lpDV->lpDVTransport->m_lRefCount == 0 );		
			delete lpDV->lpDVTransport;
			lpDV->lpDVTransport = NULL;
		}

		DNDeleteCriticalSection( &lpDV->csCountLock );		

		DNFree(lpDV);

		DecrementObjectCount();
	} 
	else
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );
	}
   	
    return rc;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVC_QueryInterface"
STDMETHODIMP DVC_QueryInterface(LPDIRECTVOICECLIENTOBJECT lpDVC, REFIID riid, LPVOID * ppvObj) 
{
    HRESULT hr = S_OK;

	if( ppvObj == NULL ||
	    !DNVALID_WRITEPTR( ppvObj, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for object" );
		return DVERR_INVALIDPOINTER;
	}	
    
     *ppvObj=NULL;

	if( !DV_ValidDirectXVoiceClientObject( lpDVC ) )
	{
		return DVERR_INVALIDOBJECT;
	}

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IDirectPlayVoiceClient ) )
    {
		*ppvObj = lpDVC;
		DV_AddRef(lpDVC);
    }
	else if( IsEqualIID(riid, IID_IDirectPlayVoiceNotify ) )
	{
		*ppvObj = &lpDVC->dvNotify;
		DV_Notify_AddRef(&lpDVC->dvNotify);
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    return hr;

}//DVC_QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Connect"
STDMETHODIMP DVC_Connect(LPDIRECTVOICECLIENTOBJECT This, LPDVSOUNDDEVICECONFIG lpSoundDeviceConfig, LPDVCLIENTCONFIG lpClientConfig, DWORD dwFlags )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}

	return This->lpDVClientEngine->Connect( lpSoundDeviceConfig, lpClientConfig, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Disconnect"
STDMETHODIMP DVC_Disconnect(LPDIRECTVOICECLIENTOBJECT This, DWORD dwFlags)
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}

	return This->lpDVClientEngine->Disconnect( dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_GetSessionDesc"
STDMETHODIMP DVC_GetSessionDesc(LPDIRECTVOICECLIENTOBJECT This, LPDVSESSIONDESC lpSessionDesc )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	

	return This->lpDVClientEngine->GetSessionDesc( lpSessionDesc );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_GetSoundDeviceConfig"
STDAPI DVC_GetSoundDeviceConfig( LPDIRECTVOICECLIENTOBJECT This, PDVSOUNDDEVICECONFIG pSoundDeviceConfig, PDWORD pdwBufferSize )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	

	return This->lpDVClientEngine->GetSoundDeviceConfig( pSoundDeviceConfig, pdwBufferSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_GetClientConfig"
STDMETHODIMP DVC_GetClientConfig(LPDIRECTVOICECLIENTOBJECT This, LPDVCLIENTCONFIG lpClientConfig )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	

	return This->lpDVClientEngine->GetClientConfig( lpClientConfig );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_SetClientConfig"
STDMETHODIMP DVC_SetClientConfig(LPDIRECTVOICECLIENTOBJECT This, LPDVCLIENTCONFIG lpClientConfig )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	

	return This->lpDVClientEngine->SetClientConfig( lpClientConfig );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_GetCaps"
STDMETHODIMP DVC_GetCaps(LPDIRECTVOICECLIENTOBJECT This, LPDVCAPS lpdvCaps )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	

	return This->lpDVClientEngine->GetCaps( lpdvCaps );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_GetCompressionTypes"
STDMETHODIMP DVC_GetCompressionTypes( LPDIRECTVOICECLIENTOBJECT This, LPVOID lpDataBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags)
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	

	return This->lpDVClientEngine->GetCompressionTypes( lpDataBuffer, lpdwSize, lpdwNumElements, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_SetTransmitTarget"
STDMETHODIMP DVC_SetTransmitTarget( LPDIRECTVOICECLIENTOBJECT This, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	
	return This->lpDVClientEngine->SetTransmitTarget( pdvidTargets, dwNumTargets, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_GetTransmitTarget"
STDMETHODIMP DVC_GetTransmitTarget( LPDIRECTVOICECLIENTOBJECT This, LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}
	
	return This->lpDVClientEngine->GetTransmitTarget( lpdvidTargets, pdwNumElements, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Create3DSoundBuffer"
STDMETHODIMP DVC_Create3DSoundBuffer( LPDIRECTVOICECLIENTOBJECT This, DVID dvidEntity, LPDIRECTSOUNDBUFFER lpdsBuffer, DWORD dwPriority, DWORD dwFlags, LPDIRECTSOUND3DBUFFER *lpSoundBuffer )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}

	return This->lpDVClientEngine->Create3DSoundBuffer( dvidEntity, lpdsBuffer, dwPriority, dwFlags, lpSoundBuffer );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Delete3DSoundBuffer"
STDMETHODIMP DVC_Delete3DSoundBuffer( LPDIRECTVOICECLIENTOBJECT This, DVID dvidBuffer, LPDIRECTSOUND3DBUFFER *lpSoundBuffer )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
	{
		return DVERR_INVALIDOBJECT;
	}

	return This->lpDVClientEngine->Delete3DSoundBuffer( dvidBuffer, lpSoundBuffer );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVC_SetNotifyMask"
STDMETHODIMP DVC_SetNotifyMask( LPDIRECTVOICECLIENTOBJECT This, LPDWORD lpdwMessages, DWORD dwNumElements )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceClientObject( This ) )
		return DVERR_INVALIDOBJECT;

	return This->lpDVClientEngine->SetNotifyMask( lpdwMessages, dwNumElements );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvdxtran.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvdxtran.cpp
 *  Content:	Implementation of transport class providing DirectXVoice transport
 *              through the IDirectXVoiceTransport interface.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/23/99		rodtoll	Modified from dvdptran.cpp
 * 08/03/99		rodtoll	Modified to conform to new base class and minor fixes
 *						for dplay integration. 
 * 08/04/99		rodtoll	Modified to allow group targets
 * 08/10/99		rodtoll	Removed TODO pragmas
 * 08/25/99		rodtoll	Fixed group membership check
 * 08/30/99		rodtoll	Modified SendToServer to send to the server player in 
 *						client/server sessions.
 * 08/31/99		rodtoll	Updated to use new debug libs
 * 09/01/99		rodtoll	Updated so that constructor no longer calls into dplay
 * 				rodtoll	Added check for valid pointers in func calls  
 * 09/02/99		rodtoll	Added checks to handle case no local player created 
 * 09/20/99		rodtoll	Added memory alloc failure checks 
 * 09/21/99		rodtoll	Fixed memory leak
 * 10/05/99		rodtoll	Additional comments and DPF_MODNAMEs
 * 11/23/99		rodtoll	Split CheckForValid into Group and Player
 * 12/16/99		rodtoll Bug #122629 - As part of new host migration update how
 *						sends to server before first response are sent.
 * 01/14/2000	rodtoll	Renamed SendToID to SendToIDS and updated parameter list
 *						to accept multiple targets.
 *				rodtoll	Added GetNumPlayers call
 * 01/17/2000	rodtoll	Debug statement removed that limited max players to 30
 * 03/28/2000   rodtoll Moved nametable from here to upper level classes
 *              rodtoll Removed uneeded functions/members 
 * 04/07/2000   rodtoll Updated to support new DP <--> DPV interface
 *              rodtoll Updated to support no copy sends
 *              rodtoll Bug #32179 - Prevent multiple client/server registrations on transport 
 * 06/21/2000	rodtoll Bug #36820 - Host migrates to wrong client when client/server are on same interface
 *						Condition exists where host sends leave message, client attempts to start new host
 *						which fails because old host still registered.  Now deregistering is two step
 *						process DisableReceiveHook then DestroyTransport.  
 * 07/22/20000	rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  Now ensures that all threads from transport have left and that
 *					  all notificatinos have been processed before shutdown is complete.  
 *  01/04/2001	rodtoll	WinBug #94200 - Remove stray comments
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets 
 *						
 ***************************************************************************/

#include "dxvoicepch.h"


#define DVF_SEND_DEBUG_LEVEL		DVF_INFOLEVEL

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::CDirectVoiceDirectXTransport"
CDirectVoiceDirectXTransport::CDirectVoiceDirectXTransport( LPDIRECTPLAYVOICETRANSPORT lpTransport
	):  m_lpTransport(NULL),
		m_dpidServer(DPID_ALLPLAYERS),
		m_dpidLocalPlayer(0),
		m_bLocalServer(TRUE),
		m_bActiveSession(TRUE),
		m_dwTransportFlags(0),
		m_lpVoiceEngine(NULL),
		m_dwMaxPlayers(0),
		m_initialized(FALSE),
		m_dwObjectType(0),
		m_fAdvised(FALSE)
{
	lpTransport->QueryInterface( IID_IDirectPlayVoiceTransport, (void **) &m_lpTransport );

	m_dvTransportInfo.dwSize = sizeof( DVTRANSPORTINFO );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::~CDirectVoiceDirectXTransport"
CDirectVoiceDirectXTransport::~CDirectVoiceDirectXTransport()
{
	if( m_lpTransport != NULL )
		m_lpTransport->Release();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DestroyTransport"
// DestroyTransport
//
// This method is used to remove last references to transport that transport 
// layer has.  There was a memory leak where 
//
// 
void CDirectVoiceDirectXTransport::DestroyTransport()
{
	if( m_lpTransport != NULL )
	{
		m_lpTransport->Release();
		m_lpTransport = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::Initialize"
//
// Initialize
//
// Called from the transport when Advise is called.
//
// Used to initialize this object.
//
HRESULT CDirectVoiceDirectXTransport::Initialize(  )
{
	HRESULT hr;

	hr = m_lpTransport->GetSessionInfo( &m_dvTransportInfo );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "DXVT::Initialize: GetSessionInfo() failed!  hr=0x%x", hr );
		return hr;
	}

	m_dwMaxPlayers = (m_dvTransportInfo.dwMaxPlayers==0) ? 255 : m_dvTransportInfo.dwMaxPlayers;


	m_dpidLocalPlayer = m_dvTransportInfo.dvidLocalID;

//  No longer needed, the server may not bee the host of the dplay session
//	m_dpidServer = m_dvTransportInfo.dvidSessionHost;
	m_dpidServer = DPID_ALLPLAYERS;

	m_initialized = TRUE;
	
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::GetMaxPlayers"
DWORD CDirectVoiceDirectXTransport::GetMaxPlayers( )
{
	return m_dwMaxPlayers;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendHelper"
HRESULT CDirectVoiceDirectXTransport::SendHelper( UNALIGNED DVID * pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	HRESULT hr;

	if( dwNumTargets > 1 )
	{
		DEBUG_ONLY( for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ ) { )
			DPFX(DPFPREP,  DVF_SEND_DEBUG_LEVEL, "Using multitargetted send [From=0x%x To=0x%x]", m_dpidLocalPlayer, pdvidTargets[dwIndex] );	
		DEBUG_ONLY( } )

		hr = m_lpTransport->SendSpeechEx( m_dpidLocalPlayer, dwNumTargets, pdvidTargets, pBufferDesc, pvContext, dwFlags );		
	}
	else
	{

		DPFX(DPFPREP,  DVF_SEND_DEBUG_LEVEL, "Single target for send [From=0x%x To=0x%x]", m_dpidLocalPlayer, pdvidTargets[0] );
		hr = m_lpTransport->SendSpeech( m_dpidLocalPlayer, *pdvidTargets, pBufferDesc, pvContext, dwFlags );
	}

/*
	DNASSERT( pdpidTargets != NULL );

	for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
	{
		hr = m_lpTransport->SendSpeech( m_dpidLocalPlayer, pdpidTargets[dwIndex], lpBuffer, dwSize, dwFlags );
	} */

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendToServer"
HRESULT CDirectVoiceDirectXTransport::SendToServer( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	if( m_dvTransportInfo.dwSessionType == DVTRANSPORT_SESSION_CLIENTSERVER )
	{
		DVID dvidTmp = DVID_SERVERPLAYER;

		DPFX(DPFPREP,  DVF_SEND_DEBUG_LEVEL, "Sending to standard server player" );
	
		return SendHelper( &dvidTmp, 1, pBufferDesc, pvContext, dwFlags );
	}
	else
	{
		DPFX(DPFPREP,  DVF_SEND_DEBUG_LEVEL, "Sending to server ID [ID=0x%x]", m_dpidServer );
		return SendHelper( &m_dpidServer, 1, pBufferDesc, pvContext, dwFlags );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendToIDS"
HRESULT CDirectVoiceDirectXTransport::SendToIDS( UNALIGNED DVID * pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	return SendHelper( pdvidTargets, dwNumTargets, pBufferDesc, pvContext, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::SendToAll"
HRESULT CDirectVoiceDirectXTransport::SendToAll( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags )
{
	DVID dvidTmp = DPID_ALLPLAYERS;
	
	return SendHelper( &dvidTmp, 1, pBufferDesc, pvContext, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmValidGroup"
BOOL CDirectVoiceDirectXTransport::ConfirmValidGroup( DVID dvid )
{
	if( dvid == DVID_ALLPLAYERS )
	{
		return TRUE;
	}
	else if( m_dvTransportInfo.dwSessionType == DVTRANSPORT_SESSION_CLIENTSERVER )
	{
		return TRUE;
	}
	else 
	{
		BOOL fResult;
		HRESULT hr;

		hr = m_lpTransport->IsValidGroup( dvid, &fResult );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error confirming valid group hr=0x%x", hr );
			return FALSE;
		}
		else
		{
			return fResult;
		}
	}	

	return FALSE;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmValidEntity"
//
// ConfirmValidEntity
//
// Checks to ensure that the ID passed is a valid one for the session.
//
// Will return TRUE if the player iD is one of:
// DVID_ALLPLAYERS, DVID_NOTARGET, (any value in client/server mode),
// a player in the map, or a valid Transport group.
//
BOOL CDirectVoiceDirectXTransport::ConfirmValidEntity( DVID dvid )
{
	if( m_dvTransportInfo.dwSessionType == DVTRANSPORT_SESSION_CLIENTSERVER )
	{
		return TRUE;
	}
	else 
	{
		BOOL fResult;
		m_lpTransport->IsValidEntity( dvid, &fResult );
		return fResult;
	}

	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::EnableReceiveHook"
//
// EnableReceiveHook
//
// This is used to activate the connection between the transport
// and the transport class.
//
// We call advise, which will cause Initialize to be called on this
// class before we return from Advise.
//
HRESULT CDirectVoiceDirectXTransport::EnableReceiveHook( LPDIRECTVOICEOBJECT dvObject, DWORD dwObjectType )
{
	HRESULT hr;
	
	m_lpVoiceEngine = dvObject->lpDVEngine;
	m_dwObjectType = dwObjectType;

	// The transport will call Initialize on our notification interface
	// before returning from this function.
	//
	// Once we've returned from this function we should be ok.
	// FYI: This is safe, but using QueryInterface would be more "correct".  However, we would
	//      need to determine if this is a client or a server and call the appropriate QueryInterface.  
	hr = m_lpTransport->Advise( (LPUNKNOWN) dvObject, m_dwObjectType );	

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Advise failed.  hr=0x%x", hr );
		m_fAdvised = FALSE;
	}
	else
	{
		m_fAdvised = TRUE;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DisableReceiveHook"
HRESULT CDirectVoiceDirectXTransport::WaitForDetachCompletion()
{
	DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "# of threads remaining: %d", m_lRefCount );

	// Loop until all threads are done inside our layer
	while( m_lRefCount > 0 )	
		Sleep( 5 );	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DisableReceiveHook"
//
// DisableReceiveHook
//
// Removes the hooks into the transport and releases the interface
// reference this object holds for the transport.
//
// Also responsible for destroying the list of players maintained
// by this object.
//
HRESULT CDirectVoiceDirectXTransport::DisableReceiveHook( )
{
	if( m_fAdvised )
	{
		m_lpTransport->UnAdvise( m_dwObjectType );

		m_fAdvised = FALSE;

		m_initialized = FALSE;		

		DPFX(DPFPREP,  DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL, "Unhooking Transport" );
	}

	// When this is done no more indications will be waiting.  	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmLocalHost"
BOOL CDirectVoiceDirectXTransport::ConfirmLocalHost( )
{
	if( !m_initialized )
		m_lpTransport->GetSessionInfo( &m_dvTransportInfo );
	
	if( m_dvTransportInfo.dwFlags & DVTRANSPORT_LOCALHOST )
		return TRUE;
	else
		return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::ConfirmSessionActive"
BOOL CDirectVoiceDirectXTransport::ConfirmSessionActive( )
{
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::GetTransportSettings"
HRESULT CDirectVoiceDirectXTransport::GetTransportSettings( LPDWORD lpdwSessionType, LPDWORD lpdwFlags )
{
	HRESULT hr = DV_OK;
	
	if( !m_initialized )
		hr = m_lpTransport->GetSessionInfo( &m_dvTransportInfo );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to retrieve transport settings" );
		return hr;
	}

	*lpdwSessionType = m_dvTransportInfo.dwSessionType;
	*lpdwFlags = m_dvTransportInfo.dwFlags;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::AddPlayerEntry"
HRESULT CDirectVoiceDirectXTransport::AddPlayerEntry( DVID dvidPlayer, LPVOID lpData )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DeletePlayerEntry"
HRESULT CDirectVoiceDirectXTransport::DeletePlayerEntry( DVID dvidPlayer )
{
	return DVERR_NOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::GetPlayerEntry"
//
// GetPlayerEntry
//
// Retrieves the player record for the specified player (if it exists).
//
HRESULT CDirectVoiceDirectXTransport::GetPlayerEntry( DVID dvidPlayer,  CVoicePlayer **lplpPlayer )
{
	return DVERR_NOTSUPPORTED;
}


////////////////////////////////////////////////////////////////////////
//
// USEFUL FOR REMOTE VOICE SESSIONS
//

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::CreateGroup"
HRESULT CDirectVoiceDirectXTransport::CreateGroup( LPDVID dvidGroup )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::DeleteGroup"
HRESULT CDirectVoiceDirectXTransport::DeleteGroup( DVID dvidGroup )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::AddPlayerToGroup"
HRESULT CDirectVoiceDirectXTransport::AddPlayerToGroup( LPDVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::RemovePlayerFromGroup"
HRESULT CDirectVoiceDirectXTransport::RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::IsPlayerInGroup"
BOOL CDirectVoiceDirectXTransport::IsPlayerInGroup( DVID dvidGroup, DVID dvidPlayer )
{
	if( dvidGroup == DVID_ALLPLAYERS )
	{
		return TRUE;
	}

	if( dvidGroup == dvidPlayer )
	{
		return TRUE;
	}

	return (m_lpTransport->IsGroupMember( dvidGroup, dvidPlayer )==DV_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::MigrateHost"
//
// MigrateHost
//
// Updates server DPID to match new host
//
HRESULT CDirectVoiceDirectXTransport::MigrateHost( DVID dvidNewHost )
{
	DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: Setting host to 0x%x", dvidNewHost );	
	m_dpidServer = dvidNewHost;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceDirectXTransport::MigrateHost"
DVID CDirectVoiceDirectXTransport::GetLocalID() 
{ 
    m_dwDuumy = m_dpidLocalPlayer;
    return m_dpidLocalPlayer; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvdxtran.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvdxtran.h
 *  Content:	Definition of transport class providing DirectXVoice transport
 *              through the IDirectXVoiceTransport interface.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/23/99		rodtoll	Modified from dvdptran.h
 * 08/03/99		rodtoll	Modified to conform to new base class and minor fixes
 *						for dplay integration.
 * 11/23/99		rodtoll	Split CheckForValid into Group and Player
 * 01/14/2000	rodtoll	Renamed SendToID to SendToIDS and updated parameter list
 *						to accept multiple targets.
 *				rodtoll	Added GetNumPlayers call
 * 03/28/2000   rodtoll Moved nametable from here to upper level classes
 *              rodtoll Removed uneeded functions/members
 * 04/07/2000   rodtoll Updated to support new DP <--> DPV interface
 *              rodtoll Updated to support no copy sends
 *              rodtoll Bug #32179 - Prevent multiple client/server registrations on transport
 * 06/21/2000	rodtoll Bug #36820 - Host migrates to wrong client when client/server are on same interface
 *						Condition exists where host sends leave message, client attempts to start new host
 *						which fails because old host still registered.  Now deregistering is two step
 *						process DisableReceiveHook then DestroyTransport.  
 *						
 ***************************************************************************/
#ifndef __DVDPTRANSPORT_H
#define __DVDPTRANSPORT_H

// CDirectVoiceDirectXTransport
//
// Implements the transport system using the IDirectXVoiceTransport
// interface that will be implemented by both DirectPlay and 
// DirectNet.
//
// This class handles the interaction between an DirectPlayVoice engine
// and the transport level.
// 
volatile class CDirectVoiceDirectXTransport : public CDirectVoiceTransport
{
public:
	CDirectVoiceDirectXTransport( LPDIRECTPLAYVOICETRANSPORT lpTransport );
	~CDirectVoiceDirectXTransport();

	HRESULT Initialize();

public:
	HRESULT AddPlayerEntry( DVID dvidPlayer, LPVOID lpData );
	HRESULT DeletePlayerEntry( DVID dvidPlayer );
	HRESULT GetPlayerEntry( DVID dvidPlayer, CVoicePlayer **lplpPlayer );
	HRESULT MigrateHost( DVID dvidNewHost );	

	DWORD GetMaxPlayers( );

	inline LPDIRECTPLAYVOICETRANSPORT GetTransportInterface( ) { return m_lpTransport; };

    DVID GetLocalID();
	inline DVID GetServerID() { return m_dpidServer; };

public:
	HRESULT SendToServer( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags );
	HRESULT SendToAll( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags );
	HRESULT SendToIDS( UNALIGNED DVID * pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags );

public: // Remote Server Synchronization functions
	HRESULT CreateGroup( LPDVID dvidGroup );
	HRESULT DeleteGroup( DVID dvidGroup );
	HRESULT AddPlayerToGroup( LPDVID dvidGroup, DVID dvidPlayer ); 
	HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer );
	BOOL ConfirmValidEntity( DVID dvid );
	BOOL ConfirmValidGroup( DVID dvid );
	BOOL ConfirmLocalHost( );
	BOOL ConfirmSessionActive();
	BOOL IsPlayerInGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT GetTransportSettings( LPDWORD lpdwSessionType, LPDWORD lpdwFlags );

	HRESULT EnableReceiveHook( LPDIRECTVOICEOBJECT dvObject, DWORD dwObjectType );
	HRESULT DisableReceiveHook(  );
	HRESULT WaitForDetachCompletion( );	
	void DestroyTransport( );

	// Debug / Test Only
	//HRESULT SetInfo( DPID dpidServer, DPID dpidClient );

protected:
	HRESULT SendHelper( UNALIGNED DVID * pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvContext, DWORD dwFlags );

protected:
	LPDIRECTPLAYVOICETRANSPORT m_lpTransport;		// Transport interface 
	DPID m_dpidServer;								// DPID of the session host
	BOOL m_bLocalServer;							// Is the host on same interface as the client
	BOOL m_bActiveSession;							// Is there a session active on the transport
	DWORD m_dwTransportFlags;						// Flags describing the session
	CDirectVoiceEngine *m_lpVoiceEngine;			// Engine this transport is working for
	DWORD m_dwMaxPlayers;							// Maximum # of players this session can have
	BOOL  m_initialized;							// Has this object been initialized?
			
	DVTRANSPORTINFO m_dvTransportInfo;				// Information about the transport
	DPID m_dpidLocalPlayer;							// DPID of the local client	
	DWORD m_dwDuumy;
	DWORD m_dwObjectType;

	BOOL	m_fAdvised;

	std::map<DWORD,LPVOID>::iterator m_mPlayerIterator;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvengine.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvengine.cpp
 *  Content:	Implementation of CDirectVoiceEngine's static functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/19/99		rodtoll	Created
 * 07/29/99		rodtoll	Added static members to load default settings
 * 08/10/99		rodtoll	Removed the TODOs
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 *						Added default parameter reads from the registry
 * 08/30/99		rodtoll	Distinguish between primary buffer format and
 *						playback format.
 *						Changed playback format to be 8Khz, 16Bit mono
 * 10/05/99		rodtoll	Additional comments/DPFs
 * 10/07/99		rodtoll	Updated to work in Unicode 
 * 02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 04/21/2000  rodtoll   Bug #32889 - Does not run on Win2k on non-admin account
 * 04/24/2000   rodtoll Bug #33203 - Aureal Vortex plays back at the wrong rate
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 * 10/10/2000	rodtoll	Bug #46907 - 3D Sound position not working correctly with Win9X & VxD
 * 04/06/2001	kareemc	Added Voice Defense
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// Registry settings and their defaults
#define DPVOICE_REGISTRY_DEFAULTAGGRESSIVENESS		L"DefaultAggressiveness"
#define DPVOICE_DEFAULT_DEFAULTAGGRESSIVENESS		15

#define DPVOICE_REGISTRY_DEFAULTQUALITY				L"DefaultQuality"
#define DPVOICE_DEFAULT_DEFAULTQUALITY				15

#define DPVOICE_REGISTRY_DEFAULTSENSITIVITY			L"DefaultSensitivity"
#define DPVOICE_DEFAULT_DEFAULTSENSITIVITY			20

#define DPVOICE_REGISTRY_ASO						L"AltStart"
#define DPVOICE_DEFAULT_ASO							FALSE

#define DPVOICE_REGISTRY_DUMPDIAGNOSTICS			L"InitDiagnostics"
#define DPVOICE_DEFAULT_DUMPDIAGNOSTICS				FALSE

// Fix for bug #33203 -- Some cards having trouble with playback at 8Khz.
#define DPVOICE_REGISTRY_PLAYBACKFORMAT				L"PlaybackFormat"
#define DPVOICE_DEFAULT_PLAYBACKFORMAT				CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 22050, 16 )

#define DPVOICE_REGISTRY_PRIMARYFORMAT				L"PrimaryFormat"
#define DPVOICE_DEFAULT_PRIMARYFORMAT				CreateWaveFormat( WAVE_FORMAT_PCM, TRUE, 22050, 16 )

#define DPVOICE_REGISTRY_MIXERFORMAT				L"MixerFormat"
#define DPVOICE_DEFAULT_MIXERFORMAT					CreateWaveFormat( WAVE_FORMAT_PCM, FALSE, 8000, 16 );

// Initialize static member variables
DWORD CDirectVoiceEngine::s_dwDefaultBufferAggressiveness = DPVOICE_DEFAULT_DEFAULTAGGRESSIVENESS;
DWORD CDirectVoiceEngine::s_dwDefaultBufferQuality = DPVOICE_DEFAULT_DEFAULTQUALITY;
DWORD CDirectVoiceEngine::s_dwDefaultSensitivity = DPVOICE_DEFAULT_DEFAULTSENSITIVITY;
LPWAVEFORMATEX CDirectVoiceEngine::s_lpwfxPrimaryFormat = NULL;
LPWAVEFORMATEX CDirectVoiceEngine::s_lpwfxPlaybackFormat = NULL;
LPWAVEFORMATEX CDirectVoiceEngine::s_lpwfxMixerFormat = NULL;
BOOL CDirectVoiceEngine::s_fASO = DPVOICE_DEFAULT_ASO;
WCHAR CDirectVoiceEngine::s_szRegistryPath[_MAX_PATH];	
BOOL CDirectVoiceEngine::s_fDumpDiagnostics = DPVOICE_DEFAULT_DUMPDIAGNOSTICS;
DNCRITICAL_SECTION CDirectVoiceEngine::s_csSTLLock;

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceEngine::Startup"
//
// Startup
//
// Called to load global settings and compression info from the registry.  
//
HRESULT CDirectVoiceEngine::Startup(const WCHAR *szPath)
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Starting up global DLL state" );

	wcscpy( s_szRegistryPath, szPath );

	if (!DNInitializeCriticalSection( &s_csSTLLock ) )
	{
		return DVERR_OUTOFMEMORY;
	}

	hr = DVCDB_LoadCompressionInfo( s_szRegistryPath );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load compression info: hr=0x%x", hr );
		return hr;
	}

	InitRecordFormats();

	CRegistry cregSettings;

	if( !cregSettings.Open( HKEY_CURRENT_USER, s_szRegistryPath, FALSE, TRUE ) )
	{
		s_dwDefaultBufferQuality = DPVOICE_DEFAULT_DEFAULTAGGRESSIVENESS;
		s_dwDefaultBufferAggressiveness = DPVOICE_DEFAULT_DEFAULTQUALITY;
		s_dwDefaultSensitivity = DPVOICE_DEFAULT_DEFAULTSENSITIVITY;

		CDirectVoiceEngine::s_lpwfxPlaybackFormat = DPVOICE_DEFAULT_PLAYBACKFORMAT;
		CDirectVoiceEngine::s_lpwfxPrimaryFormat = DPVOICE_DEFAULT_PRIMARYFORMAT;
		CDirectVoiceEngine::s_lpwfxMixerFormat = DPVOICE_DEFAULT_MIXERFORMAT;
		CDirectVoiceEngine::s_fDumpDiagnostics = DPVOICE_DEFAULT_DUMPDIAGNOSTICS;

		return DV_OK;
	}

	cregSettings.ReadDWORD( DPVOICE_REGISTRY_DEFAULTQUALITY, s_dwDefaultBufferQuality );
	cregSettings.ReadDWORD( DPVOICE_REGISTRY_DEFAULTAGGRESSIVENESS, s_dwDefaultBufferAggressiveness );
	cregSettings.ReadDWORD( DPVOICE_REGISTRY_DEFAULTSENSITIVITY, s_dwDefaultSensitivity );
	cregSettings.ReadBOOL( DPVOICE_REGISTRY_ASO, s_fASO );
	cregSettings.ReadBOOL( DPVOICE_REGISTRY_DUMPDIAGNOSTICS, s_fDumpDiagnostics );

	if( FAILED( CREG_ReadAndAllocWaveFormatEx( cregSettings, DPVOICE_REGISTRY_PLAYBACKFORMAT, &CDirectVoiceEngine::s_lpwfxPlaybackFormat  ) ) )
	{
		CDirectVoiceEngine::s_lpwfxPlaybackFormat = DPVOICE_DEFAULT_PLAYBACKFORMAT;
	}

	if( FAILED( CREG_ReadAndAllocWaveFormatEx( cregSettings, DPVOICE_REGISTRY_PRIMARYFORMAT, &CDirectVoiceEngine::s_lpwfxPrimaryFormat  ) ) )
	{
		CDirectVoiceEngine::s_lpwfxPrimaryFormat = DPVOICE_DEFAULT_PRIMARYFORMAT;
	}

	if( FAILED( CREG_ReadAndAllocWaveFormatEx( cregSettings, DPVOICE_REGISTRY_MIXERFORMAT, &CDirectVoiceEngine::s_lpwfxMixerFormat ) ) )
	{
		CDirectVoiceEngine::s_lpwfxMixerFormat = DPVOICE_DEFAULT_MIXERFORMAT;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceEngine::Shutdown"
//
// Shutdown
//
// Called to free the global settings and compression list
//
HRESULT CDirectVoiceEngine::Shutdown()
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Shutting down global DLL state" );	

	DeInitRecordFormats();

	if( CDirectVoiceEngine::s_lpwfxPlaybackFormat != NULL )
		delete CDirectVoiceEngine::s_lpwfxPlaybackFormat;

	if( CDirectVoiceEngine::s_lpwfxMixerFormat != NULL )
		delete CDirectVoiceEngine::s_lpwfxMixerFormat;

	if( CDirectVoiceEngine::s_lpwfxPrimaryFormat != NULL )
		delete CDirectVoiceEngine::s_lpwfxPrimaryFormat;

	hr = DVCDB_FreeCompressionInfo();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to un-load compression info: hr=0x%x", hr );
		return hr;
	}

	DNDeleteCriticalSection( &s_csSTLLock );	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceEngine::ValidateSpeechPacketSize"
//
// ValidateSpeechPacketSize
//
// Called to make sure the speech packet size is valid
//
BOOL CDirectVoiceEngine::ValidateSpeechPacketSize(LPDVFULLCOMPRESSIONINFO lpdvfCompressionInfo, DWORD dwSize)
{
	BOOL bValid;

	// return true in this case because it isn't a hack attempt
	if( lpdvfCompressionInfo == NULL)
		return TRUE;

	// Check for VR12
	if( lpdvfCompressionInfo->guidType == DPVCTGUID_VR12 )
		bValid = ( dwSize <= lpdvfCompressionInfo->dwFrameLength );
	else 
		bValid = ( dwSize == lpdvfCompressionInfo->dwFrameLength );

	return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvengine.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvdptransport.h
 *  Content:	Definition of base class for Transport --> DirectXVoice
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created It
 * 07/29/99		rodtoll	Added static members to load default settings 
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						ompression sub-system.  
 *						Added default parameter reads from the registry
 * 08/30/99		rodtoll	Distinguish between primary buffer format and
 *						playback format.
 * 09/14/99		rodtoll	Updated parameters to Init
 * 10/07/99		rodtoll	Updated to work in Unicode 
 * 10/27/99		pnewson Fix: Bug #113935 - Saved AGC values should be device specific
 * 01/10/00		pnewson AGC and VA tuning
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 04/07/2000   rodtoll Updated for new DP <--> DPV interface
 * 07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 04/06/2001	kareemc	Added Voice Defense
 *
 ***************************************************************************/

#ifndef __DVENGINE_H
#define __DVENGINE_H

#include "dpvcp.h"

// CDirectVoiceEngine
//
// This class is the base interface for DirectVoiceClientEngine and 
// DirectVoiceServerEngine.  This interface is used by DirectPlay/
// DirectNet to inform the DirectXVoice engine of new events.  
//
// Hooks are placed into DirectPlay that call these functions.
//
class CDirectVoiceEngine
{
public:
public: // Incoming messages
	virtual BOOL ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize ) = 0;

public: // Session Management
	virtual HRESULT StartTransportSession() = 0;
	virtual HRESULT StopTransportSession() = 0;

public: // Player information
	virtual HRESULT AddPlayer( DVID dvID ) = 0;
	virtual HRESULT RemovePlayer( DVID dvID ) = 0;

public: // Used by local voice server to hook player messages to send
	    // to the remote voice server
	virtual HRESULT Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements ) = 0;
	virtual HRESULT CreateGroup( DVID dvID ) = 0;
	virtual HRESULT DeleteGroup( DVID dvID ) = 0;
	virtual HRESULT AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;
	virtual HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;
	virtual HRESULT MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer ) = 0;
	virtual HRESULT SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete ) = 0;

public: // Compression Information Storage
	static HRESULT Startup( const WCHAR *szRegistryPath );
	static HRESULT Shutdown();

	static DNCRITICAL_SECTION s_csSTLLock;			// Lock serializing access to the STL 	

public: // packet validation
	BOOL ValidateSpeechPacketSize( LPDVFULLCOMPRESSIONINFO lpdvfCompressionInfo, DWORD dwSize );
	
protected:

	static DWORD s_dwDefaultBufferAggressiveness;	// Default system buffer aggresiveness
	static DWORD s_dwDefaultBufferQuality;			// Default system buffer quality
	static DWORD s_dwDefaultSensitivity;			// Default system sensitivity
	static LPWAVEFORMATEX s_lpwfxPrimaryFormat;		// Primary buffer format
	static LPWAVEFORMATEX s_lpwfxPlaybackFormat;	// Playback format
	static LPWAVEFORMATEX s_lpwfxMixerFormat;		// Format for the mixer
	static BOOL s_fASO;								// Should ASO be used?
	static WCHAR s_szRegistryPath[_MAX_PATH];		// Registry path
	static BOOL s_fDumpDiagnostics;					// Should we dump diagnostic info during wizard runs?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvprot.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvprotocol.h
 *  Content:	Defines structures / types for DirectXVoice protocol
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/02/99	rodtoll	Created It
 *  07/21/99	rodtoll Added settings confirm message to protocol
 *  08/18/99	rodtoll	Changed the message type to a BYTE
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *  09/07/99	rodtoll	Moved definition of settarget message to dvoice.h
 *  09/30/99	rodtoll	Updated to include more comments
 *  12/16/99	rodtoll	Updated to include new messages used by host migration
 *						and update protocol number
 *  01/14/2000	rodtoll	Updated with new speech packets which optimize peer
 *						to peer and allow multiple targets in multicast/mixing
 *						and updated protocol number.
 *  04/07/2000  rodtoll Code cleanup, proper structure defs
 *  01/04/2001	rodtoll	WinBug #94200 - Remove stray comments
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets 
 *
 ***************************************************************************/

#ifndef __DVPROTOCOL_H
#define __DVPROTOCOL_H

#pragma pack(push,1)

// DVPROTOCOL_VERSION_XXXXXX
//
// These are the values developers should use to send in the ucVersionMajor
// ucVersionMinor and dwVersionBuild (respectively) members of the ConnectRequest
// and connect accept messages.
#define DVPROTOCOL_VERSION_MAJOR			1
#define DVPROTOCOL_VERSION_MINOR			0
#define DVPROTOCOL_VERSION_BUILD			3

//
// PROTOCOL DESCRIPTION
//
// Connection Process
// ------------------
//
// Clients connect to the voice session by sending a DVPROTOCOLMSG_CONNECTREQUEST.  
// The host then determines if the client is allowed to join the session.  If
// the client's request is rejected, the client receives a DVPROTOCOLMSG_CONNECTREFUSE.
// If the client's request is accepted, the client receives a 
// DVPROTOCOLMSG_CONNECTACCEPT.  This packet contains all the information the client 
// requires to determine if they are compatible.  
// 
// The client will then attempt to initialize themselves using the compression
// type transmitted by the server.  If the client fails to initialize it takes
// no further action.  If the client initializes succesfully it transmits a
// DVPROTOCOLMSG_SETTINGSCONFIRM message and is added to the session.  All players 
// in the session will then receive a DVPROTOCOLMSG_PLAYERJOIN.
//
// Until a DVPROTOCOLMSG_SETTINGSCONFIRM message is received by the host, the client is 
// not considered to be part of the session.  As such it will not transmit 
// speech.  (However, it may receive speech).
//
// The server then sends DVPROTOCOLMSG_PLAYERLIST message(s) to give the client the
// current player table.  (Peer to peer only).
//
// Disconnection Process
// ---------------------
//
// If a client wishes to disconnect from the voice session, it sends a 
// DVPROTOCOLMSG_DISCONNECT message to the host.  The host will then transmit
// to all players  a DVPROTOCOLMSG_PLAYERQUIT message and will send a 
// DVPROTOCOLMSG_DISCONNECT message back to the player to confirm.
//
// If the client disconnects unexpectedly the voice host will detect this and 
// will automatically send DVPROTOCOLMSG_PLAYERQUIT messages to all the other clients 
// in the session. 
//
// Speech Messages
// ---------------
//
// Speech messages are described in detail in the description for DVPROTOCOLMSG_SPEECH.
//
// Messages sent from the host are sent with the DVMSGID_SPEECHBOUNCE instead 
// of DVMSGID_SPEECH so that whena host and client share a single dplay id 
// the client can ignore it's own speech packets. 
// 
// Host Migration
// --------------
//
// NEW HOST MIGRATION
//
// Pros/Cons:
//
// First, the advantages to the new system:
// - The new host migration mechanism allows DirectPlay Voice to have a host 
// -  seperate from the directplay host.
// - Shutting down the host without stopping the dplay interface causes voice host 
//   to migrate.
// - Minimizes changes to directplay.
// - Removes requirement that all clients had to run voice clients.  
// - You can prevent the host from migrating when you call stopsession by 
//   specifying the new DVFLAGS_NOHOSTMIGRATE which causes the session to be 
//   stopped.
//
// Disadvantages of the new system:
// - If there are no voice clients in the session when the host is lost, then the 
// voice session will be lost.
// 
// Host Election
// 
// In order to elect a new host, each client is given a "Host Order ID" when 
// they have completed their connection.  All clients are informed of an 
// individual's "Host Order ID" when they find out about the player.  These 
// identifiers start at 0, are a DWORD in size, and are incremented with each 
// new user.  Therefore the first player in the session will have ID 0, the 
// second will have ID 1, etc.
//
// By using this method we ensure that the client elected to be the host will be 
// the oldest client in the session.  This has the advantage (because of the way 
// the name table is distributed) if any client has any clients at all, they 
// will have the oldest clients.  Therefore everyone in the session will either 
// have just themselves, or at the very least the client who will become the new 
// host.  If a client doesn't have anyone in the session, it means they either 
// are the only ones in the session (in which case they become the new host) or 
// they haven't received the name table yet.  If they haven't received the name 
// table they will not yet have a "Host Order ID" and will therefore be 
// inelligable to become the new host.
//
// When the host migrates to a new host, the new host offsets a constant (in 
// this case defined in dvcleng.cpp as DVMIGRATE_ORDERID_OFFSET) from it's own 
// Host Order ID and uses it as the next Host Order ID to hand out.  (So 
// duplicate host order IDs are not handed out).
//
// Unless.. you get DVMIGRATE_ORDERID_OFFSET connects between when the new host 
// joined and a new player joins before a player with a higher ID joins.  (If a 
// player informs the server that it's Host Order ID is > then the seed the host 
// bumps the seed to be DVMIGRATE_ORDERID_OFFSET from the user's value).  In 
// this case you may end up with > 1 host.  (But this case is extremely unlikely).
//
// How It's Implemented
//
// Each client in the session knows the DPID of the host.  Therefore, to detect 
// the situation where the host will migrate the client looks at if the session 
// supports host migration and for one of two things: 
//
// - A DVPROTOCOLMSG_HOSTMIGRATELEAVE message - This is sent by the host when StopSession (
//   without the DVFLAGS_NOHOSTMIGRATE flag) or Release is called. 
// - DirectPlay informs DirectPlay Voice that the player ID belonging to the 
//   session host has left the session.
//
// Once one of the above occurs, each clients runs the new host election 
// algorithm.  Their action will depend on the situation:
//
// - If no clients are found that are elligible to become the new host.  Then the 
//   client will disconnect.
// - If clients are found that are elligible to become the new host but it is not 
//   the local client, the local client takes no action.
// - If the local client is to be the new host then it starts up a new host locally.
//
// Once the new host starts up, it will send a DVPROTOCOLMSG_HOSTMIGRATE message to all 
// the users in the session.  Each client in the session responds with their 
// current settings using a DVPROTOCOLMSG_SETTINGSCONFIRM message (which includes the 
// client's current "Host Order ID".  Using these messages the new host rebuilds 
// the player list.  Also, in response to the DVPROTOCOLMSG_SETTINGSCONFIRM message each 
// client receives a copy of the latest name table.  For players who respond to 
// the host migration after you, DVPROTOCOLMSG_CREATEVOICEPLAYER messages will be sent.  
// This player ensures that every client ends up with a proper and up to date 
// name table.  
//
// Each client in the session ignores duplicate CREATEVOICEPLAYER messages.  
// 
// The client object that creates the new host holds a reference to the new host 
// and will destroy it when the client is destroyed.  (Possibly causing the host 
// to migrate again).  
//
// Session Losses
//
// Using this new scheme it is possible to lose the voice session if there are 
// no voice clients elligeble to become the new voice host.  (Meaning there are 
// no clients properly connected).  All clients which are not yet completed 
// their connection will detect this situation and will disconnect from the 
// session.
//
// In addition, when the host goes to stop, it checks to see if there are any 
// clients elligeble to become the host.  If there are none it transmits a 
// DVPROTOCOLMSG_SESSIONLOST message to all players in the session.  
//
// Notes:
//
// One thing to watch for is since the DirectPlayVoice host may migrate to a 
// different client then the DirectPlay host does, just because you know who the 
// DirectPlay Host is doesn't mean you know who the voice host is.
//
// In order to implement this new mechanism the following related changes were 
// made:
//
// - Clients with differing major/minor/build protocol version numbers are 
//   rejected by the host now.  The result is that new clients may be able to 
//   connect to old hosts but may crash, and old clients are now rejected by new 
//   hosts.  (Handling of these cases on old clients was not good -- just don't do 
//   it).
// - DirectPlay host migration messages are ignored.
// - Connection requests are sent to everyone in the session.  The client 
//   determines who the host is by seeing who responded to their message.  
// - Handling of rejection messages now results in the connection failing.  (There 
//   was a bug).
// - The rejection message now contains the major/minor/build protocol version of 
//   the host.
// - Instead of sending individual messages for each user in the current session 
//   to a client when it first joins the host now sends a DVPROTOCOLMSG_PLAYERLIST which 
//   is a list of players in the session.  This reduces bandwidth and makes the 
//   connection process shorter.  

/////////////////////////////////////////////////////////////////////////////////
//
// PROTOCOL SPECIFIC DEFINES
//
/////////////////////////////////////////////////////////////////////////////////

// The maximum size in bytes that a single playerlist packet can be.
//
// (Holds about 120 entries / packet).
//
#define DVPROTOCOL_PLAYERLIST_MAXSIZE	1000

#define DVPROTOCOL_HOSTORDER_INVALID	0xFFFFFFFF

// DVMIGRATE_ORDERID_OFFSET
//
// This is the number to add to this client's Host Order ID to be the
// next value handed out by the host which the client is creating in
// response to host migration.
//
#define DVMIGRATE_ORDERID_OFFSET				256


/////////////////////////////////////////////////////////////////////////////////
//
// MESSAGE IDENTIFIERS
//
/////////////////////////////////////////////////////////////////////////////////

#define DVMSGID_INTERNALBASE		0x0050

#define DVMSGID_CONNECTREQUEST		DVMSGID_INTERNALBASE+0x0001
#define DVMSGID_CONNECTREFUSE		DVMSGID_INTERNALBASE+0x0003
#define DVMSGID_DISCONNECT			DVMSGID_INTERNALBASE+0x0004
#define DVMSGID_SPEECH				DVMSGID_INTERNALBASE+0x0005
#define DVMSGID_CONNECTACCEPT		DVMSGID_INTERNALBASE+0x0006
#define DVMSGID_SETTINGSCONFIRM		DVMSGID_INTERNALBASE+0x0008
#define DVMSGID_SETTINGSREJECT		DVMSGID_INTERNALBASE+0x0009
#define DVMSGID_DISCONNECTCONFIRM	DVMSGID_INTERNALBASE+0x000A
#define DVMSGID_SPEECHBOUNCE		DVMSGID_INTERNALBASE+0x0010
#define DVMSGID_PLAYERLIST			DVMSGID_INTERNALBASE+0x0011
#define DVMSGID_HOSTMIGRATELEAVE	DVMSGID_INTERNALBASE+0x0012
#define DVMSGID_SPEECHWITHTARGET	DVMSGID_INTERNALBASE+0x0013
#define DVMSGID_SPEECHWITHFROM		DVMSGID_INTERNALBASE+0x0014

/////////////////////////////////////////////////////////////////////////////////
//
// CONNECT MESSAGES
//
/////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_CONNECTREQUEST
//
// Session Types: ALL
// Message Flow : Voice Client -> Voice Host
//
// Requests a connection to the existing DirectXVoice session.
//
typedef UNALIGNED struct _DVPROTOCOLMSG_CONNECTREQUEST
{
	BYTE	dwType;				// = DVMID_CONNECTREQUEST
	BYTE	ucVersionMajor;		// Client's protocol version (major)
	BYTE	ucVersionMinor;		// Client's protocol version (minor)
	DWORD	dwVersionBuild;		// Client's protocol version (build)
} DVPROTOCOLMSG_CONNECTREQUEST, *PDVPROTOCOLMSG_CONNECTREQUEST;

//
// DVPROTOCOLMSG_CONNECTREFUSE
//
// Session Types: ALL
// Message Flow : Voice Host -> Voice Clients
//
// Server responds with this if no voice session available or needs
// to refuse the connection.  E.g. out of memory or incompatible 
// version.
//
typedef UNALIGNED struct _DVPROTOCOLMSG_CONNECTREFUSE
{
	BYTE	dwType;				// = DVMSGID_CONNECTREFUSE
	HRESULT hresResult;			// Reason for refusal (DVERR_XXXXXX)
	BYTE	ucVersionMajor;		// Server's protocol version (major)
	BYTE	ucVersionMinor;		// Server's protocol version (minor)
	DWORD	dwVersionBuild;		// Server's protocol version (build)
} DVPROTOCOLMSG_CONNECTREFUSE, *PDVPROTOCOLMSG_CONNECTREFUSE;

//
// DVPROTOCOLMSG_CONNECTACCEPT
//
// Session Types: ALL
// Message Flow : Voice Host -> Voice Clients
//
// Indicates to the client that their connect request was accepted.
// This message contains information about the voice session that
// the client needs to initialize.
//
typedef UNALIGNED struct _DVPROTOCOLMSG_CONNECTACCEPT
{
	BYTE			dwType;				// = DVMSGID_CONNECTACCEPT
	DWORD			dwSessionType;		// Type of session = DVSESSIONTYPE_XXXXXX
	BYTE			ucVersionMajor;		// Server's protocol version (major)
	BYTE			ucVersionMinor;		// Server's protocol version (minor)
	DWORD			dwVersionBuild;		// Server's protocol version (build)
	DWORD			dwSessionFlags;		// Flags for the session (Combination of DVSESSION_XXXXXX values)
	GUID			guidCT;				// Compression Type (= DPVCTGUID_XXXXXX)
} DVPROTOCOLMSG_CONNECTACCEPT, *PDVPROTOCOLMSG_CONNECTACCEPT;

//
// DVPROTOCOLMSG_SETTINGSCONFIRM 
//
// Session Types: ALL
// Message Flow : Voice Client -> Voice Host
//
// Sent by client to confirm they can handle current compression
// settings.  This message is sent once the client has determined that
// they can support the specified compression type and the sound 
// system has succesfully initialized.
//
// This message is also sent from voice clients to the new voice host
// when a migration has taken place.
//
typedef UNALIGNED struct _DVPROTOCOLMSG_SETTINGSCONFIRM
{
	BYTE	dwType;				// Message Type = DVMSGID_SETTINGSCONFIRM
	DWORD	dwFlags;			// Client Flags (Only valid one is half duplex)
	DWORD	dwHostOrderID;		// Host Order ID (=INVALID to assign new one)
} DVPROTOCOLMSG_SETTINGSCONFIRM, *PDVPROTOCOLMSG_SETTINGSCONFIRM;

//
// DVPROTOCOLMSG_PLAYERLIST
//
// Session Types: Peer to Peer
// Message Flow : Voice Host -> Voice Clients
//
// Builds a list of players in the session to be sent to the 
// client once they have confirmed they are connected.
//
// May be spread over multiple packets.
//
// These messages will be the following header followed by a
// list of DVPROTOCOLMSG_PLAYERLIST_ENTRY structures (the # will be 
// specified in dwNumEntries).
//
typedef UNALIGNED struct _DVPROTOCOLMSG_PLAYERLIST
{
	BYTE 					dwType;				// = DVMSGID_PLAYERLIST
	DWORD					dwHostOrderID;		// Host migration sequence number (for client)
	DWORD					dwNumEntries;		// Number of DVPROTOCOLMSG_PLAYERLIST_ENTRY structures 
												// following this header in this packet
} DVPROTOCOLMSG_PLAYERLIST, *PDVPROTOCOLMSG_PLAYERLIST;

//
// DVPROTOCOLMSG_PLAYERLIST_ENTRY
//
// Sent as part of a DVPROTOCOLMSG_PLAYERLIST message.
//
// Peer to Peer Only
//
// Each of these structures represents a player in the session.
// They are sent as part of the DVPROTOCOLMSG_PLAYERLIST structure.
//
typedef UNALIGNED struct _DVPROTOCOLMSG_PLAYERLIST_ENTRY
{
	DVID	dvidID;				// Player's DVID
	DWORD	dwPlayerFlags;		// Player's player flags (DVPLAYERCAPS_XXXXX)
	DWORD	dwHostOrderID;		// Host migration sequence number
} DVPROTOCOLMSG_PLAYERLIST_ENTRY, *PDVPROTOCOLMSG_PLAYERLIST_ENTRY;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - SPEECH
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_SPEECHHEADER
//
// This message is used for transporting speech. Speech packets contain
// one of these headers followed by the audio data.  After this header
// the audio data will be the remaining part of the packet.
//
// ----
//
// Session Types: Peer to Peer
// Message Flow : Voice Clients <-> Voice Clients
//
// Session Types: Mixing
// Message Flow : Voice Mixing Server --> Voice Clients
//
// Session Types: Echo
// Message Flow : Voice Host <-> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_SPEECHHEADER
{
	BYTE	dwType;				// = DVMSGID_SPEECH
	BYTE	bMsgNum;			// Message # for message
	BYTE	bSeqNum;			// Sequence # for message
} DVPROTOCOLMSG_SPEECHHEADER, *PDVPROTOCOLMSG_SPEECHHEADER;

//
// DVPROTOCOLMSG_SPEECHWITHTARGET
//
// This message is used for transporting speech. The message consists
// of this header followed by a single DVID for each target the packet
// is targetted at.  After the target list the audio data will be the
// remaining part of the packet.
//
// ----
// Sesssion Types: Mixing / Forwarding
// Message Flow  : Voice Clients --> Voice Host / Voice Mixing Server
//
typedef UNALIGNED struct _DVPROTOCOLMSG_SPEECHWITHTARGET
{
	DVPROTOCOLMSG_SPEECHHEADER	dvHeader;
								// dwType = DVMSGID_SPEECHWITHTARGET
	DWORD dwNumTargets;			// # of targets following this header 
} DVPROTOCOLMSG_SPEECHWITHTARGET, *PDVPROTOCOLMSG_SPEECHWITHTARGET;

// 
// DVPROTOCOLMSG_SPEECHWITHFROM
//
// This message is used by forwarding servers when a speech packet is 
// bounced.  The packet contains this header followed by the audio 
// data.  The audio data will be the remaining part of the packet.
//
// ---
// Session Types: Forwarding 
// Message Flow : Forwarding Server --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_SPEECHWITHFROM
{
	DVPROTOCOLMSG_SPEECHHEADER	dvHeader;
								// dwType = DVMSGID_SPEECHWITHFROM
	DVID dvidFrom;				// DVID of the client that this packet originated.
} DVPROTOCOLMSG_SPEECHWITHFROM, *PDVPROTOCOLMSG_SPEECHWITHFROM;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - TARGET MANAGEMENT
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_SETTARGET
//
// Tells client to switch it's target to the specified value.  Used when 
// the server calls SetTransmitTarget for a particular player.  This message
// contains this header followed by dwNumTargets DWORDs containing the
// players / groups that the client is targetting.  
//
// ---
// Session Types: Sessions with Server Controlled Targetting Enabled
// Message Flow : Voice Host --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_SETTARGET
{
	BYTE			dwType;				// = DVMSGID_SETTARGETS
	DWORD			dwNumTargets;		// # of targets (Can be 0 for no targets).
} DVPROTOCOLMSG_SETTARGET, *PDVPROTOCOLMSG_SETTARGET;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - NAMETABLE MANAGEMENT
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_PLAYERJOIN
//
// This message is used to inform clients when a new client has connected
// to the session.  
//
// ---
// Session Types: Peer to Peer
// Message Flow : Voice Host --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_PLAYERJOIN
{
	BYTE			dwType;				// = DVMSGID_CREATEVOICEPLAYER
	DVID			dvidID;				// ID of the player
	DWORD			dwFlags;			// Player's player flags (DVPLAYERCAPS_XXXXX)
	DWORD			dwHostOrderID;		// Host Order ID
} DVPROTOCOLMSG_PLAYERJOIN, *PDVPROTOCOLMSG_PLAYERJOIN;

//
// DVPROTOCOLMSG_PLAYERQUIT
//
// This message is used to inform clients when a client has left the voice
// session.
//
// ---
// Session Types: Peer to Peer
// Message Flow : Voice Host --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_PLAYERQUIT
{
	BYTE			dwType;				// = DVMSGID_DELETEVOICEPLAYER
	DVID			dvidID;				// ID of the player
} DVPROTOCOLMSG_PLAYERQUIT, *PDVPROTOCOLMSG_PLAYERQUIT;

// 
// DVPROTOCOLMSG_GENERIC
//
// Used to determine the type of a DirectPlayVoice message.  Used in message
// cracking.
//
typedef UNALIGNED struct _DVPROTOCOLMSG_GENERIC
{
	BYTE			dwType;
} DVPROTOCOLMSG_GENERIC, *PDVPROTOCOLMSG_GENERIC;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - HOST MIGRATION MESSAGES
//
/////////////////////////////////////////////////////////////////////////////////////

// 
// DVPROTOCOLMSG_HOSTMIGRATED
//
// This message is sent by the new host when a host migration has taken place.
// The message is sent by the new host once they have finished initialization.
// All clients should respond to this message with a DVPROTOCOLMSG_SETTINGSCONFIRM.
//
// ---
// Session Types: Peer to Peer (With host migration enabled).
// Message Flow : Voice Host (New) --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_HOSTMIGRATED
{
	BYTE			dwType; // = DVMSGID_HOSTMIGRATED
} DVPROTOCOLMSG_HOSTMIGRATED, *PDVPROTOCOLMSG_HOSTMIGRATED;

// 
// DVPROTOCOLMSG_HOSTMIGRATELEAVE
//
// This message is sent by a voice host if they are shutting down their interface
// and host migration is enabled.  It informs clients that they have to run their
// election algorithm.
//
// ---
// Session Types: Peer To Peer (With Host Migration Enabled)
// Message Flow : Voice Host (Old) --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_HOSTMIGRATELEAVE
{
	BYTE			dwType; // = DVMSGID_HOSTMIGRATELEAVE
} DVPROTOCOLMSG_HOSTMIGRATELEAVE, *PDVPROTOCOLMSG_HOSTMIGRATELEAVE;

/////////////////////////////////////////////////////////////////////////////////////
//
// IN-SESSION MESSAGES - SESSION TERMINATION
//
/////////////////////////////////////////////////////////////////////////////////////

//
// DVPROTOCOLMSG_SESSIONLOST
//
// This message is sent by the voice host when they are shutting down and
// host migration is not enabled or available.
//
// This message can also be sent if a host migration takes place and a 
// client encounters a fatal error when starting the new host.
// 
// ---
// Session Type: ALL
// Message Flow: Voice Host (New) --> Voice Clients
//				 Voice Host --> Voice Clients
//
typedef UNALIGNED struct _DVPROTOCOLMSG_SESSIONLOST
{
	BYTE			dwType;				// = DVMSGID_SESSIONLOST
	HRESULT			hresReason;			// DVERR_XXXXXX or DV_OK
} DVPROTOCOLMSG_SESSIONLOST, *PDVPROTOCOLMSG_SESSIONLOST; 

//
// DVPROTOCOLMSG_DISCONNECT
//
// This message is sent by voice clients when they wish to disconnect 
// gracefully.  The host responds with the same message to confirm
// it received the request.  Once the client receives the response
// then it is free to disconnect.
//
// ---
// Session Type: ALL
// Message Flow: Voice Host --> Voice Client (dwType = DVPROTOCOLMSG_DISCONNECTCONFIRM)
//               Voice Client --> Voice Host (dwType = DVPROTOCOLMSG_DISCONNECT)
//
typedef UNALIGNED struct _DVPROTOCOLMSG_DISCONNECT
{
	BYTE			dwType;				// = DVPROTOCOLMSG_DISCONNECTCONFIRM OR
										//   DVPROTOCOLMSG_DISCONNECT
	HRESULT			hresDisconnect;		// HRESULT that caused the disconnect
										// DV_OK or DVERR_XXXXXX
} DVPROTOCOLMSG_DISCONNECT, *PDVPROTOCOLMSG_DISCONNECT;

typedef union _DVPROTOCOLMSG_FULLMESSAGE
{
	DVPROTOCOLMSG_GENERIC			dvGeneric;
	DVPROTOCOLMSG_SESSIONLOST		dvSessionLost;
	DVPROTOCOLMSG_PLAYERJOIN		dvPlayerJoin;
	DVPROTOCOLMSG_PLAYERQUIT		dvPlayerQuit;
	DVPROTOCOLMSG_CONNECTACCEPT		dvConnectAccept;
	DVPROTOCOLMSG_CONNECTREFUSE		dvConnectRefuse;
	DVPROTOCOLMSG_CONNECTREQUEST	dvConnectRequest;
	DVPROTOCOLMSG_SPEECHHEADER		dvSpeech;
	DVPROTOCOLMSG_DISCONNECT		dvDisconnect;
	DVPROTOCOLMSG_SETTARGET			dvSetTarget;
	DVPROTOCOLMSG_SETTINGSCONFIRM	dvSettingsConfirm;
	DVPROTOCOLMSG_PLAYERLIST		dvPlayerList;
	DVPROTOCOLMSG_HOSTMIGRATED		dvHostMigrated;
	DVPROTOCOLMSG_HOSTMIGRATELEAVE	dvHostMigrateLeave;
	DVPROTOCOLMSG_SPEECHWITHTARGET		dvSpeechWithTarget;
	DVPROTOCOLMSG_SPEECHWITHFROM		dvSpeechWithFrom;
} DVPROTOCOLMSG_FULLMESSAGE, *PDVPROTOCOLMSG_FULLMESSAGE;

#pragma pack(pop)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvrecsub.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ClientRecordSubSystem.cpp
 *  Content:	Recording sub-system.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/19/99		rodtoll	Created
 * 07/22/99		rodtoll	Added support for multicast/ client/server sessions
 * 08/02/99		rodtoll	Added new silence detection support. 
 * 08/04/99		rodtoll	Added guard to new silence detection so only runs when
 *						appropriate
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 * 08/26/99		rodtoll	Set msgnum to 0 in constructor.
 * 08/26/99		rodtoll	Added check for record mute flag to fix record muting\
 * 08/27/99		rodtoll	General cleanup/Simplification of recording subsystem
 *						Added reset of message when target changes
 *						Fixed recording start/stop notifications
 *						Fixed level readings when using voice activation
 * 08/30/99		rodtoll	Fixed double record stop messages when recording muted
 * 09/01/99		rodtoll	Re-activated auto volume control
 * 09/02/99		rodtoll	Re-activated and fixed old auto record volume code 
 * 09/09/99		rodtoll	Fixed bug in FSM that was causing transion to VA
 *						state in almost every frame.  
 *				rodtoll	Fixed recording level checks
 * 09/13/99		rodtoll	Can now select old VA code with compiler define
 *              rodtoll Minor fixes to automatic volume control
 * 09/28/99		rodtoll	Modified to use new notification mechanism
 *				rodtoll	Added playback voice volume suppression
 * 09/29/99		pnewson Major AGC overhaul
 * 10/05/99		rodtoll	Dropped AGC volume reduce threshold from 3s to 500ms.
 * 10/25/99		rodtoll Fix: Bug#114187 Always transmits first frame
 *						Initial state looked like trailing frame, so always sent
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 11/12/99		rodtoll	Updated to use new recording classes, improved error 
 *						handling and new initialize function.  
 *				rodtoll	Added new high CPU handling code for record.  
 *						Checks for lockup AND ignores frame if pointer hasn't moved forward
 * 11/16/99		rodtoll	Recording thread now loops everytime it wakes up until it
 *						has compressed and transmitted all the data it can before
 *						going back to sleep.
 *				rodtoll	Now displays instrumentation data on recording thread
 * 11/18/99		rodtoll	Re-activated recording pointer lockup detection code 
 * 12/01/99		rodtoll Fix: Bug #121053 Microphone auto-select not working
 * 				rodtoll	Updated to use new parameters for SelectMicrophone function
 * 12/08/99		rodtoll Bug #121054 Integrate code for handling capture focus.  
 * 12/16/99		rodtoll	Removed voice suppression
 * 01/10/00		pnewson AGC and VA tuning
 * 01/14/2000	rodtoll	Updated to handle new multiple targets and use new speech
 *						packet formats.
 * 01/21/2000	pnewson Update to support new DVSOUNDCONFIG_TESTMODE internal flag
 *						used to detect lockups quickly during wizard testing.
 * 01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 * 02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected 
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *						Added instrumentation  
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 03/28/2000   rodtoll   Updated to remove uneeded locks which were causing deadlock
 * 04/05/2000   rodtoll Updated to use new async, no buffer copy sends, removed old transmit buffer 
 * 04/17/2000   rodtoll Bug #31316 - Some soundcards pass test with no microphone --
 *                      made recording system ignore first 3 frames of audio 
 * 04/19/2000   rodtoll Added support for new DVSOUNDCONFIG_NORECVOLAVAILABLE flag
 * 04/19/2000   pnewson Fix to make AGC code work properly with VA off
 * 04/25/2000   pnewson Fix to improve responsiveness of AGC when volume level too low
 * 07/09/2000	rodtoll	Added signature bytes
 * 07/18/2000	rodtoll	Fixed bug w/capture focus -- GetCurrentPosition will return an error
 *						when focus is lost -- this was causing a session lost
 * 08/18/2000	rodtoll   Bug #42542 - DPVoice retrofit: Voice retrofit locks up after host migration
 * 08/29/2000	rodtoll	Bug #43553 - Start() returns 0x80004005 after lockup
 *  			rodtoll	Bug #43620 - DPVOICE: Recording buffer locks up on Aureal Vortex (VxD).
 *						Updated reset procedure so it ignores Stop failures and if Start() fails
 *						it tries resetting the recording system.   
 * 08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold
 * 09/13/2000	rodtoll	Bug #44845 - DXSTRESS: DPLAY: Access violation 
 *              rodtoll	Regression fix which caused fails failures in loopback test
 * 10/17/2000	rodtoll	Bug #47224 - DPVOICE: Recording lockup reset fails w/DSERR_ALLOCATED added sleep to allow driver to cleanup
 * 10/30/2000	rodtoll	Same as above -- Update with looping attempting to re-allocate capture device
 * 01/26/2001	rodtoll	WINBUG #293197 - DPVOICE: [STRESS} Stress applications cannot tell difference between out of memory and internal errors.
 *						Remap DSERR_OUTOFMEMORY to DVERR_OUTOFMEMORY instead of DVERR_SOUNDINITFAILURE.
 *						Remap DSERR_ALLOCATED to DVERR_PLAYBACKSYSTEMERROR instead of DVERR_SOUNDINITFAILURE. 
 * 04/11/2001  	rodtoll	WINBUG #221494 DPVOICE: Updates to improve lockup detection ---
 *						Reset record event when no work to do so we don't spin unessessarily as much
 *						Add check to ensure frame where we grab audio but pos hasn't move we don't count towards lockup
 *						Add check to ensure we enforce a timeout + a frame count for lockup purposes.
 * 04/21/2001	rodtoll	MANBUG #50058 DPVOICE: VoicePosition: No sound for couple of seconds when position bars are moved
 *						- Modified lockup detection to be time based, increased timeout to 600ms.
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#define RECORD_MAX_RESETS			10
#define RECORD_MAX_TIMEOUT			2000
#define TESTMODE_MAX_TIMEOUT		500
#define RECORD_NUM_TARGETS_INIT		0
#define RECORD_NUM_TARGETS_GROW		10
#define RECORD_PASSES_BEFORE_LOCKUP 25
#define RECORD_RESET_PAUSE			500
#define RECORD_RESET_ALLOC_ATTEMPTS	10

// RECORD_LOCKUP_TIMEOUT
//
// # of ms of no movement before a lockup is detected.
//
#define RECORD_LOCKUP_TIMEOUT		600

// Comment out to use the old sensitivity detection
#define __USENEWVA

// RECORDTEST_MIN_POWER / RECORDTEST_MAX_POWER
//
// Define the max and min possible power values
//#define RECORDTEST_MIN_POWER                0
//#define RECORDTEST_MAX_POWER                100

// We have to double the # because IsMuted is called twice / pass
#define RECORDTEST_NUM_FRAMESBEFOREVOICE      6

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::CClientRecordSubSystem"
// CClientRecordSubSystem
//
// This is the constructor for the CClientRecordSubSystem class. 
// It intiailizes the classes member variables with the appropriate
// values.
//
// Parameters:
// CDirectVoiceClientEngine *clientEngine -
//		Pointer to the client object which is using this object.
//
// Returns:
// N/A
//
CClientRecordSubSystem::CClientRecordSubSystem( 
    CDirectVoiceClientEngine *clientEngine 
    ): m_dwSignature(VSIG_CLIENTRECORDSYSTEM),
	   m_recordState(RECORDSTATE_IDLE),
       m_converter(NULL),
       m_remain(0), 
       m_clientEngine(clientEngine),
	   m_dwCurrentPower(0),
	   m_dwSilentTime(0),
	   m_lastFrameTransmitted(FALSE),
	   m_msgNum(0),
	   m_seqNum(0),
	   m_dwLastTargetVersion(0),
	   m_lSavedVolume(0),
	   m_fRecordVolumeSaved(FALSE),
	   m_uncompressedSize(0),
	   m_compressedSize(0),
	   m_framesPerPeriod(0),
	   m_pbConstructBuffer(NULL),
	   m_dwResetCount(0),
	   m_dwNextReadPos(0),
	   m_fIgnoreFrame(FALSE),
	   m_dwPassesSincePosChange(0), 
	   m_fLostFocus(FALSE),
	   m_pagcva(NULL),
	   m_dwFrameCount(0),
	   m_prgdvidTargetCache(NULL),
	   m_dwTargetCacheSize(0),
	   m_dwTargetCacheEntries(0),
	   m_dwFullBufferSize(0)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::Initialize"
HRESULT CClientRecordSubSystem::Initialize()
{
	HRESULT hr;

	hr = DVCDB_CreateConverter( m_clientEngine->m_audioRecordBuffer->GetRecordFormat(), m_clientEngine->m_lpdvfCompressionInfo->guidType, &m_converter );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create converter.  hr = 0x%x", hr );
		return hr ;
	}

	hr = m_converter->GetUnCompressedFrameSize( &m_uncompressedSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get size hr=0x%x", hr );
		return hr;
	}
	
	hr = m_converter->GetCompressedFrameSize( &m_compressedSize );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get size hr=0x%x", hr );
		return hr;
	}
	
	hr = m_converter->GetNumFramesPerBuffer( &m_framesPerPeriod );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get size.  hr = 0x%x", hr );
		return hr;
	}
	
	m_transmitFrame     = FALSE;
    m_currentBuffer     = 0;
    m_dwResetCount = 0;
	m_dwPassesSincePosChange = 0;

	m_dwLastFrameTime	= GetTickCount();
    m_dwFrameTime       = m_clientEngine->m_lpdvfCompressionInfo->dwTimeout;
    m_dwSilenceTimeout  = m_clientEngine->m_lpdvfCompressionInfo->dwTrailFrames*m_dwFrameTime;    

	// Prevents first frame from transmitting all the time
	m_dwSilentTime		= m_dwSilenceTimeout+1;

    if( m_clientEngine->m_audioRecordBuffer->GetRecordFormat()->wBitsPerSample == 8 )
    {
        m_eightBit = TRUE;
    }
    else
    {
        m_eightBit = FALSE;
    }

    m_dwFullBufferSize = m_uncompressedSize*m_framesPerPeriod;

	m_pbConstructBuffer = new BYTE[m_dwFullBufferSize];

	if( m_pbConstructBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
		return DVERR_OUTOFMEMORY;
	}	

	BeginStats();	
	InitStats();

	// create and init the AGC and VA algorithm class
	m_pagcva = new CAGCVA1();
	if (m_pagcva == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
		return DVERR_OUTOFMEMORY;
	}

	LONG lSavedAGCVolume;
	hr = m_pagcva->Init(
            m_clientEngine->s_szRegistryPath,
			m_clientEngine->m_dvClientConfig.dwFlags, 
			m_clientEngine->m_dvSoundDeviceConfig.guidCaptureDevice,
			m_clientEngine->m_audioRecordBuffer->GetRecordFormat()->nSamplesPerSec,
			m_eightBit ? 8 : 16,
			&lSavedAGCVolume,
			m_clientEngine->m_dvClientConfig.dwThreshold);
	if (FAILED(hr))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error initializing AGC and/or VA algorithm, code: %i", hr);
		delete m_pagcva;
		return hr;
	}
	
	if( m_clientEngine->m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_AUTOSELECT	)
	{
		m_clientEngine->m_audioRecordBuffer->SelectMicrophone(TRUE);
	}

	m_dwLastTargetVersion = m_clientEngine->m_dwTargetVersion;

    if( !(m_clientEngine->m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_NORECVOLAVAILABLE) )
    {
    	// save the original volume settings
    	m_clientEngine->m_audioRecordBuffer->GetVolume( &m_lSavedVolume );
    	m_fRecordVolumeSaved = TRUE;

    	// set our initial volume
    	if (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME)
    	{
    		m_clientEngine->m_dvClientConfig.lRecordVolume = lSavedAGCVolume;
    	}

    	m_clientEngine->m_audioRecordBuffer->SetVolume( m_clientEngine->m_dvClientConfig.lRecordVolume );
    }
    else
    {
        m_fRecordVolumeSaved = FALSE;
    }


	// So our next 
	m_dwNextReadPos = 0;
	m_dwLastReadPos = 0; //m_uncompressedSize*(m_framesPerPeriod-1);
	m_dwLastBufferPos = m_dwLastReadPos;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::CleanupForReset"
HRESULT CClientRecordSubSystem::CleanupForReset()
{
	HRESULT hr;
	
	if( m_converter != NULL )
	{
		m_converter->Release();
		m_converter = NULL;
	}

	if( m_clientEngine->m_audioRecordBuffer )
	{
	    // Stop recording
	    m_clientEngine->m_audioRecordBuffer->Stop();

		if( m_fRecordVolumeSaved )
		{
			m_clientEngine->m_audioRecordBuffer->SetVolume( m_lSavedVolume );
		}
	}

	// Deinit and cleanup the AGC and VA algorthms
	if (m_pagcva != NULL)
	{
		hr = m_pagcva->Deinit();
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Deinit error on AGC and/or VA algorithm, code: %i", hr);
		}
		delete m_pagcva;
		m_pagcva = NULL;
	}
	else
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unexpected NULL pointer for AGC/VA algorithm");
	}

	if( m_pbConstructBuffer != NULL )
	{
		delete [] m_pbConstructBuffer;
		m_pbConstructBuffer = NULL;
	}

	if( m_prgdvidTargetCache )
	{
		delete [] m_prgdvidTargetCache;
		m_prgdvidTargetCache = NULL;
		m_dwTargetCacheSize = 0;
	   	m_dwTargetCacheEntries = 0;
	}

	return DV_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::~CClientRecordSubSystem"
// CClientRecordSubSystem
//
// This is the destructor for the CClientRecordSubSystem
// class.  It cleans up the allocated memory for the class
// and stops the recording device.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CClientRecordSubSystem::~CClientRecordSubSystem()
{
	HRESULT hr;

	CleanupForReset();

	CompleteStats();

	m_dwSignature = VSIG_CLIENTRECORDSYSTEM_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::IsMuted"
BOOL CClientRecordSubSystem::IsMuted()
{
	// If the notification of the local player hasn't been processed and we're in peer to peer mode, don't
	// allow recording to start until after the player has been indicated
	if( !m_clientEngine->m_fLocalPlayerAvailable )
	{
		DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "Local player has not yet been indicated, ignoring frame" );
		return TRUE;
	}
	
	BOOL fMuted =  FALSE;

//    if(m_clientEngine->m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_TESTMODE  )
//  {
        if( m_dwFrameCount < RECORDTEST_NUM_FRAMESBEFOREVOICE )
        {
            DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "Skipping first %d frames for startup burst", RECORDTEST_NUM_FRAMESBEFOREVOICE );
            m_dwFrameCount++;
            return TRUE;
        }
//  }
    
	if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION )
	{
		DNEnterCriticalSection( &m_clientEngine->m_lockPlaybackMode );

		if( (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_RECORDMUTE) ||
		    (m_clientEngine->m_dwEchoState == DVCECHOSTATE_PLAYBACK) )
		{
			fMuted = TRUE;
		}

		DNLeaveCriticalSection( &m_clientEngine->m_lockPlaybackMode );
	}
	else
	{
		fMuted = (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_RECORDMUTE);
	}

	return fMuted;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::StartMessage()"
void CClientRecordSubSystem::StartMessage() 
{
	BYTE bPeakLevel;
	
	if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED || 
	   m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED )
 	{
 		m_pagcva->PeakResults(&bPeakLevel);
 	}
 	else
 	{
 		bPeakLevel = 0;
 	}

 	DVMSG_RECORDSTART dvRecordStart;
 	dvRecordStart.dwPeakLevel = bPeakLevel;
 	dvRecordStart.dwSize = sizeof( DVMSG_RECORDSTART );
 	dvRecordStart.pvLocalPlayerContext = m_clientEngine->m_pvLocalPlayerContext;
 	
	m_clientEngine->NotifyQueue_Add( DVMSGID_RECORDSTART, &dvRecordStart, sizeof( DVMSG_RECORDSTART ) );

	DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Starting Message" );

	// STATSBLOCK: Begin
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwNumMessages++;
	// STATSBLOCK: End
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::EndMessage()"
void CClientRecordSubSystem::EndMessage()
{
	BYTE bPeakLevel;
	
	if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED || 
	   m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED )
 	{
 		m_pagcva->PeakResults(&bPeakLevel);
 	}
 	else
 	{
 		bPeakLevel = 0;
 	}

	// STATBLOCK: Begin
	if( m_seqNum > m_clientEngine->m_pStatsBlob->m_recStats.m_dwMLMax )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwMLMax = m_seqNum;
	}

	if( m_seqNum < m_clientEngine->m_pStatsBlob->m_recStats.m_dwMLMin )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwMLMin = m_seqNum;
	}

	m_clientEngine->m_pStatsBlob->m_recStats.m_dwMLTotal += m_seqNum;
	// STATBLOCK: End

	DVMSG_RECORDSTOP dvRecordStop;
	dvRecordStop.dwPeakLevel = bPeakLevel;
	dvRecordStop.dwSize = sizeof( DVMSG_RECORDSTOP );
 	dvRecordStop.pvLocalPlayerContext = m_clientEngine->m_pvLocalPlayerContext;	
	
	m_clientEngine->NotifyQueue_Add( DVMSGID_RECORDSTOP, &dvRecordStop, sizeof( DVMSG_RECORDSTOP ) );

	m_msgNum++;
	m_seqNum = 0;	

	DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Ending Message" );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::CheckVA()"
BOOL CClientRecordSubSystem::CheckVA()
{
#ifdef __USENEWVA

	// We've been muted, turn off the VA
	if( IsMuted() )
	{
		m_dwSilentTime = m_dwSilenceTimeout+1;	
		return FALSE;
	}

	BOOL m_fVoiceDetected;
	m_pagcva->VAResults(&m_fVoiceDetected);
	if (!m_fVoiceDetected)
	{
		// This prevents wrap-around on silence timeout
		if( m_dwSilentTime <= m_dwSilenceTimeout )
		{
			m_dwSilentTime += m_dwFrameTime;
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "### Silence Time to %d", m_dwSilentTime );		

		if( m_dwSilentTime > m_dwSilenceTimeout )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "### Silence Time exceeded %d", m_dwSilenceTimeout );				

			if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION )
			{
				// If we're in the idle state, go to the recording state
				DNEnterCriticalSection( &m_clientEngine->m_lockPlaybackMode );

				if( m_clientEngine->m_dwEchoState == DVCECHOSTATE_RECORDING )
				{
					DPFX(DPFPREP,  RECORD_SWITCH_DEBUG_LEVEL, "%%%% Switching to idle mode" ); 			
					m_clientEngine->m_dwEchoState = DVCECHOSTATE_IDLE;
				}

				DNLeaveCriticalSection( &m_clientEngine->m_lockPlaybackMode );
			}

			return FALSE;
		}
	}
	else
	{
		m_dwSilentTime = 0;
		DPFX(DPFPREP,  DVF_INFOLEVEL, "### Silence Time to 0" );
		DPFX(DPFPREP,  DVF_INFOLEVEL, "### Transmit!!!!" );
	}

	if( m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_ECHOSUPPRESSION )
	{
		// If we're in the idle state, go to the recording state
		DNEnterCriticalSection( &m_clientEngine->m_lockPlaybackMode );

		if( m_clientEngine->m_dwEchoState == DVCECHOSTATE_IDLE )
		{
			DPFX(DPFPREP,  RECORD_SWITCH_DEBUG_LEVEL, "%%%% Switching to recording mode" ); 				
			m_clientEngine->m_dwEchoState = DVCECHOSTATE_RECORDING;
		}

		DNLeaveCriticalSection( &m_clientEngine->m_lockPlaybackMode );
	}

	return TRUE;
#else
	m_peakCheck = TRUE;

	return !DetectSilence( m_bufferPtr, m_uncompressedSize, m_eightBit, 32, m_clientEngine->m_dwActivatePowerLevel, m_clientEngine->m_bLastPeak );
#endif
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::DoAGC"
HRESULT CClientRecordSubSystem::DoAGC() 
{
	// let AGC have a bash at changing the volume, but only if AGC is enabled in the current client config.
	if (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME 
		&& !(m_clientEngine->m_dvSoundDeviceConfig.dwFlags & DVSOUNDCONFIG_NORECVOLAVAILABLE) )
	{

		// get the current hardware volume level - this will allow us to track "outside" changes
		// to the volume control. e.g. The user find the volume is too low, and manually drags the 
		// volume control's volume slider up a bit. We won't become totally confused, since we're 
		// checking the hardware level here.
		m_clientEngine->m_audioRecordBuffer->GetVolume( &(m_clientEngine->m_dvClientConfig.lRecordVolume) );

		LONG lNewVolume;
		m_pagcva->AGCResults(m_clientEngine->m_dvClientConfig.lRecordVolume, &lNewVolume, m_transmitFrame);

		// set the current hardware volume level, but only if it has changed
		if (m_clientEngine->m_dvClientConfig.lRecordVolume != lNewVolume)
		{
			// Problem: due to the convertion of logarithmic to linear
			// volume settings, there may be a rounding error at low 
			// volumes. So, AGC will try to make a small volume adjustment
			// that results in NO adjustment due to rounding, and it can't
			// work it's way out of the hole.
			// 
			// So - if AGC tried to uptick or downtick the volume, make
			// sure it worked!
			LONG lOrgVolume;
			LONG lVolumeDelta;
			LONG lNewHWVolume;
			lOrgVolume = m_clientEngine->m_dvClientConfig.lRecordVolume;
			lVolumeDelta = lNewVolume - lOrgVolume;
			lNewHWVolume = lOrgVolume;
			while(1)
			{
				m_clientEngine->m_dvClientConfig.lRecordVolume = lNewVolume;
				DPFX(DPFPREP, DVF_INFOLEVEL, "AGC: Setting volume to %i", lNewVolume);
				m_clientEngine->m_audioRecordBuffer->SetVolume(lNewVolume);
				m_clientEngine->m_audioRecordBuffer->GetVolume(&lNewHWVolume);

				if (lNewHWVolume == lOrgVolume)
				{
					// The value did not change, so we're hitting a rounding
					// error.

					// Make sure we're not already at the min or max
					if (lNewVolume == DSBVOLUME_MIN || lNewVolume == DSBVOLUME_MAX)
					{
						// There's nothing more we can do. Give up.
						break;
					}

					// Add another delta to the new volume, and try again.
					lNewVolume += lVolumeDelta;
					if (lNewVolume > DSBVOLUME_MAX)
					{
						lNewVolume = DSBVOLUME_MAX;
					}
					if (lNewVolume < DSBVOLUME_MIN)
					{
						lNewVolume = DSBVOLUME_MIN;
					}
				}
				else
				{
					// The value changed, so we're done.
					break;
				}
			}
		}
	}
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::RecordFSM"
HRESULT CClientRecordSubSystem::RecordFSM() 
{
	
	if( m_fIgnoreFrame )
	{
		return DV_OK;
	}

	// In this case we NEVER transmit
	// Shortcut to simplify the other cases
	if( IsMuted() || !IsValidTarget() )
	{
		// Go immediately to IDLE
		DPFX(DPFPREP,  DVF_INFOLEVEL, "### IsMuted || IsValidTarget --> IDLE" );
		m_recordState = RECORDSTATE_IDLE;
	}

	if( !IsMuted() )
	{
		// before we analyze the data, push down the current
		// relevant portions of the client config structure.
		m_pagcva->SetSensitivity(m_clientEngine->m_dvClientConfig.dwFlags, m_clientEngine->m_dvClientConfig.dwThreshold);
		m_pagcva->AnalyzeData(m_bufferPtr, m_uncompressedSize);
	}

	m_transmitFrame = FALSE;	

	switch( m_recordState )
	{
	case RECORDSTATE_IDLE:

		DPFX(DPFPREP,  DVF_INFOLEVEL, "### STATE: IDLE" );

		if( !IsMuted() && IsValidTarget() )
		{
			if( IsPTT() )
			{
				m_recordState = RECORDSTATE_PTT;
				m_transmitFrame = TRUE;
			}
			else
			{
				m_transmitFrame = CheckVA();

				if( m_transmitFrame )
				{
					m_recordState = RECORDSTATE_VA;
				}
			}
		}

		break;
		
	case RECORDSTATE_VA:

		DPFX(DPFPREP,  DVF_INFOLEVEL, "### STATE: VA" );	

		if( IsPTT() )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "### VA --> PTT" );				
			m_recordState = RECORDSTATE_PTT;
			m_transmitFrame = TRUE;
		}
		else
		{
			m_transmitFrame = CheckVA();
			if (!m_transmitFrame)
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "### !VA --> IDLE" );		
				m_recordState = RECORDSTATE_IDLE;
			}
		}

		break;

	case RECORDSTATE_PTT:

		DPFX(DPFPREP,  DVF_INFOLEVEL, "### STATE: PTT" );

		if( IsVA() )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "### PTT --> VA" );				
			m_recordState = RECORDSTATE_VA;
			m_transmitFrame = CheckVA();
		}
		else
		{
			m_transmitFrame = TRUE;
		}

		break;
	}

	// Now that we've figured out if we're transmitting or not, do the AGC
	DoAGC();

	// Message Ended
	if( m_lastFrameTransmitted && !m_transmitFrame )
	{
		EndMessage();
	}
	// Message Started
	else if( !m_lastFrameTransmitted && m_transmitFrame )
	{
		StartMessage();
	}
	// Message Continuing
	else
	{
		// If the target has changed since the last frame
		if( m_clientEngine->m_dwTargetVersion != m_dwLastTargetVersion )
		{
			// If we're going to be transmitting
			if( m_transmitFrame )
			{
				EndMessage();
				StartMessage();
			}
		}
	}

	m_lastFrameTransmitted = m_transmitFrame;
	m_dwLastTargetVersion = m_clientEngine->m_dwTargetVersion;

	// Save the peak level to propogate up to the app
	if( m_fIgnoreFrame )
	{
		m_clientEngine->m_bLastPeak = 0;
	}
	else
	{
		m_pagcva->PeakResults(&(m_clientEngine->m_bLastPeak));
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::ResetForLockup"
// Reset For Lockup
//
// This function is called when an amount of time specified
// by the timeout is exceeded since the last movement of the
// recording buffer
//
// Parameters:
// N/A
//
// Returns:
// hr
//
HRESULT CClientRecordSubSystem::ResetForLockup()
{
	HRESULT hr;
	DWORD dwBufferPos;
	
	Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Detected!  Attempting RESET" );
	
	hr = m_clientEngine->m_audioRecordBuffer->Stop();

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Stop() Failed hr=0x%x", hr );
	}
	else
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Stop() worked", hr );
	}

	hr = m_clientEngine->m_audioRecordBuffer->Record( TRUE );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Record() failed hr=0x%x", hr );		

		// Cleanup for a FULL recording subsystem reset
		hr = CleanupForReset();

		if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Unable to cleanup for reset hr=0x%x", hr );
			return hr;
		}

		// Destroy / stop etc old buffer
		delete m_clientEngine->m_audioRecordBuffer;
		m_clientEngine->m_audioRecordBuffer = NULL;

		// Will now re-attempt to re-acquire the device a total of RECORD_RESET_ALLOC_ATTEMPTS times.  
		for( DWORD dwAttempt = 0; dwAttempt < RECORD_RESET_ALLOC_ATTEMPTS; dwAttempt++ )
		{

			// Ok.  So why's this sleep here?
			//
			// Turns out on some systems / drivers destroying the buffer as above and then immediately trying to create a new
			// one returns a DSERR_ALLOCATED (which ends up causing a session lost w/DVERR_RECORDSYSTEMERROR).  There
			// is likely some kind of timing problem in the drivers effected.  Adding this sleep alleviates the problem probably
			// because it gives the driver time to reset.
			//
			// The problem itself is hard to repro, so don't assume removing the assert and not seeing the problem means it
			// doesn't happen anymore.
			//
			Sleep( RECORD_RESET_PAUSE );

			// Create a new one
			hr = InitializeRecordBuffer( m_clientEngine->m_dvSoundDeviceConfig.hwndAppWindow, m_clientEngine->m_lpdvfCompressionInfo, 
				                    m_clientEngine->m_audioRecordDevice, &m_clientEngine->m_audioRecordBuffer, 
				                    m_clientEngine->m_dvSoundDeviceConfig.dwFlags ); 

			if( hr == DSERR_ALLOCATED )
			{
				Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Unable to rebuild capture object, re-attempting.." );
				continue;
			}
			else if( FAILED( hr ) )
			{
				DSASSERT( FALSE );				
				Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Unable to restart locked up recording buffer hr=0x%x", hr );
				return hr;
			}
			else if( SUCCEEDED(hr) )
			{
				break;
			}
		}

		DSASSERT( SUCCEEDED( hr ) );

		// Restart the entire recording sub-system
		hr = Initialize();

		if( FAILED( hr ) )
		{
			Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Unable to re-initialize recording sub-system hr=0x%x", hr );
			return hr;
		}

		Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Full reset worked!" );
				
	}
	else
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "LOCKUP: Start() succeeded" );
	}

	BOOL fLostFocus;

	// We're going to ignore focus results because it will be picked up by the next
	// pass through the loop.
	//
	hr = m_clientEngine->m_audioRecordBuffer->GetCurrentPosition( &dwBufferPos, &fLostFocus );

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Get Current position failed" );
		return hr;
	}	

	m_dwLastReadPos = dwBufferPos;  //(m_uncompressedSize*(m_framesPerPeriod-1));	
	m_dwNextReadPos = dwBufferPos; // 0;

	m_dwLastBufferPos = dwBufferPos;
	m_dwLastFrameTime = GetTickCount();

	// Reset the record count -- this routine can take some time so the record
	// count will queue up on a reset.  Don't want too many queued events or
	// we could end up with a false lockup detection.
	//
	ResetEvent( m_clientEngine->m_thTimerInfo.hRecordTimerEvent );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::GetNextFrame"
// GetNextFrame
//
// This function retrieves the next frame from the recording input
// and detects recording lockup.  If a recording lockup is detected
// then this function attempts to restart the recording system
// 3 times.  If it fails the recording system is considered to be
// locked up.
//
// This was implemented as a fix for SB Live! cards which periodically
// lockup while recording.  (Also noticed on Aureal Vortex cards).
//
// Parameters:
// N/A
//
// Returns:
// bool - true if next frame was retrieved, false if lockup detected
HRESULT CClientRecordSubSystem::GetNextFrame( LPBOOL pfContinue ) 
{
	HRESULT hr;
	DWORD dwBufferPos;

	PVOID pBufferPtr1, pBufferPtr2;
	DWORD dwSizeBuffer1, dwSizeBuffer2;
	DWORD dwCurrentTime;
	BOOL fLostFocus;
	DWORD dwTSLM;

	hr = m_clientEngine->m_audioRecordBuffer->GetCurrentPosition( &dwBufferPos, &fLostFocus );

	if( FAILED( hr ) && !fLostFocus )
	{
		DSASSERT( FALSE );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Get Current position failed" );
		return hr;
	}

	// Get the current time
	dwCurrentTime = GetTickCount();

	// The focus has changed!
	if( fLostFocus != m_fLostFocus )
	{
		m_fLostFocus = fLostFocus;					

		// We just lost focus.  
		if( fLostFocus )
		{
			DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Buffer just lost focus.  No more input until focus returns" );

			// Keep frame time up to date since we are about to exit
			m_dwLastFrameTime = dwCurrentTime;	

			// Notify the application
			m_clientEngine->NotifyQueue_Add( DVMSGID_LOSTFOCUS, NULL, 0 );	

			// If we're in a message, end it.  Won't be any more input until focus returns.
			if( m_lastFrameTransmitted )
			{
				EndMessage();
				m_lastFrameTransmitted = FALSE;
			}

			// Set the peak levels to 0
			m_clientEngine->m_bLastPeak	= 0;		

			// To ignore the frame
			m_fIgnoreFrame = TRUE;

			// To shortcircuit recording loop
			*pfContinue = FALSE;

			// Drop the data remaining in the buffer
			if( dwBufferPos < m_uncompressedSize )
			{
				m_dwLastReadPos = (m_dwFullBufferSize) - (m_uncompressedSize - dwBufferPos);
			}
			else
			{
				m_dwLastReadPos = (dwBufferPos - m_uncompressedSize );
			}
			
			m_dwNextReadPos = dwBufferPos;

			DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Moving last read to %d and next to %d", m_dwLastReadPos, m_dwNextReadPos );

			return DV_OK;
		}
		// We just gained focus... continue as if normal.
		else
		{
			m_clientEngine->NotifyQueue_Add( DVMSGID_GAINFOCUS, NULL, 0 );											
		}			
	} 

	if( fLostFocus )
	{
		// Set the peak levels to 0
		m_clientEngine->m_bLastPeak	= 0;		

		// Ignore this frame
		m_fIgnoreFrame = TRUE;

		// Do not continue in recording loop until next wakeup
		*pfContinue = FALSE;	

		// Keep frame time up to date since we are about to exit
		m_dwLastFrameTime = dwCurrentTime;	

		// Track the moving buffer (if it's moving) for the case of WDM
		// drivers on Millenium that continue to record
		if( dwBufferPos < m_uncompressedSize )
		{
			m_dwLastReadPos = (m_dwFullBufferSize) - (m_uncompressedSize - dwBufferPos);
		}
		else
		{
			m_dwLastReadPos = (dwBufferPos - m_uncompressedSize );
		}
		
		m_dwNextReadPos = dwBufferPos;		

		return DV_OK;
	}
	
	// STATSBLOCK: Begin
	dwTSLM = dwCurrentTime - m_dwLastFrameTime;
	
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwRTSLMTotal += dwTSLM;
	
	if( dwTSLM > m_clientEngine->m_pStatsBlob->m_recStats.m_dwRTSLMMax )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwRTSLMMax = dwTSLM;
	}

	if( dwTSLM < m_clientEngine->m_pStatsBlob->m_recStats.m_dwRTSLMMin )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwRTSLMMin = dwTSLM;	
	}	
	// STATSBLOCK: End

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Current Pos: %d, Last Pos: %d", dwBufferPos, m_dwLastBufferPos );

	// Calculate how much buffer we have to catch up for.  
	if( m_dwNextReadPos > dwBufferPos )
	{
		dwSizeBuffer2 = ((m_dwFullBufferSize)-m_dwNextReadPos)+dwBufferPos;
	}
	else
	{
		dwSizeBuffer2 = dwBufferPos - m_dwNextReadPos;	
	}	

	// See if a lockup occurred which means the buffer hasn't moved
	//
	// We only check for a lockup however when we aren't in the process of "Catching up".  If we've
	// fallen behind because we lost CPU, and we're several frames behind we're going to run through
	// this section several times to catch up.  The issue is that when we run several times there is
	// very little time between the runs and therefore it is perfectly reasonable for DirectSound
	// to have not moved it's buffer pointer.
	// 
	if( m_dwLastBufferPos == dwBufferPos && 
		dwSizeBuffer2 < m_uncompressedSize )	// Make sure we're not just "catching up".
	{
		m_dwPassesSincePosChange++;

		// The lower this number is, the better the experience for people with bad drivers that lockup.
		// The higher it is, the more we think we've locked up in situations where the buffer legitimately
		// doesn't move, like high CPU usage, or when the app is in the debugger.
		if( (dwCurrentTime - m_dwLastFrameTime) >= RECORD_LOCKUP_TIMEOUT )
		{
			m_dwPassesSincePosChange = 0;

			// We've been RECORD_MAX_RESETS passes through here without the buffer moving, reset

			if( m_dwResetCount > RECORD_MAX_RESETS )
			{
				DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Maximum Resets exceeded" );
				return DVERR_RECORDSYSTEMERROR;
			}
			
			DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Lockup Detected %d ms since last movement", dwCurrentTime - m_dwLastFrameTime );

			// STATSBLOCK: Begin		
			DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: Record: Recording buffer has stopped moving." );		
			// STATSBLOCK: End

			hr = ResetForLockup();

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, Reset for lockup failed hr=0x%x", hr );
				return hr;
			}

			m_fIgnoreFrame = TRUE;
			*pfContinue = FALSE;
			m_dwResetCount++;

			// STATSBLOCK: Begin
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRRTotal++;

			if( m_dwResetCount < m_clientEngine->m_pStatsBlob->m_recStats.m_dwRRMin )
			{
				m_clientEngine->m_pStatsBlob->m_recStats.m_dwRRMin = m_dwResetCount;
			}

			if( m_dwResetCount > m_clientEngine->m_pStatsBlob->m_recStats.m_dwRRMax )
			{
				m_clientEngine->m_pStatsBlob->m_recStats.m_dwRRMax = m_dwResetCount;
			}
			// STATSBLOCK: End

			// Keep frame time up to date since we are about to exit
			//
			// NOTE: This needs to be GetTickCount() because Reset() can take 100's of ms.
			m_dwLastFrameTime = GetTickCount();
			
			return DV_OK;
		}
	}
	else
	{
		m_dwPassesSincePosChange = 0;
	}

	// There was no lockup, and we are in focus, continue
	m_dwLastBufferPos = dwBufferPos;

	// Calc Delta in bytes of buffer read pointer
	if( m_dwLastBufferPos > dwBufferPos )
	{
		dwSizeBuffer1 = ((m_dwFullBufferSize)-m_dwLastBufferPos)+dwBufferPos;
	}
	else
	{
		dwSizeBuffer1 = dwBufferPos - m_dwLastBufferPos;
	}

	// The position did not move enough for a full frame.
	if( dwSizeBuffer2 < m_uncompressedSize )
	{
		m_fIgnoreFrame = TRUE;
		*pfContinue = FALSE;

		DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, %d, %d, %d, %d, %d, %d (SKIPPING)", 
			 dwBufferPos, 
			 dwSizeBuffer1,
			 dwCurrentTime - m_dwLastFrameTime,
			 m_dwNextReadPos, 
			 dwSizeBuffer2,
			 m_uncompressedSize );
	}
	else
	{
		DPFX(DPFPREP,  RRI_DEBUGOUTPUT_LEVEL, "RRI, %d, %d, %d, %d, %d, %d", 
			 dwBufferPos, 
			 dwSizeBuffer1,
			 dwCurrentTime - m_dwLastFrameTime,
			 m_dwNextReadPos, 
			 dwSizeBuffer2,
			 m_uncompressedSize );

		m_dwResetCount = 0;		

		// STATSBLOCK: BEGIN
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMMSTotal += (dwCurrentTime - m_dwLastFrameTime);

		if( (dwCurrentTime - m_dwLastFrameTime) > m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMMSMax )
		{
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMMSMax = dwCurrentTime - m_dwLastFrameTime;
		}

		if( m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMMSMax > 70000 )
		{
		}

		if( (dwCurrentTime - m_dwLastFrameTime) < m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMMSMin )
		{
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMMSMin = dwCurrentTime - m_dwLastFrameTime;
		}
		
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMBTotal += dwSizeBuffer1;

		if( dwSizeBuffer1 > m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMBMax )
		{
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMBMax = dwSizeBuffer1;
		}

		if( dwSizeBuffer1 < m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMBMin )
		{
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRMBMin = dwSizeBuffer1;
		}		
		
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwRLTotal += dwSizeBuffer2;

		if( dwSizeBuffer2 > m_clientEngine->m_pStatsBlob->m_recStats.m_dwRLMax )
		{
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRLMax = dwSizeBuffer2;
		}

		if( dwSizeBuffer2 < m_clientEngine->m_pStatsBlob->m_recStats.m_dwRLMin )
		{
			m_clientEngine->m_pStatsBlob->m_recStats.m_dwRLMin = dwSizeBuffer2;
		}		
		// STATSBLOCK: END
	
		// Get the next block of audio data and construct it into the buffer
		hr = m_clientEngine->m_audioRecordBuffer->Lock( m_dwNextReadPos, m_uncompressedSize, &pBufferPtr1, &dwSizeBuffer1, &pBufferPtr2, &dwSizeBuffer2, 0 );

		if( FAILED( hr ) )
		{
			DSASSERT( FALSE );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error locking buffer: loc=%d size=%d hr=0x%x", m_dwNextReadPos, m_uncompressedSize, hr );
			return hr;
		}

		memcpy( m_pbConstructBuffer, pBufferPtr1, dwSizeBuffer1 );

		if( dwSizeBuffer2 > 0 )
		{
			memcpy( &m_pbConstructBuffer[dwSizeBuffer1], pBufferPtr2, dwSizeBuffer2 );		
		}

		hr = m_clientEngine->m_audioRecordBuffer->UnLock( pBufferPtr1, dwSizeBuffer1, pBufferPtr2, dwSizeBuffer2 );

		if( FAILED( hr ) )
		{
			DSASSERT( FALSE );
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error unlocking buffer hr=0x%x", hr );
			return hr;
		}

		m_bufferPtr = m_pbConstructBuffer;

		m_fIgnoreFrame = FALSE;		

		m_dwLastReadPos = m_dwNextReadPos;	
		m_dwNextReadPos += m_uncompressedSize;
		m_dwNextReadPos %= (m_dwFullBufferSize);

		// Update the last frame time
		m_dwLastFrameTime = dwCurrentTime;

		*pfContinue = TRUE;
	}

    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::TransmitFrame"
// TransmitFrame
//
// This function looks at the state of the FSM, and if the latest
// frame is to be transmitted it compresses it and transmits
// it to the server (cleint/server mode) or to all the players
// (or player if whispering) in peer to peer mode.  If the frame
// is not to be transmitted this function does nothing.  
//
// It is also responsible for ensuring any microphone clicks are
// mixed into the audio stream.
//
// This function also updates the transmission statisics and
// the current transmission status.  
//
// Parameters:
// N/A
//
// Returns:
// bool - always returns true at the moment
HRESULT CClientRecordSubSystem::TransmitFrame() 
{
	HRESULT hr = DV_OK;

    if( m_transmitFrame && !m_fIgnoreFrame ) 
    {
    	// STATSBLOCK: Begin
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwSentFrames++;
		// STATSBLOCK: End
		
		if( m_clientEngine->m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
		{
			hr = BuildAndTransmitSpeechHeader(FALSE);
		}
		else if( m_clientEngine->m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO )
		{
			hr = BuildAndTransmitSpeechHeader(TRUE);
		}
		else
		{
			hr = BuildAndTransmitSpeechWithTarget(TRUE);
		}
	}
	else
	{
    	// STATSBLOCK: Begin
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwIgnoredFrames++;
		// STATSBLOCK: End	
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::BuildAndTransmitSpeechHeader"
HRESULT CClientRecordSubSystem::BuildAndTransmitSpeechHeader( BOOL bSendToServer )
{
	PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader;
	HRESULT hr;
	DWORD dwTargetSize;
	DWORD dwStartTime;
	DWORD dwCompressTime;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	LPVOID pvSendContext;

	pBufferDesc = m_clientEngine->GetTransmitBuffer( sizeof(DVPROTOCOLMSG_SPEECHHEADER)+COMPRESSION_SLUSH+m_compressedSize, &pvSendContext );

	if( pBufferDesc == NULL )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to get buffer for transmission" );
	    return DVERR_OUTOFMEMORY;
	}

	pdvSpeechHeader = (PDVPROTOCOLMSG_SPEECHHEADER) pBufferDesc->pBufferData;

	pdvSpeechHeader->dwType = DVMSGID_SPEECH;		
	pdvSpeechHeader->bMsgNum = m_msgNum;
	pdvSpeechHeader->bSeqNum = m_seqNum;

	DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Record:  Msg [%d] Seq [%d]", m_msgNum, m_seqNum );

	dwTargetSize = m_compressedSize;

	dwStartTime = GetTickCount();
	
    hr = m_converter->Convert( (BYTE *) m_bufferPtr, m_uncompressedSize, (BYTE *) &pdvSpeechHeader[1], &dwTargetSize, FALSE );

    if( FAILED( hr ) )
    {
        m_clientEngine->ReturnTransmitBuffer( pvSendContext );        
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to perform conversion hr=0x%x", hr );
    	return hr;
    }

    dwCompressTime = GetTickCount() - dwStartTime;

    DPFX(DPFPREP,  DVF_INFOLEVEL, "Compressed %d bytes to %d taking %d ms", m_uncompressedSize, dwTargetSize, dwCompressTime );

	// STATSBLOCK: Begin
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTTotal += dwCompressTime;

    if( dwCompressTime < m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMin )
    {
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMin = dwCompressTime;  	
    }

    if( dwCompressTime > m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMax )
    {
    	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMax = dwCompressTime;
    }

	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSTotal += dwTargetSize;

	if( dwTargetSize < m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMin )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMin = dwTargetSize;
	}

	if( dwTargetSize > m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMax )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMax = dwTargetSize;	
	}

	// Header is fixed size
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSTotal += sizeof( DVPROTOCOLMSG_SPEECHHEADER );
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMax = sizeof( DVPROTOCOLMSG_SPEECHHEADER );
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMin = sizeof( DVPROTOCOLMSG_SPEECHHEADER );	
	
	// STATSBLOCK: End

    if( m_clientEngine->m_dwNumTargets == 0 )
    {
    	DPFX(DPFPREP,  DVF_INFOLEVEL, "Targets set to NONE since FSM.  Not transmitting" );
		m_clientEngine->ReturnTransmitBuffer( pvSendContext );
    	return DV_OK;
    }
    else
    {
	    pBufferDesc->dwBufferSize = sizeof(DVPROTOCOLMSG_SPEECHHEADER)+dwTargetSize;    
	        
       	if( bSendToServer )
    	{
	    	DPFX(DPFPREP,  DVF_INFOLEVEL, "Transmitting %d bytes to server", pBufferDesc->dwBufferSize );    	
			hr = m_clientEngine->m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, 0 );
		}
		else
		{
			// Copy the target list to a cache so we can drop the lock during the send.
		    DNEnterCriticalSection( &m_clientEngine->m_csTargetLock );
			if( m_clientEngine->m_dwNumTargets > m_dwTargetCacheSize )
			{
				if( m_prgdvidTargetCache )
					delete [] m_prgdvidTargetCache;
				m_dwTargetCacheSize = m_clientEngine->m_dwNumTargets;
				m_prgdvidTargetCache = new DVID[m_dwTargetCacheSize];

				if( !m_prgdvidTargetCache )
				{
				    DNLeaveCriticalSection( &m_clientEngine->m_csTargetLock );														
					DPFERR( "Out of memory" );
					return DVERR_OUTOFMEMORY;
				}
			}
			memcpy( m_prgdvidTargetCache, m_clientEngine->m_pdvidTargets, sizeof(DVID)*m_clientEngine->m_dwNumTargets );
			m_dwTargetCacheEntries = m_clientEngine->m_dwNumTargets;
		    DNLeaveCriticalSection( &m_clientEngine->m_csTargetLock );									

			// the target cache (prgdvidTargetCache) doesn't need protection since it is only accessed by one thread at a time.
		    
	    	DPFX(DPFPREP,  DVF_INFOLEVEL, "Transmitting %d bytes to target list", pBufferDesc->dwBufferSize );    	
			hr = m_clientEngine->m_lpSessionTransport->SendToIDS( m_prgdvidTargetCache, m_dwTargetCacheEntries,
	                                                          	  pBufferDesc, pvSendContext, 0 );
		}

		if( hr == DVERR_PENDING )
		{
		    hr = DV_OK;
		}
        else if ( FAILED( hr ))
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Send failed hr=0x%x", hr );
		}

	    m_seqNum++;	
		
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::BuildAndTransmitSpeechWithTarget"
HRESULT CClientRecordSubSystem::BuildAndTransmitSpeechWithTarget( BOOL bSendToServer )
{
	PDVPROTOCOLMSG_SPEECHWITHTARGET pdvSpeechWithTarget;
	HRESULT hr;
	DWORD dwTargetSize;
	DWORD dwTransmitSize;
	DWORD dwTargetInfoSize;
	PBYTE pbBuilderLoc;
	DWORD dwStartTime;
	DWORD dwCompressTime;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	LPVOID pvSendContext;

	dwTransmitSize = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET );

	// Calculate size we'll need for storing the targets
    DNEnterCriticalSection( &m_clientEngine->m_csTargetLock );

   	dwTargetInfoSize = sizeof( DVID ) * m_clientEngine->m_dwNumTargets;    

    if( dwTargetInfoSize == 0 )
    {
    	DPFX(DPFPREP,  DVF_INFOLEVEL, "Targets set to NONE since FSM.  Not transmitting" );
	    DNLeaveCriticalSection( &m_clientEngine->m_csTargetLock );      	

    	return DV_OK;
    }
    else
    {
		dwTransmitSize += dwTargetInfoSize;	
	}

	DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Record:  Msg [%d] Seq [%d]", m_msgNum, m_seqNum );	

	dwTransmitSize += m_compressedSize;

    pBufferDesc = m_clientEngine->GetTransmitBuffer( sizeof(DVPROTOCOLMSG_SPEECHWITHTARGET)+m_compressedSize+COMPRESSION_SLUSH+dwTransmitSize, &pvSendContext );

	if( pBufferDesc == NULL )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to get buffer for transmission" );
	    return DVERR_OUTOFMEMORY;
	}

	pdvSpeechWithTarget = (PDVPROTOCOLMSG_SPEECHWITHTARGET) pBufferDesc->pBufferData;	
	pbBuilderLoc = (PBYTE) &pdvSpeechWithTarget[1];

	memcpy( pbBuilderLoc, m_clientEngine->m_pdvidTargets, dwTargetInfoSize );

	pdvSpeechWithTarget->dwNumTargets = m_clientEngine->m_dwNumTargets;

	DNLeaveCriticalSection( &m_clientEngine->m_csTargetLock );

 	pbBuilderLoc += dwTargetInfoSize;

	pdvSpeechWithTarget->dvHeader.dwType = DVMSGID_SPEECHWITHTARGET;		
	pdvSpeechWithTarget->dvHeader.bMsgNum = m_msgNum;
	pdvSpeechWithTarget->dvHeader.bSeqNum = m_seqNum;

	dwTargetSize = m_compressedSize;

	dwStartTime = GetTickCount();	

	DPFX(DPFPREP,  DVF_COMPRESSION_DEBUG_LEVEL, "COMPRESS: < %d --> %d ", m_uncompressedSize, dwTargetSize );

    hr = m_converter->Convert( (BYTE *) m_bufferPtr, m_uncompressedSize, (BYTE *) pbBuilderLoc, &dwTargetSize, FALSE );

    if( FAILED( hr ) )
    {
        m_clientEngine->ReturnTransmitBuffer( pvSendContext );
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to perform conversion hr=0x%x", hr );
    	return hr;
    }

    dwCompressTime = GetTickCount() - dwStartTime;

	DPFX(DPFPREP,  DVF_COMPRESSION_DEBUG_LEVEL, "COMPRESS: > %d --> %d %d ms", m_uncompressedSize, dwTargetSize, dwCompressTime );

	// STATSBLOCK: Begin
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTTotal += dwCompressTime;

    if( dwCompressTime < m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMin )
    {
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMin = dwCompressTime;  	
    }

    if( dwCompressTime > m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMax )
    {
    	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMax = dwCompressTime;
    }
    
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSTotal += dwTargetSize;

	if( dwTargetSize < m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMin )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMin = dwTargetSize;
	}

	if( dwTargetSize > m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMax )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMax = dwTargetSize;	
	}

	// Header stats
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSTotal += sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )+dwTargetInfoSize;

	if( sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )+dwTargetInfoSize > m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMax )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMax = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )+dwTargetInfoSize;
	}

	if( sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )+dwTargetInfoSize < m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMin )
	{
		m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMin = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET )+dwTargetInfoSize;
	}	

	// STATSBLOCK: End    

	// We need to transmit header, target info and then speech data
    dwTransmitSize = sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) + dwTargetInfoSize + dwTargetSize;

	pBufferDesc->dwBufferSize = dwTransmitSize;

    hr = m_clientEngine->m_lpSessionTransport->SendToServer( pBufferDesc, pvSendContext, 0 );

    m_seqNum++;	

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
	else if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Send failed hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::IsValidTarget"
BOOL CClientRecordSubSystem::IsValidTarget() 
{ 
	BOOL fValidTarget;
	
	DNEnterCriticalSection( &m_clientEngine->m_csTargetLock );
	
	if( m_clientEngine->m_dwNumTargets > 0 )
	{
		fValidTarget = TRUE;
	}
	else
	{
		fValidTarget = FALSE;
	}
	
	DNLeaveCriticalSection( &m_clientEngine->m_csTargetLock );

	return fValidTarget;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::InitStats"
void CClientRecordSubSystem::InitStats()
{
	// STATSBLOCK: begin
	// Setup record stats
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwFramesPerBuffer = m_framesPerPeriod;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwFrameTime = m_dwFrameTime;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCSMin = 0xFFFFFFFF;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwUnCompressedSize = m_uncompressedSize;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwSilenceTimeout = m_dwSilenceTimeout;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwRPWMin = 0xFFFFFFFF;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwRRMin = 0xFFFFFFFF;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwRTSLMMin = 0xFFFFFFFF;
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwHSMin = 0xFFFFFFFF;	
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwMLMin = 0xFFFFFFFF;	
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwCTMin = 0xFFFFFFFF;
	// STATSBLOCK: End
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::BeginStats"	
void CClientRecordSubSystem::BeginStats()
{
	// STATSBLOCK: Begin
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwTimeStart = GetTickCount();
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwStartLag = m_clientEngine->m_pStatsBlob->m_recStats.m_dwTimeStart-m_clientEngine->m_pStatsBlob->m_dwTimeStart;
	// STATSBLOCK: end
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClientRecordSubSystem::CompleteStats"    
void CClientRecordSubSystem::CompleteStats()
{
	m_clientEngine->m_pStatsBlob->m_recStats.m_dwTimeStop = GetTickCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvrecsub.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ClientRecordSubSystem.h
 *  Content:	Recording sub-system.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/19/99		rodtoll	Modified from original
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 * 08/27/99		rodtoll	General cleanup/Simplification of recording subsystem
 *						Added reset of message when target changes
 *						Fixed recording start/stop notifications 
 * 09/29/99		pnewson Major AGC overhaul
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 11/12/99		rodtoll	Updated to use new recording classes, improved error 
 *						handling and new initialize function.  
 *				rodtoll	Added new high CPU handling code for record.  
 * 11/13/99		rodtoll	Added parameter to GetNextFrame
 * 11/18/99		rodtoll	Re-activated recording pointer lockup detection code
 * 01/10/00		pnewson AGC and VA tuning
 * 01/14/2000	rodtoll	Updated to handle new multiple targets
 * 02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected 
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *						Added instrumentation  
 * 04/05/2000   rodtoll Updated to use new async, no buffer copy sends, removed old transmit buffer
 * 04/19/2000   pnewson Fix to make AGC code work properly with VA off
 * 07/09/2000	rodtoll	Added signature bytes
 * 08/18/2000	rodtoll   Bug #42542 - DPVoice retrofit: Voice retrofit locks up after host migration 
 * 08/29/2000	rodtoll	Bug #43553 - Start() returns 0x80004005 after lockup
 *  			rodtoll	Bug #43620 - DPVOICE: Recording buffer locks up on Aureal Vortex (VxD).
 *						Updated reset procedure so it ignores Stop failures and if Start() fails
 *						it tries resetting the recording system.  
 * 08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 * 04/11/2001  	rodtoll	WINBUG #221494 DPVOICE: Updates to lockup detection methods
 *
 ***************************************************************************/
#ifndef __CLIENTRECORDSUBSYSTEM_H
#define __CLIENTRECORDSUBSYSTEM_H


class CAGCVA;

// CClientRecordSubSystem
//
// This class implements the recording subsystem for the BattleCom client.
// It works closely with the control CShadowClientControl object to 
// provide the recording / compression and transmissions portions of the
// client.  This includes addition of microphone clicks to outgoing
// audio streams when appropriate.
//
// The core of the recording system is a finite state machine which 
// is used to provide a way of managing the recording system's
// state and to provide smooth transitions between various 
// states.  
//
// It looks to the CShadowClientControl object to detect when keys
// are pressed and to provide neccessary parameters.
//
#define VSIG_CLIENTRECORDSYSTEM			'SRCV'
#define VSIG_CLIENTRECORDSYSTEM_FREE	'SRC_'
//
class CClientRecordSubSystem
{
protected: // State Machine States
    typedef enum {
        RECORDSTATE_IDLE = 0,	// Recording is idle, no transmissions required
        RECORDSTATE_VA,			// Voice activated mode
        RECORDSTATE_PTT			// Push to talk mode
    } RecordState;

public:
    CClientRecordSubSystem( CDirectVoiceClientEngine *clientEngine );
    ~CClientRecordSubSystem();

protected:

	friend class CDirectVoiceClientEngine;

	HRESULT Initialize();

    HRESULT GetNextFrame( LPBOOL fContinue );

	BOOL IsMuted();
	BOOL IsValidTarget();
    inline BOOL IsPTT() { return !IsVA(); };
    inline BOOL IsVA() { return (m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED || m_clientEngine->m_dvClientConfig.dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED); };
    
    BOOL CheckVA();
    HRESULT DoAGC();
    void EndMessage();
    void StartMessage();

    HRESULT TransmitFrame();

protected: // FSM
	HRESULT BuildAndTransmitSpeechHeader( BOOL bSendToServer );
	HRESULT BuildAndTransmitSpeechWithTarget( BOOL bSendToServer );
	
    HRESULT RecordFSM();
    HRESULT HandleAutoVolumeAdjust();
	HRESULT CleanupForReset();
    HRESULT ResetForLockup();

	void InitStats();
    void BeginStats();
    void CompleteStats();

protected: 

	DWORD					m_dwSignature;

	DWORD					m_dwSilentTime;			// # of ms that the input has been silent
	DWORD					m_dwFrameTime;			// Amount of ms per frame
	CAGCVA*					m_pagcva;				// Auto Gain control and Voice Activation algorithm

	void					DoFrameCheck();
	
protected:

    RecordState             m_recordState;          // Current state of the FSM
    PDPVCOMPRESSOR          m_converter;           // AudioConverter for outgoing data
    DWORD                   m_uncompressedSize;		// Size of frame in uncompressed format
    DWORD                   m_compressedSize;		// Maximum size in bytes of compressed frame
    BOOL                    m_eightBit;				// Is recording format 8-bit?
    DWORD                   m_remain;				// # of trailing frames we should have
    unsigned char           m_currentBuffer;        // Buffer ID of current recording buffer
    unsigned long           m_framesPerPeriod;      // # of subbuffers in the recording bfufer
    CDirectVoiceClientEngine *m_clientEngine;         // The client engine this subsystem is for
    BOOL                    m_transmitFrame;        // Transmit Current frame?
    unsigned char           *m_bufferPtr;           // Pointer to current buffer?
    DWORD                   m_dwSilenceTimeout;     // Amount of silence in ms before transmissions tops
	BOOL					m_lastFrameTransmitted; 
                                                    // Was the last frame transmitted
	unsigned char			m_msgNum;               // Current message number 
	unsigned char			m_seqNum;               // Current sequence #
    LPBYTE					m_pbConstructBuffer;	
	DWORD					m_dwCurrentPower;		// Power level of the last packet
	DWORD					m_dwLastTargetVersion;	// Version of target info on last frame (to check for changes)
	LONG					m_lSavedVolume;			// System record volume when recording started
	BOOL					m_fRecordVolumeSaved;	// Was the system record volume saved?
	DWORD					m_dwResetCount;
	DWORD					m_dwNextReadPos;
	DWORD					m_dwLastReadPos;
	DWORD					m_dwLastBufferPos;
	DWORD					m_dwPassesSincePosChange;
	BOOL					m_fIgnoreFrame;
	DWORD					m_dwLastFrameTime;		// GetTickCount() at last frame
	BOOL					m_fLostFocus;
	DWORD                   m_dwFrameCount;
	DVID					*m_prgdvidTargetCache;
	DWORD					m_dwTargetCacheSize;
	DWORD					m_dwTargetCacheEntries;
	DWORD					m_dwFullBufferSize;		// Cached version of m_uncompressedSize*m_framesPerPeriod
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsereng.h ===
/*==========================================================================
 * Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 * File:       dvserverengine.h
 * Content:    Definition of class for DirectXVoice Server
 * History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/06/99	rodtoll	Created It
 *  07/21/99	rodtoll Added settings confirm message to protocol.
 *  07/22/99	rodtoll	Added multiple reader/single writer guard to class
 *  07/23/99	rodtoll	Additional members for client/server and multicast
 *	07/26/99	rodtoll	Added support for new interfaces and access for DIRECTVOICESERVEROBJECT
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 *						Added parameter to the GetCompression Func
 * 09/14/99		rodtoll	Added new SetNotifyMask function
 *				rodtoll	Updated Iniitalize parameters to take notification masks.
 * 				rodtoll	Implemented notification masks.  (Allows user to choose which notifications to receive) 
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 11/23/99		rodtoll	Updated Initialize/SetNotifyMask so error checking behaviour is consistant 
 * 12/16/99		rodtoll Fix: Bug #122629 - Host migration broken in unusual configurations.
 *						Updated to use new algorithm described in dvprot.h
 *						- Generate and added host order IDs to player table messages
 *						- Added send of new hostmigrateleave message when shutting down and
 *					      host should migrate
 *						- Sends session lost when shutting down if no one available to take over hosting
 *						- Added new player list message
 *						- Fixed handling of refusing player connections 
 * 01/14/2000	rodtoll	Updated to allow multiple targets for a single player
 *				rodtoll	Updated to use FPM for managing memory for Multicast mode
 *				rodtoll	Updated to use new callback semantics
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 * 04/07/2000   rodtoll Bug #32179 - Prevent registration of > 1 interface
 *              rodtoll Updated to use no copy sends, so handles pooling frames to be sent, proper
 *                      pulling of frames from pools and returns.   
 * 07/09/2000	rodtoll	Added signature bytes
 * 11/16/2000	rodtoll	Bug #40587 - DPVOICE: Mixing server needs to use multi-processors  
 * 11/28/2000	rodtoll	Bug #47333 - DPVOICE: Server controlled targetting - invalid targets are not removed automatically 
 * 04/06/2001	kareemc	Added Voice Defense
 *
 ***************************************************************************/
#ifndef __DVSERVERENGINE_H
#define __DVSERVERENGINE_H


struct DIRECTVOICESERVEROBJECT;
typedef struct _MIXERTHREAD_CONTROL *PMIXERTHREAD_CONTROL;

#define DVSSTATE_NOTINITIALIZED		0x00000000
#define DVSSTATE_IDLE				0x00000001
#define DVSSTATE_STARTUP			0x00000002
#define DVSSTATE_RUNNING			0x00000003
#define DVSSTATE_SHUTDOWN			0x00000004

// CDirectVoiceClientEngine
//
// This class represents the IDirectXVoiceServer interface.
//
#define VSIG_SERVERENGINE		'EVSV'
#define VSIG_SERVERENGINE_FREE	'EVS_'
//
volatile class CDirectVoiceServerEngine: public CDirectVoiceEngine
{

public:
	CDirectVoiceServerEngine( DIRECTVOICESERVEROBJECT *lpObject );
	~CDirectVoiceServerEngine();

public: // IDirectXVoiceServer Interface

	HRESULT HostMigrateStart(LPDVSESSIONDESC lpSessionDesc, DWORD dwHostOrderIDSeed = 0 );
    virtual HRESULT StartSession(LPDVSESSIONDESC lpSessionDesc, DWORD dwFlags, DWORD dwHostOrderIDSeed = 0 );
    virtual HRESULT StopSession(DWORD dwFlags, BOOL fSilent=FALSE, HRESULT hrResult = DV_OK );
    virtual HRESULT GetSessionDesc(LPDVSESSIONDESC lpSessionDescBuffer );
    virtual HRESULT SetSessionDesc(LPDVSESSIONDESC lpSessionDesc );
    HRESULT GetCaps(LPDVCAPS dvCaps);
    HRESULT GetCompressionTypes( LPVOID lpBuffer, LPDWORD lpdwBufferSize, LPDWORD lpdwNumElements, DWORD dwFlags);
    virtual HRESULT SetTransmitTarget(DVID dvidSource, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags);
    virtual HRESULT GetTransmitTarget(DVID dvidSource, LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags );
	virtual HRESULT MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer );    
	virtual HRESULT SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );	

public: // CDirectVoiceEngine Members

	HRESULT Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements );
	virtual BOOL ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize );
	HRESULT StartTransportSession();
	HRESULT StopTransportSession();
	HRESULT AddPlayer( DVID dvID );
	HRESULT RemovePlayer( DVID dvID );
	HRESULT CreateGroup( DVID dvID );
	HRESULT DeleteGroup( DVID dvID );
	HRESULT AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer );
	HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer );

	inline DWORD GetCurrentState() { return m_dwCurrentState; };	

	BOOL	InitClass();
	
public: // packet validation
	inline BOOL ValidateSettingsFlags( DWORD dwFlags );
	inline BOOL ValidatePacketType( PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage );

	
protected: // Protocol Layer Handling (protserver.cpp)

    HRESULT Send_SessionLost( HRESULT hrReason );
    HRESULT Send_HostMigrateLeave( );
    HRESULT Send_HostMigrated();
    HRESULT Send_DisconnectConfirm( DVID dvid, HRESULT hrReason );
    HRESULT Send_DeletePlayer( DVID dvid );
    HRESULT Send_CreatePlayer( DVID dvidTarget, CVoicePlayer *pPlayer );
    HRESULT Send_ConnectRefuse( DVID dvid, HRESULT hrReason );
    HRESULT Send_ConnectAccept( DVID dvid );
	HRESULT SendPlayerList( DVID dvidSource, DWORD dwHostOrderID );
    
	BOOL CheckProtocolCompatible( BYTE ucMajor, BYTE ucMinor, DWORD dwBuild );    

protected:

	HRESULT InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements );	

	void DoPlayerDisconnect( DVID dvidPlayer, BOOL bInformPlayer );
	void TransmitMessage( DWORD dwMessageType, LPVOID lpdvData, DWORD dwSize );
	void SetCurrentState( DWORD dwState );
	HRESULT CreatePlayerEntry( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwHostOrderID, CVoicePlayer **ppPlayer );

	BOOL HandleDisconnect( DVID dvidSource, PDVPROTOCOLMSG_GENERIC lpdvDisconnect, DWORD dwSize );
	BOOL HandleConnectRequest( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREQUEST lpdvConnectRequest, DWORD dwSize );
	BOOL HandleSettingsConfirm( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwSize );
	BOOL HandleSettingsReject( DVID dvidSource, PDVPROTOCOLMSG_GENERIC lpdvGeneric, DWORD dwSize );
	BOOL HandleSpeechWithTarget( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHTARGET lpdvSpeech, DWORD dwSize );
	BOOL HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize );	

	PDVTRANSPORT_BUFFERDESC GetTransmitBuffer( DWORD dwSize, LPVOID *ppvContext );
    HRESULT SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete );
    void ReturnTransmitBuffer( PVOID pvContext );

	HRESULT BuildAndSendTargetUpdate( DVID dvidSource, CVoicePlayer *pPlayerInfo );

	BOOL CheckForMigrate( DWORD dwFlags, BOOL fSilent );
	HRESULT InformClientsOfMigrate();
	void WaitForBufferReturns();

protected: // Client Server specific information (mixserver.cpp)

	static DWORD WINAPI MixerWorker( void *lpContext );
	static DWORD WINAPI MixerControl( void *pvContext );
	static BOOL MixingServerWakeupProc( DWORD_PTR param );

	void HandleMixerThreadError( HRESULT hr );
	void Mixer_Buffer_Reset(DWORD dwThreadIndex);
	void Mixer_Buffer_MixBuffer( DWORD dwThreadIndex,unsigned char *source );
	void Mixer_Buffer_Normalize( DWORD dwThreadIndex );

	HRESULT SetupBuffers();
	HRESULT FreeBuffers();

	HRESULT StartupClientServer();
	HRESULT ShutdownClientServer();

	HRESULT ShutdownWorkerThreads();
	HRESULT StartWorkerThreads();

	HRESULT HandleMixingReceive( CDVCSPlayer *pTargetPlayer, PDVPROTOCOLMSG_SPEECHWITHTARGET pdvSpeechWithtarget, DWORD dwSpeechSize, PBYTE pbSpeechData );	

	void AddPlayerToMixingAddList( CVoicePlayer *pVoicePlayer );
	void UpdateActiveMixingPendingList( DWORD dwThreadIndex, DWORD *pdwNumActive );
	void CleanupMixingList();

	void SpinWorkToThread( LONG lThreadIndex );

	void FindAndRemoveDeadTarget( DVID dvidTargetID );

protected: // Forwarding Server specific funcs (fwdserver.cpp)

	HRESULT StartupMulticast();
	HRESULT ShutdownMulticast();

	HRESULT HandleForwardingReceive( CVoicePlayer *pTargetPlayer,PDVPROTOCOLMSG_SPEECHWITHTARGET pdvSpeechWithtarget, DWORD dwSpeechSize, PBYTE pbSpeechData );

	void CleanupActiveList();

protected:

	DWORD					m_dwSignature;			// Signature 

	LPDVMESSAGEHANDLER		m_lpMessageHandler;		// User message handler
	LPVOID					m_lpUserContext;		// User context for message handler
	DVID					m_dvidLocal;			// DVID of the transport player for this host
	DWORD					m_dwCurrentState;		// Current state of the engine
    CDirectVoiceTransport	*m_lpSessionTransport;	// Transport for the session
	DVSESSIONDESC			m_dvSessionDesc;		// Description of session
	DWORD					m_dwTransportFlags;		// Flags for the transport session
	DWORD					m_dwTransportSessionType;
													// Type of transport session (client/server or peer to peer)
	LPDVFULLCOMPRESSIONINFO m_lpdvfCompressionInfo;	// Details of current compression type
	DWORD					m_dwCompressedFrameSize;// Max size of compressed frame
	DWORD					m_dwUnCompressedFrameSize;
													// Size of a single frame uncompressed
	DWORD					m_dwNumPerBuffer;		// Size of playback/record buffers in frames
	CFramePool				*m_pFramePool;			// Pool of frames for the queues
	 												// time of a frame size.
	DIRECTVOICESERVEROBJECT *m_lpObject;			// Pointer to the COM object this is running in 

	LPDWORD					m_lpdwMessageElements;	// Array containing the DVMSGID_XXXX values for all the
													// notifications developer wishes to receive.
													// If this is NULL all notifications are active
	DWORD					m_dwNumMessageElements;	// # of elements in the m_lpdwMessageElements array
	DWORD					m_dwNextHostOrderID;
	HRESULT					m_hrStopSessionResult;	// Reason that the session was stopped

    BOOL					m_mixerEightBit;		// Is the mixer format 8-bit
	BYTE					m_padding[3];    

	ServerStats				*m_pServerStats;

	DVCAPS					m_dvCaps;				// Caps

	DNCRITICAL_SECTION		m_csClassLock;
	DNCRITICAL_SECTION		m_csNotifyLock;			// Lock protection notification mask

	BILINK					m_blPlayerActiveList;
	DNCRITICAL_SECTION		m_csPlayerActiveList;

    CVoiceNameTable         m_voiceNameTable;
    CLockedFixedPool<CDVCSPlayer> m_fpCSPlayers;
    CLockedFixedPool<CVoicePlayer> m_fpPlayers;
	DNCRITICAL_SECTION		m_csHostOrderLock;

    DNCRITICAL_SECTION        m_csBufferLock;
	ServerStats				m_dvsServerStatsFixed;	// If global memory is unavailable    
    PFPOOL                  m_pBufferDescPool;
    PFPOOL                  *m_pBufferPools;
    DWORD                   *m_pdwBufferPoolSizes;
    DWORD                   m_dwNumPools;

protected: // Mixing server information

	DWORD					m_dwNumMixingThreads;
    DWORD					m_dwMixerSize;		// # of samples in the high resolution  mixer buffer	

	DNCRITICAL_SECTION		m_csMixingAddList;

	HANDLE					m_hTickSemaphore;		// Semaphore signalled by the timer
	HANDLE					m_hShutdownMixerEvent;	// Event signalled to shutdown the mixer
	HANDLE					m_hMixerDoneEvent;		// Signalled by the mixer thread when it's shutdown
	Timer					*m_timer;				// Timer that is signalled on a period equal to the

	PMIXERTHREAD_CONTROL	m_prWorkerControl;

	DWORD					m_dwMixerControlThreadID;
	HANDLE					m_hMixerControlThread;

	MixingServerStats		m_statMixingFixed;
	MixingServerStats		*m_pStats;

    PERF_APPLICATION		m_perfInfo;					// Perf info entry for this object	
    PERF_APPLICATION_INFO	m_perfAppInfo;				// APplication specific perrf info
    DNCRITICAL_SECTION		m_csStats;

	BOOL					m_fCritSecInited;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsereng.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvserverengine.cpp
 *  Content:	Implements the CDirectVoiceServerEngine class.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/18/99	rodtoll	Created It
 *  07/22/99	rodtoll	Added multiple reader/single writer guard to class
 *						Added use of new player information handlers
 *						Added additional error checks
 *  07/23/99	rodtoll	Completed client/server support
 *						Bugfixes to client/server
 *						Multicast support to the server
 *	07/26/99	rodtoll	Updated to use new method for communicating with
 *						the transport.  
 *  07/29/99	pnewson	Updated call to CInputQueue2 constructor
 *  08/03/99	pnewson	Cleanup of Frame and Queue classes
 *  08/03/99	rodtoll Removed async flag from send calls, not needed
 *  08/05/99	rodtoll	Fixed locking, was causing deadlock w/DirectPlay 
 *  08/10/99	rodtoll	Removed TODO pragmas
 *  08/18/99	rodtoll	Modified speech transmission behaviour from server.
 *						To allow server to distinguish bounced speech from
 *						client speech, server now sends SPEECHBOUNCED
 *						message types.
 *	08/25/99	rodtoll	Fixed speech receive so it records target of audio
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added parameters to GetCompression func
 *	08/26/99	rodtoll	Added more debug statements & shutdown call on session stop
 *  08/30/99	rodtoll	Updated to allow client/server mode Mixing/Multicast sessions
 *  09/01/99	rodtoll	Added check for valid pointers in func calls 
 *  09/02/99	rodtoll	Added checks to handle case no local player created 
 *  09/04/99	rodtoll	Added new "echo server" mode to the server
 *  09/07/99	rodtoll	Implemented SetTransmitTarget and GetTransmitTarget
 *  09/10/99	rodtoll	Fixed bug with StartSession parameter validation
 * 				rodtoll	Bug w/check for current status in StartSession
 * 09/14/99		rodtoll	Added new SetNotifyMask function
 *				rodtoll	Updated Iniitalize parameters to take notification masks.
 * 				rodtoll	Implemented notification masks.  (Allows user to choose which notifications to receive) 
 * 09/15/99		rodtoll	Fixed bug with target set proper usage checking and client/server mode checking
 * 09/20/99		rodtoll	Added more memory alloc failure checks
 *   			rodtoll	Added error handling for client/server mixing thread
 *				rodtoll	Updated error handling so when session lost send session lost message
 *				rodtoll	Tightened checks for valid Notify Masks
 * 				rodtoll	Added proper error checking to SetNotifyMask 
 * 09/28/99		rodtoll	Fixed StopSession for host migration.  Won't send SessionLost messages to players
 *						if stopping and host migration is available
 * 10/04/99		rodtoll	Added usage of the DVPROTOCOL_VERSION_XXX macros 
 * 				rodtoll	Additional documentation/DPFs
 * 10/18/99		rodtoll Fix: Calling Initialize twice doesn't fail
 * 10/20/99		rodtoll	Fix: Bug #114114 - StartSession takes invalid parameters
 * 10/25/99		rodtoll Fix: Bug #114684 - GetCaps causes lockup on shutdown
 *				rodtoll	Fix: Bug #114682 - SetSessionDesc crashes when you specify NULL 
 * 				rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate 
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.    
 * 11/17/99		rodtoll Fix: Bug #115538 - dwSize members of > sizeof struct were accepted 
 *				rodtoll	Fix: Bug #115823 - Passing NULL for buffer size in GetCompressionTypes crashes
 * 				rodtoll	Fix: Bug #115827 - Calling SetNotifyMask when there is no callback should fail
 *          	rodtoll	Fix: Bug #116440 - Remove unused flags 
 *				rodtoll Fix: Bug #117447 - GetTransmitTarget has problems 
 * 11/22/99		rodtoll Fixed Initialize() would fail incorrectly
 * 11/23/99		rodtoll	Updated Initialize/SetNotifyMask so error checking behaviour is consistant 
 *				rodtoll	Updated GetTransmitTarget to release lock while calling into dplay
 * 11/23/99		rodtoll	Split CheckForValid into Group and Player 
 * 12/06/99		rodtoll	Bumped playback/record threads to time critical priority 
 * 12/16/99		rodtoll Fix: Bug #122629 - Host migration broken in unusual configurations.
 *						Updated to use new algorithm described in dvprot.h
 *						- Generate and added host order IDs to player table messages
 *						- Added send of new hostmigrateleave message when shutting down and
 *					      host should migrate
 *						- Sends session lost when shutting down if no one available to take over hosting
 *						- Added new player list message
 *						- Fixed handling of refusing player connections
 * 01/14/2000	rodtoll	Updated to allow multiple targets for a single player
 *				rodtoll	Updated to use FPM for managing memory for Multicast mode
 *				rodtoll	Updated to use new callback semantics
 *				rodtoll	Removed DVFLAGS_SYNC as a valid flag for StartSession/StopSession
 *				rodtoll	Removed DVMSGID_STARTSESSIONRESULT / DVMSGID_STOPSESSIONRESULT
 * 03/29/2000	rodtoll	Updated to use new nametable / more efficient locking
 *				rodtoll Modified calls to ConfirmValidEntity to check the nametable instead
 * 04/07/2000   rodtoll Bug #32179 - Prevent registration of > 1 interface
 *              rodtoll Updated to use no copy sends, so handles pooling frames to be sent, proper
 *                      pulling of frames from pools and returns.   
 * 05/31/2000   rodtoll Bug #35860 - Fix VC6 compile errors for instrumented builds
 * 06/02/2000   rodtoll Moved host migration so it is keyed off voice message and transport messages.  
 *                      More reliable this way. 
 * 06/15/2000   rodtoll Bug #36794 - dwIndex build error with old compiler fixed
 * 06/21/2000	rodtoll Bug #36820 - Host migration failure when local client is next host.
 *						Updated shutdown sequence to deregister server before sending out hostmigrateleave
 * 06/27/2000	rodtoll	Bug #37604 - Voice objects don't get SESSION_LOST when transport session is closed
 *						Added send of session lost message in this case.
 *				rodtoll	Fixed window which would cause crash when outstanding sends are completed after we
 *						have deregistered -- we now wait.  
 * 06/28/2000	rodtoll	Prefix Bug #38022
 *  07/01/2000	rodtoll	Bug #38280 - DVMSGID_DELETEVOICEPLAYER messages are being sent in non-peer to peer sessions
 *  07/09/2000	rodtoll	Added signature bytes
 * 07/22/2000	rodtoll	Bug #40284 - Initialize() and SetNotifyMask() should return invalidparam instead of invalidpointer  
 *				rodtoll   Bug #40296, 38858 - Crashes due to shutdown race condition
 *						Now ensures that all threads from transport have left and that
 *						all notificatinos have been processed before shutdown is complete. 
 *				rodtoll	Bug #39586 - Trap 14 in DPVVOX.DLL during session of voicegroup, adding guards for overwrites 
 * 07/26/2000	rodtoll	Bug #40607 - DPVoice: Problems with Mixing serer when there are more then 3 clients connected to a server and 2 of the transmit
 *						Logic bug caused all people reusing mix to get garbage 
 * 08/03/2000	rodtoll	Bug #41320 - DirectPlayVoice servers will reject connections from newer clients
 * 08/08/2000	rodtoll	Was missing a DNLeaveCriticalSection during shutdown
 * 08/25/2000	rodtoll	Bug #43485 - Memory leak -- Session Lost case leaks one buffer 
 * 08/28/2000	masonb  Voice Merge: DNet FPOOLs use DNCRITICAL_SECTION, modified m_pBufferDescPool usage
 * 09/01/2000	masonb	Modified Mixer to call _endthread to clean up thread handle
 * 09/14/2000	rodtoll	Bug #45001 - DVOICE: AV if client has targetted > 10 players  
 * 09/28/2000	rodtoll	Fix Again: Bug #45541 - DPVOICE: Client gets DVERR_TIMEOUT message when disconnecting (Server always confirms disconnect) 
 * 11/16/2000	rodtoll	Bug #40587 - DPVOICE: Mixing server needs to use multi-processors  
 * 11/28/2000	rodtoll	Bug #47333 - DPVOICE: Server controlled targetting - invalid targets are not removed automatically
 * 04/02/2001	simonpow	Bug #354859 - Fixes for PREfast spotted problems. (HRESULT to BOOL casting)
 * 04/06/2001	kareemc	Added Voice Defense
 * 04/09/2001	rodtoll	WINBUG #364126 - DPVoice : Memory leak when Initializing 2 Voice Servers with same DPlay transport
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#define SERVER_POOLS_NUM                3
#define SERVER_POOLS_SIZE_MESSAGE       (sizeof(DVPROTOCOLMSG_FULLMESSAGE))
#define SERVER_POOLS_SIZE_PLAYERLIST    DVPROTOCOL_PLAYERLIST_MAXSIZE      

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CDirectVoiceServerEngine"
// 
// Constructor
// 
// Initializes the object into the uninitialized state
//
CDirectVoiceServerEngine::CDirectVoiceServerEngine( DIRECTVOICESERVEROBJECT *lpObject
):	m_dwSignature(VSIG_SERVERENGINE), 
	m_lpMessageHandler(NULL),
	m_lpUserContext(NULL),
	m_lpObject(lpObject),
	m_dvidLocal(0),
	m_dwCurrentState(DVSSTATE_NOTINITIALIZED),
	m_lpSessionTransport(NULL),
	m_lpdwMessageElements(NULL),
	m_dwNumMessageElements(0),
	m_dwNextHostOrderID(0),
    m_pBufferPools(NULL),
    m_pdwBufferPoolSizes(NULL),
    m_hMixerControlThread(NULL),
    m_dwMixerControlThreadID(0),
    m_pBufferDescPool(NULL),
    m_pStats(NULL),
	m_fCritSecInited(FALSE)
{
	memset( &m_dvCaps, 0x00, sizeof( DVCAPS ) );
	m_dvCaps.dwSize = sizeof( DVCAPS );
	m_dvCaps.dwFlags = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::InitClass"

CDirectVoiceServerEngine::InitClass( )
{
	if (!DNInitializeCriticalSection( &m_csMixingAddList ))
	{
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csPlayerActiveList ))
	{
		DNDeleteCriticalSection( &m_csMixingAddList );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csHostOrderLock ))
	{
		DNDeleteCriticalSection( &m_csPlayerActiveList );
		DNDeleteCriticalSection( &m_csMixingAddList );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csBufferLock ))
	{
		DNDeleteCriticalSection( &m_csHostOrderLock );
		DNDeleteCriticalSection( &m_csPlayerActiveList );
		DNDeleteCriticalSection( &m_csMixingAddList );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csClassLock ))
	{
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csHostOrderLock );
		DNDeleteCriticalSection( &m_csPlayerActiveList );
		DNDeleteCriticalSection( &m_csMixingAddList );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csStats ))
	{
		DNDeleteCriticalSection( &m_csClassLock );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csHostOrderLock );
		DNDeleteCriticalSection( &m_csPlayerActiveList );
		DNDeleteCriticalSection( &m_csMixingAddList );
		return FALSE;
	}
	if (!DNInitializeCriticalSection( &m_csNotifyLock ))
	{
		DNDeleteCriticalSection( &m_csStats );
		DNDeleteCriticalSection( &m_csClassLock );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csHostOrderLock );
		DNDeleteCriticalSection( &m_csPlayerActiveList );
		DNDeleteCriticalSection( &m_csMixingAddList );
		return FALSE;
	}
	m_fCritSecInited = TRUE;
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::~CDirectVoiceServerEngine"
//
// Destructor
//
// Frees the resources associated with the server.  Shuts the server down
// if it is running.
//
// Server objects should never be destructed directly, the COM Release
// method should be used.
//
// Called By:
// DVS_Release (When reference count reaches 0)
//
// Locks Required:
// - Global Write Lock
//
CDirectVoiceServerEngine::~CDirectVoiceServerEngine()
{
	HRESULT hr;

	// Stop the session if it's running.
	hr = StopSession(0, FALSE , DV_OK );

	if( hr != DV_OK && hr != DVERR_NOTHOSTING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "StopSession Failed hr=0x%x", hr );
	}

	DNEnterCriticalSection( &m_csClassLock );
	
	if( m_lpdwMessageElements != NULL )
		delete [] m_lpdwMessageElements;

	DNLeaveCriticalSection( &m_csClassLock );

	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection( &m_csMixingAddList );
		DNDeleteCriticalSection( &m_csHostOrderLock );
		DNDeleteCriticalSection( &m_csPlayerActiveList );
		DNDeleteCriticalSection( &m_csBufferLock );
		DNDeleteCriticalSection( &m_csClassLock );
		DNDeleteCriticalSection( &m_csNotifyLock );
		DNDeleteCriticalSection( &m_csStats );	
	}

	m_dwSignature = VSIG_SERVERENGINE_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::TransmitMessage"
// 
// TransmitMessage
//
// This function sends a notification to the notification handler.  Before transmitting
// it, the notify elements are checked to ensure the specified notification is activated.
// (or notification array is NULL).
//
// Called By:
// - Multiple locations throughout dvsereng.cpp
// 
// Locks Required:
// - m_csNotifyLock - The notification lock
// 
void CDirectVoiceServerEngine::TransmitMessage( DWORD dwMessageType, LPVOID lpdvData, DWORD dwSize )
{
	if( m_lpMessageHandler != NULL )
	{
	    BFCSingleLock slLock( &m_csNotifyLock );
	    slLock.Lock();

		BOOL fSend = FALSE;	    

	    if( m_dwNumMessageElements == 0 )
	    {
	    	fSend = TRUE;
	    }
	    else
	    {
		    for( DWORD dwIndex = 0; dwIndex < m_dwNumMessageElements; dwIndex++ )
		    {
		    	if( m_lpdwMessageElements[dwIndex] == dwMessageType )
		    	{
		    		fSend = TRUE;
		    		break;
		    	}
		    }
		}

		if( fSend )
		{
			(*m_lpMessageHandler)( m_lpUserContext, dwMessageType,lpdvData );	    		
		}
	}
}

// Handles initializing a server object for host migration
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HostMigrateStart"
//
// HostMigrateStart
//
// This function is called on the object which is to become the new host when 
// the host migrates.  It is used instead of the traditional startup to 
// ensure that the object is initialized correctly in the migration case.
//
// Called By:
// - DV_HostMigrate
//
// Locks Required:
// - None
// 
HRESULT CDirectVoiceServerEngine::HostMigrateStart(LPDVSESSIONDESC lpSessionDesc, DWORD dwHostOrderIDSeed )
{
	HRESULT hr;
	
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVSE::HostMigrateStart() Begin" );

	// Start 
	hr = StartSession( lpSessionDesc, 0, dwHostOrderIDSeed );

	// Fail
	if( hr != DV_OK ) 
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "CDirectVoiceServerEngine::HostMigrateStart Failed Hr=0x%x", hr );
		return hr;
	}

	hr = InformClientsOfMigrate();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to inform users of host migration hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME 
#define DPF_MODNAME "CDirectVoiceServerEngine::InformClientsOfMigrate"
//
//
// This function will 
//  
HRESULT CDirectVoiceServerEngine::InformClientsOfMigrate()
{
	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Informing clients of migration" );

	return Send_HostMigrated();
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartSession"
//
// StartSession
//
// This function handles starting the directplayvoice session in the associated directplay/net
// session.  It also handles startup for a new host when the host migrates.  (Called by 
// HostMigrateStart in this case).
//
// Called By:
// - DV_StartSession
// - HostMigrateStart
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceServerEngine::StartSession(LPDVSESSIONDESC lpSessionDesc, DWORD dwFlags, DWORD dwHostOrderIDSeed )
{
	HRESULT hr;
	BOOL fPoolsInit = FALSE;

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpSessionDesc = 0x%p  dwFlags = 0x%x", lpSessionDesc, dwFlags );

	if( dwFlags !=0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags specified" );
		return DVERR_INVALIDFLAGS;
	}

	hr = DV_ValidSessionDesc( lpSessionDesc );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error validating session description.  hr=0x%x", hr );
		return hr;
	}

	DV_DUMP_SD( lpSessionDesc );	

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	switch( m_dwCurrentState )
	{
	case DVSSTATE_SHUTDOWN:
	case DVSSTATE_RUNNING:
	case DVSSTATE_STARTUP:
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Session is already in progress." );
		return DVERR_HOSTING;
	case DVSSTATE_NOTINITIALIZED:
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	if( m_lpSessionTransport == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid transport" );
		return DVERR_INVALIDOBJECT;
	}

	m_timer = NULL;
	m_hTickSemaphore = NULL;
	m_hShutdownMixerEvent = NULL;
	m_hMixerDoneEvent = NULL;
	m_prWorkerControl = NULL;
	m_pFramePool = NULL;

	// Retrieve the information about the dplay/dnet session
	hr = m_lpSessionTransport->GetTransportSettings( &m_dwTransportSessionType, &m_dwTransportFlags );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not retrieve transport settings hr=0x%x", hr );
		return hr;
	}

	// Peer-to-peer mode not available in client/server mode
	if( m_dwTransportSessionType == DVTRANSPORT_SESSION_CLIENTSERVER &&
	    (lpSessionDesc->dwSessionType == DVSESSIONTYPE_PEER) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot host peer session in client/server transport" );
		return DVERR_NOTSUPPORTED;
	}

	// Server control target not available if host migration is enabled
	if( (m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST) &&
	    (lpSessionDesc->dwFlags & DVSESSION_SERVERCONTROLTARGET) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot support host migration with server controlled targetting" );
		return DVERR_NOTSUPPORTED;
	}

	if( m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST &&
	    (lpSessionDesc->dwSessionType == DVSESSIONTYPE_MIXING || 
	     lpSessionDesc->dwSessionType == DVSESSIONTYPE_ECHO) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot support host migration for mixing or echo servers" );
		return DVERR_NOTSUPPORTED;
	}

	hr = DVCDB_GetCompressionInfo( lpSessionDesc->guidCT, &m_lpdvfCompressionInfo );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Compression type not supported. hr=0x%x", hr );
		return DVERR_COMPRESSIONNOTSUPPORTED;
	}

	m_dwCompressedFrameSize = m_lpdvfCompressionInfo->dwFrameLength;

	SetCurrentState( DVSSTATE_STARTUP );

	// Scrub the session description

	memcpy( &m_dvSessionDesc, lpSessionDesc, sizeof( DVSESSIONDESC ) );

	if( m_dvSessionDesc.dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		m_dvSessionDesc.dwBufferAggressiveness = s_dwDefaultBufferAggressiveness;
	}

	if( m_dvSessionDesc.dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		m_dvSessionDesc.dwBufferQuality = s_dwDefaultBufferQuality;
	}	

	m_dwNextHostOrderID = dwHostOrderIDSeed;

	ZeroMemory( &m_perfAppInfo, sizeof( PERF_APPLICATION_INFO ) );

	m_perfInfo.dwFlags = PERF_APPLICATION_VALID | PERF_APPLICATION_VOICE | PERF_APPLICATION_SERVER;
	CoCreateGuid( &m_perfInfo.guidApplicationInstance );
	CoCreateGuid( &m_perfInfo.guidInternalInstance );
	m_perfInfo.guidIID = IID_IDirectPlayVoiceServer;
	m_perfInfo.dwProcessID = GetCurrentProcessId();
	m_perfInfo.dwMemoryBlockSize = sizeof( MixingServerStats ) + sizeof( ServerStats );

	// Initilalize the new performance library
	hr = PERF_AddEntry( &m_perfInfo, &m_perfAppInfo );

	// This is an error, but not fatal
	if( FAILED ( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create performance tracking object 0x%x", hr );
	}

	if( m_perfAppInfo.pbMemoryBlock )
	{
		m_pStats = (MixingServerStats *) (m_perfAppInfo.pbMemoryBlock+sizeof( ServerStats ));
		m_pServerStats = (ServerStats *) m_perfAppInfo.pbMemoryBlock;
	}
	else
	{
		m_pStats = &m_statMixingFixed;
		m_pServerStats = &m_dvsServerStatsFixed;
	}

	// Reset statistics 
	ZeroMemory( m_pStats, sizeof( MixingServerStats ) );
	ZeroMemory( m_pServerStats, sizeof( ServerStats ) );
	memcpy( &m_pServerStats->m_dvSessionDesc, &m_dvSessionDesc, sizeof( DVSESSIONDESC ) );

	hr = SetupBuffers();

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to setup buffer pools hr=0x%x", hr );
	    goto STARTSESSION_FAILURE;
	}

	if( lpSessionDesc->dwSessionType == DVSESSIONTYPE_FORWARDING )
	{
		hr = StartupMulticast();

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initializing multicast hr=0x%x", hr );
			goto STARTSESSION_FAILURE;
		}
	}

	// Setup name table
	hr = m_voiceNameTable.Initialize();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to initialize nametable hr=0x%x", hr );
		goto STARTSESSION_FAILURE;				
	}

	// Initialize player allocation pools
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		fPoolsInit = m_fpCSPlayers.Initialize();
	}
	else
	{
		fPoolsInit = m_fpPlayers.Initialize();
	}

	InitBilink( &m_blPlayerActiveList, NULL );

	SetCurrentState( DVSSTATE_RUNNING );

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		hr = StartupClientServer();

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to startup client/server hr=0x%x", hr );
			goto STARTSESSION_FAILURE;			
		}
	}

	// Tell DirectPlay we're alive and want to see incoming traffic
	hr = m_lpSessionTransport->EnableReceiveHook( m_lpObject, DVTRANSPORT_OBJECTTYPE_SERVER );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed on call to EnableReceiveHook hr=0x%x", hr );
		goto STARTSESSION_FAILURE;
	}

STARTSESSION_RETURN:

	guardLock.Unlock();

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Success" );

	return hr;

STARTSESSION_FAILURE:

	PERF_RemoveEntry( m_perfInfo.guidInternalInstance, &m_perfAppInfo );

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		ShutdownClientServer();
	}		
	else if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
	{
	    ShutdownMulticast();
	}

	m_voiceNameTable.DeInitialize(TRUE, m_lpUserContext,m_lpMessageHandler);

	// Initialize player allocation pools
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		if( fPoolsInit )
		{
			m_fpCSPlayers.Deinitialize();
		}
		delete m_pFramePool;
		m_pFramePool = NULL;
	}
	else
	{
		if( fPoolsInit )
		{
			m_fpPlayers.Deinitialize();
		}
	}    	
	
	FreeBuffers();
	
	SetCurrentState( DVSSTATE_IDLE );
	
	goto STARTSESSION_RETURN;
	

	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CheckForMigrate"
BOOL CDirectVoiceServerEngine::CheckForMigrate( DWORD dwFlags, BOOL fSilent )
{
	// We should shutdown the session if:
	//
	// 1. We're not in peer to peer mode
	// 2. "No host migration" flag was specified in session description
	// 3. "No host migrate" flag was specified on call to StopSession
	// 4. We were not asked to be silent
	// 5. There isn't a host migrate
	// 
	if( (m_dvSessionDesc.dwSessionType != DVSESSIONTYPE_PEER ) || 
	    (m_dvSessionDesc.dwFlags & DVSESSION_NOHOSTMIGRATION) || 
		(dwFlags & DVFLAGS_NOHOSTMIGRATE) ||
		fSilent ||
		!(m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Destroying session." );
		return FALSE;
	}
	// A migration is possible
	else
	{
	    return TRUE;

	    /*
	    THIS IS DISABLED BECAUSE OF a race condition where the server has not yet
	    received notifications from all players in the session and therefore may 
	    think (incorrectly) that there is no one left.
	    
		// We look for at least one client who hasn't marked themselves 
		// as notpeerhost
		//

		DVID dvidNewHost;

		DWORD dwNewHostOrder = m_voiceNameTable.GetLowestHostOrderID(&dvidNewHost);

		if( dwNewHostOrder != DVPROTOCOL_HOSTORDER_INVALID )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Found at least one client who can become host.  (It's 0x%x)", dvidNewHost );
			return TRUE;
		}
		else
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not find a client to become host" );
			return FALSE;
		}
		*/
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StopSession"
//
// StopSession
//
// This function is responsible for shutting down the directplayvoice session.  In sessions 
// without host migration, this function will simply cleanup the memory and detach itself
// from directplay.  This way directplay will take care of the host migration.  To use this
// option, specify fSilent = TRUE.
// 
// In addition, this function is called when an fatal error occurs while the session is 
// running.  
//
// It is also called when the user calls StopSession.
//
// Called By:
// - HandleMixerThreadError
// - HandleStopTransportSession
// - DVS_StopSession
// 
// Locks Required:
// - Global Write Lock
// 
HRESULT CDirectVoiceServerEngine::StopSession(DWORD dwFlags, BOOL fSilent, HRESULT hrResult )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "DVSE::StopSession() Begin" );
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: dwFlags = 0x%x", dwFlags );


	if( dwFlags & ~(DVFLAGS_NOHOSTMIGRATE) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags specified" );
		return DVERR_INVALIDFLAGS;
	}

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	// We need to be initialized
	if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not Initialized" );
		return DVERR_NOTINITIALIZED;
	}	

	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Session is not running" );
		return DVERR_NOTHOSTING;
	}

	// Stop client/server thread
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Shutting down client/server" );
		ShutdownClientServer();
		DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Shutting down client/server" );		
	}	

	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Waiting for buffer returns." );
	// Wait until all the outstanding sends have completed  
	WaitForBufferReturns();
	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Waiting for buffer returns." );	

	// Disable receives
	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Unhook transport." );
	m_lpSessionTransport->DisableReceiveHook( );
	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Unhook transport." );	

	// Waits for transport threads to be done inside our layer
	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Awaiting detach." );	
	m_lpSessionTransport->WaitForDetachCompletion();	
	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Awaiting detach." );		

	// Check to see if there is migration going on.  If a migration should
	// happen then we do not transmit a session lost message
	//
	if( !FAILED( hrResult ) )
	{
		if( !CheckForMigrate( dwFlags, fSilent ) )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Host migration not possible.  Sending lost session." );				
			Send_SessionLost( DVERR_SESSIONLOST );
		}
		// Host is migrating.  Inform the users
		else if( m_dwTransportFlags & DVTRANSPORT_MIGRATEHOST )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Host migration begin." );					
			Send_HostMigrateLeave();
		}
	}

	SetCurrentState( DVSSTATE_SHUTDOWN );

	// Disable sends
	//m_lpSessionTransport->DestroyTransport();

	// Kill name table
	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Destroying nametable" );					
	m_voiceNameTable.DeInitialize(TRUE,m_lpUserContext,m_lpMessageHandler);
	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Destroying nametable" );					

	// Cleanup the active list
	CleanupActiveList();

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Cleanup mixing" );							

		// Kill the FPM
		m_fpCSPlayers.Deinitialize();
		delete m_pFramePool;
		m_pFramePool = NULL;
	}
	else
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Cleanup.." );									
		m_fpPlayers.Deinitialize();
	}

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Shutdown forwarding" );											
		ShutdownMulticast();
		DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Shutdown forwarding" );													
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Final cleanup" );	
	FreeBuffers();
	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Final cleanup" );	

	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Removing perf info" );
	PERF_RemoveEntry( m_perfInfo.guidInternalInstance, &m_perfAppInfo );
	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Removing perf info" );

	SetCurrentState( DVSSTATE_IDLE );

	guardLock.Unlock();

	// Check to see if the transport session was closed
	if( hrResult == DVERR_SESSIONLOST )
	{
		DVMSG_SESSIONLOST dvMsgLost;
		dvMsgLost.dwSize = sizeof( DVMSG_SESSIONLOST );
		dvMsgLost.hrResult = hrResult;

		TransmitMessage( DVMSGID_SESSIONLOST, &dvMsgLost, sizeof( DVPROTOCOLMSG_SESSIONLOST ) );
	}

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return DV_OK;
}

// WaitForBufferReturns
//
// This function waits until oustanding sends have completed before continuing
// we use this to ensure we don't deregister with outstanding sends.
// 
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::WaitForBufferReturns"
void CDirectVoiceServerEngine::WaitForBufferReturns()
{
	DPFX(DPFPREP,  DVF_INFOLEVEL, ">> Waiting for buffer returns. %d remaining", m_pBufferDescPool->nInUse );	
	
	while( 1 ) 
	{
		DNEnterCriticalSection( &m_pBufferDescPool->cs );

		if( m_pBufferDescPool->nInUse == 0 )
		{
			DNLeaveCriticalSection( &m_pBufferDescPool->cs );			
			break;
		}

		DNLeaveCriticalSection( &m_pBufferDescPool->cs );

		Sleep( 20 );
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "<< Waiting complete." );		

	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetSessionDesc"
//
// GetSessionDesc
//
// Called to retrieve the description of the current session.  
//
// Called By:
// - DVS_GetSessionDesc
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceServerEngine::GetSessionDesc( LPDVSESSIONDESC lpSessionDesc )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpSessionDesc = 0x%p", lpSessionDesc );

	if( lpSessionDesc == NULL || !DNVALID_WRITEPTR(lpSessionDesc,sizeof( DVSESSIONDESC )) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Session desc pointer bad" );
		return DVERR_INVALIDPOINTER;
	}

	if( lpSessionDesc->dwSize != sizeof( DVSESSIONDESC ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid size on session desc" );
		return DVERR_INVALIDPARAM;
	}	

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();

	// We need to be initialized
	if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not Initialized" );
		return DVERR_NOTINITIALIZED;
	}	

	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No host running" );
		return DVERR_NOTHOSTING;
	}

	memcpy( lpSessionDesc, &m_dvSessionDesc, sizeof( DVSESSIONDESC ) ); 	
	
	DV_DUMP_SD( (LPDVSESSIONDESC) lpSessionDesc );

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done, Returning DV_OK" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetSessionDesc"
//
// SetSessionDesc
//
// Used to set session parameters.  The only parameters that can be set are the 
// buffer quality and buffer aggresiveness.  
//
// Called By:
// - DVS_SetSessionDesc
//
// Locks Required:
// - Global Write Lock
// 
HRESULT CDirectVoiceServerEngine::SetSessionDesc(LPDVSESSIONDESC lpSessionDesc )
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "DVSE::SetSessionDesc() Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpSessionDesc = 0x%p", lpSessionDesc);

	if( lpSessionDesc == NULL ||
	 	!DNVALID_READPTR( lpSessionDesc, sizeof(DVSESSIONDESC)) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	DV_DUMP_SD( lpSessionDesc );	

	if( lpSessionDesc->dwSize != sizeof( DVSESSIONDESC ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid size of session desc" );
		return DVERR_INVALIDPARAM;
	}

	if( !DV_ValidBufferAggresiveness( lpSessionDesc->dwBufferAggressiveness ) ||
		!DV_ValidBufferQuality( lpSessionDesc->dwBufferQuality) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid buffer settings" );
		return DVERR_INVALIDPARAM;
	}

	CDVCSLock guardLock(&m_csClassLock);

	guardLock.Lock();

	// We need to be initialized
	if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not Initialized" );
		return DVERR_NOTINITIALIZED;
	}	

	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No session running" );
		return DVERR_NOTHOSTING;
	}

	if( m_dvSessionDesc.dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		m_dvSessionDesc.dwBufferAggressiveness = s_dwDefaultBufferAggressiveness;
	}
	else
	{
		m_dvSessionDesc.dwBufferAggressiveness = lpSessionDesc->dwBufferAggressiveness;
	}

	if( m_dvSessionDesc.dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		m_dvSessionDesc.dwBufferQuality = s_dwDefaultBufferQuality;
	}
	else
	{
		m_dvSessionDesc.dwBufferQuality = lpSessionDesc->dwBufferQuality;	
	}
	
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "End" );

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetCaps"
//
// GetCaps
//
// Retrieves the caps for the DirectPlayVoiceServer object.
//
// Called By:
// - DVS_GetCaps
//
// Locks Required:
//
HRESULT CDirectVoiceServerEngine::GetCaps(LPDVCAPS lpdvCaps)
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpdvCaps = 0x%p", lpdvCaps );
	
	if( lpdvCaps == NULL ||
		!DNVALID_WRITEPTR(lpdvCaps,sizeof(DVCAPS)) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	DV_DUMP_CAPS( lpdvCaps );

	if( lpdvCaps->dwSize != sizeof( DVCAPS ) )
	{
		DPFX(DPFPREP,   DVF_ERRORLEVEL, "Invalid size" );
		return DVERR_INVALIDPARAM;
	}

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();

	memcpy( lpdvCaps, &m_dvCaps, sizeof( DVCAPS ) );

	guardLock.Unlock();

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Done" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetCompressionTypes"
//
// GetCompressionTypes
//
// This function retrieves a list of the current compression types.
//
// Called By:
// - DVS_GetCompressionTypes
//
// Locks Required:
// NONE
// 
HRESULT CDirectVoiceServerEngine::GetCompressionTypes( LPVOID lpBuffer, LPDWORD lpdwBufferSize, LPDWORD lpdwNumElements, DWORD dwFlags)
{
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpBuffer = 0x%p lpdwBufferSize = 0x%p lpdwNumElements = 0x%p dwFlags = 0x%x", lpBuffer, lpdwBufferSize, lpdwNumElements, dwFlags);

	HRESULT hres = DVCDB_CopyCompressionArrayToBuffer( lpBuffer, lpdwBufferSize, lpdwNumElements, dwFlags );

	if( hres == DV_OK )
	{
		DV_DUMP_CI( (LPDVCOMPRESSIONINFO) lpBuffer, *lpdwNumElements );
	}

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "End" );

	return hres;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetTransmitTarget"
//
// SetTransmitTarget
//
// This function sets the transmit target for the specified user.  Only available in sessions with the 
// DVSESSION_SERVERCONTROLTARGET flag specified.
//
// Called By:
// - DVS_SetTransmitTarget
//
// Locks Required:
// - Global Write Lock
//
HRESULT CDirectVoiceServerEngine::SetTransmitTarget(DVID dvidSource, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags)
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Begin" );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: dvidSource: 0x%x pdvidTargets: 0x%p  dwNumTargets: %d dwFlags: 0x%x", dvidSource, pdvidTargets, dwNumTargets, dwFlags );

	HRESULT hr;

	hr = DV_ValidTargetList( pdvidTargets, dwNumTargets );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid target list hr=0x%x", hr );
		return hr;
	}

	// Flags must be 0.
	if( dwFlags != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	// We need to be initialized
	if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not Initialized" );
		return DVERR_NOTINITIALIZED;
	}

	// We need to be running
	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not hosting" );
		return DVERR_NOTCONNECTED;
	}

	// Only if servercontroltarget is active
	if( !(m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Only available with the DVSESSION_SERVERCONTROLTARGET session flag" );
		return DVERR_NOTALLOWED;
	}

	// Parameter checks
	if( !m_voiceNameTable.IsEntry( dvidSource ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid source player" );
		return DVERR_INVALIDPLAYER;
	}

	if( dwNumTargets > 0 )
	{
		for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
		{
			if( !m_voiceNameTable.IsEntry( pdvidTargets[dwIndex] ) )
			{
				if( !m_lpSessionTransport->ConfirmValidGroup( pdvidTargets[dwIndex] ) )
				{
					DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid target player/group" );
					return DVERR_INVALIDTARGET;
				}
			} 
		}
	}

	if( dvidSource == DVID_ALLPLAYERS )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot set the target for all or none" );
		return DVERR_INVALIDPLAYER;
	}	

	// Grab the player and set the target field
	CDVCSPlayer *pPlayerInfo;

	hr = m_voiceNameTable.GetEntry( dvidSource, (CVoicePlayer **) &pPlayerInfo, TRUE );	

	if( FAILED( hr ) || pPlayerInfo == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to lookup player entry.  hr=0x%x", hr );
		return DVERR_INVALIDPLAYER;
	}

	// We have to ensure that updates to the player's target list do not 
	// happen simulatenously between a call to this function and a removal
	// of a player because of a player leaving the session.
	pPlayerInfo->Lock();

	hr = pPlayerInfo->SetPlayerTargets( pdvidTargets, dwNumTargets );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to set player target hr=0x%x", hr );
		pPlayerInfo->Release();
		return hr;
	}
	
	hr = BuildAndSendTargetUpdate( dvidSource, pPlayerInfo );

	pPlayerInfo->UnLock();

	pPlayerInfo->Release();

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::BuildAndSendTargetUpdate"
//
// BuildAndSendTargetUpdate
//
// This function builds and sends a message with a target list to the specified
// user.
//
HRESULT CDirectVoiceServerEngine::BuildAndSendTargetUpdate( DVID dvidSource,CVoicePlayer *pPlayerInfo )
{
	// Grab the player and set the target field
	HRESULT hr;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;

	// Protect target information
	pPlayerInfo->Lock();

	DWORD dwTransmitSize;
	PDVPROTOCOLMSG_SETTARGET pSetTargetMsg;
	PVOID pvSendContext;
	
	dwTransmitSize = sizeof( DVPROTOCOLMSG_SETTARGET ) + (pPlayerInfo->GetNumTargets()*sizeof(DVID));

	pBufferDesc = GetTransmitBuffer( dwTransmitSize, &pvSendContext );

	if( pBufferDesc == NULL )
	{
		pPlayerInfo->UnLock();
		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to alloc memory" );
		return DVERR_BUFFERTOOSMALL;
	}

	pSetTargetMsg = (PDVPROTOCOLMSG_SETTARGET) pBufferDesc->pBufferData;

	// Send the message to the player
	pSetTargetMsg->dwType = DVMSGID_SETTARGETS;
	pSetTargetMsg->dwNumTargets = pPlayerInfo->GetNumTargets();
	
	memcpy( &pSetTargetMsg[1], pPlayerInfo->GetTargetList(), sizeof( DVID ) * pPlayerInfo->GetNumTargets() );

	pPlayerInfo->UnLock();

	hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

	if( hr == DVERR_PENDING )
	{
	    hr = DV_OK;
    }
	else if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to send target set message hr=0x%x", hr );
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetTransmitTarget"
//
// GetTransmitTarget
//
// This function returns the current transmission target of the specified user.  
//
// Only available in sessions with the DVSESSION_SERVERCONTROLTARGET flag.
//
// Called By:
// - DVS_GetTransmitTarget
//
// Locks Required:
// - Global Read Lock
//
HRESULT CDirectVoiceServerEngine::GetTransmitTarget(DVID dvidSource, LPDVID lpdvidTargets, PDWORD pdwNumElements, DWORD dwFlags )
{
	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: dvidSource = 0x%x lpdvidTargets = 0x%p pdwNumElements = 0x%p dwFlags = 0x%x", dvidSource, lpdvidTargets, pdwNumElements, dwFlags );

	if( pdwNumElements == NULL ||
	    !DNVALID_WRITEPTR( pdwNumElements, sizeof( DWORD ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( pdwNumElements != NULL && 
	    *pdwNumElements > 0 &&
	    !DNVALID_WRITEPTR( lpdvidTargets, (*pdwNumElements)*sizeof(DVID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid target list buffer specified" );
		return DVERR_INVALIDPOINTER;
	}	

	if( pdwNumElements == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "You must provider a ptr # of elements" );
		return DVERR_INVALIDPARAM;
	}	

	// Flags must be 0.
	if( dwFlags != 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags specified" );
		return DVERR_INVALIDFLAGS;
	}

	// We need to be initialized
	if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	// We need to be running
	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No session running" );
		return DVERR_NOTCONNECTED;
	}

	// Only if servercontroltarget is active
	if( !(m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Only available with the DVSESSION_SERVERCONTROLTARGET session flag" );
		return DVERR_NOTALLOWED;
	}

	if( dvidSource == DVID_ALLPLAYERS )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot get target for all or none" );
		return DVERR_INVALIDPLAYER;
	}

	// Parameter checks
	if( !m_voiceNameTable.IsEntry( dvidSource ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified player does not exist" );
		return DVERR_INVALIDPLAYER;
	} 

	HRESULT hr;	

	// Grab the player and set the target field
	CDVCSPlayer *pPlayerInfo;

	hr = m_voiceNameTable.GetEntry( dvidSource, (CVoicePlayer **) &pPlayerInfo, TRUE );	

	if( FAILED( hr ) || pPlayerInfo == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to lookup player entry.  hr=0x%x", hr );
		return DVERR_INVALIDPLAYER;
	}

	pPlayerInfo->Lock();

	if( *pdwNumElements < pPlayerInfo->GetNumTargets() )
	{
		hr = DVERR_BUFFERTOOSMALL;
	}
	else
	{
		memcpy( lpdvidTargets, pPlayerInfo->GetTargetList(), pPlayerInfo->GetNumTargets()*sizeof(DVID) );
	}
	
	*pdwNumElements  = pPlayerInfo->GetNumTargets();

	pPlayerInfo->UnLock();
	
	pPlayerInfo->Release();

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Initialize"
//
// Initialize
//
// This function is responsible for connecting the DirectPlayVoiceServer object
// to the associated transport session.  It sets up the object and makes
// it ready for a call to StartSession.
//
// Called By:
// - DV_Initialize
//
// Locks Required:
// - Global Write Lock
// 
HRESULT CDirectVoiceServerEngine::Initialize( CDirectVoiceTransport *lpTransport, LPDVMESSAGEHANDLER lpdvHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Begin" );
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "Param: lpTransport = 0x%p lpdvHandler = 0x%p lpUserContext = 0x%p ", lpTransport, lpdvHandler, lpUserContext );
	
	if( lpTransport == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}	

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );	
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "lpdwMessages = 0x%p dwNumElements = %d", lpdwMessages, dwNumElements );

	hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, TRUE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid message array hr=0x%x", hr );
		return hr;
	}

	DPFX(DPFPREP,  DVF_APIPARAM, "Message IDs=%d", dwNumElements );

	if( lpdwMessages != NULL )
	{
		for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
		{
			DPFX(DPFPREP,  DVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
		}
	}

	CDVCSLock guardLock(&m_csClassLock);
	guardLock.Lock();
	
	if( m_dwCurrentState != DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already Initialized" );
		return DVERR_INITIALIZED;
	}

    if( lpdvHandler == NULL && lpdwMessages != NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
    	return DVERR_NOCALLBACK;
    }

	SetCurrentState( DVSSTATE_IDLE );	

	BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();		

	m_lpMessageHandler = lpdvHandler;

	hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

	if( FAILED( hr ) )
	{
		SetCurrentState( DVSSTATE_NOTINITIALIZED );	
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "SetNotifyMask Failed hr=0x%x", hr );
		return hr;
	}	

	m_lpSessionTransport = lpTransport;
	m_lpUserContext = lpUserContext;

	m_dvidLocal = m_lpSessionTransport->GetLocalID();

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "DVSE::Initialize() End" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ReceiveSpeechMessage"
//
// ReceiveSpeechMessage
//
// Responsible for processing a speech message when it is received.  
//
// Called By:
// - DV_ReceiveSpeechMessage
//
// Locks Required:
// - None 
//
BOOL CDirectVoiceServerEngine::ReceiveSpeechMessage( DVID dvidSource, LPVOID lpMessage, DWORD dwSize )
{
	PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage;

	// if we dont' have at least one byte then we are going to bail
	if ( dwSize < 1 )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::ReceiveSpeechMessage() Ignoring zero-byte sized message from=0x%x",
			dvidSource );
		return FALSE;
	}

	lpdvFullMessage = (PDVPROTOCOLMSG_FULLMESSAGE) lpMessage;

	if( !ValidatePacketType( lpdvFullMessage ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::ReceiveSpeechMessage() Ignoring message with invalid packet type, type=0x%x, from=0x%x",
			lpdvFullMessage->dvGeneric.dwType, dvidSource );
		return FALSE;
	}
	
	switch( lpdvFullMessage->dvGeneric.dwType )
	{
 	case DVMSGID_SPEECHBOUNCE:
 		// Ignore speech bounces, only reason we get is because we're sending to all or targetting
 		// a client on the same ID as us.
 		return TRUE;
	case DVMSGID_CONNECTREQUEST:
		return HandleConnectRequest( dvidSource, static_cast<PDVPROTOCOLMSG_CONNECTREQUEST>(lpMessage), dwSize );
	case DVMSGID_DISCONNECT:
		return HandleDisconnect( dvidSource, static_cast<PDVPROTOCOLMSG_GENERIC>(lpMessage), dwSize);
	case DVMSGID_SETTINGSCONFIRM:
		return HandleSettingsConfirm( dvidSource, static_cast<PDVPROTOCOLMSG_SETTINGSCONFIRM>(lpMessage), dwSize );
	case DVMSGID_SETTINGSREJECT:
		return HandleSettingsReject( dvidSource, static_cast<PDVPROTOCOLMSG_GENERIC>(lpMessage), dwSize );
	case DVMSGID_SPEECHWITHTARGET:
		return HandleSpeechWithTarget( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHWITHTARGET>(lpMessage), dwSize );
	case DVMSGID_SPEECH:
		return HandleSpeech( dvidSource, static_cast<PDVPROTOCOLMSG_SPEECHHEADER>(lpMessage), dwSize );
	default:
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "DVSE::ReceiveSpeechMessage() Ignoring Non-Speech Message id=0x%x from=0x%x", 
			 lpdvFullMessage->dvGeneric.dwType, dvidSource );
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSpeech"
// HandleSpeech
//
// Handles processing of incoming speech packets (in echo server mode).
//
// How speech is handled depends on session type.  If the session is client/server, the 
// packet is buffered in the appropriate user's queue.  If the session is multicast,
// the packet is forwarded to the packet's target.
//
BOOL CDirectVoiceServerEngine::HandleSpeech( DVID dvidSource, PDVPROTOCOLMSG_SPEECHHEADER lpdvSpeech, DWORD dwSize )
{
	HRESULT hr = DV_OK;

	if ( dwSize < sizeof( DVPROTOCOLMSG_SPEECHHEADER ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSpeech() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( !ValidateSpeechPacketSize( m_lpdvfCompressionInfo, dwSize - sizeof( DVPROTOCOLMSG_SPEECHHEADER ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSpeech() Ignoring message with invalid speech size, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO )
	{
		// Bounce speech back to the user

		PDVTRANSPORT_BUFFERDESC pBufferDesc;
		PVOID pvSendContext;
		PDVPROTOCOLMSG_SPEECHHEADER pvSpeechHeader;

		pBufferDesc = GetTransmitBuffer( dwSize, &pvSendContext );

		if( pBufferDesc == NULL )
		{
		    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating transmit buffer" );
		    return FALSE;
		}

		pvSpeechHeader = (PDVPROTOCOLMSG_SPEECHHEADER) pBufferDesc->pBufferData;
		memcpy( pvSpeechHeader, lpdvSpeech, dwSize );

		pvSpeechHeader->dwType = DVMSGID_SPEECHBOUNCE;
		
		hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1, pBufferDesc, pvSendContext, 0 );

		if( hr == DVERR_PENDING )
		{
		    hr = DV_OK;
		}
		else if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed sending to ID hr=0x%x", hr );
		}

		return (hr==DV_OK);
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSpeechWithTarget"
// HandleSpeechWithTarget
//
// Handles processing of incoming speech packets.
//
// How speech is handled depends on session type.  If the session is client/server, the 
// packet is buffered in the appropriate user's queue.  If the session is multicast,
// the packet is forwarded to the packet's target.
//
BOOL CDirectVoiceServerEngine::HandleSpeechWithTarget( DVID dvidSource, PDVPROTOCOLMSG_SPEECHWITHTARGET lpdvSpeech, DWORD dwSize )
{
	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Enter");

	DWORD dwSpeechSize;		// Size of speech portion in bytes
	DWORD dwTargetSize;		// Size of targetting info in bytes
	PBYTE pSourceSpeech;	// Pointer to speech within the packet
	HRESULT hr = DV_OK;
	CVoicePlayer *pTargetPlayer;

	if ( dwSize < sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) || dwSize < sizeof(DVPROTOCOLMSG_SPEECHWITHTARGET) + lpdvSpeech->dwNumTargets*sizeof(DVID) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSpeechWithFrom() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}

	if( lpdvSpeech->dwNumTargets > DV_MAX_TARGETS )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSpeechWithTarget() Ignoring message with too many targets, targets=0x%x, from=0x%x",
			lpdvSpeech->dwNumTargets, dvidSource );
		return FALSE;
	}
	
	if( !ValidateSpeechPacketSize( m_lpdvfCompressionInfo, dwSize - (sizeof(DVPROTOCOLMSG_SPEECHWITHTARGET) + lpdvSpeech->dwNumTargets*sizeof( DVID ) ) ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSpeechWithFrom() Ignoring message with invalid speech size, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	hr = m_voiceNameTable.GetEntry( dvidSource, &pTargetPlayer, TRUE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  1, "Ignoring speech from unknown source hr=0x%x", hr );
		return FALSE;
	}

	dwTargetSize = lpdvSpeech->dwNumTargets*sizeof(DVID);

	dwSpeechSize = dwSize - sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) - dwTargetSize;

	pSourceSpeech = (PBYTE) lpdvSpeech;
	pSourceSpeech += sizeof( DVPROTOCOLMSG_SPEECHWITHTARGET ) + dwTargetSize;

	// We're a mixing server, queue up the speech.
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		hr = HandleMixingReceive( (CDVCSPlayer *) pTargetPlayer, lpdvSpeech, dwSpeechSize, pSourceSpeech );
	}
	else if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING )
	{
		hr = HandleForwardingReceive( pTargetPlayer, lpdvSpeech, dwSpeechSize, pSourceSpeech );
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  1, "Unable to receive audio hr=0x%x", hr );
		pTargetPlayer->Release();
		return FALSE;
	}	

	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Exit");

	pTargetPlayer->Release();

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::DoPlayerDisconnect"
//
// Performs the work of removing the specified player from the session.
//
// Optionally informs the specified player of their disconnection.  
//
// Called By:
// - HandleDisconnect (Player requests disconnect)
// - RemovePlayer (Dplay tells us player disconnected)
//
// Locks Required:
// - Global Write Lock
//
void CDirectVoiceServerEngine::DoPlayerDisconnect( DVID dvidPlayer, BOOL bInformPlayer ) 
{
	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Disconnecting player 0x%x", dvidPlayer );

	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Player disconnect ignored, not running" );
		return;
	}

	CVoicePlayer *pPlayerInfo = NULL;

	HRESULT hr;

	hr = m_voiceNameTable.GetEntry( dvidPlayer, &pPlayerInfo, TRUE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Error retrieving player entry. hr=0x%x Player may have dropped.", hr );
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Or we may have encountered disconnect during host migration" );

		// If we're peer to peer session, inform players of disconnection
		// Clients will ignore disconnects for players who are not in the session
		//
		if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
		{
		    hr = Send_DeletePlayer( dvidPlayer );

		    if( FAILED( hr ) )
		    {
		        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending deleteplayer to all hr=0x%x", hr );
		    }

			DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent player Quit to all" );				
		}		

		// If specified, send a message to the user to inform them of the disconnection
		// This will prevent client from timing out.  
		if( bInformPlayer )
		{
		    hr = Send_DisconnectConfirm( dvidPlayer, DV_OK );

		    if( FAILED( hr ) )
		    {
		        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending disconnect confirm hr=0x%x", hr );
		    }
		    else
		    {
	    		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent disconnect confirm to player" );							
		    }
		}
		
		return;
	}
	else
	{
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Retrieved record" );	
	}

	// Mark record as disconnected
	pPlayerInfo->SetDisconnected();

	// Release reference and remove from the nametable
	m_voiceNameTable.DeleteEntry( dvidPlayer );

	// Remove player from the "active" list!
	DNEnterCriticalSection( &m_csPlayerActiveList );
	pPlayerInfo->RemoveFromNotifyList();
	pPlayerInfo->Release();
	DNLeaveCriticalSection( &m_csPlayerActiveList );

	// If we're peer to peer session, inform players of disconnection
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
	{
	    hr = Send_DeletePlayer( dvidPlayer );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending deleteplayer to all hr=0x%x", hr );
	    }

		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent player Quit to all" );				
	}

	// If specified, send a message to the user to inform them of the disconnection
	if( bInformPlayer )
	{
	    hr = Send_DisconnectConfirm( dvidPlayer, DV_OK );

	    if( FAILED( hr ) )
	    {
	        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending disconnect confirm hr=0x%x", hr );
	    }
	    else
	    {
    		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent disconnect confirm to player" );							
	    }
	}

	DVMSG_DELETEVOICEPLAYER dvDeletePlayer;
	dvDeletePlayer.dvidPlayer = dvidPlayer;
	dvDeletePlayer.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
	dvDeletePlayer.pvPlayerContext = pPlayerInfo->GetContext();
	pPlayerInfo->SetContext( NULL );

	// Release reference for find
	pPlayerInfo->Release();	

	TransmitMessage( DVMSGID_DELETEVOICEPLAYER, &dvDeletePlayer, sizeof( DVMSG_DELETEVOICEPLAYER ) );

	// Remove this player from everyone's target lists  
	FindAndRemoveDeadTarget( dvidPlayer );
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleDisconnect"
//
// HandleDisconnect
//
// Called when a DVMSGID_DISCONNECT message is received.
//
// Called By:
// - ReceiveSpeechMessage
//
// Locks Required:
// - None
//
BOOL CDirectVoiceServerEngine::HandleDisconnect( DVID dvidSource, PDVPROTOCOLMSG_GENERIC lpdvDisconnect, DWORD dwSize )
{

	if ( dwSize != sizeof( DVPROTOCOLMSG_GENERIC ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleDisconnect() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	DoPlayerDisconnect( dvidSource, TRUE );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CreatePlayerEntry"
// 
// CreatePlayerEntry
//
// Performs the actual work of creating a player entity.  The work performed depends on the 
// type of session.
//
// Called By:
// - HandleSettingsConfirm
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::CreatePlayerEntry( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwHostOrderID, CVoicePlayer **ppPlayer )
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Requesting create [ID=0x%x]",dvidSource );

	CVoicePlayer *pNewPlayer;

	// Complicated.
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		CDVCSPlayer *pNewMixingPlayer = m_fpCSPlayers.Get();

		hr = pNewMixingPlayer->Initialize( dvidSource, dwHostOrderID, 
			                               lpdvSettingsConfirm->dwFlags, NULL, 
										   m_dwCompressedFrameSize, m_dwUnCompressedFrameSize,
										   &m_fpCSPlayers, m_dwNumMixingThreads );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error initializing new player record hr=0x%x", hr );
			return hr;
		}

        QUEUE_PARAMS queueParams;
    
        queueParams.wFrameSize = m_dwCompressedFrameSize;
        queueParams.bInnerQueueSize = m_lpdvfCompressionInfo->wInnerQueueSize;
        queueParams.bMaxHighWaterMark = m_lpdvfCompressionInfo->wMaxHighWaterMark, 
        queueParams.iQuality = m_dvSessionDesc.dwBufferQuality;
        queueParams.iHops = 2;
        queueParams.iAggr = m_dvSessionDesc.dwBufferAggressiveness;
        queueParams.bInitHighWaterMark = 2;
        queueParams.wQueueId = dvidSource;
        queueParams.wMSPerFrame = m_lpdvfCompressionInfo->dwTimeout,
        queueParams.pFramePool = m_pFramePool;

		hr = pNewMixingPlayer->CreateQueue( &queueParams );

        if( FAILED( hr ) )
        {
		    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create inputqueue hr=0x%x", hr );
			pNewMixingPlayer->Release();
		    return hr;
        }

		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Created mixing player" );

		pNewPlayer = (CVoicePlayer *) pNewMixingPlayer;
	}
	// Otherwise.. not so complicated
	else 
	{
		pNewPlayer = m_fpPlayers.Get();

		if( pNewPlayer == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "CDirectVoiceServerEngine::CreatePlayerEntry() Alloc failure on player struct" );
			return DVERR_OUTOFMEMORY;
		}

		hr = pNewPlayer->Initialize( dvidSource, dwHostOrderID, lpdvSettingsConfirm->dwFlags, NULL, &m_fpPlayers );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error initializing new player record hr=0x%x", hr );
			return hr;
		}

		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Created regular player" );		
	}

	hr = m_voiceNameTable.AddEntry( dvidSource, pNewPlayer );

	// Add failed.. release our entry, destroying player
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Error adding player to nametable hr=0x%x", hr );
		pNewPlayer->Release();
		return hr;
	}

	// If we're mixing session add this player to the mixing server "add queue"
	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		AddPlayerToMixingAddList( pNewPlayer );
	}

	// Add player to the "active" list!
	DNEnterCriticalSection( &m_csPlayerActiveList );
	pNewPlayer->AddToNotifyList(&m_blPlayerActiveList);
	pNewPlayer->AddRef();
	DNLeaveCriticalSection( &m_csPlayerActiveList );

    *ppPlayer = pNewPlayer;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSettingsConfirm"
//
// HandleSettingsConfirm
//
// Called to handle the DVMSGID_SETTINGSCONFIRM message.  Creates a player entry for
// the specified player and optionally informs all players in the session.
//
// Called By:
// - ReceiveSpeechMessage
//
// Locks Required:
// - Global Write Lock
//
BOOL CDirectVoiceServerEngine::HandleSettingsConfirm( DVID dvidSource, PDVPROTOCOLMSG_SETTINGSCONFIRM lpdvSettingsConfirm, DWORD dwSize )
{
	HRESULT hr;
	CVoicePlayer *pPlayer;

	if ( dwSize != sizeof( DVPROTOCOLMSG_SETTINGSCONFIRM ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSettingsConfirm() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	if( !ValidateSettingsFlags( lpdvSettingsConfirm->dwFlags ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleSettingsConfirm() Ignoring message with invalid client flags, flags=0x%x, from=0x%x",
			 lpdvSettingsConfirm->dwFlags, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "HandleSettingsConfirm: Start [ID=0x%x]", dvidSource );
	
	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Ignoring settings confirm message, not hosting" );
		return TRUE;
	}

	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Received settings confirm [ID=0x%x]", dvidSource );

	DWORD dwHostOrderID;

	DNEnterCriticalSection( &m_csHostOrderLock );

	// This is a host migration version of this message, so re-use existing 
	// host order ID
	//
	if( lpdvSettingsConfirm->dwHostOrderID != DVPROTOCOL_HOSTORDER_INVALID )
	{
		dwHostOrderID = lpdvSettingsConfirm->dwHostOrderID;	

		// Further reduce chances of duplicate ID, if we received a host order ID > then
		// the last ID offset the next value by offset again.
		if( dwHostOrderID > m_dwNextHostOrderID )
		{
			m_dwNextHostOrderID += DVMIGRATE_ORDERID_OFFSET;
		}
	}
	else
	{
		dwHostOrderID = m_dwNextHostOrderID;		
		m_dwNextHostOrderID++;
	}

	DNLeaveCriticalSection( &m_csHostOrderLock );

	hr = CreatePlayerEntry( dvidSource, lpdvSettingsConfirm, dwHostOrderID, &pPlayer );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Error creating player entry. [ID=0x%x] hr=0x%x", dvidSource, hr );
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Normal during host migration" );
		return TRUE;
	}
	else
	{
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Player Created [ID=0x%x]", dvidSource );
	}

	if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER )
	{
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Sending current player list [ID=0x%x]", dvidSource );
		
		hr = SendPlayerList( dvidSource, dwHostOrderID );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to send player list to player [ID=0x%x] hr=0x%x", dvidSource, hr );
		}
		else
		{
			DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Playerlist sent [[ID=0x%x]", dvidSource );
		}

		hr = Send_CreatePlayer( DVID_ALLPLAYERS, pPlayer );

		if( FAILED( hr ) )
		{
		    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Send to all for new player failed hr=0x%x", hr );
		}
		else
		{
    		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Informed players of join of [ID=0x%x]", dvidSource );
		}
	}
	else if( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING )
	{
		hr = Send_CreatePlayer( dvidSource, pPlayer );

		if( FAILED( hr ) )
		{
		    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Send to player for new player failed hr=0x%x", hr );
		}
        else
        {
    		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Informed player of their own join [ID=0x%x]", dvidSource );
        }
	}


	DVMSG_CREATEVOICEPLAYER dvCreatePlayer;
	dvCreatePlayer.dvidPlayer = dvidSource;
	dvCreatePlayer.dwFlags = lpdvSettingsConfirm->dwFlags;
	dvCreatePlayer.dwSize = sizeof( DVMSG_CREATEVOICEPLAYER );
	dvCreatePlayer.pvPlayerContext = NULL;

	TransmitMessage( DVMSGID_CREATEVOICEPLAYER, &dvCreatePlayer, sizeof( DVMSG_CREATEVOICEPLAYER ) );

	pPlayer->SetContext( dvCreatePlayer.pvPlayerContext );

    // Release our reference to the player 
	pPlayer->Release();

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done processing [ID=0x%x]", dvidSource );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleSettingsReject"
//
// HandleSettingsReject
//
// This message type is ignored.
//
BOOL CDirectVoiceServerEngine::HandleSettingsReject( DVID dvidSource, PDVPROTOCOLMSG_GENERIC lpdvGeneric, DWORD dwSize )
{
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleConnectRequest"
//
// HandleConnectRequest
//
// This function is responsible for responding to user connect requests.  It is the server's
// oportunity to reject or accept players.  Called in response to a DVMSGID_CONNECTREQUEST
// message.
//
// Called By:
// - ReceiveSpeechMessage
//
// Locks Required:
// - Global Read Lock
// 
BOOL CDirectVoiceServerEngine::HandleConnectRequest( DVID dvidSource, PDVPROTOCOLMSG_CONNECTREQUEST lpdvConnectRequest, DWORD dwSize )
{
	HRESULT hr;

	if ( dwSize != sizeof( DVPROTOCOLMSG_CONNECTREQUEST ) )
	{
		DPFX( DPFPREP, DVF_ANTIHACK_DEBUG_LEVEL, "DVSE::HandleConnectRequest() Ignoring incorrectly sized message, size=0x%x, from=0x%x",
			dwSize, dvidSource );
		return FALSE;
	}
	
	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Receive Connect Request.. From [ID=0x%x]", dvidSource );
	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Processing Request.. [ID=0x%x]", dvidSource );

	// Handle case where we've shutdown or starting up and we
	// receive this message
	//
	if( m_dwCurrentState != DVSSTATE_RUNNING )
	{
		hr = Send_ConnectRefuse( dvidSource, DVERR_NOTHOSTING );

    	if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Error! Failed on internal send hr=0x%x", hr );
		}

		return TRUE;
	}

	if( !CheckProtocolCompatible( lpdvConnectRequest->ucVersionMajor, 
							   lpdvConnectRequest->ucVersionMinor, 
							   lpdvConnectRequest->dwVersionBuild )	)
	{
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Protocol is not compatible.  [ID=0x%x] Current=%d.%d b%d User=%d.%d b%d", dvidSource,
							DVPROTOCOL_VERSION_MAJOR, 
							DVPROTOCOL_VERSION_MINOR,
							DVPROTOCOL_VERSION_BUILD,
							lpdvConnectRequest->ucVersionMajor, 
  						    lpdvConnectRequest->ucVersionMinor, 
							lpdvConnectRequest->dwVersionBuild );
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Rejecting connection request. [ID=0x%x]", dvidSource );

		hr = Send_ConnectRefuse( dvidSource, DVERR_INCOMPATIBLEVERSION );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Error! Failed on internal send hr=0x%x", hr );
		}		

		return TRUE;
	}

	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Processing Request..2 [ID=0x%x]", dvidSource );

	hr = Send_ConnectAccept( dvidSource );

    if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending player's connect request: hr=0x%x", hr );
		//// TODO: Handle this case better
	}
	else
	{
		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Sent connect request [ID=0x%x]", dvidSource );
	}

	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Processing Request..4 [ID=0x%x]", dvidSource );

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StopTransportSession"
//
// StopTransportSession
// 
// This function is called by the transport when the transport session
// is stopped.
//
// Called By:
// - DV_NotifyEvent
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::StopTransportSession()
{
	StopSession(0,FALSE,DVERR_SESSIONLOST);
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartTransportSession"
HRESULT CDirectVoiceServerEngine::StartTransportSession( )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::AddPlayer"
HRESULT CDirectVoiceServerEngine::AddPlayer( DVID dvID )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::RemovePlayer"
HRESULT CDirectVoiceServerEngine::RemovePlayer( DVID dvID )
{
	if( m_voiceNameTable.IsEntry( dvID ) )
	{
		DoPlayerDisconnect( dvID, FALSE );
	}

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::CreateGroup"
HRESULT CDirectVoiceServerEngine::CreateGroup( DVID dvID )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::DeleteGroup"
HRESULT CDirectVoiceServerEngine::DeleteGroup( DVID dvID )
{
	FindAndRemoveDeadTarget( dvID );	
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::AddPlayerToGroup"
HRESULT CDirectVoiceServerEngine::AddPlayerToGroup( DVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::RemovePlayerFromGroup"
HRESULT CDirectVoiceServerEngine::RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetCurrentState"
// SetCurrentState
//
// Sets the current state of the client engine
// 
void CDirectVoiceServerEngine::SetCurrentState( DWORD dwState )
{
	m_dwCurrentState = dwState;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::MigrateHost"
//
// MigrateHost
//
// This function is responsible for stoping the host in the case where the host
// suddenly migrates from this client.
//
// In most cases the session will be lost before this occurs on the local object
// and this will never get called.
// 
HRESULT CDirectVoiceServerEngine::MigrateHost( DVID dvidNewHost, LPDIRECTPLAYVOICESERVER lpdvServer )
{
	// Cleanup... 
//	return StopSession( DVFLAGS_SYNC, TRUE );
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::InternalSetNotifyMask"
// 
// SetNotifyMask
//
HRESULT CDirectVoiceServerEngine::InternalSetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{
    BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();

	if( m_lpdwMessageElements != NULL )
	{
		delete [] m_lpdwMessageElements;
	}

	m_dwNumMessageElements = dwNumElements;

	// Make copies of the message elements into our own message array.
	if( m_dwNumMessageElements > 0 )
	{
		m_lpdwMessageElements = new DWORD[m_dwNumMessageElements];

		if( m_lpdwMessageElements == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Initialize: Error allocating memory" );
			return DVERR_OUTOFMEMORY;
		}

		memcpy( m_lpdwMessageElements, lpdwMessages, sizeof(DWORD)*m_dwNumMessageElements );
	}
	else
	{
		m_lpdwMessageElements = NULL;
	}	

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::SetNotifyMask"
// 
// SetNotifyMask
//
// This function sets the notification mask for the DirectPlayVoice object.
//
// The array passed in lpdwMessages specify the ID's of the notifications the user wishes to
// receive.  This or specifying NULL for the array turns on all notifications.
//
// Called By:
// - DVS_SetNotifyMask
//
// Locks Required:
// - m_csNotifyLock (Notification array lock)
//
HRESULT CDirectVoiceServerEngine::SetNotifyMask( LPDWORD lpdwMessages, DWORD dwNumElements )
{
	HRESULT hr;

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Enter" );	
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_APIPARAM, "lpdwMessages = 0x%p dwNumElements = %d", lpdwMessages, dwNumElements );

	hr = DV_ValidMessageArray( lpdwMessages, dwNumElements, TRUE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid message array hr=0x%x", hr);
		return hr;
	}

	DPFX(DPFPREP,  DVF_APIPARAM, "Message IDs=%d", dwNumElements );

	if( lpdwMessages != NULL )
	{
		for( DWORD dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
		{
			DPFX(DPFPREP,  DVF_APIPARAM, "MessageIDs[%d] = %d", dwIndex, lpdwMessages[dwIndex] );
		}
	}

	if( m_dwCurrentState == DVSSTATE_NOTINITIALIZED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Not initialized" );
		return DVERR_NOTINITIALIZED;
	}

	BFCSingleLock slLock( &m_csNotifyLock );
    slLock.Lock();		

    if( m_lpMessageHandler == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify message mask there is no callback function" );
    	return DVERR_NOCALLBACK;
    } 	

    hr = InternalSetNotifyMask( lpdwMessages, dwNumElements );

	DPFX(DPFPREP,  DVF_ENTRYLEVEL, "Done" );

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CleanupActiveList"
void CDirectVoiceServerEngine::CleanupActiveList()
{
	BILINK *pblSearch;
	CVoicePlayer *pVoicePlayer;

	DNEnterCriticalSection( &m_csPlayerActiveList );

	pblSearch = m_blPlayerActiveList.next;

	while( pblSearch != &m_blPlayerActiveList )
	{
		pVoicePlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );

		pblSearch = pblSearch->next;

		pVoicePlayer->RemoveFromNotifyList();
		pVoicePlayer->Release();
	}

	DNLeaveCriticalSection( &m_csPlayerActiveList );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::GetTransmitBuffer"
PDVTRANSPORT_BUFFERDESC CDirectVoiceServerEngine::GetTransmitBuffer( DWORD dwSize, LPVOID *ppvSendContext )
{
    PDVTRANSPORT_BUFFERDESC pNewBuffer = NULL;
    DWORD dwFPMIndex = 0xFFFFFFFF;
    DWORD dwWastedSpace = 0xFFFFFFFF;
    DWORD dwSearchFPMIndex;

    DNEnterCriticalSection( &m_csBufferLock );

    pNewBuffer = (PDVTRANSPORT_BUFFERDESC) m_pBufferDescPool->Get( m_pBufferDescPool );

    DNLeaveCriticalSection( &m_csBufferLock );

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer desc address 0x%p", (void *) pNewBuffer );

    if( pNewBuffer == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting transmit buffer" );
        goto GETTRANSMITBUFFER_ERROR;
    }

	pNewBuffer->lRefCount = 0;
	pNewBuffer->dwObjectType = DVTRANSPORT_OBJECTTYPE_SERVER;
	pNewBuffer->dwFlags = 0;
	pNewBuffer->pBufferData = NULL;

    for( dwSearchFPMIndex = 0; dwSearchFPMIndex < m_dwNumPools; dwSearchFPMIndex++ )
    {
        // Potential pool
        if( m_pdwBufferPoolSizes[dwSearchFPMIndex] >= dwSize )
        {
            if( m_pdwBufferPoolSizes[dwSearchFPMIndex] - dwSize < dwWastedSpace )
            {
                dwWastedSpace = m_pdwBufferPoolSizes[dwSearchFPMIndex] - dwSize;
                dwFPMIndex = dwSearchFPMIndex;
            }
        }
    }

    if( dwFPMIndex == 0xFFFFFFFF )
    {
        DNASSERT( FALSE );
        DPFX(DPFPREP,  0, "Could not find pool large enough for buffer" );
        goto GETTRANSMITBUFFER_ERROR;
    }
	
	pNewBuffer->pvContext = m_pBufferPools[dwFPMIndex];

    DNEnterCriticalSection( &m_csBufferLock );	
    pNewBuffer->pBufferData = (PBYTE) m_pBufferPools[dwFPMIndex]->Get(m_pBufferPools[dwFPMIndex]);
    DNLeaveCriticalSection( &m_csBufferLock );

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Got a buffer value at address 0x%p", (void *) pNewBuffer->pBufferData );
	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: nInUse  = %i", m_pBufferDescPool->nInUse );		

    if( pNewBuffer->pBufferData == NULL )
    {
        DPFX(DPFPREP,  0, "Error getting buffer for buffer desc" );
        goto GETTRANSMITBUFFER_ERROR;
    }
    
    pNewBuffer->dwBufferSize = dwSize;

    *ppvSendContext = pNewBuffer;

    return pNewBuffer;

GETTRANSMITBUFFER_ERROR:

    DNEnterCriticalSection( &m_csBufferLock );
    if( pNewBuffer != NULL && pNewBuffer->pBufferData != NULL )
    {
        ((PFPOOL) pNewBuffer->pvContext)->Release( ((PFPOOL) pNewBuffer->pvContext), pNewBuffer->pBufferData );
    }

    if( pNewBuffer != NULL )
    {
        m_pBufferDescPool->Release( m_pBufferDescPool, pNewBuffer );
    }
    DNLeaveCriticalSection( &m_csBufferLock );

    return NULL;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ReturnTransmitBuffer"
// ReturnTransmitBuffer
//
// PDVTRANSPORT_BUFFERDESC pBufferDesc - Buffer description of buffer to return
// LPVOID lpvContext - Context value to be used when returning the buffer 
// 
void CDirectVoiceServerEngine::ReturnTransmitBuffer( PVOID pvContext )
{
    PDVTRANSPORT_BUFFERDESC pBufferDesc = (PDVTRANSPORT_BUFFERDESC) pvContext;
    PFPOOL pPool = (PFPOOL) pBufferDesc->pvContext;

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer desc at address 0x%p", (void *) pBufferDesc );
	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: Returning a buffer at address 0x%p", (void *) pBufferDesc->pBufferData );

    DNEnterCriticalSection( &m_csBufferLock );

    // Release memory
    pPool->Release( pPool, pBufferDesc->pBufferData );

    // Release buffer description
    m_pBufferDescPool->Release( m_pBufferDescPool, pvContext );

	DPFX(DPFPREP,  DVF_BUFFERDESC_DEBUG_LEVEL, "BUFFERDESC: nInUse  = %i", m_pBufferDescPool->nInUse );    

    DNLeaveCriticalSection( &m_csBufferLock );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SendComplete"
HRESULT CDirectVoiceServerEngine::SendComplete( PDVEVENTMSG_SENDCOMPLETE pSendComplete )
{
    ReturnTransmitBuffer( pSendComplete->pvUserContext );
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SetupBuffers"
HRESULT CDirectVoiceServerEngine::SetupBuffers()
{
    HRESULT hr = DV_OK;

    DWORD dwIndex = 0;

    m_dwNumPools = SERVER_POOLS_NUM;

    m_pBufferDescPool = FPM_Create( sizeof(DVTRANSPORT_BUFFERDESC), NULL, NULL, NULL, NULL, 
    								&m_pServerStats->m_dwBufferDescOustanding, 
    								&m_pServerStats->m_dwBufferDescAllocated );

    if( m_pBufferDescPool == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DVERR_OUTOFMEMORY;
        goto SETUPBUFFERS_ERROR;
    }

    m_pBufferPools = new PFPOOL[m_dwNumPools];

    if( m_pBufferPools == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DVERR_OUTOFMEMORY;
        goto SETUPBUFFERS_ERROR;
    }

    memset( m_pBufferPools, 0x00, sizeof( PFPOOL ) * m_dwNumPools );

    m_pdwBufferPoolSizes = new DWORD[m_dwNumPools];

    if( m_pdwBufferPoolSizes == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        hr = DVERR_OUTOFMEMORY;
        goto SETUPBUFFERS_ERROR;
    }

    m_pdwBufferPoolSizes[0] = SERVER_POOLS_SIZE_MESSAGE;
    m_pdwBufferPoolSizes[1] = SERVER_POOLS_SIZE_PLAYERLIST;
    m_pdwBufferPoolSizes[2] = sizeof( DVPROTOCOLMSG_SPEECHWITHFROM )+m_dwCompressedFrameSize+COMPRESSION_SLUSH;

    for( dwIndex = 0; dwIndex < m_dwNumPools; dwIndex++ )
    {
        m_pBufferPools[dwIndex] = FPM_Create( m_pdwBufferPoolSizes[dwIndex], NULL, NULL, NULL, NULL, 
        									  &m_pServerStats->m_dwPacketsOutstanding[dwIndex], 
        									  &m_pServerStats->m_dwPacketsAllocated[dwIndex] );

        if( m_pBufferPools == NULL )
        {
            DPFX(DPFPREP,  0, "Error creating transmit buffers" );
            goto SETUPBUFFERS_ERROR;
        }
    }

    return DV_OK;

SETUPBUFFERS_ERROR:

    FreeBuffers();

    return hr;
        
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::FreeBuffers"
HRESULT CDirectVoiceServerEngine::FreeBuffers()
{
    DWORD dwIndex;

    if( m_pBufferPools != NULL )
    {
        for( dwIndex  = 0; dwIndex < m_dwNumPools; dwIndex++ )
        {
            if( m_pBufferPools[dwIndex] != NULL )
                m_pBufferPools[dwIndex]->Fini(m_pBufferPools[dwIndex], FALSE);
        }
        
        delete [] m_pBufferPools;

        m_pBufferPools = NULL;
    }

    if( m_pdwBufferPoolSizes != NULL )
    {
        delete [] m_pdwBufferPoolSizes;
        m_pdwBufferPoolSizes = 0;
    }

    if( m_pBufferDescPool != NULL )
    {
        m_pBufferDescPool->Fini( m_pBufferDescPool, FALSE );
        m_pBufferDescPool = NULL;
    }

    m_dwNumPools = 0;

    return DV_OK;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::FindAndRemoveDeadTargets"
//
// FindAndRemoveDeadTargets
//
// This function when called with the server controlled targetting flag active
// scans the list of players and for each player checks to see if the specified
// DVID is in their target list.  If the player IS in the target list the target
// list for the player is updated and and update is sent to the client.
//
// Parameters:
// dvidID - ID of the player who has been removed for some reason.
// 
void CDirectVoiceServerEngine::FindAndRemoveDeadTarget( DVID dvidID )
{
	if( !(m_dvSessionDesc.dwFlags & DVSESSION_SERVERCONTROLTARGET) )
		return;
		
	DPFX(DPFPREP, DVF_INFOLEVEL, "Player/Group ID [0x%x] was removed, checking player target lists", dvidID );

	// Grab the active player list lock so we can run the list
	DNEnterCriticalSection( &m_csPlayerActiveList );

	BILINK *pblSearch = NULL;
	CVoicePlayer *pPlayer = NULL;
	HRESULT hr = DV_OK;

	pblSearch = m_blPlayerActiveList.next;

	while( pblSearch != &m_blPlayerActiveList )
	{
		pPlayer = CONTAINING_RECORD(pblSearch, CVoicePlayer, m_blNotifyList);

		DNASSERT( pPlayer );

		// Lock the specified player -- we have to to ensure that we don't get another
		// simultaneous taregtting update that races this one.  
		pPlayer->Lock();

		// Specified target was in this player's target list
		if( pPlayer->FindAndRemovePlayerTarget(dvidID) )
		{
			// Send an update to the client 
			hr = BuildAndSendTargetUpdate( pPlayer->GetPlayerID(),pPlayer );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP, DVF_INFOLEVEL, "Unable to send target update to player [0x%x] hr=[0x%x]", pPlayer->GetPlayerID(), hr );
			}
		}

		pPlayer->UnLock();
			
		pblSearch = pblSearch->next;
	}

	DNLeaveCriticalSection( &m_csPlayerActiveList );
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ValidateSettingsFlags"
BOOL CDirectVoiceServerEngine::ValidateSettingsFlags( DWORD dwFlags )
{
	return ((dwFlags == 0) || (dwFlags == DVPLAYERCAPS_HALFDUPLEX));
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ValidatePacketType"
BOOL CDirectVoiceServerEngine::ValidatePacketType( PDVPROTOCOLMSG_FULLMESSAGE lpdvFullMessage )
{

	switch( lpdvFullMessage->dvGeneric.dwType )
	{
	case DVMSGID_SPEECHWITHTARGET:
		return ( ( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_FORWARDING ) || 
				( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING ) );
		break;
	case DVMSGID_SPEECH:
		return ( ( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_MIXING ) ||
				( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_PEER ) ||
				( m_dvSessionDesc.dwSessionType == DVSESSIONTYPE_ECHO ) );
		break;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvserver.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvserver.cpp
 *  Content:	Implements functions for the IDirectXVoiceServer interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/02/99	rodtoll	Created It
 *  07/26/99	rodtoll	Updated QueryInterface to support IDirectXVoiceNotify
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added parameter to the GetCompressionTypes func
 *  09/10/99	rodtoll	Object validity checking 
 *  09/14/99	rodtoll	Added DVS_SetNotifyMask  
 *  10/05/99	rodtoll	Reversed destruction order to destroy object before
 *						transport.  Fixes crash on host migration shutdown.  
 *  10/18/99	rodtoll	Fix: Passing NULL in QueryInterface casues crash 
 *				rodtoll	Fix: Calling Initialize twice passes 
 *  10/19/99	rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if stopsession should be called from release
 *  10/25/99	rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 *  01/14/2000	rodtoll	Updated with new parameters for Set/GetTransmitTarget
 *				rodtoll	Removed DVFLAGS_SYNC from StopSession call
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DVS_Release"
STDAPI DVS_Release(LPDIRECTVOICESERVEROBJECT lpDV )
{
    HRESULT hr=S_OK;
    LONG rc;

	if( !DV_ValidDirectXVoiceServerObject( lpDV ) )
		return DVERR_INVALIDOBJECT;

	DNEnterCriticalSection( &lpDV->csCountLock );
	
	if (lpDV->lIntRefCnt == 0)
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );
		return 0;
	}

	// dec the interface count
	lpDV->lIntRefCnt--;

	// Special case: Releasing object without stopping session
	if( (lpDV->lIntRefCnt == 0) && lpDV->lpDVServerEngine->GetCurrentState() != DVSSTATE_IDLE )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Releasing interface without calling StopSession" );

		lpDV->lIntRefCnt = 0;

		// We must release the lock because stopsession may call back into this function
		DNLeaveCriticalSection( &lpDV->csCountLock );		

		hr = lpDV->lpDVServerEngine->StopSession( 0 );

		DNEnterCriticalSection( &lpDV->csCountLock );			

		if( hr != DV_OK && hr != DVERR_SESSIONLOST  )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "StopSession Failed hr=0x%x", hr );
		}

	}

	rc = lpDV->lIntRefCnt;

	if ( lpDV->lIntRefCnt == 0 )
	{
		// Leave the critical section, we may call back into this func.
		// (Shouldn't though).
		DNLeaveCriticalSection( &lpDV->csCountLock );

		DNASSERT( lpDV->lpDVServerEngine );

		delete lpDV->lpDVServerEngine;
		lpDV->lpDVServerEngine = NULL;

		if( lpDV->lpDVTransport != 0 )
		{
			DNASSERT( lpDV->lpDVTransport->m_lRefCount == 0 );				
			delete lpDV->lpDVTransport;
			lpDV->lpDVTransport = NULL;
		}

		DNDeleteCriticalSection( &lpDV->csCountLock );

		DNFree(lpDV);

		DecrementObjectCount();
	} 
	else
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );
	}
   	
    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_QueryInterface"
STDMETHODIMP DVS_QueryInterface(LPDIRECTVOICESERVEROBJECT lpDVS, REFIID riid, LPVOID * ppvObj) 
{
    HRESULT hr = S_OK;

	if( ppvObj == NULL ||
	    !DNVALID_WRITEPTR( ppvObj, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for object" );
		return DVERR_INVALIDPOINTER;
	}	
    
     *ppvObj=NULL;

	if( !DV_ValidDirectXVoiceServerObject( lpDVS ) )
		return DVERR_INVALIDOBJECT;     

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IDirectPlayVoiceServer ) )
    {
		*ppvObj = lpDVS;
		DV_AddRef(lpDVS);
    }
	else if( IsEqualIID(riid, IID_IDirectPlayVoiceNotify ) )
	{
		*ppvObj = &lpDVS->dvNotify;
		DV_Notify_AddRef(&lpDVS->dvNotify);
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    return hr;

}//DVS_QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_StartSession"
STDMETHODIMP DVS_StartSession(LPDIRECTVOICESERVEROBJECT This, LPDVSESSIONDESC lpdvSessionDesc, DWORD dwFlags )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->StartSession( lpdvSessionDesc, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_StopSession"
STDMETHODIMP DVS_StopSession(LPDIRECTVOICESERVEROBJECT This, DWORD dwFlags )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->StopSession( dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_GetSessionDesc"
STDMETHODIMP DVS_GetSessionDesc(LPDIRECTVOICESERVEROBJECT This, LPDVSESSIONDESC lpdvSessionDesc )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->GetSessionDesc( lpdvSessionDesc );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_SetSessionDesc"
STDMETHODIMP DVS_SetSessionDesc(LPDIRECTVOICESERVEROBJECT This, LPDVSESSIONDESC lpdvSessionDesc )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->SetSessionDesc( lpdvSessionDesc );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_GetCaps"
STDMETHODIMP DVS_GetCaps(LPDIRECTVOICESERVEROBJECT This, LPDVCAPS lpdvCaps )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->GetCaps( lpdvCaps );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_GetCompressionTypes"
STDMETHODIMP DVS_GetCompressionTypes( LPDIRECTVOICESERVEROBJECT This, LPVOID lpDataBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags)
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->GetCompressionTypes( lpDataBuffer, lpdwSize, lpdwNumElements, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_SetTransmitTarget"
STDMETHODIMP DVS_SetTransmitTarget( LPDIRECTVOICESERVEROBJECT This, DVID dvidSource, PDVID pdvidTargets, DWORD dwNumTargets, DWORD dwFlags)
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->SetTransmitTarget( dvidSource, pdvidTargets, dwNumTargets, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_GetTransmitTarget"
STDMETHODIMP DVS_GetTransmitTarget( LPDIRECTVOICESERVEROBJECT This, DVID dvidSource, LPDVID pdvidTargets, PDWORD pdwNumElements, DWORD dwFlags)
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;	

	return This->lpDVServerEngine->GetTransmitTarget( dvidSource, pdvidTargets, pdwNumElements, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_SetNotifyMask"
STDMETHODIMP DVS_SetNotifyMask( LPDIRECTVOICESERVEROBJECT This, LPDWORD lpdwMessages, DWORD dwNumElements )
{
	DNASSERT( This != NULL );
	DNASSERT( This->lpDVEngine != NULL );

	if( !DV_ValidDirectXVoiceServerObject( This ) )
		return DVERR_INVALIDOBJECT;

	return This->lpDVServerEngine->SetNotifyMask( lpdwMessages, dwNumElements );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsetup.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvsetup.h
 *  Content:	Defines functions for the DirectXVoiceClient interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/02/99	pnewson	Created It
 *  11/04/99	pnewson Bug #115297 - removed unused members of Setup interface
 *									- added HWND to check audio setup
 *  11/30/99	pnewson	Bug #117449 - IDirectPlayVoiceSetup Parameter validation
 * 05/03/2000   rodtoll Bug #33640 - CheckAudioSetup takes GUID * instead of const GUID *  
 *
 ***************************************************************************/

#ifndef __DVSETUP__
#define __DVSETUP__

class CDirectVoiceSetup;

struct DIRECTVOICESETUPOBJECT
{
	LPVOID				lpVtbl;
	LONG				lIntRefCnt;
	DNCRITICAL_SECTION	csCountLock;
	CDirectVoiceSetup*	lpDVSetup;
};

typedef DIRECTVOICESETUPOBJECT *LPDIRECTVOICESETUPOBJECT;

#ifdef __cplusplus
extern "C" {
#endif

STDAPI DVT_AddRef(LPDIRECTVOICESETUPOBJECT lpDVT);
STDAPI DVT_Release(LPDIRECTVOICESETUPOBJECT lpDVT );
STDAPI DVT_QueryInterface( LPDIRECTVOICESETUPOBJECT lpDVT, REFIID riid, LPVOID * ppvObj );
STDAPI DVT_CheckAudioSetup( LPDIRECTVOICESETUPOBJECT, const GUID *,  const GUID * , HWND, DWORD );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsetupi.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvsetupi.cpp
 *  Content:	Implementation of class for DirectXVoice Setup utility functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/02/99		pnewson Created it
 * 11/04/99		pnewson Bug #115297 - removed unused members of Setup interface
 *									- added HWND to check audio setup
 * 05/03/2000   rodtoll Bug #33640 - CheckAudioSetup takes GUID * instead of const GUID *  
 *
 ***************************************************************************/

#include "dxvoicepch.h"


// CDirectVoiceSetup
//
// This class represents the IDirectXVoiceSetup interface.
//
// The class is thread safe except for construction and
// destruction.
//

CDirectVoiceSetup::CDirectVoiceSetup( DIRECTVOICESETUPOBJECT *lpObject )
{
	return;
}

CDirectVoiceSetup::~CDirectVoiceSetup()
{
	return;
}

HRESULT CDirectVoiceSetup::CheckAudioSetup(
	const GUID *  lpguidRenderDevice, 
	const GUID *  lpguidCaptureDevice,
	HWND hwndParent,
	DWORD dwFlags)
{
	return SupervisorCheckAudioSetup(
		lpguidRenderDevice, 
		lpguidCaptureDevice, 
		hwndParent,
		dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsetupi.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvsetupi.h
 *  Content:	Definition of class for DirectXVoice Setup utility functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/02/99		pnewson Created it
 * 11/04/99		pnewson Bug #115297 - removed unused members of Setup interface
 *									- added HWND to check audio setup
 * 05/03/2000   rodtoll Bug #33640 - CheckAudioSetup takes GUID * instead of const GUID * 
 *
 ***************************************************************************/

#ifndef __DVSETUPENGINE_H
#define __DVSETUPENGINE_H

struct DIRECTVOICESETUPOBJECT;

// CDirectVoiceSetup
//
// This class represents the IDirectXVoiceSetup interface.
//
// The class is thread safe except for construction and
// destruction.
//
class CDirectVoiceSetup
{
public:
	CDirectVoiceSetup( DIRECTVOICESETUPOBJECT *lpObject );
	~CDirectVoiceSetup();

public: // IDirectXVoiceSetup Interface
	HRESULT CheckAudioSetup( const GUID * guidRenderDevice, const GUID * guidCaptureDevice, HWND hwndParent, DWORD dwFlags );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvserver.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvserver.h
 *  Content:	Defines functions for the DirectXVoiceServer interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	02/07/99	rodtoll	Created It
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system. 
 *						Added parameter to GetCompressionTypes
 *  09/14/99	rodtoll	Added DVS_SetNotifyMask
 *  01/14/2000	rodtoll	Updated with new parameters for Set/GetTransmitTarget
 ***************************************************************************/
#ifndef __DVSERVER__
#define __DVSERVER__

class CDirectVoiceServerEngine;

volatile struct DIRECTVOICESERVEROBJECT : public DIRECTVOICEOBJECT
{
	CDirectVoiceServerEngine	*lpDVServerEngine;
};

typedef DIRECTVOICESERVEROBJECT *LPDIRECTVOICESERVEROBJECT;

#ifdef __cplusplus
extern "C" {
#endif

STDAPI DVS_QueryInterface( LPDIRECTVOICESERVEROBJECT lpDVC, REFIID riid, LPVOID * ppvObj );
STDAPI DVS_StartSession(LPDIRECTVOICESERVEROBJECT, LPDVSESSIONDESC, DWORD );
STDAPI DVS_StopSession(LPDIRECTVOICESERVEROBJECT, DWORD );
STDAPI DVS_GetSessionDesc(LPDIRECTVOICESERVEROBJECT, LPDVSESSIONDESC );
STDAPI DVS_SetSessionDesc(LPDIRECTVOICESERVEROBJECT, LPDVSESSIONDESC );
STDAPI DVS_GetCaps(LPDIRECTVOICESERVEROBJECT, LPDVCAPS );
STDAPI DVS_GetCompressionTypes( LPDIRECTVOICESERVEROBJECT, LPVOID, LPDWORD, LPDWORD, DWORD );
STDAPI DVS_SetTransmitTarget( LPDIRECTVOICESERVEROBJECT, DVID, PDVID, DWORD, DWORD );
STDAPI DVS_GetTransmitTarget( LPDIRECTVOICESERVEROBJECT, DVID, LPDVID, PDWORD, DWORD );
STDAPI DVS_Release(LPDIRECTVOICESERVEROBJECT lpDV );
STDAPI DVS_SetNotifyMask( LPDIRECTVOICESERVEROBJECT, LPDWORD, DWORD );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsetup.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvsetup.c
 *  Content:	Implements functions for the DirectXVoiceSetup interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/02/99	pnewson Created It
 *  10/25/99	rodtoll	Bug #114098 - Calling AddRef/Release from seperate threads
 *									  on multiproc can cause improper results
 *  11/04/99	pnewson Bug #115297 - removed unused members of Setup interface
 *									- added HWND to check audio setup
 *  11/17/99	rodtoll	Bug #116153 - Setup QueryInterface crashes with NULL pointer
 *  11/30/99	pnewson	Bug #117449 - Parameter validation
 *  05/03/2000  rodtoll Bug #33640 - CheckAudioSetup takes GUID * instead of const GUID *  
 *  08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 * 
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// defined in unk.cpp
extern LPVOID dvtInterface[];

#undef DPF_MODNAME
#define DPF_MODNAME "DVT_ValidDirectXVoiceSetupObject"
// DV_ValidDirectXVoiceSetupObject
//
// Checks to ensure the specified pointer points to a valid directvoice setup
// object.
BOOL DVT_ValidDirectXVoiceSetupObject( LPDIRECTVOICESETUPOBJECT lpdvt )
{
	if (lpdvt == NULL)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Invalid Setup object pointer");
		return FALSE;
	}

	if (!DNVALID_READPTR(lpdvt, sizeof(LPDIRECTVOICESETUPOBJECT)))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Invalid Setup object pointer");
		return FALSE;
	}

	if( lpdvt->lpVtbl != dvtInterface )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid setup vtable" );	
		return FALSE;
	}

	if ( lpdvt->lpDVSetup == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Inavlid CDirectVoiceSetup pointer");
		return FALSE;
	}

	if (!DNVALID_READPTR(lpdvt->lpDVSetup, sizeof(CDirectVoiceSetup)))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Inavlid CDirectVoiceSetup pointer");
		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVT_AddRef"
STDAPI DVT_AddRef(LPDIRECTVOICESETUPOBJECT lpDVT)
{
	LONG rc;

	DNEnterCriticalSection( &lpDVT->csCountLock );
	
	rc = ++lpDVT->lIntRefCnt;

	DNLeaveCriticalSection( &lpDVT->csCountLock );

	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVT_Release"
STDAPI DVT_Release(LPDIRECTVOICESETUPOBJECT lpDV )
{
    HRESULT hr=S_OK;
	LONG rc;

	DNEnterCriticalSection( &lpDV->csCountLock );

	if (lpDV->lIntRefCnt == 0)
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );
		return 0;
	}

	// dec the interface count
	rc = --lpDV->lIntRefCnt;
	
	if (0 == rc)
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );	
		delete lpDV->lpDVSetup;
		DNDeleteCriticalSection( &lpDV->csCountLock );
		DNFree(lpDV);
		DecrementObjectCount();	
	}
	else
	{
		DNLeaveCriticalSection( &lpDV->csCountLock );	
	}
	   	
    return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVT_QueryInterface"
STDMETHODIMP DVT_QueryInterface(LPDIRECTVOICESETUPOBJECT lpDVT, REFIID riid, LPVOID * ppvObj) 
{
    HRESULT hr = S_OK;

    if( ppvObj == NULL ||
        !DNVALID_WRITEPTR( ppvObj, sizeof( LPVOID ) ) )
    {
    	return DVERR_INVALIDPOINTER;
    }
    
     *ppvObj=NULL;

    if( IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IDirectPlayVoiceTest ) )
    {
		*ppvObj = lpDVT;
		DVT_AddRef(lpDVT);
    }
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    return hr;

}//DVT_QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DVT_CheckAudioSetup"
STDMETHODIMP DVT_CheckAudioSetup(LPDIRECTVOICESETUPOBJECT This, const GUID * lpguidRenderDevice, const GUID *  lpguidCaptureDevice, HWND hwndParent, DWORD dwFlags)
{
	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Enter");

	if( !DVT_ValidDirectXVoiceSetupObject( This ) )
		return DVERR_INVALIDOBJECT;	
	
	HRESULT hr;
	hr = This->lpDVSetup->CheckAudioSetup( lpguidRenderDevice, lpguidCaptureDevice, hwndParent, dwFlags );

	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Exit");	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvshared.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvshared.h
 *  Content:	Utility functions for DirectXVoice structures.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created It
 * 07/26/99		rodtoll	Added support for DirectXVoiceNotify objects
 * 08/04/99		rodtoll	Added new validation functions 
 * 08/25/99		rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 *						Added new DUMP functions
 *						Moved several compression functions to dvcdb
 * 09/01/99		rodtoll	Added check for valid pointers in func calls 
 *						Changed return type on DV_ call to HRESULT
 * 09/14/99		rodtoll	Added new Init params and DV_ValidMessageArray
 * 10/04/99		rodtoll	Updated initialize to take LPUNKNOWN instead of LPVOID
 * 10/19/99		rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if stopsession should be called from release
 * 10/25/99		rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads
 * 01/14/2000	rodtoll	Added DV_ValidTargetList function
 * 01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC  
 *						Updated param validations to check new params
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 * 06/21/2000	rodtoll Bug #35767 - Must implement ability for DSound effects processing on Voice buffers
 *						Updated parameter validation to take new parameters.
 * 07/22/2000	rodtoll	Bug #40284 - Initialize() and SetNotifyMask() should return invalidparam instead of invalidpointer 
 * 09/14/2000	rodtoll	Bug #45001 - DVOICE: AV if client has targetted > 10 players
 *
 ***************************************************************************/

#ifndef __DVSHARED_H
#define __DVSHARED_H

struct DIRECTVOICEOBJECT;
class CDirectVoiceEngine;
class CDirectVoiceTransport;

volatile struct DIRECTVOICENOTIFYOBJECT
{
	LPVOID						lpNotifyVtble;
	DIRECTVOICEOBJECT			*lpDV;
	LONG						lRefCnt;
};

volatile struct DIRECTVOICEOBJECT
{
	LPVOID						lpVtbl;
	LONG						lIntRefCnt;
	CDirectVoiceEngine			*lpDVEngine;
	CDirectVoiceTransport		*lpDVTransport;
	DIRECTVOICENOTIFYOBJECT		dvNotify;
	DNCRITICAL_SECTION			csCountLock;
};

typedef DIRECTVOICEOBJECT *LPDIRECTVOICEOBJECT;
typedef DIRECTVOICENOTIFYOBJECT *LPDIRECTVOICENOTIFYOBJECT;

BOOL DV_ValidBufferAggresiveness( DWORD dwValue );
BOOL DV_ValidBufferQuality( DWORD dwValue );
BOOL DV_ValidSensitivity( DWORD dwValue );

HRESULT DV_ValidBufferSettings( LPDIRECTSOUNDBUFFER lpdsBuffer, DWORD dwPriority, DWORD dwFlags, LPWAVEFORMATEX pwfxPlayFormat );
HRESULT DV_ValidClientConfig( LPDVCLIENTCONFIG lpClientConfig );
HRESULT DV_ValidSoundDeviceConfig( LPDVSOUNDDEVICECONFIG lpSoundDeviceConfig, LPWAVEFORMATEX pwfxPlayFormat );
HRESULT DV_ValidSessionDesc( LPDVSESSIONDESC lpSessionDesc );
HRESULT DV_ValidTargetList( PDVID pdvidTargets, DWORD dwNumTargets );

BOOL DV_ValidDirectVoiceObject( LPDIRECTVOICEOBJECT lpdv );
BOOL DV_ValidDirectXVoiceClientObject( LPDIRECTVOICEOBJECT lpdvc );
BOOL DV_ValidDirectXVoiceServerObject( LPDIRECTVOICEOBJECT lpdvs );
HRESULT DV_ValidMessageArray( LPDWORD lpdwMessages, DWORD dwNumMessages, BOOL fServer );

STDAPI DV_AddRef(LPDIRECTVOICEOBJECT lpDV );
STDAPI DV_Initialize( LPDIRECTVOICEOBJECT lpdvObject, LPUNKNOWN lpTransport, LPDVMESSAGEHANDLER lpMessageHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements );

DWORD DV_GetWaveFormatExSize( LPWAVEFORMATEX lpwfxFormat );
HRESULT DV_CopySessionDescToBuffer( LPVOID lpTarget, LPDVSESSIONDESC lpdvSessionDesc, LPDWORD lpdwSize );
HRESULT DV_CopyCompressionInfoArrayToBuffer( LPVOID lpTarget, LPDVCOMPRESSIONINFO lpdvCompressionList, LPDWORD lpdwSize, DWORD dwNumElements  );

void DV_DUMP_Caps( LPDVCAPS lpdvCaps );
void DV_DUMP_CompressionInfo( LPDVCOMPRESSIONINFO lpdvCompressionInfo, DWORD dwNumElements );
void DV_DUMP_FullCompressionInfo( LPDVFULLCOMPRESSIONINFO lpdvfCompressionInfo, DWORD dwNumElements );
void DV_DUMP_SessionDesc( LPDVSESSIONDESC lpdvSessionDesc );
void DV_DUMP_SoundDeviceConfig( LPDVSOUNDDEVICECONFIG lpdvSoundConfig );
void DV_DUMP_ClientConfig( LPDVCLIENTCONFIG lpdvClientConfig );
void DV_DUMP_WaveFormatEx( LPWAVEFORMATEX lpwfxFormat );
void DV_DUMP_GUID( GUID guid );

#ifdef _DEBUG
#define DV_DUMP_CI( ci, ne )	DV_DUMP_CompressionInfo( ci, ne )
#define DV_DUMP_SD( sd )		DV_DUMP_SessionDesc( sd )
#define DV_DUMP_SDC( sdc )		DV_DUMP_SoundDeviceConfig( sdc )
#define DV_DUMP_CC( cc )		DV_DUMP_ClientConfig( cc )
#define DV_DUMP_CAPS( caps )	DV_DUMP_Caps( caps )
#define DV_DUMP_CIF( cif, ne )	DV_DUMP_FullCompressionInfo( cif, ne )
#else 
#define DV_DUMP_CIF( cif, ne )
#define DV_DUMP_CI( ci, ne )
#define DV_DUMP_SD( sd )
#define DV_DUMP_SDC( sdc )
#define DV_DUMP_CC( cc )
#define DV_DUMP_CAPS( caps )
#endif

#define DV_MAX_TARGETS							64
#define CLIENT_POOLS_NUM_TARGETS_BUFFERED  DV_MAX_TARGETS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvshared.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dvshared.cpp
 *  Content:	Utility functions for DirectXVoice structures.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/06/99	rodtoll	Created It
 *  07/26/99	rodtoll	Added support for DirectXVoiceNotify interface
 *  07/30/99	rodtoll Updated to remove references to removed wave members 
 *                      of sounddeviceconfig
 *	08/03/99	rodtoll	Updated to use new IDirectXVoiceNotify interface
 *						transport instead of old test transport
 *	08/04/99	rodtoll	Added new validation functions
 *  08/10/99	rodtoll	Removed TODO pragmas 
 *  08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *						compression sub-system.  
 *						Added new DUMP functions
 *						Moved several compression functions to dvcdb 
 *  09/03/99	rodtoll	Bug #102159 - Parameter Validations on Initialize
 *  09/08/99	rodtoll	Updated for new compression structure in dump func
 *  09/10/99	rodtoll	Added DV_ValidSessionDesc function
 *				rodtoll	Various param validation code added
 *  09/10/99	rodtoll	Complete object validation funcs added
 *  09/13/99	rodtoll	Updated DV_ValidSoundDeviceConfig to reflect new struct
 *              rodtoll Updated DV_DUMP_SoundDeviceConfig for new struct
 *  09/14/99	rodtoll	Added new Init params and DV_ValidMessageArray 
 *  09/20/99	rodtoll	Added checks for memory allocation failures
 *  			rodtoll	Addes stricter checks on notify masks & used new notifyperiodmax
 *  09/29/99	rodtoll	Updated to allow specification of new voice suppression info
 *  10/04/99	rodtoll	Updated to allow initialize to take an LPUNKNOWN instead of LPVOID
 *  10/05/99	rodtoll	Additional comments
 *  10/07/99	rodtoll	Updated to handle Unicode Strings
 *  10/08/99	rodtoll	Fixed for passing NULL in the DirectSound Pointers
 *  10/15/99	rodtoll Removed check for GUID_NULL since default devices are now mapped there
 *  10/18/99	rodtoll	Fix: Calling Initialize twice passes
 *  10/20/99	rodtoll	Fix: Bug #114116 Initialize called with invalid message IDs results in crash
 *  			rodtoll Fix: Bug #114218 Parameter validation for initialize
 *  10/25/99	rodtoll	Fix: Bug #114682 Session Desc maint functions fail
 *  10/27/99	pnewson Fix: Bug #113935 - Saved AGC values should be device specific
 *  10/28/99	pnewson Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/10/99	rodtoll	Adding waveIN/waveOut caps and echo suppression
 *  11/17/99	rodtoll Fix: Bug #115538 - dwSize members of > sizeof struct were accepted
 *              rodtoll Fix: Bug #115827 - Calling SetNotifyMask w/no callback should fail
 *  			rodtoll	Fix: Bug #116440 - Remove unused flags 
 *  11/20/99	rodtoll	Fixed code which allows new force flags to recognize millenium debug flags
 *  11/23/99	rodtoll	Removed unrequired code.
 *				rodtoll Change error for insufficient buffer size to an info level (since expected in many cases)
 *				rodtoll	Fixed ref count problem when calling Iniitalize > 1 times (first time succesful)
 *  12/08/99	rodtoll Fix: Bug #121054 - Added support for new flags supporting capture focus
 *  12/16/99	rodtoll Updated to remove voice suppression and accept new session flags
 *  01/14/2000	rodtoll	Added DV_ValidTargetList function 
 *				rodtoll	Fixed Dump function for DVSOUNDDEVICECONFIG
 *				rodtoll	Updated DV_ValidMessageArray to remove old messages
 *  01/21/2000	pnewson Support DVSOUNDCONFIG_TESTMODE and DVRECORDVOLUME_LAST
 *  01/24/2000	pnewson Added check for valid hwnd DV_ValidSoundDeviceConfig
 *  01/27/2000	rodtoll	Bug #129934 - Update Create3DSoundBuffer to take DSBUFFERDESC  
 *						Updated param validations to check new params 
 *  01/28/2000	rodtoll	Bug #130480 - Updated so Host Migration is no longer valid ID for servers
 * 02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected 
 *  03/29/2000	rodtoll	Added support for new flag: DVSOUNDCONFIG_SETCONVERSIONQUALITY
 *  06/21/2000	rodtoll	Fixed a memory leak if you Connect, Disconnect then Re-Connect.
 *				rodtoll	Bug #35767 We must implement ability to allow DSound effects processing in Voice buffers.
 *  07/22/2000	rodtoll	Bug #40284 - Initialize() and SetNotifyMask() should return invalidparam instead of invalidpointer
 *  08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h, added STR_* and strutils.h
 *  08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *  09/14/2000	rodtoll	Bug #45001 - DVOICE: AV if client has targetted > 10 players 
 *  04/02/2001	simonpow	Bug #354859 Fixes for PREfast (unecessary variable declarations in
 *							DV_ValidBufferSettings method)
 *
 ***************************************************************************/

#include "dxvoicepch.h"


// Useful macros for checking record/suppression volumes
#define DV_ValidRecordVolume( x ) DV_ValidPlaybackVolume( x )
#define DV_ValidSuppressionVolume( x ) DV_ValidPlaybackVolume( x )

// VTABLES for all of the interfaces supported by the object
extern LPVOID dvcInterface[];
extern LPVOID dvsInterface[];
extern LPVOID dvtInterface[];
extern LPVOID dvServerNotifyInterface[];
extern LPVOID dvClientNotifyInterface[];

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidTargetList"
HRESULT DV_ValidTargetList( PDVID pdvidTargets, DWORD dwNumTargets )
{
	if( (pdvidTargets != NULL && dwNumTargets == 0) ||
	    (pdvidTargets == NULL && dwNumTargets > 0 ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid params" );
		return DVERR_INVALIDPARAM;
	}

	if( dwNumTargets == 0 )
		return DV_OK;
	
	if( pdvidTargets != NULL &&
	    !DNVALID_READPTR( pdvidTargets, dwNumTargets*sizeof( DVID ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid array of player targets" );
		return DVERR_INVALIDPOINTER;
	}

	// Search for duplicates in the targets
	for( DWORD dwIndex = 0; dwIndex < dwNumTargets; dwIndex++ )
	{
		if( pdvidTargets[dwIndex] == DVID_ALLPLAYERS && dwNumTargets > 1 )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify allplayers (or noplayers) in addition to other ids" );
			return DVERR_INVALIDPARAM;
		}

		for( DWORD dwInnerIndex = dwIndex+1; dwInnerIndex < dwNumTargets; dwInnerIndex++ )
		{
			if( pdvidTargets[dwInnerIndex] == pdvidTargets[dwIndex] )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Duplicate found in target list" );
				return DVERR_INVALIDPARAM;
			}
		}
	}

	// Set max # of targets to ensure we don't exceed target buffer size
	if( dwNumTargets > DV_MAX_TARGETS )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "You can only have a maximum of %d targets", DV_MAX_TARGETS );
		return DVERR_NOTALLOWED;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidBufferSettings"
// DV_ValidBufferSettings
//
// This function is used to check to ensure that the buffer specified is in a valid 
// format to be used by voice.  
//
HRESULT DV_ValidBufferSettings( LPDIRECTSOUNDBUFFER lpdsBuffer, DWORD dwPriority, DWORD dwFlags, LPWAVEFORMATEX pwfxPlayFormat )
{
	// If buffer was specified make sure it's valid
	if( lpdsBuffer != NULL && 
	   !DNVALID_READPTR( lpdsBuffer, sizeof( IDirectSoundBuffer * ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( lpdsBuffer )
	{
		DWORD dwLength = 0;
		HRESULT hr = DS_OK;
		DWORD dwSize1 = 0, dwSize2 = 0;
		DWORD dwBufferSize1=0, dwBufferSize2=0;
		PVOID pvBuffer1 = NULL, pvBuffer2 = NULL;
		LPWAVEFORMATEX pwfxFormat = NULL;
		DWORD dwFormatSize = 0;
		DSBCAPS dsbCaps;
		DWORD dwStatus = 0;

		// Flip on a try-except block  to ensure calls into dsound don't crash on us.
		_try
		{
			// Get the format of the buffer -- make sure it matches our format
			hr = lpdsBuffer->GetFormat( pwfxFormat, 0, &dwFormatSize );

			if( hr != DSERR_INVALIDPARAM && hr != DS_OK )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting format of ds buffer hr=0x%x", hr );
				return DVERR_INVALIDBUFFER;
			}

			pwfxFormat = (LPWAVEFORMATEX) new BYTE[dwFormatSize];

			if( !pwfxFormat )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
				return DVERR_INVALIDBUFFER;
			}

			hr = lpdsBuffer->GetFormat( pwfxFormat, dwFormatSize, &dwFormatSize );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting format of buffer hr=0x%x", hr );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

			// Make sure the format matches
			if( memcmp( pwfxPlayFormat, pwfxFormat, sizeof( WAVEFORMATEX ) ) != 0 )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "DS buffer is not of the correct format hr=0x%x", hr );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;
			}

			memset( &dsbCaps, 0x00, sizeof( DSBCAPS ) );
			dsbCaps.dwSize = sizeof( DSBCAPS );

			hr = lpdsBuffer->GetCaps( &dsbCaps );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get buffer caps hr=0x%x", hr );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

			if( !(dsbCaps.dwFlags & DSBCAPS_CTRL3D) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "You must specify 3D flags for buffers hr=0x%x", hr );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

			if( !(dsbCaps.dwFlags & DSBCAPS_GETCURRENTPOSITION2) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "You must specify ctrlposnotify for buffers hr=0x%x", hr );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

			if( dsbCaps.dwFlags & DSBCAPS_PRIMARYBUFFER ) 
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "You cannot pass in a primary buffer" );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

		
			if( dsbCaps.dwBufferBytes  < pwfxPlayFormat->nAvgBytesPerSec )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer size is less then one second worth of audio" );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

			hr = lpdsBuffer->GetStatus( &dwStatus );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting buffer status hr=0x%x", hr );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;				
			}

			if( dwStatus & DSBSTATUS_PLAYING )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Buffer must be stopped" );
				hr = DVERR_INVALIDBUFFER;
				goto VALID_EXIT;
			}

				// Check to see if the buffer is locked already
			hr = lpdsBuffer->Lock( 0, 0, &pvBuffer1, &dwBufferSize1, &pvBuffer2, &dwBufferSize2, DSBLOCK_ENTIREBUFFER );

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not lock the buffer, likely is already locked hr=0x%x", hr );
				hr = DVERR_LOCKEDBUFFER;
				goto VALID_EXIT;
			}

			lpdsBuffer->Unlock( pvBuffer1, dwBufferSize1, pvBuffer2, dwBufferSize2 );

VALID_EXIT:
			if( pwfxFormat )
				delete[] pwfxFormat;

			return hr;
		}
		_except( EXCEPTION_EXECUTE_HANDLER )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error during validation of directsound buffer" );
			
			if( pwfxFormat )
				delete[] pwfxFormat;
			
			return DVERR_INVALIDPOINTER;
		}
	}

	return DV_OK;

}


// DV_ValidPlaybackVolume
//
// Checks the specified playback volume to ensure it's valid
BOOL DV_ValidPlaybackVolume( LONG lPlaybackVolume )
{
	if( (lPlaybackVolume >= DSBVOLUME_MIN) && (lPlaybackVolume <= DSBVOLUME_MAX) )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

// DV_ValidNotifyPeriod
//
// Checks the specified notification period to ensure it's valid
//
BOOL DV_ValidNotifyPeriod( DWORD dwNotifyPeriod ) 
{
	if( (dwNotifyPeriod == 0) || (dwNotifyPeriod >= DVNOTIFYPERIOD_MINPERIOD) )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidSoundDeviceConfig"
// DV_ValidSoundDeviceConfig
//
// Checks the specified sound device configuration to ensure that it's 
// valid.
//
HRESULT DV_ValidSoundDeviceConfig( LPDVSOUNDDEVICECONFIG lpSoundDeviceConfig, LPWAVEFORMATEX pwfxPlayFormat ) 
{
	HRESULT hr;
	
	if( lpSoundDeviceConfig == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( !DNVALID_READPTR( lpSoundDeviceConfig, sizeof(DVSOUNDDEVICECONFIG) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid read pointer" );
		return DVERR_INVALIDPOINTER;
	}

	if( lpSoundDeviceConfig->dwSize != sizeof( DVSOUNDDEVICECONFIG ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid size" );
		return DVERR_INVALIDPARAM;
	}

	if( (lpSoundDeviceConfig->dwFlags & DVSOUNDCONFIG_NOFOCUS) &&
	    (lpSoundDeviceConfig->dwFlags & DVSOUNDCONFIG_STRICTFOCUS) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify no focus and strictfocus" );
		return DVERR_INVALIDPARAM;
	}

	if( lpSoundDeviceConfig->dwFlags & 
	    ~(DVSOUNDCONFIG_AUTOSELECT | DVSOUNDCONFIG_HALFDUPLEX |
	      DVSOUNDCONFIG_STRICTFOCUS | DVSOUNDCONFIG_NOFOCUS | 
	      DVSOUNDCONFIG_TESTMODE | DVSOUNDCONFIG_NORMALMODE |
		  DVSOUNDCONFIG_SETCONVERSIONQUALITY | 
#if defined(_DEBUG) || defined(DEBUG) || defined(DBG)
	      DVSOUNDCONFIG_FORCEWAVEOUT | DVSOUNDCONFIG_FORCEWAVEIN | 	    
#endif
		  DVSOUNDCONFIG_ALLOWWAVEOUT | DVSOUNDCONFIG_ALLOWWAVEIN ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags" );		
		return DVERR_INVALIDFLAGS;
	}

	if( (lpSoundDeviceConfig->dwFlags & DVSOUNDCONFIG_NORMALMODE) && lpSoundDeviceConfig->lpdsPlaybackDevice )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify normal mode AND specify dsound object" );
		return DVERR_INVALIDPARAM;
	}

	if( lpSoundDeviceConfig->lpdsPlaybackDevice != NULL)
	{
		if (!DNVALID_READPTR(lpSoundDeviceConfig->lpdsPlaybackDevice, sizeof(IDirectSound)))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid playback device object" );	
			return DVERR_INVALIDPARAM;
		}
	}

	if( lpSoundDeviceConfig->lpdsCaptureDevice != NULL)
	{
		if (!DNVALID_READPTR(lpSoundDeviceConfig->lpdsCaptureDevice, sizeof(IDirectSoundCapture)))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid capture device object" );	
			return DVERR_INVALIDPARAM;
		}
	}

	if (!IsWindow(lpSoundDeviceConfig->hwndAppWindow))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Invalid window handle");
		return DVERR_INVALIDPARAM;
	}

	hr = DV_ValidBufferSettings( lpSoundDeviceConfig->lpdsMainBuffer, 
							  lpSoundDeviceConfig->dwMainBufferPriority,
							  lpSoundDeviceConfig->dwMainBufferFlags, pwfxPlayFormat );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid buffer or buffer settings specified in sound config hr=0x%x", hr );
		return hr;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidClientConfig"
// DV_ValidClientConfig
//
// Checks the valid client configuration structure to ensure it's valid
//
HRESULT DV_ValidClientConfig( LPDVCLIENTCONFIG lpClientConfig )
{
	if( lpClientConfig == NULL || !DNVALID_READPTR(lpClientConfig,sizeof(DVCLIENTCONFIG)) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}

	if( lpClientConfig->dwSize != sizeof( DVCLIENTCONFIG ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid size" );
		return DVERR_INVALIDPARAM;
	}

	if( lpClientConfig->dwFlags & 
	    ~(DVCLIENTCONFIG_RECORDMUTE | DVCLIENTCONFIG_PLAYBACKMUTE | 
	      DVCLIENTCONFIG_AUTOVOICEACTIVATED | DVCLIENTCONFIG_AUTORECORDVOLUME | 
	      DVCLIENTCONFIG_MUTEGLOBAL | DVCLIENTCONFIG_MANUALVOICEACTIVATED |
		  DVCLIENTCONFIG_AUTOVOLUMERESET | DVCLIENTCONFIG_ECHOSUPPRESSION ) 
	  )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	if( lpClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED && 
	   lpClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Cannot specify manual AND auto voice activated" );
		return DVERR_INVALIDFLAGS;
	}

    if( lpClientConfig->dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME ) 
	{
        if( !DV_ValidRecordVolume(lpClientConfig->lRecordVolume) 
	    	&& lpClientConfig->lRecordVolume != DVRECORDVOLUME_LAST )
	    {
	    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid record volume w/auto" );
			return DVERR_INVALIDPARAM;
		}
	}
	else
	{
		if( !DV_ValidRecordVolume( lpClientConfig->lRecordVolume ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid recording volume" );
			return DVERR_INVALIDPARAM;
		}
	}

	if(	!DV_ValidPlaybackVolume( lpClientConfig->lPlaybackVolume ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid playback volume" );
		return DVERR_INVALIDPARAM;
	}

	// If it's NOT manual, this parameter must be 0.
	if( !(lpClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED) )
	{
		if( lpClientConfig->dwThreshold != DVTHRESHOLD_UNUSED )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid sensitivity w/auto" );
			return DVERR_INVALIDPARAM;
		}
	}
	else
	{
		if( !DV_ValidSensitivity( lpClientConfig->dwThreshold ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid sensitivity" );
			return DVERR_INVALIDPARAM;
		}
	}

	if( !DV_ValidBufferAggresiveness( lpClientConfig->dwBufferAggressiveness ) ||
		!DV_ValidBufferQuality( lpClientConfig->dwBufferQuality ) || 
		!DV_ValidNotifyPeriod( lpClientConfig->dwNotifyPeriod ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid volume/aggresiveness/period" );
		return DVERR_INVALIDPARAM;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidSessionDesc"
// DV_ValidSessionDesc
//
// Checks the specified session description to ensure it's valid.
//
HRESULT DV_ValidSessionDesc( LPDVSESSIONDESC lpSessionDesc )
{
	if( lpSessionDesc == NULL ||
		!DNVALID_READPTR( lpSessionDesc, sizeof(DVSESSIONDESC) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );				
		return E_POINTER;
	}

	if( lpSessionDesc->dwSize != sizeof( DVSESSIONDESC) ) 
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid size" );			
		return DVERR_INVALIDPARAM;
	}

	if( !DV_ValidBufferAggresiveness( lpSessionDesc->dwBufferAggressiveness ) ||
		!DV_ValidBufferQuality( lpSessionDesc->dwBufferQuality ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid buffer settings" );		
		return DVERR_INVALIDPARAM;
	}

	if( lpSessionDesc->dwSessionType != DVSESSIONTYPE_PEER &&
	    lpSessionDesc->dwSessionType != DVSESSIONTYPE_MIXING &&
	    lpSessionDesc->dwSessionType != DVSESSIONTYPE_FORWARDING &&
	    lpSessionDesc->dwSessionType != DVSESSIONTYPE_ECHO )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid session type" );	
		return DVERR_INVALIDPARAM;
	}

	if( lpSessionDesc->dwFlags & ~(DVSESSION_SERVERCONTROLTARGET | DVSESSION_NOHOSTMIGRATION) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid flags" );
		return DVERR_INVALIDFLAGS;
	}

	return DV_OK;

}

// DV_ValidBufferAggresiveness
//
// Checks the specified aggressiveness to ensure it's valid
//
BOOL DV_ValidBufferAggresiveness( DWORD dwValue )
{
	if( dwValue != DVBUFFERAGGRESSIVENESS_DEFAULT &&
	    ((dwValue < DVBUFFERAGGRESSIVENESS_MIN) ||
	      dwValue > DVBUFFERAGGRESSIVENESS_MAX) )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

// DV_ValidBufferQuality
//
// Checks the specified buffer quality to ensure it's valid
// 
BOOL DV_ValidBufferQuality( DWORD dwValue )
{
	if( dwValue != DVBUFFERQUALITY_DEFAULT &&
	    ((dwValue < DVBUFFERQUALITY_MIN) ||
	      dwValue > DVBUFFERQUALITY_MAX) )
	{
		return FALSE;
	}		
	else
	{
		return TRUE;
	}
}

// DV_ValidSensitivity
//
// Checks the sensitivity to ensure it's valid
//
BOOL DV_ValidSensitivity( DWORD dwValue )
{
	if( dwValue != DVTHRESHOLD_DEFAULT &&
	    (// Commented out because min is currently 0 (dwValue < DVTHRESHOLD_MIN) || 
	     (dwValue > DVTHRESHOLD_MAX) ) )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_CopySessionDescToBuffer"
//
// DV_CopySessionDescToBuffer
//
// Checks the parameters for validity and then copies the specified session description
// to the specified buffer.  (If it will fit).
//
HRESULT DV_CopySessionDescToBuffer( LPVOID lpTarget, LPDVSESSIONDESC lpdvSessionDesc, LPDWORD lpdwSize )
{ 
	LPDVSESSIONDESC lpSessionDesc = (LPDVSESSIONDESC) lpTarget;

	if( lpdwSize == NULL ||
	    !DNVALID_READPTR( lpdwSize, sizeof(DWORD) ))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer" );
		return E_POINTER;
	}

	if( (*lpdwSize) < sizeof( DVSESSIONDESC ) )
	{
		*lpdwSize = sizeof( DVSESSIONDESC );	

		DPFX(DPFPREP,   DVF_INFOLEVEL, "Error size" );
		return DVERR_BUFFERTOOSMALL;
	}

	*lpdwSize = sizeof( DVSESSIONDESC );	

	if( lpTarget == NULL || !DNVALID_WRITEPTR(lpTarget,sizeof( DVSESSIONDESC )) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Target buffer pointer bad" );
		return E_POINTER;
	}

	memcpy( lpTarget, lpdvSessionDesc, sizeof( DVSESSIONDESC ) ); 

	DPFX(DPFPREP,   DVF_ENTRYLEVEL, "DVCE::GetSessionDesc() Success" );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_GetWaveFormatExSize"
DWORD DV_GetWaveFormatExSize( LPWAVEFORMATEX lpwfxFormat )
{
	DNASSERT( lpwfxFormat != NULL );

	return (lpwfxFormat->cbSize+sizeof(WAVEFORMATEX));
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_AddRef"
STDAPI DV_AddRef(LPDIRECTVOICEOBJECT lpDV )
{
	LONG rc;

	DNEnterCriticalSection( &lpDV->csCountLock );
	
	rc = ++lpDV->lIntRefCnt;

	DNLeaveCriticalSection( &lpDV->csCountLock );

	return rc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_Initialize"
//
// DV_Initialize
//
// Responsible for initializing the specified directvoice object with the specified parameters.
//
STDAPI DV_Initialize( LPDIRECTVOICEOBJECT lpdvObject, LPUNKNOWN lpTransport, LPDVMESSAGEHANDLER lpMessageHandler, LPVOID lpUserContext, LPDWORD lpdwMessages, DWORD dwNumElements )
{
	HRESULT hr = S_OK;

	LPUNKNOWN lpUnknown = lpTransport;
	LPDIRECTPLAYVOICETRANSPORT lpdvNotify;
	CDirectVoiceDirectXTransport *lpdxTransport;

	if( lpUnknown == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Bad pointer" );
		return DVERR_NOTRANSPORT;
	}

	// Fix a memory leak if you Connect/Disconnect and then reconnect.  
	if( lpdvObject->lpDVTransport )
	{
		delete lpdvObject->lpDVTransport;
		lpdvObject->lpDVTransport = NULL;
	}

	// Try and retrieve transport interface from the object we got.
	hr = lpUnknown->QueryInterface( IID_IDirectPlayVoiceTransport, (void **) &lpdvNotify );

	// If we failed, default to the old type
	if( FAILED( hr ) )
	{
		if( hr == E_NOINTERFACE )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "The specified interface is not a valid transport" );
			return DVERR_NOTRANSPORT;
		}
		else
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Query for interface failed hr = 0x%x", hr );
			return DVERR_GENERIC;
		}
	}
	// Otherwise, startup the new transport system.  
	else
	{
		lpdxTransport = new CDirectVoiceDirectXTransport(lpdvNotify);

		if( lpdxTransport == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate transport" );
			lpdvNotify->Release();
			return DVERR_OUTOFMEMORY;
		}
		
		lpdvNotify->Release();
	}

	hr = lpdvObject->lpDVEngine->Initialize( static_cast<CDirectVoiceTransport *>(lpdxTransport), lpMessageHandler, lpUserContext, lpdwMessages, dwNumElements  );

	if( FAILED( hr ) )
	{
		delete lpdxTransport;

		return hr;
	}

	lpdvObject->lpDVTransport = static_cast<CDirectVoiceTransport *>(lpdxTransport);

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_Caps"
// DV_DUMP_Caps
//
// Dumps a DVCAPS structure
//
void DV_DUMP_Caps( LPDVCAPS lpdvCaps )
{
	DNASSERT( lpdvCaps != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DVCAPS Dump Addr=0x%p", lpdvCaps );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdvCaps->dwSize );		
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvCaps->dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_GUID"
void DV_DUMP_GUID( GUID guid )
{
    DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guid.Data1, guid.Data2, guid.Data3, 
               guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
               guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_CompressionInfo"
void DV_DUMP_CompressionInfo( LPDVCOMPRESSIONINFO lpdvCompressionInfo, DWORD dwNumElements )
{
	DNASSERT( lpdvCompressionInfo != NULL );

	DWORD dwIndex;

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DVCOMPRESSIONINFO Array Dump Addr=0x%p", lpdvCompressionInfo );

	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdvCompressionInfo[dwIndex].dwSize );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvCompressionInfo[dwIndex].dwFlags );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpszDescription = %s", lpdvCompressionInfo[dwIndex].lpszDescription );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpszName = %s", lpdvCompressionInfo[dwIndex].lpszName );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "guidType = " );
		DV_DUMP_GUID( lpdvCompressionInfo[dwIndex].guidType );
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwMaxBitsPerSecond = %d", lpdvCompressionInfo[dwIndex].dwMaxBitsPerSecond );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_FullCompressionInfo"
void DV_DUMP_FullCompressionInfo( LPDVFULLCOMPRESSIONINFO lpdvfCompressionInfo, DWORD dwNumElements )
{
	DNASSERT( lpdvfCompressionInfo != NULL );

	DWORD dwIndex;
	LPSTR lpszTmp;

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DVFULLCOMPRESSIONINFO Array Dump Addr=0x%p", lpdvfCompressionInfo );

	for( dwIndex = 0; dwIndex < dwNumElements; dwIndex++ )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdvfCompressionInfo[dwIndex].dwSize );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvfCompressionInfo[dwIndex].dwFlags );		

		if( FAILED( STR_AllocAndConvertToANSI( &lpszTmp, lpdvfCompressionInfo[dwIndex].lpszDescription ) ) )
		{
			DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpszDescription = <Convert Failed>" );
		}
		else
		{
			DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpszDescription = %s", lpszTmp );		
			delete [] lpszTmp;
		}

		if( FAILED( STR_AllocAndConvertToANSI( &lpszTmp, lpdvfCompressionInfo[dwIndex].lpszName ) ) )
		{
			DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpszName = <Convert Failed>" );
		}
		else
		{
			DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpszName = %s", lpszTmp );		
			delete [] lpszTmp;
		}
		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "guidType = " );
		DV_DUMP_GUID( lpdvfCompressionInfo[dwIndex].guidType );
		// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpwfxFormat = 0x%p", lpdvfCompressionInfo[dwIndex].lpwfxFormat );
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFramesPerBuffer = %d", lpdvfCompressionInfo[dwIndex].dwFramesPerBuffer );
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwTrailFrames = %d", lpdvfCompressionInfo[dwIndex].dwTrailFrames );
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwTimeout = %d", lpdvfCompressionInfo[dwIndex].dwTimeout );			
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "bMinConnectType = %d", (DWORD) lpdvfCompressionInfo[dwIndex].bMinConnectType );
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFrameLength = %d", lpdvfCompressionInfo[dwIndex].dwFrameLength );		 
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFrame8Khz = %d", lpdvfCompressionInfo[dwIndex].dwFrame8Khz );		  
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFrame11Khz = %d", lpdvfCompressionInfo[dwIndex].dwFrame11Khz );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFrame22Khz = %d", lpdvfCompressionInfo[dwIndex].dwFrame22Khz );		 
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFrame44Khz = %d", lpdvfCompressionInfo[dwIndex].dwFrame44Khz );		
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwMaxBitsPerSecond = %d", lpdvfCompressionInfo[dwIndex].dwMaxBitsPerSecond );	
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "wInnerQueueSize = %d", lpdvfCompressionInfo[dwIndex].wInnerQueueSize );	
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "wMaxHighWaterMark = %d", lpdvfCompressionInfo[dwIndex].wMaxHighWaterMark );
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "bMaxQueueSize = %d", (DWORD) lpdvfCompressionInfo[dwIndex].bMaxQueueSize );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_SessionDesc"
void DV_DUMP_SessionDesc( LPDVSESSIONDESC lpdvSessionDesc )
{
	DNASSERT( lpdvSessionDesc != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DVSESSIONDESC Dump Addr=0x%p", lpdvSessionDesc );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdvSessionDesc->dwSize );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvSessionDesc->dwFlags );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "          %s", (lpdvSessionDesc->dwFlags & DVSESSION_SERVERCONTROLTARGET) ? "DVSESSION_SERVERCONTROLTARGET," : "");

	switch( lpdvSessionDesc->dwSessionType )
	{
	case DVSESSIONTYPE_PEER:
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSessionType = DVSESSIONTYPE_PEER" );
		break;
	case DVSESSIONTYPE_MIXING:
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSessionType = DVSESSIONTYPE_MIXING" );
		break;
	case DVSESSIONTYPE_FORWARDING: 
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSessionType = DVSESSIONTYPE_FORWARDING" );
		break;
	case DVSESSIONTYPE_ECHO: 
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSessionType = DVSESSIONTYPE_ECHO" );
		break;
	default:
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSessionType = Unknown" );
		break;
	}

	if( lpdvSessionDesc->dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferAggressiveness = DEFAULT" );
	}
	else
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferAggressiveness = %d", lpdvSessionDesc->dwBufferAggressiveness );
	}

	if( lpdvSessionDesc->dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferQuality = DEFAULT" );
	}
	else
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferQuality = %d", lpdvSessionDesc->dwBufferQuality );
	}

	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "guidCT = " );
	DV_DUMP_GUID( lpdvSessionDesc->guidCT );

}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_DSBDESC"
void DV_DUMP_DSBDESC( LPDSBUFFERDESC lpdsBufferDesc )
{
	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DSBUFFERDESC DUMP Addr=0x%p", lpdsBufferDesc );

	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdsBufferDesc->dwSize );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdsBufferDesc->dwFlags );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferBytes = %d", lpdsBufferDesc->dwBufferBytes );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwReserved = %d", lpdsBufferDesc->dwReserved );

	if( lpdsBufferDesc->dwSize >= sizeof( DSBUFFERDESC1 ) )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "guid3DAlgorithm = " );
		DV_DUMP_GUID( lpdsBufferDesc->guid3DAlgorithm );
	}

	if( lpdsBufferDesc->lpwfxFormat == NULL )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpwfxFormat = NULL" );
	}
	else
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpwfxFormat = " );	
		DV_DUMP_WaveFormatEx(lpdsBufferDesc->lpwfxFormat);
	}
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_SoundDeviceConfig"
void DV_DUMP_SoundDeviceConfig( LPDVSOUNDDEVICECONFIG lpdvSoundConfig )
{
	DNASSERT( lpdvSoundConfig != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DVSOUNDDEVICECONFIG Dump Addr=0x%p", lpdvSoundConfig );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdvSoundConfig->dwSize );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvSoundConfig->dwFlags );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "          %s%s", 
							(lpdvSoundConfig->dwFlags & DVSOUNDCONFIG_AUTOSELECT) ? "DVSOUNDCONFIG_AUTOSELECT," : "",
							(lpdvSoundConfig->dwFlags & DVSOUNDCONFIG_HALFDUPLEX) ? "DVSESSION_HALFDUPLEX," : "", 
							(lpdvSoundConfig->dwFlags & DVSOUNDCONFIG_STRICTFOCUS) ? "DVSOUNDCONFIG_STRICTFOCUS," : "",
							(lpdvSoundConfig->dwFlags & DVSOUNDCONFIG_NOFOCUS) ? "DVSOUNDCONFIG_NOFOCUS," : "");

	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "guidPlaybackDevice =" );
	DV_DUMP_GUID( lpdvSoundConfig->guidPlaybackDevice );

	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "guidCaptureDevice =" );
	DV_DUMP_GUID( lpdvSoundConfig->guidCaptureDevice );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpdsPlaybackDevice = 0x%p", lpdvSoundConfig->lpdsPlaybackDevice ) ;
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpdsCaptureDevice = 0x%p", lpdvSoundConfig->lpdsCaptureDevice ) ;
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lpdsMainBuffer = 0x%p", lpdvSoundConfig->lpdsMainBuffer );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwMainBufferPriority = 0x%x", lpdvSoundConfig->dwMainBufferPriority );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwMainBufferFlags = 0x%x", lpdvSoundConfig->dwMainBufferFlags );

}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_ClientConfig"
void DV_DUMP_ClientConfig( LPDVCLIENTCONFIG lpdvClientConfig )
{
	DNASSERT( lpdvClientConfig != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "DVCLIENTCONFIG Dump Addr = 0x%p", lpdvClientConfig );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwSize = %d", lpdvClientConfig->dwSize );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwFlags = 0x%x", lpdvClientConfig->dwFlags );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "          %s%s%s%s%s%s", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_RECORDMUTE) ? "DVCLIENTCONFIG_RECORDMUTE," : "", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_PLAYBACKMUTE) ? "DVCLIENTCONFIG_PLAYBACKMUTE," : "",
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_MANUALVOICEACTIVATED) ? "DVCLIENTCONFIG_MANUALVOICEACTIVATED," : "", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED) ? "DVCLIENTCONFIG_AUTOVOICEACTIVATED," : "",
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_MUTEGLOBAL) ? "DVCLIENTCONFIG_MUTEGLOBAL," : "", 
							(lpdvClientConfig->dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME) ? "DVCLIENTCONFIG_AUTORECORDVOLUME" : "" );

	if( lpdvClientConfig->dwBufferAggressiveness == DVBUFFERAGGRESSIVENESS_DEFAULT )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferAggressiveness = DEFAULT" );
	}
	else
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferAggressiveness = %d", lpdvClientConfig->dwBufferAggressiveness );
	}

	if( lpdvClientConfig->dwBufferQuality == DVBUFFERQUALITY_DEFAULT )
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferQuality = DEFAULT" );
	}
	else
	{
		DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwBufferQuality = %d", lpdvClientConfig->dwBufferQuality );
	}

	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "dwNotifyPeriod = %d", lpdvClientConfig->dwNotifyPeriod );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lPlaybackVolume = %li", lpdvClientConfig->lPlaybackVolume );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "lRecordVolume = %li", lpdvClientConfig->lRecordVolume );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_DUMP_WaveFormatEx"
void DV_DUMP_WaveFormatEx( LPWAVEFORMATEX lpwfxFormat )
{
	DNASSERT( lpwfxFormat != NULL );

	// 7/31/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "WAVEFORMATEX Dump Addr = 0x%p", lpwfxFormat );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "wFormatTag = %d", lpwfxFormat->wFormatTag );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "nSamplesPerSec = %d", lpwfxFormat->nSamplesPerSec );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "nChannels = %d", lpwfxFormat->nChannels );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "wBitsPerSample = %d", lpwfxFormat->wBitsPerSample );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "nAvgBytesPerSec = %d", lpwfxFormat->nAvgBytesPerSec );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "nBlockAlign = %d", lpwfxFormat->nBlockAlign );
	DPFX(DPFPREP,  DVF_STRUCTUREDUMP, "cbSize = %d", lpwfxFormat->cbSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidDirectVoiceObject"
// DV_ValidDirectVoiceObject
//
// Checks to ensure the specified pointer points to a valid directvoice 
// object.
BOOL DV_ValidDirectVoiceObject( LPDIRECTVOICEOBJECT lpdv )
{
	if( lpdv == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object is null" );
		return FALSE;
	}

	if( !DNVALID_READPTR( lpdv, sizeof( DIRECTVOICEOBJECT ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid read ptr" );
		return FALSE;
	}

	if( lpdv->lpDVEngine != NULL &&
	    !DNVALID_READPTR( lpdv->lpDVEngine, sizeof( CDirectVoiceEngine ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid engine" );
		return FALSE;
	}

	if( lpdv->lpDVTransport != NULL &&
		!DNVALID_READPTR( lpdv->lpDVEngine, sizeof( CDirectVoiceTransport ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid transport" );
		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidDirectXVoiceClientObject"
// DV_ValidDirectXVoiceClientObject
//
// Checks to ensure the specified pointer points to a valid directvoice 
// object.
BOOL DV_ValidDirectXVoiceClientObject( LPDIRECTVOICEOBJECT lpdvc )
{
	if( !DV_ValidDirectVoiceObject( lpdvc ) )
	{
		return FALSE;
	}

	if( lpdvc->lpVtbl != dvcInterface )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Bad vtable" );
		return FALSE;
	}

	if( lpdvc->dvNotify.lpNotifyVtble != NULL && 
	    lpdvc->dvNotify.lpNotifyVtble != dvClientNotifyInterface )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid notify vtable" );
		return FALSE;
	}

	LPDIRECTVOICECLIENTOBJECT lpdvClientObject = (LPDIRECTVOICECLIENTOBJECT) lpdvc;

	if( lpdvClientObject->lpDVClientEngine != NULL && 
	    !DNVALID_READPTR( lpdvClientObject->lpDVClientEngine, sizeof( CDirectVoiceClientEngine ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid client engine" );
		return FALSE;
	}
	
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidDirectXVoiceServerObject"
// DV_ValidDirectXVoiceServerObject
//
// Checks to ensure the specified pointer points to a valid directvoice 
// object.
BOOL DV_ValidDirectXVoiceServerObject( LPDIRECTVOICEOBJECT lpdvs )
{
	if( !DV_ValidDirectVoiceObject( lpdvs ) )
	{
		return FALSE;
	}

	if( lpdvs->lpVtbl != dvsInterface )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid server vtable" );	
		return FALSE;
	}

	if( lpdvs->dvNotify.lpNotifyVtble != NULL && 
	    lpdvs->dvNotify.lpNotifyVtble != dvServerNotifyInterface )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid notify vtable" );		
		return FALSE;
	}

	LPDIRECTVOICESERVEROBJECT lpdvServerObject = (LPDIRECTVOICESERVEROBJECT) lpdvs;

	if( lpdvServerObject->lpDVServerEngine != NULL && 
	    !DNVALID_READPTR( lpdvServerObject->lpDVServerEngine, sizeof( CDirectVoiceServerEngine ) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid server engine" );	
		return FALSE;
	}	

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ValidMessageArray"
// Validate message mask.
//
// May be too strict to enforce server only or client/only.
//
HRESULT DV_ValidMessageArray( LPDWORD lpdwMessages, DWORD dwNumMessages, BOOL fServer )
{
	if( dwNumMessages > 0 &&
	    (lpdwMessages == NULL || 
	     !DNVALID_READPTR( lpdwMessages, sizeof(DWORD)*dwNumMessages )) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for the lpdwMessages parameter." );
		return DVERR_INVALIDPOINTER;
	}

	if( lpdwMessages != NULL && dwNumMessages == 0 )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Non-NULL notification array with 0 size" );
		return DVERR_INVALIDPARAM;
	}

	DWORD dwIndex, dwSubIndex;

	for( dwIndex = 0; dwIndex < dwNumMessages; dwIndex++ )
	{
		if( lpdwMessages[dwIndex] < DVMSGID_MINBASE || lpdwMessages[dwIndex] > DVMSGID_MAXBASE )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid message specified in notification array" );
			return DVERR_INVALIDPARAM;
		}
			
		switch( lpdwMessages[dwIndex] )
		{
		// Player only messages
		case DVMSGID_PLAYERVOICESTART:
		case DVMSGID_PLAYERVOICESTOP:
		case DVMSGID_RECORDSTART:
		case DVMSGID_RECORDSTOP:
		case DVMSGID_CONNECTRESULT:
		case DVMSGID_DISCONNECTRESULT:
		case DVMSGID_INPUTLEVEL:
		case DVMSGID_OUTPUTLEVEL:
		case DVMSGID_SETTARGETS:
		case DVMSGID_PLAYEROUTPUTLEVEL:
		case DVMSGID_LOSTFOCUS:
		case DVMSGID_GAINFOCUS:		
		case DVMSGID_HOSTMIGRATED:
		case DVMSGID_LOCALHOSTSETUP:
			if( fServer )
			{
				DPFX(DPFPREP,  0, "Client-only notification ID specified in server notification mask" );
				return DVERR_INVALIDPARAM;
			}
			break;
		}

		for( dwSubIndex = 0; dwSubIndex < dwNumMessages; dwSubIndex++ )
		{	
			if( dwIndex != dwSubIndex && 
			    lpdwMessages[dwIndex] == lpdwMessages[dwSubIndex] ) 
			{
				DPFX(DPFPREP,  0, "Duplicate IDs specified in notification mask" );
				return DVERR_INVALIDPARAM;
			}
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsndt.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvsndt.cpp
 *  Content:	Implementation of CSoundTarget class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/02/99		rodtoll	Created
 * 09/08/99		rodtoll	Updated to handle lockup of playback buffer
 *				rodtoll	Added handling for restarting playback buffer or 
 * 					    handling slowdown/speedup of buffer playback
 *						because of high cpu loads.
 *				rodtoll	Added write-ahead of silence to the buffers to that
 *						in high CPU conditions silence will be played instead
 *						of old voice.
 * 09/14/99		rodtoll	Added new WriteAheadSilence which writes silence ahead
 *						of the current write location to prevent high CPU from
 *						playing old data. 
 * 09/20/99		rodtoll	Added checks for memory allocation failures 
 * 				rodtoll	Added handlers for buffer loss
 * 10/05/99		rodtoll	Added additional comments
 * 10/25/99		rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate
 * 11/02/99		pnewson Fix: Bug #116365 - using wrong DSBUFFERDESC
 * 11/12/99		rodtoll	Updated to use new abstractions for playback (allows use
 *						of waveOut with this class). 
 * 11/13/99		rodtoll	Re-activated code which pushes write pointer ahead if
 *						buffer pointer passes us. 
 * 01/24/2000	rodtoll	Fix: Bug #129427 - Destroying transport before calling Delete3DSound
 * 01/27/2000	rodtoll	Bug #129934 - Update SoundTargets to take DSBUFFERDESC    
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *						Added instrumentation 
 * 04/14/2000   rodtoll Bug #32215 - Voice Conference Lost after resume from hibernation
 *                      Updated code to use new restore handling in dsound layer
 * 05/17/2000   rodtoll Bug #35110 Simultaneous playback of 2 voices results in distorted playback 
 * 06/21/2000	rodtoll Fix: Bug #35767 - Must implement ability for dsound effects on voice buffers
 *						Added new constructor/init that takes pre-built buffers
 * 07/09/2000	rodtoll	Added signature bytes
 * 07/28/2000	rodtoll	Bug #40665 - DirectSound reports 1 buffer leaked
 * 11/16/2000	rodtoll	Bug #47783 - DPVOICE: Improve debugging of failures caused by DirectSound errors.
 * 04/02/2001	simonpow	Bug #354859 Fixes for PREfast (initialising local variables in RestoreLostBuffer)
 * 04/21/2001	rodtoll	MANBUG #50058 DPVOICE: VoicePosition: No sound for couple of seconds when position bars are moved
 *						- Added initialization for uninitialized variables
 *						- Removed ifdef'ed out code.
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#define SOUNDTARGET_WRITEAHEAD			2

// Max # of restarts to attempt on a buffer
#define SOUNDTARGET_MAX_RESTARTS		10

// Max # of frames of silence which are written ahead of the latest frame
// of audio
#define SOUNDTARGET_MAX_WRITEAHEAD		3

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::CSoundTarget"
//
// Constructor
//
// This constructor is used when a DIRECTSOUND buffer needs to be created.  If there is already
// a DIRECTSOUNDBUFFER you wish to attach the sound target object to, use the other constructor
// type.
//
CSoundTarget::CSoundTarget( 
	DVID dvidTarget, CAudioPlaybackDevice *lpPlaybackDevice, 
	LPDSBUFFERDESC lpdsBufferDesc, DWORD dwPriority, 
	DWORD dwFlags, DWORD dwFrameSize 
	):	m_lpds3dBuffer(NULL),
		m_lpAudioPlaybackBuffer(NULL),
		m_lpMixBuffer(NULL),
		m_dwSignature(VSIG_SOUNDTARGET)
{
	CAudioPlaybackBuffer	*lpdsBuffer;
    LPVOID                  lpvBuffer1, lpvBuffer2;
    DWORD                   dwBufferSize1, dwBufferSize2;

    Stats_Init();

	m_hrInitResult = lpPlaybackDevice->CreateBuffer( lpdsBufferDesc, dwFrameSize, &lpdsBuffer );

	if( FAILED( m_hrInitResult ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not create the sound buffer hr=0x%x", m_hrInitResult );
		return;
	}

    m_hrInitResult = lpdsBuffer->Lock( 0, 0, &lpvBuffer1, &dwBufferSize1, &lpvBuffer2, &dwBufferSize2, DSBLOCK_ENTIREBUFFER );

	if( FAILED( m_hrInitResult ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not lock the sound buffer hr=0x%x", m_hrInitResult );
		m_hrInitResult = DVERR_LOCKEDBUFFER;
		return;
	}

	if( lpdsBufferDesc->lpwfxFormat->wBitsPerSample == 8  )
	{
		memset( lpvBuffer1, 0x80, dwBufferSize1 );
	}
	else
	{
		memset( lpvBuffer1, 0x00, dwBufferSize1 );		
	}

    m_hrInitResult = lpdsBuffer->UnLock( lpvBuffer1, dwBufferSize1, lpvBuffer2, dwBufferSize2 );

    if( FAILED( m_hrInitResult ) )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not unlock the sound buffer hr=0x%x", m_hrInitResult );
		return;
	}

	// Required always
	dwFlags |= DSBPLAY_LOOPING;

    m_hrInitResult = lpdsBuffer->Play( dwPriority, dwFlags );

    if( FAILED( m_hrInitResult ) )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not play the sound buffer hr=0x%x", m_hrInitResult );
		return;
	}

	m_hrInitResult = Initialize( dvidTarget, lpdsBuffer, (lpdsBufferDesc->lpwfxFormat->wBitsPerSample==8), dwPriority, dwFlags, dwFrameSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::RestoreLostBuffer"
//
// RestoreLostBuffer
//
// Handles restoration of lost directsound buffers.
//
HRESULT CSoundTarget::RestoreLostBuffer()
{
	HRESULT hr = DSERR_BUFFERLOST;

	DPFX(DPFPREP,  0, "Restoring lost buffer" );

	while( hr == DSERR_BUFFERLOST )
	{
		hr = m_lpAudioPlaybackBuffer->Restore();

		DPFX(DPFPREP,  0, "Buffer result for restore was 0x%x", hr );

	       if( hr == DS_OK )
	       {
	       	hr = m_lpAudioPlaybackBuffer->GetCurrentPosition( &m_dwWritePos );
	    		DPFX(DPFPREP,  0, "GetCurrentPos returned 0x%x", hr );        	

	           	if( hr != DSERR_BUFFERLOST && FAILED( hr ) )
	           	{
	                DPFX(DPFPREP,  DVF_ERRORLEVEL, "Lost buffer while getting pos, failed to get pos hr=0x%x", hr );
	                return hr;
	            	}
	        }
	        else if( hr != DSERR_BUFFERLOST )
	        {
	            DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error restoring buffer hr=0x%x", hr );
	            return hr;
	        }
	}

	// STATBLOCK: Begin
	m_statPlay.m_dwNumBL++;
	// STATBLOCK: End

	m_dwNextWritePos = m_dwWritePos + (m_dwFrameSize*SOUNDTARGET_WRITEAHEAD);
	m_dwNextWritePos %= m_dwBufferSize;

	m_dwLastWritePos = m_dwWritePos;	

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::CSoundTarget"
//
// Constructor
//
// This constructor is used when you wish to attach a soundtarget to an existing 
// DirectSond buffer.  
//
CSoundTarget::CSoundTarget( 
	DVID dvidTarget, CAudioPlaybackDevice *lpads, 
	CAudioPlaybackBuffer *lpdsBuffer, LPDSBUFFERDESC lpdsBufferDesc, 
	DWORD dwPriority, DWORD dwFlags, DWORD dwFrameSize 
	): 	m_lpds3dBuffer(NULL),
		m_lpAudioPlaybackBuffer(NULL),
		m_lpMixBuffer(NULL),
		m_dwSignature(VSIG_SOUNDTARGET)
{
	m_hrInitResult = Initialize( dvidTarget, lpdsBuffer, (lpdsBufferDesc->lpwfxFormat->wBitsPerSample==8), dwPriority, dwFlags, dwFrameSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::CSoundTarget"
CSoundTarget::CSoundTarget( 
	DVID dvidTarget, 
	CAudioPlaybackDevice *lpads, 
	LPDIRECTSOUNDBUFFER lpdsBuffer, 
	BOOL fEightBit, 
	DWORD dwPriority, 
	DWORD dwFlags, 
	DWORD dwFrameSize 
	): 	m_lpds3dBuffer(NULL),
		m_lpAudioPlaybackBuffer(NULL),
		m_lpMixBuffer(NULL),
		m_dwSignature(VSIG_SOUNDTARGET)
{
	CDirectSoundPlaybackBuffer *pAudioBuffer = NULL;

	// Create audio buffer to wrap buffer for call to initialize
	pAudioBuffer = new CDirectSoundPlaybackBuffer( lpdsBuffer );

	if( pAudioBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
		m_hrInitResult = DVERR_OUTOFMEMORY;
		return;
	}

	// Required always
	dwFlags |= DSBPLAY_LOOPING;

    m_hrInitResult = pAudioBuffer->Play( dwPriority, dwFlags );

    if( FAILED( m_hrInitResult ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed playing new buffer hr=0x%x", m_hrInitResult );
        return;
    }

	m_hrInitResult = Initialize( dvidTarget, pAudioBuffer, fEightBit, dwPriority, dwFlags, dwFrameSize );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::~CSoundTarget"
//
// Destructor
//
// Destroys the 3d and buffer pointers and frees memory.
//
CSoundTarget::~CSoundTarget()
{
	Stats_End();

	if( m_lpds3dBuffer != NULL )
	{
		m_lpds3dBuffer->Release();
		m_lpds3dBuffer = NULL;
	}

	if( m_lpAudioPlaybackBuffer != NULL )
	{
		m_lpAudioPlaybackBuffer->Stop();		
		delete m_lpAudioPlaybackBuffer;
		m_lpAudioPlaybackBuffer = NULL;
	}

	if( m_lpMixBuffer != NULL )
	{
		delete [] m_lpMixBuffer;
		m_lpMixBuffer = NULL;
	}

	if( SUCCEEDED( m_hrInitResult ) )
	{
		DNDeleteCriticalSection( &m_csGuard );	
	}

	m_dwSignature = VSIG_SOUNDTARGET_FREE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::AdjustWritePtr"
//
// AdjustWritePtr
//
// This function ensures that the directsoundbuffer is acting as it should.  It handles 
// checking the write pointer and determining if some form of error or problem has
// occured and taking the appropriate corrective action.
//
// E.g. the buffer hasn't moved since the last frame, the buffer hasn't moved enough,
//      the buffer has skipped ahead etc.
//
// This function should be called once per mixing pass.  
//
// Call before writing the frame
//
HRESULT CSoundTarget::AdjustWritePtr()
{
	HRESULT hr;
	LONG lDifference, lHalfSize;
	DWORD dwCurrentTick;

   	hr = m_lpAudioPlaybackBuffer->GetCurrentPosition( &m_dwWritePos );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "GetCurrentPosition Failed hr=0x%x", hr );
		DSASSERT( FALSE );
		return hr;
	}

	// STATSBLOCK: Begin
	m_statPlay.m_dwNumRuns++;
	// STATSBLOCK: End

	DWORD dwTmpAdvance, dwTmpLead;

	dwCurrentTick = GetTickCount();

	if( m_dwLastWritePos > m_dwWritePos )
	{
		dwTmpAdvance = (m_dwBufferSize - m_dwLastWritePos) + m_dwWritePos;
	}
	else
	{
		dwTmpAdvance =  m_dwWritePos - m_dwLastWritePos;			
	}

	if( m_dwNextWritePos < m_dwWritePos )
	{
		dwTmpLead = (m_dwBufferSize-m_dwWritePos) + m_dwNextWritePos;
	}
	else
	{
		dwTmpLead = m_dwNextWritePos - m_dwWritePos;
	}

	DPFX(DPFPREP,  PWI_DEBUGOUTPUT_LEVEL, "PWI, [0x%x], %d, %d, %d, %d, %d, %d", m_dvidTarget, m_dwWritePos, dwTmpAdvance, 
	                    dwCurrentTick - m_dwLastWriteTime, m_dwNextWritePos, dwTmpLead, m_dwFrameSize );

	// STATSBLOCK: Begin

	DWORD dwTmpDiff = dwCurrentTick - m_dwLastWriteTime;

	if( dwTmpDiff > m_statPlay.m_dwPMMSMax )
	{
		m_statPlay.m_dwPMMSMax = dwTmpDiff;	
	}

	if( dwTmpDiff < m_statPlay.m_dwPMMSMin )
	{
		m_statPlay.m_dwPMMSMin = dwTmpDiff;
	}

	m_statPlay.m_dwPMMSTotal += dwTmpDiff;

	if( dwTmpAdvance > m_statPlay.m_dwPMBMax )
	{
		m_statPlay.m_dwPMBMax = dwTmpAdvance;	
	}

	if( dwTmpAdvance < m_statPlay.m_dwPMBMin )
	{
		m_statPlay.m_dwPMBMin = dwTmpAdvance;
	}

	m_statPlay.m_dwPMBTotal += dwTmpAdvance;	

	if( dwTmpLead > m_statPlay.m_dwPLMax )
	{
		m_statPlay.m_dwPLMax = dwTmpLead;	
	}

	if( dwTmpLead < m_statPlay.m_dwPLMin )
	{
		m_statPlay.m_dwPLMin = dwTmpLead;
	}

	m_statPlay.m_dwPLTotal += dwTmpLead;		
	// STATSBLOCK: End

	lHalfSize = m_dwBufferSize / 2;
	lDifference = m_dwNextWritePos - m_dwWritePos;

	// If the write position is somehow ahead of position AND 
	// 
	if( lDifference < 0 &&
	    lDifference > (-1*lHalfSize) )
	{
		m_dwNextWritePos = m_dwWritePos;
		m_dwNextWritePos += (m_dwFrameSize * SOUNDTARGET_WRITEAHEAD);
		m_dwNextWritePos %= m_dwBufferSize;
		
		DPFX(DPFPREP,  PWI_DEBUGOUTPUT_LEVEL, "PWI, [0x%x], Punt --> %d", m_dvidTarget, m_dwNextWritePos );

		// STATSBLOCK: Begin
		m_statPlay.m_dwPPunts++;	

		DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: [0x%x] Playback: Write pointer has fallen behind buffer pointer.  Compensating", m_dvidTarget );

		m_statPlay.m_dwGlitches++;

		// STATSBLOCK: End
	}


	m_dwLastWritePos = m_dwWritePos;
	m_dwLastWriteTime = dwCurrentTick;

	if( m_dwNextWritePos < m_dwWritePos && 
	    (m_dwNextWritePos + m_dwFrameSize) > m_dwWritePos )
	{
		DPFX(DPFPREP,  PWI_DEBUGOUTPUT_LEVEL, "PWI, [0x%x], Ignore - Crossing", m_dvidTarget );
		m_fIgnoreFrame = TRUE;
		// STATSBLOCK: Begin
		m_statPlay.m_dwPIgnore++;	

		DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: [0x%x] Playback: Current frame will cross buffer pointer.  Ignoring", m_dvidTarget );
		DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: [0x%x] Playback: May be catching up with buiffer pointer", m_dvidTarget );		

		m_statPlay.m_dwGlitches++;
		// STATSBLOCK: End		
	}
	else
	{
		m_fIgnoreFrame = FALSE;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::WriteAheadSilence"
//
// WriteAheadSilence
//
// This function is responsible for writing frames of silence ahead of the latest frame
// placed in the buffer.  This way if because of high CPU writer thread donesn't get woken
// up silence will be played instead of old speech.
//
// Called AFTER latest frame of data has been written.
//
HRESULT CSoundTarget::WriteAheadSilence() 
{
	HRESULT hr;
	DWORD dwBufferSize1, dwBufferSize2;
	LPVOID lpvBuffer1, lpvBuffer2;

	if( m_dwNextWritePos < m_dwWritePos && 
	    (m_dwNextWritePos + (m_dwFrameSize*SOUNDTARGET_MAX_WRITEAHEAD)) > m_dwWritePos )	
	{
		DPFX(DPFPREP,  PWI_DEBUGOUTPUT_LEVEL, "PWI, [0x%x], Ignore2 - Crossing", m_dvidTarget );

		// STATSBLOCK: Begin
		m_statPlay.m_dwSIgnore++;	

		DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: Playback: Silence will cross buffer pointer.  Ignoring" );
		DPFX(DPFPREP,  DVF_GLITCH_DEBUG_LEVEL, "GLITCH: Playback: May be catching up with buiffer pointer" );

		// STATSBLOCK: End				
		return DV_OK;
	}

	hr = m_lpAudioPlaybackBuffer->Lock( m_dwNextWritePos, m_dwFrameSize*SOUNDTARGET_MAX_WRITEAHEAD, &lpvBuffer1, &dwBufferSize1, &lpvBuffer2, &dwBufferSize2, 0 );

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Lock() Failed hr=0x%x", hr );
		return hr;
	}

	memset( lpvBuffer1, (m_fEightBit) ? 0x80 : 0x00, dwBufferSize1 );
	memset( lpvBuffer2, (m_fEightBit) ? 0x80 : 0x00, dwBufferSize2 );

	hr = m_lpAudioPlaybackBuffer->UnLock( lpvBuffer1, dwBufferSize1, lpvBuffer2, dwBufferSize2 );

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unlock() Failed hr=0x%x", hr );
		return hr;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::MixInSingle"
// 
// MixInSingle
//
// This function is an optimization.
//
// If there is only one frame to mix into this buffer, this function performs the 
// MixIn and Commit all in one step.  You still must call Commit before the next
// frame hwoever.
//
HRESULT CSoundTarget::MixInSingle( LPBYTE lpbBuffer )
{
	HRESULT hr;

	DWORD dwBufferSize1, dwBufferSize2;
	LPVOID lpvBuffer1, lpvBuffer2;

	hr = AdjustWritePtr();
	
	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "AdjustWritePtr Failed hr=0x%x", hr );
		return hr;
	} 

	if( !m_fIgnoreFrame )
	{
		hr = m_lpAudioPlaybackBuffer->Lock( m_dwNextWritePos, m_dwFrameSize, &lpvBuffer1, &dwBufferSize1, &lpvBuffer2, &dwBufferSize2, 0 );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Lock() Failed hr=0x%x", hr );
			return hr;
		}

		memcpy( lpvBuffer1, lpbBuffer, dwBufferSize1 );

		if( dwBufferSize2 )
		{
			memcpy( lpvBuffer2, &lpbBuffer[dwBufferSize1], dwBufferSize2 );
		}

		hr = m_lpAudioPlaybackBuffer->UnLock( lpvBuffer1, dwBufferSize1, lpvBuffer2, dwBufferSize2 );

		if( FAILED( hr ) )
		{
			DSASSERT( FALSE );			
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "UnLock() Failed hr=0x%x", hr );
			return hr;
		}
	}

	m_dwNextWritePos += m_dwFrameSize;
	m_dwNextWritePos %= m_dwBufferSize;

	m_bCommited = TRUE;
	m_fMixed = TRUE;	

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::MixIn"
// Mix in a user's audio.
//
// Simply copies and promotes the audio samples into the buffer with LONG's 
// in it.  
//
HRESULT CSoundTarget::MixIn( LPBYTE lpbBuffer )
{
	DWORD dwIndex;

	if( !m_fMixed )
	{
	    FillBufferWithSilence( m_lpMixBuffer, m_fEightBit, m_dwFrameSize );
	    m_fMixed = TRUE;
	}

    if( !m_fIgnoreFrame )
    	MixInBuffer( m_lpMixBuffer, lpbBuffer, m_fEightBit, m_dwFrameSize );

	m_bCommited = FALSE;
	m_fMixed = TRUE;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::Commit"
// Commit
//
// If we didn't do a single direct mix, commit the mixed audio to the buffer
//
HRESULT CSoundTarget::Commit()
{
	DWORD dwBufferSize1, dwBufferSize2;
	LPVOID lpvBuffer1, lpvBuffer2;
	DWORD dwIndex = 0;
	LPBYTE lpbBufferPtr;
	LPWORD lpsBufferPtr;
	HRESULT hr;

	if( !m_fMixed )
	{
		FillBufferWithSilence( m_lpMixBuffer, m_fEightBit, m_dwFrameSize );

		// STATSBLOCK: Begin
		m_statPlay.m_dwNumSilentMixed++;
		// STATSBLOCK: End
	}
	else
	{
		if( !m_fIgnoreFrame )
		{
			// STATSBLOCK: Begin
			m_statPlay.m_dwNumMixed++;
			// STATSBLOCK: End
		}
	}

	if( !m_bCommited || !m_fMixed )
	{
		hr = AdjustWritePtr();

		if( FAILED( hr ) )
		{
			DSASSERT( FALSE );			
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "AdjustWritePtr() Failed hr=0x%x", hr );
			return hr;
		}

		if( !m_fIgnoreFrame	)		
		{
			hr = m_lpAudioPlaybackBuffer->Lock( m_dwNextWritePos, m_dwFrameSize, &lpvBuffer1, &dwBufferSize1, &lpvBuffer2, &dwBufferSize2, 0 );

			if( FAILED( hr ) )
			{
				DSASSERT( FALSE );				
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Lock() Failed hr=0x%x", hr );
				return hr;
			}

            // Mix first half
            NormalizeBuffer( (BYTE *) lpvBuffer1, m_lpMixBuffer, m_fEightBit, dwBufferSize1 );

            if( dwBufferSize2 > 0 )
			{
				if( m_fEightBit )
				{
					// Mix second half
					NormalizeBuffer( (BYTE *) lpvBuffer2, &m_lpMixBuffer[dwBufferSize1], m_fEightBit, dwBufferSize2 );
				}
				else
				{
					// Mix second half
					NormalizeBuffer( (BYTE *) lpvBuffer2, &m_lpMixBuffer[(dwBufferSize1 >> 1)], m_fEightBit, dwBufferSize2 );
				}
			}

			hr = m_lpAudioPlaybackBuffer->UnLock( lpvBuffer1, dwBufferSize1, lpvBuffer2, dwBufferSize2 );

			if( FAILED( hr ) )
			{
				DSASSERT( FALSE );				
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "UnLock Failed hr=0x%x", hr );
				return hr;
			}
		}

		m_dwNextWritePos += m_dwFrameSize;
		m_dwNextWritePos %= m_dwBufferSize;

		m_bCommited = FALSE;
		m_fMixed = FALSE;

		return DV_OK;
	}

	hr = WriteAheadSilence();

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  0, "WriteAhead Failed hr=0x%x", hr );
	}

	m_fMixed = FALSE;
	m_bCommited = FALSE;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::Initialize"
//
// Initialize
//
// NOTE: Takes a reference to the buffer
//
// Attaches a sound target to the specified sound buffer, initializes the object and creates
// the associated 3d buffer.
//
HRESULT CSoundTarget::Initialize( DVID dvidTarget, CAudioPlaybackBuffer *lpdsBuffer, BOOL fEightBit, DWORD dwPriority, DWORD dwFlags, DWORD dwFrameSize )
{
	HRESULT hr = DV_OK;
	PVOID pvBuffer1 = NULL, pvBuffer2 = NULL;
	DWORD dwBufferSize1, dwBufferSize2;

	if (!DNInitializeCriticalSection( &m_csGuard ))
	{
		return DVERR_OUTOFMEMORY;
	}

	// Determine the buffer size (in bytes)
	hr = lpdsBuffer->Lock( 0, 0, &pvBuffer1, &dwBufferSize1, &pvBuffer2, &dwBufferSize2, DSBLOCK_ENTIREBUFFER );

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Lock() failed hr=0x%x", hr );
		return hr;
	}

	hr = lpdsBuffer->UnLock( pvBuffer1, dwBufferSize1, pvBuffer2, dwBufferSize2 );

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "UnLock() failed hr=0x%x", hr );
		return hr;
	}

	m_lpds3dBuffer = NULL;
	m_lpAudioPlaybackBuffer = NULL;
	m_lpMixBuffer = NULL;

	// We always need the looping flag
	dwFlags |= DSBPLAY_LOOPING;

    m_dwPlayFlags = dwFlags;
    m_dwPriority = dwPriority;
	m_fIgnoreFrame = FALSE;
	m_dwLastWriteTime = GetTickCount();
    m_lRefCount = 1;
	m_lpstNext = NULL;
	m_dwNumResets = 0;
	m_dwNumSinceMove = 1;
	m_bCommited = FALSE;

	m_dvidTarget = dvidTarget;
	m_dwFrameSize = dwFrameSize;
	m_dwBufferSize = dwBufferSize1;

	// STATSBLOCK: Begin
	Stats_Init();
	// STATSBLOCK: End

	m_fLastFramePushed = FALSE;

	m_lpAudioPlaybackBuffer = lpdsBuffer;

	hr = m_lpAudioPlaybackBuffer->Get3DBuffer(&m_lpds3dBuffer);
	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "QueryInterface failed hr=0x%x", hr );
	}

	m_dwNextWritePos = 0;

	if( fEightBit )
	{
		m_fEightBit = TRUE;
		m_dwMixSize = dwFrameSize;
	}
	else
	{
		m_fEightBit = FALSE;
		m_dwMixSize = dwFrameSize / 2;
	}

	m_lpMixBuffer = new LONG[m_dwMixSize];

	if( m_lpMixBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		m_lpds3dBuffer->Release();
		m_lpds3dBuffer = NULL;
		return DVERR_OUTOFMEMORY;
	}

	m_fMixed = FALSE;

	return DV_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::AddRef"
LONG CSoundTarget::AddRef()
{
	LONG lNewCount;
	
	DNEnterCriticalSection( &m_csGuard );

	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] lRefCount %d --> %d", m_dvidTarget, m_lRefCount, m_lRefCount+1 );
	
    m_lRefCount++;

    lNewCount = m_lRefCount;

    DNLeaveCriticalSection( &m_csGuard );

    return lNewCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::Release"
LONG CSoundTarget::Release()
{
	LONG lNewCount;

	DNEnterCriticalSection( &m_csGuard );

	DNASSERT( m_lRefCount > 0 );

	DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] lRefCount %d --> %d", m_dvidTarget, m_lRefCount, m_lRefCount-1 );
	
	m_lRefCount--;

	lNewCount = m_lRefCount;

	DNLeaveCriticalSection( &m_csGuard );

	// Reference reaches 0, destroy!
    if( lNewCount == 0 )
    {
		DPFX(DPFPREP,  DVF_SOUNDTARGET_DEBUG_LEVEL, "SOUNDTARGET: [0x%x] DESTROYING", m_dvidTarget, m_lRefCount, m_lRefCount+1 );
        delete this;
    }

    return lNewCount;
    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSoundTarget::StartMix"
//
// StartMix
//
// Called ONCE only.
//
// Call this function right before you wish to perform the first mix on the buffer.
// Initializes the object to match the current state of the associated directsound
// buffer
//
HRESULT CSoundTarget::StartMix()
{
	HRESULT hr;

   	hr = m_lpAudioPlaybackBuffer->GetCurrentPosition( &m_dwWritePos );

	if( FAILED( hr ) )
	{
		DSASSERT( FALSE );		
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "GetCurrentPosition Failed hr=0x%x", hr );
		return hr;
	}	

	m_dwNextWritePos = m_dwWritePos + (m_dwFrameSize*SOUNDTARGET_WRITEAHEAD);
	m_dwNextWritePos %= m_dwBufferSize;

	m_dwLastWritePos = m_dwWritePos;

	// STATBLOCK: Begin
	Stats_Begin();
	// STATBLOCK: End

	return DV_OK;
}

void CSoundTarget::GetStats( PlaybackStats *statPlayback )
{
	memcpy( statPlayback, &m_statPlay, sizeof( PlaybackStats ) );
}

void CSoundTarget::Stats_Init()
{
	memset( &m_statPlay, 0x00, sizeof( PlaybackStats ) );

	m_statPlay.m_dwFrameSize = m_dwFrameSize;
	m_statPlay.m_dwBufferSize = m_dwBufferSize;

	m_statPlay.m_dwPMMSMin = 0xFFFFFFFF;
	m_statPlay.m_dwPMBMin = 0xFFFFFFFF;
	m_statPlay.m_dwPLMin = 0xFFFFFFFF;
	m_statPlay.m_dwTimeStart = GetTickCount();
}

void CSoundTarget::Stats_Begin()
{
	m_statPlay.m_dwStartLag = GetTickCount() - m_statPlay.m_dwTimeStart;
}

void CSoundTarget::Stats_End()
{
	char tmpBuffer[200];

	m_statPlay.m_dwTimeStop = GetTickCount();

	DWORD dwPlayRunLength = m_statPlay.m_dwTimeStop - m_statPlay.m_dwTimeStart;

	if( dwPlayRunLength == 0 )
		dwPlayRunLength = 1;

	DWORD dwNumInternalRuns = m_statPlay.m_dwNumRuns;

	if( dwNumInternalRuns == 0 )
		dwNumInternalRuns = 1;

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "--- PLAYBACK BUFFER STATISTICS --------------------------------------[End]" );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Buffer for ID          : 0x%x", m_dvidTarget );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Play Run Length (ms)   : %u", dwPlayRunLength );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Start Lag              : %u", m_statPlay.m_dwStartLag );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Speech Size (Uncomp.)  : %u", m_statPlay.m_dwFrameSize );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Frames / Buffer        : %u", m_statPlay.m_dwBufferSize / m_statPlay.m_dwFrameSize);
	
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "# of wakeups           : %u", m_statPlay.m_dwNumRuns );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Ignored Frames (Speech): %u", m_statPlay.m_dwPIgnore );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Ignored Frames (Silent): %u", m_statPlay.m_dwSIgnore );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Mixed Frames (Speech)  : %u", m_statPlay.m_dwNumMixed );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Mixed Frames (Silent)  : %u", m_statPlay.m_dwNumSilentMixed );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Punted Frames          : %u", m_statPlay.m_dwPPunts );
	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "Audio Glitches         : %u", m_statPlay.m_dwGlitches );

	sprintf( tmpBuffer, "Play Movement (ms)     : Avg: %u [%u..%u]", 
			m_statPlay.m_dwPMMSTotal / dwNumInternalRuns,
			m_statPlay.m_dwPMMSMin,
			m_statPlay.m_dwPMMSMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Play Movement (bytes)  : Avg: %u [%u..%u]",
			m_statPlay.m_dwPMBTotal / dwNumInternalRuns,
			m_statPlay.m_dwPMBMin,
			m_statPlay.m_dwPMBMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Play Movement (frames) : Avg: %.2f [%.2f..%.2f]",
			(((float) m_statPlay.m_dwPMBTotal) / ((float) dwNumInternalRuns)) / ((float) m_statPlay.m_dwFrameSize),
			((float) m_statPlay.m_dwPMBMin) / ((float) m_statPlay.m_dwFrameSize),
			((float) m_statPlay.m_dwPMBMax) / ((float) m_statPlay.m_dwFrameSize) );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );
			
	sprintf( tmpBuffer, "Play Lead (bytes)      : Avg: %u [%u..%u]",
			m_statPlay.m_dwPLTotal / dwNumInternalRuns,
			m_statPlay.m_dwPLMin ,
			m_statPlay.m_dwPLMax );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	sprintf( tmpBuffer, "Play Lag (frames)      : Avg: %.2f [%.2f..%.2f]",
			(float) ((float) m_statPlay.m_dwPLTotal / (float) dwNumInternalRuns) / ((float) m_statPlay.m_dwFrameSize),
			(float) ((float) m_statPlay.m_dwPLMin) / (float) m_statPlay.m_dwFrameSize,
			(float) ((float) m_statPlay.m_dwPLMax) / (float) m_statPlay.m_dwFrameSize );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, tmpBuffer );

	DPFX(DPFPREP,  DVF_STATS_DEBUG_LEVEL, "--- PLAYBACK BUFFER STATISTICS ------------------------------------[Begin]" );
}


HRESULT CSoundTarget::GetCurrentLead( PDWORD pdwLead )  
{
	HRESULT hr;

	hr = m_lpAudioPlaybackBuffer->GetCurrentPosition( &m_dwWritePos );
	
	if( m_dwNextWritePos < m_dwWritePos )
	{
		*pdwLead = (m_dwBufferSize-m_dwWritePos) + m_dwNextWritePos;
	}
	else
	{
		*pdwLead = m_dwNextWritePos - m_dwWritePos;
	}

	return DV_OK;
    
}

LPDIRECTSOUND3DBUFFER CSoundTarget::Get3DBuffer()
{ 
    m_lpDummy = m_lpds3dBuffer;
    return m_lpds3dBuffer; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvsndt.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvsndt.h
 *  Content:	definition of CSoundTarget class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/02/99		rodtoll	Created
 * 09/08/99		rodtoll	Updated to provide lockup detection
 * 09/14/99		rodtoll	Added WriteAheadSilence()
 * 09/20/99		rodtoll	Added handlers for buffer loss 
 * 11/12/99		rodtoll	Updated to use new abstractions for playback (allows use
 *						of waveOut with this class).
 * 01/24/2000	rodtoll	Fix: Bug #129427 - Destroying transport before calling Delete3DSound 
 *  01/27/2000	rodtoll	Bug #129934 - Update SoundTargets to take DSBUFFERDESC   
 * 02/17/2000	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *						Added instrumentation 
 * 04/17/2000   rodtoll Fix: Bug #32215 - Session Lost after resuming from hibernation
 * 06/21/2000	rodtoll Fix: Bug #35767 - Must implement ability for dsound effects on voice buffers
 *						Added new constructor/init that takes pre-built buffers
 * 07/09/2000	rodtoll	Added signature bytes
 *
 ***************************************************************************/

#ifndef __DVSNDT_H
#define __DVSNDT_H

// CSoundTarget
//
// This class represents a single mixer target within the DirectPlayClient system.  Normally there
// is only a single mixer target ("main") for all incoming audio.  However, using the CreateUserBuffer and
// DeleteUserBuffer APIs the developer can specify that they wish to seperate a group or a player
// from the main mixer target.  In this manner they can control the 3d spatialization of the group/player's
// incoming audio stream.  
//
// This class handles all the details related to a mixer target.  It encapsulates the mixing of single 
// or multiple source audio frames and then commiting them to the corresponding directsound buffer.  It also
// handles timing errors in the directsoundbuffer.
//
// For example, if the directsoundbuffer stops running, it will attempt to reset the buffer.
//
// If the directsoundbuffer slows down (because of high CPU), it moves the read pointer forward.  In short
// it ensures that there is always 1 or 2 frames of mixed audio present in the buffer in advance of the 
// read pointer.
//
// In addition the class provides reference counting to prevent premature deletion of the class.  If you 
// wish to take a reference to the class, call AddRef and you MUST then call Release when you are done.
//
// Do not destroy the object directly.  When the last reference to the object is released the object will
// destroy itself.
//
// This class is not multithread safe (except for AddRef and Release).  Only one thread should be 
// accessing it.
//
#define VSIG_SOUNDTARGET		'TNSV'
#define VSIG_SOUNDTARGET_FREE	'TNS_'

volatile struct CSoundTarget
{
public:

	CSoundTarget( DVID dvidTarget, CAudioPlaybackDevice *lpads, LPDSBUFFERDESC lpdsBufferDesc, DWORD dwPriority, DWORD dwFlags, DWORD dwFrameSize  );
	CSoundTarget( DVID dvidTarget, CAudioPlaybackDevice *lpads, CAudioPlaybackBuffer *lpdsBuffer, LPDSBUFFERDESC lpdsBufferDesc, DWORD dwPriority, DWORD dwFlags, DWORD dwFrameSize );
	CSoundTarget( DVID dvidTarget, CAudioPlaybackDevice *lpads, LPDIRECTSOUNDBUFFER lpdsBuffer, BOOL fEightBit, DWORD dwPriority, DWORD dwFlags, DWORD dwFrameSize );

	~CSoundTarget();

	HRESULT StartMix();

	HRESULT MixInSingle( LPBYTE lpbBuffer );
	HRESULT MixIn( LPBYTE lpbBuffer );

	HRESULT Commit();

	inline HRESULT GetInitResult() { return m_hrInitResult; };

	LPDIRECTSOUND3DBUFFER Get3DBuffer();
	inline CAudioPlaybackBuffer *GetBuffer() { return m_lpAudioPlaybackBuffer; };

	CSoundTarget			*m_lpstNext;		// Next entry in the list

    inline DVID GetTarget() { return m_dvidTarget; };
	inline LONG GetRefCount() { return m_lRefCount; };

    LONG AddRef();
    LONG Release();

    void GetStats( PlaybackStats *statPlayback );

    HRESULT GetCurrentLead( PDWORD pdwLead );

protected:

	HRESULT Initialize( DVID dvidTarget, CAudioPlaybackBuffer *lpdsBuffer, BOOL fEightBit, DWORD dwPriority, DWORD dwFlags, DWORD dwFrameSize );
	HRESULT RestoreLostBuffer();

	HRESULT AdjustWritePtr();
	HRESULT WriteAheadSilence();

	void Stats_Init();
	void Stats_Begin();
	void Stats_End();

public:

	DWORD					m_dwSignature;

protected:

	CAudioPlaybackBuffer	*m_lpAudioPlaybackBuffer;
	LPDIRECTSOUND3DBUFFER	m_lpds3dBuffer;		// 3d buffer interface for this sound target
	DWORD					m_dwNextWritePos;	// Next byte position in the directsound buffer we'll
												// be writing to.
	DWORD					m_dwBufferSize;		// Size of directsound buffer in bytes
	BOOL					m_bGroup;			// Does this buffer represent a group?
	LPLONG					m_lpMixBuffer;		// High resolution mixing buffer
	BOOL					m_bCommited;		// Has the data in the latest mix been commited to the buffer
	BOOL					m_fEightBit;		// Is the buffer 8-bit?
	HRESULT					m_hrInitResult;		// Contains result of the initializatio of this object
	DWORD					m_dwMixSize;		// # of samples per frame
	DWORD					m_dwFrameSize;		// Size of a frame in bytes 
	BOOL					m_fMixed;			// Set to TRUE as soon as a single source has been mixed
											    // Set to FALSE whenever the mix is commited.
    LONG                    m_lRefCount;		// Reference count on the object
    DWORD					m_dwLastWritePos;	// Byte position that the last write occured at.
    DWORD					m_dwNumResets;		// # of times buffer has been reset
    BOOL					m_fLastFramePushed;	// Did the last frame push the read pointer forward?
    DWORD					m_dwNumSinceMove;   // How many frames since no movement was detected?
    DWORD					m_dwLastWriteTime;	// GetTickCount() at last call to AdjustWritePtr
    BOOL					m_fIgnoreFrame;		// This frame will cross the boundary of where the write pointer is.
    											// Do NOT write to the buffer
    DWORD					m_dwWritePos;
    DNCRITICAL_SECTION		m_csGuard;			// Guard for reference counts
    DWORD					m_dwPlayFlags;
    DWORD					m_dwPriority;

	DVID 					m_dvidTarget;		// DVID this buffer is for.  
												// DVID_REMAINING for the global one
    
    PlaybackStats			m_statPlay;			// Playback Statistics
    LPVOID                   m_lpDummy;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dxvclassfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	a generic class factory
 *
 *
 *	This is a generic C class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instace of
 *	your object.  
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash
 ***************************************************************************/

#include "dxvoicepch.h"


HRESULT DVT_Create(LPDIRECTVOICESETUPOBJECT *piDVT);
HRESULT DVS_Create(LPDIRECTVOICESERVEROBJECT *piDVS);
HRESULT DVC_Create(LPDIRECTVOICECLIENTOBJECT *piDVC);

#define EXP __declspec(dllexport)

class CClassFactory : IClassFactory
{
public:
	CClassFactory(CLSID* pclsid) : m_lRefCnt(0), m_clsid(*pclsid) {}

	STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObj);
	STDMETHOD_(ULONG, AddRef)() 
	{
		return InterlockedIncrement(&m_lRefCnt);
	}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InterlockedDecrement(&m_lRefCnt);
		if (l == 0)
		{
			delete this;
	    	DecrementObjectCount();
		}
		return l;
	}
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj);
	STDMETHOD(LockServer)(BOOL fLock)
	{
		if( fLock )
		{
    		InterlockedIncrement( &g_lNumLocks );
		}
		else
		{
    		InterlockedDecrement( &g_lNumLocks );
		}	
		return S_OK;	
	}

private:	
	LONG					m_lRefCnt;
	CLSID					m_clsid;
};

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;

    if( IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        InterlockedIncrement( &m_lRefCnt );
        *ppvObj = this;
		return S_OK;
    }
    else
    { 
		return E_NOINTERFACE;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CClassFactory::CreateInstance"
STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj)
{
	HRESULT hr = DV_OK;

	if( ppvObj == NULL ||
	    !DNVALID_WRITEPTR( ppvObj, sizeof(LPVOID) ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Invalid pointer passed for object" );
		return DVERR_INVALIDPOINTER;
	}

	if( pUnkOuter != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Object does not support aggregation" );
		return CLASS_E_NOAGGREGATION;
	}

	if( IsEqualGUID(riid,IID_IDirectPlayVoiceClient) )
	{
		hr = DVC_Create((LPDIRECTVOICECLIENTOBJECT *) ppvObj);
		if (FAILED(hr))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "DVC_Create Failed hr=0x%x", hr );
			return hr;
		}

		// get the right interface and bump the refcount
		hr = DVC_QueryInterface((LPDIRECTVOICECLIENTOBJECT) *ppvObj, riid, ppvObj);
	}
	else if( IsEqualGUID(riid,IID_IDirectPlayVoiceServer) )
	{
		hr = DVS_Create((LPDIRECTVOICESERVEROBJECT *) ppvObj);
		if (FAILED(hr))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "DVS_Create Failed hr=0x%x", hr );
			return hr;
		}

		// get the right interface and bump the refcount
		hr = DVS_QueryInterface((LPDIRECTVOICESERVEROBJECT) *ppvObj, riid, ppvObj);
	}
	else if( IsEqualGUID(riid,IID_IDirectPlayVoiceTest) )
	{
		hr = DVT_Create((LPDIRECTVOICESETUPOBJECT *) ppvObj);
		if (FAILED(hr))
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "DVT_Create Failed hr=0x%x", hr );
			return hr;
		}

		// get the right interface and bump the refcount
		hr = DVT_QueryInterface((LPDIRECTVOICESETUPOBJECT) *ppvObj, riid, ppvObj);
	}
	else if( IsEqualGUID(riid,IID_IUnknown) )
	{
		if( m_clsid == CLSID_DirectPlayVoice )
		{
			DPFX(DPFPREP,  0, "Requesting IUnknown through generic CLSID" );
			return E_NOINTERFACE;
		}
		else if( m_clsid == CLSID_DirectPlayVoiceClient )
		{
			hr = DVC_Create((LPDIRECTVOICECLIENTOBJECT *) ppvObj);
			if (FAILED(hr))
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "DVC_Create Failed hr=0x%x", hr );
				return hr;
			}

			// get the right interface and bump the refcount
			hr = DVC_QueryInterface((LPDIRECTVOICECLIENTOBJECT) *ppvObj, riid, ppvObj);
		}
		else if( m_clsid == CLSID_DirectPlayVoiceServer )
		{
			hr = DVS_Create((LPDIRECTVOICESERVEROBJECT *) ppvObj);
			if (FAILED(hr))
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "DVS_Create Failed hr=0x%x", hr );
				return hr;
			}

			// get the right interface and bump the refcount
			hr = DVS_QueryInterface((LPDIRECTVOICESERVEROBJECT) *ppvObj, riid, ppvObj);
		}
		else if( m_clsid == CLSID_DirectPlayVoiceTest ) 
		{
			hr = DVT_Create((LPDIRECTVOICESETUPOBJECT *) ppvObj);
			if (FAILED(hr))
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "DVT_Create Failed hr=0x%x", hr );
				return hr;
			}

			// get the right interface and bump the refcount
			hr = DVT_QueryInterface((LPDIRECTVOICESETUPOBJECT) *ppvObj, riid, ppvObj);
		}
		else
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unknown interface" );
			return E_NOINTERFACE;
		}
	}
	else 
	{
		return E_NOINTERFACE;
	}

	IncrementObjectCount();
	
	return hr;
}


#ifdef DPLAY_LOADANDCHECKTRUE
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

extern HMODULE ghRedirect;
extern PFN_DLLGETCLASSOBJECT pfnGetClassObject;
extern PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow;
#endif


/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    CClassFactory*	pcf;
    HRESULT		hr;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		GUID guidCLSID;

		if( IsEqualCLSID( rclsid, DPVOICE_CLSID_DPVOICE ) )
		{
			memcpy( &guidCLSID, &CLSID_DirectPlayVoice, sizeof(GUID) );
		}
		else
		{
			memcpy( &guidCLSID, rclsid, sizeof(GUID) );
		}

		return (*pfnGetClassObject)(&guidCLSID,riid,ppvObj);
	}
#endif

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
	if( !IsEqualCLSID(rclsid, DPVOICE_CLSID_DPVOICE) && 
		!IsEqualCLSID(rclsid, CLSID_DirectPlayVoiceClient) &&
		!IsEqualCLSID(rclsid, CLSID_DirectPlayVoiceServer) && 
		!IsEqualCLSID(rclsid, CLSID_DirectPlayVoiceTest) )
	{
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = new CClassFactory((CLSID*)&rclsid);
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

    hr = pcf->QueryInterface( riid, ppvObj );
    if( FAILED( hr ) )
    {
        delete ( pcf );
        *ppvObj = NULL;
    }
    else
    {
		IncrementObjectCount();
	}
	
    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

#ifdef DPLAY_LOADANDCHECKTRUE
	if( ghRedirect != NULL )
	{
		return (*pfnDllCanUnLoadNow)();
	}
#endif

	if ( (0 == g_lNumObjects) && (0 == g_lNumLocks) )
	{
		hr = S_OK;
	}
	
    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dvtran.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvtransport.h
 *  Content:	Base class for dp/dnet abstraction
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Created It
 * 07/22/99		rodtoll	Updated to reflect new player table routines
 * 07/23/99		rodtoll	Added group membership checks and player id retrieval
 * 07/26/99		rodtoll	Modified EnableReceiveHook for use with new interfaces
 * 08/03/99		rodtoll	Changed abstraction for new init order
 * 11/23/99		rodtoll	Split CheckForValid into Group and Player 
 * 01/14/2000	rodtoll	Renamed SendToID to SendToIDS and updated parameter list
 *						to accept multiple targets.
 *				rodtoll	Added GetNumPlayers call 
 * 03/28/2000   rodtoll Moved nametable from here to upper level classes
 *              rodtoll Updated Advise to have interface specify if it's a client or server when advising/unadvising
 * 04/07/2000   rodtoll Bug #32179 - Registering more then one server/and/or/client 
 *              rodtoll Updated sends to take new buffer descs for no copy sends
 * 06/21/2000	rodtoll Bug #36820 - Host migrates to wrong client when client/server are on same interface
 *						Condition exists where host sends leave message, client attempts to start new host
 *						which fails because old host still registered.  Now deregistering is two step
 *						process DisableReceiveHook then DestroyTransport.  
 * 07/22/20000	rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				    Now ensures that all threads from transport have left and that
 *					    all notificatinos have been processed before shutdown is complete.  
 *  01/22/2001	rodtoll	WINBUG #288437 - IA64 Pointer misalignment due to wire packets 
 *
 ***************************************************************************/

#ifndef __DVTRANSPORT_H
#define __DVTRANSPORT_H

class CDirectVoiceEngine;
class CVoicePlayer;
class CDirectVoiceTransport;

struct DIRECTVOICEOBJECT;

// CDirectVoiceTransport
//
// Abstracts the transport system so that the sends and group management 
// features of DPlay/DirectNet are indpendent.
class CDirectVoiceTransport 
{
// Voice player table management
public:
	CDirectVoiceTransport(): m_lRefCount(0) {};
	virtual ~CDirectVoiceTransport() {};

	inline void Release() { InterlockedDecrement( &m_lRefCount ); };
	inline void AddRef() { InterlockedIncrement( &m_lRefCount ); };

	virtual HRESULT AddPlayerEntry( DVID dvidPlayer, LPVOID lpData ) = 0;
	virtual HRESULT DeletePlayerEntry( DVID dvidPlayer ) = 0;
	virtual HRESULT GetPlayerEntry( DVID dvidPlayer, CVoicePlayer **lplpPlayer ) = 0;
	virtual HRESULT Initialize() = 0;
	virtual HRESULT MigrateHost( DVID dvidNewHost ) = 0;

	virtual DVID GetLocalID() = 0;
	virtual DVID GetServerID() = 0;

public:
	virtual HRESULT SendToServer( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags ) = 0;
	virtual HRESULT SendToAll( PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags ) = 0;
	virtual HRESULT SendToIDS( UNALIGNED DVID * pdvidTargets, DWORD dwNumTargets, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvContext, DWORD dwFlags ) = 0;

	virtual DWORD GetMaxPlayers( )= 0;

public: // Remote Server Synchronization functions
	virtual HRESULT CreateGroup( LPDVID dvidGroup ) = 0;
	virtual HRESULT DeleteGroup( DVID dvidGroup ) = 0;
	virtual HRESULT AddPlayerToGroup( LPDVID dvidGroup, DVID dvidPlayer ) = 0; 
	virtual HRESULT RemovePlayerFromGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;

public: // Hooks into the transport
	virtual BOOL IsPlayerInGroup( DVID dvidGroup, DVID dvidPlayer ) = 0;
	virtual BOOL ConfirmValidEntity( DVID dvid ) = 0;
	virtual BOOL ConfirmValidGroup( DVID dvid ) = 0;
	virtual HRESULT EnableReceiveHook( DIRECTVOICEOBJECT *dvObject, DWORD dwObjectType ) = 0;
	virtual HRESULT DisableReceiveHook( ) = 0;
	virtual HRESULT WaitForDetachCompletion() = 0;
	virtual void DestroyTransport() = 0;
	virtual BOOL ConfirmLocalHost( ) = 0;
	virtual BOOL ConfirmSessionActive( ) = 0;
	virtual HRESULT GetTransportSettings( LPDWORD lpdwSessionType, LPDWORD lpdwFlags ) = 0;

public:

	LONG	m_lRefCount;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dxvoicepch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxvoicepch.h
 *  Content:    DirectPlayVoice DXVOICE master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DXVOICEPCH_H__
#define __DXVOICEPCH_H__

#ifdef WINNT
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#endif

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <process.h>
#include <map>
#ifndef WIN95
#include <prsht.h>
#include "shfusion.h"
#else
#include <commctrl.h>
#endif
#include <string>
#include <vector>
#include <list>


// 
// DirectX includes
//
#include "dsound.h"
#include "dsprv.h"

// 
// DirectPlay public includes
//
#include "dvoice.h"
#include "dplay.h"
#include "dpvcp.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "comutil.h"
#include "dvcslock.h"
#include "fpm.h"
#include "lockedcfpm.h"
#include "perfinfo.h"
#include "classhashvc.h"
#include "bilink.h"
#include "strutils.h"
#include "creg.h"

// 
// DirectVoice private includes
//
#include "aplayb.h"
#include "aplayd.h"
#include "arecb.h"
#include "arecd.h"
#include "wiutils.h"
#include "sndutils.h"
#include "dsplayd.h"
#include "dsplayb.h"
#include "dscrecd.h"
#include "dvcdb.h"
#include "devmap.h"
#include "dsprvobj.h"
#include "diagnos.h"
#include "bfctypes.h"
#include "bfcsynch.h"
#include "frame.h"
#include "inqueue2.h"
#include "timer.h"
//#include "aplayd.h"
//#include "aplayb.h"
#include "arecd.h"
#include "arecb.h"
#include "agcva.h"
#include "agcva1.h"

#include "supervis.h"

// 
// Voice includes
//
#include "statdef.h"
#include "dvshared.h"
#include "mixutils.h"
#include "dvclient.h"
#include "dvsndt.h"
#include "dvserver.h"
#include "dvtran.h"
#include "dvdxtran.h"
#include "in_core.h"
#include "dvconfig.h"
#include "dvprot.h"
#include "vplayer.h"
#include "vnametbl.h"
#include "dvengine.h"
#include "dvcleng.h"
#include "dvcsplay.h"
#include "dvsereng.h"
#include "dvrecsub.h"
#include "mixserver.h"
#include "trnotify.h"
#include "createin.h"
#include "dvsetup.h"
#include "dvsetupi.h"

#include "..\..\..\bldcfg\dpvcfg.h"

#endif // __DXVOICEPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\in_core.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		in_core.h
 *  Content:	Instrumentation for voice core.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 * 04/06/2001	kareemc	Added Voice Defense
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#if defined(DEBUG) || defined(DBG)

// Default levels
#define IN_DEFAULT_RRI_DEBUGOUTPUT_LEVEL						DVF_INFOLEVEL
#define IN_DEFAULT_RECORD_SWITCH_DEBUG_LEVEL					DVF_INFOLEVEL
#define IN_DEFAULT_PLAYBACK_SWITCH_DEBUG_LEVEL					DVF_INFOLEVEL
#define IN_DEFAULT_PWI_DEBUGOUTPUT_LEVEL						DVF_INFOLEVEL
#define IN_DEFAULT_DVF_CONNECT_PROCEDURE_DEBUG_LEVEL			DVF_INFOLEVEL
#define IN_DEFAULT_DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL		DVF_INFOLEVEL
#define IN_DEFAULT_DVF_PLAYERMANAGE_DEBUG_LEVEL					DVF_INFOLEVEL
#define IN_DEFAULT_DVF_STATS_DEBUG_LEVEL						DVF_INFOLEVEL
#define IN_DEFAULT_DVF_GLITCH_DEBUG_LEVEL						DVF_WARNINGLEVEL
#define IN_DEFAULT_DVF_CLIENT_SEQNUM_DEBUG_LEVEL				DVF_INFOLEVEL
#define IN_DEFAULT_DVF_HOSTMIGRATE_DEBUG_LEVEL                  DVF_WARNINGLEVEL
#define IN_DEFAULT_DVF_COMPRESSION_DEBUG_LEVEL					DVF_INFOLEVEL
#define IN_DEFAULT_DVF_BUFFERDESC_DEBUG_LEVEL					DVF_INFOLEVEL+2
#define IN_DEFAULT_DVF_SOUNDTARGET_DEBUG_LEVEL					DVF_INFOLEVEL+2
#define IN_DEFAULT_DVF_MIXER_DEBUG_LEVEL						DVF_INFOLEVEL+1
#define IN_DEFAULT_DVF_ANTIHACK_DEBUG_LEVEL						DVF_WARNINGLEVEL

// String names
#define IN_PROFILE_RRI_DEBUGOUTPUT_LEVEL						"Client.Core.Record"
#define IN_PROFILE_RECORD_SWITCH_DEBUG_LEVEL					"Client.Core.Echo.Record"
#define IN_PROFILE_PLAYBACK_SWITCH_DEBUG_LEVEL					"Client.Core.Echo.Playback"
#define IN_PROFILE_PWI_DEBUGOUTPUT_LEVEL						"Client.Core.Playback"
#define IN_PROFILE_DVF_CONNECT_PROCEDURE_DEBUG_LEVEL			"Client.Core.Connect"
#define IN_PROFILE_DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL			"Client.Core.Disconnect"
#define IN_PROFILE_DVF_PLAYERMANAGE_DEBUG_LEVEL					"Server.Core.Players"
#define IN_PROFILE_DVF_STATS_DEBUG_LEVEL						"Client.Stats.Summary"
#define IN_PROFILE_DVF_GLITCH_DEBUG_LEVEL						"Client.Glitch"
#define IN_PROFILE_DVF_CLIENT_SEQNUM_DEBUG_LEVEL				"Client.Core.SeqNum"
#define IN_PROFILE_DVF_HOSTMIGRATE_DEBUG_LEVEL                  "Core.HostMigrate"
#define IN_PROFILE_DVF_COMPRESSION_DEBUG_LEVEL					"Client.Compression"
#define IN_PROFILE_DVF_BUFFERDESC_DEBUG_LEVEL					"Core.BufferDesc"
#define IN_PROFILE_DVF_SOUNDTARGET_DEBUG_LEVEL					"Core.Client.SoundTargets"
#define IN_PROFILE_DVF_MIXER_DEBUG_LEVEL						"Server.Mixer"
#define IN_PROFILE_DVF_ANTIHACK_DEBUG_LEVEL						"Core.AntiHack"

DVINSTRUMENT_INFO g_in_core[NUM_CORE_SECTIONS] = 
{
	DVINSTRUMENT_INFO(IN_DEFAULT_RRI_DEBUGOUTPUT_LEVEL,IN_DEFAULT_RRI_DEBUGOUTPUT_LEVEL,IN_PROFILE_RRI_DEBUGOUTPUT_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_RECORD_SWITCH_DEBUG_LEVEL,IN_DEFAULT_RECORD_SWITCH_DEBUG_LEVEL,IN_PROFILE_RECORD_SWITCH_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_PLAYBACK_SWITCH_DEBUG_LEVEL,IN_DEFAULT_PLAYBACK_SWITCH_DEBUG_LEVEL,IN_PROFILE_PLAYBACK_SWITCH_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_PWI_DEBUGOUTPUT_LEVEL,IN_DEFAULT_PWI_DEBUGOUTPUT_LEVEL,IN_PROFILE_PWI_DEBUGOUTPUT_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_CONNECT_PROCEDURE_DEBUG_LEVEL,IN_DEFAULT_DVF_CONNECT_PROCEDURE_DEBUG_LEVEL,IN_PROFILE_DVF_CONNECT_PROCEDURE_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL,IN_DEFAULT_DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL,IN_PROFILE_DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_PLAYERMANAGE_DEBUG_LEVEL,IN_DEFAULT_DVF_PLAYERMANAGE_DEBUG_LEVEL,IN_PROFILE_DVF_PLAYERMANAGE_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_STATS_DEBUG_LEVEL,IN_DEFAULT_DVF_STATS_DEBUG_LEVEL,IN_PROFILE_DVF_STATS_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_GLITCH_DEBUG_LEVEL,IN_DEFAULT_DVF_GLITCH_DEBUG_LEVEL,IN_PROFILE_DVF_GLITCH_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_CLIENT_SEQNUM_DEBUG_LEVEL,IN_DEFAULT_DVF_CLIENT_SEQNUM_DEBUG_LEVEL,IN_PROFILE_DVF_CLIENT_SEQNUM_DEBUG_LEVEL),	
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_HOSTMIGRATE_DEBUG_LEVEL,IN_DEFAULT_DVF_HOSTMIGRATE_DEBUG_LEVEL,IN_PROFILE_DVF_HOSTMIGRATE_DEBUG_LEVEL),		
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_COMPRESSION_DEBUG_LEVEL,IN_DEFAULT_DVF_COMPRESSION_DEBUG_LEVEL,IN_PROFILE_DVF_COMPRESSION_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_BUFFERDESC_DEBUG_LEVEL,IN_DEFAULT_DVF_BUFFERDESC_DEBUG_LEVEL,IN_PROFILE_DVF_BUFFERDESC_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_SOUNDTARGET_DEBUG_LEVEL,IN_DEFAULT_DVF_SOUNDTARGET_DEBUG_LEVEL,IN_PROFILE_DVF_SOUNDTARGET_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_MIXER_DEBUG_LEVEL,IN_DEFAULT_DVF_MIXER_DEBUG_LEVEL,IN_PROFILE_DVF_MIXER_DEBUG_LEVEL),
	DVINSTRUMENT_INFO(IN_DEFAULT_DVF_ANTIHACK_DEBUG_LEVEL,IN_DEFAULT_DVF_ANTIHACK_DEBUG_LEVEL,IN_PROFILE_DVF_ANTIHACK_DEBUG_LEVEL)	
	
};

void Instrument_Core_Init()
{
	for( DWORD dwIndex = 0; dwIndex < NUM_CORE_SECTIONS; dwIndex++ )
	{
		g_in_core[dwIndex].m_dwLevel = GetProfileIntA( PROF_SECT, g_in_core[dwIndex].m_szProfileName, g_in_core[dwIndex].m_dwDefaultLevel );
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\in_def.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		in_def.h
 *  Content:	Definition of common structs for voice instrumentation
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 * 04/06/2001	kareemc	Added Voice Defense
 *
 ***************************************************************************/
#ifndef __IN_DEF_H
#define __IN_DEF_H

#define PROF_SECT "DirectPlay8"

struct DVINSTRUMENT_INFO
{
	DVINSTRUMENT_INFO( DWORD dwLevel, DWORD dwDefaultLevel, const char *szProfileName ):	m_dwLevel(dwLevel), m_dwDefaultLevel(dwDefaultLevel), m_szProfileName(szProfileName) {};	
	DWORD	m_dwLevel;
	DWORD m_dwDefaultLevel;
	const char *m_szProfileName;
};

typedef DVINSTRUMENT_INFO *PDVINSTRUMENT_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\in_core.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		in_core.h
 *  Content:	Instrumentation for voice core.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 * 04/06/2001	kareemc	Added Voice Defense
 *
 ***************************************************************************/
 #ifndef __IN_CORE_H
#define __IN_CORE_H

#include "in_def.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#if defined(DEBUG) || defined(DBG)

#define NUM_CORE_SECTIONS		 16

extern DVINSTRUMENT_INFO g_in_core[NUM_CORE_SECTIONS];

// Defines for modules 
#define RRI_DEBUGOUTPUT_LEVEL									(g_in_core[0].m_dwLevel)
#define RECORD_SWITCH_DEBUG_LEVEL								(g_in_core[1].m_dwLevel)
#define PLAYBACK_SWITCH_DEBUG_LEVEL								(g_in_core[2].m_dwLevel)
#define PWI_DEBUGOUTPUT_LEVEL									(g_in_core[3].m_dwLevel)
#define DVF_CONNECT_PROCEDURE_DEBUG_LEVEL						(g_in_core[4].m_dwLevel)
#define DVF_DISCONNECT_PROCEDURE_DEBUG_LEVEL					(g_in_core[5].m_dwLevel)
#define DVF_PLAYERMANAGE_DEBUG_LEVEL							(g_in_core[6].m_dwLevel)
#define DVF_STATS_DEBUG_LEVEL									(g_in_core[7].m_dwLevel)
#define DVF_GLITCH_DEBUG_LEVEL									(g_in_core[8].m_dwLevel)
#define DVF_CLIENT_SEQNUM_DEBUG_LEVEL							(g_in_core[9].m_dwLevel)
#define DVF_HOSTMIGRATE_DEBUG_LEVEL								(g_in_core[10].m_dwLevel)
#define DVF_COMPRESSION_DEBUG_LEVEL								(g_in_core[11].m_dwLevel)
#define DVF_BUFFERDESC_DEBUG_LEVEL								(g_in_core[12].m_dwLevel)
#define DVF_SOUNDTARGET_DEBUG_LEVEL								(g_in_core[13].m_dwLevel)
#define DVF_MIXER_DEBUG_LEVEL									(g_in_core[14].m_dwLevel)
#define DVF_ANTIHACK_DEBUG_LEVEL								(g_in_core[15].m_dwLevel)

void Instrument_Core_Init();
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\mixserver.h ===
#ifndef __MIXSERVER_H
#define __MIXSERVER_H

class CDirectVoiceServerEngine;

typedef struct _MIXERTHREAD_CONTROL
{
	DWORD						dwThreadIndex;		// Internal thread index
	DWORD						dwThreadID;			// Thread ID.
	DWORD						dwNumToMix;
	HANDLE						hThread;			// Thread Handle.
	HANDLE						hThreadIdle;		// Event signalled when thread is idle.
	HANDLE						hThreadDoWork;		// Event signalled when thread should do work.
	HANDLE						hThreadQuit;		// Event signalled to get thread to quit
	HANDLE						hThreadDone;		// Event signalled when thread has completed 
	DNCRITICAL_SECTION			m_csMixingAddList;
	BILINK						m_blMixingActivePlayers; 
	BILINK 						m_blMixingAddPlayers;
	BILINK						m_blMixingSpeakingPlayers;
	BILINK						m_blMixingHearingPlayers;
    LONG						*m_realMixerBuffer;	// High resolution mixer buffer
    BYTE						*m_mixerBuffer;
    CDirectVoiceServerEngine	*m_pServerObject;
} MIXERTHREAD_CONTROL, *PMIXERTHREAD_CONTROL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\dxvdllmain.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.cpp
 *  Content:	This file contains all of the DLL exports except for DllGetClass / DllCanUnload
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 07/05/00 rodtoll Created
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 * 01/11/2001	rmt		MANBUG #48487 - DPLAY: Crashes if CoCreate() isn't called.   
 * 03/14/2001   rmt		WINBUG #342420 - Restore COM emulation layer to operation. 
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#ifdef DPLAY_LOADANDCHECKTRUE 
HRESULT InitializeRedirectFunctionTable()
HRESULT FreeRedirectFunctionTable()
#endif

DNCRITICAL_SECTION g_csObjectInitGuard;
LONG lInitCount = 0;

// # of objects active in the system
volatile LONG g_lNumObjects = 0;
LONG g_lNumLocks = 0;

#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT RegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPVOICE_REGISTRY_BASE DPVOICE_REGISTRY_CP, FALSE, TRUE ) )
	{
		return DVERR_GENERIC;
	}
	else
	{
		return DV_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
// For DPVOICE.DLL this is making sure the compression provider sub-key is created.
//
HRESULT UnRegisterDefaultSettings()
{
	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPVOICE_REGISTRY_BASE, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove compression provider, does not exist" );
	}
	else
	{
		if( !creg.DeleteSubKey( &(DPVOICE_REGISTRY_CP)[1] ) )
		{
			DPFERR( "Cannot remove cp sub-key, could have elements" );
		}
	}

	return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::Register( L"DirectPlayVoice.Compat.1", L"DirectPlayVoice Object", 
							  L"dpvoice.dll", CLSID_DIRECTPLAYVOICE, L"DirectPlayVoice.Compat") )
	{
		DPFERR( "Could not register compat object" );
		fFailed = TRUE;
	}
	
	if( !CRegistry::Register( L"DirectPlayVoice.Server.1", L"DirectPlayVoice Server Object", 
							  L"dpvoice.dll", CLSID_DirectPlayVoiceServer, L"DirectPlayVoice.Server") )
	{
		DPFERR( "Could not register server object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlayVoice.Client.1", L"DirectPlayVoice Client Object", 
	                          L"dpvoice.dll", CLSID_DirectPlayVoiceClient, 
							  L"DirectPlayVoice.Client") )
	{

		DPFERR( "Could not register client object" );
		fFailed = TRUE;
	}

	if( !CRegistry::Register( L"DirectPlayVoice.Test.1", L"DirectPlayVoice Test Object", 
	                          L"dpvoice.dll", CLSID_DirectPlayVoiceTest, 
							  L"DirectPlayVoice.Test") )
	{
		DPFERR( "Could not register test object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
STDAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( !CRegistry::UnRegister(CLSID_DirectPlayVoiceServer) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to unregister server object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DIRECTPLAYVOICE) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to unregister compat object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DirectPlayVoiceClient) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to unregister client object" );
		fFailed = TRUE;
	}

	if( !CRegistry::UnRegister(CLSID_DirectPlayVoiceTest) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to unregister test object" );
		fFailed = TRUE;
	}

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlayVoiceCreate"
HRESULT WINAPI DirectPlayVoiceCreate( const GUID * pcIID, void **ppvInterface, IUnknown *pUnknown) 
{
	GUID clsid;
	
    if( pcIID == NULL || 
        !DNVALID_READPTR( pcIID, sizeof( GUID ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer specified for interface GUID" );
        return DVERR_INVALIDPOINTER;
    }

    if( *pcIID != IID_IDirectPlayVoiceClient && 
        *pcIID != IID_IDirectPlayVoiceServer && 
        *pcIID != IID_IDirectPlayVoiceTest )
    {
        DPFX(DPFPREP,  0, "Interface ID is not recognized" );
        return DVERR_INVALIDPARAM;
    }

    if( ppvInterface == NULL || !DNVALID_WRITEPTR( ppvInterface, sizeof( void * ) ) )
    {
        DPFX(DPFPREP,  0, "Invalid pointer specified to receive interface" );
        return DVERR_INVALIDPOINTER;
    }

    if( pUnknown != NULL )
    {
        DPFX(DPFPREP,  0, "Aggregation is not supported by this object yet" );
        return DVERR_INVALIDPARAM;
    }

    if( *pcIID == IID_IDirectPlayVoiceClient )
	{
		clsid = CLSID_DirectPlayVoiceClient;
    }
    else if( *pcIID == IID_IDirectPlayVoiceServer )
	{
		clsid = CLSID_DirectPlayVoiceServer;
	}
	else if( *pcIID == IID_IDirectPlayVoiceTest )
	{
		clsid = CLSID_DirectPlayVoiceTest;
	}
    else 
    {
    	DPFERR( "Invalid IID specified" );
    	return E_NOINTERFACE;
    }

    return COM_CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, *pcIID, ppvInterface, TRUE ); 
   
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
BOOL WINAPI DllMain(
              HINSTANCE hDllInst,
              DWORD fdwReason,
              LPVOID lpvReserved)
{
	if( fdwReason == DLL_PROCESS_ATTACH )
	{
		if( !lInitCount )
		{
#ifndef WIN95
			SHFusionInitializeFromModule(hDllInst);
#endif
			if (!DNOSIndirectionInit())
			{
				return FALSE;
			}
			if (!DNInitializeCriticalSection(&g_csObjectInitGuard))
			{
				DPFX(DPFPREP, 0, "Failed to create CS" );
				DNOSIndirectionDeinit();
				return FALSE;
			}
			if (FAILED(COM_Init()))
			{
				DPFX(DPFPREP, 0, "Failed to Init COM layer" );
				DNDeleteCriticalSection(&g_csObjectInitGuard);
				DNOSIndirectionDeinit();
				return FALSE;
			}

			if (!DSERRTRACK_Init())
			{
				DPFX(DPFPREP, 0, "Failed to Init DS error tracking" );
				COM_Free();
				DNDeleteCriticalSection(&g_csObjectInitGuard);
				DNOSIndirectionDeinit();
				return FALSE;
			}

#if defined(DEBUG) || defined(DBG)
			Instrument_Core_Init();			
#endif
#ifdef DPLAY_LOADANDCHECKTRUE 			
			InitializeRedirectFunctionTable();
#endif
			InterlockedIncrement( &lInitCount );

			PERF_Initialize();
		}
	}
	else if( fdwReason == DLL_PROCESS_DETACH )
	{
		InterlockedDecrement( &lInitCount );

		if( lInitCount == 0 )
		{
			DSERRTRACK_UnInit();
			DPFX(DPFPREP,  DVF_INFOLEVEL, ">>>>>>>>>>>>>>>> DPF UNINITED <<<<<<<<<<<<<<<" );
#ifdef DPLAY_LOADANDCHECKTRUE 			
			FreeRedirectFunctionTable();
#endif
			COM_Free();
			PERF_DeInitialize();

			DNDeleteCriticalSection(&g_csObjectInitGuard);	

			// This must be called after all DNDeleteCriticalSection calls are done
			DNOSIndirectionDeinit();

			// Check to ensure we're not being unloaded with objects active

			if( g_lNumObjects != 0 || g_lNumLocks != 0 )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "=========================================================================" );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "DPVOICE.DLL is unloading with %i objects and %i locks still open.   This is an ERROR.  ", g_lNumObjects, g_lNumLocks );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "You must release all DirectPlayVoice objects before exiting your process." );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "=========================================================================" );				
				DNASSERT( FALSE );
			}

#ifndef WIN95	
			SHFusionUninitialize();
#endif
		}
	}

	return TRUE;
}

////////////////////////////////////////////////////////////////////////
//
// SUPPORT FUNCTIONS FOR STANDALONE DLL

#ifdef DPLAY_LOADANDCHECKTRUE 
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

extern "C" {
HMODULE ghRedirect = NULL;
PFN_DLLGETCLASSOBJECT pfnGetClassObject = NULL;
PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow = NULL;
};

#undef DPF_MODNAME
#define DPF_MODNAME "CheckForPrivateBit"
BOOL CheckForPrivateBit( DWORD dwBit )
{
    CRegistry creg;
    DWORD dwValue;

    if( !creg.Open( DPLAY_LOADTREE_REGTREE, DPLAY_LOADTRUE_REGPATH, TRUE, FALSE ) )
    {
        return FALSE;
    }

    if( !creg.ReadDWORD( DPLAY_LOADTRUE_REGKEY, dwValue ) )
    {
        return FALSE;
    }

    if( dwValue & dwBit )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

HRESULT InitializeRedirectFunctionTable()
{
    LONG lLastError;
    
    if( CheckForPrivateBit( DPLAY_LOADTRUE_BIT ) )
    {
        ghRedirect = LoadLibrary( "dpvoice.dll" );

        if( ghRedirect == NULL )
        {
            lLastError = GetLastError();
            
            DPFX(DPFPREP,  0, "Could not load dplayx.dll error = 0x%x", lLastError );
			return DPERR_GENERIC;

        }

		pfnGetClassObject = (PFN_DLLGETCLASSOBJECT) GetProcAddress( ghRedirect, "DllGetClassObject" );
		pfnDllCanUnLoadNow = (PFN_DLLCANUNLOADNOW) GetProcAddress( ghRedirect, "DllCanUnloadNow" );
    }

    return DP_OK;    
}

HRESULT FreeRedirectFunctionTable()
{
    if( ghRedirect != NULL )
        FreeLibrary( ghRedirect );

    return DP_OK;
}
#endif

LONG DecrementObjectCount()
{
	LONG lNewValue;
	
	DNEnterCriticalSection( &g_csObjectInitGuard );

	g_lNumObjects--;
	lNewValue = g_lNumObjects;	

	if( g_lNumObjects == 0 )
	{
		CDirectVoiceEngine::Shutdown();	
	}

	DNLeaveCriticalSection( &g_csObjectInitGuard );

	return lNewValue;
}

LONG IncrementObjectCount()
{
	LONG lNewValue;
	
	DNEnterCriticalSection( &g_csObjectInitGuard );

	g_lNumObjects++;
	lNewValue = g_lNumObjects;

	if( g_lNumObjects == 1 )
	{
       	CDirectVoiceEngine::Startup(DPVOICE_REGISTRY_BASE);
	}

	DNLeaveCriticalSection( &g_csObjectInitGuard );	

	return lNewValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\fwdserver.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fwdserver.cpp
 *  Content:	Implements the forwarding server portion of the server class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/01/2000	rodtoll	Split out from dvsereng.cpp
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartupMulticast"
//
// StartupMulticast
//
// This function is called to initialize the multicast portion of the server
// object.  
//
// Called By:
// - StartSession
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::StartupMulticast()
{
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ShutdownMulticast"
//
// ShutdownMulticast
//
// This function is called to shutdown the multicast portion of the server
// object.  
//
// Called By:
// - StartSession
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::ShutdownMulticast()
{

	return DV_OK;
}

HRESULT CDirectVoiceServerEngine::HandleForwardingReceive( CVoicePlayer *pTargetPlayer, PDVPROTOCOLMSG_SPEECHWITHTARGET pdvSpeechWithtarget, DWORD dwSpeechSize, PBYTE pbSpeechData )
{
	HRESULT hr;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
	PDVPROTOCOLMSG_SPEECHWITHFROM pdvSpeechWithFrom;
	PVOID pvSendContext;

	DWORD dwTransmitSize = sizeof( DVPROTOCOLMSG_SPEECHWITHFROM ) + dwSpeechSize;

	DNASSERT( dwTransmitSize <= m_lpdvfCompressionInfo->dwFrameLength + sizeof( DVPROTOCOLMSG_SPEECHWITHFROM ) );

	pBufferDesc = GetTransmitBuffer( dwTransmitSize, &pvSendContext );

	if( pBufferDesc == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
		pTargetPlayer->Release();
		return FALSE;
	}

	pdvSpeechWithFrom = (PDVPROTOCOLMSG_SPEECHWITHFROM) pBufferDesc->pBufferData;

	pdvSpeechWithFrom->dvHeader.dwType = DVMSGID_SPEECHWITHFROM;
	pdvSpeechWithFrom->dvHeader.bMsgNum = pdvSpeechWithtarget->dvHeader.bMsgNum;
	pdvSpeechWithFrom->dvHeader.bSeqNum = pdvSpeechWithtarget->dvHeader.bSeqNum;
	pdvSpeechWithFrom->dvidFrom = pTargetPlayer->GetPlayerID();

	memcpy( &pdvSpeechWithFrom[1], pbSpeechData, dwSpeechSize );
	
	hr = m_lpSessionTransport->SendToIDS( (PDVID) &pdvSpeechWithtarget[1], pdvSpeechWithtarget->dwNumTargets, pBufferDesc, pvSendContext, 0 );

	if( hr == DVERR_PENDING )
	{
	    hr = DV_OK;
	}
	else if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed sending to ID hr=0x%x", hr );
	}	

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\mixserver.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mixserver.cpp
 *  Content:	Implements the mixing server portion of the server class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/01/2000	rodtoll	Split out from dvsereng.cpp
 *  12/14/2000	rodtoll	DPVOICE: [Mixing Server] Mixer may create infinite loop
 *  02/20/2001	rodtoll	WINBUG #321297 - DPVOICE: Access violation in DPVoice.dll while running DVSalvo server
 *  04/09/2001	rodtoll	WINBUG #364126 - DPVoice : Memory leak when Initializing 2 Voice Servers with same DPlay transport
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#define IsEmpty(x)   (x.next == x.prev && x.next == &x)

//#define IsEmpty(x)		(FALSE)

#define CONVERTTORECORD(x,y,z)		((y *)(x->pvObject))

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::AddPlayerToMixingAddList"
void CDirectVoiceServerEngine::AddPlayerToMixingAddList( CVoicePlayer *pPlayer )
{
	CDVCSPlayer *pVoicePlayer = (CDVCSPlayer *) pPlayer;
	DNASSERT( pVoicePlayer );

	for( DWORD dwIndex = 0; dwIndex < m_dwNumMixingThreads; dwIndex++ )
	{
		DNEnterCriticalSection( &m_prWorkerControl[dwIndex].m_csMixingAddList );
		pVoicePlayer->AddToMixingList( dwIndex, &m_prWorkerControl[dwIndex].m_blMixingAddPlayers );
		pVoicePlayer->AddRef();
		DNLeaveCriticalSection( &m_prWorkerControl[dwIndex].m_csMixingAddList );
	}
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartWorkerThreads"
// StartWorkerThreads
//
// This function starts mixer worker threads.  The number started is based on the
// m_dwNumMixingThreads variable which must be initialized before this is called.
//
HRESULT CDirectVoiceServerEngine::StartWorkerThreads()
{
	HRESULT hr = DV_OK;
	DWORD dwIndex;
	
  	m_prWorkerControl = new MIXERTHREAD_CONTROL[m_dwNumMixingThreads];

    if( m_prWorkerControl == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory!" );
    	return DVERR_OUTOFMEMORY;
    }

	// Zero memory so everything is initialized.
    ZeroMemory( m_prWorkerControl, sizeof( MIXERTHREAD_CONTROL )*m_dwNumMixingThreads );

    for( dwIndex = 0; dwIndex < m_dwNumMixingThreads; dwIndex++ )
    {
    	m_prWorkerControl[dwIndex].dwThreadIndex = dwIndex;
		m_prWorkerControl[dwIndex].hThreadDone = CreateEvent( NULL, FALSE, FALSE, NULL );
		m_prWorkerControl[dwIndex].hThreadDoWork = CreateEvent( NULL, FALSE, FALSE, NULL );
		m_prWorkerControl[dwIndex].hThreadIdle = CreateEvent( NULL, FALSE, FALSE, NULL );
		m_prWorkerControl[dwIndex].hThreadQuit = CreateEvent( NULL, FALSE, FALSE, NULL );
		m_prWorkerControl[dwIndex].m_pServerObject = this;

		InitBilink( &m_prWorkerControl[dwIndex].m_blMixingAddPlayers, NULL );		
		InitBilink( &m_prWorkerControl[dwIndex].m_blMixingActivePlayers, NULL );

		if (!DNInitializeCriticalSection( &m_prWorkerControl[dwIndex].m_csMixingAddList ))
		{
			hr = DVERR_OUTOFMEMORY;
			goto EXIT_ERROR;
		}

		if( m_prWorkerControl[dwIndex].hThreadDone == NULL || 
			m_prWorkerControl[dwIndex].hThreadDoWork == NULL || 
			m_prWorkerControl[dwIndex].hThreadIdle == NULL ||
			m_prWorkerControl[dwIndex].hThreadQuit == NULL )
		{
			hr = GetLastError();			
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating events hr=0x%x", hr );
			hr = DVERR_GENERIC;
			goto EXIT_ERROR;
		}

	    m_prWorkerControl[dwIndex].m_mixerBuffer = new BYTE[m_dwUnCompressedFrameSize];
	    m_prWorkerControl[dwIndex].m_realMixerBuffer = new LONG[m_dwMixerSize];

		if( m_prWorkerControl[dwIndex].m_mixerBuffer == NULL || 
			m_prWorkerControl[dwIndex].m_realMixerBuffer == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
			hr = DVERR_OUTOFMEMORY;
			goto EXIT_ERROR;
		}

		m_prWorkerControl[dwIndex].hThread = (HANDLE) CreateThread( NULL, 0, MixerWorker, &m_prWorkerControl[dwIndex], 0, &m_prWorkerControl[dwIndex].dwThreadID ); 		

		if( m_prWorkerControl[dwIndex].hThread == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating events/thread" );
			hr = DVERR_GENERIC;
			goto EXIT_ERROR;
		}
	
		::SetThreadPriority( m_prWorkerControl[dwIndex].hThread, THREAD_PRIORITY_TIME_CRITICAL );	

	
    }

    return DV_OK;

EXIT_ERROR:

	ShutdownWorkerThreads();

	return hr;
}

HRESULT CDirectVoiceServerEngine::ShutdownWorkerThreads()
{
	DWORD dwIndex;

	if( m_prWorkerControl )
	{
		for( dwIndex = 0; dwIndex < m_dwNumMixingThreads; dwIndex++ )
		{
			if( m_prWorkerControl[dwIndex].hThread )
			{
				DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "[%d]: Shutting down ID=[0x%x]", dwIndex, m_prWorkerControl[dwIndex].dwThreadID ); 
					
				SetEvent( m_prWorkerControl[dwIndex].hThreadQuit );
				WaitForSingleObject( m_prWorkerControl[dwIndex].hThreadDone, INFINITE );

				DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "[%d]: Shutting down complete", dwIndex ); 			

				CloseHandle( m_prWorkerControl[dwIndex].hThread );
				m_prWorkerControl[dwIndex].hThread = NULL;

				DNDeleteCriticalSection( &m_prWorkerControl[dwIndex].m_csMixingAddList );
			}
			
			if( m_prWorkerControl[dwIndex].hThreadDone )
				CloseHandle( m_prWorkerControl[dwIndex].hThreadDone );

			if( m_prWorkerControl[dwIndex].hThreadDoWork )
				CloseHandle( m_prWorkerControl[dwIndex].hThreadDoWork );

			if( m_prWorkerControl[dwIndex].hThreadIdle )
				CloseHandle( m_prWorkerControl[dwIndex].hThreadIdle );

			if( m_prWorkerControl[dwIndex].hThreadQuit )
				CloseHandle( m_prWorkerControl[dwIndex].hThreadQuit );

			if( m_prWorkerControl[dwIndex].m_mixerBuffer )
				delete [] m_prWorkerControl[dwIndex].m_mixerBuffer;

			if( m_prWorkerControl[dwIndex].m_realMixerBuffer )
				delete [] m_prWorkerControl[dwIndex].m_realMixerBuffer;

			DNASSERT( (IsEmpty( m_prWorkerControl[dwIndex].m_blMixingAddPlayers )) );		
			DNASSERT( (IsEmpty( m_prWorkerControl[dwIndex].m_blMixingActivePlayers )) );	
			
		}

		delete [] m_prWorkerControl;
		m_prWorkerControl = NULL;
	}
	return 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::StartupClientServer"
//
// StartupClientServer
//
// This function is called to initialize the Mixer portion of the server object.  
// Only called for Mixing Sessions.  Initialization includes the startup of 
// the mixing thread and startup of the mixer multimedia timer. 
//
// Called By:
// - StartSession
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::StartupClientServer()
{
	HRESULT hr;
	HANDLE tmpThreadHandle;	
	SYSTEM_INFO sysInfo;
	DWORD dwIndex;
	
	m_pFramePool = NULL;

	m_dwCompressedFrameSize = m_lpdvfCompressionInfo->dwFrameLength;
	m_dwUnCompressedFrameSize = DVCDB_CalcUnCompressedFrameSize( m_lpdvfCompressionInfo, s_lpwfxMixerFormat );
	m_dwNumPerBuffer = m_lpdvfCompressionInfo->dwFramesPerBuffer;

	m_pFramePool = new CFramePool( m_dwCompressedFrameSize );

	if( m_pFramePool == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate frame pool" );
		return DVERR_OUTOFMEMORY;
	}

	if (!m_pFramePool->Init())
	{
		delete m_pFramePool;
		m_pFramePool = NULL;
		return DVERR_OUTOFMEMORY;
	}

    m_mixerEightBit = (s_lpwfxMixerFormat->wBitsPerSample==8) ? TRUE : FALSE;

    GetSystemInfo( &sysInfo );
    m_dwNumMixingThreads = sysInfo.dwNumberOfProcessors;

    DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXER: There will be %d worker threads", m_dwNumMixingThreads );

    if( m_mixerEightBit )
    {
        m_dwMixerSize = m_dwUnCompressedFrameSize;
    }
    else
    {
		// Mixer size is / 2 because 16-bit samples, only need 1 LONG for
		// each 16-bit sample = 2 * 8bit.  
        m_dwMixerSize = m_dwUnCompressedFrameSize / 2;
    }    

	m_pStats->m_dwNumMixingThreads = m_dwNumMixingThreads;

    hr = StartWorkerThreads();

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed starting worker threads hr=0x%x", hr );
    	goto EXIT_CLIENTSERVERSTARTUP;
    }
    
    // General info
    m_timer = new Timer;

    if( m_timer == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory!" );
    	hr = DVERR_OUTOFMEMORY;
    	goto EXIT_CLIENTSERVERSTARTUP;
    }

    m_hTickSemaphore = CreateSemaphore( NULL, 0, 0xFFFFFF, NULL );

    if( m_hTickSemaphore == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create semaphore" );
    	hr = DVERR_GENERIC;
    	goto EXIT_CLIENTSERVERSTARTUP;
    }

    m_hShutdownMixerEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    m_hMixerDoneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    if( m_hShutdownMixerEvent == NULL || 
    	m_hMixerDoneEvent == NULL )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create events" );
    	hr = DVERR_GENERIC;
    	goto EXIT_CLIENTSERVERSTARTUP;
    }

	m_hMixerControlThread = CreateThread( NULL, 0, MixerControl, this, 0, &m_dwMixerControlThreadID ); 			

	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXER: Controller Started: ID=0x%x", m_dwMixerControlThreadID );

	if( m_hMixerControlThread == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating events/thread" );
		hr = DVERR_GENERIC;
		goto EXIT_CLIENTSERVERSTARTUP;
	}
	
	::SetThreadPriority( m_hMixerControlThread, THREAD_PRIORITY_TIME_CRITICAL );
	
    if( !m_timer->Create( m_lpdvfCompressionInfo->dwTimeout, 2, (DWORD_PTR) &m_hTickSemaphore, MixingServerWakeupProc ) )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to create multimedia timer" );
    	hr = DVERR_GENERIC;
    	goto EXIT_CLIENTSERVERSTARTUP;
    }

    return DV_OK;
    
EXIT_CLIENTSERVERSTARTUP:

	ShutdownClientServer();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::ShutdownClientServer"
//
// ShutdownClientServer
//
// This function is responsible for shutting down the mixer portion of the 
// server object.  This function should only be called for mixing sessions.
//
// This function will stop the mixer thread and the mixer multimedia timer.
//
// Called By:
// - StopSession
//
// Locks Required:
// - None
//
HRESULT CDirectVoiceServerEngine::ShutdownClientServer()
{
	if( m_hMixerControlThread )
	{
		SetEvent( m_hShutdownMixerEvent );
		WaitForSingleObject( m_hMixerDoneEvent, INFINITE );
		CloseHandle( m_hMixerControlThread );
		m_hMixerControlThread = NULL;

		// Cleanup the mixing list
		CleanupMixingList();
	}

	if( m_hShutdownMixerEvent )
	{
		CloseHandle( m_hShutdownMixerEvent );
		m_hShutdownMixerEvent = NULL;
	}

	if( m_hMixerDoneEvent )
	{
		CloseHandle( m_hMixerDoneEvent );
		m_hMixerDoneEvent = NULL;
	}

	ShutdownWorkerThreads();

	if( m_timer )
	{
		delete m_timer;
		m_timer = NULL;
	}

	if( m_hTickSemaphore )
	{
	    CloseHandle( m_hTickSemaphore );
	    m_hTickSemaphore = NULL;
	}

    return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Mixer_Buffer_Reset"
// Mixer_Buffer_Reset
//
// This function resets the mixer buffer back to silence.
void CDirectVoiceServerEngine::Mixer_Buffer_Reset( DWORD dwThreadIndex )
{
	FillBufferWithSilence( m_prWorkerControl[dwThreadIndex].m_realMixerBuffer, 
						   m_prWorkerControl[dwThreadIndex].m_pServerObject->m_mixerEightBit, 
						   m_prWorkerControl[dwThreadIndex].m_pServerObject->m_dwUnCompressedFrameSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Mixer_Buffer_MixBuffer"
// Mixer_Buffer_MixBuffer
//
// This function mixes the speech pointed to by the source parameter
// into the mixer buffer.  
//
// Parameters:
// unsigned char *source - 
//		Pointer to source data in uncompressed format
void CDirectVoiceServerEngine::Mixer_Buffer_MixBuffer( DWORD dwThreadIndex, unsigned char *source )
{
	MixInBuffer( m_prWorkerControl[dwThreadIndex].m_realMixerBuffer, source, 
				 m_prWorkerControl[dwThreadIndex].m_pServerObject->m_mixerEightBit, 
				 m_prWorkerControl[dwThreadIndex].m_pServerObject->m_dwUnCompressedFrameSize ); 
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Mixer_Buffer_Normalize"
// Mixer_Buffer_Normalize
//
// This function takes the mixed audio data from the mixer
// buffer and transfers it back to the mixer format 
// and places it into the m_mixerBuffer buffer.
//
void CDirectVoiceServerEngine::Mixer_Buffer_Normalize( DWORD dwThreadIndex )
{
	NormalizeBuffer( m_prWorkerControl[dwThreadIndex].m_mixerBuffer, 
					 m_prWorkerControl[dwThreadIndex].m_realMixerBuffer, 
					 m_prWorkerControl[dwThreadIndex].m_pServerObject->m_mixerEightBit, 
					 m_prWorkerControl[dwThreadIndex].m_pServerObject->m_dwUnCompressedFrameSize );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleMixerThreadError"
//
// HandleMixerThreadError
//
// This function is called by the mixer when an unrecoverable error
// occurs.
//
void CDirectVoiceServerEngine::HandleMixerThreadError( HRESULT hr )
{
	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Mixer Thread Encountered an error.  hr=0x%x", hr );
    SetEvent( m_hMixerDoneEvent );	
	StopSession( 0, FALSE, hr );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::MixerControl"
DWORD WINAPI CDirectVoiceServerEngine::MixerControl( void *pvContext )
{
	CDirectVoiceServerEngine *This = (CDirectVoiceServerEngine *) pvContext;

	HANDLE hEvents[3];
	HANDLE *hIdleEvents = new HANDLE[This->m_dwNumMixingThreads+1];
	DWORD dwIndex = 0;
	LONG lFreeThreadIndex = 0;
	DWORD dwNumToMix = 0;
	DWORD dwTickCountStart;
	LONG lWaitResult;

	if( !hIdleEvents )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "MIXCTRL: Error allocating array" );
		DNASSERT( FALSE );
		SetEvent( This->m_hMixerDoneEvent );
		return 0;
	}

	hEvents[0] = This->m_hShutdownMixerEvent;
	hEvents[1] = This->m_hTickSemaphore;
	hEvents[2] = (HANDLE) ((DWORD_PTR) 0xFFFFFFFF);

	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXCTRL: Starting up" );	

	for( dwIndex = 0; dwIndex < This->m_dwNumMixingThreads; dwIndex++ )
	{
		hIdleEvents[dwIndex] = This->m_prWorkerControl[dwIndex].hThreadIdle;
	}

	hIdleEvents[This->m_dwNumMixingThreads] = (HANDLE) ((DWORD_PTR) 0xFFFFFFFF);

	// Wait for tick or for quit command
	while( (lWaitResult = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE )) != WAIT_OBJECT_0 )
	{
		// On Win9X we may occationally over run the end of the wait list
		// and the result is we hit the FFFFFFFFF which will cause
		// a failure.
		if( lWaitResult == WAIT_FAILED )
			continue;
			
		// Update statistics block
		InterlockedIncrement( &This->m_pStats->m_dwNumMixingPasses );

		dwTickCountStart = GetTickCount();

		// On Win95 you may occasionally encounter a situation where the waitformultiple runs
		// off the end of the list and ends up with the invalid handle above.  Just continue 
		// in this case.  
		lFreeThreadIndex = WAIT_FAILED;

		while( lFreeThreadIndex == WAIT_FAILED )
		{
			// Wait for a single mixing thread to be free
			lFreeThreadIndex = WaitForMultipleObjects( This->m_dwNumMixingThreads, hIdleEvents, FALSE, INFINITE );
			//// TODO: Error checking!  
		}

		lFreeThreadIndex -= WAIT_OBJECT_0;

		DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXCTRL: Worker [%d] is elected to do work", lFreeThreadIndex );

		This->SpinWorkToThread( lFreeThreadIndex );
	}
	
	delete [] hIdleEvents;

	SetEvent( This->m_hMixerDoneEvent );

	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXCTRL: Shutting down" );	
	
	return 0;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::MixerWorker"
DWORD WINAPI CDirectVoiceServerEngine::MixerWorker( void *pvContext )
{
	PMIXERTHREAD_CONTROL This = (PMIXERTHREAD_CONTROL) pvContext;
	HANDLE hEvents[3];
	BILINK *pblSearch, *pblSubSearch;
	CDVCSPlayer *pCurrentPlayer = NULL, *pTmpPlayer = NULL;
	PDVID pdvidTargets = NULL;
	DWORD dwNumTargets = 0;
	DWORD dwTargetIndex = 0;
	DWORD dwResultSize = 0;
	DWORD dwIndex = 0;
	DWORD dwThreadIndex = This->dwThreadIndex;
	HRESULT hr;
	CDVCSPlayer **ppThreadHearList = NULL;
	PDVPROTOCOLMSG_SPEECHHEADER pdvmSpeechHeader = NULL;
	PDVTRANSPORT_BUFFERDESC pdvbTransmitBufferDesc = NULL;
	PVOID pvSendContext = NULL;
	DVID dvidSendTarget;
	DWORD dwTickCountStart;
	DWORD dwTickCountDecStart;
	DWORD dwTickCountMixStart;
	DWORD dwTickCountDupStart;
	DWORD dwTickCountRetStart;
	DWORD dwStatIndex;
	DWORD dwTickCountEnd;
	DWORD dwTotalMix, dwForwardMix, dwReuseMix, dwOriginalMix;
	LONG lWaitResult;

	MixingServerStats *pStats = This->m_pServerObject->m_pStats;
	
	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: [%d] Started [0x%x] Thread", This->dwThreadIndex, GetCurrentThreadId() );

	hEvents[0] = This->hThreadQuit;
	hEvents[1] = This->hThreadDoWork;
	hEvents[2] = (HANDLE) ((DWORD_PTR) 0xFFFFFFFF);

	SetEvent( This->hThreadIdle );

	while( (lWaitResult = WaitForMultipleObjects( 2, hEvents, FALSE, INFINITE )) != WAIT_OBJECT_0 )
	{
		// On Win95 it may occationally move off the end of the list and hit the guard value
		if( lWaitResult == WAIT_FAILED )
			continue;
		
		// Statistics update
		dwTickCountStart = GetTickCount();
		InterlockedIncrement( &pStats->m_dwNumMixingThreadsActive );
		pStats->m_dwNumMixingPassesPerThread[dwThreadIndex]++;

		if( pStats->m_dwNumMixingThreadsActive > 
			pStats->m_dwMaxMixingThreadsActive )
		{
			pStats->m_dwMaxMixingThreadsActive = pStats->m_dwNumMixingThreadsActive;
		}

		dwStatIndex = pStats->m_dwCurrentMixingHistoryLoc[dwThreadIndex];		

		pStats->m_lCurrentPlayerCount[dwThreadIndex][dwStatIndex] = This->dwNumToMix;
		
		DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: [%d] Starting work", This->dwThreadIndex );

		if( This->dwNumToMix == 0 )
		{
			DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: No players to process!" );
			goto WORK_COMPLETE;
		}

		dwTickCountDecStart = GetTickCount();

		pStats->m_lCurrentDecCountHistory[dwThreadIndex][dwStatIndex] = 0;

		// Pass through player list and decompress those who need decompression
		//
		pblSearch = This->m_blMixingSpeakingPlayers.next;

		while( pblSearch != &This->m_blMixingSpeakingPlayers )
		{
			pCurrentPlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_blMixingSpeakingPlayers[dwThreadIndex] );

			// Dereference the array of can hear players for this player
			ppThreadHearList = pCurrentPlayer->m_pppCanHear[dwThreadIndex];

			// Player needs to have their voice decompressed
			if( pCurrentPlayer->m_pfNeedsDecompression[dwThreadIndex] )
			{
				DNASSERT( pCurrentPlayer );
				DNASSERT( pCurrentPlayer->m_pSourceFrame[dwThreadIndex] );
				DNASSERT( !pCurrentPlayer->m_pSourceFrame[dwThreadIndex]->GetIsSilence() );

				dwResultSize = This->m_pServerObject->m_dwUnCompressedFrameSize;
				
				hr = pCurrentPlayer->DeCompressInBound( 
							pCurrentPlayer->m_pSourceFrame[dwThreadIndex], 
							&pCurrentPlayer->m_sourceUnCompressed[pCurrentPlayer->m_pdwUnCompressedBufferOffset[dwThreadIndex]], 
							&dwResultSize );	

				pStats->m_lCurrentDecCountHistory[dwThreadIndex][dwStatIndex]++;				

				if( FAILED( hr ) )
				{
					DNASSERT( FALSE );
				// TODO: ERROR Handling for failed decompression
				}
				else
				{
					pCurrentPlayer->m_pfDecompressed[dwThreadIndex] = TRUE;
				}

				DNASSERT( dwResultSize == This->m_pServerObject->m_dwUnCompressedFrameSize );
			}

// Integrity checks
//
// Check to ensure that each player who this person can hear is supposed to be decompressed
#ifdef _DEBUG
			DNASSERT( pCurrentPlayer->m_pdwHearCount[dwThreadIndex] < This->dwNumToMix );
			if( pCurrentPlayer->m_pdwHearCount[dwThreadIndex] > 1 )
			{
				for( dwIndex; dwIndex < pCurrentPlayer->m_pdwHearCount[dwThreadIndex]; dwIndex++ )
				{
					DNASSERT( ppThreadHearList[dwIndex] );
					DNASSERT( ppThreadHearList[dwIndex]->m_pfNeedsDecompression[dwThreadIndex] );
				}
			}
#endif
	
			pblSearch = pblSearch->next;
		}

		dwTickCountDupStart = GetTickCount();		
		pStats->m_lCurrentDecTimeHistory[dwThreadIndex][dwStatIndex] = dwTickCountDupStart - dwTickCountDecStart;

		// Check for duplicates in the sending.  If there is duplicates then we need 
		// to setup the reuse
		pblSearch = This->m_blMixingHearingPlayers.next;

		while( pblSearch != &This->m_blMixingHearingPlayers )
		{
			pCurrentPlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_blMixingHearingPlayers[dwThreadIndex] );

			// If we don't hear anybody, this step is irrelevant
			if( pCurrentPlayer->m_pdwHearCount[dwThreadIndex] < 2 )
				goto DUPLICATE_CHECK_LOOP_DONE;

			// Dereference the array of can hear players for this player
			ppThreadHearList = pCurrentPlayer->m_pppCanHear[dwThreadIndex];			

			pblSubSearch = This->m_blMixingHearingPlayers.next;

			// Only do the people who come before them.  
			while( pblSubSearch != pblSearch )
			{
				pTmpPlayer = CONVERTTORECORD( pblSubSearch, CDVCSPlayer, m_blMixingHearingPlayers[dwThreadIndex] );

				// This person's mix is the same, re-use it!
				if( pTmpPlayer->ComparePlayerMix( dwThreadIndex, pCurrentPlayer ) )
				{
					pCurrentPlayer->m_pReuseMixFromThisPlayer[dwThreadIndex] = pTmpPlayer;
					pTmpPlayer->m_pfMixToBeReused[dwThreadIndex] = TRUE;
					break;
				}

				pblSubSearch = pblSubSearch->next;
			}
DUPLICATE_CHECK_LOOP_DONE:

			pblSearch = pblSearch->next;

		}

		dwTickCountMixStart = GetTickCount();
		pStats->m_lCurrentDupTimeHistory[dwThreadIndex][dwStatIndex] = dwTickCountMixStart - dwTickCountDupStart;

		dwTotalMix = 0;
		dwForwardMix = 0;
		dwReuseMix = 0;
		dwOriginalMix = 0;

		// Pass through player list and compress and send mixes as appropriate
		pblSearch = This->m_blMixingHearingPlayers.next;
		
		while( pblSearch != &This->m_blMixingHearingPlayers )
		{
			pCurrentPlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_blMixingHearingPlayers[dwThreadIndex] );

			// Dereference the array of can hear players for this player
			ppThreadHearList = pCurrentPlayer->m_pppCanHear[dwThreadIndex];			

			// Pre-set next so we can continue() below and still go to next item
			pblSearch = pblSearch->next;

			if( !pCurrentPlayer->m_pdwHearCount[dwThreadIndex] )
			{
				continue;
			}

			dwTotalMix++;			

			// Get a transmission buffer and description
            pdvbTransmitBufferDesc = This->m_pServerObject->GetTransmitBuffer( This->m_pServerObject->m_dwCompressedFrameSize+sizeof(DVPROTOCOLMSG_SPEECHHEADER)+COMPRESSION_SLUSH,
                                                   			  &pvSendContext );			

            if( pdvbTransmitBufferDesc == NULL )
            {
            	// TODO: Error handling for out of memory condition
            	DNASSERT( FALSE );
            }

			// Setup the packet header
			pdvmSpeechHeader = (PDVPROTOCOLMSG_SPEECHHEADER) pdvbTransmitBufferDesc->pBufferData;

			pdvmSpeechHeader->dwType = DVMSGID_SPEECHBOUNCE;
			pdvmSpeechHeader->bMsgNum = pCurrentPlayer->m_pbMsgNumToSend[dwThreadIndex];
			pdvmSpeechHeader->bSeqNum = pCurrentPlayer->m_pbSeqNumToSend[dwThreadIndex];

			DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: [%d] Sending Packet to 0x%x Msg=0x%x Seq=0x%x",
			     dwThreadIndex,
				 pCurrentPlayer->GetPlayerID(),
				 pdvmSpeechHeader->bMsgNum,
				 pdvmSpeechHeader->bSeqNum );

			// If this player hears something they will be getting a packet
			//
			// Only hear one person -- forward the packet
			//
			if( pCurrentPlayer->m_pdwHearCount[dwThreadIndex] == 1)
			{
				dwResultSize = ppThreadHearList[0]->m_pSourceFrame[dwThreadIndex]->GetFrameLength();

				memcpy( &pdvmSpeechHeader[1], 
						ppThreadHearList[0]->m_pSourceFrame[dwThreadIndex]->GetDataPointer(), 
						dwResultSize );

				DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: [%d] Forwarding already compressed packet", dwThreadIndex );

				pCurrentPlayer->m_pfMixed[dwThreadIndex] = TRUE;

				dwForwardMix++;
			}
			else if( pCurrentPlayer->m_pdwHearCount[dwThreadIndex] > 1) 
			{
				pTmpPlayer = pCurrentPlayer->m_pReuseMixFromThisPlayer[dwThreadIndex];

				// We are re-using a previous player's mix
				if( pTmpPlayer )
				{
					DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXERWORKER: [%d] Forwarding pre-built mix", dwThreadIndex );
					DNASSERT( pTmpPlayer->m_pfMixed[dwThreadIndex] );
					DNASSERT( pTmpPlayer->m_pfMixToBeReused[dwThreadIndex] );
					DNASSERT( pTmpPlayer->m_pdwResultLength[dwThreadIndex] );

					dwResultSize = pTmpPlayer->m_pdwResultLength[dwThreadIndex];
								
					memcpy( &pdvmSpeechHeader[1], 
						    &pTmpPlayer->m_targetCompressed[pTmpPlayer->m_pdwCompressedBufferOffset[dwThreadIndex]],
						    dwResultSize );

                    dwReuseMix++;
				}
				else
				{
					DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXERWORKER: [%d] Creating original mix", dwThreadIndex );

                    dwOriginalMix++;
					
					dwResultSize = This->m_pServerObject->m_dwCompressedFrameSize;	

					// Reset the high resolution mixer buffer
					This->m_pServerObject->Mixer_Buffer_Reset(dwThreadIndex);

					// Mix in specified player's audio.
					for( dwIndex = 0; dwIndex < pCurrentPlayer->m_pdwHearCount[dwThreadIndex]; dwIndex++ )
					{
						DNASSERT( !ppThreadHearList[dwIndex]->m_pfSilence[dwThreadIndex] );
						This->m_pServerObject->Mixer_Buffer_MixBuffer(dwThreadIndex,ppThreadHearList[dwIndex]->m_sourceUnCompressed );
					}

					// Normalize the buffer back to the thread's mix buffer
					This->m_pServerObject->Mixer_Buffer_Normalize(dwThreadIndex);

					hr = pCurrentPlayer->CompressOutBound( This->m_mixerBuffer, 
														   This->m_pServerObject->m_dwUnCompressedFrameSize, 
														   (BYTE *) &pdvmSpeechHeader[1], 
														   &dwResultSize );

					if( FAILED( hr ) )
					{
						DNASSERT( FALSE );
						DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed compressing outbound audio" );
						
					}

					pCurrentPlayer->m_pfMixed[dwThreadIndex] = TRUE;
					pCurrentPlayer->m_pdwResultLength[dwThreadIndex] = dwResultSize;
					
					// This player's mix will be re-used, ensure that we cache it
					if( pCurrentPlayer->m_pfMixToBeReused[dwThreadIndex] )
					{
						memcpy( &pCurrentPlayer->m_targetCompressed[pCurrentPlayer->m_pdwCompressedBufferOffset[dwThreadIndex]],
								&pdvmSpeechHeader[1], 
							    pCurrentPlayer->m_pdwResultLength[dwThreadIndex] );					
					}
				}
			}
			else
			{
				DNASSERT(FALSE);
			}
			
			dvidSendTarget = pCurrentPlayer->GetPlayerID();

			pdvbTransmitBufferDesc->dwBufferSize= dwResultSize + sizeof( DVPROTOCOLMSG_SPEECHHEADER );

			hr = This->m_pServerObject->m_lpSessionTransport->SendToIDS( &dvidSendTarget, 1, pdvbTransmitBufferDesc, pvSendContext, 0 );

			if( hr == DVERR_PENDING )
				hr = DV_OK;

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "MIXWORKER: [%d] Unable to transmit to target [0x%x]", pCurrentPlayer->GetPlayerID() );
			}

		}	

		dwTickCountRetStart = GetTickCount();
		pStats->m_lCurrentMixTimeHistory[dwThreadIndex][dwStatIndex] = dwTickCountRetStart - dwTickCountMixStart;

    	pStats->m_lCurrentMixCountTotalHistory[dwThreadIndex][dwStatIndex] = dwTotalMix;
		pStats->m_lCurrentMixCountFwdHistory[dwThreadIndex][dwStatIndex] = dwForwardMix;
		pStats->m_lCurrentMixCountReuseHistory[dwThreadIndex][dwStatIndex] = dwReuseMix;
		pStats->m_lCurrentMixCountOriginalHistory[dwThreadIndex][dwStatIndex] = dwOriginalMix;
		

WORK_COMPLETE:
	
		// Pass through player list and return frames
		pblSearch = This->m_blMixingActivePlayers.next;

		while( pblSearch != &This->m_blMixingActivePlayers )
		{
			pCurrentPlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[dwThreadIndex] );

			DNASSERT( pCurrentPlayer->m_pSourceFrame[dwThreadIndex] );

			pCurrentPlayer->CompleteRun( dwThreadIndex );

			pblSearch = pblSearch->next;
		}

		dwTickCountEnd = GetTickCount();
		pStats->m_lCurrentRetTimeHistory[dwThreadIndex][dwStatIndex] = dwTickCountEnd - dwTickCountRetStart;

		DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: [%d] Work complete", This->dwThreadIndex );

		// Statistics update
		InterlockedDecrement( &This->m_pServerObject->m_pStats->m_dwNumMixingThreadsActive );		
		
		SetEvent( This->hThreadIdle );

		// Statistics update
		pStats->m_dwMixingPassesTimeHistory[dwThreadIndex][dwStatIndex] = dwTickCountEnd - dwTickCountStart;
		pStats->m_dwCurrentMixingHistoryLoc[dwThreadIndex]++;
		pStats->m_dwCurrentMixingHistoryLoc[dwThreadIndex] %= MIXING_HISTORY;

	}
	
	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "MIXWORKER: [%d] Shutting down", This->dwThreadIndex );

	SetEvent( This->hThreadDone );
	
	return 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SpinWorkToThread"
//
// SpinWorkToThread
//
// This function performs the first step of a mixing server pass and then
// passes the work off to the specified thread
//
// Responsible for: 
// 1. Updating the 
// 2. running the list of players, determinging who they can hear
// 
void CDirectVoiceServerEngine::SpinWorkToThread( LONG lThreadIndex )
{
	BILINK *pblSearch = NULL, *pblSubSearch = NULL;
	CDVCSPlayer *pCurrentPlayer = NULL, *pTmpPlayer = NULL, *pComparePlayer = NULL;
	HRESULT hr;
	PDVID pdvidTargets = NULL;
	DWORD dwNumTargets = 0;
	DWORD dwTargetIndex = 0;

	DWORD dwTickCountStart = GetTickCount();

	// Update the list of players from the pending lists to the individual bilinks 
	UpdateActiveMixingPendingList( lThreadIndex, &m_prWorkerControl[lThreadIndex].dwNumToMix );		

	InitBilink( &m_prWorkerControl[lThreadIndex].m_blMixingSpeakingPlayers, NULL );
	InitBilink( &m_prWorkerControl[lThreadIndex].m_blMixingHearingPlayers, NULL );	

	// Pass 1 through player list.
	//
	// Reset state variables for specified thread, create any converters that need creating
	pblSearch = m_prWorkerControl[lThreadIndex].m_blMixingActivePlayers.next;

	while( pblSearch != &m_prWorkerControl[lThreadIndex].m_blMixingActivePlayers )
	{
		pTmpPlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[lThreadIndex] );

		pblSearch = pblSearch->next;

		// Reset for the next pass
		pTmpPlayer->ResetForNextRun(lThreadIndex,TRUE);

		// Resize the can hear array
		pTmpPlayer->ResizeIfRequired( lThreadIndex, m_prWorkerControl[lThreadIndex].dwNumToMix );

		// Lock the player -- only one person should be creating converter at a time
		pTmpPlayer->Lock();

		// Create outbound converter if required
		if( !pTmpPlayer->IsOutBoundConverterInitialized() )
		{
			hr = pTmpPlayer->CreateOutBoundConverter( s_lpwfxMixerFormat, m_dvSessionDesc.guidCT );

			if( FAILED( hr ) )
			{
			   DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create outbound converter hr=0x%x", hr );
			   DNASSERT( FALSE );
			}
		}

		// Create inbound converter if required
		if( !pTmpPlayer->IsInBoundConverterInitialized() )
		{
			hr = pTmpPlayer->CreateInBoundConverter( m_dvSessionDesc.guidCT, s_lpwfxMixerFormat );

			if( FAILED( hr ) )
			{
			   DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create converter" );
			   DNASSERT( FALSE );
			}			
		}
		
		pTmpPlayer->UnLock();
	}

    DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL,  "SST: 2" );

    // Pass 2.
    //
    // For each player:
    // 1. Figure out who they hear.
    // 2. TODO: If they hear anyone, add them to the "to send to" list of people
    // 3. TODO: If they hear > 1, add the people they hear to the "to decompress" list of people.  
    // 4. Setup the appropriate sequence # / msg # for the transmission
    //
	pblSearch = m_prWorkerControl[lThreadIndex].m_blMixingActivePlayers.next;

	while( pblSearch != &m_prWorkerControl[lThreadIndex].m_blMixingActivePlayers )
	{
		pCurrentPlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[lThreadIndex] );

        DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "0x%x Can hear: ", pCurrentPlayer->GetPlayerID() );

		pblSearch = pblSearch->next;

		pblSubSearch = m_prWorkerControl[lThreadIndex].m_blMixingActivePlayers.next;

		// Search the list of people in the session
		while( pblSubSearch != &m_prWorkerControl[lThreadIndex].m_blMixingActivePlayers )
		{
			pComparePlayer = CONVERTTORECORD( pblSubSearch, CDVCSPlayer, m_pblMixingActivePlayers[lThreadIndex] );

			pblSubSearch = pblSubSearch->next;

			// This record contains a silent record -- ignore 
			if( pComparePlayer->m_pfSilence[lThreadIndex] )
				continue;

			// If this isn't the player themselves 
			if( pblSearch != pblSubSearch )
			{
				DNASSERT( pComparePlayer->m_pSourceFrame[lThreadIndex] );
				pdvidTargets = pComparePlayer->m_pSourceFrame[lThreadIndex]->GetTargetList();
				dwNumTargets = pComparePlayer->m_pSourceFrame[lThreadIndex]->GetNumTargets();

				// The target of the subIndex user's frame is this user OR
				// The user is in the group which is target of subIndex user's frame

				for( dwTargetIndex = 0; dwTargetIndex < dwNumTargets; dwTargetIndex++ )
				{
					if( pCurrentPlayer->GetPlayerID() == pdvidTargets[dwTargetIndex] ||
					    m_lpSessionTransport->IsPlayerInGroup( pdvidTargets[dwTargetIndex], pCurrentPlayer->GetPlayerID() ) )
					{
						*((*(pCurrentPlayer->m_pppCanHear+lThreadIndex))+pCurrentPlayer->m_pdwHearCount[lThreadIndex]) = pComparePlayer;
						pCurrentPlayer->m_pdwHearCount[lThreadIndex]++;
						DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "0x%x", pComparePlayer->GetPlayerID() );

						// Setup the appropriate msg num / sequence number so when it's sent
						// we ensure it gets re-assembled on the other side in the right order
						if( pCurrentPlayer->m_pdwHearCount[lThreadIndex] == 1 )
						{
				            if( pCurrentPlayer->m_bLastSent == FALSE )
				            {
				                pCurrentPlayer->m_bMsgNum++;
				                pCurrentPlayer->m_bSeqNum = 0;
				                pCurrentPlayer->m_bLastSent = TRUE;
				            }
				            else
				            {
				            	pCurrentPlayer->m_bSeqNum++;
				            }

				            pCurrentPlayer->m_pbMsgNumToSend[lThreadIndex] = pCurrentPlayer->m_bMsgNum;
				            pCurrentPlayer->m_pbSeqNumToSend[lThreadIndex] = pCurrentPlayer->m_bSeqNum;

				            pCurrentPlayer->AddToHearingList( lThreadIndex, &m_prWorkerControl[lThreadIndex].m_blMixingHearingPlayers );
						}
						// We can hear > 1 person, we need to mark each person as needing decompression
						else if( pCurrentPlayer->m_pdwHearCount[lThreadIndex] > 1 )
						{
							if( !pComparePlayer->m_pfNeedsDecompression[lThreadIndex] )
							{
								// Add this player to the list of people who need to be decompressed
								pComparePlayer->AddToSpeakingList( lThreadIndex, &m_prWorkerControl[lThreadIndex].m_blMixingSpeakingPlayers );								
								pComparePlayer->m_pfNeedsDecompression[lThreadIndex] = TRUE;
							}

							// Special case, we just transitioned to having > 1 people heard by this player,
							// we should mark the first person we can hear for decompression as well
							if( pCurrentPlayer->m_pdwHearCount[lThreadIndex] == 2 )
							{
								pTmpPlayer = (pCurrentPlayer->m_pppCanHear[lThreadIndex])[0];

								if( !pTmpPlayer->m_pfNeedsDecompression[lThreadIndex] )
								{
									pTmpPlayer->AddToSpeakingList( lThreadIndex, &m_prWorkerControl[lThreadIndex].m_blMixingSpeakingPlayers );								
									pTmpPlayer->m_pfNeedsDecompression[lThreadIndex] = TRUE;
								}
							}
						}

						// We need to break out of the loop as we only need to add an individual player once to the 
						// list of people a player can hear.  
						break;
					}
				}
			}

		}	

		if( !pCurrentPlayer->m_pdwHearCount[lThreadIndex] )
		{
			pCurrentPlayer->m_bLastSent = FALSE;
		}
		else
		{
			pCurrentPlayer->m_bLastSent = TRUE;
		}
	}

	m_pStats->m_dwPreMixingPassTimeHistoryLoc++;
	m_pStats->m_dwPreMixingPassTimeHistoryLoc %= MIXING_HISTORY;
	m_pStats->m_dwPreMixingPassTimeHistory[m_pStats->m_dwPreMixingPassTimeHistoryLoc] = GetTickCount() - dwTickCountStart;

	SetEvent( m_prWorkerControl[lThreadIndex].hThreadDoWork );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::MixingServerWakeupProc"
// MixingServerWakeupProc
//
// This function is called by the windows timer used by this 
// class each time the timer goes off.  The function signals
// a semaphore provided by the creator of the timer. 
//
// Parameters:
// DWORD param - A recast pointer to a HANDLE
BOOL CDirectVoiceServerEngine::MixingServerWakeupProc( DWORD_PTR param )
{
    HANDLE *semaphore = (HANDLE *) param;

    ReleaseSemaphore( *semaphore, 1, NULL );

    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::HandleMixingReceive"
HRESULT CDirectVoiceServerEngine::HandleMixingReceive( CDVCSPlayer *pTargetPlayer, PDVPROTOCOLMSG_SPEECHWITHTARGET pdvSpeechWithtarget, DWORD dwSpeechSize, PBYTE pSourceSpeech )
{
	HRESULT hr;
	
	DPFX(DPFPREP,  DVF_MIXER_DEBUG_LEVEL, "Mixing Server Speech Handler" );

	hr = pTargetPlayer->HandleMixingReceive( &pdvSpeechWithtarget->dvHeader, pSourceSpeech, dwSpeechSize, (PDVID) &pdvSpeechWithtarget[1], pdvSpeechWithtarget->dwNumTargets );

	DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Receive: Msg [%d] Seq [%d]", pdvSpeechWithtarget->dvHeader.bMsgNum, pdvSpeechWithtarget->dvHeader.bSeqNum );		

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::UpdateActiveMixingPendingList"
void CDirectVoiceServerEngine::UpdateActiveMixingPendingList( DWORD dwThreadIndex, DWORD *pdwNumActive)
{
	BILINK *pblSearch;
	CDVCSPlayer *pVoicePlayer;

	DNEnterCriticalSection( &m_prWorkerControl[dwThreadIndex].m_csMixingAddList );

	// Add players who are pending
	pblSearch = m_prWorkerControl[dwThreadIndex].m_blMixingAddPlayers.next;

	while( pblSearch != &m_prWorkerControl[dwThreadIndex].m_blMixingAddPlayers )
	{
		pVoicePlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[dwThreadIndex] );

		pVoicePlayer->RemoveFromMixingList(dwThreadIndex);
		pVoicePlayer->AddToMixingList( dwThreadIndex, &m_prWorkerControl[dwThreadIndex].m_blMixingActivePlayers );

		pblSearch = m_prWorkerControl[dwThreadIndex].m_blMixingAddPlayers.next;
	}

	DNASSERT( (IsEmpty( m_prWorkerControl[dwThreadIndex].m_blMixingAddPlayers) ) );	

	DNLeaveCriticalSection( &m_prWorkerControl[dwThreadIndex].m_csMixingAddList );

	*pdwNumActive = 0;

	// Remove players who have disconnected
	pblSearch = m_prWorkerControl[dwThreadIndex].m_blMixingActivePlayers.next;

	while( pblSearch != &m_prWorkerControl[dwThreadIndex].m_blMixingActivePlayers )
	{
		pVoicePlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[dwThreadIndex] );

		pblSearch = pblSearch->next;

		// If current player has disconnected, remove them from active list
		// and release the reference the list has
		if( pVoicePlayer->IsDisconnected() )
		{
			pVoicePlayer->RemoveFromMixingList(dwThreadIndex);
			pVoicePlayer->Release();
		}
		else
		{
			(*pdwNumActive)++;
		}
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceClientEngine::CleanupMixingList"
void CDirectVoiceServerEngine::CleanupMixingList()
{
	BILINK *pblSearch;
	CDVCSPlayer *pVoicePlayer;

	for( DWORD dwIndex = 0; dwIndex < m_dwNumMixingThreads; dwIndex++ )
	{
		DNEnterCriticalSection( &m_prWorkerControl[dwIndex].m_csMixingAddList );

		// Add players who are pending
		pblSearch = m_prWorkerControl[dwIndex].m_blMixingAddPlayers.next;

		while( pblSearch != &m_prWorkerControl[dwIndex].m_blMixingAddPlayers )
		{
			pVoicePlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[dwIndex] );

			pblSearch = pblSearch->next;

			pVoicePlayer->RemoveFromMixingList(dwIndex);
			pVoicePlayer->Release();
		}

		DNLeaveCriticalSection( &m_prWorkerControl[dwIndex].m_csMixingAddList );

		DNASSERT( (IsEmpty(m_prWorkerControl[dwIndex].m_blMixingAddPlayers )) );
		
		pblSearch = m_prWorkerControl[dwIndex].m_blMixingActivePlayers.next;

		while( pblSearch != &m_prWorkerControl[dwIndex].m_blMixingActivePlayers )
		{
			pVoicePlayer = CONVERTTORECORD( pblSearch, CDVCSPlayer, m_pblMixingActivePlayers[dwIndex] );

			pblSearch = pblSearch->next;

			pVoicePlayer->RemoveFromMixingList(dwIndex);
			pVoicePlayer->Release();
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\mixutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MixerUtils.cpp
 *  Content:	Utility functions for mixing audio 
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/06/99	rodtoll	Created It
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#define DPV_MAX_SHORT   ((SHORT)32767)
#define DPV_MIN_SHORT   ((SHORT)-32768)

#define DPV_MAX_BYTE    127
#define DPV_MIN_BYTE    0

// "Mixer Buffer"
//
// Throughout this module we refer to a "mixer buffer".  A mixer buffer is a 
// buffer of higher resolution then a traditional audio buffer which is used
// for mixing audio.  In the case of this module a mixer buffer promotes 
// each sample to a DWORD.  So audio is mixed in a "mixer buffer" and then
// converted back to the approrpriate sample size.

#undef DPF_MODNAME
#define DPF_MODNAME "FillBufferWithSilence"
// FillBufferWithSilence
//
// This function fills a mixer buffer with the appropriate bytes to make it
// equivalent to silence.  
//
// Parameters:
// LONG *buffer -
//		Pointer to the mixer buffer which will be filled with silence.
// BOOL eightBit -
//		Is the audio we're mixing 8 bit?  (Set to TRUE for 8 bit)
// LONG frameSize -
//		The number of samples the mixer buffer consists of.  
//
// Returns:
// N/A
//
void FillBufferWithSilence( LONG *buffer, BOOL eightBit, LONG frameSize )
{
    LONG mixerSize = frameSize;

	// If we're working with 16 bit then the number of samples is half the 
	// number of bytes in a frame.
    if( !eightBit )
    {
        mixerSize >>= 1;
    }

    BYTE silenceByte = (eightBit) ? 0x80 : 0x00;

	// Set the mixer buffer to silence
    memset( buffer, silenceByte, mixerSize << 2 );
}

#undef DPF_MODNAME
#define DPF_MODNAME "MixIn8BitBuffer"
// MixIn8BitBuffer
//
// This function mixes an 8-bit buffer with an existing mixer buffer.  
//
// Parameters:
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// BYTE *sourceBuffer -
//		Pointer to the buffer which will be mixed into the mixer buffer
// LONG frameSize -
//		The size, in bytes of the source Buffer.  (Also = # of samples)
//
// Returns:
// N/A
//
void MixIn8BitBuffer( LONG *mixerBuffer, BYTE *sourceBuffer, LONG frameSize )
{
    LONG mixerSize = frameSize;

    for( int index = 0; index < mixerSize; index++ )
    {
        mixerBuffer[index] += sourceBuffer[index];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MixIn16BitBuffer"
// MixIn16BitBuffer
//
// This function mixes a 16-bit buffer with an existing mixer buffer.  
//
// Parameters:
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// SHORT *sourceBuffer -
//		Pointer to the buffer which will be mixed into the mixer buffer
// LONG frameSize -
//		The size, in bytes of the source Buffer.  (Since the sourceBuffer
//		is 16 bit, the number of samples is # of bytes / 2).
//
// Returns:
// N/A
//
void MixIn16BitBuffer( LONG *mixerBuffer, SHORT *sourceBuffer, LONG frameSize )
{
    LONG mixerSize = frameSize >> 1;

    for( int index = 0; index < mixerSize; index++ )
    {
        mixerBuffer[index] += sourceBuffer[index];
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "MixInBuffer"
// MixInBitBuffer
//
// This function mixes an 8 or 16-bit buffer with an existing mixer buffer.  
//
// Parameters:
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// BYTE *sourceBuffer -
//		Pointer to the buffer which will be mixed into the mixer buffer
// LONG frameSize -
//		The size, in bytes of the source Buffer.  
//
// Returns:
// N/A
//
void MixInBuffer( LONG *mixerBuffer, BYTE *sourceBuffer, BOOL eightBit, LONG frameSize )
{
    if( eightBit )
    {
        MixIn8BitBuffer( mixerBuffer, sourceBuffer, frameSize );
    }
    else
    {
        MixIn16BitBuffer( mixerBuffer, (SHORT *) sourceBuffer, frameSize );
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Normalize16BitBuffer"
// Normalize16BitBuffer
//
// This function takes the "mixer buffer" and transfers the result of
// the mix back to a 16-bit audio buffer.
//
// Parameters:
// SHORT *targetBuffer -
//		Pointer to the buffer which where the mixed audio will be placed
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// LONG frameSize -
//		The size, in bytes of the target buffer.  
//
// Returns:
// N/A
//
void Normalize16BitBuffer( SHORT *targetBuffer, LONG *mixerBuffer, LONG frameSize )
{
    LONG mixerSize = frameSize >> 1;

    for( int index = 0; index < mixerSize; index++ )
    {
        // Clip mixed audio, ensure it does not exceed range
        if( mixerBuffer[index] >= DPV_MAX_SHORT )
            targetBuffer[index] = DPV_MAX_SHORT;
        else if( mixerBuffer[index] <= DPV_MIN_SHORT )
            targetBuffer[index] = DPV_MIN_SHORT;
        else
            targetBuffer[index] = (SHORT) mixerBuffer[index]; // / noiseCount;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Normalize8BitBuffer"
// Normalize8BitBuffer
//
// This function takes the "mixer buffer" and transfers the result of
// the mix back to an 8-bit audio buffer.
//
// Parameters:
// BYTE *targetBuffer -
//		Pointer to the buffer which where the mixed audio will be placed
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// LONG frameSize -
//		The size, in bytes of the target buffer.  
//
// Returns:
// N/A
//
void Normalize8BitBuffer( BYTE *targetBuffer, LONG *mixerBuffer, LONG frameSize )
{
    LONG mixerSize = frameSize;

    for( int index = 0; index < mixerSize; index++ )
    {
        targetBuffer[index] = (BYTE) mixerBuffer[index]; /// noiseCount;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "NormalizeBuffer"
// NormalizeBuffer
//
// This function takes the "mixer buffer" and transfers the result of
// the mix back to an 8-bit or 160bit audio buffer.
//
// Parameters:
// BYTE *targetBuffer -
//		Pointer to the buffer which where the mixed audio will be placed
// LONG *mixerBuffer -
//		Pointer to the mixer buffer
// BOOL eightBit -
//		If the buffer is 8-bit, set this to TRUE, set to FALSE for 16-bit
// LONG frameSize -
//		The size, in bytes of the target buffer.  
//
// Returns:
// N/A
//
void NormalizeBuffer( BYTE *targetBuffer, LONG *mixerBuffer, BOOL eightBit, LONG frameSize )
{
    if( eightBit )
    {
        Normalize8BitBuffer( targetBuffer, mixerBuffer, frameSize );
    }
    else
    {
        Normalize16BitBuffer( (SHORT *) targetBuffer, mixerBuffer, frameSize );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\mixutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		MixerUtils.h
 *  Content:	Base class for dp/dnet abstraction
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/06/99		rodtoll	Utility functions for mixing audio 
 *
 ***************************************************************************/

#ifndef __MIXERUTILS_H
#define __MIXERUTILS_H

void FillBufferWithSilence( LONG *buffer, BOOL eightBit, LONG frameSize );
void MixInBuffer( LONG *mixerBuffer, BYTE *sourceBuffer, BOOL eightBit, LONG frameSize );
void NormalizeBuffer( BYTE *targetBuffer, LONG *mixerBuffer, BOOL eightBit, LONG frameSize );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\protserver.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fwdserver.cpp
 *  Content:	Implements the forwarding server portion of the server class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/01/2000	rodtoll	Split out from dvsereng.cpp
 *
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_CreatePlayer"
HRESULT CDirectVoiceServerEngine::Send_CreatePlayer( DVID dvidTarget, CVoicePlayer *pPlayer )
{
    PDVPROTOCOLMSG_PLAYERJOIN pdvPlayerJoin;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_PLAYERJOIN ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvPlayerJoin = (PDVPROTOCOLMSG_PLAYERJOIN) pBufferDesc->pBufferData;

    pdvPlayerJoin->dwType = DVMSGID_CREATEVOICEPLAYER;
    pdvPlayerJoin->dvidID = pPlayer->GetPlayerID();
    pdvPlayerJoin->dwFlags = pPlayer->GetTransportFlags();
    pdvPlayerJoin->dwHostOrderID = pPlayer->GetHostOrder();

    hr = m_lpSessionTransport->SendToIDS( &dvidTarget, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending create player to 0x%x hr=0x%x", dvidTarget, hr );
    }

    return hr;    
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_ConnectRefuse"
HRESULT CDirectVoiceServerEngine::Send_ConnectRefuse( DVID dvidID, HRESULT hrReason )
{
    PDVPROTOCOLMSG_CONNECTREFUSE pdvConnectRefuse;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_CONNECTREFUSE ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvConnectRefuse = (PDVPROTOCOLMSG_CONNECTREFUSE) pBufferDesc->pBufferData;

	pdvConnectRefuse->dwType = DVMSGID_CONNECTREFUSE;
	pdvConnectRefuse->hresResult = hrReason;
	pdvConnectRefuse->ucVersionMajor = DVPROTOCOL_VERSION_MAJOR;
	pdvConnectRefuse->ucVersionMinor = DVPROTOCOL_VERSION_MINOR;
	pdvConnectRefuse->dwVersionBuild = DVPROTOCOL_VERSION_BUILD;    

    hr = m_lpSessionTransport->SendToIDS( &dvidID, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending disconnect confirm migrated to all hr=0x%x", hr );
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_DisconnectConfirm"
HRESULT CDirectVoiceServerEngine::Send_DisconnectConfirm( DVID dvidID, HRESULT hrReason )
{
    PDVPROTOCOLMSG_DISCONNECT pdvDisconnectConfirm;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_DISCONNECT ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvDisconnectConfirm = (PDVPROTOCOLMSG_DISCONNECT) pBufferDesc->pBufferData;

    pdvDisconnectConfirm->dwType = DVMSGID_DISCONNECTCONFIRM;
    pdvDisconnectConfirm->hresDisconnect = hrReason;

    hr = m_lpSessionTransport->SendToIDS( &dvidID, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending disconnect confirm migrated to all hr=0x%x", hr );
    }

    return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_ConnectAccept"
HRESULT CDirectVoiceServerEngine::Send_ConnectAccept( DVID dvidID )
{
    PDVPROTOCOLMSG_CONNECTACCEPT pdvConnectAccept;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_CONNECTACCEPT ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvConnectAccept = (PDVPROTOCOLMSG_CONNECTACCEPT) pBufferDesc->pBufferData;

	pdvConnectAccept->dwType = DVMSGID_CONNECTACCEPT;
	pdvConnectAccept->dwSessionFlags = m_dvSessionDesc.dwFlags;
	pdvConnectAccept->dwSessionType = m_dvSessionDesc.dwSessionType;
	pdvConnectAccept->ucVersionMajor = DVPROTOCOL_VERSION_MAJOR;
	pdvConnectAccept->ucVersionMinor = DVPROTOCOL_VERSION_MINOR;
	pdvConnectAccept->dwVersionBuild = DVPROTOCOL_VERSION_BUILD;
	pdvConnectAccept->guidCT = m_dvSessionDesc.guidCT;

    hr = m_lpSessionTransport->SendToIDS( &dvidID, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending connect accept to player hr=0x%x", hr );
    }

    return hr;
}



#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_DeletePlayer"
HRESULT CDirectVoiceServerEngine::Send_DeletePlayer( DVID dvidID )
{
    PDVPROTOCOLMSG_PLAYERQUIT pdvPlayerQuit;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_PLAYERQUIT ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvPlayerQuit = (PDVPROTOCOLMSG_PLAYERQUIT) pBufferDesc->pBufferData;

    pdvPlayerQuit->dwType = DVMSGID_DELETEVOICEPLAYER;
    pdvPlayerQuit->dvidID = dvidID;

    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending delete player migrated to all hr=0x%x", hr );
		ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}
		
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_SessionLost"
HRESULT CDirectVoiceServerEngine::Send_SessionLost( HRESULT hrReason )
{
    PDVPROTOCOLMSG_SESSIONLOST pdvSessionLost;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_SESSIONLOST ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvSessionLost = (PDVPROTOCOLMSG_SESSIONLOST) pBufferDesc->pBufferData;

    pdvSessionLost->dwType = DVMSGID_SESSIONLOST;
    pdvSessionLost->hresReason = hrReason;

    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED | DVTRANSPORT_SEND_SYNC );

    if( FAILED( hr ) )
    {
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending session lost to all hr=0x%x", hr );
    }
        
	ReturnTransmitBuffer( pvSendContext );        

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_HostMigrateLeave"
HRESULT CDirectVoiceServerEngine::Send_HostMigrateLeave( )
{
    PDVPROTOCOLMSG_HOSTMIGRATELEAVE pdvHostMigrateLeave;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_HOSTMIGRATELEAVE ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pdvHostMigrateLeave = (PDVPROTOCOLMSG_HOSTMIGRATELEAVE) pBufferDesc->pBufferData;

    pdvHostMigrateLeave->dwType = DVMSGID_HOSTMIGRATELEAVE;

	// Send this message with sync.  Sync messages do not generate callbacks
	//
    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED | DVTRANSPORT_SEND_SYNC );

	if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending host migrated to all hr=0x%x", hr );
    }

	ReturnTransmitBuffer( pvSendContext );        

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::Send_HostMigrated"
HRESULT CDirectVoiceServerEngine::Send_HostMigrated()
{
    PDVPROTOCOLMSG_HOSTMIGRATED pvMigrated;
    PDVTRANSPORT_BUFFERDESC pBufferDesc;
    PVOID pvSendContext;
    HRESULT hr;

    pBufferDesc = GetTransmitBuffer( sizeof( DVPROTOCOLMSG_HOSTMIGRATED ), &pvSendContext );

    if( pBufferDesc == NULL )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc error" );
        return DVERR_OUTOFMEMORY;
    }

    pvMigrated = (PDVPROTOCOLMSG_HOSTMIGRATED) pBufferDesc->pBufferData;

    pvMigrated->dwType = DVMSGID_HOSTMIGRATED;

    hr = m_lpSessionTransport->SendToAll( pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );

    if( hr == DVERR_PENDING )
    {
        hr = DV_OK;
    }
    else if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error sending host migrated to all hr=0x%x", hr );
		ReturnTransmitBuffer( pvSendContext );        
    }

    return hr;
}

BOOL CDirectVoiceServerEngine::CheckProtocolCompatible( BYTE ucMajor, BYTE ucMinor, DWORD dwBuild ) 
{
	/*
	if( ucMajor != DVPROTOCOL_VERSION_MAJOR ||
	    ucMinor != DVPROTOCOL_VERSION_MINOR ||
	    dwBuild != DVPROTOCOL_VERSION_BUILD )
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}*/
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectVoiceServerEngine::SendPlayerList"
//
// SendPlayerList
//
// This function sends a bunch of DVMSGID_PLAYERLIST messages to the 
// client containing the list of current players.
//
// This will send multiple structues if the number 
// 
HRESULT CDirectVoiceServerEngine::SendPlayerList( DVID dvidSource, DWORD dwHostOrderID )
{
	BOOL bContinueEnum = FALSE;
	CVoicePlayer *lpPlayer;		
	BILINK *pblSearch;

	HRESULT hr = DV_OK;

	BOOL  fAtLeastOneSent = FALSE;
	DWORD dwCurrentBufferLoc;
	DWORD dwNumInCurrentPacket;
	PDVTRANSPORT_BUFFERDESC pBufferDesc;
	PDVPROTOCOLMSG_PLAYERLIST lpdvPlayerList;
	DVPROTOCOLMSG_PLAYERLIST_ENTRY *pdvPlayerEntries;
	PVOID pvSendContext;
	
	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Building player list" );

	pBufferDesc = GetTransmitBuffer(DVPROTOCOL_PLAYERLIST_MAXSIZE, &pvSendContext);

	if( pBufferDesc == NULL )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory!" );
	    return DVERR_OUTOFMEMORY;
	}

	lpdvPlayerList = (PDVPROTOCOLMSG_PLAYERLIST) pBufferDesc->pBufferData;

	pdvPlayerEntries = (DVPROTOCOLMSG_PLAYERLIST_ENTRY *) &lpdvPlayerList[1];

	lpdvPlayerList->dwType = DVMSGID_PLAYERLIST;
	lpdvPlayerList->dwHostOrderID = dwHostOrderID;	
	
	dwNumInCurrentPacket = 0;
	dwCurrentBufferLoc = sizeof(DVPROTOCOLMSG_PLAYERLIST); 

	DNEnterCriticalSection( &m_csPlayerActiveList );

	pblSearch = m_blPlayerActiveList.next;

	while( pblSearch != &m_blPlayerActiveList )
	{
		lpPlayer = CONTAINING_RECORD( pblSearch, CVoicePlayer, m_blNotifyList );

		// We need to split the packet, start a new packet, transmit this one.
		if( (dwCurrentBufferLoc+sizeof(DVPROTOCOLMSG_PLAYERLIST_ENTRY)) > DVPROTOCOL_PLAYERLIST_MAXSIZE )
		{
			// Wrap up current packet and transmit
			lpdvPlayerList->dwNumEntries = dwNumInCurrentPacket;

			pBufferDesc->dwBufferSize = dwCurrentBufferLoc;
			
			hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1,pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );				

            if( hr == DVERR_PENDING )
            {
                hr = DV_OK;
            }
            else if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Error on internal send hr=0x%x (Didn't get playerlist)", hr );
				return hr;
			}				

			// Reset for further players

			DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Transmitting playerlist chunk %d players", dwNumInCurrentPacket );

        	pBufferDesc = GetTransmitBuffer(DVPROTOCOL_PLAYERLIST_MAXSIZE, &pvSendContext);

        	if( pBufferDesc == NULL )
        	{
        	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory!" );
        	    return DVERR_OUTOFMEMORY;
        	}

        	lpdvPlayerList = (PDVPROTOCOLMSG_PLAYERLIST) pBufferDesc->pBufferData;
        	pdvPlayerEntries = (DVPROTOCOLMSG_PLAYERLIST_ENTRY *) &lpdvPlayerList[1];
        	lpdvPlayerList->dwType = DVMSGID_PLAYERLIST;
        	lpdvPlayerList->dwHostOrderID = dwHostOrderID;	
        	dwCurrentBufferLoc = sizeof(DVPROTOCOLMSG_PLAYERLIST);         	
        	dwNumInCurrentPacket = 0;
			fAtLeastOneSent = TRUE;
		}

		pdvPlayerEntries[dwNumInCurrentPacket].dvidID = lpPlayer->GetPlayerID();
		pdvPlayerEntries[dwNumInCurrentPacket].dwPlayerFlags = lpPlayer->GetTransportFlags();
		pdvPlayerEntries[dwNumInCurrentPacket].dwHostOrderID = lpPlayer->GetHostOrder();

		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Adding player ID 0x%x", lpPlayer->GetPlayerID() );		

		dwNumInCurrentPacket++;
		dwCurrentBufferLoc += sizeof(DVPROTOCOLMSG_PLAYERLIST_ENTRY);

		DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Got next player" );					

		pblSearch = pblSearch->next;
	}

	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Build Complete" );	

	DNLeaveCriticalSection( &m_csPlayerActiveList );

	DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "PlayerList: Total of %d entries", dwNumInCurrentPacket );

	// Remaining entries to be sent
	// 
	// (Or empty packet just so user gets their ID)
	// 
	if( !fAtLeastOneSent  )
	{
		// Wrap up current packet and transmit
		lpdvPlayerList->dwNumEntries = dwNumInCurrentPacket;

		pBufferDesc->dwBufferSize = dwCurrentBufferLoc;		
				
		hr = m_lpSessionTransport->SendToIDS( &dvidSource, 1, pBufferDesc, pvSendContext, DVTRANSPORT_SEND_GUARANTEED );					

        if( hr == DVERR_PENDING || hr == DV_OK )
        {
			DPFX(DPFPREP,  DVF_PLAYERMANAGE_DEBUG_LEVEL, "Playerlist sent" );
        }
        else
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error on internal send hr=0x%x (Didn't get playerlist)", hr );
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\statdef.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		statdef.h
 *  Content:	Definition of stat structures for voice instrumentation
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 ***************************************************************************/

#ifndef __STATDEF_H
#define __STATDEF_H

#define MAX_MIXING_THREADS		16

#define MIXING_HISTORY			20

struct ServerStats 
{
	DVSESSIONDESC	m_dvSessionDesc;
	DWORD			m_dwBufferDescAllocated;
	DWORD			m_dwBufferDescOustanding;
	DWORD			m_dwPacketsAllocated[3];
	DWORD			m_dwPacketsOutstanding[3];
};

struct MixingServerStats
{
	LONG		m_dwNumMixingThreads;	// # of mixing threads on this server
	LONG		m_dwNumMixingThreadsActive;
										// # of mixing threads currently active
	LONG		m_dwPreMixingPassTimeHistoryLoc;
	LONG		m_dwPreMixingPassTimeHistory[MIXING_HISTORY];										
	LONG		m_dwMaxMixingThreadsActive;
										// Maximum # of mixing threads running at once
	LONG		m_dwNumMixingPasses;	// # of times the mixing server has run
	LONG		m_dwNumMixingPassesPerThread[MAX_MIXING_THREADS];
										// # of times each thread has been run
	LONG		m_dwCurrentMixingHistoryLoc[MAX_MIXING_THREADS];
	LONG 		m_dwMixingPassesTimeHistory[MAX_MIXING_THREADS][MIXING_HISTORY]; 
										// # of ms each thread took during it's last 20 runs

	LONG		m_lCurrentPlayerCount[MAX_MIXING_THREADS][MIXING_HISTORY];
	LONG		m_lCurrentDupTimeHistory[MAX_MIXING_THREADS][MIXING_HISTORY];
	LONG		m_lCurrentDecTimeHistory[MAX_MIXING_THREADS][MIXING_HISTORY];
	LONG		m_lCurrentMixTimeHistory[MAX_MIXING_THREADS][MIXING_HISTORY];	
	LONG		m_lCurrentRetTimeHistory[MAX_MIXING_THREADS][MIXING_HISTORY];	
	LONG		m_lCurrentDecCountHistory[MAX_MIXING_THREADS][MIXING_HISTORY];
	LONG		m_lCurrentMixCountTotalHistory[MAX_MIXING_THREADS][MIXING_HISTORY];	
	LONG		m_lCurrentMixCountFwdHistory[MAX_MIXING_THREADS][MIXING_HISTORY];	
	LONG		m_lCurrentMixCountReuseHistory[MAX_MIXING_THREADS][MIXING_HISTORY];	
	LONG		m_lCurrentMixCountOriginalHistory[MAX_MIXING_THREADS][MIXING_HISTORY];	

};

// ReceiveStats
//
// Statistics for receive
//
struct ReceiveStats
{
	DWORD		m_dwNumPackets;
	DWORD		m_dwNumBytes;
	DWORD		m_dwReceiveErrors;
};

// RecordStats
//
// Statistics for recording buffers
//
struct RecordStats
{
	DWORD		m_dwNumWakeups;			// # of wakeup
	DWORD		m_dwRPWMax;				// Runs / wakeup Max
	DWORD		m_dwRPWMin;				// Runs / wakeup Min
	DWORD		m_dwRPWTotal;			// Runs / wakeup total
	DWORD		m_dwNumMessages;		// # of messages sent
	DWORD		m_dwRRMax;				// # of record resets Max
	DWORD		m_dwRRMin;				// # of record resets Min
	DWORD		m_dwRRTotal;			// # of record resets Total
	DWORD		m_dwRTSLMMax;			// # of ms since last movement (Max)
	DWORD		m_dwRTSLMMin;			// # of ms since last movement (Min)
	DWORD		m_dwRTSLMTotal;  		// # of ms since last movement (Total)
	DWORD		m_dwRMMSMax;			// Record movemenet (ms) Max
	DWORD		m_dwRMMSMin;			// Record movement (ms) Min
	DWORD		m_dwRMMSTotal;			// Record movement (ms) Total
	DWORD		m_dwRMBMax;				// Record movement (bytes) Max
	DWORD		m_dwRMBMin;				// Record movement (bytes) Min
	DWORD		m_dwRMBTotal;			// Record movement (bytes) Total
	DWORD		m_dwRLMax;				// Record lag (bytes) Max
	DWORD		m_dwRLMin;				// Record lag (bytes) Min
	DWORD		m_dwRLTotal;			// Record lag (bytes) Total
	DWORD		m_dwHSTotal;			// Size of header (bytes) Total
	DWORD		m_dwHSMax;				// Size of header (bytes) Max
	DWORD		m_dwHSMin;				// Size of header (bytes) Min
	DWORD		m_dwSentFrames;			// # of frames sent
	DWORD  		m_dwIgnoredFrames;		// # of frames ignored
	DWORD		m_dwCSMin;				// Min Size (bytes) compressed frame
	DWORD		m_dwCSMax;				// Max size (bytes) compressed frame
	DWORD		m_dwCSTotal;			// Total size (bytes) of compressed data
	DWORD		m_dwUnCompressedSize;	// Size of a frame uncompressed
	DWORD		m_dwFramesPerBuffer;  // # of frames per buffer
	DWORD		m_dwFrameTime;			// Time for a frame
	DWORD		m_dwSilenceTimeout;		// Silence timeout
	DWORD		m_dwTimeStart;			// Time subsystem started
	DWORD		m_dwTimeStop;			// Time subsystem stopped
	DWORD		m_dwStartLag;			// Lag between Rec & SubSys Start
	DWORD		m_dwMLMax;				// Message length max
	DWORD		m_dwMLMin;				// Message length (min)
	DWORD		m_dwMLTotal;			// Message length (total)
	DWORD		m_dwCTMax;			// Time to compress a frame (Max)
	DWORD		m_dwCTMin;			// Time to compress a frame (Min)
	DWORD		m_dwCTTotal;			// Time to compress a frame (Total)
};

// PlaybackStats
//
// Statistics used to track statistics for playback buffers
//
struct PlaybackStats
{
	DWORD		m_dwNumRuns;			// # of runs this buffer had
	DWORD		m_dwPMMSMax;			// Play movement (ms) Max
	DWORD		m_dwPMMSMin;			// Play movement (ms) Min
	DWORD		m_dwPMMSTotal;			// Play movement (ms) Total
	DWORD		m_dwPMBMax;				// Play movement (bytes) Max
	DWORD		m_dwPMBMin;				// Play movement (bytes) Min
	DWORD		m_dwPMBTotal;			// Play movement (bytes) Total
	DWORD		m_dwPLMax;				// Play lead (bytes) Max
	DWORD		m_dwPLMin;				// Play lead (bytes) Min
	DWORD		m_dwPLTotal;			// Play lead (bytes) Total
	DWORD		m_dwPPunts;				// # of times pointer punted
	DWORD		m_dwPIgnore;			// # of ignored frames for wraparound
	DWORD		m_dwNumMixed;			// # of frames which were mixed
	DWORD		m_dwNumSilentMixed;		// # of frames mixed which were silence
	DWORD		m_dwTimeStart;			// GetTickCount at buffer playback
	DWORD		m_dwTimeStop;			// GetTickCount at buffer Stop
	DWORD		m_dwStartLag;			// Lag between play & subsys start
	DWORD		m_dwNumBL;				// # of lost buffer / restores
	DWORD		m_dwGlitches;			// # of glitches during playback
	DWORD		m_dwSIgnore;			// # of times ignored frame on silence write
	DWORD		m_dwFrameSize;			// Size of frame in bytes
	DWORD		m_dwBufferSize;			// Size of buffer
};

// TransmitSTats
// 
// Statistics for transmission 
//
struct TransmitStats
{
	DWORD		m_dwNumPackets;
	DWORD		m_dwNumBytes;
	DWORD		m_dwTransmitErrors;
};

struct ClientStatistics
{
	RecordStats		m_recStats;
	PlaybackStats 	m_playStats;
	ReceiveStats 	m_recvStats;
	TransmitStats 	m_tranStats;
	DWORD			m_dwMaxBuffers;		// Max # of playback buffers
	DWORD			m_dwTotalBuffers;	// Total # of playback buffers
	DWORD			m_dwTimeStart;		// GetTickCount when connect accepted
	DWORD			m_dwTimeStop;		// GetTickCount when cleanup completed
	DWORD			m_dwPPDQSilent;		// # of silent frames dequeued
	DWORD			m_dwPPDQLost;		// # of lost frames dequeued
	DWORD			m_dwPPDQSpeech;		// # of Speech frames dequeued
	DWORD			m_dwPDTMax;			// ms for decompress (max)
	DWORD			m_dwPDTMin;			// ms for decompress (min)
	DWORD			m_dwPDTTotal;		// ms for decompress (total)
	DWORD			m_dwPRESpeech;		// # of packets enqueued
	DWORD			m_dwBDPOutstanding;
	DWORD			m_dwBDPAllocated;
	DWORD			m_dwBPOutstanding[3];
	DWORD			m_dwBPAllocated[3];
	DWORD			m_dwNPOutstanding;
	DWORD			m_dwNPAllocated;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
//#define IDS_DO_NOT_USE					0
#define IDS_SYS_ERR_MSG_CAPTION         1
#define IDS_ERROR_MSG_CAPTION           1
#define IDS_PROP_SHEET_CAPTION          1
#define IDS_FDTEST_ERR_MSG_CAPTION      2
#define IDS_WARNING_MSG_CAPTION         2
#define IDS_E_UNKNOWN                   3
#define IDS_E_ALREADY_RUNNING           4
#define IDS_E_NOT_COMPLETE              5
#define IDS_E_PREVIOUS_TEST_CRASHED     6
#define IDS_E_ALLOC_FAILED              7
#define IDS_E_BAD_COMMAND_LINE          8
#define IDS_E_CHILD_NOT_TERMINATED      9
#define IDS_E_TIMEOUT                   10
#define IDS_S_EXIT                      11
#define IDS_E_UNKNOWN_IPC_TARGET        12
#define IDS_E_BUFFER_TOO_SMALL          13
#define IDS_E_UNKNOWN_COMMAND           14
#define IDS_E_FORMAT_NOT_SUPPORTED      15
#define IDS_E_LOCK_FAILED               16
#define IDS_E_DIRECTSOUND_FAILED        17
#define IDS_MSG_LOOPBACK_STARTING       18
#define IDS_MSG_LOOPBACK_RUNNING        19
#define IDS_MSG_LOOPBACK_STARTING_BUTTON 20
#define IDS_MSG_LOOPBACK_RUNNING_BUTTON 21
#define IDS_MSG_LOOPBACK_AUDIBLE        22
#define IDS_MSG_LOOPBACK_AUDIBLE_BUTTON 23
#define IDS_MSG_LOOPBACK_NOINPUT        24
#define IDD_PREVIOUS_TEST_CRASHED       101
#define IDD_PRIORITY_DIALOG             102
#define IDD_RETROFIT_CONFIG             102
#define IDD_LOOPBACK_DIALOG             104
#define IDD_LOOPBACKSTARTING_DIALOG     105
#define IDD_NOTIFY_USER_HALFDUPLEX      106
#define IDD_PROP_RETROFIT               106
#define IDD_HALFDUPLEXFAILED            106
#define IDD_WELCOME                     107
#define IDD_COMPLETE                    108
#define IDD_ALREADYRUNNING              109
#define IDD_PREVIOUSCRASH               110
#define IDD_FULLDUPLEXTEST              111
#define IDD_MICTEST                     112
#define IDD_MICTEST_FAILED              113
#define IDD_SPEAKER_TYPE                114
#define IDD_SPEAKER_TEST                115
#define IDD_COMPLETE_FAILED             116
#define IDD_FULLDUPLEXFAILED            116
#define IDD_PROPPAGE_LARGE              117
#define IDD_DIALOG1                     118
#define IDD_PROP_DEVICES                119
#define IDI_LIST_DEFAULT                120
#define IDD_WIZARD_CANCELED             121
#define IDD_PREVIOUS_CRASH              122
#define IDD_ALREADY_RUNNING             123
#define IDI_MIC                         124
#define IDI_SPEAKER                     125
#define IDB_WIZIMAGE                    126
#define IDS_ERROR_MSG					127
#define IDS_ERROR_CAPTION				128
#define IDS_ERROR_NODEVICES				129
#define IDC_PRIORITY_PROGRESS           1002
#define IDC_CUSTOM1                     1006
#define IDC_LOOPBACK_MSG                1007
#define IDC_PEAKMETER                   1008
#define IDC_MOREINFO                    1009
#define IDC_RECPEAKMETER                1009
#define IDC_WELCOME_TITLE               1012
#define IDC_WELCOME_P1                  1013
#define IDC_P1                          1013
#define IDC_WELCOME_P2                  1014
#define IDC_P2                          1014
#define IDC_WELCOME_P3                  1015
#define IDC_P3                          1015
#define IDC_WELCOME_IMAGE               1016
#define IDC_COMPLETE_TITLE              1017
#define IDC_COMPLETE_P1                 1018
#define IDC_COMPLETE_P2                 1019
#define IDC_COMPLETE_P3                 1020
#define IDC_COMPLETE_IMAGE              1021
#define IDC_TITLE                       1022
#define IDC_PROGRESSBAR                 1023
#define IDC_RADIO_EXTERNAL              1024
#define IDC_RADIO_HEADSET               1025
#define IDC_COMPLETE_FAILED_GRAPHIC     1026
#define IDC_P4                          1027
#define IDC_P6                     1028
#define IDC_P5                          1029
#define IDC_GAME_LISTBOX                1030
#define IDC_CONFIGURE                   1033
#define IDC_LIST_GAMES                  1034
#define IDC_COMBO1                      1036
#define IDC_COMBO2                      1037
#define IDC_VOICE_PLAYBACK              1038
#define IDC_VOICE_RECORDING             1039
#define IDC_STATIC_PREF_PLAY_DEV        1040
#define IDC_STATIC_PREF_REC_DEV         1041
#define IDC_TEST_DEVICES                1042
#define IDC_VOICE_DEVICES               1043
#define IDC_GROUP1                      1044
#define IDC_GROUP2                      1045
#define IDC_ICON_WARNING                1047
#define IDC_ICON_ERROR                  1048
#define IDC_RECVOL_SLIDER               1054
#define IDC_RECADVANCED                 1055
#define IDC_OUTVOL_SLIDER               1056
#define IDC_OUTPEAKMETER                1057
#define IDC_OUTADVANCED                 1058
#define IDC_OUTGROUP                    1059
#define IDC_WIZIMAGE                    1060
#define IDC_WARNINGICON                 1061
#define IDC_TEXT_PLAYBACK               1065
#define IDC_TEXT_RECORDING              1066
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1067
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\sources.inc ===
!INCLUDE ..\..\..\bldcfg\dpvbld.inc

#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#required or you get the cryptic error on Win95 gold : "Expects newer version of windows"
UMTYPE=windows

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=$(DPVOICE_BUILD_FILENAME_DPVOICE)
DLLDEF=..\$(DPVOICE_BUILD_FILENAME_DPVOICE).def

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dxvoicepch.h
PRECOMPILED_PCH=dxvoicepch.pch
PRECOMPILED_OBJ=dxvoicepch.obj
!endif

# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.DirectX.DirectPlayVoice
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=$(DPVOICE_BUILD_FILENAME_DPVOICE).Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
SXS_MANIFEST_RESOURCE_ID=123

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           ..\..\dxvutils\obj$(BUILD_ALT_DIR)\*\dxvutils.lib \
	   ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
           ..\..\..\dnet\common\obj$(BUILD_ALT_DIR)\*\common.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\msacm32.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
!if "$(CHICAGO_PRODUCT)" == ""
           ..\..\dxvtlib\daytona\obj$(BUILD_ALT_DIR)\*\dxvt.lib \
	   $(BASEDIR)\public\internal\shell\lib\*\shfusion.lib \
	   $(BASEDIR)\public\sdk\lib\*\shlwapi.lib \
!else
           ..\..\dxvtlib\win9x\obj$(BUILD_ALT_DIR)\*\dxvt.lib \
	   $(BASEDIR)\public\sdk\lib\*\comctl32.lib \
!endif
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib


   
#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc;..\..\..\dnet\common;..\..\inc;..\..\dxvutils;..\..\dxvtlib;$(DXROOT)\private\inc;$(BASEDIR)\public\internal\shell\inc;..\


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= ..\mixserver.cpp \
	..\fwdserver.cpp \
        ..\vplayer.cpp \
	..\dvengine.cpp \
	..\protserver.cpp \
	..\mixutils.cpp \
	..\dvcleng.cpp \
	..\dvclient.cpp \
	..\dvcsplay.cpp \
	..\dvdxtran.cpp \
	..\dvrecsub.cpp \
	..\dvsereng.cpp \
	..\dvserver.cpp \
	..\dvshared.cpp \
	..\dvsetup.cpp \
	..\dvsetupi.cpp \
	..\trnotify.cpp \
	..\dxvclassfac.cpp \
	..\in_core.cpp \
	..\unk.cpp \
	..\dvsndt.cpp \
	..\vnametbl.cpp \
	..\dxvdllmain.cpp \
	..\resource.rc 

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL \
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(CHICAGO_PRODUCT)" == ""
	/D_UNICODE /DUNICODE \
!endif
!if "$(VOICE_TARGET)" == "allegiance" 
	/DVOICE_BUILD_ALLEGIANCE \
!endif
           /DDIRECTVOICE_EXPORTS /DDIRECTSOUND_VERSION=0x0800


USE_NOLIBS=1

USE_NATIVE_EH=1

DLLENTRY=_DllMainCRTStartup

# This is necessary because we link to shfusion.lib which contains a reference to PropertySheetW which
# we make a call to.
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\unk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       unk.c
 *  Content:	IUnknown implementation
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 07/02/99 rodtoll Modified existing unk.c for use w/DirectXVoice
 * 07/26/99	rodtoll	Added the new IDirectXVoiceNotify Interfaces
 * 08/09/99 rodtoll	Fixed VTable for server notify interface
 * 08/25/99	rodtoll	General Cleanup/Modifications to support new 
 *					compression sub-system. 
 * 08/31/99	rodtoll	Updated to use new debug libs 
 * 09/02/99	pnewson	Added IDirectXVoiceSetup interface
 * 09/07/99	rodtoll	Added DPF_MODNAMEs to the module
 * 			rodtoll	Fixed vtable for server object
 * 09/10/99	rodtoll	Vtables from static to non-static so other modules can access
 * 09/13/99	pnewson added dplobby.h include so lobby GUIDs get created
 * 09/14/99	rodtoll	Modified VTable to add new SetNotifyMask func
 * 10/05/99	rodtoll	Added DPFs
 * 10/07/99	rodtoll	Updated to work in Unicode, Add Init of OS Abstraction Layer
 * 10/18/99	rodtoll	Fix: Passing NULL in QueryInterface casues crash
 * 10/19/99	rodtoll	Fix: Bug #113904 Release Issues
 *					Added init for notify interface count
 * 10/25/99	rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 * 11/12/99	rodtoll	Fixed to use new dsound header.
 * 11/30/99	pnewson	Bug #117449 - IDirectPlayVoiceSetup Parameter validation
 * 12/01/99	rodtoll	Added includes to define and instantiate GUID_NULL
 * 12/16/99	rodtoll Bug #117405 - 3D sound APIs misleading
 * 01/14/00	rodtoll	Added new DVC_GetSoundDeviceConfig member to VTable
 * 02/17/00	rodtoll	Bug #133691 - Choppy audio - queue was not adapting
 *					Added instrumentation
 *			rodtoll	Removed self-registration code
 * 03/03/00	rodtoll	Updated to handle alternative gamevoice build. 
 * 04/11/00 rodtoll Added code for redirection for custom builds if registry bit is set 
 * 04/21/00 rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 * 06/07/00	rodtoll	Bug #34383 Must provide CLSID for each IID to fix issues with Whistler
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 * 06/28/2000	rodtoll	Prefix Bug #38022
 * 07/05/00	rodtoll	Moved code to new dllmain.cpp
 * 08/23/2000	rodtoll	DllCanUnloadNow always returning TRUE! 
 * 08/28/2000	masonb  Voice Merge: Removed dvosal.h, changed ccomutil.h to comutil.h
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash 
 *
 ***************************************************************************/

#include "dxvoicepch.h"


// VTable types
typedef struct IDirectPlayVoiceClientVtbl DVCINTERFACE;
typedef DVCINTERFACE FAR * LPDVCINTERFACE;

typedef struct IDirectPlayVoiceServerVtbl DVSINTERFACE;
typedef DVSINTERFACE FAR * LPDVSINTERFACE;

typedef struct IDirectPlayVoiceSetupVtbl DVTINTERFACE;
typedef DVTINTERFACE FAR * LPDVTINTERFACE;

#define EXP __declspec(dllexport)

/*#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif*/

// Client VTable
LPVOID dvcInterface[] =
{
    (LPVOID)DVC_QueryInterface,
    (LPVOID)DV_AddRef,
    (LPVOID)DVC_Release,
	(LPVOID)DV_Initialize,
	(LPVOID)DVC_Connect,
	(LPVOID)DVC_Disconnect,
	(LPVOID)DVC_GetSessionDesc,
	(LPVOID)DVC_GetClientConfig,
	(LPVOID)DVC_SetClientConfig,
	(LPVOID)DVC_GetCaps, 
	(LPVOID)DVC_GetCompressionTypes,
    (LPVOID)DVC_SetTransmitTarget,
	(LPVOID)DVC_GetTransmitTarget,
	(LPVOID)DVC_Create3DSoundBuffer,
	(LPVOID)DVC_Delete3DSoundBuffer,
	(LPVOID)DVC_SetNotifyMask,
	(LPVOID)DVC_GetSoundDeviceConfig
};    

// Server VTable
LPVOID dvsInterface[]  = 
{
    (LPVOID)DVS_QueryInterface,
    (LPVOID)DV_AddRef,
    (LPVOID)DVS_Release,
	(LPVOID)DV_Initialize,
	(LPVOID)DVS_StartSession,
	(LPVOID)DVS_StopSession,
	(LPVOID)DVS_GetSessionDesc,
	(LPVOID)DVS_SetSessionDesc,
	(LPVOID)DVS_GetCaps, 
	(LPVOID)DVS_GetCompressionTypes,
	(LPVOID)DVS_SetTransmitTarget,
	(LPVOID)DVS_GetTransmitTarget,
	(LPVOID)DVS_SetNotifyMask	
};

// Setup VTable
LPVOID dvtInterface[]  = 
{
    (LPVOID)DVT_QueryInterface,
    (LPVOID)DVT_AddRef,
    (LPVOID)DVT_Release,
    (LPVOID)DVT_CheckAudioSetup,
};

// VTable for Client version of notification interface
LPVOID dvClientNotifyInterface[] = 
{
    (LPVOID)DVC_Notify_QueryInterface,
    (LPVOID)DV_Notify_AddRef,
    (LPVOID)DVC_Notify_Release,
	(LPVOID)DV_Notify_Initialize,
	(LPVOID)DV_NotifyEvent,
	(LPVOID)DV_ReceiveSpeechMessage
};

// VTable for server version of notification interface
LPVOID dvServerNotifyInterface[] = 
{
    (LPVOID)DVS_Notify_QueryInterface,
    (LPVOID)DV_Notify_AddRef,
    (LPVOID)DVS_Notify_Release,
	(LPVOID)DV_Notify_Initialize,
	(LPVOID)DV_NotifyEvent,
	(LPVOID)DV_ReceiveSpeechMessage
};

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Create"
HRESULT DVC_Create(LPDIRECTVOICECLIENTOBJECT *piDVC)
{
	HRESULT hr = S_OK;
	LPDIRECTVOICECLIENTOBJECT pDVCInt;

	pDVCInt = static_cast<LPDIRECTVOICECLIENTOBJECT>( DNMalloc(sizeof(DIRECTVOICECLIENTOBJECT)) );
	if (pDVCInt == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return E_OUTOFMEMORY;
	}

	if (!DNInitializeCriticalSection( &pDVCInt->csCountLock ))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNFree(pDVCInt);
		return E_OUTOFMEMORY;
	}

	pDVCInt->lpVtbl = &dvcInterface;
	pDVCInt->lpDVClientEngine = new CDirectVoiceClientEngine(pDVCInt);

	if (pDVCInt->lpDVClientEngine == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNDeleteCriticalSection( &pDVCInt->csCountLock );				
		DNFree( pDVCInt );
		return E_OUTOFMEMORY;
	}

	if (!pDVCInt->lpDVClientEngine->InitClass())
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNDeleteCriticalSection( &pDVCInt->csCountLock );
		delete pDVCInt->lpDVEngine;
		DNFree( pDVCInt );
		return E_OUTOFMEMORY;
	}

	pDVCInt->lpDVEngine = static_cast<CDirectVoiceEngine *>(pDVCInt->lpDVClientEngine);
	pDVCInt->lpDVTransport = NULL;
	pDVCInt->lIntRefCnt = 0;
	pDVCInt->dvNotify.lpDV = pDVCInt;
	pDVCInt->dvNotify.lpNotifyVtble = &dvClientNotifyInterface;
	pDVCInt->dvNotify.lRefCnt = 0;

	*piDVC = pDVCInt;

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_Create"
HRESULT DVS_Create(LPDIRECTVOICESERVEROBJECT *piDVS)
{
	HRESULT hr = S_OK;
	LPDIRECTVOICESERVEROBJECT pDVSInt;

	pDVSInt = static_cast<LPDIRECTVOICESERVEROBJECT>( DNMalloc(sizeof(DIRECTVOICESERVEROBJECT)) );
	if (pDVSInt == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return E_OUTOFMEMORY;
	}

	if (!DNInitializeCriticalSection( &pDVSInt->csCountLock ))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNFree(pDVSInt);
		return E_OUTOFMEMORY;
	}

	pDVSInt->lpVtbl = &dvsInterface;
	pDVSInt->lpDVServerEngine = new CDirectVoiceServerEngine(pDVSInt);

	if (pDVSInt->lpDVServerEngine == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNDeleteCriticalSection( &pDVSInt->csCountLock );		
		DNFree( pDVSInt );
		return E_OUTOFMEMORY;
	}

	if (!pDVSInt->lpDVServerEngine->InitClass())
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNDeleteCriticalSection( &pDVSInt->csCountLock );
		delete pDVSInt->lpDVEngine;
		DNFree( pDVSInt );
		return E_OUTOFMEMORY;
	}

	pDVSInt->lpDVEngine = static_cast<CDirectVoiceEngine *>(pDVSInt->lpDVServerEngine);
	pDVSInt->lpDVTransport = NULL;
	pDVSInt->lIntRefCnt = 0;
	pDVSInt->dvNotify.lpDV = pDVSInt;
	pDVSInt->dvNotify.lpNotifyVtble = &dvServerNotifyInterface;
	pDVSInt->dvNotify.lRefCnt = 0;

	*piDVS = pDVSInt;

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVT_Create"
HRESULT DVT_Create(LPDIRECTVOICESETUPOBJECT *piDVT)
{
	HRESULT hr = S_OK;
	LPDIRECTVOICESETUPOBJECT pDVTInt;

	pDVTInt = static_cast<LPDIRECTVOICESETUPOBJECT>( DNMalloc(sizeof(DIRECTVOICESETUPOBJECT)) );
	if (pDVTInt == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return E_OUTOFMEMORY;
	}

	if (!DNInitializeCriticalSection( &pDVTInt->csCountLock ))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNFree(pDVTInt);
		return E_OUTOFMEMORY;
	}
	
	pDVTInt->lpVtbl = &dvtInterface;
	pDVTInt->lpDVSetup = new CDirectVoiceSetup(pDVTInt);

	if (pDVTInt->lpDVSetup == NULL)
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		DNDeleteCriticalSection( &pDVTInt->csCountLock );
		DNFree( pDVTInt );
		return E_OUTOFMEMORY;
	}

	pDVTInt->lIntRefCnt = 0;

	*piDVT = pDVTInt;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\trnotify.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		trnotify.h
 *  Content:	Definitions of the IDirectXVoiceNotify interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/26/99		rodtoll	Created
 * 08/03/99		rodtoll	Updated with new parameters for Initialize
 * 08/05/99		rodtoll	Added new receive parameter 
 * 04/07/2000   rodtoll Updated to match changes in DP <--> DPV interface
 *						
 ***************************************************************************/
#ifndef __TRNOTIFY_H
#define __TRNOTIFY_H

#ifdef __cplusplus
extern "C" {
#endif

STDAPI DV_NotifyEvent( LPDIRECTVOICENOTIFYOBJECT lpDVN, DWORD dwType, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
STDAPI DV_ReceiveSpeechMessage( LPDIRECTVOICENOTIFYOBJECT lpDVN, DVID dvidSource, DVID dvidTo, LPVOID lpMessage, DWORD dwSize );
STDAPI DV_Notify_Initialize( LPDIRECTVOICENOTIFYOBJECT lpDVN );

STDAPI DV_Notify_AddRef(LPDIRECTVOICENOTIFYOBJECT lpDVN );
STDAPI DVC_Notify_Release(LPDIRECTVOICENOTIFYOBJECT lpDVN );
STDAPI DVC_Notify_QueryInterface(LPDIRECTVOICENOTIFYOBJECT lpDVN, REFIID riid, LPVOID * ppvObj );
STDAPI DVS_Notify_QueryInterface(LPDIRECTVOICENOTIFYOBJECT lpDVN, REFIID riid, LPVOID * ppvObj );
STDAPI DVS_Notify_Release(LPDIRECTVOICENOTIFYOBJECT lpDVN );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\trnotify.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		trnotify.cpp
 *  Content:	Implementation of the IDirectXVoiceNotify interface
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/26/99		rodtoll	Created
 * 08/03/99		rodtoll	Updated with new parameters for Initialize
 *						Updated for new initialization order
 * 08/05/99		rodtoll	Added hook for host migration
 * 08/05/99		rodtoll	Added new receive parameter
 * 08/10/99		rodtoll	Initial host migration
 * 08/31/99		rodtoll	Updated to use new debug libs
 * 09/14/99		rodtoll	Updated to reflect new parameters for Initialize call
 * 09/20/99		rodtoll	Updated to check for out of memory errors
 * 09/28/99		rodtoll	Added release on server interface created by host migration
 * 10/05/99		rodtoll	Additional comments
 * 10/19/99		rodtoll	Fix: Bug #113904 - Shutdown issues
 *                      - Added reference count for notify interface, allows
 *                        determination if stopsession should be called from release
 *						- Fixed host migration break caused by Fix.
 * 10/25/99		rodtoll	Fix: Bug #114098 - Release/Addref failure from multiple threads 
 * 12/16/99		rodtoll Fix: Bug #122629 - Updated for new host migration
 * 04/07/2000   rodtoll Updated to match changes in DP <--> DPV interface 
 * 07/22/20000	rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				  Now ensures that all threads from transport have left and that
 *					  all notificatinos have been processed before shutdown is complete. 
 * 01/04/2001	rodtoll	WinBug #94200 - Remove stray comments 
 *						
 ***************************************************************************/

#include "dxvoicepch.h"


extern HRESULT DVC_Create(LPDIRECTVOICECLIENTOBJECT *piDVC);
extern HRESULT DVS_Create(LPDIRECTVOICESERVEROBJECT *piDVS);

#undef DPF_MODNAME
#define DPF_MODNAME "DV_HostMigrate"
// 
// DV_HostMigrate
//
// Called by DV_NotifyEvent to handle host migration
//
void DV_HostMigrate( LPDIRECTVOICEOBJECT lpdv, DVID dvidNewHost )
{
	LPDIRECTVOICECLIENTOBJECT lpdvcClientObject = NULL;
	LPDIRECTVOICESERVEROBJECT lpdvsServerObject = NULL;
	DVSESSIONDESC dvSessionDesc;
	HRESULT hr = DP_OK;

	DPFX(DPFPREP,  DVF_INFOLEVEL, "DV_HostMigrate: Notified of a host migration.  New Host = 0x%x", dvidNewHost );
	
	// We're the new host!  Create and setup a server object for the session host
	// When other clients receive the host migrate message this object will 
	// be contacted with join messages.
	//
	// If this case is active, we should be a client, afterall why would we host migrate
	// to ourselves.  
	//
	if( dvidNewHost == lpdv->lpDVTransport->GetLocalID() )
	{
		lpdvcClientObject = (LPDIRECTVOICECLIENTOBJECT) lpdv;

		DPFX(DPFPREP,  DVF_INFOLEVEL, "DV_HostMigrate: We're the new host -- Congrats!" );
		
		// Create a new server object
		DVS_Create( &lpdvsServerObject );

		// FYI: Casts to a DXTransport, which should be safe unless we implement a different transport
		//      If you implement different transport object interface then a QI type system will be needed
		//
		CDirectVoiceDirectXTransport *transport = (CDirectVoiceDirectXTransport *) lpdv->lpDVTransport;

		// Initialize the server object
		hr = DV_Initialize( lpdvsServerObject, transport->GetTransportInterface(), NULL, NULL, NULL, 0 );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "DV_Initialize on new host object failed.  hr=0x%x", hr );
			return;
		}

		dvSessionDesc.dwSize = sizeof( DVSESSIONDESC );
		hr = lpdvcClientObject->lpDVClientEngine->GetSessionDesc( &dvSessionDesc );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "GetSessionInfo failed.  hr=0x%x", hr );
			lpdvsServerObject->lIntRefCnt = 1;

			DVS_Release( lpdvsServerObject );

			return;
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "DV_HostMigrate: Starting new object" );		
	
		lpdvsServerObject->lpDVServerEngine->HostMigrateStart(&dvSessionDesc);

		DPFX(DPFPREP,  DVF_INFOLEVEL, "DV_HostMigrate: WStartup Complete" );	
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "DV_HostMigrate: Informing local engine of new host" );		
	
	lpdv->lpDVEngine->MigrateHost( dvidNewHost, (LPDIRECTPLAYVOICESERVER) lpdvsServerObject );

	// Ok.  We need an extra reference to this object to prevent
	// the code which detects it needs to call StopSession for 
	// people who don't call StopSession before calling Release.
	/*
	// Release this function's reference on the object
	if( lpdvsServerObject != NULL )
	{
		DVS_Release( lpdvsServerObject );
	}*/
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_NotifyEvent"
STDMETHODIMP DV_NotifyEvent( LPDIRECTVOICENOTIFYOBJECT lpDVN, DWORD dwNotifyType, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{

	switch( dwNotifyType )
	{
	case DVEVENT_MIGRATEHOST:
		lpDVN->lpDV->lpDVEngine->MigrateHost( 0, NULL );
		break;
	case DVEVENT_STARTSESSION:
		lpDVN->lpDV->lpDVEngine->StartTransportSession();
		break;
	case DVEVENT_STOPSESSION:
		lpDVN->lpDV->lpDVEngine->StopTransportSession();
		break;
	case DVEVENT_ADDPLAYER:
		lpDVN->lpDV->lpDVEngine->AddPlayer( (DVID) dwParam1 );
		break;
	case DVEVENT_REMOVEPLAYER:
		lpDVN->lpDV->lpDVEngine->RemovePlayer( (DVID) dwParam1 );
		break;
	case DVEVENT_CREATEGROUP:
		lpDVN->lpDV->lpDVEngine->CreateGroup( (DVID) dwParam1 );
		break;
	case DVEVENT_DELETEGROUP:
		lpDVN->lpDV->lpDVEngine->DeleteGroup( (DVID) dwParam1 );
		break;
	case DVEVENT_ADDPLAYERTOGROUP:
		lpDVN->lpDV->lpDVEngine->AddPlayerToGroup( (DVID) dwParam1, (DVID) dwParam2 );
		break;
	case DVEVENT_REMOVEPLAYERFROMGROUP:
		lpDVN->lpDV->lpDVEngine->RemovePlayerFromGroup( (DVID) dwParam1, (DVID) dwParam2 );
		break;
	case DVEVENT_SENDCOMPLETE:
	    lpDVN->lpDV->lpDVEngine->SendComplete( (PDVEVENTMSG_SENDCOMPLETE) dwParam1 );
	    break;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_ReceiveSpeechMessage"
STDMETHODIMP DV_ReceiveSpeechMessage( LPDIRECTVOICENOTIFYOBJECT lpDVN, DVID dvidSource, DVID dvidTo, LPVOID lpMessage, DWORD dwSize )
{
	lpDVN->lpDV->lpDVEngine->ReceiveSpeechMessage( dvidSource, lpMessage, dwSize );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_Notify_Initialize"
STDMETHODIMP DV_Notify_Initialize( LPDIRECTVOICENOTIFYOBJECT lpDVN ) 
{
	return lpDVN->lpDV->lpDVTransport->Initialize();
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_Notify_AddRef"
STDMETHODIMP DV_Notify_AddRef(LPDIRECTVOICENOTIFYOBJECT lpDVN )
{
	lpDVN->lpDV->lpDVTransport->AddRef();
	return 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Notify_Release"
STDAPI DVC_Notify_Release(LPDIRECTVOICENOTIFYOBJECT lpDVN )
{
	lpDVN->lpDV->lpDVTransport->Release();	
	return 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVC_Notify_QueryInterface"
STDMETHODIMP DVC_Notify_QueryInterface(LPDIRECTVOICENOTIFYOBJECT lpDVN, REFIID riid, LPVOID * ppvObj )
{
	return DVC_QueryInterface( (LPDIRECTVOICECLIENTOBJECT) lpDVN->lpDV, riid, ppvObj );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_Notify_QueryInterface"
STDMETHODIMP DVS_Notify_QueryInterface(LPDIRECTVOICENOTIFYOBJECT lpDVN, REFIID riid, LPVOID * ppvObj )
{
	return DVS_QueryInterface( (LPDIRECTVOICESERVEROBJECT) lpDVN->lpDV, riid, ppvObj );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVS_Notify_Release"
STDAPI DVS_Notify_Release(LPDIRECTVOICENOTIFYOBJECT lpDVN )
{
	lpDVN->lpDV->lpDVTransport->Release();	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\vnametbl.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vnametbl.h
 *  Content:	Voice Player Name Table
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/26/00	rodtoll Created
 *  06/02/00    rodtoll  Updated so host migration algorithm returns ID as well as order ID 
 *  07/01/2000	rodtoll	Bug #38280 - DVMSGID_DELETEVOICEPLAYER messages are being sent in non-peer to peer sessions
 *						Nametable will now only unravel with messages if session is peer to peer.
 *  07/09/2000	rodtoll	Added signature bytes 
 ***************************************************************************/

#include "dxvoicepch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// DeInitialize
//
// Cleanup the name table
#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceNameTable::DeInitialize"

HRESULT CVoiceNameTable::DeInitialize(BOOL fUnRavel, PVOID pvContext, LPDVMESSAGEHANDLER pvMessageHandler )
{
	CVoicePlayer *pPlayer;
	DVID dvID;
	PVOID pvPlayerContext;
	DVMSG_DELETEVOICEPLAYER dvMsgDelete;

	if( !m_fInitialized )
		return DV_OK;

	Lock();

	while( !m_nameTable.IsEmpty() )
	{
		if( m_nameTable.RemoveLastEntry( &pPlayer ) )
		{
			// Mark it as disconnected
			pPlayer->SetDisconnected();

			dvID = pPlayer->GetPlayerID();
			pvPlayerContext = pPlayer->GetContext();

			// Release the player record reference we had
			pPlayer->Release();

            if( pvMessageHandler != NULL )
            {
				if( fUnRavel )
				{
					// Drop locks to call up to user
    				UnLock();

					dvMsgDelete.dvidPlayer = dvID;
					dvMsgDelete.dwSize = sizeof( DVMSG_DELETEVOICEPLAYER );
					dvMsgDelete.pvPlayerContext = pvPlayerContext;

					(*pvMessageHandler)( pvContext, DVMSGID_DELETEVOICEPLAYER, &dvMsgDelete );
               
        			Lock();
				}
            }
		}
	}

	UnLock();

	m_nameTable.Deinitialize();

	m_fInitialized = FALSE;

	DNDeleteCriticalSection( &m_csTableLock );

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoiceNameTable::GetLowestHostOrderID"

DWORD CVoiceNameTable::GetLowestHostOrderID(DVID *pdvidHost)
{
	DWORD dwLowestID = DVPROTOCOL_HOSTORDER_INVALID;

	Lock();

	DWORD dwNumTableEntries = 1 << m_nameTable.m_iHashBitDepth;
	CBilink *blLink;
	CClassHashEntry<CVoicePlayer,DVID> *pEntry;

	// Search the list, finding the lowest ID
	for( DWORD dwIndex = 0; dwIndex < dwNumTableEntries; dwIndex++ )
	{
		blLink = &m_nameTable.m_pHashEntries[ dwIndex ];

		while ( blLink->GetNext() != &m_nameTable.m_pHashEntries[ dwIndex ] )
		{
			pEntry = CClassHashEntry<CVoicePlayer,DVID>::EntryFromBilink( blLink->GetNext() );

            DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: ID [0x%x] ORDERID [0x%x]", pEntry->m_pItem->GetPlayerID(), pEntry->m_pItem->GetHostOrder() );
			if( pEntry->m_pItem->GetHostOrder() < dwLowestID )
			{
			    DPFX(DPFPREP,  DVF_HOSTMIGRATE_DEBUG_LEVEL, "HOST MIGRATION: ID [0x%x] IS CURRENT CANDIDATE", pEntry->m_pItem->GetPlayerID() );
				dwLowestID = pEntry->m_pItem->GetHostOrder();

				*pdvidHost = pEntry->m_pItem->GetPlayerID();
			}

			blLink = blLink->GetNext();
		}

	}

	UnLock();

	return dwLowestID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\vnametbl.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vnametbl.h
 *  Content:	Voice Name Table Routines
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/26/00  rodtoll    Created
 *  06/02/00    rodtoll  Updated so host migration algorithm returns ID as well as order ID   
 *  06/21/2000	rodtoll	 Fixed bug in error handling (not yet encountered -- but good to fix).
 *  07/01/2000	rodtoll	Bug #38280 - DVMSGID_DELETEVOICEPLAYER messages are being sent in non-peer to peer sessions
 *						Nametable will now only unravel with messages if session is peer to peer.
 *  07/09/2000	rodtoll	Added signature bytes
 *  08/28/2000	masonb  Voice Merge: Changed classhash.h to classhashvc.h
 *  04/09/2001	rodtoll	WINBUG #364126 - DPVoice : Memory leak when Initializing 2 Voice Servers with same DPlay transport 
 *
 ***************************************************************************/

#ifndef __NAMETABLE_H
#define __NAMETABLE_H

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define VSIG_VOICENAMETABLE			'BTNV'
#define VSIG_VOICENAMETABLE_FREE	'BTN_'

#undef DPF_MODNAME
#define DPF_MODNAME "ClassHash_Hash"
inline DWORD_PTR ClassHash_Hash( const DVID &dvidKey, UINT_PTR HashBitCount )
{
		DWORD_PTR hashResult;

		hashResult = dvidKey;
		
		// Clear upper bits
		hashResult <<= ((sizeof(DWORD_PTR)*8)-HashBitCount);

		// Restore value
		hashResult >>= ((sizeof(DWORD_PTR)*8)-HashBitCount);

		return hashResult;
}

#define VOICE_NAMETABLE_START_BITDEPTH		6
#define VOICE_NAMETABLE_GROW_BITDEPTH		2

volatile class CVoiceNameTable
{
public:
	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::CVoiceNameTable"
	CVoiceNameTable( )
	{
		m_dwSignature = VSIG_VOICENAMETABLE;
		m_fInitialized = FALSE;
	};
	
	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::~CVoiceNameTable"
	~CVoiceNameTable()
	{
		DeInitialize(FALSE, NULL, NULL);

		m_dwSignature = VSIG_VOICENAMETABLE_FREE;
	}

	HRESULT DeInitialize(BOOL fUnRavel, PVOID pvContext, LPDVMESSAGEHANDLER pvMessageHandler);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::Initialize"
	inline HRESULT Initialize()
	{
		BOOL fResult;

		if (!DNInitializeCriticalSection( &m_csTableLock ))
		{
			return DVERR_OUTOFMEMORY;
		}

		fResult = m_nameTable.Initialize( VOICE_NAMETABLE_START_BITDEPTH, VOICE_NAMETABLE_GROW_BITDEPTH );

		if( !fResult )
		{
			DPFX(DPFPREP, 0, "Failed to initialize hash table" );
			DNDeleteCriticalSection( &m_csTableLock );
			return DVERR_GENERIC;
		}

		m_fInitialized = TRUE;

		return DV_OK;
	};

	DWORD GetLowestHostOrderID(DVID *pdvidHost);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::IsEntry"
	BOOL IsEntry( const DVID dvidID )
	{
		BOOL fResult;

		CVoicePlayer *pEntry;

		Lock();

		fResult = m_nameTable.Find( dvidID, &pEntry );

		UnLock();

		return fResult;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::GetEntry"
	inline HRESULT GetEntry( const DVID dvidID, CVoicePlayer **ppEntry, BOOL fAddReference )
	{
		BOOL fFound;

		Lock();

		fFound = m_nameTable.Find( dvidID, ppEntry );
		
		if( !fFound )
		{
			*ppEntry = NULL;
			UnLock();
			return DVERR_INVALIDPLAYER;
		}

		DNASSERT( *ppEntry != NULL );

		if( fAddReference )
		{
			(*ppEntry)->AddRef();
		}

		UnLock();

		return DV_OK;
	}
	
	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::AddEntry"
	inline HRESULT AddEntry( const DVID dvidID, CVoicePlayer *pEntry )
	{
		BOOL fFound;
		CVoicePlayer *pTmpEntry;

		Lock();

		fFound = m_nameTable.Find( dvidID, &pTmpEntry );

		if( fFound )
		{
			UnLock();
			return DVERR_GENERIC;
		}

		pEntry->AddRef();

		fFound = m_nameTable.Insert( dvidID, pEntry );

		if( !fFound )
		{
			pEntry->Release();
			UnLock();
			return DVERR_GENERIC;
		}

		UnLock();

		return DV_OK;
	}
	
	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::DeleteEntry"
	inline HRESULT DeleteEntry( const DVID dvidID )
	{
		BOOL fFound;
		CVoicePlayer *pTmpEntry;

		Lock();

		fFound = m_nameTable.Find( dvidID, &pTmpEntry );

		if( !fFound )
		{
			UnLock();
			return DVERR_GENERIC;
		}

		m_nameTable.Remove( dvidID );

		DNASSERT( pTmpEntry != NULL );

		// Regardless of if it was found..
		// Drop the reference count
		pTmpEntry->Release();

		if( !fFound )
		{
			UnLock();
			return DVERR_GENERIC;
		}

		UnLock();

		return DV_OK;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::Lock"
	inline void Lock()
	{
		DNEnterCriticalSection( &m_csTableLock );
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CVoiceNameTable::UnLock"
	inline void UnLock()
	{
		DNLeaveCriticalSection( &m_csTableLock );
	}

protected:

	DWORD							m_dwSignature; 
	CClassHash<CVoicePlayer,DVID>	m_nameTable;
	DNCRITICAL_SECTION				m_csTableLock;
	BOOL							m_fInitialized;
};

#undef DPF_MODNAME

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\vplayer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vplayer.h
 *  Content:	Voice Player Entry
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/26/00	rodtoll Created
 * 03/29/2000	rodtoll Bug #30753 - Added volatile to the class definition
 *  07/09/2000	rodtoll	Added signature bytes 
 *  11/28/2000	rodtoll	Bug #47333 - DPVOICE: Server controlled targetting - invalid targets are not removed automatically
 ***************************************************************************/

#ifndef __VPLAYER_H
#define __VPLAYER_H

#define VOICEPLAYER_FLAGS_DISCONNECTED          0x00000001  // Player has disconnected
#define VOICEPLAYER_FLAGS_INITIALIZED           0x00000002  // Player is initialized
#define VOICEPLAYER_FLAGS_ISRECEIVING           0x00000004  // Player is currently receiving audio
#define VOICEPLAYER_FLAGS_ISSERVERPLAYER        0x00000008  // Player is the server player
#define VOICEPLAYER_FLAGS_TARGETIS8BIT          0x00000010  // Is the target 8-bit?
#define VOICEPLAYER_FLAGS_ISAVAILABLE			0x00000020	// Is player available

typedef struct _VOICEPLAYER_STATISTICS
{
    DWORD               dwNumSilentFrames;
    DWORD               dwNumSpeechFrames;
    DWORD               dwNumReceivedFrames;
    DWORD               dwNumLostFrames;
    QUEUE_STATISTICS    queueStats;
} VOICEPLAYER_STATISTICS, *PVOICEPLAYER_STATISTICS;

#define VSIG_VOICEPLAYER		'YLPV'
#define VSIG_VOICEPLAYER_FREE	'YLP_'

volatile class CVoicePlayer
{
public: // Init / destruct

    CVoicePlayer();
    virtual ~CVoicePlayer();

    HRESULT Initialize( const DVID dvidPlayer, const DWORD dwHostOrder, DWORD dwFlags, 
                        PVOID pvContext, CLockedFixedPool<CVoicePlayer> *pOwner );

    HRESULT CreateQueue( PQUEUE_PARAMS pQueueParams );
    HRESULT CreateInBoundConverter( const GUID &guidCT, PWAVEFORMATEX pwfxTargetFormat );
    virtual HRESULT DeInitialize();
	void FreeResources();
	HRESULT SetPlayerTargets( PDVID pdvidTargets, DWORD dwNumTargets );
	
	BOOL FindAndRemovePlayerTarget( DVID dvidTargetToRemove );

    inline void AddRef()
    {
        InterlockedIncrement( &m_lRefCount );
    }

    inline void Release()
    {
        if( InterlockedDecrement( &m_lRefCount ) == 0 )
        {
            DeInitialize();
        }
    }

public: // Speech Handling 

    HRESULT HandleReceive( PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize );
	HRESULT GetNextFrameAndDecompress( PVOID pvBuffer, PDWORD pdwBufferSize, BOOL *pfLost, BOOL *pfSilence, DWORD *pdwSeqNum, DWORD *pdwMsgNum );
	HRESULT DeCompressInBound( CFrame *frCurrentFrame, PVOID pvBuffer, PDWORD pdwBufferSize );
	CFrame *Dequeue(BOOL *pfLost, BOOL *pfSilence);

    void GetStatistics( PVOICEPLAYER_STATISTICS pStats );

    inline DVID GetPlayerID()
    {
        return m_dvidPlayer;
    }

    inline DWORD GetFlags()
    {
        return m_dwFlags;
    }

	inline BOOL IsInBoundConverterInitialized()
	{
		return (m_lpInBoundAudioConverter != NULL);
	}

    inline BOOL Is8BitUnCompressed()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_TARGETIS8BIT );
    }

    inline BOOL IsReceiving()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_ISRECEIVING);
    }

    inline void SetReceiving( const BOOL fReceiving )
    {
        Lock();
        if( fReceiving )
            m_dwFlags |= VOICEPLAYER_FLAGS_ISRECEIVING;
        else
            m_dwFlags &= ~VOICEPLAYER_FLAGS_ISRECEIVING;
        UnLock();
    }

    inline void SetAvailable( const BOOL fAvailable )
    {
    	Lock();
		if( fAvailable )
			m_dwFlags |= VOICEPLAYER_FLAGS_ISAVAILABLE;
		else 
			m_dwFlags &= ~VOICEPLAYER_FLAGS_ISAVAILABLE;
    	UnLock();
    }

    inline BOOL IsAvailable()
    {
    	return (m_dwFlags & VOICEPLAYER_FLAGS_ISAVAILABLE);
   	}

    inline BOOL IsInitialized()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_INITIALIZED);
    }

    inline BOOL IsServerPlayer()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_ISSERVERPLAYER);
    }

    inline void SetServerPlayer()
    {
        Lock();
        m_dwFlags |= VOICEPLAYER_FLAGS_ISSERVERPLAYER;
        UnLock();
    }

    inline BOOL IsDisconnected()
    {
        return (m_dwFlags & VOICEPLAYER_FLAGS_DISCONNECTED);
    }

    inline void SetDisconnected()
    {
        Lock();
        m_dwFlags |= VOICEPLAYER_FLAGS_DISCONNECTED;
        UnLock();
    }

    inline void SetHostOrder( const DWORD dwHostOrder )
    {
        Lock();
        m_dwHostOrderID = dwHostOrder;
        UnLock();
    }

    inline DWORD GetHostOrder() 
    {
        return m_dwHostOrderID;
    }

    inline void Lock()
    {
        DNEnterCriticalSection( &m_csLock );
    }

    inline void UnLock()
    {
        DNLeaveCriticalSection( &m_csLock );
    }

    inline void *GetContext()
    {
        return m_pvPlayerContext;
    }

    inline void SetContext( void *pvContext )
    {
        Lock();

        m_pvPlayerContext = pvContext;

        UnLock();
    }

    inline BYTE GetLastPeak()
    {
        return m_bLastPeak;
    }

    inline DWORD GetTransportFlags()
    {
        return m_dwTransportFlags;
    }

    inline void AddToPlayList( BILINK *pblBilink )
    {
        InsertAfter( &m_blPlayList, pblBilink );
    }

	inline void AddToNotifyList( BILINK *pblBilink )
	{
        InsertAfter( &m_blNotifyList, pblBilink );

	}

    inline void RemoveFromNotifyList()
    {
        Delete( &m_blNotifyList );
    }

	inline void RemoveFromPlayList()
	{
		Delete( &m_blPlayList );
	}

	inline DWORD_PTR GetLastPlayback()
	{
		return m_dwLastPlayback;
	}

	inline DWORD GetNumTargets()
	{
		return m_dwNumTargets;
	}

	inline PDVID GetTargetList()
	{
		return m_pdvidTargets;
	}

	DWORD				m_dwSignature;

	BILINK				m_blNotifyList;
	BILINK				m_blPlayList;

protected:

    virtual void Reset();

	PDVID				m_pdvidTargets;		// The player's current target
	DWORD				m_dwNumTargets;

    DWORD               m_dwTransportFlags;
    DWORD               m_dwFlags;
    DWORD               m_dwNumSilentFrames;
    DWORD               m_dwNumSpeechFrames;
    DWORD               m_dwNumReceivedFrames;
    DWORD               m_dwNumLostFrames;
	DVID		        m_dvidPlayer;		// Player's ID
	DWORD				m_dwHostOrderID;	// Host ORDER ID

	LONG		        m_lRefCount;		// Reference count on the player

	PDPVCOMPRESSOR		m_lpInBoundAudioConverter; // Converter for this player's audio
	CInputQueue2		*m_lpInputQueue;	// Input queue for this player's audio
    PVOID               m_pvPlayerContext;
    CLockedFixedPool<CVoicePlayer> *m_pOwner;

	DWORD_PTR			m_dwLastData;		// GetTickCount() value when last data received
    DWORD_PTR			m_dwLastPlayback;	// GetTickCount() when last non-silence from this player

	DNCRITICAL_SECTION	m_csLock;

    BYTE				m_bLastPeak;		// Last peak value for this player.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvoice\vplayer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vplayer.h
 *  Content:	Voice Player Entry
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/26/00	rodtoll Created
 *  07/09/2000	rodtoll	Added signature bytes 
 ***************************************************************************/

#include "dxvoicepch.h"


CVoicePlayer::CVoicePlayer()
{
	m_dwSignature = VSIG_VOICEPLAYER;
    Reset();
}

CVoicePlayer::~CVoicePlayer()
{
    if( IsInitialized() )
        DeInitialize();

	m_dwSignature = VSIG_VOICEPLAYER_FREE;
}

void CVoicePlayer::Reset()
{
    m_dwFlags = 0;
    m_dvidPlayer = 0;
    m_lRefCount = 0;
    m_lpInBoundAudioConverter = NULL;
    m_lpInputQueue = NULL;
    m_dwLastData = 0;
    m_dwHostOrderID = 0xFFFFFFFF;
    m_bLastPeak = 0;
    m_dwLastPlayback = 0;
    m_dwNumSilentFrames = 0;
    m_dwTransportFlags = 0;
    m_dwNumLostFrames = 0;
    m_dwNumSpeechFrames = 0;
    m_dwNumReceivedFrames = 0;
    m_pvPlayerContext = NULL;
	InitBilink( &m_blNotifyList, this );
	InitBilink( &m_blPlayList, this );
	m_dwNumTargets = 0;
	m_pdvidTargets = NULL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::SetPlayerTargets"
//
// Assumes the array has been checked for validity
// 
HRESULT CVoicePlayer::SetPlayerTargets( PDVID pdvidTargets, DWORD dwNumTargets )
{
	Lock();

	delete [] m_pdvidTargets;

	if( dwNumTargets == 0 )
	{
		m_pdvidTargets = NULL;
	}
	else
	{
		m_pdvidTargets = new DVID[dwNumTargets];

		if( m_pdvidTargets == NULL )
		{
			m_pdvidTargets = NULL;
			m_dwNumTargets = 0;
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
			UnLock();
			return DVERR_OUTOFMEMORY;
		}

		memcpy( m_pdvidTargets, pdvidTargets, sizeof(DVID)*dwNumTargets );
	}

	m_dwNumTargets = dwNumTargets;
	
	UnLock();

	return DV_OK;
}



HRESULT CVoicePlayer::Initialize( const DVID dvidPlayer, const DWORD dwHostOrder, DWORD dwFlags, PVOID pvContext, 
                                  CLockedFixedPool<CVoicePlayer> *pOwner )
{
    if (!DNInitializeCriticalSection( &m_csLock ))
	{
		return DVERR_OUTOFMEMORY;
	}
    m_lRefCount = 1;
    m_pOwner = pOwner;
    m_dvidPlayer = dvidPlayer;
    m_dwHostOrderID = dwHostOrder;
    m_dwLastData = GetTickCount();
    m_dwLastPlayback = 0;
    m_dwTransportFlags = dwFlags;
    m_pvPlayerContext = pvContext;
    m_dwFlags |= VOICEPLAYER_FLAGS_INITIALIZED;
    return DV_OK;
}

void CVoicePlayer::GetStatistics( PVOICEPLAYER_STATISTICS pStats )
{
    memset( pStats, 0x00, sizeof( VOICEPLAYER_STATISTICS ) );

    // Get queue statistics
    if( m_lpInputQueue != NULL )
    {
        Lock();
    
        m_lpInputQueue->GetStatistics( &pStats->queueStats );

        UnLock();
    }
    
    pStats->dwNumLostFrames = m_dwNumLostFrames;
    pStats->dwNumSilentFrames = m_dwNumSilentFrames;
    pStats->dwNumSpeechFrames = m_dwNumSpeechFrames;
    pStats->dwNumReceivedFrames = m_dwNumReceivedFrames;

    return;
}


HRESULT CVoicePlayer::CreateQueue( PQUEUE_PARAMS pQueueParams )
{
    HRESULT hr;

    DNEnterCriticalSection( &CDirectVoiceEngine::s_csSTLLock );

    m_lpInputQueue = new CInputQueue2();
    
    if( m_lpInputQueue == NULL )
    {
        DPFX(DPFPREP,  0, "Error allocating memory" );
        return DVERR_OUTOFMEMORY;
    }
    
    hr = m_lpInputQueue->Initialize( pQueueParams );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed initializing queue hr=0x%x", hr );
        delete m_lpInputQueue;
        m_lpInputQueue = NULL;
        return hr;
    }

    DNLeaveCriticalSection( &CDirectVoiceEngine::s_csSTLLock );

    return hr;
}

HRESULT CVoicePlayer::CreateInBoundConverter( const GUID &guidCT, PWAVEFORMATEX pwfxTargetFormat )
{
    HRESULT hr;

    hr = DVCDB_CreateConverter( guidCT, pwfxTargetFormat, &m_lpInBoundAudioConverter );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Error creating audio converter hr=0x%x" , hr );
        return hr;
    }

    if( pwfxTargetFormat->wBitsPerSample == 8)
    {
        m_dwFlags |= VOICEPLAYER_FLAGS_TARGETIS8BIT;
    }

    return hr;
}

HRESULT CVoicePlayer::DeInitialize()
{
	FreeResources();

    m_pOwner->Release( this );

    return DV_OK;
}

HRESULT CVoicePlayer::HandleReceive( PDVPROTOCOLMSG_SPEECHHEADER pdvSpeechHeader, PBYTE pbData, DWORD dwSize )
{
	CFrame tmpFrame;

	tmpFrame.SetSeqNum( pdvSpeechHeader->bSeqNum );
	tmpFrame.SetMsgNum( pdvSpeechHeader->bMsgNum );
	tmpFrame.SetIsSilence( FALSE );
	tmpFrame.SetFrameLength( dwSize );
	tmpFrame.UserOwn_SetData( pbData, dwSize );

    Lock();

	DPFX(DPFPREP,  DVF_CLIENT_SEQNUM_DEBUG_LEVEL, "SEQ: Receive: Msg [%d] Seq [%d]", pdvSpeechHeader->bMsgNum, pdvSpeechHeader->bSeqNum );		

	// STATSBLOCK: Begin
	//m_stats.m_dwPRESpeech++;
	// STATSBLOCK: End
		
	m_lpInputQueue->Enqueue( tmpFrame );
	m_dwLastData = GetTickCount();

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Received speech is buffered!" );

    m_dwNumReceivedFrames++;

    UnLock();

    return DV_OK;
}

CFrame *CVoicePlayer::Dequeue(BOOL *pfLost, BOOL *pfSilence)
{
	CFrame *frTmpFrame;

	Lock();
	frTmpFrame = m_lpInputQueue->Dequeue();
	UnLock();

    if( !frTmpFrame->GetIsSilence() )
    {
        *pfSilence = FALSE;
        m_dwLastPlayback = GetTickCount();
        m_dwNumSpeechFrames++;
    }
    else
    {
        m_dwNumSilentFrames++;
        *pfSilence = TRUE;
    }

    if( frTmpFrame->GetIsLost() )
    {
        *pfLost = TRUE;
        m_dwNumLostFrames++;
    }
    else
    {
        *pfLost = FALSE;
    }

	return frTmpFrame;
}

HRESULT CVoicePlayer::DeCompressInBound( CFrame *frCurrentFrame, PVOID pvBuffer, PDWORD pdwBufferSize )
{
	HRESULT hr;

    hr = m_lpInBoundAudioConverter->Convert( frCurrentFrame->GetDataPointer(), frCurrentFrame->GetFrameLength(), pvBuffer, pdwBufferSize, frCurrentFrame->GetIsSilence() );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed converting audio hr=0x%x", hr );
        return hr;
    }

	return hr;
}

HRESULT CVoicePlayer::GetNextFrameAndDecompress( PVOID pvBuffer, PDWORD pdwBufferSize, BOOL *pfLost, BOOL *pfSilence, DWORD *pdwSeqNum, DWORD *pdwMsgNum )
{
    CFrame *frTmpFrame;
    BYTE bLastPeak;
    HRESULT hr;

    frTmpFrame = Dequeue(pfLost,pfSilence );

	*pdwSeqNum = frTmpFrame->GetSeqNum();
	*pdwMsgNum = frTmpFrame->GetMsgNum();

	hr = DeCompressInBound( frTmpFrame, pvBuffer, pdwBufferSize );

    frTmpFrame->Return();

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  0, "Failed converting audio hr=0x%x", hr );
        return hr;
    }

	if( *pfSilence )
	{
		m_bLastPeak = 0;
	}
	else
	{
	    m_bLastPeak = FindPeak( (PBYTE) pvBuffer, *pdwBufferSize, Is8BitUnCompressed() );
	}

    return hr;
}

void CVoicePlayer::FreeResources()
{
    DNDeleteCriticalSection( &m_csLock );

    DNEnterCriticalSection( &CDirectVoiceEngine::s_csSTLLock );
    if( m_lpInputQueue != NULL )
    {
        delete m_lpInputQueue;
		m_lpInputQueue = NULL;
    }
    DNLeaveCriticalSection( &CDirectVoiceEngine::s_csSTLLock );    

    if( m_lpInBoundAudioConverter != NULL )
    {
        m_lpInBoundAudioConverter->Release();
		m_lpInBoundAudioConverter = NULL;
    }

	if( m_pdvidTargets != NULL )
	{
		delete [] m_pdvidTargets;
		m_pdvidTargets = NULL;
	}


    Reset();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CVoicePlayer::FindAndRemovePlayerTarget"
//
// FindAndRemovePlayerTarget 
//
// Searches the list of targets for this player and removes the specified player if it is part 
// of the list.  The pfFound variable is set to TRUE if the player specfied was in the target
// list, false otherwise. 
//
BOOL CVoicePlayer::FindAndRemovePlayerTarget( DVID dvidTargetToRemove )
{
	BOOL fFound = FALSE;
	
	Lock();

	for( DWORD dwTargetIndex = 0; dwTargetIndex < m_dwNumTargets; dwTargetIndex++ )
	{
		if( m_pdvidTargets[dwTargetIndex] == dvidTargetToRemove )
		{
			if( m_dwNumTargets == 1 )
			{
				delete [] m_pdvidTargets;
				m_pdvidTargets = NULL;
			}
			// Shortcut, move last element into the current element
			// prevents re-allocation.  (However, it wastes an element of 
			// target space) *Shrug*.  If this is the last element in the list
			// we're removing this will simply provide an unessessary duplication
			// of the last element.  (But num targets is correct so that's ok).
			else
			{
				m_pdvidTargets[dwTargetIndex] = m_pdvidTargets[m_dwNumTargets-1];
			}

			m_dwNumTargets--;
			
			fFound = TRUE;
			break;
		}
	}

	UnLock();

	return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvt\dxvt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxvt.cpp
 *  Content:    Full Duplex Test main program.
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 *  09/02/99	pnewson		renamed to dxvt.cpp from fdtest.cpp
 *  11/01/99	rodtoll		Bug #113726 - Voxware integration now uses COM
 *							and this module uses LoadLibrary so we require
 *							a CoInitialize() call.
 *  01/21/2000	pnewson     Running this program with no command line options
 *							now does nothing, since the cpanel is the correct
 *							launch point now.
 *  03/03/2000	rodtoll	    Updated to handle alternative gamevoice build.   
 *  04/19/2000	pnewson	    Error handling cleanup  
 *							removed obsolete retrocfg.h dependency
 *  06/28/2000	rodtoll		Prefix Bug #38026 
 *  07/12/2000	rodtoll Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 *  08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h, added STR_* and strutils.h
 *  04/02/2001	simonpow	Bug #354859 Fixes for PREfast (BOOL casts on DVGUIDFromString calls)
 *                          
 ***************************************************************************/

#include <windows.h>
#include <tchar.h>
#include <initguid.h>
#include <dplobby.h>
#include <commctrl.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include <dsprv.h>
#include "dvoice.h"

#include "creg.h"
#include "osind.h"
#include "priority.h"
#include "fulldup.h"
#include "fdtcfg.h"
#include "dndbg.h"
#include "dsound.h"
#include "supervis.h"
#include "guidutil.h"
#include "strutils.h"
#include "comutil.h"
#include "diagnos.h"

#include "..\..\bldcfg\dpvcfg.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DPVOICE_REGISTRY_DUMPDIAGNOSTICS			L"InitDiagnostics"

struct DPVSETUP_PARAMETERS
{
	BOOL fPriority;
	BOOL fFullDuplex;
	BOOL fTest;
	GUID guidRender;
	GUID guidCapture;
};

#undef DPF_MODNAME
#define DPF_MODNAME "ProcessCommandLine"
BOOL ProcessCommandLine( TCHAR *pstrCommandLine, DPVSETUP_PARAMETERS* pParameters )
{
	TCHAR *pNextToken = NULL;
	WCHAR wszGuidString[GUID_STRING_LEN];
	BOOL fRet;
	HRESULT hr=S_OK;

	DPF_ENTER();

	ZeroMemory(pParameters, sizeof(DPVSETUP_PARAMETERS));

	// default to the default voice devices
	pParameters->guidRender = DSDEVID_DefaultVoicePlayback;
	pParameters->guidCapture = DSDEVID_DefaultVoiceCapture;

	pNextToken = _tcstok(pstrCommandLine, _T(" "));

	// skip dpvsetup portion of command-line.
	pNextToken = _tcstok( NULL, _T(" ") );

	while( pNextToken != NULL )
	{
		if( _tcsicmp(pNextToken, _T("/T")) == 0 
			|| _tcsicmp(pNextToken, _T("/TEST")) == 0 
			|| _tcsicmp(pNextToken, _T("-T")) == 0 
			|| _tcsicmp(pNextToken, _T("-TEST")) == 0 
			|| _tcsicmp(pNextToken, _T("TEST")) == 0)
		{
			pParameters->fTest = TRUE;
		}
		else if(_tcsicmp(pNextToken, _T("/F")) == 0 
			|| _tcsicmp(pNextToken, _T("/FULLDUPLEX")) == 0 
			|| _tcsicmp(pNextToken, _T("-F")) == 0 
			|| _tcsicmp(pNextToken, _T("-FULLDUPLEX")) == 0 
			|| _tcsicmp(pNextToken, _T("FULLDUPLEX")) == 0)
		{
			pParameters->fFullDuplex = TRUE;
		}
		else if(_tcsicmp(pNextToken, _T("/P")) == 0 
			|| _tcsicmp(pNextToken, _T("/PRIORITY")) == 0 
			|| _tcsicmp(pNextToken, _T("-P")) == 0 
			|| _tcsicmp(pNextToken, _T("-PRIORITY")) == 0 
			|| _tcsicmp(pNextToken, _T("PRIORITY")) == 0)
		{
			pParameters->fPriority = TRUE;
		}
		else if(_tcsicmp(pNextToken, _T("/R")) == 0 
			|| _tcsicmp(pNextToken, _T("/RENDER")) == 0 
			|| _tcsicmp(pNextToken, _T("-R")) == 0 
			|| _tcsicmp(pNextToken, _T("-RENDER")) == 0)
		{
			// get the render device guid
			pNextToken = _tcstok( pstrCommandLine, _T(" ") );
			if (pNextToken != NULL)
			{
				if (_tcslen(pstrCommandLine) != GUID_STRING_LEN - 1)
				{
					// command line guid string too long, error
					DPFX(DPFPREP, DVF_ERRORLEVEL, "guid on command line wrong size");
					DPF_EXIT();
					return FALSE;
				}
				else
				{
#ifdef UNICODE
					wcscpy( wszGuidString, pNextToken );
#else
					if ( FAILED(STR_jkAnsiToWide(wszGuidString, pNextToken, GUID_STRING_LEN)))
					{
						DPFX(DPFPREP, DVF_ERRORLEVEL, "STR_jkAnsiToWide failed");
						DPF_EXIT();
						return FALSE;
					}
#endif
					
					hr=DVGUIDFromString(wszGuidString, &pParameters->guidRender);
					if (FAILED(hr))
					{
						DPFX(DPFPREP, DVF_ERRORLEVEL, "DVGUIDFromString failed");
						DPF_EXIT();
						return FALSE;
					}
				}
			}
		}
		else if( _tcsicmp(pNextToken, _T("/C")) == 0 
			|| _tcsicmp(pNextToken, _T("/CAPTURE")) == 0 
			|| _tcsicmp(pNextToken, _T("-C")) == 0 
			|| _tcsicmp(pNextToken, _T("-CAPTURE")) == 0)
		{
			// get the render device guid
			pNextToken = _tcstok( pstrCommandLine, _T(" ") );
			if (pNextToken != NULL)
			{
				if (_tcslen(pstrCommandLine) != GUID_STRING_LEN - 1)
				{
					// command line guid string too long, error
					DPFX(DPFPREP, DVF_ERRORLEVEL, "guid on command line wrong size");
					DPF_EXIT();
					return FALSE;
				}
				else
				{
#ifdef UNICODE
					wcscpy( wszGuidString, pNextToken );
#else
					if ( FAILED(STR_jkAnsiToWide(wszGuidString, pNextToken, GUID_STRING_LEN)))
					{
						DPFX(DPFPREP, DVF_ERRORLEVEL, "STR_jkAnsiToWide failed");
						DPF_EXIT();
						return FALSE;
					}
#endif
					
					hr=DVGUIDFromString(wszGuidString, &pParameters->guidCapture);
					if (FAILED(hr))
					{
						DPFX(DPFPREP, DVF_ERRORLEVEL, "DVGUIDFromString failed");
						DPF_EXIT();
						return FALSE;
					}
				}
			}
		}
		else
		{
			DPF_EXIT();
			return FALSE;
		}
		
		pNextToken = _tcstok( NULL, _T(" ") );
	}

	// check to make sure only one of test, fullduplex, or priority was specified.
	int i = 0;
	if (pParameters->fTest)
	{
		++i;
	}
	if (pParameters->fFullDuplex)
	{
		++i;
	}
	if (pParameters->fPriority)
	{
		++i;
	}
	if (i > 1)
	{
		DPF_EXIT();
		return FALSE;
	}

	DPF_EXIT();
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetDiagnosticsSetting"
BOOL GetDiagnosticsSetting()
{
	CRegistry cregSettings;

	BOOL fResult = FALSE;

	if( !cregSettings.Open( HKEY_CURRENT_USER, DPVOICE_REGISTRY_BASE, FALSE, TRUE ) )
	{
		return FALSE;
	}

	cregSettings.ReadBOOL( DPVOICE_REGISTRY_DUMPDIAGNOSTICS, fResult );

	return fResult;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WinMain"
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, CHAR *szOriginalCmdLine, int iCmdShow)
{
	HINSTANCE hResDLLInstance = NULL;
	HRESULT hr;
	DPVSETUP_PARAMETERS dpvsetupParam;
	BOOL fCoInitialized = FALSE;
	BOOL fDNOSInitialized = FALSE;
	BOOL fDiagnostics = FALSE; 
	TCHAR *szCmdLine = GetCommandLine();

	DPF_ENTER();

	hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		MessageBox( NULL, _T("Error initializing COM"), _T("Error"), MB_OK|MB_ICONERROR);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	fCoInitialized = TRUE;

	if (!DNOSIndirectionInit())
	{
		MessageBox( NULL, _T("Error initializing OS indirection layer"), _T("Error"), MB_OK|MB_ICONERROR);
		hr = DVERR_OUTOFMEMORY;
		goto error_cleanup;
	}
	fDNOSInitialized = TRUE;

	fDiagnostics = GetDiagnosticsSetting();

	if (!ProcessCommandLine(szCmdLine, &dpvsetupParam))
	{
		MessageBox(NULL, _T("Bad Command Line Parameters"), _T("Error"), MB_OK|MB_ICONERROR);
		hr = DVERR_INVALIDPARAM;
		goto error_cleanup;
	}

	hResDLLInstance = LoadLibraryA(gc_szResDLLName);
	if (hResDLLInstance == NULL)
	{
		MessageBox(NULL, _T("Unable to load resource DLL - exiting program"), _T("Error"), MB_OK|MB_ICONERROR);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	if (dpvsetupParam.fPriority)
	{
		// This process is the one that opens dsound in 
		// priority mode and sets the primary buffer to various 
		// formats.
		// use SEH to clean up any really nasty errors
		__try
		{
			Diagnostics_Begin( fDiagnostics, "dpv_pri.txt" );
			
			hr = PriorityProcess(hResDLLInstance, hPrevInstance, szCmdLine, iCmdShow);

			Diagnostics_End();

		}
		__except(1)
		{
			hr = DVERR_GENERIC;
		}
		if( FAILED( hr ) )
		{
			goto error_cleanup;		
		}
	}
	else if (dpvsetupParam.fFullDuplex)
	{
		// This process is the one that performs the full duplex
		// testing, in conjunction with the other process that
		// sets the primary buffer format.
		// use SEH to clean up any really nasty errors
		__try
		{
			Diagnostics_Begin( fDiagnostics, "dpv_fd.txt" );

			hr = FullDuplexProcess(hResDLLInstance, hPrevInstance, szCmdLine, iCmdShow);

			Diagnostics_End();
		}
		__except(1)
		{
			hr = DVERR_GENERIC;
		}
		if( FAILED( hr ) )
		{
			goto error_cleanup;		
		}
	}
	else if (dpvsetupParam.fTest)
	{
		Diagnostics_Begin( fDiagnostics, "dpv_sup.txt" );

		// The user wants this program to run the whole test on the default
		// voice devices.
		hr = SupervisorCheckAudioSetup(&dpvsetupParam.guidRender, &dpvsetupParam.guidCapture, NULL, 0);

		Diagnostics_End();

		if( FAILED( hr ) )
		{
			goto error_cleanup;		
		}
	}
	
	// With no command line parameters, this process does nothing.
	// You must know the secret handshake to get it to do something.

	// no error checking, since we're on our way out anyway
	FreeLibrary(hResDLLInstance);
	hResDLLInstance = NULL;
	DNOSIndirectionDeinit();
	fDNOSInitialized = FALSE;
	COM_CoUninitialize();
	fCoInitialized = FALSE;
	DPF_EXIT();
	return DV_OK;
	
error_cleanup:

	if (hResDLLInstance != NULL)
	{
		FreeLibrary(hResDLLInstance);
		hResDLLInstance = NULL;
	}

	if (fDNOSInitialized == TRUE)
	{
		DNOSIndirectionDeinit();
		fDNOSInitialized = FALSE;
	}

	if (fCoInitialized == TRUE)
	{
		COM_CoUninitialize();
		fCoInitialized = FALSE;
	}

	DPF_EXIT();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\dxvtlibpch.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxvtlibpch.h
 *  Content:    DirectPlayVoice DXVTLIB master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DXVTLIBPCH_H__
#define __DXVTLIBPCH_H__

// 
// Public includes
//
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#include <stdio.h>
#ifndef WIN95
#include <prsht.h>
#include <shfusion.h>
#endif
#include <commctrl.h>

// 
// DirectX public includes
//
#include "dsound.h"
#include "dsprv.h"

// 
// DirectPlay public includes
//
#include "dvoice.h"
#include "dplay8.h"

// 
// DirectPlay4 public includes
//
//#include "dplay.h"
//#include "dplobby.h"

// 
// DirectPlay private includes
//
#include "osind.h"
#include "dndbg.h"
#include "guidutil.h"
#include "comutil.h"
#include "creg.h"

// 
// DirectPlay Voice private includes
//
#include "winutil.h"
#include "decibels.h"
#include "diagnos.h"
#include "devmap.h"
#include "dverror.h"

// 
// Voice includes
//
#include "fdtcfg.h"
#include "fdtipc.h"
#include "fulldup.h"
#include "fdtglob.h"
#include "loopback.h"
#include "peakmetr.h"
#include "resource.h"
#include "supervis.h"

#include "..\..\..\bldcfg\dpvcfg.h"

#endif // __DXVTLIBPCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvt\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

!INCLUDE ..\..\..\bldcfg\dpvbld.inc

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=$(DPVOICE_BUILD_FILENAME_DPVSETUP)


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=PROGRAM
UMENTRY=winmain
UMTYPE=windows

# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.DirectX.DPVSETUP
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=dpvsetup.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1


#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	  ..\..\..\dnet\common\obj$(BUILD_ALT_DIR)\*\common.lib \
          ..\..\guids\obj$(BUILD_ALT_DIR)\*\guids.lib \
	  ..\..\dxvutils\obj$(BUILD_ALT_DIR)\*\dxvutils.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\dsound.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\imagehlp.lib \
	   $(BASEDIR)\public\sdk\lib\*\comctl32.lib \
	   $(BASEDIR)\public\sdk\lib\*\shell32.lib \
!if "$(CHICAGO_PRODUCT)" == ""
           ..\..\dxvtlib\daytona\obj$(BUILD_ALT_DIR)\*\dxvt.lib \
!else
           ..\..\dxvtlib\win9x\obj$(BUILD_ALT_DIR)\*\dxvt.lib \
!endif
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib
	

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=.;$(DXROOT)\inc;..\..\dxvtlib;..\..\..\dnet\common;..\..\inc;..\..\dxvoice;..\..\dxvutils;$(DXROOT)\private\inc


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= \
	..\dxvt.cpp \
        ..\dxvt.rc


#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_WINDOWS /DWIN32 /D_MT /D_DLL /DCINTERFACE \
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(CHICAGO_PRODUCT)" == ""
	/D_UNICODE /DUNICODE \
!endif
!if "$(VOICE_TARGET)" == "allegiance" 
	/DVOICE_BUILD_ALLEGIANCE \
!endif
	/DDIRECTSOUND_VERSION=0x0800

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fdtglob.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fdtglob.cpp
 *  Content:    Declares global variables used for IPC mechanisms.
 *  History:
 *	Date   By  Reason
 *	============
 *	08/25/99	pnewson		created
 ***************************************************************************/

#include "dxvtlibpch.h"
 

// the critical section to guard these globals
DNCRITICAL_SECTION g_csGuard;

// the DirectSound objects
LPDIRECTSOUND g_lpdsPriorityRender = NULL;
LPDIRECTSOUND g_lpdsFullDuplexRender = NULL;
LPDIRECTSOUNDCAPTURE g_lpdscFullDuplexCapture = NULL;
LPDIRECTSOUNDBUFFER g_lpdsbPriorityPrimary = NULL;
LPDIRECTSOUNDBUFFER g_lpdsbPrioritySecondary = NULL;
LPDIRECTSOUNDBUFFER g_lpdsbFullDuplexSecondary = NULL;
LPDIRECTSOUNDNOTIFY g_lpdsnFullDuplexSecondary = NULL;
HANDLE g_hFullDuplexRenderEvent = NULL;
LPDIRECTSOUNDCAPTUREBUFFER g_lpdscbFullDuplexCapture = NULL;
LPDIRECTSOUNDNOTIFY g_lpdsnFullDuplexCapture = NULL;
HANDLE g_hFullDuplexCaptureEvent = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fdtcfg.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fdtcfg.cpp
 *  Content:    Configuration of the full duplex test app
 *  History:
 *	Date   By  Reason
 *	============
 *	08/20/99	pnewson		created
 *  10/28/99	pnewson 	Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/04/99	pnewson 	Bug #115279 removed unused const global
 *										fixed infinite timeouts
 *  11/30/99	pnewson		default device mapping support
 *  01/21/2000	pnewson		changed registry key names
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/18/2000  rodtoll     Bug #32649 Voice wizard failing 
 *                          Changed secondary format for tests from stereo --> mono
 *
 ***************************************************************************/

#include "dxvtlibpch.h"


// the name of the DLL where the direct voice functions reside
const char gc_szDVoiceDLLName[] = DPVOICE_FILENAME_DPVOICE_A;

// the name of the DLL where the required resources are (could be different
// from the DLL above, hence the second name...)
const char gc_szResDLLName[] = DPVOICE_FILENAME_RES_A;

// the name of the DirectSound DLL
const char gc_szDSoundDLLName[] = "dsound.dll";

// the name of the GetDeviceID DirectSound function
const char gc_szGetDeviceIDFuncName[] = "GetDeviceID";

// command line related definitions
const TCHAR gc_szPriorityCommand[] = DPVOICE_COMMANDLINE_PRIORITY;
const TCHAR gc_szFullDuplexCommand[] = DPVOICE_COMMANDLINE_FULLDUPLEX;

// registry related definitions
const WCHAR gc_wszKeyName_AudioConfig[] = DPVOICE_REGISTRY_BASE DPVOICE_REGISTRY_AUDIOCONFIG;
const WCHAR gc_wszValueName_Started[] = L"Started";
const WCHAR gc_wszValueName_FullDuplex[] = L"FullDuplex";
const WCHAR gc_wszValueName_HalfDuplex[] = L"HalfDuplex";
const WCHAR gc_wszValueName_MicDetected[] = L"MicDetected";

// the name of the mutex used to ensure only one app instance 
// uses a GUID to ensure uniqueness
const TCHAR gc_szMutexName[] = _T("A5EBE0E0-57B5-4e8f-AE94-976EAD62355C");

// the event names
// uses GUIDs to ensure uniqueness
const TCHAR gc_szPriorityEventName[] = _T("85D97F8C-7131-4d14-95E2-056843FADC34");
const TCHAR gc_szFullDuplexEventName[] = _T("CB6DD850-BA0A-4e9f-924A-8FECAFCF502F");
const TCHAR gc_szPriorityReplyEventName[] = _T("C4AEDED9-7B39-46db-BFF2-DE19A766B42B");
const TCHAR gc_szFullDuplexReplyEventName[] = _T("53E6CF94-CE39-40a5-9BEF-EB5DE9307A77");

// The shared memory names and sizes. Again, guids for names
// Shared memory sizes do not need to be big. We're just passing
// back and forth some WAVEFORMATEX structures and return codes.
// 1 k should be more than adequate.
const TCHAR gc_szPriorityShMemName[] = _T("E814F4FC-5DAC-4149-8B98-8899A1BF66A7");
const DWORD gc_dwPriorityShMemSize = 1024;
const TCHAR gc_szFullDuplexShMemName[] = _T("3CBCA2AD-C462-4f3a-85FE-9766D02E5E53");
const DWORD gc_dwFullDuplexShMemSize = 1024;

// the send mutex names
const TCHAR gc_szPrioritySendMutex[] = _T("855EF6EE-48D4-4968-8D3D-8D29E865E370");
const TCHAR gc_szFullDuplexSendMutex[] = _T("05DACF95-EFE9-4f3c-9A92-2A7F5C2A7A51");

// the error message and caption to use if the FormatMessage function fails
const TCHAR gc_szUnknownMessage[] 
	= _T("An error has occured, but the program was unable to retrive the text of the error message");
const TCHAR gc_szUnknownMessageCaption[]
	= _T("Error");

// While there is officially a global for each timeout, they are all
// the same value right now. This define is here to make it simple
// to change the timeouts to INFINITE and back for debugging.
//
// Uncomment the timeout you want to use.
#ifdef DEBUG
#define GENERIC_TIMEOUT 10000
//#define GENERIC_TIMEOUT INFINITE
#else
#define GENERIC_TIMEOUT 10000
#endif

// The number of milliseconds we will wait for the child processes
// to exit before we timeout.
const DWORD gc_dwChildWaitTimeout = GENERIC_TIMEOUT;

// The number of milliseconds we will wait for the child processes
// to startup and signal the supervisor before we timeout.
const DWORD gc_dwChildStartupTimeout = GENERIC_TIMEOUT;

// The number of milliseconds a process will wait to receive a command,
// or wait for the reply from a command.
const DWORD gc_dwCommandReceiveTimeout = GENERIC_TIMEOUT;
const DWORD gc_dwCommandReplyTimeout = GENERIC_TIMEOUT;

// The number of milliseconds a process will wait to acquire the
// mutex used to make a SendCommand() call.
const DWORD gc_dwSendMutexTimeout = GENERIC_TIMEOUT;

// The number of milliseconds to wait for a dialog box to spawn
const DWORD gc_dwDialogTimeout = GENERIC_TIMEOUT;

// In the loopback test, how long to wait for the loopback test
// thread proc to exit.
const DWORD gc_dwLoopbackTestThreadTimeout = GENERIC_TIMEOUT;

// The number of milliseconds of audio in a DirectSound buffer
const DWORD gc_dwFrameSize = 50;

// The array of wave formats to try
const WAVEFORMATEX gc_rgwfxPrimaryFormats[] =
{
	{ WAVE_FORMAT_PCM, 2, 44100, 4*44100, 4, 16, 0 },
	{ WAVE_FORMAT_PCM, 2, 22050, 4*22050, 4, 16, 0 },
	{ WAVE_FORMAT_PCM, 2, 11025, 4*11025, 4, 16, 0 },
	{ WAVE_FORMAT_PCM, 2,  8000, 4* 8000, 4, 16, 0 },
	{ WAVE_FORMAT_PCM, 1, 44100, 2*44100, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1, 22050, 2*22050, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1, 11025, 2*11025, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1,  8000, 2* 8000, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 2, 44100, 2*44100, 2,  8, 0 },
	{ WAVE_FORMAT_PCM, 2, 22050, 2*22050, 2,  8, 0 },
	{ WAVE_FORMAT_PCM, 2, 11025, 2*11025, 2,  8, 0 },
	{ WAVE_FORMAT_PCM, 2,  8000, 2* 8000, 2,  8, 0 },
	{ WAVE_FORMAT_PCM, 1, 44100, 1*44100, 1,  8, 0 },
	{ WAVE_FORMAT_PCM, 1, 22050, 1*22050, 1,  8, 0 },
	{ WAVE_FORMAT_PCM, 1, 11025, 1*11025, 1,  8, 0 },
	{ WAVE_FORMAT_PCM, 1,  8000, 1* 8000, 1,  8, 0 },
	{ 0, 0, 0, 0, 0, 0, 0 } // Note: make sure this remains the last format!
};
	
const WAVEFORMATEX gc_wfxSecondaryFormat =	
	{ WAVE_FORMAT_PCM, 1,  22050, 2* 22050, 2, 16, 0 };
	
const WAVEFORMATEX gc_rgwfxCaptureFormats[] =
{
	{ WAVE_FORMAT_PCM, 1,  8000, 2* 8000, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1, 11025, 2*11025, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1, 22050, 2*22050, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1, 44100, 2*44100, 2, 16, 0 },
	{ WAVE_FORMAT_PCM, 1,  8000, 1* 8000, 1,  8, 0 },
	{ WAVE_FORMAT_PCM, 1, 11025, 1*11025, 1,  8, 0 },
	{ WAVE_FORMAT_PCM, 1, 22050, 1*22050, 1,  8, 0 },
	{ WAVE_FORMAT_PCM, 1, 44100, 1*44100, 1,  8, 0 },
	{ 0, 0, 0, 0, 0, 0, 0 } // Note: make sure this remains the last format!
};

// the devices to test if the user passes null to CheckAudioSetup
const GUID gc_guidDefaultCaptureDevice = GUID_NULL;
const GUID gc_guidDefaultRenderDevice = GUID_NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fdtglob.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fdtglob.h
 *  Content:    Declares global variables used for IPC mechanisms.
 *  History:
 *	Date   By  Reason
 *	============
 *	08/25/99	pnewson		created
 *  09/14/99	pnewson		converted from raw globals to classes
 ***************************************************************************/

#ifndef _FDTGLOB_H_
#define _FDTGLOB_H_
 
// the critical section to guard these globals
extern DNCRITICAL_SECTION g_csGuard;

// the macros used to manipulate this guard
//#define InitGlobGuard() 	DPFX(DPFPREP, 5, "InitGuard"), DNInitializeCriticalSection(&g_csGuard)
#define InitGlobGuard() 	DNInitializeCriticalSection(&g_csGuard)
#define DeinitGlobGuard() 	DNDeleteCriticalSection(&g_csGuard)
#define GlobGuardIn() 		DNEnterCriticalSection(&g_csGuard)
#define GlobGuardOut() 		DNLeaveCriticalSection(&g_csGuard)

// the DirectSound objects
extern LPDIRECTSOUND g_lpdsPriorityRender;
extern LPDIRECTSOUND g_lpdsFullDuplexRender;
extern LPDIRECTSOUNDCAPTURE g_lpdscFullDuplexCapture;
extern LPDIRECTSOUNDBUFFER g_lpdsbPriorityPrimary;
extern LPDIRECTSOUNDBUFFER g_lpdsbPrioritySecondary;
extern LPDIRECTSOUNDBUFFER g_lpdsbFullDuplexSecondary;
extern LPDIRECTSOUNDNOTIFY g_lpdsnFullDuplexSecondary;
extern HANDLE g_hFullDuplexRenderEvent;
extern LPDIRECTSOUNDCAPTUREBUFFER g_lpdscbFullDuplexCapture;
extern LPDIRECTSOUNDNOTIFY g_lpdsnFullDuplexCapture;
extern HANDLE g_hFullDuplexCaptureEvent;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fdtcfg.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fdtcfg.h
 *  Content:    Definitions the configure the full duplex test app
 *  History:
 *	Date   By  Reason
 *	============
 *	08/20/99	pnewson		created
 *  10/28/99	pnewson 	Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/04/99	pnewson 	Bug #115279 removed unused const global
 *  11/30/99	pnewson		default device mapping support
 *  01/21/2000	pnewson		changed registry key names
 *
 ***************************************************************************/

#ifndef _FDTCFG_H_
#define _FDTCFG_H_

// the name of the DLL where the direct voice functions reside
extern const char gc_szDVoiceDLLName[];

// the name of the DLL where the required resources are
extern const char gc_szResDLLName[];

// the name of the DirectSound DLL
extern const char gc_szDSoundDLLName[];

// the name of the GetDeviceID DirectSound function
extern const char gc_szGetDeviceIDFuncName[];

// command line related definitions
extern const TCHAR gc_szPriorityCommand[];
extern const TCHAR gc_szFullDuplexCommand[];

// registry related definitions
extern const WCHAR gc_wszKeyName_AudioConfig[];
extern const WCHAR gc_wszValueName_Started[];
extern const WCHAR gc_wszValueName_FullDuplex[];
extern const WCHAR gc_wszValueName_HalfDuplex[];
extern const WCHAR gc_wszValueName_MicDetected[];


// the name of the mutex used to ensure only one app instance 
extern const TCHAR gc_szMutexName[];

// the event names
extern const TCHAR gc_szPriorityEventName[];
extern const TCHAR gc_szFullDuplexEventName[];
extern const TCHAR gc_szPriorityReplyEventName[];
extern const TCHAR gc_szFullDuplexReplyEventName[];

// the shared memory names, and sizes
extern const TCHAR gc_szPriorityShMemName[];
extern const DWORD gc_dwPriorityShMemSize;
extern const TCHAR gc_szFullDuplexShMemName[];
extern const DWORD gc_dwFullDuplexShMemSize;

// the send mutex names
extern const TCHAR gc_szPrioritySendMutex[];
extern const TCHAR gc_szFullDuplexSendMutex[];

// the error message and caption to use if the FormatMessage function fails
extern const TCHAR gc_szUnknownMessage[]; 
extern const TCHAR gc_szUnknownMessageCaption[];

// The largest string we will accept from a string resource
// or the system message table
#define MAX_STRING_RESOURCE_SIZE 512

// The number of milliseconds we will wait for the child processes
// to exit before we timeout.
extern const DWORD gc_dwChildWaitTimeout;

// The number of milliseconds we will wait for the child processes
// to startup and signal the supervisor before we timeout.
extern const DWORD gc_dwChildStartupTimeout;

// The number of milliseconds a process will wait for receive
// and reply signals
extern const DWORD gc_dwCommandReceiveTimeout;
extern const DWORD gc_dwCommandReplyTimeout;

// The number of milliseconds a process will wait to acquire the
// mutex used to make a SendCommand() call.
extern const DWORD gc_dwSendMutexTimeout;

// The number of milliseconds to wait for a dialog box to spawn
extern const DWORD gc_dwDialogTimeout;

// The number of milliseconds of audio in a DirectSound buffer
extern const DWORD gc_dwFrameSize;

// The wave formats to try
extern const WAVEFORMATEX gc_rgwfxPrimaryFormats[];
extern const WAVEFORMATEX gc_wfxSecondaryFormat;
extern const WAVEFORMATEX gc_rgwfxCaptureFormats[];

// In the loopback test, how long to wait for the loopback test
// thread proc to exit.
extern const DWORD gc_dwLoopbackTestThreadTimeout;

// the devices to test if the user passes null to CheckAudioSetup
extern const GUID gc_guidDefaultCaptureDevice;
extern const GUID gc_guidDefaultRenderDevice;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fdtipc.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fdtipc.cpp
 *  Content:    Implements the IPC calls for the full duplex test
 *  History:
 *	Date   By  Reason
 *	============
 *	08/26/99	pnewson		created
 *  04/19/2000	pnewson	    Error handling cleanup  
 *  06/28/2000	rodtoll	Prefix Bug #38022
 ***************************************************************************/

#include "dxvtlibpch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// static helper functions for this file
HRESULT DoReceive(
	SFDTestCommand* pfdtc,
	HANDLE hEvent,
	HANDLE hReplyEvent,
	LPVOID lpvShMemPtr);
	
HRESULT DoReply(HRESULT hr, HANDLE hReplyEvent, LPVOID lpvShMemPtr);

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::CSupervisorIPC"
CSupervisorIPC::CSupervisorIPC()
	: m_fInitComplete(FALSE)
	, m_hFullDuplexEvent(NULL)
	, m_hFullDuplexMutex(NULL)
	, m_hFullDuplexReplyEvent(NULL)
	, m_hFullDuplexShMemHandle(NULL)
	, m_hPriorityEvent(NULL)
	, m_hPriorityMutex(NULL)
	, m_hPriorityReplyEvent(NULL)
	, m_hPriorityShMemHandle(NULL)
	, m_lpvFullDuplexShMemPtr(NULL)
	, m_lpvPriorityShMemPtr(NULL)
{
	ZeroMemory(&m_piFullDuplex, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&m_piPriority, sizeof(PROCESS_INFORMATION));
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::Init"
HRESULT CSupervisorIPC::Init()
{
	LONG lRet;
	HRESULT hr;

	DPF_ENTER();

	if (!DNInitializeCriticalSection(&m_csLock))
	{
		return DVERR_OUTOFMEMORY;
	}

	DNEnterCriticalSection(&m_csLock);

	if (m_fInitComplete != FALSE)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// create the event objects - make sure they don't already 
	// exist!
	m_hPriorityEvent = CreateEvent(NULL, FALSE, FALSE, gc_szPriorityEventName);
	lRet = GetLastError();
	if (m_hPriorityEvent == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hFullDuplexEvent = CreateEvent(NULL, FALSE, FALSE, gc_szFullDuplexEventName);
	lRet = GetLastError();
	if (m_hFullDuplexEvent == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hPriorityReplyEvent = CreateEvent(NULL, FALSE, FALSE, gc_szPriorityReplyEventName);
	lRet = GetLastError();
	if (m_hPriorityReplyEvent == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hFullDuplexReplyEvent = CreateEvent(NULL, FALSE, FALSE, gc_szFullDuplexReplyEventName);
	lRet = GetLastError();
	if (m_hFullDuplexReplyEvent == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// create the shared memory blocks
	m_hPriorityShMemHandle = CreateFileMapping(
		INVALID_HANDLE_VALUE, 
		NULL,
		PAGE_READWRITE,
		0,
		gc_dwPriorityShMemSize,
		gc_szPriorityShMemName);
	lRet = GetLastError();
	if (m_hPriorityShMemHandle == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	m_lpvPriorityShMemPtr = MapViewOfFile(
		m_hPriorityShMemHandle,
		FILE_MAP_WRITE,
		0,
		0,
		gc_dwPriorityShMemSize);
	if (m_lpvPriorityShMemPtr == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	m_hFullDuplexShMemHandle = CreateFileMapping(
		INVALID_HANDLE_VALUE, 
		NULL,
		PAGE_READWRITE,
		0,
		gc_dwFullDuplexShMemSize,
		gc_szFullDuplexShMemName);
	lRet = GetLastError();
	if (m_hFullDuplexShMemHandle == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	m_lpvFullDuplexShMemPtr = MapViewOfFile(
		m_hFullDuplexShMemHandle,
		FILE_MAP_WRITE,
		0,
		0,
		gc_dwFullDuplexShMemSize);
	if (m_lpvFullDuplexShMemPtr == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// create the send mutexes
	m_hPriorityMutex = CreateMutex(NULL, FALSE, gc_szPrioritySendMutex);
	lRet = GetLastError();
	if (m_hPriorityMutex == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hFullDuplexMutex = CreateMutex(NULL, FALSE, gc_szFullDuplexSendMutex);
	lRet = GetLastError();
	if (m_hFullDuplexMutex == NULL)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	m_fInitComplete = TRUE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (m_hFullDuplexMutex != NULL)
	{
		CloseHandle(m_hFullDuplexMutex);
		m_hFullDuplexMutex = NULL;
	}

	if (m_hPriorityMutex != NULL)
	{
		CloseHandle(m_hPriorityMutex);
		m_hPriorityMutex = NULL;
	}

	if (m_lpvFullDuplexShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvFullDuplexShMemPtr);
		m_lpvFullDuplexShMemPtr = NULL;
	}

	if (m_hFullDuplexShMemHandle != NULL)
	{
		CloseHandle(m_hFullDuplexShMemHandle);
		m_hFullDuplexShMemHandle = NULL;
	}

	if (m_lpvPriorityShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvPriorityShMemPtr);
		m_lpvPriorityShMemPtr = NULL;
	}

	if (m_hPriorityShMemHandle != NULL)
	{
		CloseHandle(m_hPriorityShMemHandle);
		m_hPriorityShMemHandle = NULL;
	}

	if (m_hFullDuplexReplyEvent != NULL)
	{
		CloseHandle(m_hFullDuplexReplyEvent);
		m_hFullDuplexReplyEvent = NULL;
	}

	if (m_hPriorityReplyEvent != NULL)
	{
		CloseHandle(m_hPriorityReplyEvent);
		m_hPriorityReplyEvent = NULL;
	}

	if (m_hFullDuplexEvent != NULL)
	{
		CloseHandle(m_hFullDuplexEvent);
		m_hFullDuplexEvent = NULL;
	}

	if (m_hPriorityEvent != NULL)
	{
		CloseHandle(m_hPriorityEvent);
		m_hPriorityEvent = NULL;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::Deinit"
HRESULT CSupervisorIPC::Deinit()
{
	LONG lRet;
	HRESULT hr = DV_OK;

	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);

	if (m_fInitComplete != TRUE)
	{
		hr = DVERR_NOTINITIALIZED;
	}
	m_fInitComplete = FALSE;

	if (m_hFullDuplexMutex != NULL)
	{
		CloseHandle(m_hFullDuplexMutex);
		m_hFullDuplexMutex = NULL;
	}

	if (m_hPriorityMutex != NULL)
	{
		CloseHandle(m_hPriorityMutex);
		m_hPriorityMutex = NULL;
	}

	if (m_lpvFullDuplexShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvFullDuplexShMemPtr);
		m_lpvFullDuplexShMemPtr = NULL;
	}

	if (m_hFullDuplexShMemHandle != NULL)
	{
		CloseHandle(m_hFullDuplexShMemHandle);
		m_hFullDuplexShMemHandle = NULL;
	}

	if (m_lpvPriorityShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvPriorityShMemPtr);
		m_lpvPriorityShMemPtr = NULL;
	}

	if (m_hPriorityShMemHandle != NULL)
	{
		CloseHandle(m_hPriorityShMemHandle);
		m_hPriorityShMemHandle = NULL;
	}

	if (m_hFullDuplexReplyEvent != NULL)
	{
		CloseHandle(m_hFullDuplexReplyEvent);
		m_hFullDuplexReplyEvent = NULL;
	}

	if (m_hPriorityReplyEvent != NULL)
	{
		CloseHandle(m_hPriorityReplyEvent);
		m_hPriorityReplyEvent = NULL;
	}

	if (m_hFullDuplexEvent != NULL)
	{
		CloseHandle(m_hFullDuplexEvent);
		m_hFullDuplexEvent = NULL;
	}

	if (m_hPriorityEvent != NULL)
	{
		CloseHandle(m_hPriorityEvent);
		m_hPriorityEvent = NULL;
	}

	DNLeaveCriticalSection(&m_csLock);

	DNDeleteCriticalSection(&m_csLock);

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::SendToPriority"
HRESULT CSupervisorIPC::SendToPriority(const SFDTestCommand *pfdtc)
{
	HRESULT hr;

	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);

	hr = DoSend(
		pfdtc,
		m_piPriority.hProcess,
		m_hPriorityEvent,
		m_hPriorityReplyEvent,
		m_lpvPriorityShMemPtr,
		m_hPriorityMutex);

	DNLeaveCriticalSection(&m_csLock);

	DPF_EXIT();
	
	return hr;
}		

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::SendToFullDuplex"
HRESULT CSupervisorIPC::SendToFullDuplex(const SFDTestCommand *pfdtc)
{
	HRESULT hr;

	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);

	hr = DoSend(
		pfdtc,
		m_piFullDuplex.hProcess,
		m_hFullDuplexEvent,
		m_hFullDuplexReplyEvent,
		m_lpvFullDuplexShMemPtr,
		m_hFullDuplexMutex);

	DNLeaveCriticalSection(&m_csLock);

	DPF_EXIT();
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::DoSend"
HRESULT CSupervisorIPC::DoSend(
	const SFDTestCommand* pfdtc,
	HANDLE hProcess,
	HANDLE hEvent,
	HANDLE hReplyEvent,
	LPVOID lpvShMemPtr,
	HANDLE hMutex)
{
	DWORD dwRet;
	LONG lRet;
	HRESULT hr;
	HANDLE hWaitArray[2];
	BOOL fHaveMutex = FALSE;

	DPF_ENTER();

	// grab the mutex
	dwRet = WaitForSingleObject(hMutex, gc_dwSendMutexTimeout);
	if (dwRet != WAIT_OBJECT_0)
	{
		if (dwRet == WAIT_TIMEOUT)
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Timed out waiting for send mutex");
			hr = DVERR_TIMEOUT;
			goto error_cleanup;
		}
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Error waiting for send mutex, code: %i", lRet);
		hr = DVERR_WIN32;
		goto error_cleanup;
	}
	fHaveMutex = TRUE;

	// copy the command into shared memory
	CopyMemory(lpvShMemPtr, pfdtc, pfdtc->dwSize);

	// signal the event
	if (!SetEvent(hEvent))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to set event, code: %i", lRet);
		hr = DVERR_WIN32;
		goto error_cleanup;
	}

	// Wait for the reply event - note that we only expect the
	// supervisor process to call this function, and therefore
	// we don't check for directsound events occuring during this
	// time.
	// Also, wait on the process handle, if the process we are sending
	// to exits, we'll want to continue right away, not wait for a timeout.
	hWaitArray[0] = hReplyEvent;
	hWaitArray[1] = hProcess;
	dwRet = WaitForMultipleObjects(2, hWaitArray, FALSE, gc_dwCommandReplyTimeout);
	switch(dwRet)
	{
	case WAIT_OBJECT_0:
		// The other process replied, move along.
		break;

	case WAIT_OBJECT_0+1:
		// The other process exited!
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Process exited while waiting for reply");
		hr = DVERR_TIMEOUT;
		goto error_cleanup;

	case WAIT_TIMEOUT:
		// The other process did not reply in a reasonable amount of time.
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Timed out waiting for reply to command");
		hr = DVERR_TIMEOUT;
		goto error_cleanup;

	default:
		// No idea what happened here...
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Error waiting for reply event, code: %i", dwRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	// get the reply code (an HRESULT) from shared memory
	hr = *(HRESULT*)lpvShMemPtr;

	// release the mutex
	if (!ReleaseMutex(hMutex))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Error releasing mutex, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	DPF_EXIT();
	return hr;

error_cleanup:
	if (hMutex != NULL)
	{
		ReleaseMutex(hMutex);
	}
	
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::StartPriorityProcess"
HRESULT CSupervisorIPC::StartPriorityProcess()
{
	STARTUPINFO si;
	DPF_ENTER();

	TCHAR szPriorityCommandLine[_MAX_PATH+1];

	DNEnterCriticalSection(&m_csLock);
	
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	_tcsncpy( szPriorityCommandLine, gc_szPriorityCommand, _MAX_PATH );
	szPriorityCommandLine[_MAX_PATH] = 0;

	if (!CreateProcess(
		NULL,
		(LPTSTR) szPriorityCommandLine,
		NULL,
		NULL,
		FALSE,
		0,
		NULL,
		NULL,
		&si,
		&m_piPriority))
	{
		m_piPriority.hProcess = NULL;
		m_piPriority.hThread = NULL;
		DNLeaveCriticalSection(&m_csLock);
		DPF_EXIT();
		return DVERR_WIN32;
	}

	// don't need the thread handle
	if (!CloseHandle(m_piPriority.hThread))
	{
		m_piPriority.hThread = NULL;
		DNLeaveCriticalSection(&m_csLock);
		DPF_EXIT();
		return DVERR_WIN32;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::WaitOnChildren"
HRESULT CSupervisorIPC::WaitOnChildren()
{
	HANDLE rghChildren[2];
	DWORD dwRet;
	LONG lRet;
	HRESULT hr = DV_OK;
	BOOL fRet;

	DPF_ENTER();
	
	DNEnterCriticalSection(&m_csLock);
	rghChildren[0] = m_piPriority.hProcess;
	rghChildren[1] = m_piFullDuplex.hProcess;
	DNLeaveCriticalSection(&m_csLock);
	
	dwRet = WaitForMultipleObjects(2, rghChildren, TRUE, gc_dwChildWaitTimeout);
	if (dwRet == WAIT_TIMEOUT)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "WaitForMultipleObjects timed out waiting on child process handles");
		DPF_EXIT();
		return DVERR_CHILDPROCESSFAILED;
	}
	else if (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_OBJECT_0 + 1)
	{
		// This is the expected behavior. The processes shut down
		// gracefully. Close and NULL out our handles to them.
		// Note that just because the process shut down gracefully,
		// that does not mean that it did not have an error. The
		// process returns an HRESULT for it's exit code. Check it.
		// Note that this code assumes HRESULTS are DWORDS. Hopefully
		// this won't break in Win64!
		DNEnterCriticalSection(&m_csLock);		
		fRet = GetExitCodeProcess(m_piPriority.hProcess, (LPDWORD)&hr);
		if (!fRet || FAILED(hr))
		{
			lRet = GetLastError();
			CloseHandle(m_piPriority.hProcess);
			CloseHandle(m_piFullDuplex.hProcess);
			m_piPriority.hProcess = NULL;
			m_piFullDuplex.hProcess = NULL;
			DNLeaveCriticalSection(&m_csLock);
			if (!fRet && SUCCEEDED(hr))
			{
				DPFX(DPFPREP, DVF_ERRORLEVEL, "GetExitCodeProcess failed, lRet: %i", lRet);
				DPF_EXIT();
				return DVERR_GENERIC;
			}
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Priority Process exited with error code, hr: %i", hr);
			DPF_EXIT();
			return hr;
		}
		
		if (!CloseHandle(m_piPriority.hProcess))
		{
			lRet = GetLastError();
			CloseHandle(m_piFullDuplex.hProcess);
			m_piPriority.hProcess = NULL;
			m_piFullDuplex.hProcess = NULL;
			DNLeaveCriticalSection(&m_csLock);
			DPFX(DPFPREP, DVF_ERRORLEVEL, "CloseHandle failed, lRet: %i", lRet);
			DPF_EXIT();
			return DVERR_GENERIC;
		}
		
		fRet = GetExitCodeProcess(m_piFullDuplex.hProcess, (LPDWORD)&hr);
		if (!fRet || FAILED(hr))
		{
			lRet = GetLastError();
			CloseHandle(m_piFullDuplex.hProcess);
			m_piPriority.hProcess = NULL;
			m_piFullDuplex.hProcess = NULL;
			DNLeaveCriticalSection(&m_csLock);
			if (!fRet && SUCCEEDED(hr))
			{
				DPFX(DPFPREP, DVF_ERRORLEVEL, "GetExitCodeProcess failed, lRet: %i", lRet);
				DPF_EXIT();
				return DVERR_GENERIC;
			}
			DPFX(DPFPREP, DVF_ERRORLEVEL, "FullDuplex Process exited with error code, hr: %i", hr);
			DPF_EXIT();
			return hr;
		}
		
		if (!CloseHandle(m_piFullDuplex.hProcess))
		{
			lRet = GetLastError();
			m_piPriority.hProcess = NULL;
			m_piFullDuplex.hProcess = NULL;
			DNLeaveCriticalSection(&m_csLock);
			DPFX(DPFPREP, DVF_ERRORLEVEL, "CloseHandle failed, lRet: %i", lRet);
			DPF_EXIT();
			return DVERR_GENERIC;
		}
		
		m_piPriority.hProcess = NULL;
		m_piFullDuplex.hProcess = NULL;
		DNLeaveCriticalSection(&m_csLock);
		DPF_EXIT();
		return DV_OK;
	}
	else
	{
		// Not sure what happened...
		DPF_EXIT();
		return DVERR_GENERIC;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::TerminateChildProcesses"
HRESULT CSupervisorIPC::TerminateChildProcesses()
{
	LONG lRet;
	HRESULT hr = DV_OK;

	DPF_ENTER();
	
	// The child processes did not exit gracefully.	So now
	// we get to kill them off rudely. Note that this
	// function may be called at any time, including when
	// there are no child processes running.
	DNEnterCriticalSection(&m_csLock);
	if (m_piPriority.hProcess != NULL)
	{
		if (!TerminateProcess(m_piPriority.hProcess, 0))
		{
			lRet = GetLastError();		
			DPFX(DPFPREP, DVF_ERRORLEVEL, "TerminateProcess failed on priority process, code: %i", lRet);
			if (!CloseHandle(m_piPriority.hProcess))
			{
				lRet = GetLastError();		
				DPFX(DPFPREP, DVF_ERRORLEVEL, "CloseHandle failed on priority process handle, code: %i", lRet);
			}
			m_piPriority.hProcess = NULL;
			hr = DVERR_GENERIC;
		}
		if (!CloseHandle(m_piPriority.hProcess))
		{
			lRet = GetLastError();		
			DPFX(DPFPREP, DVF_ERRORLEVEL, "CloseHandle failed on priority process handle, code: %i", lRet);
			hr = DVERR_GENERIC;
		}
		m_piPriority.hProcess = NULL;
	}
	if (m_piFullDuplex.hProcess != NULL)
	{
		if (!TerminateProcess(m_piFullDuplex.hProcess, 0))
		{
			lRet = GetLastError();		
			DPFX(DPFPREP, DVF_ERRORLEVEL, "TerminateProcess failed on full duplex process, code: %i", lRet);
			hr = DVERR_GENERIC;
		}
		if (!CloseHandle(m_piFullDuplex.hProcess))
		{
			lRet = GetLastError();		
			DPFX(DPFPREP, DVF_ERRORLEVEL, "CloseHandle failed on full duplex process handle, code: %i", lRet);
			hr = DVERR_GENERIC;
		}
		m_piFullDuplex.hProcess = NULL;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::StartFullDuplexProcess"
HRESULT CSupervisorIPC::StartFullDuplexProcess()
{
	STARTUPINFO si;
	TCHAR szFullDuplexCommandLine[_MAX_PATH+1];

	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);
	
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);

	_tcsncpy( szFullDuplexCommandLine, gc_szFullDuplexCommand, _MAX_PATH );
	szFullDuplexCommandLine[_MAX_PATH] = 0;

	if (!CreateProcess(
		NULL,
		(LPTSTR) szFullDuplexCommandLine,
		NULL,
		NULL,
		FALSE,
		0,
		NULL,
		NULL,
		&si,
		&m_piFullDuplex))
	{
		m_piFullDuplex.hProcess = NULL;
		m_piFullDuplex.hThread = NULL;
		DNLeaveCriticalSection(&m_csLock);
		DPF_EXIT();
		return DVERR_WIN32;
	}

	// don't need the thread handle
	if (!CloseHandle(m_piFullDuplex.hThread))
	{
		m_piFullDuplex.hThread = NULL;
		DNLeaveCriticalSection(&m_csLock);
		DPF_EXIT();
		return DVERR_WIN32;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorIPC::WaitForStartupSignals"
HRESULT CSupervisorIPC::WaitForStartupSignals()
{
	HANDLE rghEvents[2];
	DWORD dwRet;
	HRESULT hr;
	LONG lRet;
	
	// wait to be signaled by both child processes, indicating that
	// they are ready to go.
	DNEnterCriticalSection(&m_csLock);
	rghEvents[0] = m_hPriorityReplyEvent;
	rghEvents[1] = m_hFullDuplexReplyEvent;
	DNLeaveCriticalSection(&m_csLock);
	dwRet = WaitForMultipleObjects(2, rghEvents, TRUE, gc_dwChildStartupTimeout);
	if (dwRet != WAIT_OBJECT_0 && dwRet != WAIT_OBJECT_0 + 1)
	{
		if (dwRet == WAIT_TIMEOUT)
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Timeout waiting for child processes to startup");
			return DVERR_TIMEOUT;
		}
		else
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Error waiting for signals from child processes, code: %i", lRet);
			return DVERR_WIN32;
		}
	}
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPriorityIPC::CPriorityIPC"
CPriorityIPC::CPriorityIPC()
	: m_fInitComplete(FALSE)
	, m_hPriorityEvent(NULL)
	, m_hPriorityMutex(NULL)
	, m_hPriorityReplyEvent(NULL)
	, m_hPriorityShMemHandle(NULL)
	, m_lpvPriorityShMemPtr(NULL)
{
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPriorityIPC::Init"
HRESULT CPriorityIPC::Init()
{
	LONG lRet;
	HRESULT hr;

	DPF_ENTER();

	if (!DNInitializeCriticalSection(&m_csLock))
	{
		return DVERR_OUTOFMEMORY;
	}

	DNEnterCriticalSection(&m_csLock);

	if (m_fInitComplete == TRUE)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CPriorityIPC::Init - already initialized");
		hr = DVERR_INITIALIZED;
		goto error_cleanup;
	}
	
	m_hPriorityEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, gc_szPriorityEventName);
	if (m_hPriorityEvent == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to open Priority event, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hPriorityReplyEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, gc_szPriorityReplyEventName);
	if (m_hPriorityReplyEvent == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to open Priority Reply event, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hPriorityShMemHandle = OpenFileMapping(FILE_MAP_WRITE, FALSE, gc_szPriorityShMemName);
	if (m_hPriorityShMemHandle == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to open Priority FileMapping object, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_lpvPriorityShMemPtr = MapViewOfFile(
		m_hPriorityShMemHandle, 
		FILE_MAP_WRITE, 
		0, 
		0, 
		gc_dwPriorityShMemSize);
	if (m_lpvPriorityShMemPtr == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to Map view of Priority FileMapping object, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_fInitComplete = TRUE;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (m_lpvPriorityShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvPriorityShMemPtr);
		m_lpvPriorityShMemPtr = NULL;
	}
	
	if (m_hPriorityShMemHandle != NULL)
	{
		CloseHandle(m_hPriorityShMemHandle);
		m_hPriorityShMemHandle = NULL;
	}

	if (m_hPriorityReplyEvent != NULL)
	{
		CloseHandle(m_hPriorityReplyEvent);
		m_hPriorityReplyEvent = NULL;
	}

	if (m_hPriorityEvent != NULL)
	{
		CloseHandle(m_hPriorityEvent);
		m_hPriorityEvent = NULL;
	}
	
	DNLeaveCriticalSection(&m_csLock);

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPriorityIPC::Deinit"
HRESULT CPriorityIPC::Deinit()
{
	LONG lRet;
	HRESULT hr = DV_OK;

	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);

	if (m_fInitComplete != TRUE)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CPriorityIPC::Deinit called on uninitialized object");
		hr = DVERR_NOTINITIALIZED;
	}
	m_fInitComplete = FALSE;

	if (m_lpvPriorityShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvPriorityShMemPtr);
		m_lpvPriorityShMemPtr = NULL;
	}
	
	if (m_hPriorityShMemHandle != NULL)
	{
		CloseHandle(m_hPriorityShMemHandle);
		m_hPriorityShMemHandle = NULL;
	}

	if (m_hPriorityReplyEvent != NULL)
	{
		CloseHandle(m_hPriorityReplyEvent);
		m_hPriorityReplyEvent = NULL;
	}

	if (m_hPriorityEvent != NULL)
	{
		CloseHandle(m_hPriorityEvent);
		m_hPriorityEvent = NULL;
	}

	DNLeaveCriticalSection(&m_csLock);

	DNDeleteCriticalSection(&m_csLock);

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPriorityIPC::SignalParentReady"
HRESULT CPriorityIPC::SignalParentReady()
{
	BOOL fRet;
	LONG lRet;
	
	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);
	
	fRet = SetEvent(m_hPriorityReplyEvent);
	if (!fRet)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, 0, "Error Setting Priority Reply Event, code: %i", lRet);
		DPF_EXIT();
		return DVERR_WIN32;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPriorityIPC::Receive"
HRESULT CPriorityIPC::Receive(SFDTestCommand* pfdtc)
{
	HRESULT hr;
	
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);

	hr = DoReceive(pfdtc, m_hPriorityEvent, m_hPriorityReplyEvent, m_lpvPriorityShMemPtr);

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPriorityIPC::Reply"
HRESULT CPriorityIPC::Reply(HRESULT hr)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);

	hr = DoReply(hr, m_hPriorityReplyEvent, m_lpvPriorityShMemPtr);

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFullDuplexIPC::CFullDuplexIPC"
CFullDuplexIPC::CFullDuplexIPC()
	: m_fInitComplete(FALSE)
	, m_hFullDuplexEvent(NULL)
	, m_hFullDuplexMutex(NULL)
	, m_hFullDuplexReplyEvent(NULL)
	, m_hFullDuplexShMemHandle(NULL)
	, m_lpvFullDuplexShMemPtr(NULL)
{
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFullDuplexIPC::Init"
HRESULT CFullDuplexIPC::Init()
{
	LONG lRet;
	HRESULT hr;

	DPF_ENTER();

	if (!DNInitializeCriticalSection(&m_csLock))
	{
		return DVERR_OUTOFMEMORY;
	}

	DNEnterCriticalSection(&m_csLock);

	if (m_fInitComplete != FALSE)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CFullDuplexIPC::Init - already initialized");
		hr = DVERR_INITIALIZED;
		goto error_cleanup;
	}
	
	m_hFullDuplexEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, gc_szFullDuplexEventName);
	if (m_hFullDuplexEvent == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to open FullDuplex event, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hFullDuplexReplyEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, gc_szFullDuplexReplyEventName);
	if (m_hFullDuplexReplyEvent == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to open FullDuplex Reply event, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hFullDuplexShMemHandle = OpenFileMapping(FILE_MAP_WRITE, FALSE, gc_szFullDuplexShMemName);
	if (m_hFullDuplexShMemHandle == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to open FullDuplex FileMapping object, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_lpvFullDuplexShMemPtr = MapViewOfFile(
		m_hFullDuplexShMemHandle, 
		FILE_MAP_WRITE, 
		0, 
		0, 
		gc_dwFullDuplexShMemSize);
	if (m_lpvFullDuplexShMemPtr == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to Map view of FullDuplex FileMapping object, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_fInitComplete = TRUE;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (m_lpvFullDuplexShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvFullDuplexShMemPtr);
		m_lpvFullDuplexShMemPtr = NULL;
	}

	if (m_hFullDuplexShMemHandle != NULL)
	{
		CloseHandle(m_hFullDuplexShMemHandle);
		m_hFullDuplexShMemHandle = NULL;
	}

	if (m_hFullDuplexReplyEvent != NULL)
	{
		CloseHandle(m_hFullDuplexReplyEvent);
		m_hFullDuplexReplyEvent = NULL;
	}

	if (m_hFullDuplexEvent != NULL)
	{
		CloseHandle(m_hFullDuplexEvent);
		m_hFullDuplexEvent = NULL;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFullDuplexIPC::Deinit"
HRESULT CFullDuplexIPC::Deinit()
{
	LONG lRet;
	HRESULT hr = DV_OK;

	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);

	if (m_fInitComplete != TRUE)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CFullDuplexIPC::Deinit called on uninitialized object");
		hr = DVERR_NOTINITIALIZED;
	}
	m_fInitComplete = FALSE;

	if (m_lpvFullDuplexShMemPtr != NULL)
	{
		UnmapViewOfFile(m_lpvFullDuplexShMemPtr);
		m_lpvFullDuplexShMemPtr = NULL;
	}

	if (m_hFullDuplexShMemHandle != NULL)
	{
		CloseHandle(m_hFullDuplexShMemHandle);
		m_hFullDuplexShMemHandle = NULL;
	}

	if (m_hFullDuplexReplyEvent != NULL)
	{
		CloseHandle(m_hFullDuplexReplyEvent);
		m_hFullDuplexReplyEvent = NULL;
	}

	if (m_hFullDuplexEvent != NULL)
	{
		CloseHandle(m_hFullDuplexEvent);
		m_hFullDuplexEvent = NULL;
	}
	
	DNLeaveCriticalSection(&m_csLock);

	DNDeleteCriticalSection(&m_csLock);

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFullDuplexIPC::SignalParentReady"
HRESULT CFullDuplexIPC::SignalParentReady()
{
	BOOL fRet;
	LONG lRet;
	
	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);
	
	fRet = SetEvent(m_hFullDuplexReplyEvent);
	if (!fRet)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Error Setting FullDuplex Event, code: %i", lRet);
		DPF_EXIT();
		return DVERR_WIN32;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFullDuplexIPC::Receive"
HRESULT CFullDuplexIPC::Receive(SFDTestCommand* pfdtc)
{
	HRESULT hr;
	
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);

	hr = DoReceive(pfdtc, m_hFullDuplexEvent, m_hFullDuplexReplyEvent, m_lpvFullDuplexShMemPtr);

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CFullDuplexIPC::Reply"
HRESULT CFullDuplexIPC::Reply(HRESULT hrReply)
{
	HRESULT hr;
	
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);

	hr = DoReply(hrReply, m_hFullDuplexReplyEvent, m_lpvFullDuplexShMemPtr);

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DoReceive"
HRESULT DoReceive(
	SFDTestCommand* pfdtc,
	HANDLE hEvent,
	HANDLE hReplyEvent,
	LPVOID lpvShMemPtr)
{
	DWORD dwRet;
	LONG lRet;

	DPF_ENTER();

	dwRet = WaitForSingleObject(hEvent,	gc_dwCommandReceiveTimeout);
	switch (dwRet)
	{
	case WAIT_OBJECT_0:
		// this is the expected signal, continue
		break;
		
	case WAIT_FAILED:
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Error waiting for event, code: %i", lRet);
		DPF_EXIT();
		return DVERR_WIN32;

	case WAIT_TIMEOUT:
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Timed out waiting to receive command");
		DPF_EXIT();
		return DVERR_TIMEOUT;

	default:
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unknown error waiting for event");
		DPF_EXIT();
		return DVERR_UNKNOWN;
	}
		
	// Copy the command from shared memory to the caller's
	// buffer. Ensure the caller's buffer is large enough
	if (pfdtc->dwSize < ((SFDTestCommand*)lpvShMemPtr)->dwSize)
	{
		// reply to both the sender and receiver that the 
		// buffer was not large enough! We already have an
		// error, so ingore the return code from the reply
		// call
		DoReply(DVERR_BUFFERTOOSMALL, hReplyEvent, lpvShMemPtr);
		DPF_EXIT();
		return DVERR_BUFFERTOOSMALL;
	}

	CopyMemory(pfdtc, lpvShMemPtr, ((SFDTestCommand*)lpvShMemPtr)->dwSize);

	// Let the caller know how much was copied
	pfdtc->dwSize = ((SFDTestCommand*)lpvShMemPtr)->dwSize;

	// all done.
	DPF_EXIT();
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DoReply"
HRESULT DoReply(HRESULT hr, HANDLE hReplyEvent, LPVOID lpvShMemPtr)
{
	LONG lRet;

	DPF_ENTER();

	// Copy the return code to shared memory
	*((HRESULT*)lpvShMemPtr) = hr;

	// Signal that we have replied
	if (!SetEvent(hReplyEvent))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to set event, code: %i", lRet);
		DPF_EXIT();
		return DVERR_WIN32;
	}
	DPF_EXIT();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fulldup.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fulldup.h
 *  Content:    Prototypes the FullDuplexProcess function
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#ifndef _FULLDUP_H_
#define _FULLDUP_H_

HRESULT FullDuplexProcess(HINSTANCE hResDLLInstance, HINSTANCE hPrevInstance, TCHAR *szCmdLine, int iCmdShow);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\loopback.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		loopback.cpp
 *  Content:	Declares the loopback test function
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/10/99		pnewson	Created
 *  01/21/2000	pnewson	Updated to support use of loopback tests for full duplex testing
 *  11/29/2000	rodtoll	Bug #48348 - DPVOICE: Modify wizard to make use of DirectPlay8 as the transport. 
 *
 ***************************************************************************/

HRESULT StartLoopback(
	LPDIRECTPLAYVOICESERVER* lplpdvs, 
	LPDIRECTPLAYVOICECLIENT* lplpdvc,
	PDIRECTPLAY8SERVER* lplpdp8, 
	LPVOID lpvCallbackContext,
	HWND hwndAppWindow,
	GUID guidCaptureDevice,
	GUID guidRenderDevice,
	DWORD dwFlags);

HRESULT StopLoopback(
	LPDIRECTPLAYVOICESERVER lpdvs, 
	LPDIRECTPLAYVOICECLIENT lpdvc,
	PDIRECTPLAY8SERVER lpdp8 );

HRESULT StartDirectPlay( PDIRECTPLAY8SERVER* lplpdp8 );
HRESULT StopDirectPlay( PDIRECTPLAY8SERVER lplpdp8 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fdtipc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fdtipc.cpp
 *  Content:    Declard the IPC calls for the full duplex test
 *  History:
 *	Date   By  Reason
 *	============
 *	08/26/99	pnewson		created
 *	01/21/2000	pnewson		modified full duplex start command struct
 *  04/18/2000  rodtoll     Bug #32649 Voice wizard failing 
 *                          Changed secondary format for tests from stereo --> mono 
 *  04/19/2000	pnewson	    Error handling cleanup  
 ***************************************************************************/

#ifndef _FDTIPC_H_
#define _FDTIPC_H_

enum EFDTestCommandCode
{
	fdtccExit = 1,
	fdtccPriorityStart,
	fdtccPriorityStop,
	fdtccFullDuplexStart,
	fdtccFullDuplexStop,
	fdtccEndOfEnum	// keep this last thing in enum!
};

// Exit command struct
// This command tells the child processes to exit
struct SFDTestCommandExit
{
};

// PriorityStart command struct
// This command tells the child process to:
// - create a DirectSound interface on the specified render device
// - set it's cooperative level to priority mode
// - create a primary buffer
// - set the format of the primary buffer to the format specified in wfx
// - creates a secondary buffer of the same format as the primary
// = fills the secondary buffer with zeros
// - starts playing the secondary buffer
struct SFDTestCommandPriorityStart
{
	GUID guidRenderDevice;
	WAVEFORMATEX wfxRenderFormat;
	WAVEFORMATEX wfxSecondaryFormat;
	HWND hwndWizard;
	HWND hwndProgress;
};

// PriorityStop command struct
// This command tells the child process to:
// - stop playing the secondary buffer
// - destroy the secondardy buffer object
// - destroy the primary buffer object
// - destroy the DirectSound object
struct SFDTestCommandPriorityStop
{
};

// FullDuplexStart command struct
// This command tells the child process to start
// a fullduplex loopback test.
struct SFDTestCommandFullDuplexStart
{
	GUID guidRenderDevice;
	GUID guidCaptureDevice;
	DWORD dwFlags;
};

// FullDuplexStop command struct
// This command tells the child process to
// stop the full duplex loopback test.
struct SFDTestCommandFullDuplexStop
{
};

union UFDTestCommandUnion
{
	SFDTestCommandExit fdtcExit;
	SFDTestCommandPriorityStart fdtcPriorityStart;
	SFDTestCommandPriorityStop fdtcPriorityStop;
	SFDTestCommandFullDuplexStart fdtcFullDuplexStart;
	SFDTestCommandFullDuplexStop fdtcFullDuplexStop;
};

struct SFDTestCommand
{
	DWORD dwSize;
	EFDTestCommandCode fdtcc;
	UFDTestCommandUnion fdtu;
};

enum EFDTestTarget
{
	fdttPriority = 1,
	fdttFullDuplex
};

// The class used by the Supervisor Process
class CSupervisorIPC
{
private: 
	//HANDLE m_hMutex;
	HANDLE m_hPriorityEvent;
	HANDLE m_hFullDuplexEvent;
	HANDLE m_hPriorityReplyEvent;
	HANDLE m_hFullDuplexReplyEvent;
	HANDLE m_hPriorityShMemHandle;
	LPVOID m_lpvPriorityShMemPtr;
	HANDLE m_hFullDuplexShMemHandle;
	LPVOID m_lpvFullDuplexShMemPtr;
	HANDLE m_hPriorityMutex;
	HANDLE m_hFullDuplexMutex;
	PROCESS_INFORMATION m_piPriority;
	PROCESS_INFORMATION m_piFullDuplex;

	DNCRITICAL_SECTION m_csLock;

	BOOL m_fInitComplete;
	
	HRESULT DoSend(
		const SFDTestCommand *pfdtc,
		HANDLE hProcess,
		HANDLE hEvent,
		HANDLE hReplyEvent,
		LPVOID lpvShMemPtr,
		HANDLE hMutex);

	// make this private to disallow copy construction
	// also not implemented, so linker error if used
	CSupervisorIPC(const CSupervisorIPC& rhs);

public:
	CSupervisorIPC();
	HRESULT Init();
	HRESULT Deinit();
	HRESULT SendToPriority(const SFDTestCommand *pfdtc);
	HRESULT SendToFullDuplex(const SFDTestCommand *pfdtc);
	HRESULT StartPriorityProcess();
	HRESULT StartFullDuplexProcess();
	HRESULT WaitForStartupSignals();
	HRESULT WaitOnChildren();
	HRESULT TerminateChildProcesses();
};

// The class used by the Priority Process
class CPriorityIPC
{
private: 
	HANDLE m_hPriorityEvent;
	HANDLE m_hPriorityReplyEvent;
	HANDLE m_hPriorityShMemHandle;
	LPVOID m_lpvPriorityShMemPtr;
	HANDLE m_hPriorityMutex;

	DNCRITICAL_SECTION m_csLock;

	BOOL m_fInitComplete;

	// make this private to disallow copy construction
	// also not implemented, so linker error if used
	CPriorityIPC(const CPriorityIPC& rhs);

public:
	CPriorityIPC();
	HRESULT Init();
	HRESULT Deinit();
	HRESULT SignalParentReady();
	HRESULT Receive(SFDTestCommand* pfdtc);
	HRESULT Reply(HRESULT hr);
};

// The class used by the Full Duplex Process
class CFullDuplexIPC
{
private: 
	HANDLE m_hFullDuplexEvent;
	HANDLE m_hFullDuplexReplyEvent;
	HANDLE m_hFullDuplexShMemHandle;
	LPVOID m_lpvFullDuplexShMemPtr;
	HANDLE m_hFullDuplexMutex;

	DNCRITICAL_SECTION m_csLock;

	BOOL m_fInitComplete;

	// make this private to disallow copy construction
	// also not implemented, so linker error if used
	CFullDuplexIPC(const CFullDuplexIPC& rhs);
	
public:
	CFullDuplexIPC();
	HRESULT Init();
	HRESULT Deinit();
	HRESULT SignalParentReady();
	HRESULT Receive(SFDTestCommand* pfdtc);
	HRESULT Reply(HRESULT hr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\fulldup.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fulldup.cpp
 *  Content:    Implements a process that uses DirectSound and 
 *              DirectSoundCapture to test the systems full duplex
 *				capability. Note that WinMain is in fdtest.cpp, but 
 *              the guts are here.
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 *  10/28/99	pnewson Bug #113937 audible clicking during full duplex test
 *  11/02/99		 pnewson Fix: Bug #116365 - using wrong DSBUFFERDESC
 *  01/21/2000	pnewson 	Changed over to using a dpvoice loopback session
 *							for full duplex testing
 *  04/19/2000	pnewson	    Error handling cleanup  
 *  07/12/2000	rodtoll		Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 ***************************************************************************/

#include "dxvtlibpch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


static HRESULT OpenIPCObjects();
static HRESULT CloseIPCObjects();
static HRESULT CommandLoop(CFullDuplexIPC* lpipcFullDuplex);
static HRESULT DispatchCommand(CFullDuplexIPC* lpipcFullDuplex, SFDTestCommand* pfdtc);
static HRESULT CommandFullDuplexStart(SFDTestCommandFullDuplexStart* pfdtcFullDuplexStart, HRESULT* phrIPC);
static HRESULT CommandFullDuplexStop(SFDTestCommandFullDuplexStop* pfdtcFullDuplexStop, HRESULT* phrIPC);
static HRESULT PlayAndCheckRender(LPDIRECTSOUNDBUFFER lpdsb, HANDLE hEvent);
static HRESULT PlayAndCheckCapture(LPDIRECTSOUNDCAPTUREBUFFER lpdscb, HANDLE hEvent);
static HRESULT AttemptCapture();


// one global struct to store this process's state data.
struct SFullDuplexData
{
	LPDIRECTPLAYVOICESERVER lpdpvs;
	LPDIRECTPLAYVOICECLIENT lpdpvc;
	PDIRECTPLAY8SERVER lpdp8;
};

SFullDuplexData g_FullDuplexData;


#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexProcess"
HRESULT FullDuplexProcess(HINSTANCE hResDLLInstance, HINSTANCE hPrevInstance, TCHAR *szCmdLine, int iCmdShow)
{
	HRESULT hr;
	CFullDuplexIPC ipcFullDuplex;
	BOOL fIPCInitialized = FALSE;
 	PDIRECTPLAYVOICECLIENT pdpvClient = NULL;

 	g_FullDuplexData.lpdp8 = NULL;

	DPF_ENTER();

	// Create dummy voice object so that voice process state gets initialized
	hr = CoCreateInstance( CLSID_DirectPlayVoiceClient, NULL, CLSCTX_INPROC, IID_IDirectPlayVoiceClient, (void **) &pdpvClient );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to create dummy dp8 object hr: 0x%x", hr);
		goto error_cleanup;
	}
	
	if (!InitGlobGuard())
	{
		hr = DVERR_OUTOFMEMORY;
		goto error_cleanup;
	}

	hr = ipcFullDuplex.Init();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CIPCFullDuplex::Init() failed, hr: 0x%x", hr);
		goto error_cleanup;
	}
	fIPCInitialized = TRUE;

	// Startup DirectPlay once so that we don't have to do it over and over
	// again for the test.  
	hr = StartDirectPlay( &g_FullDuplexData.lpdp8 );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Failed to start transport hr: 0x%x", hr);
		goto error_cleanup;		
	}

	// start up the testing loop
	hr = CommandLoop(&ipcFullDuplex);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CommandLoop failed, hr: 0x%x", hr);
		goto error_cleanup;
	}

	hr = StopDirectPlay( g_FullDuplexData.lpdp8 );

	g_FullDuplexData.lpdp8 = NULL;

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Failed to stop transport hr: 0x%x", hr);
		goto error_cleanup;		
	}

	// close the mutex, events and shared memory stuff
	hr = ipcFullDuplex.Deinit();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CIPCFullDuplex::Deinit() failed, hr: 0x%x", hr);
		goto error_cleanup;
	}

	// Destroy dummy client object which will shutdown dplayvoice state
	pdpvClient->Release();

	DeinitGlobGuard();
	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (fIPCInitialized == TRUE)
	{
		ipcFullDuplex.Deinit();
		fIPCInitialized = FALSE;
	}

	if( g_FullDuplexData.lpdp8 )
	{
		g_FullDuplexData.lpdp8->Release();
		g_FullDuplexData.lpdp8 = NULL;
	}

	if( pdpvClient )
		pdpvClient->Release();
	
	DeinitGlobGuard();
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CommandLoop"
HRESULT CommandLoop(CFullDuplexIPC* lpipcFullDuplex)
{
	BOOL fRet;
	LONG lRet;
	HRESULT hr;
	DWORD dwRet;
	SFDTestCommand fdtc;

	DPF_ENTER();

	// Kick the supervisor process to let it know
	// we're ready to go.
	hr = lpipcFullDuplex->SignalParentReady();
	if (FAILED(hr))
	{
		return hr;
	}

	// enter the main command loop
	while (1)
	{
		// wait for a command from the supervisor process
		fdtc.dwSize = sizeof(fdtc);
		hr = lpipcFullDuplex->Receive(&fdtc);
		if (FAILED(hr))
		{
			break;
		}
		
		// dispatch the command
		hr = DispatchCommand(lpipcFullDuplex, &fdtc);
		if (FAILED(hr))
		{
			break;
		}
		if (hr == DV_EXIT)
		{
			DPFX(DPFPREP, DVF_INFOLEVEL, "Exiting FullDuplex process command loop");
			break;
		}
	}

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DispatchCommand"
HRESULT DispatchCommand(CFullDuplexIPC* lpipcFullDuplex, SFDTestCommand* pfdtc)
{
	HRESULT hr;
	HRESULT hrIPC;

	DPF_ENTER();

	switch (pfdtc->fdtcc)
	{
	case fdtccExit:
		// ok - reply to the calling process to let them
		// know we are getting out.
		DPFX(DPFPREP, DVF_INFOLEVEL, "FullDuplex received Exit command");
		lpipcFullDuplex->Reply(DV_EXIT);

		// returning this code will break us out of
		// the command processing loop
		DPFX(DPFPREP, DVF_INFOLEVEL, "Exit");
		return DV_EXIT;

	case fdtccFullDuplexStart:
		hr = CommandFullDuplexStart(&(pfdtc->fdtu.fdtcFullDuplexStart), &hrIPC);
		if (FAILED(hr))
		{
			lpipcFullDuplex->Reply(hrIPC);
			DPF_EXIT();
			return hr;
		}
		hr = lpipcFullDuplex->Reply(hrIPC);
		DPF_EXIT();
		return hr;

	case fdtccFullDuplexStop:
		hr = CommandFullDuplexStop(&(pfdtc->fdtu.fdtcFullDuplexStop), &hrIPC);
		if (FAILED(hr))
		{
			lpipcFullDuplex->Reply(hrIPC);
			DPF_EXIT();
			return hr;
		}
		hr = lpipcFullDuplex->Reply(hrIPC);
		DPF_EXIT();
		return hr;
		
	default:
		// Don't know this command. Reply with the appropriate
		// code.
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "FullDuplex received Unknown command");
		lpipcFullDuplex->Reply(DVERR_UNKNOWN);
		
		// While this is an error, it is one that the calling
		// process needs to figure out. In the meantime, this
		// process will happily continue on.
		DPF_EXIT();
		return S_OK;
	}
}

/*
#undef DPF_MODNAME
#define DPF_MODNAME "CommandFullDuplexStart"
HRESULT CommandFullDuplexStart(SFDTestCommandFullDuplexStart* pfdtcFullDuplexStart, HRESULT* phrIPC)
{
	HRESULT hr;
	DSBUFFERDESC1 dsbd;
	WAVEFORMATEX wfx;
	DWORD dwSizeWritten;
	DSBCAPS	 dsbc;
	LPVOID lpvAudio1 = NULL;
	DWORD dwAudio1Size = NULL;
	LPVOID lpvAudio2 = NULL;
	DWORD dwAudio2Size = NULL;
	HANDLE hFullDuplexRenderEvent;
	HANDLE hFullDuplexCaptureEvent;
	DSBPOSITIONNOTIFY dsbPositionNotify;
	DWORD dwRet;
	LONG lRet;
	LPDIRECTSOUNDBUFFER lpdsb;
	HANDLE hEvent;
	BYTE bSilence;

	DPF_ENTER();
	
	// create the DirectSound interface
	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating DirectSound");
	GlobGuardIn();
	hr = DirectSoundCreate(&pfdtcFullDuplexStart->guidRenderDevice, &g_lpdsFullDuplexRender, NULL);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "DirectSoundCreate failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_0;
	}

	// create the DirectSoundCapture interface
	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating DirectSoundCapture");
	GlobGuardIn();
	hr = DirectSoundCaptureCreate(&pfdtcFullDuplexStart->guidCaptureDevice, &g_lpdscFullDuplexCapture, NULL);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "DirectSoundCaptureCreate failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_1;
	}
	
	// set to normal mode
	DPFX(DPFPREP, DVF_INFOLEVEL, "Setting Cooperative Level");
	GlobGuardIn();
	hr = g_lpdsFullDuplexRender->SetCooperativeLevel(GetDesktopWindow(), DSSCL_NORMAL);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "SetCooperativeLevel failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_2;
	}

	// Create a secondary buffer object.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating Secondary Buffer");
	CopyMemory(&wfx, &gc_wfxSecondaryFormat, sizeof(wfx));
	ZeroMemory(&dsbd, sizeof(dsbd));
	dsbd.dwSize = sizeof(dsbd);
	dsbd.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLVOLUME;
	dsbd.dwBufferBytes = 
		(wfx.nSamplesPerSec 
		* wfx.nBlockAlign)
		/ (1000 / gc_dwFrameSize);
	dsbd.dwReserved = 0;
	dsbd.lpwfxFormat = &wfx;
	GlobGuardIn();
        hr = g_lpdsFullDuplexRender->CreateSoundBuffer((LPDSBUFFERDESC)&dsbd, &g_lpdsbFullDuplexSecondary, NULL);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "CreateSoundBuffer failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_2;
	}

	// clear out the secondary buffer
	DPFX(DPFPREP, DVF_INFOLEVEL, "Clearing Secondary Buffer");
	GlobGuardIn();
	hr = g_lpdsbFullDuplexSecondary->Lock(
		0,
		0,
		&lpvAudio1,
		&dwAudio1Size,
		&lpvAudio2,
		&dwAudio2Size, 
		DSBLOCK_ENTIREBUFFER);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Lock failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_3;
	}

	if (lpvAudio1 == NULL)
	{
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_3;
	}

	if (pfdtcFullDuplexStart->wfxRenderFormat.wBitsPerSample == 8)
	{
		bSilence = 0x80;
	}
	else
	{
		bSilence = 0x00;
	}
	
	memset(lpvAudio1, bSilence, dwAudio1Size);
	if (lpvAudio2 != NULL)
	{
		memset(lpvAudio2, bSilence, dwAudio2Size);
	}

	GlobGuardIn();
	hr = g_lpdsbFullDuplexSecondary->Unlock(
		lpvAudio1, 
		dwAudio1Size, 
		lpvAudio2, 
		dwAudio2Size);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Unlock failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_3;
	}

	// Set up one notification position in the buffer so
	// we can tell if it is really playing, or lying to us.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Querying for IDirectSoundNotify");
	GlobGuardIn();
	hr = g_lpdsbFullDuplexSecondary->QueryInterface(
		IID_IDirectSoundNotify,
		(LPVOID*)&g_lpdsnFullDuplexSecondary);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "QueryInterface(IID_DirectSoundNotify) failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_3;
	}

	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating Notification Event");
	GlobGuardIn();
	g_hFullDuplexRenderEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hFullDuplexRenderEvent = g_hFullDuplexRenderEvent;
	GlobGuardOut();
	if (hFullDuplexRenderEvent == NULL)
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "CreateEvent failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_WIN32;
		goto error_level_4;
	}

	DPFX(DPFPREP, DVF_INFOLEVEL, "calling SetNotificationPositions");
	dsbPositionNotify.dwOffset = 0;
	dsbPositionNotify.hEventNotify = hFullDuplexRenderEvent;
	GlobGuardIn();
	hr = g_lpdsnFullDuplexSecondary->SetNotificationPositions(1, &dsbPositionNotify);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "SetNotificationPositions failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_5;
	}

	// start the secondary buffer and confirm that it's running
	GlobGuardIn();
	lpdsb = g_lpdsbFullDuplexSecondary;
	hEvent = g_hFullDuplexRenderEvent;
	GlobGuardOut();
	hr = PlayAndCheckRender(lpdsb, hEvent);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Render verification test failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_5;
	}

	hr = AttemptCapture();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "AttemptCapture() failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
		goto error_level_6;
	}

	DPF_EXIT();
	return S_OK;

// error block
error_level_6:
	GlobGuardIn();
	g_lpdsbFullDuplexSecondary->Stop();
	GlobGuardOut();
	
error_level_5:
	GlobGuardIn();
	CloseHandle(g_hFullDuplexRenderEvent);
	g_hFullDuplexRenderEvent = NULL;
	GlobGuardOut();
	
error_level_4:
	GlobGuardIn();
	g_lpdsnFullDuplexSecondary->Release();
	g_lpdsnFullDuplexSecondary = NULL;
	GlobGuardOut();
	
error_level_3:
	GlobGuardIn();
	g_lpdsbFullDuplexSecondary->Release();
	g_lpdsbFullDuplexSecondary = NULL;
	GlobGuardOut();

error_level_2:
	GlobGuardIn();
	g_lpdscFullDuplexCapture->Release();
	g_lpdscFullDuplexCapture = NULL;
	GlobGuardOut();
	
error_level_1:
	GlobGuardIn();
	g_lpdsFullDuplexRender->Release();
	g_lpdsFullDuplexRender = NULL;
	GlobGuardOut();
	
error_level_0:
	// error for other process, not this one.
	DPF_EXIT();
	return S_OK;
}
*/

#undef DPF_MODNAME
#define DPF_MODNAME "CommandFullDuplexStart"
HRESULT CommandFullDuplexStart(SFDTestCommandFullDuplexStart* pfdtcFullDuplexStart, HRESULT* phrIPC)
{
	DPF_ENTER();

	HRESULT hr;

	Diagnostics_Write( DVF_INFOLEVEL, "-----------------------------------------------------------" );

	hr = Diagnostics_DeviceInfo( &pfdtcFullDuplexStart->guidRenderDevice, &pfdtcFullDuplexStart->guidCaptureDevice );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( 0, "Error getting device information hr=0x%x", hr );
	}

	Diagnostics_Write( DVF_INFOLEVEL, "-----------------------------------------------------------" );

	*phrIPC = StartLoopback(
		&g_FullDuplexData.lpdpvs, 
		&g_FullDuplexData.lpdpvc,
		&g_FullDuplexData.lpdp8, 
		NULL,
		GetDesktopWindow(),
		pfdtcFullDuplexStart->guidCaptureDevice,
		pfdtcFullDuplexStart->guidRenderDevice,
		pfdtcFullDuplexStart->dwFlags);

	DPFX(DPFPREP,  DVF_INFOLEVEL, "StartLoopback() return hr=0x%x", *phrIPC );

	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CommandFullDuplexStop"
HRESULT CommandFullDuplexStop(SFDTestCommandFullDuplexStop* pfdtcFullDuplexStop, HRESULT* phrIPC)
{
	DPF_ENTER();

	*phrIPC = StopLoopback(
		g_FullDuplexData.lpdpvs, 
		g_FullDuplexData.lpdpvc,
		g_FullDuplexData.lpdp8);

	if( FAILED( *phrIPC ) )
	{
		Diagnostics_Write( DVF_ERRORLEVEL, "Full Duplex Result = 0x%x", *phrIPC );
	}
	else
	{
		Diagnostics_Write( DVF_INFOLEVEL, "Full Duplex Result = DV_OK" );
	}

	DPF_EXIT();
	return DV_OK;
}

/*
#undef DPF_MODNAME
#define DPF_MODNAME "CommandFullDuplexStop"
HRESULT CommandFullDuplexStop(SFDTestCommandFullDuplexStop* pfdtcFullDuplexStop, HRESULT* phrIPC)
{
	HRESULT hr;
	LONG lRet;
	HANDLE hFullDuplexRenderEvent;
	HANDLE hFullDuplexCaptureEvent;
	DWORD dwRet;
	
	DPF_ENTER();

	*phrIPC = S_OK;
	hr = S_OK;

	// wait for one more notification to ensure the buffer is
	// still playing - give the buffer up to 10 times
	// as long as it should need to actually notify us.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Waiting for 2 notifications to confirm playback is still working");
	GlobGuardIn();
	hFullDuplexRenderEvent = g_hFullDuplexRenderEvent;
	GlobGuardOut();
	dwRet = WaitForSingleObject(hFullDuplexRenderEvent, 10 * gc_dwFrameSize);
	if (dwRet != WAIT_OBJECT_0)
	{
		// check for timeout
		if (dwRet == WAIT_TIMEOUT)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Wait for notification timed out! Buffer is not really playing");
			*phrIPC = DVERR_SOUNDINITFAILURE;
		}
		else
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "WaitForSingleObject failed, code: %i", lRet);
			hr = DVERR_WIN32;
			*phrIPC = hr;
		}
	}
	if (SUCCEEDED(hr))
	{
		dwRet = WaitForSingleObject(hFullDuplexRenderEvent, 10 * gc_dwFrameSize);
		if (dwRet != WAIT_OBJECT_0)
		{
			// check for timeout
			if (dwRet == WAIT_TIMEOUT)
			{
				DPFX(DPFPREP, DVF_WARNINGLEVEL, "Wait for notification timed out! Buffer is not really playing");
				*phrIPC = DVERR_SOUNDINITFAILURE;
			}
			else
			{
				lRet = GetLastError();
				DPFX(DPFPREP, DVF_WARNINGLEVEL, "WaitForSingleObject failed, code: %i", lRet);
				hr = DVERR_WIN32;
				*phrIPC = hr;
			}
		}
	}

	// also wait for the capture buffer...
	DPFX(DPFPREP, DVF_INFOLEVEL, "Waiting for 2 notifications to confirm capture is still working");
	GlobGuardIn();
	hFullDuplexCaptureEvent = g_hFullDuplexCaptureEvent;
	GlobGuardOut();
	dwRet = WaitForSingleObject(hFullDuplexCaptureEvent, 10 * gc_dwFrameSize);
	if (dwRet != WAIT_OBJECT_0)
	{
		// check for timeout
		if (dwRet == WAIT_TIMEOUT)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Wait for notification timed out! Buffer is not really playing");
			*phrIPC = DVERR_SOUNDINITFAILURE;
		}
		else
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "WaitForSingleObject failed, code: %i", lRet);
			hr = DVERR_WIN32;
			*phrIPC = hr;
		}
	}
	if (SUCCEEDED(hr))
	{
		dwRet = WaitForSingleObject(hFullDuplexCaptureEvent, 10 * gc_dwFrameSize);
		if (dwRet != WAIT_OBJECT_0)
		{
			// check for timeout
			if (dwRet == WAIT_TIMEOUT)
			{
				DPFX(DPFPREP, DVF_WARNINGLEVEL, "Wait for notification timed out! Buffer is not really playing");
				*phrIPC = DVERR_SOUNDINITFAILURE;
			}
			else
			{
				lRet = GetLastError();
				DPFX(DPFPREP, DVF_WARNINGLEVEL, "WaitForSingleObject failed, code: %i", lRet);
				hr = DVERR_WIN32;
				*phrIPC = hr;
			}
		}
	}

	DPFX(DPFPREP, DVF_INFOLEVEL, "Stopping Capture Buffer");
	GlobGuardIn();
	hr = g_lpdscbFullDuplexCapture->Stop();
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Stop failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
	}
	
	DPFX(DPFPREP, DVF_INFOLEVEL, "Stopping Secondary Buffer");
	GlobGuardIn();
	hr = g_lpdsbFullDuplexSecondary->Stop();
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Stop failed, code: %i", HRESULT_CODE(hr));
		*phrIPC = DVERR_SOUNDINITFAILURE;
	}

	GlobGuardIn();
	if (g_hFullDuplexCaptureEvent != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Closing Capture Buffer Notification Event Handle");
		CloseHandle(g_hFullDuplexCaptureEvent);
		g_hFullDuplexCaptureEvent = NULL;
	}
	if (g_lpdsnFullDuplexCapture != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing DirectSoundNotifier (capture)");
		g_lpdsnFullDuplexCapture->Release();
		g_lpdsnFullDuplexCapture = NULL;
	}
	if (g_lpdscbFullDuplexCapture != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing DirectSoundCaptureBuffer");
		g_lpdscbFullDuplexCapture->Release();
		g_lpdscbFullDuplexCapture = NULL;
	}
	
	if (g_lpdscFullDuplexCapture != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing DirectSoundCapture");
		g_lpdscFullDuplexCapture->Release();
		g_lpdscFullDuplexCapture = NULL;
	}	
	if (g_hFullDuplexRenderEvent != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Closing Secondary Buffer Notification Event Handle");
		if (!CloseHandle(g_hFullDuplexRenderEvent))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "CloseHandle failed, code: %i", lRet);
			*phrIPC = DVERR_WIN32;
			hr = *phrIPC;
		}
		g_hFullDuplexRenderEvent = NULL;
	}
	if (g_lpdsnFullDuplexSecondary != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing Secondary Notifier");
		g_lpdsnFullDuplexSecondary->Release();
		g_lpdsnFullDuplexSecondary = NULL;
	}
	if (g_lpdsbFullDuplexSecondary != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing Secondary Buffer");
		g_lpdsbFullDuplexSecondary->Release();
		g_lpdsbFullDuplexSecondary = NULL;
	}
	if (g_lpdsFullDuplexRender != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing DirectSound");
		g_lpdsFullDuplexRender->Release();
		g_lpdsFullDuplexRender = NULL;
	}
	GlobGuardOut();
	
	DPF_EXIT();
	return hr;
}
*/

/*
#undef DPF_MODNAME
#define DPF_MODNAME "PlayAndCheckRender"
HRESULT PlayAndCheckRender(LPDIRECTSOUNDBUFFER lpdsb, HANDLE hEvent)
{
	HRESULT hr;
	DWORD dwRet;
	LONG lRet;

	DPF_ENTER();
	
	// start playing the secondary buffer
	DPFX(DPFPREP, DVF_INFOLEVEL, "Playing Secondary Buffer");
	GlobGuardIn();
	hr = lpdsb->Play(0, 0, DSBPLAY_LOOPING);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Play failed, code: %i", HRESULT_CODE(hr));
		hr = DVERR_SOUNDINITFAILURE;
		goto error_level_0;
	}

	// wait for the first notification to ensure the buffer has
	// really started to play - give the buffer up to 10 times
	// as long as it should need to actually notify us.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Waiting for notification to confirm playback is working");
	dwRet = WaitForSingleObject(hEvent, 10 * gc_dwFrameSize);
	if (dwRet != WAIT_OBJECT_0)
	{
		// check for timeout
		if (dwRet == WAIT_TIMEOUT)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Wait for notification timed out! Buffer is not really playing");
			hr = DVERR_SOUNDINITFAILURE;
			goto error_level_1;
		}
		else
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "WaitForSingleObject failed, code: %i", lRet);
			hr = DVERR_WIN32;
			goto error_level_1;
		}
	}
	DPFX(DPFPREP, DVF_INFOLEVEL, "First notification received, continuing");

	DPF_EXIT();
	return S_OK;

// error block
error_level_1:
	GlobGuardIn();
	lpdsb->Stop();
	GlobGuardOut();
	
error_level_0:
	DPF_EXIT();
	return hr;
}
*/

/*
#undef DPF_MODNAME
#define DPF_MODNAME "PlayAndCheckCapture"
HRESULT PlayAndCheckCapture(LPDIRECTSOUNDCAPTUREBUFFER lpdscb, HANDLE hEvent)
{
	HRESULT hr;
	DWORD dwRet;
	LONG lRet;

	DPF_ENTER();
	
	// start playing the capture buffer
	DPFX(DPFPREP, DVF_INFOLEVEL, "Starting Capture Buffer");
	GlobGuardIn();
	hr = lpdscb->Start(DSCBSTART_LOOPING);
	GlobGuardOut();
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Start failed, code: %i", HRESULT_CODE(hr));
		hr = DVERR_SOUNDINITFAILURE;
		goto error_level_0;
	}

	// wait for the first notification to ensure the buffer has
	// really started to capture - give the buffer up to 10 times
	// as long as it should need to actually notify us.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Waiting for notification to confirm capture is working");
	dwRet = WaitForSingleObject(hEvent, 10 * gc_dwFrameSize);
	if (dwRet != WAIT_OBJECT_0)
	{
		// check for timeout
		if (dwRet == WAIT_TIMEOUT)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Wait for notification timed out! Buffer is not really playing");
			hr = DVERR_SOUNDINITFAILURE;
			goto error_level_1;
		}
		else
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "WaitForSingleObject failed, code: %i", lRet);
			hr = DVERR_WIN32;
			goto error_level_1;
		}
	}
	DPFX(DPFPREP, DVF_INFOLEVEL, "First notification received, continuing");

	DPF_EXIT();
	return S_OK;

// error block
error_level_1:
	GlobGuardIn();
	lpdscb->Stop();
	GlobGuardOut();
	
error_level_0:
	DPF_EXIT();
	return hr;
}
*/

/*
#undef DPF_MODNAME
#define DPF_MODNAME "AttemptCapture"
HRESULT AttemptCapture()
{
	DPF_ENTER();
	
	DWORD dwIndex;
	BOOL fCaptureFailed;
	HANDLE hFullDuplexCaptureEvent;
	DSBPOSITIONNOTIFY dsbPositionNotify;
	DSCBUFFERDESC dscbd;
	LPDIRECTSOUNDCAPTUREBUFFER lpdscb;
	HRESULT hr;
	HANDLE hEvent;
	WAVEFORMATEX wfx;

	fCaptureFailed = TRUE;
	dwIndex = 0;
	while (1)
	{
		CopyMemory(&wfx, &gc_rgwfxCaptureFormats[dwIndex], sizeof(wfx));
		
		if (wfx.wFormatTag == 0
			&& wfx.nChannels == 0
			&& wfx.nSamplesPerSec == 0
			&& wfx.nAvgBytesPerSec == 0
			&& wfx.nBlockAlign == 0
			&& wfx.wBitsPerSample == 0
			&& wfx.cbSize == 0)
		{
			// we've found the last element of the array, break out.
			break;
		}

		// create the capture buffer
		DPFX(DPFPREP, DVF_INFOLEVEL, "Creating DirectSoundCaptureBuffer");
		ZeroMemory(&dscbd, sizeof(dscbd));
		dscbd.dwSize = sizeof(dscbd);
		dscbd.dwFlags = 0;
		dscbd.dwBufferBytes = 
			(wfx.nSamplesPerSec 
			* wfx.nBlockAlign)
			/ (1000 / gc_dwFrameSize);
		dscbd.dwReserved = 0;
		dscbd.lpwfxFormat = &wfx;
		GlobGuardIn();
		hr = g_lpdscFullDuplexCapture->CreateCaptureBuffer(&dscbd, &g_lpdscbFullDuplexCapture, NULL);
		GlobGuardOut();
		if (FAILED(hr))
		{
			// try the next format
			++dwIndex;
			continue;
		}

		// setup the notifier on the capture buffer
		DPFX(DPFPREP, DVF_INFOLEVEL, "Querying for IDirectSoundNotify");
		GlobGuardIn();
		hr = g_lpdscbFullDuplexCapture->QueryInterface(
			IID_IDirectSoundNotify,
			(LPVOID*)&g_lpdsnFullDuplexCapture);
		GlobGuardOut();
		if (FAILED(hr))
		{
			// Once the above works, this should not fail, so treat
			// this as a real error
			DPFX(DPFPREP, DVF_ERRORLEVEL, "QueryInterface(IID_DirectSoundNotify) failed, code: %i", HRESULT_CODE(hr));
			GlobGuardIn();
			g_lpdscbFullDuplexCapture->Release();
			GlobGuardOut();
			DPF_EXIT();
			return hr;
		}
		
		DPFX(DPFPREP, DVF_INFOLEVEL, "Creating Notification Event");
		GlobGuardIn();
		g_hFullDuplexCaptureEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		hFullDuplexCaptureEvent = g_hFullDuplexCaptureEvent;
		GlobGuardOut();
		if (hFullDuplexCaptureEvent == NULL)
		{
			// Once the above works, this should not fail, so treat
			// this as a real error
			DPFX(DPFPREP, DVF_INFOLEVEL, "CreateEvent failed, code: %i", HRESULT_CODE(hr));
			GlobGuardIn();
			g_lpdscbFullDuplexCapture->Release();
			g_lpdsnFullDuplexCapture->Release();
			GlobGuardOut();
			DPF_EXIT();
			return DVERR_WIN32;
		}

		DPFX(DPFPREP, DVF_INFOLEVEL, "calling SetNotificationPositions");
		dsbPositionNotify.dwOffset = 0;
		dsbPositionNotify.hEventNotify = hFullDuplexCaptureEvent;
		GlobGuardIn();
		hr = g_lpdsnFullDuplexCapture->SetNotificationPositions(1, &dsbPositionNotify);
		GlobGuardOut();
		if (FAILED(hr))
		{
			// Once the above works, this should not fail, so treat
			// this as a real error
			DPFX(DPFPREP, DVF_ERRORLEVEL, "SetNotificationPositions failed, code: %i", HRESULT_CODE(hr));
			GlobGuardIn();
			g_lpdscbFullDuplexCapture->Release();
			g_lpdsnFullDuplexCapture->Release();
			CloseHandle(hFullDuplexCaptureEvent);
			GlobGuardOut();
			DPF_EXIT();
			return hr;
		}

		// start the capture buffer and confirm that it is actually working
		GlobGuardIn();
		lpdscb = g_lpdscbFullDuplexCapture;
		hEvent = g_hFullDuplexCaptureEvent;
		GlobGuardOut();
		hr = PlayAndCheckCapture(lpdscb, hEvent);
		if (FAILED(hr))
		{
			// This can happen, so just try the next format
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Capture verification test failed, code: %i", HRESULT_CODE(hr));
			GlobGuardIn();
			g_lpdscbFullDuplexCapture->Release();
			g_lpdsnFullDuplexCapture->Release();
			CloseHandle(hFullDuplexCaptureEvent);
			GlobGuardOut();
			++dwIndex;
			continue;
		}

		// If we get here, capture is up and running, so return success!
		DPF_EXIT();
		return S_OK;
	}
	// if we get here, none of the formats worked, so return directsound error
	DPF_EXIT();
	return DVERR_SOUNDINITFAILURE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\peakmetr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		peakmetr.h
 *  Content:	Implements a peak meter custom control
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/22/99		pnewson	Created
 ***************************************************************************/

#ifndef _PEAKMETR_H_
#define _PEAKMETR_H_


// How to use this custom control
//
// In your code:
// 1) Include peakmetr.h in your project
// 2) Create an instance of the CPeakMeterWndClass class
// 3) Call Register() on that instance to register the window class
// 4) Send the control PM_SETMAX, PM_SETMIN, PM_SETCUR, PM_SETSTEPS
//    messages as required.
// 5) When you are no longer using the control, call unregister
// 6) Destroy the CPeakMeterWndClass object
//
// In the dialog editor
// 1) Add a "Custom Control" to your dialog box
// 2) In the properties for that custom control, specify
//    "DirectPlayVoicePeakMeter" for the window class

// Peak Meter windows messages:
//
// PM_SETMIN
// wParam = 0;
// lParam = (LPARAM)dwNewMinValue;
//
// Set the new minimum value for the peak meter, i.e. the
// value that represents the bottom of the meter range.
// If this message is not sent, the control defaults to 0.
// The message returns an HRESULT
//
// PM_SETMAX
// wParam = 0;
// lParam = (LPARAM)dwNewMaxValue;
//
// Set the new maximum value for the peak meter, i.e. the
// value that represents the top of the meter range.
// If this message is not sent, the control defaults to 0xffffffff.
// The message returns an HRESULT
//
// PM_SETCUR
// wParam = 0;
// lParam = (LPARAM)dwNewCurValue;
//
// Set the new current value for the peak meter, i.e. the
// value tells the meter where in it's range it should be.
// If this message is not sent, the control defaults to 0.
//
// Sending this message causes the control to call InvalidateRgn
// on its window, but does not call UpdateWindow. This allows
// the caller to be lazy or quick about actually redrawing
// the peak meter.
// The message returns an HRESULT
//
// PM_SETSTEPS
// wParam = 0;
// lParam = (LPARAM)dwNewMaxValue;
//
// Suggest to the peak meter the number of bars it should
// display. The bars have a minimum size, so depending on
// the size of the control, the peak meter may not be able
// to honor the request.
// If this message is not sent, the control defaults to 20
// The message returns an HRESULT

#define PM_SETMAX 	WM_USER + 1
#define PM_SETMIN 	WM_USER + 2
#define PM_SETCUR 	WM_USER + 3
#define PM_SETSTEPS WM_USER + 4

class CPeakMeterWndClass
{
private:
	HINSTANCE m_hinst;

public:
	HRESULT Register();
	HRESULT Unregister();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\priority.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       priority.cpp
 *  Content:    Implements a process that uses DirectSound in prioirty
 *				mode to simulate an aggressive external playback only 
 *				application (such as a game) that may be running while
 *              the full duplex application is in use. Note that WinMain 
 *              is in fdtest.cpp, but the guts are here.
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 *  10/28/99	pnewson Bug #113937 audible clicking during full duplex test
 * 11/02/99		pnewson Fix: Bug #116365 - using wrong DSBUFFERDESC
 *  01/21/2000	pnewson 	Workaround for broken SetNotificationPositions call.
 *							undef DSOUND_BROKEN once the SetNotificationPositions
 *                          no longer broken.
 *	02/15/2000  pnewson		Removed the workaround for bug 116365
 *	04/04/2000  pnewson		Changed a SendMessage to PostMessage to fix deadlock
 *  04/19/2000	pnewson	    Error handling cleanup  
 *  07/12/2000	rodtoll		Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 *  08/25/2000	rodtoll		Bug #43363 - CommandPriorityStart does not init return param and uses stack trash.  
 *
 ***************************************************************************/

#include "dxvtlibpch.h"
 

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


static HRESULT CommandLoop(CPriorityIPC* lpipcPriority);
static HRESULT DispatchCommand(CPriorityIPC* lpipcPriority, SFDTestCommand* pfdtc);
static HRESULT CommandPriorityStart(SFDTestCommandPriorityStart* pfdtcPriorityStart, HRESULT* phrIPC);
static HRESULT CommandPriorityStop(SFDTestCommandPriorityStop* pfdtcPriorityStop, HRESULT* phrIPC);

#undef DPF_MODNAME
#define DPF_MODNAME "PriorityProcess"
HRESULT PriorityProcess(HINSTANCE hResDLLInstance, HINSTANCE hPrevInstance, TCHAR *szCmdLine, int iCmdShow)
{
	
	//DEBUG_ONLY(_asm int 3;)

	DPF_ENTER();

	HRESULT hr;
	CPriorityIPC ipcPriority;	
	BOOL fIPCInit = FALSE;
	BOOL fGuardInit = FALSE;

	if (!InitGlobGuard())
	{
		return DVERR_OUTOFMEMORY;
	}
	fGuardInit = TRUE;

	// Init the common control library. Use the old style
	// call, so we're compatibile right back to 95.
	InitCommonControls();

	// get the mutex, events and shared memory stuff
	hr = ipcPriority.Init();
	if (FAILED(hr))
	{
		goto error_cleanup;
	}
	fIPCInit = TRUE;
	
	// start up the testing loop
	hr = CommandLoop(&ipcPriority);
	if (FAILED(hr))
	{
		goto error_cleanup;
	}

	// close the mutex, events and shared memory stuff
	hr = ipcPriority.Deinit();
	fIPCInit = FALSE;
	if (FAILED(hr))
	{
		goto error_cleanup;
	}

	DeinitGlobGuard();

	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (fIPCInit == TRUE)
	{
		ipcPriority.Deinit();
		fIPCInit = FALSE;
	}

	if (fGuardInit == TRUE)
	{
		DeinitGlobGuard();
		fGuardInit = FALSE;
	}
	
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CommandLoop"
static HRESULT CommandLoop(CPriorityIPC* lpipcPriority)
{
	DPF_ENTER();
	
	BOOL fRet;
	LONG lRet;
	HRESULT hr;
	DWORD dwRet;
	SFDTestCommand fdtc;
	
	// Kick the supervisor process to let it know
	// we're ready to go.
	hr = lpipcPriority->SignalParentReady();
	if (FAILED(hr))
	{
		DPF_EXIT();
		return hr;
	}
	
	// enter the main command loop
	while (1)
	{
		// wait for a command from the supervisor process
		fdtc.dwSize = sizeof(fdtc);
		hr = lpipcPriority->Receive(&fdtc);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "CPriorityIPC::Receive() failed, hr: 0x%x", hr);
			break;
		}

		// dispatch the command
		hr = DispatchCommand(lpipcPriority, &fdtc);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DispatchCommand() failed, hr: 0x%x", hr);
			break;
		}
		if (hr == DV_EXIT)
		{
			DPFX(DPFPREP, DVF_INFOLEVEL, "Exiting Priority process command loop");
			break;
		}
	}

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DispatchCommand"
static HRESULT DispatchCommand(CPriorityIPC* lpipcPriority, SFDTestCommand* pfdtc)
{
	DPF_ENTER();
	
	HRESULT hr;
	HRESULT hrIPC;

	switch (pfdtc->fdtcc)
	{
	case fdtccExit:
		// ok - reply to the calling process to let them
		// know we are getting out.
		DPFX(DPFPREP, DVF_INFOLEVEL, "Priority received Exit command");
		lpipcPriority->Reply(DV_EXIT);

		// returning this code will break us out of
		// the command processing loop
		DPF_EXIT();
		return DV_EXIT;

	case fdtccPriorityStart:
		hr = CommandPriorityStart(&(pfdtc->fdtu.fdtcPriorityStart), &hrIPC);
		if (FAILED(hr))
		{
			lpipcPriority->Reply(hrIPC);
			DPF_EXIT();
			return hr;
		}
		hr = lpipcPriority->Reply(hrIPC);
		DPF_EXIT();
		return hr;

	case fdtccPriorityStop:
		hr = CommandPriorityStop(&(pfdtc->fdtu.fdtcPriorityStop), &hrIPC);
		if (FAILED(hr))
		{
			lpipcPriority->Reply(hrIPC);
			DPF_EXIT();
			return hr;
		}
		hr = lpipcPriority->Reply(hrIPC);
		DPF_EXIT();
		return hr;
			
	default:
		// Don't know this command. Reply with the appropriate
		// code.
		DPFX(DPFPREP, DVF_INFOLEVEL, "Priority received Unknown command");
		hr = lpipcPriority->Reply(DVERR_UNKNOWN);
		if (FAILED(hr))
		{
			DPF_EXIT();
			return hr;
		}
		
		// While this is an error, it is one that the calling
		// process needs to figure out. In the meantime, this
		// process will happily continue on.
		DPF_EXIT();
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CommandPriorityStart"
HRESULT CommandPriorityStart(SFDTestCommandPriorityStart* pfdtcPriorityStart, HRESULT* phrIPC)
{
	DPF_ENTER();
	*phrIPC = DV_OK;	
	HRESULT hr = S_OK;
	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;
	DWORD dwSizeWritten;
	DSBCAPS	 dsbc;
	LPVOID lpvAudio1 = NULL;
	DWORD dwAudio1Size = NULL;
	LPVOID lpvAudio2 = NULL;
	DWORD dwAudio2Size = NULL;
	DSBPOSITIONNOTIFY dsbPositionNotify;
	DWORD dwRet;
	LONG lRet;
	BOOL fRet;
	HWND hwnd;
	BYTE bSilence;
	BOOL bBufferPlaying = FALSE;
	GUID guidTmp;

	memset( &guidTmp, 0x00, sizeof( GUID ) );

	// initalize the global vars
	GlobGuardIn();
	g_lpdsPriorityRender = NULL;
	g_lpdsbPriorityPrimary = NULL;
	g_lpdsbPrioritySecondary = NULL;
	GlobGuardOut();

	Diagnostics_Write( DVF_INFOLEVEL, "-----------------------------------------------------------" );

	hr = Diagnostics_DeviceInfo( &pfdtcPriorityStart->guidRenderDevice, &guidTmp );

	if( FAILED( hr ) )
	{
		Diagnostics_Write( 0, "Error getting device information hr=0x%x", hr );
	}

	Diagnostics_Write( DVF_INFOLEVEL, "-----------------------------------------------------------" );
	Diagnostics_Write( DVF_INFOLEVEL, "Primary Format: " );

	Diagnositcs_WriteWAVEFORMATEX( DVF_INFOLEVEL, &pfdtcPriorityStart->wfxRenderFormat );

	// make sure the priority dialog is in the foreground
	DPFX(DPFPREP, DVF_INFOLEVEL, "Bringing Wizard to the foreground");
	fRet = SetForegroundWindow(pfdtcPriorityStart->hwndWizard);
	if (!fRet)
	{
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Unable to bring wizard to foreground, continuing anyway...");
	}

	// kick the progress bar forward one tick
	DPFX(DPFPREP, DVF_INFOLEVEL, "Incrementing progress bar in dialog");
	PostMessage(pfdtcPriorityStart->hwndProgress, PBM_STEPIT, 0, 0);

	// create the DirectSound interface
	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating DirectSound");
	GlobGuardIn();
	hr = DirectSoundCreate(&pfdtcPriorityStart->guidRenderDevice, &g_lpdsPriorityRender, NULL);
	if (FAILED(hr))
	{
		g_lpdsPriorityRender = NULL;
		GlobGuardOut();
		Diagnostics_Write(DVF_ERRORLEVEL, "DirectSoundCreate failed, code: 0x%x", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}
	GlobGuardOut();
	
	// set to priority mode
	DPFX(DPFPREP, DVF_INFOLEVEL, "Setting Cooperative Level");
	GlobGuardIn();
	hr = g_lpdsPriorityRender->SetCooperativeLevel(pfdtcPriorityStart->hwndWizard, DSSCL_PRIORITY);
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "SetCooperativeLevel failed, code: 0x%x", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	// Create a primary buffer object with 3d controls.
	// We're not actually going to use the controls, but a game probably would,
	// and we are really trying to emulate a game in this process.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating Primary Sound Buffer");
	ZeroMemory(&dsbd, sizeof(dsbd));
	dsbd.dwSize = sizeof(dsbd);
	dsbd.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_PRIMARYBUFFER;
	dsbd.dwBufferBytes = 0;
	dsbd.dwReserved = 0;
	dsbd.lpwfxFormat = NULL;
	dsbd.guid3DAlgorithm = DS3DALG_DEFAULT;	
	GlobGuardIn();
   	hr = g_lpdsPriorityRender->CreateSoundBuffer((LPDSBUFFERDESC)&dsbd, &g_lpdsbPriorityPrimary, NULL);
	if (FAILED(hr))
	{
		g_lpdsbPriorityPrimary = NULL;
		GlobGuardOut();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateSoundBuffer failed, code: 0x%x", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}
	GlobGuardOut();

	// Set the format of the primary buffer to the requested format.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Setting Primary Buffer Format");

	GlobGuardIn();
	hr = g_lpdsbPriorityPrimary->SetFormat(&pfdtcPriorityStart->wfxRenderFormat);
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "SetFormat failed, code: 0x%x ", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	// check to make sure the SetFormat actually worked
	DPFX(DPFPREP, DVF_INFOLEVEL, "Verifying Primary Buffer Format");
	GlobGuardIn();
	hr = g_lpdsbPriorityPrimary->GetFormat(&wfx, sizeof(wfx), &dwSizeWritten);
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetFormat failed, code: 0x%x ", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	if (dwSizeWritten != sizeof(wfx))
	{
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	if (memcmp(&wfx, &pfdtcPriorityStart->wfxRenderFormat, sizeof(wfx)) != 0)
	{
		// This is an interesting case. Is it really a full duplex error that
		// we are unable to initialize a primary buffer in this format?
		// Perhaps not. Perhaps it is sufficient that we can get full duplex
		// sound even if the forground priority mode app attempts to play
		// using this format. So just dump a debug note, and move along...
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: SetFormat on primary buffer did not actually set the format");
	}

	// Create a secondary buffer object with 3d controls.
	// We're not actually going to use the controls, but a game probably would,
	// and we are really trying to emulate a game in this process.
	DPFX(DPFPREP, DVF_INFOLEVEL, "Creating Secondary Buffer");
	dsbd.dwSize = sizeof(dsbd);
	dsbd.dwFlags = DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_CTRLPOSITIONNOTIFY;

	dsbd.dwBufferBytes = 
		(pfdtcPriorityStart->wfxSecondaryFormat.nSamplesPerSec 
		* pfdtcPriorityStart->wfxSecondaryFormat.nBlockAlign)
		/ (1000 / gc_dwFrameSize);
	dsbd.dwReserved = 0;
	dsbd.guid3DAlgorithm = DS3DALG_DEFAULT;
	dsbd.lpwfxFormat = &(pfdtcPriorityStart->wfxSecondaryFormat);

	GlobGuardIn();
   	hr = g_lpdsPriorityRender->CreateSoundBuffer((LPDSBUFFERDESC)&dsbd, &g_lpdsbPrioritySecondary, NULL);
	if (FAILED(hr))
	{
		g_lpdsbPrioritySecondary = NULL;
		GlobGuardOut();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateSoundBuffer failed, code: 0x%x Primary ", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}
	GlobGuardOut();

	// clear out the secondary buffer
	DPFX(DPFPREP, DVF_INFOLEVEL, "Clearing Secondary Buffer");
	GlobGuardIn();
	hr = g_lpdsbPrioritySecondary->Lock(
		0,
		0,
		&lpvAudio1,
		&dwAudio1Size,
		&lpvAudio2,
		&dwAudio2Size, 
		DSBLOCK_ENTIREBUFFER);
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Lock failed, code: 0x%x ", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	if (lpvAudio1 == NULL)
	{
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	if (pfdtcPriorityStart->wfxSecondaryFormat.wBitsPerSample == 8)
	{
		bSilence = 0x80;
	}
	else
	{
		bSilence = 0x00;
	}
	memset(lpvAudio1, bSilence, dwAudio1Size);
	if (lpvAudio2 != NULL)
	{
		memset(lpvAudio2, bSilence, dwAudio2Size);
	}

	GlobGuardIn();
	hr = g_lpdsbPrioritySecondary->Unlock(
		lpvAudio1, 
		dwAudio1Size, 
		lpvAudio2, 
		dwAudio2Size);
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unlock failed, code: 0x%x ", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}

	// start playing the secondary buffer
	DPFX(DPFPREP, DVF_INFOLEVEL, "Playing Secondary Buffer");
	GlobGuardIn();
	hr = g_lpdsbPrioritySecondary->Play(0, 0, DSBPLAY_LOOPING);
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Play failed, code: 0x%x ", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
		goto error_cleanup;
	}
	bBufferPlaying = TRUE;
	
	DPF_EXIT();

	Diagnostics_Write(DVF_INFOLEVEL, "Priority Result = DV_OK" );

	return DV_OK;

error_cleanup:
	GlobGuardIn();
	
	if (bBufferPlaying == TRUE)
	{
		if (g_lpdsbPrioritySecondary != NULL)
		{
			g_lpdsbPrioritySecondary->Stop();
		}
		bBufferPlaying = FALSE;
	}

	if (g_lpdsbPrioritySecondary != NULL)
	{
		g_lpdsbPrioritySecondary->Release();
		g_lpdsbPrioritySecondary = NULL;
	}

	if (g_lpdsbPriorityPrimary != NULL)
	{
		g_lpdsbPriorityPrimary->Release();
		g_lpdsbPriorityPrimary = NULL;
	}

	if (g_lpdsPriorityRender != NULL)
	{
		g_lpdsPriorityRender->Release();
		g_lpdsPriorityRender = NULL;
	}
	
	GlobGuardOut();
	
	DPF_EXIT();
	Diagnostics_Write(DVF_INFOLEVEL, "Priority Result = 0x%x", hr );
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CommandPriorityStop"
HRESULT CommandPriorityStop(SFDTestCommandPriorityStop* pfdtcPriorityStop, HRESULT* phrIPC)
{
	DPF_ENTER();
	
	HRESULT hr;
	LONG lRet;
	DWORD dwRet;
	
	*phrIPC = S_OK;
	hr = S_OK;
	
	GlobGuardIn();
	if (g_lpdsbPrioritySecondary != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Stopping Secondary Buffer");
		hr = g_lpdsbPrioritySecondary->Stop();
	}
	GlobGuardOut();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Stop failed, code: 0x%x", hr);
		*phrIPC = DVERR_SOUNDINITFAILURE;
		hr = DV_OK;
	}		

	GlobGuardIn();
	
	if (g_lpdsbPrioritySecondary != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing Secondary Buffer");
		g_lpdsbPrioritySecondary->Release();
		g_lpdsbPrioritySecondary = NULL;
	}
	if (g_lpdsbPriorityPrimary != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing Primary Buffer");
		g_lpdsbPriorityPrimary->Release();
		g_lpdsbPriorityPrimary = NULL;
	}
	if (g_lpdsPriorityRender != NULL)
	{
		DPFX(DPFPREP, DVF_INFOLEVEL, "Releasing DirectSound");
		g_lpdsPriorityRender->Release();
		g_lpdsPriorityRender = NULL;
	}
	GlobGuardOut();
	
	DPF_EXIT();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\priority.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       priority.h
 *  Content:    Prototypes the PriorityProcess function
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#ifndef _PRIORITY_H_
#define _PRIORITY_H_

HRESULT PriorityProcess(HINSTANCE hResDLLInstance, HINSTANCE hPrevInstance, TCHAR *szCmdLine, int iCmdShow);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\loopback.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		loopback.cpp
 *  Content:	Implements the loopback portion of the full duplex test
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/10/99		pnewson	Created
 * 10/25/99		rodtoll	Removed lpszVoicePassword member from sessiondesc
 * 10/27/99		pnewson Fix: Bug #113936 - Wizard should reset the AGC level before loopback test 
 *						Note: this fix adds the DVCLIENTCONFIG_AUTOVOLUMERESET flag
 *  10/28/99	pnewson Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/04/99	pnewson Bug #115279 changed SendMessage to PostMessage to resolve some deadlocks
 *  11/30/99	pnewson	use default codec
 *						use devices passed to CheckAudioSetup, instead of default devices
 *  12/01/99	rodtoll	Added flag to cause wizard to auto-select the microphone
 *  01/14/2000	rodtoll	Updated with API changes  
 *  01/21/2000	pnewson	Updated for UI revisions
 *						Updated to support use of loopback tests for full duplex testing
 *  01/27/2000	rodtoll	Updated with API changes
 *  02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected 
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/19/2000	pnewson	    Error handling cleanup  
 * 04/21/2000  rodtoll   Bug #32952 Does not run on Win95 GOLD w/o IE4 installed
 * 06/21/2000	rodtoll	Updated to use new parameters
 * 06/28/2000	rodtoll	Prefix Bug #38022
 *  07/31/2000	rodtoll	Bug #39590 - SB16 class soundcards are passing when they should fail
 *						Half duplex code was being ignored in mic test portion. 
 *  08/28/2000	masonb  Voice Merge: Changed ccomutil.h to ccomutil.h
 * 08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *  11/29/2000	rodtoll	Bug #48348 - DPVOICE: Modify wizard to make use of DirectPlay8 as the transport. 
 *						NOTE: Now requires a TCP/IP adapter to be present (or at least loopback)
 * 02/04/2001	simonpow	Bug #354859 PREfast spotted errors (PostMessage return codes incorrectly
 *							treated as HRESULTs)
 * 04/12/2001	kareemc	WINBUG #360971 - Wizard Memory Leaks
 * 
 ***************************************************************************/

#include "dxvtlibpch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// application defined message ids
//#define WMAPP_LOOPBACKRUNNING 	WM_USER + 1
//#define WMAPP_INPUTVOLUME		WM_USER + 2

// {53CA3FB7-4FD5-4a67-99E4-6F2496E6FEC2}
static const GUID GUID_LOOPBACKTEST = 
	{ 0x53ca3fb7, 0x4fd5, 0x4a67, { 0x99, 0xe4, 0x6f, 0x24, 0x96, 0xe6, 0xfe, 0xc2 } };

HRESULT StartDirectPlay( PDIRECTPLAY8SERVER* lplpdp8 );
HRESULT StopDirectPlay( PDIRECTPLAY8SERVER lpdp8 );

#undef DPF_MODNAME
#define DPF_MODNAME "DVMessageHandlerServer"
HRESULT PASCAL DVMessageHandlerServer( 
	LPVOID 		lpvUserContext,
	DWORD 		dwMessageType,
	LPVOID  	lpMessage
)
{
	DPF_ENTER();
	switch( dwMessageType )
	{
	case DVMSGID_CREATEVOICEPLAYER:
		break;
	case DVMSGID_DELETEVOICEPLAYER:
		break;
	case DVMSGID_SESSIONLOST:
		break;
	case DVMSGID_PLAYERVOICESTART:
		break;
	case DVMSGID_PLAYERVOICESTOP:
		break;
	case DVMSGID_RECORDSTART:
		break;
	case DVMSGID_RECORDSTOP:
		break;
	case DVMSGID_CONNECTRESULT:
		break;		
	case DVMSGID_DISCONNECTRESULT:
		break;
	case DVMSGID_INPUTLEVEL:
		break;
	case DVMSGID_OUTPUTLEVEL:
		break;
	default:
		break;
	}

	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVMessageHandlerClient"
HRESULT PASCAL DVMessageHandlerClient( 
	LPVOID 		lpvUserContext,
	DWORD 		dwMessageType,
	LPVOID    	lpMessage
)
{
	DPF_EXIT();

	HWND hwndDialog;
	HWND hwndPeakMeter;
	HWND hwndSlider;
	LONG lRet;
	HRESULT hr;
	CSupervisorInfo* lpsinfo;
	PDVMSG_INPUTLEVEL pdvInputLevel;
	PDVMSG_OUTPUTLEVEL pdvOutputLevel;

	lpsinfo = (CSupervisorInfo*)lpvUserContext;

	if( lpsinfo )
	{
		if( !lpsinfo->GetLoopbackRunning() )
			return DV_OK;
	}

	
	switch( dwMessageType )
	{
	case DVMSGID_CREATEVOICEPLAYER:
		break;
	case DVMSGID_DELETEVOICEPLAYER:
		break;
	case DVMSGID_SESSIONLOST:
		break;
	case DVMSGID_PLAYERVOICESTART:
		break;
	case DVMSGID_PLAYERVOICESTOP:
		break;
	case DVMSGID_RECORDSTART:
		if (lpsinfo == NULL)
		{
			break;
		}

		// forward the message along to the appropriate window
		lpsinfo->GetHWNDDialog(&hwndDialog);
		if (!PostMessage(hwndDialog, WM_APP_RECORDSTART, 0, 0))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "PostMessage failed, code: %i", GetLastError());
			break;	// no error return, just continue
		}
		break;
		
	case DVMSGID_RECORDSTOP:
		if (lpsinfo == NULL)
		{
			break;
		}
		
		// forward the message along to the appropriate window
		lpsinfo->GetHWNDDialog(&hwndDialog);
		if (!PostMessage(hwndDialog, WM_APP_RECORDSTOP, 0, 0))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "PostMessage failed, code: %i", GetLastError());
			break;	// no error return, just continue
		}
		break;
		
	case DVMSGID_CONNECTRESULT:
		break;		
	case DVMSGID_DISCONNECTRESULT:
		break;
	case DVMSGID_INPUTLEVEL:
		if (lpsinfo == NULL)
		{
			break;
		}
		// update the peak meter
		lpsinfo->GetHWNDInputPeak(&hwndPeakMeter);
		if (IsWindow(hwndPeakMeter))
		{
			pdvInputLevel = (PDVMSG_INPUTLEVEL) lpMessage;
			if (!PostMessage(hwndPeakMeter, PM_SETCUR, 0, pdvInputLevel->dwPeakLevel ))
			{
				DPFX(DPFPREP, DVF_ERRORLEVEL, "PostMessage failed, code: %i", GetLastError());
				break;	// no error return, just continue
			}
		}

		// update the volume slider
		lpsinfo->GetHWNDInputVolumeSlider(&hwndSlider);
		if (IsWindow(hwndSlider))
		{
			pdvInputLevel = (PDVMSG_INPUTLEVEL) lpMessage;
			if (!PostMessage(hwndSlider, TBM_SETPOS, 1, DBToAmpFactor(DSBVOLUME_MAX)-DBToAmpFactor(pdvInputLevel->lRecordVolume)))
			{
				DPFX(DPFPREP, DVF_ERRORLEVEL, "PostMessage failed, code: %i", GetLastError());
				break;	// no error return, just continue
			}
		}
		
		break;
		
	case DVMSGID_OUTPUTLEVEL:
		if (lpsinfo == NULL)
		{
			break;
		}
		// update the peak meter
		lpsinfo->GetHWNDOutputPeak(&hwndPeakMeter);
		if (IsWindow(hwndPeakMeter))
		{
			pdvOutputLevel = (PDVMSG_OUTPUTLEVEL) lpMessage;
			if (!PostMessage(hwndPeakMeter, PM_SETCUR, 0, pdvOutputLevel->dwPeakLevel ))
			{
				DPFX(DPFPREP, DVF_ERRORLEVEL, "PostMessage failed, code: %i", GetLastError());
				break;	// no error return, just continue
			}
		}

		// update the volume slider
		lpsinfo->GetHWNDOutputVolumeSlider(&hwndSlider);
		if (IsWindow(hwndSlider))
		{
			DWORD dwVolume = 0;	// Set to 0 to avoid PREFIX bug

			// Get the current waveOut volume and set the slider to that position
			hr = lpsinfo->GetWaveOutVolume(&dwVolume);
			if (FAILED(hr))
			{
				// couldn't get the volume - set the slider to top
				PostMessage(hwndSlider, TBM_SETPOS, 1, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
				// disable the slider
				PostMessage(hwndSlider, WM_CANCELMODE, 0, 0 );
			}
			else
			{
				PostMessage(hwndSlider, TBM_SETPOS, 1, (DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN)) - dwVolume);
			}
		}
		
		break;

	default:
		break;
	}

	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "StartDirectPlay"
HRESULT StartDirectPlay( PDIRECTPLAY8SERVER* lplpdp8 )
{
	HRESULT hr = DPN_OK;
	LONG lRet = S_OK;
    PDIRECTPLAY8ADDRESS pDeviceAddress = NULL;
    PDIRECTPLAY8SERVER pdp8Server = NULL;
    DPN_APPLICATION_DESC dpnApplicationDesc;

	DPF_ENTER();

	*lplpdp8 = NULL;
	
    hr = COM_CoCreateInstance(
    	CLSID_DirectPlay8Server, 
    	NULL, 
    	CLSCTX_INPROC_SERVER, 
    	IID_IDirectPlay8Server, 
    	(void **)lplpdp8);
    if (FAILED(hr))
    {
    	*lplpdp8 = NULL;
    	DPFX(DPFPREP, DVF_ERRORLEVEL, "CoCreateInstance for DirectPlay failed, code: %i", hr);
    	goto error_cleanup;
    }

    pdp8Server = *lplpdp8;

    hr = COM_CoCreateInstance( 
        CLSID_DirectPlay8Address, 
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IDirectPlay8Address,
        (void **)&pDeviceAddress );

    if( FAILED( hr ) )
    {
        pDeviceAddress = NULL;
        DPFX(DPFPREP, DVF_ERRORLEVEL, "CoCreateInstance for DirectPlay8Address failed, code: 0x%x", hr );
        goto error_cleanup;
    }

	// 
	// NOTE: This now causes the wizard to require TCP/IP to be installed.
	// (doesn't have to be dialed up -- as long as local loopback is available)
	//
	// Eventually build a loopback SP for directplay8.
	//
	// TODO: Allow this to fall back to other SPs or use loopback SP
	//
    hr = pDeviceAddress->SetSP( &CLSID_DP8SP_TCPIP );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed setting SP for address, code: 0x%x", hr );
        goto error_cleanup;
    }

    hr = pdp8Server->Initialize( NULL, DVMessageHandlerServer, 0 );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed initializing directplay layer, code: 0x%x", hr );
        goto error_cleanup;
    }

    ZeroMemory( &dpnApplicationDesc, sizeof( DPN_APPLICATION_DESC ) );
    dpnApplicationDesc.dwSize = sizeof( DPN_APPLICATION_DESC );
    dpnApplicationDesc.guidApplication = GUID_LOOPBACKTEST;
    dpnApplicationDesc.dwFlags = DPNSESSION_NODPNSVR | DPNSESSION_CLIENT_SERVER;

    hr = pdp8Server->Host( 
                        &dpnApplicationDesc, 
                        &pDeviceAddress, 
                        1, 
                        NULL,
                        NULL,
                        NULL, 
                        0 );

    if( FAILED( hr ) )
    {
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to host on directplay layer, code: 0x%x", hr );
        goto error_cleanup;
    }

    pDeviceAddress->Release();

	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (*lplpdp8 != NULL)
	{
	    pdp8Server->Close(0);
	    pdp8Server->Release();
		*lplpdp8 = NULL;
	}

	if( pDeviceAddress )
	{
		pDeviceAddress->Release();
	}

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "StopDirectPlay"
HRESULT StopDirectPlay(PDIRECTPLAY8SERVER lpdp8)
{

	DPF_ENTER();

	// Kill the session
	if (lpdp8 != NULL)
	{
        lpdp8->Close(0);

        lpdp8->Release();
	}

	
	DPF_EXIT();
	return S_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "StartLoopback"
HRESULT StartLoopback(
	LPDIRECTPLAYVOICESERVER* lplpdvs, 
	LPDIRECTPLAYVOICECLIENT* lplpdvc,
	PDIRECTPLAY8SERVER* lplpdp8, 
	LPVOID lpvCallbackContext,
	HWND hwndAppWindow,
	GUID guidCaptureDevice,
	GUID guidRenderDevice,
	DWORD dwFlags)
{
	HRESULT hr;
	DWORD dwSize = 0;
	DVCLIENTCONFIG dvcc;
	DVSOUNDDEVICECONFIG dvsdc;
	DVID dvidAllPlayers = DVID_ALLPLAYERS;	
	PBYTE pDeviceConfigBuffer = NULL;
	PDVSOUNDDEVICECONFIG pdvsdc = NULL;
	BOOL fVoiceSessionStarted = FALSE;
	BOOL fClientConnected = FALSE;

	DPF_ENTER();

	*lplpdvs = NULL;
	*lplpdvc = NULL;

	hr = COM_CoCreateInstance(
		DPVOICE_CLSID_DPVOICE, 
		NULL, 
		CLSCTX_INPROC_SERVER, 
		IID_IDirectPlayVoiceServer, 
		(void **)lplpdvs);
	if (FAILED(hr))
	{
		*lplpdvs = NULL;
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CoCreateInstance failed, code: %i", hr);
		goto error_cleanup;
	}

	hr = (*lplpdvs)->Initialize(*lplpdp8, DVMessageHandlerServer, lpvCallbackContext, NULL, 0);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceServer::Initialize failed, code: %i", hr);
		goto error_cleanup;
	}

	DVSESSIONDESC dvSessionDesc;

	dvSessionDesc.dwSize = sizeof( DVSESSIONDESC );
	dvSessionDesc.dwBufferAggressiveness = DVBUFFERAGGRESSIVENESS_DEFAULT;
	dvSessionDesc.dwBufferQuality = DVBUFFERQUALITY_DEFAULT;
	dvSessionDesc.dwFlags = 0;
	dvSessionDesc.dwSessionType = DVSESSIONTYPE_ECHO;
	// Note this compression type is used for its short frame size so
	// we can quickly detect lockups.
    dvSessionDesc.guidCT = DPVCTGUID_NONE;     

	hr = (*lplpdvs)->StartSession( &dvSessionDesc, 0 );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceServer::StartSession failed, code: %i", hr);
		goto error_cleanup;
	}
	fVoiceSessionStarted = TRUE;
	
	hr = COM_CoCreateInstance(
		DPVOICE_CLSID_DPVOICE, 
		NULL, 
		CLSCTX_INPROC_SERVER, 
		IID_IDirectPlayVoiceClient, 
		(void **)lplpdvc);
	if (FAILED(hr))
	{
		*lplpdvc = NULL;
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CoCreateInstance failed, code: %i", hr);
		goto error_cleanup;
	}

	hr = (*lplpdvc)->Initialize(*lplpdp8, DVMessageHandlerClient, lpvCallbackContext, NULL, 0);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceClient::Initialize failed, code: %i", hr);
		goto error_cleanup;
	}

	dvsdc.dwSize = sizeof( DVSOUNDDEVICECONFIG );
	dvsdc.hwndAppWindow = hwndAppWindow;
	dvsdc.dwFlags = DVSOUNDCONFIG_AUTOSELECT;
	if (dwFlags & DVSOUNDCONFIG_HALFDUPLEX)
	{
		// The caller wants a half duplex session.
		dvsdc.dwFlags |= DVSOUNDCONFIG_HALFDUPLEX;
	}
	if (dwFlags & DVSOUNDCONFIG_TESTMODE)
	{
		// The caller wants a test mode session.
		dvsdc.dwFlags |= DVSOUNDCONFIG_TESTMODE;
	}
	dvsdc.guidCaptureDevice = guidCaptureDevice;
	dvsdc.guidPlaybackDevice = guidRenderDevice;
	dvsdc.lpdsPlaybackDevice = NULL;
	dvsdc.lpdsCaptureDevice = NULL;
	dvsdc.dwMainBufferFlags = 0;
	dvsdc.dwMainBufferPriority = 0;
	dvsdc.lpdsMainBuffer = NULL;

	dvcc.dwSize = sizeof( DVCLIENTCONFIG );
	dvcc.dwFlags = 
		DVCLIENTCONFIG_AUTOVOICEACTIVATED | 
		DVCLIENTCONFIG_AUTORECORDVOLUME | DVCLIENTCONFIG_AUTOVOLUMERESET |
		DVCLIENTCONFIG_PLAYBACKMUTE;  // we don't want the user to hear his/her voice right away
	dvcc.dwThreshold = DVTHRESHOLD_UNUSED;
	dvcc.lPlaybackVolume = DSBVOLUME_MAX;
	dvcc.lRecordVolume = DSBVOLUME_MAX;
	dvcc.dwNotifyPeriod = 50;
	dvcc.dwBufferQuality = DVBUFFERQUALITY_DEFAULT;
	dvcc.dwBufferAggressiveness = DVBUFFERAGGRESSIVENESS_DEFAULT;

	hr = (*lplpdvc)->Connect( &dvsdc, &dvcc, DVFLAGS_SYNC|DVFLAGS_NOQUERY );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceClient::Connect failed, code: %i", hr);
		goto error_cleanup;
	}
	fClientConnected = TRUE;

	hr = (*lplpdvc)->SetTransmitTargets(&dvidAllPlayers, 1 , 0);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceClient::SetTransmitTargets failed, code: %i", hr);
		goto error_cleanup;
	}
	
	dwSize = 0;
	hr = (*lplpdvc)->GetSoundDeviceConfig(pdvsdc, &dwSize);
	if( hr != DVERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "IDirectPlayVoiceClient::GetSoundDeviceConfig failed, hr: %i", hr);
		goto error_cleanup;
	}

	pDeviceConfigBuffer = new BYTE[dwSize];
	if( pDeviceConfigBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
		hr = DVERR_OUTOFMEMORY;
		goto error_cleanup;
	}

	pdvsdc = (PDVSOUNDDEVICECONFIG) pDeviceConfigBuffer;
	pdvsdc->dwSize = sizeof( DVSOUNDDEVICECONFIG );

	hr = (*lplpdvc)->GetSoundDeviceConfig(pdvsdc, &dwSize );
	if (FAILED(hr))
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "IDirectPlayVoiceClient::GetSoundDeviceConfig failed, hr: %i", hr);
		goto error_cleanup;
	}

	// If we're looking for full duplex fail and notify caller if we get half duplex
	if( !(dwFlags & DVSOUNDCONFIG_HALFDUPLEX) )
	{
		if (pdvsdc->dwFlags & DVSOUNDCONFIG_HALFDUPLEX)
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "We received a half duplex when we expected full duplex" );
			// It only started up in half duplex. Notify the caller.
			hr = DV_HALFDUPLEX;
			goto error_cleanup;
		}
	} 

	if( pdvsdc->dwFlags & DVSOUNDCONFIG_HALFDUPLEX )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "StartLoopBack() returning DV_HALFDUPLEX flags=0x%x dwFlags = 0x%x", pdvsdc->dwFlags, dwFlags );
		// it started in fullduplex, notify the caller
		delete [] pDeviceConfigBuffer;
		DPF_EXIT();
		return DV_HALFDUPLEX;
	}
	else
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "StartLoopBack() returning DV_FULLDUPLEX flags=0x%x dwFlags = 0x%x", pdvsdc->dwFlags, dwFlags );		
		// it started in fullduplex, notify the caller
		delete [] pDeviceConfigBuffer;
		DPF_EXIT();
		return DV_FULLDUPLEX;
	}

error_cleanup:

	if (pDeviceConfigBuffer != NULL)
	{
		delete [] pDeviceConfigBuffer;
		pDeviceConfigBuffer = NULL;
	}

	if (*lplpdvc != NULL)
	{
		if (fClientConnected)
		{
			(*lplpdvc)->Disconnect(DVFLAGS_SYNC);
			fClientConnected = FALSE;
		}
		(*lplpdvc)->Release();
		*lplpdvc = NULL;
	}

	if (*lplpdvs != NULL)
	{
		if (fVoiceSessionStarted)
		{
			(*lplpdvs)->StopSession(0);
			fVoiceSessionStarted = FALSE;
		}
		(*lplpdvs)->Release();
		*lplpdvs = NULL;
	}

	DPFX(DPFPREP,  DVF_ERRORLEVEL, "StartLoopback() returning hr=0x%x", hr );
	
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "StopLoopback"
HRESULT StopLoopback(
	LPDIRECTPLAYVOICESERVER lpdvs, 
	LPDIRECTPLAYVOICECLIENT lpdvc,
	PDIRECTPLAY8SERVER lpdp8 )
{
	HRESULT hr;
	LONG lRet;
	BOOL fRet;
	BOOL fClientConnected = TRUE;
	BOOL fVoiceSessionRunning = TRUE;
	
	DPF_ENTER();

	if (lpdvc != NULL)
	{
		hr = lpdvc->Disconnect(DVFLAGS_SYNC);
		fClientConnected = FALSE;
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceClient::Disconnect failed, hr: %i", hr);
			goto error_cleanup;
		}
		
		lpdvc->Release();
		lpdvc = NULL;
	}

	if (lpdvs != NULL)
	{
		hr = lpdvs->StopSession(0);
		fVoiceSessionRunning = FALSE;
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "IDirectPlayVoiceServer::StopSession failed, hr: %i", hr);
			goto error_cleanup;
		}
		lpdvs->Release();
		lpdvs = NULL;
	}

	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (lpdvc != NULL)
	{
		if (fClientConnected)
		{
			lpdvc->Disconnect(DVFLAGS_SYNC);
			fClientConnected = FALSE;
		}
		lpdvc->Release();
		lpdvc = NULL;
	}

	if (lpdvs != NULL)
	{
		if (fVoiceSessionRunning)
		{
			lpdvs->StopSession(0);
			fVoiceSessionRunning = FALSE;
		}
		lpdvs->Release();
		lpdvs = NULL;
	}

	DPF_EXIT();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\peakmetr.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		peakmetr.cpp
 *  Content:	Implements a peak meter custom control
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 09/22/99		pnewson	Created
 * 03/23/00     rodtoll   Added casts for Win64
 *  04/19/2000	pnewson	    Error handling cleanup  
 ***************************************************************************/

#include "dxvtlibpch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


struct SPeakMeterWndInfo
{
	DWORD dwCurLevel;
	DWORD dwMinLevel;
	DWORD dwMaxLevel;
	DWORD dwSteps;
	HGDIOBJ hBlackStockPen;
	HGDIOBJ hWhiteStockPen;
	HGDIOBJ hRedPen;
	HGDIOBJ hYellowPen;
	HGDIOBJ hGreenPen;
	HBRUSH hRedBrush;
	HBRUSH hYellowBrush;
	HBRUSH hGreenBrush;
};

LRESULT CALLBACK PeakMeterWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WM_CREATE_Handler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WM_DESTROY_Handler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT WM_PAINT_Handler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

// the window class name of the peak meter custom control
const TCHAR gc_szPeakMeterWindowClassName[] = _T("DirectPlayVoicePeakMeter");

// default values for caller settable data
#define DEFAULT_CURLEVEL 	0
#define DEFAULT_MINLEVEL 	0
#define DEFAULT_MAXLEVEL 	0xffffffff
#define DEFAULT_STEPS 		20

// sizes of various things in the window
#define WINDOW_BORDER_SIZE 		1
#define MIN_BAR_HEIGHT 			2
#define MIN_BAR_WIDTH			2
#define BAR_GUTTER_SIZE 		1
#define MIN_NUMBER_BARS			5

// the threshold above which the bar turns yellow, then red
#define RED_THRESHOLD 		0.9
#define YELLOW_THRESHOLD	0.8

#undef DPF_MODNAME
#define DPF_MODNAME "CPeakMeterWndClass::Register"
HRESULT CPeakMeterWndClass::Register()
{
	WNDCLASS wndclass;
	ATOM atom;
	HRESULT hr;
	LONG lRet;
	
	DPF_ENTER();
	
	m_hinst = GetModuleHandleA(gc_szDVoiceDLLName);
	if (m_hinst == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetModuleHandle failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	wndclass.style = CS_HREDRAW|CS_VREDRAW;
	wndclass.lpfnWndProc = PeakMeterWndProc;
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = sizeof(LONG_PTR);
	wndclass.hInstance = m_hinst;
	wndclass.hIcon = NULL;
	wndclass.hCursor = LoadCursor (NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH) GetSysColorBrush(COLOR_BTNFACE);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = gc_szPeakMeterWindowClassName;

	atom = RegisterClass(&wndclass);
	if (atom == 0)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "RegisterClass failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}	

	DPF_EXIT();
	return S_OK;

error_cleanup:
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CPeakMeterWndClass::Unregister"
HRESULT CPeakMeterWndClass::Unregister()
{
	HRESULT hr;
	LONG lRet;
	
	DPF_ENTER();

	if (!UnregisterClass(gc_szPeakMeterWindowClassName, m_hinst))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ENTRYLEVEL, "RegisterClass failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	DPF_EXIT();
	return S_OK;

error_cleanup:
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "PeakMeterWndProc"
LRESULT CALLBACK PeakMeterWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lres;
	LONG lRet;
	SPeakMeterWndInfo* lppmwi;

	DPF_ENTER();

	switch (message)
	{
	case WM_CREATE:
		lres = WM_CREATE_Handler(hwnd, message, wParam, lParam);
		DPF_EXIT();
		return lres;

	case WM_DESTROY:
		lres = WM_DESTROY_Handler(hwnd, message, wParam, lParam);
		DPF_EXIT();
		return lres;
		
	case PM_SETCUR:
	case PM_SETMAX:
	case PM_SETMIN:
	case PM_SETSTEPS:
		SetLastError(ERROR_SUCCESS);
		lppmwi = (SPeakMeterWndInfo*)GetWindowLongPtr(hwnd, 0);
		lRet = GetLastError();
		if (lRet != ERROR_SUCCESS)
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "GetWindowLongPtr failed, code: %i", lRet);
			DPF_EXIT();
			return DVERR_WIN32;
		}

		switch (message)
		{
		case PM_SETCUR:
			lppmwi->dwCurLevel = (DWORD) lParam;
			break;
		case PM_SETMAX:
			lppmwi->dwMaxLevel = (DWORD) lParam;
			break;
		case PM_SETMIN:
			lppmwi->dwMinLevel = (DWORD) lParam;
			break;
		case PM_SETSTEPS:
			if (lParam < MIN_NUMBER_BARS)
			{
				lppmwi->dwSteps = MIN_NUMBER_BARS;
			}
			else
			{
				lppmwi->dwSteps = (DWORD) lParam;
			}
			break;
		default:
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Unreachable code!?!");
			DPF_EXIT();
			return DVERR_GENERIC;
		}

		// no error handling available
		InvalidateRgn(hwnd, NULL, TRUE);
		
		return S_OK;

	case WM_PAINT:
		lres = WM_PAINT_Handler(hwnd, message, wParam, lParam);
		DPF_EXIT();
		return lres;
	}
	
	lres = DefWindowProc(hwnd, message, wParam, lParam);
	DPF_EXIT();
	return lres;
}

LRESULT WM_CREATE_Handler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	SPeakMeterWndInfo* lppmwi = NULL;
	LONG lRet;
	HRESULT hr;
	
	// allocate a window info struct
	lppmwi = (SPeakMeterWndInfo*)DNMalloc(sizeof(SPeakMeterWndInfo));
	if (lppmwi == NULL)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "DNMalloc failed");
		hr = DVERR_OUTOFMEMORY;
		goto error_cleanup;
	}
	ZeroMemory(lppmwi, sizeof(SPeakMeterWndInfo));

	lppmwi->dwCurLevel = DEFAULT_CURLEVEL;
	lppmwi->dwMinLevel = DEFAULT_MINLEVEL;
	lppmwi->dwMaxLevel = DEFAULT_MAXLEVEL;
	lppmwi->dwSteps = DEFAULT_STEPS;

	// create the pens and brushes we'll be needing
	lppmwi->hBlackStockPen = GetStockObject(BLACK_PEN);
	if (lppmwi->hBlackStockPen == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetStockObject failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	lppmwi->hWhiteStockPen = GetStockObject(WHITE_PEN);
	if (lppmwi->hWhiteStockPen == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetStockObject failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	lppmwi->hRedBrush = CreateSolidBrush(RGB(0xff, 0x00, 0x00));
	if (lppmwi->hRedBrush == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CreateSolidBrush failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	lppmwi->hYellowBrush = CreateSolidBrush(RGB(0xff, 0xff, 0x00));
	if (lppmwi->hYellowBrush == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CreateSolidBrush failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	lppmwi->hGreenBrush = CreateSolidBrush(RGB(0x00, 0xff, 0x00));
	if (lppmwi->hGreenBrush == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CreateSolidBrush failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	lppmwi->hRedPen = CreatePen(PS_SOLID, 1, RGB(0xff, 0x00, 0x00));
	if (lppmwi->hRedPen == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CreatePen failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	lppmwi->hYellowPen = CreatePen(PS_SOLID, 1, RGB(0xff, 0xff, 0x00));
	if (lppmwi->hYellowPen == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CreatePen failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	lppmwi->hGreenPen = CreatePen(PS_SOLID, 1, RGB(0x00, 0xff, 0x00));
	if (lppmwi->hGreenPen == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "CreatePen failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	// save the window information
	SetLastError(ERROR_SUCCESS);
	SetWindowLongPtr(hwnd, 0, (LONG_PTR)lppmwi);
	lRet = GetLastError();
	if (lRet != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "SetWindowLongPtr failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	DPF_EXIT();
	return 0; // will continue window creation

error_cleanup:
	if (lppmwi != NULL)
	{
		if (lppmwi->hGreenPen != NULL)
		{
			DeleteObject(lppmwi->hGreenPen);
			lppmwi->hGreenPen = NULL;
		}
		if (lppmwi->hYellowPen != NULL)
		{
			DeleteObject(lppmwi->hYellowPen);
			lppmwi->hYellowPen = NULL;
		}
		if (lppmwi->hRedPen != NULL)
		{
			DeleteObject(lppmwi->hRedPen);
			lppmwi->hRedPen = NULL;
		}
		if (lppmwi->hGreenBrush != NULL)
		{
			DeleteObject(lppmwi->hGreenBrush);
			lppmwi->hGreenBrush = NULL;
		}
		if (lppmwi->hYellowBrush != NULL)
		{
			DeleteObject(lppmwi->hYellowBrush);
			lppmwi->hYellowBrush = NULL;
		}
		if (lppmwi->hRedBrush != NULL)
		{
			DeleteObject(lppmwi->hRedBrush);
			lppmwi->hRedBrush = NULL;
		}
		DNFree(lppmwi);
	}

	DPF_EXIT();
	return -1;	// will abort window creation
}

LRESULT WM_DESTROY_Handler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();

	SPeakMeterWndInfo* lppmwi;
	LONG lRet;
	
	// get the window info
	SetLastError(ERROR_SUCCESS);
	lppmwi = (SPeakMeterWndInfo*)GetWindowLongPtr(hwnd, 0);
	lRet = GetLastError();
	if (lRet != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetWindowLongPtr failed, code: %i", lRet);

		// Couldn't get the pointer, so can't clean anything else up!
		DPF_EXIT();
		return 0; // not sure what returning non-zero will do...
	}

	// set the window info to null, just in case...
	SetLastError(ERROR_SUCCESS);
	SetWindowLongPtr(hwnd, 0, (LONG_PTR)NULL);
	lRet = GetLastError();
	if (lRet != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "SetWindowLongPtr failed, code: %i", lRet);
	}

	if (lppmwi != NULL)
	{
		if (lppmwi->hGreenPen != NULL)
		{
			DeleteObject(lppmwi->hGreenPen);
			lppmwi->hGreenPen = NULL;
		}
		if (lppmwi->hYellowPen != NULL)
		{
			DeleteObject(lppmwi->hYellowPen);
			lppmwi->hYellowPen = NULL;
		}
		if (lppmwi->hRedPen != NULL)
		{
			DeleteObject(lppmwi->hRedPen);
			lppmwi->hRedPen = NULL;
		}
		if (lppmwi->hGreenBrush != NULL)
		{
			DeleteObject(lppmwi->hGreenBrush);
			lppmwi->hGreenBrush = NULL;
		}
		if (lppmwi->hYellowBrush != NULL)
		{
			DeleteObject(lppmwi->hYellowBrush);
			lppmwi->hYellowBrush = NULL;
		}
		if (lppmwi->hRedBrush != NULL)
		{
			DeleteObject(lppmwi->hRedBrush);
			lppmwi->hRedBrush = NULL;
		}
		DNFree(lppmwi);
	}
	
	DPF_EXIT();
	return 0;
}

LRESULT WM_PAINT_Handler(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LONG lRet;
	HDC hdc = NULL;
	PAINTSTRUCT ps;
	RECT rect;
	SPeakMeterWndInfo* lppmwi;
	DWORD dwStepsLocal;

	// get the window info
	SetLastError(ERROR_SUCCESS);
	lppmwi = (SPeakMeterWndInfo*)GetWindowLongPtr(hwnd, 0);
	lRet = GetLastError();
	if (lRet != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "SetWindowLongPtr failed, code: %i", lRet);
		goto error_cleanup;
	}
	
	// get the client rectangle
	if (!GetClientRect(hwnd, &rect))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "GetClientRect failed, code: %i", lRet);
		goto error_cleanup;
	}

	// start painting
	hdc = BeginPaint(hwnd, &ps);
	if (hdc == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "BeginPaint failed, code: %i", lRet);
		goto error_cleanup;
	}

	// make sure the client rectangle is a minimum reasonable size.
	if (rect.right - rect.left < 
			2 * WINDOW_BORDER_SIZE +
			2 * BAR_GUTTER_SIZE +
			MIN_BAR_WIDTH
		|| rect.bottom - rect.top < 
			2 * WINDOW_BORDER_SIZE +
			(MIN_BAR_HEIGHT + BAR_GUTTER_SIZE) * MIN_NUMBER_BARS )
	{
		// unreasonable size - fill the whole rect with red so 
		// the developer will notice
		if (SelectObject(hdc, lppmwi->hRedPen) == NULL)
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "SelectObject failed, code: %i", lRet);
			goto error_cleanup;
		}

		if (SelectObject(hdc, lppmwi->hRedBrush) == NULL)
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "SelectObject failed, code: %i", lRet);
			goto error_cleanup;
		}

		if (!Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "Rectangle failed, code: %i", lRet);
			goto error_cleanup;
		}
	}
	else
	{
		// select the black pen - should be the default, but I'm paranoid
		if (SelectObject(hdc, lppmwi->hBlackStockPen) == NULL)
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "SelectObject failed, code: %i", lRet);
			goto error_cleanup;
		}

		// move to the upper left corner, again should be default.
		if (!MoveToEx(hdc, 0, 0, NULL))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "MoveToEx failed, code: %i", lRet);
			goto error_cleanup;
		}

		// draw a black line across the top
		if (!LineTo(hdc, rect.right, 0))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LineTo failed, code: %i", lRet);
			goto error_cleanup;
		}

		// move to one pixel below the upper left
		if (!MoveToEx(hdc, 0, 1, NULL))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "MoveToEx failed, code: %i", lRet);
			goto error_cleanup;
		}
		
		// draw a black line down the left side, leave the last pixel alone.
		if (!LineTo(hdc, 0, rect.bottom-1))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LineTo failed, code: %i", lRet);
			goto error_cleanup;
		}

		// select the white pen
		if (SelectObject(hdc, lppmwi->hWhiteStockPen) == NULL)
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "SelectObject failed, code: %i", lRet);
			goto error_cleanup;
		}

		// move to the upper right corner
		if (!MoveToEx(hdc, rect.right-1 , 0, NULL))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "MoveToEx failed, code: %i", lRet);
			goto error_cleanup;
		}

		// draw a white line down the right side
		if (!LineTo(hdc, rect.right-1, rect.bottom))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LineTo failed, code: %i", lRet);
			goto error_cleanup;
		}

		// move to the lower left corner, 
		if (!MoveToEx(hdc, 0 , rect.bottom-1, NULL))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "MoveToEx failed, code: %i", lRet);
			goto error_cleanup;
		}

		// draw a white line across the bottom
		if (!LineTo(hdc, rect.right-1, rect.bottom-1))
		{
			lRet = GetLastError();
			DPFX(DPFPREP, DVF_ERRORLEVEL, "LineTo failed, code: %i", lRet);
			goto error_cleanup;
		}

		// see if there is enough room to display the suggested
		// number of bars.
		DWORD dwFreeSpace = (rect.bottom) - (2 * WINDOW_BORDER_SIZE) - BAR_GUTTER_SIZE;
		if (dwFreeSpace < lppmwi->dwSteps * (BAR_GUTTER_SIZE + MIN_BAR_HEIGHT))
		{
			// There is not enough room to display the suggested size.
			// Figure out how many bars we can display if they are the
			// minimum size.
			dwStepsLocal = dwFreeSpace / (BAR_GUTTER_SIZE + MIN_BAR_HEIGHT);
		}
		else
		{
			dwStepsLocal = lppmwi->dwSteps;
		}

		// start drawing the bars from the bottom up
		HBRUSH hCurBrush;
		HGDIOBJ hCurPen;
		DWORD dwIndex;
		for (dwIndex = 0; dwIndex < dwStepsLocal; ++dwIndex)
		{
			// what "value" does the bar we are about to draw have?
			// i.e. how far up the scale is it?
			float fBarValue = (float)(dwIndex + 1) / (float)dwStepsLocal;

			// what is the "value" of the control at this moment?
			// i.e. how far up the scale should the bars go?
			float fCurValue = 
				(float)(lppmwi->dwCurLevel - lppmwi->dwMinLevel) / 
				(float)(lppmwi->dwMaxLevel - lppmwi->dwMinLevel);

			// are we done drawning bars?
			if (fBarValue > fCurValue)
			{
				// that's it, we're finished
				break;
			}
			
			// figure out what color this bar should be
			if (fBarValue > RED_THRESHOLD)
			{
				hCurBrush = lppmwi->hRedBrush;
				hCurPen = lppmwi->hRedPen;
			}
			else if (fBarValue > YELLOW_THRESHOLD)
			{
				hCurBrush = lppmwi->hYellowBrush;
				hCurPen = lppmwi->hYellowPen;
			}
			else
			{
				hCurBrush = lppmwi->hGreenBrush;
				hCurPen = lppmwi->hGreenPen;
			}

			if (SelectObject(hdc, hCurPen) == NULL)
			{
				lRet = GetLastError();
				DPFX(DPFPREP, DVF_ERRORLEVEL, "SelectObject failed, code: %i", lRet);
				goto error_cleanup;
			}

			if (SelectObject(hdc, hCurBrush) == NULL)
			{
				lRet = GetLastError();
				DPFX(DPFPREP, DVF_ERRORLEVEL, "SelectObject failed, code: %i", lRet);
				goto error_cleanup;
			}

			POINT pUpperLeft;
			POINT pLowerRight;

			pUpperLeft.x = WINDOW_BORDER_SIZE + BAR_GUTTER_SIZE;
			pUpperLeft.y = (rect.bottom)
				- WINDOW_BORDER_SIZE 
				- ((dwIndex + 1) * dwFreeSpace) / dwStepsLocal;

			pLowerRight.x = rect.right
				- WINDOW_BORDER_SIZE 
				- BAR_GUTTER_SIZE;
			pLowerRight.y = (rect.bottom)
				- WINDOW_BORDER_SIZE 
				- BAR_GUTTER_SIZE				
				- (dwIndex * dwFreeSpace) / dwStepsLocal;
			
			if (!Rectangle(hdc, pUpperLeft.x, pUpperLeft.y, pLowerRight.x, pLowerRight.y))
			{
				lRet = GetLastError();
				DPFX(DPFPREP, DVF_ERRORLEVEL, "Rectangle failed, code: %i", lRet);
				goto error_cleanup;
			}
		}
	}

	// we're done - no error checking available on this call...
	EndPaint(hwnd, &ps);
	hdc = NULL;

	// return zero to indicate that we processed this message
	DPF_EXIT();
	return 0;

error_cleanup:
	if (hdc != NULL)
	{
		EndPaint(hwnd, &ps);
		hdc = NULL;
	}

	// return non-zero to indicate that we did not process
	// this message successfully
	DPF_EXIT();
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dxvt


#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=LIBRARY

!if "$(DPLAY_PCH)" != "off"
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dxvtlibpch.h
PRECOMPILED_PCH=dxvtlibpch.pch
PRECOMPILED_OBJ=dxvtlibpch.obj
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=..\..\..\dnet\common;..\..\inc;..\..\dxvoice;..\..\dxvutils;..\..\dplobby\dplobby;$(DXROOT)\private\inc;$(BASEDIR)\public\internal\shell\inc;..\

#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= \
	..\fdtglob.cpp \
	..\fulldup.cpp \
	..\fdtcfg.cpp \
	..\priority.cpp \
	..\fdtipc.cpp \
	..\supervis.cpp \
	..\loopback.cpp \
	..\peakmetr.cpp 

	

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_LIB /DWIN32 /D_MT /D_DLL /DSECURITY_WIN32 \
!if "$(CHICAGO_PRODUCT)" == ""
	/DUNICODE /D_UNICODE \
!endif
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(VOICE_TARGET)" == "allegiance" 
	/DVOICE_BUILD_ALLEGIANCE \
!endif
/DDIRECTSOUND_VERSION=0x0800
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\supervis.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       supervis.h
 *  Content:    Prototypes the SupervisorProcess function
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 *  10/27/99	pnewson		change guid members from pointers to structs 
 *  11/04/99	pnewson 	Bug #115279 - fixed cancel processing
 *										- added HWND to check audio setup
 *  11/30/99	pnewson 	default device mapping
 *  01/21/2000	pnewson		Update for UI revisions
 *  01/23/2000	pnewson		Improvded feedback for fatal errors (millen bug 114508)
 *  01/24/2000	pnewson		fixed bug in GetRenderDesc
 *  04/04/2000	pnewson		Added support for DVFLAGS_ALLOWBACK
 *  04/19/2000  rodtoll     Bug #31106 - Grey out recording sliders when no vol control avail 
 *  04/19/2000	pnewson	    Error handling cleanup  
 *  05/03/2000	pnewson	    bug #33878 - Wizard locks up when clicking Next/Cancel during speaker test 
 *  11/29/2000	rodtoll		Bug #48348 - DPVOICE: Modify wizard to make use of DirectPlay8 as the transport. 
 *
 ***************************************************************************/

#ifndef _SUPERVIS_H_
#define _SUPERVIS_H_

#include "fdtipc.h"

extern HRESULT SupervisorCheckAudioSetup(
	const GUID* lpguidRender, 
	const GUID* lpguidCapture, 
	HWND hwndParent,
	DWORD dwFlags);

// App defined window messages
#define WM_APP_FULLDUP_TEST_COMPLETE 	(WM_APP)
#define WM_APP_STEP_PROGRESS_BAR 		(WM_APP + 1)
#define WM_APP_LOOPBACK_RUNNING 		(WM_APP + 2)
#define WM_APP_RECORDSTART		 		(WM_APP + 3)
#define WM_APP_RECORDSTOP		 		(WM_APP + 4)

// The UI element this is used for can only display about 40 chars anyway,
// so there's no point going through the hassle of allocating this off
// the heap and cleaning it up.
#define MAX_DEVICE_DESC_LEN 50	
// class used to manage the supervisor state and shared info
class CSupervisorInfo
{
private: 
	CRegistry m_creg;
	HFONT m_hfTitle;
	HFONT m_hfBold;
	CSupervisorIPC m_sipc;
	GUID m_guidCaptureDevice;
	GUID m_guidRenderDevice;
	TCHAR m_szCaptureDeviceDesc[MAX_DEVICE_DESC_LEN];
	TCHAR m_szRenderDeviceDesc[MAX_DEVICE_DESC_LEN];
	HANDLE m_hFullDuplexThread;
	BOOL m_fAbortFullDuplex;
	HANDLE m_hLoopbackThread;
	HANDLE m_hLoopbackThreadExitEvent;
	HANDLE m_hLoopbackShutdownEvent;
	BOOL m_fVoiceDetected;
	BOOL m_fUserBack;
	BOOL m_fUserCancel;
	BOOL m_fWelcomeNext;
	HWND m_hwndParent;
	HWND m_hwndWizard;
	HWND m_hwndDialog;
	HWND m_hwndProgress;
	HWND m_hwndInputPeak;
	HWND m_hwndOutputPeak;
	HWND m_hwndInputVolumeSlider;
	LONG m_lInputVolumeSliderPos;
	HWND m_hwndOutputVolumeSlider;
	LPDIRECTPLAYVOICECLIENT m_lpdpvc;
	HANDLE m_hMutex;
	PROCESS_INFORMATION m_piSndVol32Record;
	PROCESS_INFORMATION m_piSndVol32Playback;
	UINT m_uiWaveInDeviceId;
	UINT m_uiWaveOutDeviceId;
	WAVEOUTCAPS m_woCaps;
	DWORD m_dwLoopbackFlags;
	DWORD m_dwCheckAudioSetupFlags;
	HRESULT m_hrFullDuplexResults;
	HRESULT m_hrError;
	DWORD m_dwDeviceFlags;
	BOOL m_fLoopbackRunning;
	BOOL m_fCritSecInited;
	DNCRITICAL_SECTION m_csLock;

	static BOOL CALLBACK DSEnumCallback(LPGUID lpguid, LPCTSTR lpcstrDescription, LPCTSTR lpcstrModule, LPVOID lpContext);
	static BOOL CALLBACK DSCEnumCallback(LPGUID lpguid, LPCTSTR lpcstrDescription, LPCTSTR lpcstrModule, LPVOID lpContext);

public:
	CSupervisorInfo();
	~CSupervisorInfo();

	HRESULT ThereCanBeOnlyOne();
	HRESULT CrashCheckIn();
	HRESULT OpenRegKey(BOOL fCreate);
	HRESULT CloseRegKey();
	HRESULT QueryFullDuplex();
	HRESULT InitIPC();
	HRESULT DeinitIPC();
	HRESULT TestCase(const WAVEFORMATEX* lpwfxPrimary, DWORD dwFlags);
	HRESULT CreateFullDuplexThread();
	HRESULT WaitForFullDuplexThreadExitCode();
	HRESULT CreateLoopbackThread();
	HRESULT WaitForLoopbackShutdownEvent();
	HRESULT ShutdownLoopbackThread();
	HRESULT SignalLoopbackThreadDone();
	HRESULT CreateTitleFont();
	HRESULT DestroyTitleFont();
	HRESULT CreateBoldFont();
	HRESULT DestroyBoldFont();
	HRESULT Unmute();
	HRESULT Mute();
	HRESULT GetDeviceDescriptions();
	LPCTSTR GetCaptureDesc() { return m_szCaptureDeviceDesc; };
	LPCTSTR GetRenderDesc() { return m_szRenderDeviceDesc; };
	BOOL GetLoopbackRunning() { return m_fLoopbackRunning; };
	void SetLoopbackRunning( BOOL fRunning ) { m_fLoopbackRunning = fRunning; };
	BOOL InitClass();

	HRESULT Finish();
	HRESULT Cancel();
	HRESULT CancelFullDuplexTest();
	void GetDeviceFlags(DWORD *dwFlags);
	void SetDeviceFlags(DWORD dwFlags);
	HRESULT CancelLoopbackTest();
	HRESULT Abort(HWND hDlg, HRESULT hr);
	void GetReg(CRegistry* pcreg);
	void GetTitleFont(HFONT* lphfTitle);
	void GetBoldFont(HFONT* lphfTitle);
	void SetCaptureDevice(GUID guidCaptureDevice);
	void GetCaptureDevice(GUID* lpguidCaptureDevice);
	void SetRenderDevice(GUID guidRenderDevice);
	void GetRenderDevice(GUID* lpguidRenderDevice);
	void GetHWNDParent(HWND* lphwnd);
	void SetHWNDParent(HWND hwnd);
	void GetHWNDWizard(HWND* lphwnd);
	void SetHWNDWizard(HWND hwnd);
	void GetHWNDDialog(HWND* lphwnd);
	void SetHWNDDialog(HWND hwnd);
	void GetHWNDProgress(HWND* lphwnd);
	void SetHWNDProgress(HWND hwnd);
	void GetHWNDInputPeak(HWND* lphwnd);
	void SetHWNDInputPeak(HWND hwnd);
	void GetHWNDOutputPeak(HWND* lphwnd);
	void SetHWNDOutputPeak(HWND hwnd);
	void GetHWNDInputVolumeSlider(HWND* lphwnd);
	void SetHWNDInputVolumeSlider(HWND hwnd);
	void GetInputVolumeSliderPos(LONG* lpl);
	void SetInputVolumeSliderPos(LONG lpl);
	void GetHWNDOutputVolumeSlider(HWND* lphwnd);
	void SetHWNDOutputVolumeSlider(HWND hwnd);
	void GetDPVC(LPDIRECTPLAYVOICECLIENT* lplpdpvc);
	void SetDPVC(LPDIRECTPLAYVOICECLIENT lpdpvc);
	void GetLoopbackShutdownEvent(HANDLE* lphEvent);
	void SetLoopbackShutdownEvent(HANDLE hEvent);
	void GetIPC(CSupervisorIPC** lplpsipc);
	void GetAbortFullDuplex(BOOL* lpfAbort);
	void ClearAbortFullDuplex();
	void SetWaveOutHandle(HWAVEOUT hwo);
	HRESULT SetWaveOutId(UINT ui);
	void SetWaveInId(UINT ui);
	void GetLoopbackFlags(DWORD* pdwFlags);
	void SetLoopbackFlags(DWORD dwFlags);
	void GetCheckAudioSetupFlags(DWORD* pdwFlags);
	void SetCheckAudioSetupFlags(DWORD dwFlags);
	void GetFullDuplexResults(HRESULT* hr);
	void SetFullDuplexResults(HRESULT hr);
	void GetError(HRESULT* hr);
	void SetError(HRESULT hr);
	
	HRESULT GetFullDuplex(DWORD* pdwFullDuplex);
	HRESULT SetFullDuplex(DWORD dwFullDuplex);
	HRESULT GetHalfDuplex(DWORD* pdwHalfDuplex);
	HRESULT SetHalfDuplex(DWORD dwHalfDuplex);
	HRESULT GetMicDetected(DWORD* pdwMicDetected);
	HRESULT SetMicDetected(DWORD dwMicDetected);
	
	HRESULT SetRecordVolume(LONG lVolume);
	HRESULT LaunchWindowsVolumeControl(HWND hwndWizard, BOOL fRecord);
	HRESULT CloseWindowsVolumeControl(BOOL fRecord);
	HRESULT GetWaveOutVolume(DWORD* lpdwVolume);
	HRESULT SetWaveOutVolume(DWORD dwVolume);

	void CloseMutex();

	void SetVoiceDetected();
	void ClearVoiceDetected();
	void GetVoiceDetected(BOOL* lpfPreviousCrash);

	void SetUserBack();
	void ClearUserBack();
	void GetUserBack(BOOL* lpfUserBack);

	void SetUserCancel();
	void ClearUserCancel();
	void GetUserCancel(BOOL* lpfUserCancel);

	void SetWelcomeNext();
	void ClearWelcomeNext();
	void GetWelcomeNext(BOOL* lpfWelcomeNext);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvtlib\supervis.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       supervis.cpp
 *  Content:    Implements a process that oversees the full duplex
 *				testing proceedure, watching for nasty conditions in
 *				the two child processes that are used to implement the
 *				actual tests. This is required because on some older 
 *				VXD drivers, attempting full duplex can hang the process
 *				or even (grumble) lock the whole system.
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 *  10/27/99	pnewson		change guid members from pointers to structs
 *  10/28/99	pnewson 	Bug #114176 updated DVSOUNDDEVICECONFIG struct
 *  11/04/99	pnewson 	Bug #115279 - fixed cancel processing
 *										- fixed crash detection
 *										- fixed multiple instance detection
 *										- added HWND to check audio setup
 *										- automatically advance after full duplex test
 *  11/30/99	pnewson 	parameter validation and default device mapping
 *  12/16/99	rodtoll		Bug #119584 - Error code cleanup (Renamed runsetup error) 
 *  01/21/2000	pnewson		Update for UI revisions
 *  01/23/2000	pnewson		Improvded feedback for fatal errors (millen bug 114508)
 *  01/24/2000  pnewson 	Prefix detected bug fix
 *  01/25/2000  pnewson 	Added support for DVFLAGS_WAVEIDS
 *  01/27/2000	rodtoll	Updated with API changes 
 * 	02/08/2000	rodtoll	Bug #131496 - Selecting DVTHRESHOLD_DEFAULT results in voice
 *						never being detected 
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  03/23/2000  rodtoll   Win64 updates
 *  04/04/2000	pnewson		Added support for DVFLAGS_ALLOWBACK
 *							Removed "Already Running" dialog box
 *  04/19/2000  rodtoll Bug #31106 - Grey out recording sliders when no vol control avail
 *  04/19/2000	pnewson	    Error handling cleanup  
 *							Clicking Volume button brings volume window to foreground
 *  04/21/2000  rodtoll Bug #32889 - Does not run on Win2k on non-admin account
 *                      Bug #32952 Does not run on Windows 95 w/o IE4 installed
 *  05/03/2000  pnewson Bug #33878 - Wizard locks up when clicking Next/Cancel during speaker test
 *  05/17/2000  rodtoll Bug #34045 - Parameter validation error while running TestNet.
 *				rodtoll Bug #34764 - Verifies capture device before render device 
 *  06/28/2000	rodtoll	Prefix Bug #38022
 *  07/12/2000	rodtoll		Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 *  07/31/2000	rodtoll	Bug #39590 - SB16 class soundcards are passing when they should fail
 *						Half duplex code was being ignored in mic test portion.
 *  08/06/2000  RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/28/2000	masonb  Voice Merge: Changed ccomutil.h to ccomutil.h
 *  08/31/2000 	rodtoll	Bug #43804 - DVOICE: dwSensitivity structure member is confusing - should be dwThreshold 
 *  11/29/2000	rodtoll	Bug #48348 - DPVOICE: Modify wizard to make use of DirectPlay8 as the transport.
 *  02/04/2001	simonpow	Bug #354859 - Fixes for PREfast spotted problems (Unitialised variables)
 ***************************************************************************/

#include "dxvtlibpch.h"


#ifndef WIN95
#define PROPSHEETPAGE_STRUCT_SIZE 	sizeof( PROPSHEETPAGE )
#define PROPSHEETHEAD_STRUCT_SIZE	sizeof( PROPSHEETHEADER )
#else
#define PROPSHEETPAGE_STRUCT_SIZE 	PROPSHEETPAGE_V1_SIZE
#define PROPSHEETHEAD_STRUCT_SIZE	PROPSHEETHEADER_V1_SIZE
#endif


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// logical defines for registry values
#define REGVAL_NOTRUN 	0
#define REGVAL_CRASHED 	1
#define REGVAL_FAILED 	2
#define REGVAL_PASSED 	3

// local typedefs
typedef HRESULT (WINAPI *TDirectSoundEnumFnc)(LPDSENUMCALLBACK, LPVOID);

// local static functions
static HRESULT SupervisorQueryAudioSetup(CSupervisorInfo* psinfo);
static HRESULT RunFullDuplexTest(CSupervisorInfo* lpsinfo);
static HRESULT DoTests(CSupervisorInfo* lpsinfo);
static HRESULT IssueCommands(CSupervisorInfo* lpsinfo);
static HRESULT IssueShutdownCommand(CSupervisorIPC* lpipcSupervisor);

// callback functions
INT_PTR CALLBACK WelcomeProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AlreadyRunningProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PreviousCrashProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FullDuplexProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MicTestProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK MicTestFailedProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SpeakerTestProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK CompleteProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FullDuplexFailedProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK HalfDuplexFailedProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

// Thread functions
DWORD WINAPI FullDuplexTestThreadProc(LPVOID lpvParam);
DWORD WINAPI LoopbackTestThreadProc(LPVOID lpvParam);

// Message handlers
BOOL WelcomeInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL WelcomeSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL WelcomeBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL WelcomeNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL WelcomeResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexCompleteHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestLoopbackRunningHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestRecordStartHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestRecordStopHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestVScrollHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestRecAdvancedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestFailedInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestFailedSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestFailedRecordStopHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestFailedBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestFailedResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL MicTestFailedFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestVScrollHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestRecAdvancedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL SpeakerTestOutAdvancedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL CompleteInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL CompleteSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL CompleteLoopbackEndedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL CompleteFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL CompleteResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexFailedInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexFailedSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexFailedFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexFailedResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL FullDuplexFailedBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL HalfDuplexFailedInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL HalfDuplexFailedSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL HalfDuplexFailedFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL HalfDuplexFailedResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);
BOOL HalfDuplexFailedBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo);

// globals
HINSTANCE g_hResDLLInstance;

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CSupervisorInfo"
CSupervisorInfo::CSupervisorInfo()
	: m_hfTitle(NULL)
	, m_guidCaptureDevice(GUID_NULL)
	, m_guidRenderDevice(GUID_NULL)
	, m_hFullDuplexThread(NULL)
	, m_hLoopbackThreadExitEvent(NULL)
	, m_fAbortFullDuplex(FALSE)
	, m_hLoopbackThread(NULL)
	, m_hLoopbackShutdownEvent(NULL)
	, m_fVoiceDetected(FALSE)
	, m_hwndWizard(NULL)
	, m_hwndDialog(NULL)
	, m_hwndProgress(NULL)
	, m_hwndInputPeak(NULL)
	, m_hwndOutputPeak(NULL)
	, m_hwndInputVolumeSlider(NULL)
	, m_hwndOutputVolumeSlider(NULL)
	, m_lpdpvc(NULL)
	, m_hMutex(NULL)
	, m_uiWaveInDeviceId(0)
	, m_uiWaveOutDeviceId(0)
	, m_dwDeviceFlags(0)
	, m_fLoopbackRunning(FALSE)
	, m_fCritSecInited(FALSE)
{
	DPF_ENTER();

	ZeroMemory(&m_piSndVol32Record, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&m_piSndVol32Playback, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&m_woCaps, sizeof(WAVEOUTCAPS));
	
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::~CSupervisorInfo"
CSupervisorInfo::~CSupervisorInfo()
{
	if (m_fCritSecInited)
	{
		DNDeleteCriticalSection(&m_csLock);
	}
}

// this structure is only used by the next two functions, hence
// it is declared here for convenince.
struct SMoveWindowEnumProcParam
{
	PROCESS_INFORMATION* lppi;
	int x;
	int y;
	BOOL fMoved;
};

struct SBringToForegroundEnumProcParam
{
	PROCESS_INFORMATION* lppi;
	BOOL fFound;
};

#undef DPF_MODNAME
#define DPF_MODNAME "BringToForegroundWindowProc"
BOOL CALLBACK BringToForegroundWindowProc(HWND hwnd, LPARAM lParam)
{
	SBringToForegroundEnumProcParam* param;
	param = (SBringToForegroundEnumProcParam*)lParam;
	DPFX(DPFPREP, DVF_INFOLEVEL, "looking for main window for pid: %i", param->lppi->dwProcessId);

	DWORD dwProcessId;
	GetWindowThreadProcessId(hwnd, &dwProcessId);
	DPFX(DPFPREP, DVF_INFOLEVEL, "window: 0x%p has pid: 0x%08x", hwnd, dwProcessId);
	if (dwProcessId == param->lppi->dwProcessId)
	{
		TCHAR rgtchClassName[64];
		GetClassName(hwnd, rgtchClassName, 64);
		if (_tcsnicmp(rgtchClassName, _T("Volume Control"), 64) == 0)
		{
		    
			if (!SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE))
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "SetWindowPos failed, code: 0x%x", GetLastError());
			}
			else
			{
				param->fFound = TRUE;
			}
		}
		return FALSE;
	}
	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "BringToForegroundWindowEnumProc"
BOOL CALLBACK BringToForegroundWindowEnumProc(HWND hwnd, LPARAM lParam)
{
	SMoveWindowEnumProcParam* param;
	param = (SMoveWindowEnumProcParam*)lParam;
	DPFX(DPFPREP, DVF_INFOLEVEL, "looking for main window for pid: 0x%x", param->lppi->dwProcessId);

	DWORD dwProcessId;
	GetWindowThreadProcessId(hwnd, &dwProcessId);
	DPFX(DPFPREP, DVF_INFOLEVEL, "window: 0x%p has pid: 0x%08x", hwnd, dwProcessId);
	if (dwProcessId == param->lppi->dwProcessId)
	{
		TCHAR rgtchClassName[64];
		GetClassName(hwnd, rgtchClassName, 64);
		if (_tcsnicmp(rgtchClassName, _T("Volume Control"), 64) == 0)
		{
			if (!SetForegroundWindow(hwnd))
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "SetForegroundWindow failed, code: 0x%x", GetLastError());
			}
		}
		return FALSE;
	}
	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "MoveWindowEnumProc"
BOOL CALLBACK MoveWindowEnumProc(HWND hwnd, LPARAM lParam)
{
	SMoveWindowEnumProcParam* param;
	param = (SMoveWindowEnumProcParam*)lParam;
	DPFX(DPFPREP, DVF_INFOLEVEL, "looking for main window for pid: %i", param->lppi->dwProcessId);

	DWORD dwProcessId;
	GetWindowThreadProcessId(hwnd, &dwProcessId);
	DPFX(DPFPREP, DVF_INFOLEVEL, "window: 0x%p has pid: 0x%08x", hwnd, dwProcessId);
	if (dwProcessId == param->lppi->dwProcessId)
	{
		TCHAR rgtchClassName[64];
		GetClassName(hwnd, rgtchClassName, 64);
		if (_tcsnicmp(rgtchClassName, _T("Volume Control"), 64) == 0)
		{
			if (!SetWindowPos(hwnd, HWND_TOP, param->x, param->y, 0, 0, SWP_NOSIZE))
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "SetWindowPos failed, code: 0x%x", GetLastError());
			}
			else
			{
				param->fMoved = TRUE;
			}
		}
		return FALSE;
	}
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetDeviceFlags"
void CSupervisorInfo::SetDeviceFlags( DWORD dwFlags )
{
    m_dwDeviceFlags = dwFlags;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetDeviceFlags"
void CSupervisorInfo::GetDeviceFlags( DWORD *pdwFlags )
{
    *pdwFlags = m_dwDeviceFlags;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::LaunchWindowsVolumeControl"
HRESULT CSupervisorInfo::LaunchWindowsVolumeControl(HWND hwndWizard, BOOL fRecord)
{
	DPF_ENTER();

	STARTUPINFO si;
	ZeroMemory(&si, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	TCHAR ptcharCommand[64];
	PROCESS_INFORMATION* lppi;
	UINT uiPlayMixerID = 0;
	UINT uiCaptureMixerID = 0;
	MMRESULT mmr = MMSYSERR_NOERROR;
	
	mmr = mixerGetID( (HMIXEROBJ) (UINT_PTR) m_uiWaveInDeviceId, &uiCaptureMixerID, MIXER_OBJECTF_WAVEIN );

	if( mmr != MMSYSERR_NOERROR )
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Failed to get capture mixerline mmr=0x%x", mmr );
		return DV_OK;
	}
	
	mmr = mixerGetID( (HMIXEROBJ) (UINT_PTR) m_uiWaveOutDeviceId, &uiPlayMixerID, MIXER_OBJECTF_WAVEOUT );

	if( mmr != MMSYSERR_NOERROR )
	{
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Failed to get playback mixerline mmr=0x%x", mmr );
		return DV_OK;		
	}	

	if (fRecord)
	{
		_stprintf(ptcharCommand, _T("sndvol32 /R /D %i"), uiCaptureMixerID);
		lppi = &m_piSndVol32Record;
	}
	else
	{
		_stprintf(ptcharCommand, _T("sndvol32 /D %i"), uiPlayMixerID);
		lppi = &m_piSndVol32Playback;
	}

	if (lppi->hProcess != NULL)
	{
		DWORD dwExitCode;
		if (GetExitCodeProcess(lppi->hProcess, &dwExitCode) != 0)
		{
			if (dwExitCode == STILL_ACTIVE)
			{
				// not dead yet! Don't start another copy,
				// but do bring it to the foreground.
				SMoveWindowEnumProcParam param;
				param.lppi = lppi;
				param.fMoved = FALSE;
				param.x = 0;
				param.y = 0;
				EnumWindows(BringToForegroundWindowEnumProc, (LPARAM)&param);
				DPF_EXIT();
				return DV_OK;
			}
			
			// The user terminated the process. Close our handles, 
			// and zero the process information structure
			CloseHandle(lppi->hProcess);
			CloseHandle(lppi->hThread);
			ZeroMemory(lppi, sizeof(PROCESS_INFORMATION));
		}
		else
		{
			// If GetExitCodeProcess fails, assume the handle
			// is bad for some reason. Log it, then behave as
			// if the process was shut down. At worst, we'll
			// have multiple copies of SndVol32 running around.
			Diagnostics_Write(DVF_ERRORLEVEL, "GetExitCodeProcess failed, code:0x%x", GetLastError());
			// Don't close the handles, they may be bad. If they're
			// not, the OS will clean 'em up when the wizard exits.
			ZeroMemory(lppi, sizeof(PROCESS_INFORMATION));
		}
	}

	if (lppi->hProcess == NULL)
	{
		CreateProcess(
			NULL, 
			ptcharCommand, 
			NULL, 
			NULL, 
			FALSE, 
			0, 
			NULL, 
			NULL, 
			&si, 
			lppi);

		DPFX(DPFPREP, DVF_INFOLEVEL, "Launched volume control, pid:%i", lppi->dwProcessId);
		
		// Find main window for the process we just created and
		// move it manually.
		//
		// Note the race condition - I have no reliable way to wait until
		// the main window has been displayed. So, the work around
		// (a.k.a. HACK) is to keep looking for it for a while.
		// If it hasn't been found by then, we just give up. It's not
		// tragic if we don't find it, it just won't be as neat and
		// tidy, since the window will come up wherever it was last time.
		//
		// Note that sndvol32.exe does not accept the STARTF_USEPOSITION
		// flag on the PROCESS_INFORMATION structure, so I have to do 
		// this hack.
		//
		// In an attempt to let the sndvol32.exe get up and running,
		// I call Sleep to relinquish my timeslice.
		Sleep(0);

		RECT rect;
		if (GetWindowRect(hwndWizard, &rect))
		{
			SMoveWindowEnumProcParam param;
			param.lppi = lppi;
			param.fMoved = FALSE;

			param.x = rect.left;
			param.y = rect.top;

			int iOffset = GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYBORDER);
			
			if (m_piSndVol32Record.hProcess == lppi->hProcess)
			{
				// This is the recording control. Cascade it
				// one level down from the wizard main window.
				param.x += iOffset;
				param.y += iOffset;
			}
			else
			{
				// This is the playback control. Cascade it
				// two levels down from the wizard main window.
				param.x += iOffset*2;
				param.y += iOffset*2;
			}

			// Make twenty attempts to move the window.
			// Combined with Sleep(25), this will not
			// wait for more than 1/2 second before giving up.
			for (int i = 0; i < 20; ++i)
			{
				EnumWindows(MoveWindowEnumProc, (LPARAM)&param);
				if (param.fMoved)
				{
					// window was moved, break out.
					break;
				}

				// Window was not moved. Wait 25 milliseconds (plus change)
				// and try again.
				DPFX(DPFPREP, DVF_WARNINGLEVEL, "Attempt to move sndvol32 window failed");
				Sleep(25);
			}
		}
		else
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "GetWindowRect failed");
		}
		
	}
		
	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CloseWindowEnumProc"
BOOL CALLBACK CloseWindowEnumProc(HWND hwnd, LPARAM lParam)
{
	DWORD dwProcessId;
	DPFX(DPFPREP, DVF_INFOLEVEL, "looking for pid: 0x%p to shutdown", lParam);
	GetWindowThreadProcessId(hwnd, &dwProcessId);
	DPFX(DPFPREP, DVF_INFOLEVEL, "window: 0x%p has pid: 0x%08x", hwnd, dwProcessId);
	if (dwProcessId == (DWORD)lParam)
	{
		// found it, ask it to close.
		DPFX(DPFPREP, DVF_INFOLEVEL, "Sending WM_CLOSE to 0x%p", hwnd);
		SendMessage(hwnd, WM_CLOSE, 0, 0);
		return FALSE;
	}
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CloseWindowsVolumeControl"
HRESULT CSupervisorInfo::CloseWindowsVolumeControl(BOOL fRecord)
{
	DPF_ENTER();

	PROCESS_INFORMATION* lppi;

	if (fRecord)
	{
		lppi = &m_piSndVol32Record;
	}
	else
	{
		lppi = &m_piSndVol32Playback;
	}

	if (lppi->hProcess != NULL)
	{
		DWORD dwExitCode;
		if (GetExitCodeProcess(lppi->hProcess, &dwExitCode) != 0)
		{
			if (dwExitCode == STILL_ACTIVE)
			{
				DPFX(DPFPREP, DVF_INFOLEVEL, "Attempting to close volume control with pid: %i", lppi->dwProcessId);

				// there is currently a volume control showing, find it and 
				// ask it to close
				EnumWindows(CloseWindowEnumProc, lppi->dwProcessId);

				// Zero out the process information struct
				ZeroMemory(lppi, sizeof(PROCESS_INFORMATION));
			}
		}
	}
		
	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetWaveOutVolume"
HRESULT CSupervisorInfo::GetWaveOutVolume(DWORD* lpdwVolume)
{
	DPF_ENTER();

	if (!(m_woCaps.dwSupport & WAVECAPS_VOLUME|WAVECAPS_LRVOLUME))
	{
		// doesn't support wave out
		Diagnostics_Write(DVF_ERRORLEVEL, "Wave device %i does not support volume control", m_uiWaveOutDeviceId);
		DPF_EXIT();
		return E_FAIL;
	}
	
	MMRESULT mmr = waveOutGetVolume((HWAVEOUT) ((UINT_PTR) m_uiWaveOutDeviceId ), lpdwVolume);
	if (mmr != MMSYSERR_NOERROR)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "waveOutGetVolume failed, code: %i", mmr);
		DPF_EXIT();
		return E_FAIL;
	}

	if (m_woCaps.dwSupport & WAVECAPS_LRVOLUME)
	{
		// has a left and right volume control - average them
		*lpdwVolume = (HIWORD(*lpdwVolume) + LOWORD(*lpdwVolume))/2;
	}
	else
	{
		// just a mono control - only the low word is significant
		*lpdwVolume = LOWORD(*lpdwVolume);
	}

	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetWaveOutVolume"
HRESULT CSupervisorInfo::SetWaveOutVolume(DWORD dwVolume)
{
	DPF_ENTER();

	MMRESULT mmr = waveOutSetVolume((HWAVEOUT) ((UINT_PTR) m_uiWaveOutDeviceId), LOWORD(dwVolume)<<16|LOWORD(dwVolume));
	if (mmr != MMSYSERR_NOERROR)
	{
		DPF_EXIT();
		return E_FAIL;
	}
		
	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetRecordVolume"
HRESULT CSupervisorInfo::SetRecordVolume(LONG lVolume)
{
	HRESULT hr;
	
	DVCLIENTCONFIG dvcc;
	dvcc.dwSize = sizeof(dvcc);
	
	if (m_lpdpvc != NULL)
	{
		hr = m_lpdpvc->GetClientConfig(&dvcc);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "GetClientConfig failed, hr:%i", hr);
			return hr;
		}
		
		dvcc.lRecordVolume = lVolume;
		hr = m_lpdpvc->SetClientConfig(&dvcc);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "SetClientConfig failed, hr:%i", hr);
			return hr;
		}
	}
	else
	{
		return DVERR_INVALIDPOINTER;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CancelFullDuplexTest"
HRESULT CSupervisorInfo::CancelFullDuplexTest()
{
	HRESULT hrFnc;
	HRESULT hr;
	DWORD dwRet;
	LONG lRet;	

	hrFnc = DV_OK;

	Diagnostics_Write(DVF_ERRORLEVEL,"User cancelled wizard during full duplex test." );

	DNEnterCriticalSection(&m_csLock);
	
	// Are we currently in the middle of a full duplex test?
	if (m_hFullDuplexThread != NULL)
	{
		// This flag is periodically checked by the full duplex test 
		// while it works.
		m_fAbortFullDuplex = TRUE;

		// wait for the full duplex thread to exit gracefully
		DNLeaveCriticalSection(&m_csLock);
		dwRet = WaitForMultipleObjects( 1, &m_hFullDuplexThread, FALSE, gc_dwLoopbackTestThreadTimeout);
		switch (dwRet)
		{
		case WAIT_OBJECT_0:
			// the full duplex thread is now done, so continue...
			DNEnterCriticalSection(&m_csLock);
			break;

		case WAIT_TIMEOUT:
			// The full duplex thread is not cooperating - get tough with it.
			DNEnterCriticalSection(&m_csLock);
			hr = m_sipc.TerminateChildProcesses();
			if (FAILED(hr))
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "TerminateChildProcesses failed, code: 0x%x", hr);
				hrFnc = hr;
			}
			if (!TerminateThread(m_hFullDuplexThread, hr))
			{
				lRet = GetLastError();
				Diagnostics_Write(DVF_ERRORLEVEL, "TerminateThread failed, code: 0x%x", lRet);
				hrFnc = DVERR_GENERIC;
			}
			break;

		default:
			// this is not supposed to happen. Note it, terminate everything,
			// and continue.
			DNEnterCriticalSection(&m_csLock);
			if (dwRet == WAIT_ABANDONED)
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "WaitForSingleObject abandoned unexpectedly");
				hrFnc = DVERR_GENERIC;
			}
			else
			{
				lRet = GetLastError();
				Diagnostics_Write(DVF_ERRORLEVEL, "WaitForSingleObject failed, code: 0x%x", lRet);
				hrFnc = DVERR_GENERIC;
			}
			hr = m_sipc.TerminateChildProcesses();
			if (FAILED(hr))
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "TerminateChildProcesses failed, code: 0x%x", hr);
				hrFnc = hr;
			}
			if (!TerminateThread(m_hFullDuplexThread, hr))
			{
				lRet = GetLastError();
				Diagnostics_Write(DVF_ERRORLEVEL, "TerminateThread failed, code: 0x%x", lRet);
				hrFnc = DVERR_GENERIC;
			}
			break;		
		}

		// Close the full duplex thread handle
		hr = WaitForFullDuplexThreadExitCode();
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "WaitForFullDuplexThreadExitCode failed, code: 0x%x", hr);
			hrFnc = hr;
		}

		// cleanup the IPC objects
		hr = DeinitIPC();
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DeinitIPC failed, code: 0x%x", hr);
			hrFnc = hr;
		}
	}

	DNLeaveCriticalSection(&m_csLock);
	return hrFnc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CancelLoopbackTest"
HRESULT CSupervisorInfo::CancelLoopbackTest()
{
	HRESULT hr = DV_OK;

    Diagnostics_Write(DVF_ERRORLEVEL,"User cancelled wizard during loopback test" );
	
	DNEnterCriticalSection(&m_csLock);
	
	// Are we currently in the middle of a loopback test?
	if (m_hLoopbackThread != NULL)
	{
		// If the loopback thread handle is not null, the mic test may still
		// be going on, in which case we want to set that flag to
		// REGVAL_NOTRUN, since the test was not completed.
		DWORD dwRegVal;
		GetMicDetected(&dwRegVal);
		if (dwRegVal == REGVAL_CRASHED)
		{
			SetMicDetected(REGVAL_NOTRUN);
		}
		
		DNLeaveCriticalSection(&m_csLock);	// ShutdownLoopbackThread has its own guard
		hr = ShutdownLoopbackThread();
		DNEnterCriticalSection(&m_csLock);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, code: %i", hr);
		}
	}

	DNLeaveCriticalSection(&m_csLock);

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::Cancel"
HRESULT CSupervisorInfo::Cancel()
{
	DPF_ENTER();
	
	DWORD dwRet;
	HRESULT hr;
	LONG lRet;
	HRESULT hrFnc;
	BOOL fDone;
	BOOL fGotMsg;
	BOOL fWelcomeNext;
	MSG msg;

	DNEnterCriticalSection(&m_csLock);

	hrFnc = DV_OK;

	// close any open volume controls
	CloseWindowsVolumeControl(TRUE);
	CloseWindowsVolumeControl(FALSE);

	// The cancel button can be hit at any time. 
	// We are not in a known state. This function	
	// has to figure it out from the member variables.
	// How fun.
	DNLeaveCriticalSection(&m_csLock);  // CancelFullDuplexTest has it's own guard
	hrFnc = CancelFullDuplexTest();
	DNEnterCriticalSection(&m_csLock);
	
	// Are we currently in the middle of a loopback test?
	if (m_hLoopbackThread != NULL)
	{
		DNLeaveCriticalSection(&m_csLock);	// ShutdownLoopbackThread has its own guard
		hr = ShutdownLoopbackThread();
		DNEnterCriticalSection(&m_csLock);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, code: %i", hr);
			hrFnc = hr;
		}
	}

	// Reset the registry to the "test not yet run" state
	// but only if the user moved past the welcome page
	GetWelcomeNext(&fWelcomeNext);
	if (fWelcomeNext)
	{
		hr = SetHalfDuplex(REGVAL_NOTRUN);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "SetHalfDuplex failed, code: %i", hr);
			hrFnc = hr;
		}

		hr = SetFullDuplex(REGVAL_NOTRUN);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "SetFullDuplex failed, code: %i", hr);
			hrFnc = hr;
		}

		hr = SetMicDetected(REGVAL_NOTRUN);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "SetMicDetected failed, code: %i", hr);
			hrFnc = hr;
		}
	}

	// record the fact that the wizard was bailed out of
	SetUserCancel();
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hrFnc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::Abort"
HRESULT CSupervisorInfo::Abort(HWND hDlg, HRESULT hrDlg)
{
	// This is the function called whenever a fatal error is hit while in the wizard
	
	DPF_ENTER();
	
	DWORD dwRet;
	HRESULT hr;
	LONG lRet;
	HRESULT hrFnc;
	BOOL fDone;
	BOOL fGotMsg;
	BOOL fWelcomeNext;
	MSG msg;
	HWND hwndParent = NULL;


	hrFnc = DV_OK;

	// close any open volume controls
	DNEnterCriticalSection(&m_csLock);
	CloseWindowsVolumeControl(TRUE);
	CloseWindowsVolumeControl(FALSE);
	DNLeaveCriticalSection(&m_csLock);

	// The cancel button can be hit at any time. 
	// We are not in a known state. This function	
	// has to figure it out from the member variables.
	// How fun.
	// CancelFullDuplexTest has it's own guard
	hrFnc = CancelFullDuplexTest();
	
	// Are we currently in the middle of a loopback test?
	DNEnterCriticalSection(&m_csLock);
	if (m_hLoopbackThread != NULL)
	{
		DNLeaveCriticalSection(&m_csLock);	// ShutdownLoopbackThread has its own guard
		hr = ShutdownLoopbackThread();
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, code: %i", hr);
			hrFnc = hr;
		}
	}

	// Leave the registry alone - this will signal that there was
	// an error to the next wizard run, assuming we're still in 
	// the middle of a test. If we've actually gotten far enough
	// along to record a pass in the registry, so be it.

	// Call EndDialog to forcibly bail out of the wizard.
	Diagnostics_Write(DVF_ERRORLEVEL, "Attempting to abort wizard, hr: %i", hrDlg);
	hwndParent = GetParent(hDlg);
	if (IsWindow(hwndParent))
	{
		PostMessage(hwndParent, WM_CLOSE, (WPARAM)NULL, (LPARAM)NULL);
		/*
		// EndDialog does not work because we are in a property sheet
		if (!EndDialog(hwndParent, hrDlg))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "EndDialog failed, code: %i:", GetLastError());
		}
		*/
	}
	else
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to get a handle to the wizard!");
	}
	
	DPF_EXIT();
	return hrFnc;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::Finish"
HRESULT CSupervisorInfo::Finish()
{
	DPF_ENTER();

	DWORD dwRet;
	HRESULT hr;
	LONG lRet;
	HRESULT hrFnc;
	DWORD dwValue;
	
	DNEnterCriticalSection(&m_csLock);

	hrFnc = DV_OK;

	// close any open volume controls
	CloseWindowsVolumeControl(TRUE);
	CloseWindowsVolumeControl(FALSE);

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hrFnc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CreateFullDuplexThread"
HRESULT CSupervisorInfo::CreateFullDuplexThread()
{
	DPF_ENTER();
	
	HRESULT hr;
	LONG lRet;
	DWORD dwThreadId;
	
	DNEnterCriticalSection(&m_csLock);

	// Null out the interface pointer
	m_lpdpvc = NULL;	

	if (m_hFullDuplexThread != NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "m_hFullDuplexThread not NULL");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	m_hFullDuplexThread = CreateThread(NULL, 0, FullDuplexTestThreadProc, (LPVOID)this, NULL, &dwThreadId);
	if (m_hFullDuplexThread == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateThread failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::WaitForFullDuplexThreadExitCode"
HRESULT CSupervisorInfo::WaitForFullDuplexThreadExitCode()
{
	DPF_ENTER();
	
	HRESULT hr;
	HRESULT hrFnc;
	LONG lRet;
	DWORD dwThreadId;
	DWORD dwRet;
	
	DNEnterCriticalSection(&m_csLock);

	if (m_hFullDuplexThread == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "m_hFullDuplexThread is NULL");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	dwRet = WaitForSingleObject(m_hFullDuplexThread, gc_dwChildWaitTimeout);
	switch(dwRet)
	{
	case WAIT_OBJECT_0:
		break;

	case WAIT_TIMEOUT:
		Diagnostics_Write(DVF_ERRORLEVEL, "Timed out waiting for full duplex test thread to exit - terminating forcibly");
		TerminateThread(m_hFullDuplexThread, DVERR_GENERIC);
		hr = DVERR_GENERIC;
		goto error_cleanup;

	default:
		Diagnostics_Write(DVF_ERRORLEVEL, "Unknown error waiting for full duplex test thread to exit - terminating forcibly");
		TerminateThread(m_hFullDuplexThread, DVERR_GENERIC);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	if (!GetExitCodeThread(m_hFullDuplexThread, (DWORD*)&hrFnc))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Error retrieving full duplex test thread's exit code");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	if (!CloseHandle(m_hFullDuplexThread))
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	m_hFullDuplexThread = NULL;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hrFnc;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CreateLoopbackThread"
HRESULT CSupervisorInfo::CreateLoopbackThread()
{
	DPF_ENTER();
	
	HRESULT hr;
	LONG lRet;
	DWORD dwThreadId;
	
	DNEnterCriticalSection(&m_csLock);
	m_hLoopbackShutdownEvent = NULL;

	if (m_hLoopbackThread != NULL)
	{
		// The loopback test is already running. 
		// Just dump a warning and return pending.
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "m_hLoopbackThread not NULL");
		hr = DVERR_PENDING;
		goto error_cleanup;
	}

	// create an event the loopback thread signals just before it exits
	m_hLoopbackThreadExitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hLoopbackThreadExitEvent == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateEvent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// create an event the loopback thread listens for to shutdown
	m_hLoopbackShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hLoopbackShutdownEvent == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateEvent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	m_hLoopbackThread = CreateThread(NULL, 0, LoopbackTestThreadProc, (LPVOID)this, NULL, &dwThreadId);
	if (m_hLoopbackThread == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateThread failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	if (m_hLoopbackThreadExitEvent != NULL)
	{
		CloseHandle(m_hLoopbackThreadExitEvent);
		m_hLoopbackThreadExitEvent = NULL;
	}
	if (m_hLoopbackShutdownEvent != NULL)
	{
		CloseHandle(m_hLoopbackShutdownEvent);
		m_hLoopbackShutdownEvent = NULL;
	}
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::WaitForLoopbackShutdownEvent"
HRESULT CSupervisorInfo::WaitForLoopbackShutdownEvent()
{
	DPF_ENTER();
	
	HRESULT hr;
	LONG lRet;
	DWORD dwThreadId;
	DWORD dwRet;
	HANDLE hEvent;
	
	DNEnterCriticalSection(&m_csLock);
	hEvent = m_hLoopbackShutdownEvent;
	DNLeaveCriticalSection(&m_csLock);
	dwRet = WaitForSingleObject(hEvent, INFINITE);
	DNEnterCriticalSection(&m_csLock);
	switch (dwRet)
	{
	case WAIT_OBJECT_0:
		// expected behavior, continue
		break;
	case WAIT_TIMEOUT:
		Diagnostics_Write(DVF_ERRORLEVEL, "WaitForSingleObject timed out unexpectedly");
		hr = DVERR_GENERIC;
		goto error_cleanup;
		
	case WAIT_ABANDONED:
		Diagnostics_Write(DVF_ERRORLEVEL, "WaitForSingleObject abandoned unexpectedly");
		hr = DVERR_GENERIC;
		goto error_cleanup;

	default:
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "WaitForSingleObject returned unknown code, GetLastError(): %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SignalLoopbackThreadDone"
HRESULT CSupervisorInfo::SignalLoopbackThreadDone()
{
	DPF_ENTER();
	
	HRESULT hr;
	LONG lRet;
	HANDLE hEvent;

	DNEnterCriticalSection(&m_csLock);
	hEvent = m_hLoopbackThreadExitEvent;
	DNLeaveCriticalSection(&m_csLock);
	if (!SetEvent(hEvent))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "SetEvent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ShutdownLoopbackThread"
HRESULT CSupervisorInfo::ShutdownLoopbackThread()
{
	DPF_ENTER();
	
	HRESULT hr;
	LONG lRet;
	DWORD dwThreadId;
	DWORD dwRet;
	BOOL fDone;
	BOOL fGotMsg;
	MSG msg;
	HANDLE rghHandle[2];
	HANDLE hEvent;

	DNEnterCriticalSection(&m_csLock);

	if (m_hLoopbackThread == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "m_hLoopbackThread is NULL");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	if (!SetEvent(m_hLoopbackShutdownEvent))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "SetEvent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	/*
	rghHandle[0] = m_hLoopbackThreadExitEvent;
	rghHandle[1] = m_hLoopbackThread;
	*/
	hEvent = m_hLoopbackThreadExitEvent;

	DNLeaveCriticalSection(&m_csLock);
	fDone = FALSE;
	while (!fDone)
	{
		dwRet = WaitForSingleObject(hEvent, gc_dwLoopbackTestThreadTimeout);
		switch(dwRet)
		{
		case WAIT_OBJECT_0:
			DNEnterCriticalSection(&m_csLock);
			fDone = TRUE;
			break;

		case WAIT_ABANDONED:
		default:
			// not supposed to be possible, but treat both like a timeout.

		case WAIT_TIMEOUT:
			DNEnterCriticalSection(&m_csLock);
			hr = DVERR_TIMEOUT;
			goto error_cleanup;
			break;
		}
		/*
		dwRet = MsgWaitForMultipleObjects(2, rghHandle, FALSE, gc_dwLoopbackTestThreadTimeout, QS_ALLINPUT);
		switch (dwRet)
		{
		case WAIT_OBJECT_0:
		case WAIT_OBJECT_0 + 1:
			// expected result, continue...
			DNEnterCriticalSection(&m_csLock);
			fDone = TRUE;
			break;
			
		case WAIT_TIMEOUT:
			// loopback thread is not behaving, jump to
			// the error block where it will be terminated forcibly
			DNEnterCriticalSection(&m_csLock);
			hr = DVERR_TIMEOUT;
			goto error_cleanup;
			break;

		case WAIT_OBJECT_0 + 2:
			// One or more windows messages have been posted to this thread's
			// message queue. Deal with 'em.
			fGotMsg = TRUE;
			
			while( fGotMsg )
			{
				fGotMsg = PeekMessage( &msg, NULL, 0U, 0U, PM_REMOVE );

				if( fGotMsg )
				{
					TranslateMessage( &msg );
					DispatchMessage( &msg );
				}
			}
			break;

		default:
			if (dwRet == WAIT_ABANDONED)
			{
				Diagnostics_Write(DVF_ERRORLEVEL, "MsgWaitForMultipleObjects abandoned unexpectedly");
			}
			else
			{
				lRet = GetLastError();
				Diagnostics_Write(DVF_ERRORLEVEL, "MsgWaitForMultipleObjects failed, code: %i");
			}
			DNEnterCriticalSection(&m_csLock);
			hr = DVERR_TIMEOUT;
			goto error_cleanup;
			break;
		}
		*/
	}

	if (!CloseHandle(m_hLoopbackThread))
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
		m_hLoopbackThread = NULL;
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	m_hLoopbackThread = NULL;

	if (!CloseHandle(m_hLoopbackThreadExitEvent))
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
		m_hLoopbackThreadExitEvent = NULL;
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	m_hLoopbackThreadExitEvent = NULL;

	if (!CloseHandle(m_hLoopbackShutdownEvent))
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
		m_hLoopbackShutdownEvent = NULL;
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	m_hLoopbackShutdownEvent = NULL;
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	if (m_hLoopbackThread != NULL)
	{
		TerminateThread(m_hLoopbackThread, DVERR_GENERIC);
		CloseHandle(m_hLoopbackThread);
		m_hLoopbackThread = NULL;
	}

	if (m_hLoopbackThreadExitEvent != NULL)
	{
		CloseHandle(m_hLoopbackThreadExitEvent);
		m_hLoopbackThreadExitEvent = NULL;
	}
	
	if (m_hLoopbackShutdownEvent != NULL)
	{
		CloseHandle(m_hLoopbackShutdownEvent);
		m_hLoopbackShutdownEvent = NULL;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetFullDuplex"
HRESULT CSupervisorInfo::SetFullDuplex(DWORD dwFullDuplex)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	HKEY hk;
	LONG lRet;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.WriteDWORD(gc_wszValueName_FullDuplex, dwFullDuplex))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::WriteDWORD failed");
		hr = DVERR_GENERIC;
	}
	else
	{
		// Flush the registry operations to ensure they
		// are written. Otherwise we may not detect a crash!
		hk = m_creg.GetHandle();
		lRet = RegFlushKey(hk);
		if (lRet != ERROR_SUCCESS)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "RegFlushKey failed");
			hr = DVERR_GENERIC;
		}
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetFullDuplex"
HRESULT CSupervisorInfo::GetFullDuplex(DWORD* pdwFullDuplex)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.ReadDWORD(gc_wszValueName_FullDuplex, *pdwFullDuplex))
	{
		// registry key is not present
		*pdwFullDuplex = 0;
		hr = DVERR_GENERIC;		
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHalfDuplex"
HRESULT CSupervisorInfo::SetHalfDuplex(DWORD dwHalfDuplex)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	LONG lRet;
	HKEY hk;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.WriteDWORD(gc_wszValueName_HalfDuplex, dwHalfDuplex))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::WriteDWORD failed");
		hr = DVERR_GENERIC;
	}
	else
	{
		// Flush the registry operations to ensure they
		// are written. Otherwise we may not detect a crash!
		hk = m_creg.GetHandle();
		lRet = RegFlushKey(hk);
		if (lRet != ERROR_SUCCESS)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "RegFlushKey failed");
			hr = DVERR_GENERIC;
		}
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHalfDuplex"
HRESULT CSupervisorInfo::GetHalfDuplex(DWORD* pdwHalfDuplex)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.ReadDWORD(gc_wszValueName_HalfDuplex, *pdwHalfDuplex))
	{
		// registry key is not present
		*pdwHalfDuplex = 0;
		hr = DVERR_GENERIC;		
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetMicDetected"
HRESULT CSupervisorInfo::SetMicDetected(DWORD dwMicDetected)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	LONG lRet;
	HKEY hk;

	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.WriteDWORD(gc_wszValueName_MicDetected, dwMicDetected))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::WriteDWORD failed");
		hr = DVERR_GENERIC;
	}
	else
	{
		// Flush the registry operations to ensure they
		// are written. Otherwise we may not detect a crash!
		hk = m_creg.GetHandle();
		lRet = RegFlushKey(hk);
		if (lRet != ERROR_SUCCESS)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "RegFlushKey failed");
			hr = DVERR_GENERIC;
		}
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetMicDetected"
HRESULT CSupervisorInfo::GetMicDetected(DWORD* pdwMicDetected)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.ReadDWORD(gc_wszValueName_MicDetected, *pdwMicDetected))
	{
		// registry key is not present
		*pdwMicDetected = 0;
		hr = DVERR_GENERIC;		
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::QueryFullDuplex"
HRESULT CSupervisorInfo::QueryFullDuplex()
{
	DPF_ENTER();
	
	HRESULT hr;
	DWORD dwFullDuplex;
	DWORD dwHalfDuplex;
	DWORD dwMicDetected;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.ReadDWORD(gc_wszValueName_HalfDuplex, dwHalfDuplex))
	{
		// registry key is not present - setup has not run
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "HalfDuplex key not found in registry");
		hr = DVERR_RUNSETUP;
		goto error_cleanup;
	}
	switch (dwHalfDuplex)
	{
	case REGVAL_NOTRUN:
		// test not run
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "HalfDuplex = 0; test not run");
		hr = DVERR_RUNSETUP;
		goto error_cleanup;
		
	case REGVAL_CRASHED:
		// test crashed out!
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "HalfDuplex = 1; test crashed");
		hr = DVERR_SOUNDINITFAILURE;
		goto error_cleanup;

	case REGVAL_FAILED:
		// test failed gracefully
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "HalfDuplex = 2; test failed gracefully");
		hr = DVERR_SOUNDINITFAILURE;
		goto error_cleanup;
		
	case REGVAL_PASSED:
		// test passed
		DPFX(DPFPREP, DVF_INFOLEVEL, "HalfDuplex = 3; test passed");
		break;

	default:
		// bad key value - return run setup
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "HalfDuplex = %i; bad key value!", dwHalfDuplex);
		hr = DVERR_RUNSETUP;
		goto error_cleanup;
	}

	if (!m_creg.ReadDWORD(gc_wszValueName_FullDuplex, dwFullDuplex))
	{
		// registry key is not present - very odd.
		// however, since we at least passed half duplex to get
		// here, we'll return half duplex
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "FullDuplex key not found in registry");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
	}
	switch (dwFullDuplex)
	{
	case REGVAL_NOTRUN:
		// Test not run - this is very odd, considering that
		// in order to get here, the half duplex test must have
		// been run and passed. Return half duplex.
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "FullDuplex = 0; test not run");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
		
	case REGVAL_CRASHED:
		// test crashed out! - They tried, and going further
		// wouldn't help, so certify them for half duplex
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "FullDuplex = 1; test crashed");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;

	case REGVAL_FAILED:
		// test failed gracefully - mic test would not have been
		// run, certify them for half duplex.
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "FullDuplex = 2; test failed gracefully");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
		
	case REGVAL_PASSED:
		// test passed
		DPFX(DPFPREP, DVF_INFOLEVEL, "FullDuplex = 3; test passed");
		break;

	default:
		// bad key value - but the system can at least do
		// half duplex, so certify them for half duplex
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "FullDuplex = %i; bad key value!", dwFullDuplex);
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
	}

	// From this point on, we know the full duplex test was ok.
	// However, in order to get a full duplex pass, the mic must
	// also have been detected.

	if (!m_creg.ReadDWORD(gc_wszValueName_MicDetected, dwMicDetected))
	{
		// registry key is not present - very odd
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "MicDetected key not found in registry");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
	}
	switch (dwMicDetected)
	{
	case REGVAL_NOTRUN:
		// Test not run - odd, but pass them for half duplex anyway
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "MicDetected = 0; test not run");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
		
	case REGVAL_CRASHED:
		// test crashed out! This shouldn't happen, since it
		// should have been caught in the full duplex test,
		// but either way, they tried thier best and half
		// duplex worked, so certify them for half duplex.
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "MicDetected = 1; test crashed");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;

	case REGVAL_FAILED:
		// test failed gracefully - certify for half duplex
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "MicDetected = 2; test failed gracefully");
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
		
	case REGVAL_PASSED:
		// test passed
		DPFX(DPFPREP, DVF_INFOLEVEL, "MicDetected = 3; test passed");
		break;

	default:
		// bad key value - odd, but pass them for half duplex anyway.
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "MicDetected = %i; bad key value!", dwMicDetected);
		hr = DV_HALFDUPLEX;
		goto error_cleanup;
	}

	// If we get here, all keys were a clean pass, so return full duplex
	hr = DV_FULLDUPLEX;	

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::OpenRegKey"
HRESULT CSupervisorInfo::OpenRegKey(BOOL fCreate)
{
	DPF_ENTER();
	
	LONG lRet;
	HRESULT hr;
	CRegistry cregAudioConfig;
	HKEY hkAudioConfig;
	CRegistry cregRender;
	HKEY hkRender;
	WCHAR wszRenderGuidString[GUID_STRING_LEN];
	WCHAR wszCaptureGuidString[GUID_STRING_LEN];
	BOOL bAudioKeyOpen = FALSE;
	BOOL bRenderKeyOpen = FALSE;
		
	DNEnterCriticalSection(&m_csLock);

	if (!cregAudioConfig.Open(HKEY_CURRENT_USER, gc_wszKeyName_AudioConfig, FALSE, fCreate))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::Open failed");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	bAudioKeyOpen = TRUE;

	hkAudioConfig = cregAudioConfig.GetHandle();
	
	if (!cregRender.Open(hkAudioConfig, &m_guidRenderDevice, FALSE, fCreate))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::Open failed");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	bRenderKeyOpen = TRUE;

	hkRender = cregRender.GetHandle();
	
	if (!m_creg.Open(hkRender, &m_guidCaptureDevice, FALSE, fCreate))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::Open failed");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;

error_cleanup:
	if (bRenderKeyOpen)
	{
		cregRender.Close();
	}

	if (bAudioKeyOpen)
	{
		cregAudioConfig.Close();
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ThereCanBeOnlyOne"
HRESULT CSupervisorInfo::ThereCanBeOnlyOne()
{
	DPF_ENTER();
	
	LONG lRet;
	HANDLE hMutex;
	HRESULT hr;
	
	hr = DV_OK;
	hMutex = CreateMutex(NULL, FALSE, gc_szMutexName);
	lRet = GetLastError();
	if (hMutex == NULL)
	{
		// something went very wrong
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateMutex failed, code: %i", lRet);
		return DVERR_GENERIC;
	}
	
	// see if the mutex already existed
	if (lRet == ERROR_ALREADY_EXISTS)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Detected another instance of test running");
		if (!CloseHandle(hMutex))
		{
			lRet = GetLastError();
			Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
		}
		return DVERR_ALREADYPENDING;
	}

	DNEnterCriticalSection(&m_csLock);
	if (m_hMutex != NULL)
	{
		DNLeaveCriticalSection(&m_csLock);
		Diagnostics_Write(DVF_ERRORLEVEL, "m_hMutex not null");
		if (!CloseHandle(hMutex))
		{
			lRet = GetLastError();
			Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
		}
		return DVERR_GENERIC;
	}

	m_hMutex = hMutex;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CloseMutex"
void CSupervisorInfo::CloseMutex()
{
	DPF_ENTER();

	DNEnterCriticalSection(&m_csLock);

	LONG lRet;
	
	// close the mutex
	if (!CloseHandle(m_hMutex))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CloseHandle failed, code: %i", lRet);
	}
	m_hMutex = NULL;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetVoiceDetected"
void CSupervisorInfo::SetVoiceDetected()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fVoiceDetected = TRUE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ClearVoiceDetected"
void CSupervisorInfo::ClearVoiceDetected()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fVoiceDetected = FALSE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetVoiceDetected"
void CSupervisorInfo::GetVoiceDetected(BOOL* lpfPreviousCrash)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lpfPreviousCrash = m_fVoiceDetected;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetUserBack"
void CSupervisorInfo::SetUserBack()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fUserBack = TRUE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ClearUserBack"
void CSupervisorInfo::ClearUserBack()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fUserBack = FALSE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetUserBack"
void CSupervisorInfo::GetUserBack(BOOL* lpfUserBack)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lpfUserBack = m_fUserBack;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetUserCancel"
void CSupervisorInfo::SetUserCancel()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fUserCancel = TRUE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ClearUserCancel"
void CSupervisorInfo::ClearUserCancel()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fUserCancel = FALSE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetUserCancel"
void CSupervisorInfo::GetUserCancel(BOOL* lpfUserCancel)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lpfUserCancel = m_fUserCancel;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetWelcomeNext"
void CSupervisorInfo::SetWelcomeNext()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fWelcomeNext = TRUE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ClearWelcomeNext"
void CSupervisorInfo::ClearWelcomeNext()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fWelcomeNext = FALSE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetWelcomeNext"
void CSupervisorInfo::GetWelcomeNext(BOOL* lpfWelcomeNext)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lpfWelcomeNext = m_fWelcomeNext;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetError"
void CSupervisorInfo::GetError(HRESULT* hr)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*hr = m_hrError;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetError"
void CSupervisorInfo::SetError(HRESULT hr)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hrError = hr;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetTitleFont"
void CSupervisorInfo::GetTitleFont(HFONT* lphfTitle)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphfTitle = m_hfTitle;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetBoldFont"
void CSupervisorInfo::GetBoldFont(HFONT* lphfBold)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphfBold = m_hfBold;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetCaptureDevice"
void CSupervisorInfo::GetCaptureDevice(GUID* lpguidCaptureDevice)
{
	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Enter");
	DNEnterCriticalSection(&m_csLock);
	*lpguidCaptureDevice = m_guidCaptureDevice;
	DNLeaveCriticalSection(&m_csLock);
	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Exit");
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetCaptureDevice"
void CSupervisorInfo::SetCaptureDevice(GUID guidCaptureDevice)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_guidCaptureDevice = guidCaptureDevice;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetRenderDevice"
void CSupervisorInfo::GetRenderDevice(GUID* lpguidRenderDevice)
{
	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Enter");
	DNEnterCriticalSection(&m_csLock);
	*lpguidRenderDevice = m_guidRenderDevice;
	DNLeaveCriticalSection(&m_csLock);
	DPFX(DPFPREP, DVF_ENTRYLEVEL, "Exit");
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetRenderDevice"
void CSupervisorInfo::SetRenderDevice(GUID guidRenderDevice)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_guidRenderDevice = guidRenderDevice;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetWaveOutId"
HRESULT CSupervisorInfo::SetWaveOutId(UINT ui)
{
	HRESULT hr = DV_OK;
	
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_uiWaveOutDeviceId = ui;

	ZeroMemory(&m_woCaps, sizeof(WAVEOUTCAPS));
	MMRESULT mmr = waveOutGetDevCaps(ui, &m_woCaps, sizeof(WAVEOUTCAPS));
	if (mmr != MMSYSERR_NOERROR)
	{
		ZeroMemory(&m_woCaps, sizeof(WAVEOUTCAPS));
		hr = DVERR_INVALIDPARAM;
	}

//error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetWaveInId"
void CSupervisorInfo::SetWaveInId(UINT ui)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_uiWaveInDeviceId = ui;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetLoopbackFlags"
void CSupervisorInfo::GetLoopbackFlags(DWORD* pdwFlags)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*pdwFlags = m_dwLoopbackFlags;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetLoopbackFlags"
void CSupervisorInfo::SetLoopbackFlags(DWORD dwFlags)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_dwLoopbackFlags = dwFlags;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetCheckAudioSetupFlags"
void CSupervisorInfo::GetCheckAudioSetupFlags(DWORD* pdwFlags)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*pdwFlags = m_dwCheckAudioSetupFlags;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetCheckAudioSetupFlags"
void CSupervisorInfo::SetCheckAudioSetupFlags(DWORD dwFlags)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_dwCheckAudioSetupFlags = dwFlags;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetFullDuplexResults"
void CSupervisorInfo::GetFullDuplexResults(HRESULT* phr)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*phr = m_hrFullDuplexResults;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetFullDuplexResults"
void CSupervisorInfo::SetFullDuplexResults(HRESULT hr)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hrFullDuplexResults = hr;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDParent"
void CSupervisorInfo::GetHWNDParent(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndParent;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDWizard"
void CSupervisorInfo::SetHWNDParent(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndParent = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDWizard"
void CSupervisorInfo::GetHWNDWizard(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndWizard;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDWizard"
void CSupervisorInfo::SetHWNDWizard(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndWizard = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDDialog"
void CSupervisorInfo::GetHWNDDialog(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndDialog;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDDialog"
void CSupervisorInfo::SetHWNDDialog(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndDialog = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDProgress"
void CSupervisorInfo::GetHWNDProgress(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndProgress;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDProgress"
void CSupervisorInfo::SetHWNDProgress(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndProgress = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDInputPeak"
void CSupervisorInfo::GetHWNDInputPeak(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndInputPeak;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDInputPeak"
void CSupervisorInfo::SetHWNDInputPeak(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndInputPeak = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDOutputPeak"
void CSupervisorInfo::GetHWNDOutputPeak(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndOutputPeak;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDOutputPeak"
void CSupervisorInfo::SetHWNDOutputPeak(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndOutputPeak = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDInputVolumeSlider"
void CSupervisorInfo::GetHWNDInputVolumeSlider(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndInputVolumeSlider;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDInputVolumeSlider"
void CSupervisorInfo::SetHWNDInputVolumeSlider(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndInputVolumeSlider = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetInputVolumeSliderPos"
void CSupervisorInfo::GetInputVolumeSliderPos(LONG* lpl)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lpl = m_lInputVolumeSliderPos;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetInputVolumeSliderPos"
void CSupervisorInfo::SetInputVolumeSliderPos(LONG l)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_lInputVolumeSliderPos = l;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetHWNDOutputVolumeSlider"
void CSupervisorInfo::GetHWNDOutputVolumeSlider(HWND* lphwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphwnd = m_hwndOutputVolumeSlider;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetHWNDOutputVolumeSlider"
void CSupervisorInfo::SetHWNDOutputVolumeSlider(HWND hwnd)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hwndOutputVolumeSlider = hwnd;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetDPVC"
void CSupervisorInfo::GetDPVC(LPDIRECTPLAYVOICECLIENT* lplpdpvc)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lplpdpvc = m_lpdpvc;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetDPVC"
void CSupervisorInfo::SetDPVC(LPDIRECTPLAYVOICECLIENT lpdpvc)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_lpdpvc = lpdpvc;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetLoopbackShutdownEvent"
void CSupervisorInfo::GetLoopbackShutdownEvent(HANDLE* lphEvent)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lphEvent = m_hLoopbackShutdownEvent;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::SetLoopbackShutdownEvent"
void CSupervisorInfo::SetLoopbackShutdownEvent(HANDLE hEvent)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_hLoopbackShutdownEvent = hEvent;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetIPC"
void CSupervisorInfo::GetIPC(CSupervisorIPC** lplpsipc)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lplpsipc = &m_sipc;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetAbortFullDuplex"
void CSupervisorInfo::GetAbortFullDuplex(BOOL* lpfAbort)
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	*lpfAbort = m_fAbortFullDuplex;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::ClearAbortFullDuplex"
void CSupervisorInfo::ClearAbortFullDuplex()
{
	DPF_ENTER();
	DNEnterCriticalSection(&m_csLock);
	m_fAbortFullDuplex = FALSE;
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::InitIPC"
HRESULT CSupervisorInfo::InitIPC()
{
	DPF_ENTER();
	
	HRESULT hr;

	// the IPC object has it's own guard...
	hr = m_sipc.Init();
	
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::DeinitIPC"
HRESULT CSupervisorInfo::DeinitIPC()
{
	DPF_ENTER();
	
	HRESULT hr;

	// The IPC object has it's own guard...
	// and this is a safe call even if Init
	// has not been called
	hr = m_sipc.Deinit();
	
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::InitClass"
BOOL CSupervisorInfo::InitClass()
{
	if (DNInitializeCriticalSection(&m_csLock))
	{
		m_fCritSecInited = TRUE;
		return TRUE;
	}	
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "SupervisorCheckAudioSetup"
HRESULT SupervisorCheckAudioSetup(
	const GUID* lpguidRenderDevice,
	const GUID* lpguidCaptureDevice,
	HWND hwndParent,
	DWORD dwFlags)
{
	DPF_ENTER();
	
	HRESULT hr;
	LRESULT lRet;
	HKEY hkDevice = NULL;
	int iRet;
	CSupervisorInfo sinfo;
	CPeakMeterWndClass pmwc;
	BOOL fFullDuplexPassed;
	BOOL fVoiceDetected;
	BOOL fUserCancel;
	BOOL fUserBack;
	GUID guidCaptureDevice;
	GUID guidRenderDevice;
	BOOL fRegKeyOpen = FALSE;
	BOOL fWndClassRegistered = FALSE;
	BOOL fTitleFontCreated = FALSE;
	BOOL fBoldFontCreated = FALSE;
	BOOL fMutexOpen = FALSE;

	if (!sinfo.InitClass())
	{
		return DVERR_OUTOFMEMORY;
	}

	// init the globals
	g_hResDLLInstance = NULL;

	// validate the HWND, if non null
	if (hwndParent != NULL && !IsWindow(hwndParent))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Invalid (but non-null) Window Handle passed in CheckAudioSetup");
		hr = DVERR_INVALIDPARAM;
		goto error_cleanup;
	}

	// validate the flags
	if (dwFlags & ~(DVFLAGS_QUERYONLY|DVFLAGS_NOQUERY|DVFLAGS_WAVEIDS|DVFLAGS_ALLOWBACK))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Invalid flags specified in CheckAudioSetup: %x", dwFlags);
		hr = DVERR_INVALIDFLAGS;
		goto error_cleanup;
	}
	if (dwFlags & DVFLAGS_QUERYONLY)
	{
		if (dwFlags & (DVFLAGS_NOQUERY|DVFLAGS_ALLOWBACK))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "Invalid flags specified in CheckAudioSetup: %x", dwFlags);
			hr = DVERR_INVALIDFLAGS;
			goto error_cleanup;
		}
	}

	// save the flags
	sinfo.SetCheckAudioSetupFlags(dwFlags);

	// if the waveid flag was specified, translate the waveid to a guid
	if (dwFlags & DVFLAGS_WAVEIDS)
	{
		hr = DV_MapWaveIDToGUID( FALSE, lpguidRenderDevice->Data1, guidRenderDevice );
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DV_MapWaveIDToGUID failed, code: %i", hr);
			goto error_cleanup;
		}
		
		hr = DV_MapWaveIDToGUID( TRUE, lpguidCaptureDevice->Data1, guidCaptureDevice );
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DV_MapWaveIDToGUID failed, code: %i", hr);
			goto error_cleanup;
		}
	}
	else
	{
		hr = DV_MapPlaybackDevice(lpguidRenderDevice, &guidRenderDevice);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DV_MapPlaybackDevice failed, code: %i", hr);
			goto error_cleanup;
		}

		// map the devices
		hr = DV_MapCaptureDevice(lpguidCaptureDevice, &guidCaptureDevice);
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DV_MapCaptureDevice failed, code: %i", hr);
			goto error_cleanup;
		}
	}
	
	// the device guids have been mapped, if required, so save them
	sinfo.SetCaptureDevice(guidCaptureDevice);
	sinfo.SetRenderDevice(guidRenderDevice);

	// get the device descriptions, which also validates the GUIDs on
	// pre-millennium systems.
	hr = sinfo.GetDeviceDescriptions();
	if (FAILED(hr))
	{
		// error, log it and bail out of the wizard
		Diagnostics_Write(DVF_ERRORLEVEL, "Error getting device descriptions, code: %i", hr);
		goto error_cleanup;
	}

	// Open the registry key
	hr = sinfo.OpenRegKey(TRUE);
	if (FAILED(hr))
	{
		// error, log it and bail out of the wizard
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to open reg key, code: %i", hr);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	fRegKeyOpen = TRUE;
	
	if (dwFlags & DVFLAGS_QUERYONLY)
	{
		hr = SupervisorQueryAudioSetup(&sinfo);	
		sinfo.CloseRegKey();
		DPF_EXIT();
		return hr;
	}

	g_hResDLLInstance = LoadLibraryA(gc_szResDLLName);
	if (g_hResDLLInstance == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to get instance handle to resource dll: %s", gc_szResDLLName);
		Diagnostics_Write(DVF_ERRORLEVEL, "LoadLibrary error code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// check for other instances of the wizard
	hr = sinfo.ThereCanBeOnlyOne();
	if (FAILED(hr))
	{
		if (hr == DVERR_ALREADYPENDING)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "DirectPlay Voice Setup Wizard already running");
		}
		else
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "ThereCanBeOnlyOne failed, hr: %i", hr);
		}
		goto error_cleanup;
	}
	fMutexOpen = TRUE;
	
	// register the peak meter custom control window class
	hr = pmwc.Register();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CPeakMeterWndClass::Init failed, code: %i", hr);
		goto error_cleanup;
	}
	fWndClassRegistered = TRUE;

	// create the wizard header fonts
	hr = sinfo.CreateTitleFont();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateTitleFont failed");
		goto error_cleanup;
	}
	fTitleFontCreated = TRUE;
	hr = sinfo.CreateBoldFont();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateBoldFont failed");
		goto error_cleanup;
	}
	fBoldFontCreated = TRUE;

	// prepare the wizard pages
	PROPSHEETPAGE psp;
	HPROPSHEETPAGE rghpsp[10];
	PROPSHEETHEADER psh;

	// Welcome page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT; //|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = WelcomeProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_WELCOME);

	rghpsp[0] = CreatePropertySheetPage(&psp);
	if (rghpsp[0] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Full Duplex Test Page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT;//|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = FullDuplexProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_FULLDUPLEXTEST);

	rghpsp[1] = CreatePropertySheetPage(&psp);
	if (rghpsp[1] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Microphone Test Page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT; //|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = MicTestProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_MICTEST);

	rghpsp[2] = CreatePropertySheetPage(&psp);
	if (rghpsp[2] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Microphone Failed Page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT;//|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = MicTestFailedProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_MICTEST_FAILED);

	rghpsp[3] = CreatePropertySheetPage(&psp);
	if (rghpsp[3] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Speaker Test Page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT;//|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = SpeakerTestProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_SPEAKER_TEST);

	rghpsp[4] = CreatePropertySheetPage(&psp);
	if (rghpsp[4] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Wizard Complete Page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT;//|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = CompleteProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_COMPLETE);

	rghpsp[5] = CreatePropertySheetPage(&psp);
	if (rghpsp[5] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// half duplex failed page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
    psp.dwFlags = PSP_DEFAULT;//|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = HalfDuplexFailedProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_HALFDUPLEXFAILED);

	rghpsp[6] = CreatePropertySheetPage(&psp);
	if (rghpsp[6] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Full duplex failed page
	ZeroMemory(&psp, sizeof(psp));
//	psp.dwSize = sizeof(psp);
	psp.dwSize = PROPSHEETPAGE_STRUCT_SIZE;
	psp.dwFlags = PSP_DEFAULT;//|PSP_HIDEHEADER;
	psp.hInstance =	g_hResDLLInstance;
	psp.lParam = (LPARAM) &sinfo;
	psp.pfnDlgProc = FullDuplexFailedProc;
	psp.pszTemplate = MAKEINTRESOURCE(IDD_FULLDUPLEXFAILED);

	rghpsp[7] = CreatePropertySheetPage(&psp);
	if (rghpsp[7] == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreatePropertySheetPage failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Put it all together...
	ZeroMemory(&psh, sizeof(psh));
//	psh.dwSize = sizeof(psh);
    psh.dwSize = PROPSHEETHEAD_STRUCT_SIZE;
	psh.hInstance =	g_hResDLLInstance;
	psh.hwndParent = hwndParent;
	psh.phpage = rghpsp;
	psh.dwFlags = PSH_WIZARD;
	psh.nStartPage = 0;
	psh.nPages = 8;

	sinfo.SetError(DV_OK);
	iRet = (INT) PropertySheet(&psh);
	if (iRet == -1)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "PropertySheet failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hr = sinfo.DestroyBoldFont();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DestroyBoldFont failed");
		goto error_cleanup;
	}
	fBoldFontCreated = FALSE;
	
	hr = sinfo.DestroyTitleFont();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DestroyTitleFont failed");
		goto error_cleanup;
	}
	fTitleFontCreated = FALSE;

	// unregister the peak meter window class
	hr = pmwc.Unregister();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CPeakMeterWndClass::Deinit failed, code: %i", hr);
		goto error_cleanup;
	}
	fWndClassRegistered = FALSE;

 	if (!FreeLibrary(g_hResDLLInstance))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "FreeLibrary failed, code: %i", lRet);
		hr = DVERR_WIN32;
		goto error_cleanup;
	}
	g_hResDLLInstance = NULL;

	// see if an error occured
	sinfo.GetError(&hr);
	if (hr == DV_OK)
	{
		// nothing out of the ordinary happened,
		// so we'll return a cancel if the user
		// hit cancel, a "user back" if the user exited
		// the wizard by hitting back from the welcome
		// page, or the results from the registry otherwise.
		sinfo.GetUserCancel(&fUserCancel);
		sinfo.GetUserBack(&fUserBack);
		if (fUserCancel & fUserBack)
		{
			hr = DVERR_USERBACK;
		}
		else if(fUserCancel)
		{
			hr = DVERR_USERCANCEL;
		}
		else
		{
			// look in the registry for the test results
			hr = sinfo.QueryFullDuplex();

			// map a run setup result to a total failure
			if (hr == DVERR_RUNSETUP)
			{
				hr = DVERR_SOUNDINITFAILURE;
			}
		}
	}

	// close the mutex
	sinfo.CloseMutex();
	
	// close the registry key
	sinfo.CloseRegKey();

	DPF_EXIT();
	return hr;
	
error_cleanup:
	if (fBoldFontCreated == TRUE)
	{
		sinfo.DestroyBoldFont();
	}
	fBoldFontCreated = FALSE;

	if (fTitleFontCreated == TRUE)
	{
		sinfo.DestroyTitleFont();
	}
	fTitleFontCreated = FALSE;

	if (fWndClassRegistered == TRUE)
	{
		pmwc.Unregister();
	}
	fWndClassRegistered = FALSE;

	if (g_hResDLLInstance != NULL)
	{
		FreeLibrary(g_hResDLLInstance);
	}
	g_hResDLLInstance = NULL;

	if (fMutexOpen == TRUE)
	{
		sinfo.CloseMutex();
	}
	fMutexOpen = FALSE;

	if (fRegKeyOpen == TRUE)
	{
		sinfo.CloseRegKey();
	}
	fRegKeyOpen = FALSE;

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SupervisorQueryAudioSetup"
HRESULT SupervisorQueryAudioSetup(CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr;

	// will return DV_HALFDUPLEX, DV_FULLDUPLEX, DVERR_SOUNDINITFAILURE or a real error
	hr = psinfo->QueryFullDuplex();
	if (FAILED(hr) && hr != DVERR_SOUNDINITFAILURE && hr != DVERR_RUNSETUP)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "QueryFullDuplex failed, code: %i", hr);
	}
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CreateTitleFont"
HRESULT CSupervisorInfo::CreateTitleFont()
{
	DPF_ENTER();
	
	LONG lRet;
	HRESULT hr;
	HFONT hfTitle = NULL;
	INT iFontSize;
	LOGFONT lfTitle;
	HDC hdc = NULL;
	NONCLIENTMETRICS ncm;

	DNEnterCriticalSection(&m_csLock);
	
	// Set up the font for the titles on the intro and ending pages
	ZeroMemory(&ncm, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "SystemParametersInfo failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Create the intro/end title font
	lfTitle = ncm.lfMessageFont;
	lfTitle.lfWeight = FW_BOLD;
	lstrcpy(lfTitle.lfFaceName, TEXT("MS Shell Dlg"));

	hdc = GetDC(NULL); //gets the screen DC
	if (hdc == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDC failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	iFontSize = 12;
	lfTitle.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * iFontSize / 72;
	
	hfTitle = CreateFontIndirect(&lfTitle);
	if (hfTitle == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateFontIndirect failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	if (ReleaseDC(NULL, hdc) != 1)
	{
		hdc = NULL;
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "ReleaseDC failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// save the font
	m_hfTitle = hfTitle;

	DNLeaveCriticalSection(&m_csLock);
	
	DPF_EXIT();
	return DV_OK;

error_cleanup:

	if (hfTitle != NULL)
	{
		DeleteObject(hfTitle);
	}
	hfTitle = NULL;
	
	if (hdc != NULL)
	{
		ReleaseDC(NULL, hdc);
	}
	hdc = NULL;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::DestroyTitleFont"
HRESULT CSupervisorInfo::DestroyTitleFont()
{
	DPF_ENTER();
	
	HFONT hTitleFont;
	LONG lRet;
	HRESULT hr;

	DNEnterCriticalSection(&m_csLock);

	if (m_hfTitle == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "m_hTitleFont is Null");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	if (!DeleteObject(m_hfTitle))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "DeleteObject failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CreateBoldFont"
HRESULT CSupervisorInfo::CreateBoldFont()
{
	DPF_ENTER();
	
	LONG lRet;
	HRESULT hr;
	HFONT hfBold = NULL;
	INT iFontSize;
	LOGFONT lfBold;
	HDC hdc = NULL;
	NONCLIENTMETRICS ncm;

	DNEnterCriticalSection(&m_csLock);
	
	// Set up the font for the titles on the intro and ending pages
	ZeroMemory(&ncm, sizeof(ncm));
	ncm.cbSize = sizeof(ncm);
	if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "SystemParametersInfo failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Create the intro/end title font
	lfBold = ncm.lfMessageFont;
	lfBold.lfWeight = FW_BOLD;
	lstrcpy(lfBold.lfFaceName, TEXT("MS Shell Dlg"));

	hdc = GetDC(NULL); //gets the screen DC
	if (hdc == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDC failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	iFontSize = 8;
	lfBold.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * iFontSize / 72;
	
	hfBold = CreateFontIndirect(&lfBold);
	if (hfBold == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateFontIndirect failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	if (ReleaseDC(NULL, hdc) != 1)
	{
		hdc = NULL;
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "ReleaseDC failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// save the font
	m_hfBold = hfBold;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	if (hdc != NULL)
	{
		ReleaseDC(NULL, hdc);
	}
	hdc = NULL;

	if (hfBold != NULL)
	{
		DeleteObject(hfBold);
	}
	hfBold = NULL;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::DestroyBoldFont"
HRESULT CSupervisorInfo::DestroyBoldFont()
{
	DPF_ENTER();
	
	HFONT hTitleFont;
	LONG lRet;
	HRESULT hr;

	DNEnterCriticalSection(&m_csLock);

	if (m_hfBold == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "m_hTitleFont is Null");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	if (!DeleteObject(m_hfBold))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "DeleteObject failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	m_hfBold = NULL;

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::Unmute"
HRESULT CSupervisorInfo::Unmute()
{
	DPF_ENTER();
	
	LONG lRet;
	HRESULT hr;
	DVCLIENTCONFIG dvcc;

	DNEnterCriticalSection(&m_csLock);

	if (m_lpdpvc == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "NULL IDirectPlayVoiceClient");
		hr = DVERR_INVALIDPARAM;
		goto error_cleanup;
	}

	dvcc.dwSize = sizeof(dvcc);
	hr = m_lpdpvc->GetClientConfig(&dvcc);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "IDirectPlayVoiceClient::GetClientConfig failed, hr: %i", hr);
		goto error_cleanup;
	}
	
	dvcc.dwFlags &= (~DVCLIENTCONFIG_PLAYBACKMUTE);
	
	m_lpdpvc->SetClientConfig(&dvcc);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "IDirectPlayVoiceClient::SetClientConfig failed, hr: %i", hr);
		goto error_cleanup;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::Mute"
HRESULT CSupervisorInfo::Mute()
{
	DPF_ENTER();
	
	LONG lRet;
	HRESULT hr;
	DVCLIENTCONFIG dvcc;

	DNEnterCriticalSection(&m_csLock);

	if (m_lpdpvc == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "NULL IDirectPlayVoiceClient");
		hr = DVERR_INVALIDPARAM;
		goto error_cleanup;
	}

	dvcc.dwSize = sizeof(dvcc);
	hr = m_lpdpvc->GetClientConfig(&dvcc);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "IDirectPlayVoiceClient::GetClientConfig failed, hr: %i", hr);
		goto error_cleanup;
	}
	
	dvcc.dwFlags |= DVCLIENTCONFIG_PLAYBACKMUTE;
	
	m_lpdpvc->SetClientConfig(&dvcc);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "IDirectPlayVoiceClient::SetClientConfig failed, hr: %i", hr);
		goto error_cleanup;
	}

	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::DSEnumCallback"
BOOL CALLBACK CSupervisorInfo::DSEnumCallback(
	LPGUID lpGuid, 
	LPCTSTR lpcstrDescription, 
	LPCTSTR lpcstrModule,
	LPVOID lpContext)
{
	DNASSERT(lpContext);
	CSupervisorInfo* psinfo = (CSupervisorInfo*)lpContext;

	if (lpGuid)
	{
		if (psinfo->m_guidRenderDevice == *lpGuid)
		{
			// matching guid, copy the description
			_tcsncpy(psinfo->m_szRenderDeviceDesc, lpcstrDescription, MAX_DEVICE_DESC_LEN-1);

			// all done, stop enum
			return FALSE;
		}
	}
	
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::DSCEnumCallback"
BOOL CALLBACK CSupervisorInfo::DSCEnumCallback(
	LPGUID lpGuid, 
	LPCTSTR lpcstrDescription, 
	LPCTSTR lpcstrModule,
	LPVOID lpContext)
{
	DNASSERT(lpContext);
	CSupervisorInfo* psinfo = (CSupervisorInfo*)lpContext;

	if (lpGuid)
	{
		if (psinfo->m_guidCaptureDevice == *lpGuid)
		{
			// matching guid, copy the description
			_tcsncpy(psinfo->m_szCaptureDeviceDesc, lpcstrDescription, MAX_DEVICE_DESC_LEN-1);

			// all done, stop enum
			return FALSE;
		}
	}
	
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::GetDeviceDescriptions"
HRESULT CSupervisorInfo::GetDeviceDescriptions()
{
	DPF_ENTER();

	HRESULT hr;
	TDirectSoundEnumFnc fpDSEnum;
	TDirectSoundEnumFnc fpDSCEnum;
	
	DNEnterCriticalSection(&m_csLock);

	ZeroMemory(m_szRenderDeviceDesc, MAX_DEVICE_DESC_LEN);
	ZeroMemory(m_szCaptureDeviceDesc, MAX_DEVICE_DESC_LEN);

	HINSTANCE hDSound = LoadLibrary(_T("dsound.dll"));
	if (hDSound == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Error loading dsound.dll");
		hr = DVERR_SOUNDINITFAILURE;
		goto error_cleanup;
	}

#ifdef UNICODE
	fpDSEnum = (TDirectSoundEnumFnc)GetProcAddress(hDSound, "DirectSoundEnumerateW");
#else
	fpDSEnum = (TDirectSoundEnumFnc)GetProcAddress(hDSound, "DirectSoundEnumerateA");
#endif
	if (fpDSEnum == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetProcAddress failed for DirectSoundEnumerateW");
		hr = DVERR_SOUNDINITFAILURE;
		goto error_cleanup;
	}

#ifdef UNICODE
	fpDSCEnum = (TDirectSoundEnumFnc)GetProcAddress(hDSound, "DirectSoundCaptureEnumerateW");
#else
	fpDSCEnum = (TDirectSoundEnumFnc)GetProcAddress(hDSound, "DirectSoundCaptureEnumerateA");
#endif

	if (fpDSCEnum == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetProcAddress failed for DirectSoundCaptureEnumerateW");
		hr = DVERR_SOUNDINITFAILURE;
		goto error_cleanup;
	}

	hr = fpDSEnum(DSEnumCallback, (LPVOID)this);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DirectSoundEnumerate failed, code: %i, assuming bad guid", hr);
		hr = DVERR_INVALIDDEVICE;
		goto error_cleanup;
	}
	if (m_szRenderDeviceDesc[0] == NULL)
	{
		// the device wasn't found!
		Diagnostics_Write(DVF_ERRORLEVEL, "Render device not found");
		hr = DVERR_INVALIDDEVICE;
		goto error_cleanup;
	}

	hr = fpDSCEnum(DSCEnumCallback, (LPVOID)this);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DirectSoundCaptureEnumerate failed, code: %i, assuming bad guid", hr);
		hr = DVERR_INVALIDDEVICE;
		goto error_cleanup;
	}
	if (m_szCaptureDeviceDesc[0] == NULL)
	{
		// the device wasn't found!
		Diagnostics_Write(DVF_ERRORLEVEL, "Capture device not found");
		hr = DVERR_INVALIDDEVICE;
		goto error_cleanup;
	}

	FreeLibrary( hDSound );
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return DV_OK;

error_cleanup:

    if( hDSound != NULL )
    {
    	FreeLibrary( hDSound );        
    }
    
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CloseRegKey"
HRESULT CSupervisorInfo::CloseRegKey()
{
	DPF_ENTER();
	
	LONG lRet;
	HRESULT hr;
	
	DNEnterCriticalSection(&m_csLock);

	if (!m_creg.Close())
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CRegistry::Close failed");
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return S_OK;

error_cleanup:
	DNLeaveCriticalSection(&m_csLock);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexTestThreadProc"
DWORD WINAPI FullDuplexTestThreadProc(LPVOID lpvParam)
{
	DPF_ENTER();
	
	CSupervisorInfo* lpsinfo;
	CSupervisorIPC* lpipcSupervisor;
	LPGUID lpguidRenderDevice;
	LPGUID lpguidCaptureDevice;
	HKEY hkDevice;
	HRESULT hr;
	LONG lRet;
	HWND hwnd;

	lpsinfo = (CSupervisorInfo*)lpvParam;

	lpsinfo->GetHWNDDialog(&hwnd);

	hr = RunFullDuplexTest(lpsinfo);

	// post a message to the wizard so it knows we're done, but
	// only if this was not a user cancel, since the wizard will
	// already be waiting on the thread object
	if (hr != DVERR_USERCANCEL)
	{
		if (!PostMessage(hwnd, WM_APP_FULLDUP_TEST_COMPLETE, 0, (LPARAM)hr))
		{
			lRet = GetLastError();
			Diagnostics_Write(DVF_ERRORLEVEL, "PostMessage failed, code: %i", lRet);
			hr = DVERR_GENERIC;
		}
	}

	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "RunFullDuplexTest"
static HRESULT RunFullDuplexTest(CSupervisorInfo* lpsinfo)
{
	DPF_ENTER();
	
	HRESULT hr;
	HRESULT hrFnc;
	CSupervisorIPC* lpsipc;
	
	lpsinfo->GetIPC(&lpsipc);

	hr = lpsipc->StartPriorityProcess();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StartPriorityProcess failed, hr: %i", hr);
		goto error_cleanup;
	}
	
	hr = lpsipc->StartFullDuplexProcess();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StartFullDuplexProcess failed, hr: %i", hr);
		goto error_cleanup;
	}

	hrFnc = DoTests(lpsinfo);

	hr = lpsipc->WaitOnChildren();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "WaitOnChildren failed, code: %i", hr);
		goto error_cleanup;
	}
	
	DPF_EXIT();
	return hrFnc;

error_cleanup:
	// this function is safe to call, even if the child processes have not 
	// been created
	lpsipc->TerminateChildProcesses();
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::CrashCheckIn"
HRESULT CSupervisorInfo::CrashCheckIn()
{
	DPF_ENTER();

	LONG lRet;
	BOOL fRet;
	DWORD dwRegVal;
	HRESULT hrFnc;
	HRESULT hr;
	HKEY hk;

	// Each of the following three functions take the critical section,
	// so there is no need to take it here.

	// Check each of the test results to see if any tests
	// crashed.
	hr = GetHalfDuplex(&dwRegVal);
	if (!FAILED(hr) && dwRegVal == REGVAL_CRASHED)
	{
		// The half duplex test crashed.
		Diagnostics_Write(DVF_ERRORLEVEL, "Previous half duplex test crashed");
		hrFnc = DVERR_PREVIOUSCRASH;
		goto error_cleanup;
	}

	hr = GetFullDuplex(&dwRegVal);
	if (!FAILED(hr) && dwRegVal == REGVAL_CRASHED)
	{
		// The full duplex test crashed.
		Diagnostics_Write(DVF_ERRORLEVEL, "Previous full duplex test crashed");
		hrFnc = DVERR_PREVIOUSCRASH;
		goto error_cleanup;
	}

	hr = GetMicDetected(&dwRegVal);
	if (!FAILED(hr) && dwRegVal == REGVAL_CRASHED)
	{
		// The mic test crashed.
		Diagnostics_Write(DVF_ERRORLEVEL, "Previous mic test crashed");
		hrFnc = DVERR_PREVIOUSCRASH;
		goto error_cleanup;
	}

	DPF_EXIT();
	return DV_OK;

// error block
error_cleanup:
	DPF_EXIT();
	return hrFnc;		
}

#undef DPF_MODNAME
#define DPF_MODNAME "DoTests"
HRESULT DoTests(CSupervisorInfo* lpsinfo)
{

	DPF_ENTER();
	
	LONG lRet;
	DWORD dwRet;
	HANDLE rghEvents[2];
	HRESULT hr;
	HRESULT hrFnc;
	CSupervisorIPC* lpsipc;

	lpsinfo->GetIPC(&lpsipc);

	// wait until the child processes are ready to go...
	hr = lpsipc->WaitForStartupSignals();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "WaitForStartupSignals failed, hr: %i", hr);
		goto error_cleanup;
	}

	// child processes are all set, tell them what to do
	// Note: this function has only four expected return codes
	// DV_FULLDUPLEX - all tests passed
	// DV_HALFDUPLEX - all half duplex tests passed, full duplex tests failed
	// DVERR_SOUNDINITFAILURE - half duplex tests failed
	// DVERR_USERCANCEL - tests canceled by user
	hrFnc = IssueCommands(lpsinfo);
	if (FAILED(hrFnc) 
		&& hrFnc != DVERR_SOUNDINITFAILURE 
		&& hrFnc != DVERR_USERCANCEL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "IssueCommands failed, hr: %i", hrFnc);
		hr = hrFnc;
		goto error_cleanup;
	}

	// now tell the child processes to shut down
	hr = IssueShutdownCommand(lpsipc);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "IssueShutdownCommand failed, code: %i", hr);
		// Note we're not bailing out. We have our test results, so this is
		// a problem somewhere in the wizard code. Return the result
		// from the actual test.
	}
	
	DPF_EXIT();
	return hrFnc;

error_cleanup:
	// attempt to gracefully shutdown child processes.
	IssueShutdownCommand(lpsipc);
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IssueCommands"
HRESULT IssueCommands(CSupervisorInfo* lpsinfo)
{
	// Note: this function has only four possible return codes
	// DV_FULLDUPLEX - all tests passed
	// DV_HALFDUPLEX - all half duplex tests passed, full duplex tests failed
	// DVERR_SOUNDINITFAILURE - half duplex tests failed
	// DVERR_USERCANCEL - tests canceled by user
	DPF_ENTER();
	
	HRESULT hr;
	DWORD dwIndex1;
	DWORD dwIndex2;
	BOOL fAbort = FALSE;
	BOOL fPassed;

	// First do a pass testing that we can run in 
	// half duplex without error.	
	// Set the half duplex key to crash state
	lpsinfo->SetHalfDuplex(REGVAL_CRASHED);
	dwIndex1 = 0;
	fPassed = FALSE;
	while (1)
	{
		if (gc_rgwfxPrimaryFormats[dwIndex1].wFormatTag == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nChannels == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nSamplesPerSec == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nAvgBytesPerSec == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nBlockAlign == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].wBitsPerSample == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].cbSize == 0)
		{
			// we've found the last element of the array, break out.
			fPassed = TRUE;
			break;
		}

		lpsinfo->GetAbortFullDuplex(&fAbort);
		if (fAbort)
		{
			// abort the tests
			break;
		}

		hr = lpsinfo->TestCase(&gc_rgwfxPrimaryFormats[dwIndex1], DVSOUNDCONFIG_HALFDUPLEX|DVSOUNDCONFIG_TESTMODE);
		if (hr != DV_HALFDUPLEX)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "Half duplex test case not supported hr = 0x%x", hr);
			break;
		}
		++dwIndex1;

		// Why is this here?  Because DSOUND doesn't like you to open/close quickly.
		Sleep( 200 );
	}

	if (fAbort)
	{
		// The user aborted the tests, make it like they were never run.
		lpsinfo->SetHalfDuplex(REGVAL_NOTRUN);
		DPF_EXIT();
		return DVERR_USERCANCEL;
	}

	// Record the results of the half duplex test in the registry,
	// and decide what to do next.
	if (fPassed)
	{
		lpsinfo->SetHalfDuplex(REGVAL_PASSED);
		// continue on with the full duplex test.
	}
	else
	{
		lpsinfo->SetHalfDuplex(REGVAL_FAILED);
		// we failed the half duplex test, we're done.
		DPF_EXIT();
		// map all failures at this point to sound problems.
		return DVERR_SOUNDINITFAILURE;
	}

	// Now that we're finished testing in half duplex mode,
	// we can move on to the full duplex testing.
	lpsinfo->SetFullDuplex(REGVAL_CRASHED);
	fPassed = FALSE;
	dwIndex1 = 0;
	while (1)
	{
		if (gc_rgwfxPrimaryFormats[dwIndex1].wFormatTag == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nChannels == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nSamplesPerSec == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nAvgBytesPerSec == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].nBlockAlign == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].wBitsPerSample == 0
			&& gc_rgwfxPrimaryFormats[dwIndex1].cbSize == 0)
		{
			// we've found the last element of the array, break out.
			fPassed = TRUE;
			break;
		}

		lpsinfo->GetAbortFullDuplex(&fAbort);
		if (fAbort)
		{
			// abort the tests
			break;
		}

		hr = lpsinfo->TestCase(&gc_rgwfxPrimaryFormats[dwIndex1], DVSOUNDCONFIG_TESTMODE);
		if (hr != DV_FULLDUPLEX)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "Full duplex test case not supported. hr = 0x%x", hr);
			break;
		}
		++dwIndex1;

		// Why is this here?  Because DSOUND doesn't like you to open/close quickly.
		Sleep( 200 );
	}

	if (fAbort)
	{
		// The user aborted the tests, make it like they were never run.
		lpsinfo->SetFullDuplex(REGVAL_NOTRUN);
		DPF_EXIT();
		return DVERR_USERCANCEL;
	}

	// Record the results of the full duplex test in the registry,
	// and return the appropriate code.
	if (fPassed)
	{
		lpsinfo->SetFullDuplex(REGVAL_PASSED);
		DPF_EXIT();
		return DV_FULLDUPLEX;
	}
	else
	{
		lpsinfo->SetFullDuplex(REGVAL_FAILED);
		DPF_EXIT();
		return DV_HALFDUPLEX;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSupervisorInfo::TestCase"
HRESULT CSupervisorInfo::TestCase(const WAVEFORMATEX* lpwfxPrimary, DWORD dwFlags)
{
	DPF_ENTER();
	HRESULT hr = DV_OK;
	HRESULT hrFnc = DV_OK;
	SFDTestCommand fdtc;

	// tell the priority process to go
	ZeroMemory(&fdtc, sizeof(fdtc));
	fdtc.dwSize = sizeof(fdtc);
	fdtc.fdtcc = fdtccPriorityStart;
	fdtc.fdtu.fdtcPriorityStart.guidRenderDevice = m_guidRenderDevice;
	fdtc.fdtu.fdtcPriorityStart.wfxRenderFormat = *lpwfxPrimary;
	fdtc.fdtu.fdtcPriorityStart.wfxSecondaryFormat = gc_wfxSecondaryFormat;	
	fdtc.fdtu.fdtcPriorityStart.hwndWizard = m_hwndWizard;
	fdtc.fdtu.fdtcPriorityStart.hwndProgress = m_hwndProgress;
	hr = m_sipc.SendToPriority(&fdtc);
	if (FAILED(hr))
	{
		DPF_EXIT();
		return hr;
	}

	// tell the full duplex process to attempt full duplex
	ZeroMemory(&fdtc, sizeof(fdtc));
	fdtc.dwSize = sizeof(fdtc);
	fdtc.fdtcc = fdtccFullDuplexStart;
	fdtc.fdtu.fdtcFullDuplexStart.guidRenderDevice = m_guidRenderDevice;
	fdtc.fdtu.fdtcFullDuplexStart.guidCaptureDevice = m_guidCaptureDevice;
	fdtc.fdtu.fdtcFullDuplexStart.dwFlags = dwFlags;
	hrFnc = m_sipc.SendToFullDuplex(&fdtc);
	if (FAILED(hrFnc))
	{
		// The full duplex process was unable to do it.
		// tell the priority process to stop and get out.
		ZeroMemory(&fdtc, sizeof(fdtc));
		fdtc.dwSize = sizeof(fdtc);
		fdtc.fdtcc = fdtccPriorityStop;
		m_sipc.SendToPriority(&fdtc);
		DPF_EXIT();
		return hrFnc;
	}

	// Wait for a half second before we shut it down.
	// This gives it the time required for the sound system
	// to detect a lockup if it is going to.
	Sleep(1000);
	
	// The full duplex process was ok, till now. Try to 
	// shut it down.
	ZeroMemory(&fdtc, sizeof(fdtc));
	fdtc.dwSize = sizeof(fdtc);
	fdtc.fdtcc = fdtccFullDuplexStop;
	hr = m_sipc.SendToFullDuplex(&fdtc);
	if (FAILED(hr))
	{
		// It looks like the full duplex wasn't quite up to stuff
		// after all. Tell the priority process to shut down
		ZeroMemory(&fdtc, sizeof(fdtc));
		fdtc.dwSize = sizeof(fdtc);
		fdtc.fdtcc = fdtccPriorityStop;
		m_sipc.SendToPriority(&fdtc);
		DPF_EXIT();
		return hr;
	}

	// All is well, up to now, one last hurdle...
	ZeroMemory(&fdtc, sizeof(fdtc));
	fdtc.dwSize = sizeof(fdtc);
	fdtc.fdtcc = fdtccPriorityStop;
	hr = m_sipc.SendToPriority(&fdtc);
	if (FAILED(hr))
	{
		DPF_EXIT();
		return hr;
	}

	// you have graduated from full duplex class...
	DPF_EXIT();
	return hrFnc;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IssueShutdownCommand"
HRESULT IssueShutdownCommand(CSupervisorIPC* lpipcSupervisor)
{
	SFDTestCommand fdtc;
	HRESULT hr;

	DPF_EXIT();

	fdtc.dwSize = sizeof(fdtc);
	fdtc.fdtcc = fdtccExit;

	hr = lpipcSupervisor->SendToFullDuplex(&fdtc);
	if (FAILED(hr))
	{
		lpipcSupervisor->SendToPriority(&fdtc);
		DPF_EXIT();
		return hr;
	}

	hr = lpipcSupervisor->SendToPriority(&fdtc);
	if (FAILED(hr))
	{
		DPF_EXIT();
		return hr;
	}

	DPF_EXIT();
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WelcomeProc"
INT_PTR CALLBACK WelcomeProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;

	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		fRet = WelcomeInitDialogHandler(hDlg, message, wParam, lParam, psinfo); 
		break;

	case WM_NOTIFY :
		{
		LPNMHDR lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
			{
			case PSN_SETACTIVE : 
				// Enable the Next button	 
				fRet = WelcomeSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
				break;

			case PSN_WIZBACK :
				// Back button clicked
				fRet = WelcomeBackHandler(hDlg, message, wParam, lParam, psinfo);
				break;

			case PSN_WIZNEXT :
				// Next button clicked
				fRet = WelcomeNextHandler(hDlg, message, wParam, lParam, psinfo);
				break;

			case PSN_RESET :
				fRet = WelcomeResetHandler(hDlg, message, wParam, lParam, psinfo);
				break;

			default :
				break;
			}
		}
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WelcomeInitDialogHandler"
BOOL WelcomeInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HWND hwndControl;
	HWND hwndWizard = NULL;
	LONG lRet;
	HFONT hfTitle;
	HICON hIcon;
	HRESULT hr = DV_OK;
	HWND hwndParent = NULL;
	
	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// It's an intro/end page, so get the title font
	// from the shared data and use it for the title control
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetTitleFont(&hfTitle);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfTitle, (LPARAM)TRUE);
	
	// load the warning icon
	//hIcon = LoadIcon(NULL, IDI_INFORMATION);
	//SendDlgItemMessage(hDlg, IDC_WARNINGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

	// set the device descriptions
	SendDlgItemMessage(hDlg, IDC_TEXT_PLAYBACK, WM_SETTEXT, 0, (LPARAM)psinfo->GetRenderDesc());
	SendDlgItemMessage(hDlg, IDC_TEXT_RECORDING, WM_SETTEXT, 0, (LPARAM)psinfo->GetCaptureDesc());

	// reset the welcome next flag
	psinfo->ClearWelcomeNext();

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WelcomeSetActiveHandler"
BOOL WelcomeSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	HWND hwndParent;
	HWND hwndWizard;
	LONG lRet;
	DWORD dwFlags;
	HRESULT hr;

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		// log it, and return, don't know how to terminate the wizard properly
		// without this handle!
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(NULL);
	psinfo->SetHWNDOutputPeak(NULL);
	psinfo->SetHWNDInputVolumeSlider(NULL);
	psinfo->SetHWNDOutputVolumeSlider(NULL);

	// set the appropriate wizard buttons as active.
	psinfo->GetCheckAudioSetupFlags(&dwFlags);
	if (dwFlags & DVFLAGS_ALLOWBACK)
	{
		PropSheet_SetWizButtons(hwndWizard, PSWIZB_NEXT|PSWIZB_BACK);
	}
	else
	{
		PropSheet_SetWizButtons(hwndWizard, PSWIZB_NEXT);
	}

	// reset the user cancel and user back flags
	psinfo->ClearUserCancel();
	psinfo->ClearUserBack();

	DPF_EXIT();
	return FALSE;

// error block
error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WelcomeBackHandler"
BOOL WelcomeBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HWND hwndWizard = NULL;
	HRESULT hr = DV_OK;
	LPGUID lpguidCaptureDevice;
	LPGUID lpguidRenderDevice;
	HKEY hkey;
	LONG lRet;
	DWORD dwErr;
	DWORD dwRegVal;

	// Get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);
	
	// The back button was hit on the welcome page. Exit the wizard with the appropriate error code.
	psinfo->SetUserBack();
	PropSheet_PressButton(hwndWizard, PSBTN_CANCEL);

	// no previous crashes (or the user is boldly charging ahead anyway), 
	// so go to the full duplex test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXTEST);
	DPF_EXIT();
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WelcomeNextHandler"
BOOL WelcomeNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HWND hwndWizard = NULL;
	HRESULT hr = DV_OK;
	LPGUID lpguidCaptureDevice;
	LPGUID lpguidRenderDevice;
	HKEY hkey;
	LONG lRet;
	DWORD dwErr;
	DWORD dwRegVal;
	HWND hwndParent = NULL;

	// Get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);
	
	// The next button was hit on the welcome page. Do all the basic init tasks.

	// check for previous crashes
	hr = psinfo->CrashCheckIn();
	if (FAILED(hr))
	{
		if (hr == DVERR_PREVIOUSCRASH)
		{
			// the previous test crashed out, display the warning.
			Diagnostics_Write(DVF_ERRORLEVEL, "DirectPlay Voice Setup Wizard detected previous full duplex test crashed");
			int iRet = (INT) DialogBox(g_hResDLLInstance, MAKEINTRESOURCE(IDD_PREVIOUS_CRASH), hDlg, PreviousCrashProc);
			switch (iRet)
			{
			case IDOK:
				// the previous test crashed, but the user wants to continue
				// anyway, so move along...
				Diagnostics_Write(DVF_ERRORLEVEL, "User choosing to ignore previous failure");
				break;
				
			case IDCANCEL:
				// the previous test crashed, and the user is wisely choosing
				// to bail out. Go to either the full duplex failed page, or the
				// half duplex failed page, depending on the registry state.
				Diagnostics_Write(DVF_ERRORLEVEL, "User choosing not to run test");
				hr = psinfo->GetHalfDuplex(&dwRegVal);
				if (!FAILED(hr) && dwRegVal == REGVAL_PASSED)
				{
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXFAILED);
				}
				else
				{
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_HALFDUPLEXFAILED);
				}
				return TRUE;
				break;
				
			default:
				// this is an error
				Diagnostics_Write(DVF_ERRORLEVEL, "DialogBox failed");
				hr = DVERR_GENERIC;
				goto error_cleanup;
			}
		}
		else 
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "CrashCheckIn failed, code: %i", hr);
			goto error_cleanup;
		}
	}

	// no previous crashes (or the user is boldly charging ahead anyway), 
	// so go to the full duplex test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXTEST);
	DPF_EXIT();
	return TRUE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "WelcomeResetHandler"
BOOL WelcomeResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr;
	HWND hwndWizard;

	// disable all buttons
	psinfo->GetHWNDWizard(&hwndWizard);
	PropSheet_SetWizButtons(hwndWizard, 0);

	psinfo->Cancel();
	
	DPF_EXIT();
	return FALSE;
}

/*
#undef DPF_MODNAME
#define DPF_MODNAME "AlreadyRunningProc"
INT_PTR CALLBACK AlreadyRunningProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	HICON hIcon;

	switch (message)
	{
	case WM_INITDIALOG :
		hIcon = LoadIcon(NULL, IDI_ERROR);
		SendDlgItemMessage(hDlg, IDC_ICON_ERROR, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			return TRUE;

		default:
			break;
		}
		break;


	default:
		break;
	}
	
	DPF_EXIT();
	return FALSE;
}
*/

#undef DPF_MODNAME
#define DPF_MODNAME "PreviousCrashProc"
INT_PTR CALLBACK PreviousCrashProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LPNMHDR lpnm;
	HICON hIcon;

	Diagnostics_Write(DVF_ERRORLEVEL, "Previous run crashed");

	switch (message)
	{
	case WM_INITDIALOG :
		PlaySound( _T("SystemExclamation"), NULL, SND_ASYNC );					
		hIcon = LoadIcon(NULL, IDI_WARNING);
		SendDlgItemMessage(hDlg, IDC_ICON_WARNING, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hDlg, LOWORD(wParam));
			return(TRUE);
			break;

		default:
			break;
		}
		break;
		
	default:
		break;
	}
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexProc"
INT_PTR CALLBACK FullDuplexProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LONG lRet;
	BOOL fRet;
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		FullDuplexInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = FullDuplexSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZBACK :
			fRet = FullDuplexBackHandler(hDlg, message, wParam, lParam, psinfo);
			break;
			
		case PSN_WIZNEXT :
			fRet = FullDuplexNextHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_RESET :
			fRet = FullDuplexResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default :
			break;
		}
		break;

	case WM_APP_FULLDUP_TEST_COMPLETE:
		fRet = FullDuplexCompleteHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	default:
		break;
	}
	
	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexInitDialogHandler"
BOOL FullDuplexInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfBold;
	HRESULT hr = DV_OK;
	
	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetBoldFont(&hfBold);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfBold, (LPARAM)TRUE);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexSetActiveHandler"
BOOL FullDuplexSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndProgress;
	HWND hwndCancelButton;
	HANDLE hThread;
	DWORD dwThreadId;
	WORD wCount;
	HRESULT hr = DV_OK;

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// reset all the test registry bits
	psinfo->SetHalfDuplex(REGVAL_NOTRUN);
	psinfo->SetFullDuplex(REGVAL_NOTRUN);
	psinfo->SetMicDetected(REGVAL_NOTRUN);

	// remember that we've been here, so we'll know to reset the registry
	// if the user hits cancel from this point forward
	psinfo->SetWelcomeNext();

	// get the progress bar's HWND
	hwndProgress = GetDlgItem(hDlg, IDC_PROGRESSBAR);
	if (hwndProgress == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Init the progress bar...
	
	// count the number of elements in the primary format array
	wCount = 0;
	while (1)
	{
		// Increment before we test. This means that if there
		// are four formats, wCount will equal five after this
		// loop.
		++wCount;
		if (gc_rgwfxPrimaryFormats[wCount].wFormatTag == 0
			&& gc_rgwfxPrimaryFormats[wCount].nChannels == 0
			&& gc_rgwfxPrimaryFormats[wCount].nSamplesPerSec == 0
			&& gc_rgwfxPrimaryFormats[wCount].nAvgBytesPerSec == 0
			&& gc_rgwfxPrimaryFormats[wCount].nBlockAlign == 0
			&& gc_rgwfxPrimaryFormats[wCount].wBitsPerSample == 0
			&& gc_rgwfxPrimaryFormats[wCount].cbSize == 0)
		{
			// we've found the last element of the array, break out.
			break;
		}
	}

	// set up the progress bar with one segment for each
	// primary format, times two, since each is tested in
	// both half and full duplex.
	SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, wCount*2));
	SendMessage(hwndProgress, PBM_SETPOS, 0, 0);
	SendMessage(hwndProgress, PBM_SETSTEP, 1, 0);

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(hwndProgress);
	psinfo->SetHWNDInputPeak(NULL);
	psinfo->SetHWNDOutputPeak(NULL);
	psinfo->SetHWNDInputVolumeSlider(NULL);
	psinfo->SetHWNDOutputVolumeSlider(NULL);

	// clear the abort flag!
	psinfo->ClearAbortFullDuplex();

	// enable the Back button only
	PropSheet_SetWizButtons(hwndWizard, PSWIZB_BACK);

	// init IPC stuff
	hr = psinfo->InitIPC();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to Initialize IPC");
		goto error_cleanup;
	}

	// Fire up the full duplex test thread
	hr = psinfo->CreateFullDuplexThread();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateFullDuplexThread failed, code: %i", hr);
		goto error_cleanup;
	}

	DPF_EXIT();
	return FALSE;

error_cleanup:
    
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexNextHandler"
BOOL FullDuplexNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	BOOL fPassed;
	HRESULT hr;
	HWND hwndWizard;
	HWND hwndParent = NULL;

	psinfo->GetFullDuplexResults(&hr);

	switch (hr)
	{
	case DV_HALFDUPLEX:
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXFAILED);
		Diagnostics_Write(DVF_ERRORLEVEL, "Test resulted in full duplex");
		break;
		
	case DV_FULLDUPLEX:
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_MICTEST);
		Diagnostics_Write(DVF_ERRORLEVEL, "Test resulted in full duplex");
		break;

	case DVERR_SOUNDINITFAILURE:
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_HALFDUPLEXFAILED);
		Diagnostics_Write(DVF_ERRORLEVEL, "Test encountered unrecoverable error");
		break;

	default:
		// we should not get any other result
		Diagnostics_Write(DVF_ERRORLEVEL, "Unexpected full duplex results, hr: %i", hr);
		goto error_cleanup;
	}

	DPF_EXIT();
	return TRUE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexBackHandler"
BOOL FullDuplexBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr;
	HWND hwndWizard;
	HWND hwndParent = NULL;

	// Get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);

	// shut down the full duplex test
	hr = psinfo->CancelFullDuplexTest();
	if (FAILED(hr) && hr != DVERR_USERCANCEL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "CancelFullDuplexTest failed, hr: %i", hr);
		goto error_cleanup;
	}

	// reset the registry to the "test not run" state
	hr = psinfo->SetHalfDuplex(REGVAL_NOTRUN);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "SetHalfDuplex failed, code: %i", hr);
	}

	hr = psinfo->SetFullDuplex(REGVAL_NOTRUN);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "SetFullDuplex failed, code: %i", hr);
	}

	hr = psinfo->SetMicDetected(REGVAL_NOTRUN);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "SetMicDetected failed, code: %i", hr);
	}

	// go back to the welcome page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_WELCOME);

	DPF_EXIT();
	return TRUE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexCompleteHandler"
BOOL FullDuplexCompleteHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndProgress;
	LONG lRet;
	HRESULT hr = DV_OK;
	UINT idsErrorMessage = 0;

	// Get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);

	// Disable all the wizard buttons
	PropSheet_SetWizButtons(hwndWizard, 0);

	// Get the progress bar window
	psinfo->GetHWNDProgress(&hwndProgress);

	// Close the full duplex thread handle and get the test results via the exit code
	hr = psinfo->WaitForFullDuplexThreadExitCode();
	switch(hr)
	{
	case DVERR_SOUNDINITFAILURE:
	case DV_HALFDUPLEX:
	case DV_FULLDUPLEX:
		// These are the expected results from the full duplex test thread
		// this means no strange internal error occured, and it is safe
		// to move along to the next part of the wizard.
		// Record the test results
		psinfo->SetFullDuplexResults(hr);
		break;

	case DPNERR_INVALIDDEVICEADDRESS:
		// This can result from no tcp/ip stack on the machine
		// we want to dispaly a special error code and then fall
		// through with the rest of the return codes.
		idsErrorMessage = IDS_ERROR_NODEVICES;
		// fall through
	default:
		// any other error code is not expected and means we hit
		// some internal problem. Bail.
		Diagnostics_Write(DVF_ERRORLEVEL, "Full duplex test thread exited with unexpected error code, hr: %i", hr);
		psinfo->DeinitIPC();
		goto error_cleanup;
	}

	// Deinit the IPC stuff
	hr = psinfo->DeinitIPC();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DeinitIPC failed, code: %i", hr);
		goto error_cleanup;
	}

	// Move the progress bar all the way to the end.
	SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, 1));
	SendMessage(hwndProgress, PBM_SETPOS, 1, 0);

	// enable and press the next button to move 
	// to the next page automatically
	PropSheet_PressButton(hwndWizard, PSBTN_NEXT);
	
	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent, idsErrorMessage);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexResetHandler"
BOOL FullDuplexResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestProc"
INT_PTR CALLBACK MicTestProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;	
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		fRet = MicTestInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = MicTestSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZNEXT :
			fRet = MicTestNextHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZBACK :
			fRet = MicTestBackHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_RESET :
			fRet = MicTestResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default :
			break;
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RECADVANCED:
			fRet = MicTestRecAdvancedHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default:
			break;
		}
		break;

	case WM_APP_LOOPBACK_RUNNING:
		fRet = MicTestLoopbackRunningHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_APP_RECORDSTART:
		fRet = MicTestRecordStartHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_APP_RECORDSTOP:
		fRet = MicTestRecordStopHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_VSCROLL:
		fRet = MicTestVScrollHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	default:
		break;
	}

	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestInitDialogHandler"
BOOL MicTestInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfBold;
	HWND hwndRecPeak;
	HWND hwndOutPeak;
	HWND hwndRecSlider;
	HWND hwndOutSlider;
	HWND hwndOutAdvanced;
	HWND hwndOutGroup;
	HRESULT hr = DV_OK;
	
	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetBoldFont(&hfBold);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfBold, (LPARAM)TRUE);

	// Get the peak meter
	hwndRecPeak = GetDlgItem(hDlg, IDC_RECPEAKMETER);
	if (hwndRecPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Init the recording peak meter
	SendMessage(hwndRecPeak, PM_SETMIN, 0, 0);
	SendMessage(hwndRecPeak, PM_SETMAX, 0, 99);
	SendMessage(hwndRecPeak, PM_SETCUR, 0, 0);

	// Get the recording volume slider
	hwndRecSlider = GetDlgItem(hDlg, IDC_RECVOL_SLIDER);
	if (hwndRecSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Init the recording volume slider
	SendMessage(hwndRecSlider, TBM_SETRANGEMIN, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndRecSlider, TBM_SETRANGEMAX, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN));
	SendMessage(hwndRecSlider, TBM_SETPOS, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndRecSlider, TBM_SETTICFREQ,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/10, 0);
	SendMessage(hwndRecSlider, TBM_SETLINESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/20);
	SendMessage(hwndRecSlider, TBM_SETPAGESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/5);

	// Get the playback peak meter
	hwndOutPeak = GetDlgItem(hDlg, IDC_OUTPEAKMETER);
	if (hwndOutPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Init the playback peak meter
	SendMessage(hwndOutPeak, PM_SETMIN, 0, 0);
	SendMessage(hwndOutPeak, PM_SETMAX, 0, 99);
	SendMessage(hwndOutPeak, PM_SETCUR, 0, 0);

	// Get the playback volume slider
	hwndOutSlider = GetDlgItem(hDlg, IDC_OUTVOL_SLIDER);
	if (hwndOutSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Init the playback volume slider
	SendMessage(hwndOutSlider, TBM_SETRANGEMIN, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndOutSlider, TBM_SETRANGEMAX, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN));
	SendMessage(hwndOutSlider, TBM_SETPOS, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndOutSlider, TBM_SETTICFREQ, 
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/10, 0);
	SendMessage(hwndOutSlider, TBM_SETLINESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/20);
	SendMessage(hwndOutSlider, TBM_SETPAGESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/5);

	// grey out all the playback volume stuff
	EnableWindow(hwndOutSlider, FALSE);
	
	hwndOutAdvanced = GetDlgItem(hDlg, IDC_OUTADVANCED);
	if (hwndOutAdvanced == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	EnableWindow(hwndOutAdvanced, FALSE);
	
	hwndOutGroup = GetDlgItem(hDlg, IDC_OUTGROUP);
	if (hwndOutGroup == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	EnableWindow(hwndOutGroup, FALSE);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestSetActiveHandler"
BOOL MicTestSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndRecPeak;
	HWND hwndOutPeak;
	HWND hwndRecSlider;
	HWND hwndOutSlider;
	HANDLE hThread;
	HANDLE hEvent;
	DWORD dwThreadId;
	HRESULT hr = DV_OK;
	DWORD dwVolume;

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Set the recording peak meter to zero
	hwndRecPeak = GetDlgItem(hDlg, IDC_RECPEAKMETER);
	if (hwndRecPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndRecPeak, PM_SETCUR, 0, 0);

	// Get the recording volume control hwnd
	hwndRecSlider = GetDlgItem(hDlg, IDC_RECVOL_SLIDER);
	if (hwndRecSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	// Set the slider to max
	SendMessage(hwndRecSlider, TBM_SETPOS, 1, SendMessage(hwndRecSlider, TBM_GETRANGEMIN, 0, 0));

	// Set the playback peak meter to zero
	hwndOutPeak = GetDlgItem(hDlg, IDC_OUTPEAKMETER);
	if (hwndOutPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndOutPeak, PM_SETCUR, 0, 0);

	// Get the playback volume control hwnd
	hwndOutSlider = GetDlgItem(hDlg, IDC_OUTVOL_SLIDER);
	if (hwndOutSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Get the current waveOut volume and set the slider to that position
	hr = psinfo->GetWaveOutVolume(&dwVolume);
	if (FAILED(hr))
	{
		// couldn't get the volume - set the slider to top
		SendMessage(hwndOutSlider, TBM_SETPOS, 1, SendMessage(hwndOutSlider, TBM_GETRANGEMIN, 0, 0));
	}
	else
	{
		SendMessage(hwndOutSlider, TBM_SETPOS, 1, SendMessage(hwndOutSlider, TBM_GETRANGEMAX, 0, 0) - dwVolume);
	}
	
	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(hwndRecPeak);
	psinfo->SetHWNDOutputPeak(hwndOutPeak);
	psinfo->SetHWNDInputVolumeSlider(hwndRecSlider);
	psinfo->SetHWNDOutputVolumeSlider(NULL);
	psinfo->SetLoopbackFlags(0);

	// clear the voice detected flag
	psinfo->ClearVoiceDetected();

	// clear the mic test reg value
	psinfo->SetMicDetected(REGVAL_CRASHED);

	// fire up the loopback test thread
	hr = psinfo->CreateLoopbackThread();
	if (FAILED(hr))
	{
		// error, log it and bail
		Diagnostics_Write(DVF_ERRORLEVEL, "CreateLoopbackThread failed, code: %i", hr);
		goto error_cleanup;
	}
	
	// disable the buttons - they will be enabled
	// when the loopback test is up and running.
	PropSheet_SetWizButtons(hwndWizard, 0);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestLoopbackRunningHandler"
BOOL MicTestLoopbackRunningHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HRESULT hr = DV_OK;
	HWND hwndRecordSlider;
	HWND hwndRecordAdvanced;

    // Get the parent window    
	psinfo->GetHWNDWizard(&hwndWizard);

	// lParam is an HRESULT sent by the loopback test thread
	hr = (HRESULT)lParam;
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "LoopbackTestThread signaled error, code: %i", hr);
		goto error_cleanup;
	}

    hwndRecordSlider = GetDlgItem(hDlg, IDC_RECVOL_SLIDER);
    hwndRecordAdvanced = GetDlgItem( hDlg, IDC_RECADVANCED );

    if( hwndRecordSlider != NULL && hwndRecordAdvanced != NULL )
    {
        DWORD dwDeviceFlags;

        psinfo->GetDeviceFlags( &dwDeviceFlags );
        
        if( dwDeviceFlags & DVSOUNDCONFIG_NORECVOLAVAILABLE )
        {
            EnableWindow( hwndRecordAdvanced, FALSE );
            
            EnableWindow( hwndRecordSlider, FALSE );
        }
    }
    else
    {
        hr = DVERR_GENERIC;
        DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get record slider window" );
        goto error_cleanup;
    }

	// clear the voice detected flag
	psinfo->ClearVoiceDetected();

	// enable the next button
	PropSheet_SetWizButtons(hwndWizard, PSWIZB_NEXT|PSWIZB_BACK);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestRecordStartHandler"
BOOL MicTestRecordStartHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	// set the voice detected flag
	psinfo->SetVoiceDetected();

	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestRecordStopHandler"
BOOL MicTestRecordStopHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "MicTestNextHandler"
BOOL MicTestNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr;
	HWND hwndWizard;
	HWND hwndSlider;
	BOOL fVoiceDetected;
	
	// Get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);

	// If we heard a voice, go to the speaker test page.
	// Otherwise, go to the mic failed page
	psinfo->GetVoiceDetected(&fVoiceDetected);
	if (fVoiceDetected)
	{
		// save the current recording slider position
		hwndSlider = GetDlgItem(hDlg, IDC_RECVOL_SLIDER);
		if (hwndSlider == NULL)
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", GetLastError());
		}
		else
		{
			psinfo->SetInputVolumeSliderPos((LONG)SendMessage(hwndSlider, TBM_GETPOS, 0, 0));
		}

		// record the mic test result in the registry
		psinfo->SetMicDetected(REGVAL_PASSED);

		// move on to the speaker test.		
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_SPEAKER_TEST);
	}
	else
	{
		hr = psinfo->ShutdownLoopbackThread();
		if (FAILED(hr))
		{
			Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, code: %i", hr);
		}

		// record the mic test result in the registry
		psinfo->SetMicDetected(REGVAL_FAILED);

		// go to the mic test failed page
		SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_MICTEST_FAILED);
	}

	DPF_EXIT();
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestBackHandler"
BOOL MicTestBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr;
	HWND hwndWizard;
	BOOL fVoiceDetected;
	
	// Get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);

	hr = psinfo->ShutdownLoopbackThread();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, code: %i", hr);
	}

	// shutdown the any volume controls we launched
	psinfo->CloseWindowsVolumeControl(TRUE);
	psinfo->CloseWindowsVolumeControl(FALSE);

	// make it look like the mic test was never run
	psinfo->SetMicDetected(REGVAL_NOTRUN);

	// go back to the full duplex test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXTEST);

	DPF_EXIT();
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestVScrollHandler"
BOOL MicTestVScrollHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	HWND hwndSlider;
	DWORD dwSliderPos;

	psinfo->GetHWNDInputVolumeSlider(&hwndSlider);
	if (hwndSlider == (HWND)lParam)
	{
		// the user is moving the input slider
		dwSliderPos = (DWORD) SendMessage(hwndSlider, TBM_GETPOS, 0, 0);

		// set the input volume to the user's request
		psinfo->SetRecordVolume(AmpFactorToDB(DBToAmpFactor(DSBVOLUME_MAX)-dwSliderPos));			
	}
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestRecAdvancedHandler"
BOOL MicTestRecAdvancedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	HWND hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed");
		DPF_EXIT();
		return FALSE;
	}
	psinfo->LaunchWindowsVolumeControl(hwndWizard, TRUE);

	DPF_EXIT();
	return FALSE;
}



#undef DPF_MODNAME
#define DPF_MODNAME "LoopbackTestThreadProc"
DWORD WINAPI LoopbackTestThreadProc(LPVOID lpvParam)
{
	DPF_ENTER();
	
	CSupervisorInfo* psinfo;
	HRESULT hr;
	LONG lRet;
	HWND hwnd;
	LPDIRECTPLAYVOICESERVER lpdpvs;
	LPDIRECTPLAYVOICECLIENT lpdpvc;
	PDIRECTPLAY8SERVER lpdp8;
	DWORD dwRet;
	HANDLE hEvent;
	DWORD dwWaveOutId;
	DWORD dwWaveInId;
	HWND hwndWizard;
	GUID guidCaptureDevice;
	GUID guidRenderDevice;
	DWORD dwFlags;
	DWORD dwSize;
	PDVSOUNDDEVICECONFIG pdvsdc = NULL;
	PBYTE pdvsdcBuffer = NULL;	
	BOOL fLoopbackStarted = FALSE;
	
	psinfo = (CSupervisorInfo*)lpvParam;
	psinfo->GetHWNDDialog(&hwnd);
	psinfo->GetHWNDWizard(&hwndWizard);
	psinfo->GetCaptureDevice(&guidCaptureDevice);
	psinfo->GetRenderDevice(&guidRenderDevice);
	psinfo->GetLoopbackFlags(&dwFlags);

	lpdpvs = NULL;
	lpdpvc = NULL;
	lpdp8 = NULL;

	// new thread, init COM
	hr = COM_CoInitialize(NULL);

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "COM_CoInitialize failed, code: %i", hr);
		if (!PostMessage(hwnd, WM_APP_LOOPBACK_RUNNING, 0, (LPARAM)hr))
		{
			lRet = GetLastError();
			Diagnostics_Write(DVF_ERRORLEVEL, "PostMessage failed, code: %i", lRet);
		}
		goto error_cleanup;
	}

	hr = StartDirectPlay( &lpdp8 );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StartDirectPlay failed, code: 0x%x", hr);
		goto error_cleanup;		
	}

	hr = StartLoopback(
		&lpdpvs, 
		&lpdpvc,
		&lpdp8, 
		(LPVOID)psinfo,
		hwndWizard,
		guidCaptureDevice,
		guidRenderDevice,
		dwFlags);

	if (FAILED(hr) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StartLoopback failed, code: %i", hr);
		if (!PostMessage(hwnd, WM_APP_LOOPBACK_RUNNING, 0, (LPARAM)hr))
		{
			lRet = GetLastError();
			Diagnostics_Write(DVF_ERRORLEVEL, "PostMessage failed, code: %i", lRet);
		}
		goto error_cleanup;
	}

	psinfo->SetLoopbackRunning( TRUE );

	if( !(dwFlags & DVSOUNDCONFIG_HALFDUPLEX) && hr == DV_HALFDUPLEX )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StartLoopback failed with half duplex when expecting full duplex", hr);
		if (!PostMessage(hwnd, WM_APP_LOOPBACK_RUNNING, 0, (LPARAM)hr))
		{
			lRet = GetLastError();
			Diagnostics_Write(DVF_ERRORLEVEL, "PostMessage failed, code: %i", lRet);
		}
		goto error_cleanup;
	}

	// save the voice client interface for the other threads to play with
	psinfo->SetDPVC(lpdpvc);

	dwSize = 0;
	
	hr = lpdpvc->GetSoundDeviceConfig(pdvsdc, &dwSize);

	if( hr != DVERR_BUFFERTOOSMALL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "GetSoundDeviceConfig failed, hr: %i", hr );
		if (!FAILED(hr))
		{
			// map success codes to a generic failure, since we
			// did not expect success
			hr = DVERR_GENERIC;
		}
		goto error_cleanup;
	}

	pdvsdcBuffer = new BYTE[dwSize];

	if( pdvsdcBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Memory alloc failure" );
		hr = DVERR_OUTOFMEMORY;
		goto error_cleanup;
	}

	pdvsdc = (PDVSOUNDDEVICECONFIG) pdvsdcBuffer;
	pdvsdc->dwSize = sizeof( DVSOUNDDEVICECONFIG );

	hr = lpdpvc->GetSoundDeviceConfig(pdvsdc, &dwSize);	
	
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetSoundDeviceConfig failed, hr: %i", hr);
		goto error_cleanup;
	}

	hr = DV_MapGUIDToWaveID(FALSE, pdvsdc->guidPlaybackDevice, &dwWaveOutId);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DV_MapGUIDToWaveID failed, hr: %i", hr);
		goto error_cleanup;
	}
	hr = psinfo->SetWaveOutId(dwWaveOutId);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "SetWaveOutId failed, hr: %i", hr);
		goto error_cleanup;
	}
	
	hr = DV_MapGUIDToWaveID(TRUE, pdvsdc->guidCaptureDevice, &dwWaveInId);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DV_MapGUIDToWaveID failed, hr: %i", hr);
		goto error_cleanup;
	}
	psinfo->SetWaveInId(dwWaveInId);
	psinfo->SetDeviceFlags( pdvsdc->dwFlags );

	// inform the app that loopback is up and running.
	hr = DV_OK;
	// Also send along the flags from GetSoundDeviceConfig
	if (!PostMessage(hwnd, WM_APP_LOOPBACK_RUNNING, 0, (LPARAM)hr))
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "PostMessage failed, code: %i", lRet);
		goto error_cleanup;
	}

	// wait on the shutdown event
	hr = psinfo->WaitForLoopbackShutdownEvent();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "WaitForLoopbackShutdown failed, code: %i", hr);
		goto error_cleanup;
	}

	psinfo->SetLoopbackRunning( FALSE);		

	delete [] pdvsdcBuffer;	
	pdvsdcBuffer = NULL;

	// Null out the interface pointer in sinfo
	psinfo->SetDPVC(NULL);

	// shutdown the loopback test
	hr = StopLoopback(lpdpvs, lpdpvc, lpdp8);
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StopLoopback failed, code: %i", hr);
		goto error_cleanup;
	}

	hr = StopDirectPlay( lpdp8 );

	lpdp8 = NULL;

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "StopDirectPlay failed, code: %i", hr);
		goto error_cleanup;
	}		

	// Signal the loopback thread exit event
	psinfo->SignalLoopbackThreadDone();

	COM_CoUninitialize();
	DPF_EXIT();
	return DV_OK;

error_cleanup:
	if (pdvsdcBuffer != NULL)
	{
		delete [] pdvsdcBuffer;
	}

	if (fLoopbackStarted)
	{
		StopLoopback(lpdpvs, lpdpvc, lpdp8);
	}

	if( lpdp8 )
	{
		StopDirectPlay( lpdp8 );
	}

	psinfo->SetLoopbackRunning( FALSE);

	psinfo->SignalLoopbackThreadDone();
	COM_CoUninitialize();
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestResetHandler"
BOOL MicTestResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteProc"
INT_PTR CALLBACK CompleteProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;	
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		fRet = CompleteInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = CompleteSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZFINISH :
			fRet = CompleteFinishHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_RESET :
			fRet = CompleteResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default :
			break;
		}
		break;

	default:
		break;
	}

	DPF_EXIT();		
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteInitDialogHandler"
BOOL CompleteInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfTitle;
	HRESULT hr = DV_OK;
	
	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetTitleFont(&hfTitle);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfTitle, (LPARAM)TRUE);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteSetActiveHandler"
BOOL CompleteSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard;
	HWND hwndParent = NULL;
	HANDLE hEvent;
	HRESULT hr;

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		// log it, and return, don't know how to terminate the wizard properly
		// without this handle!
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(NULL);
	psinfo->SetHWNDOutputPeak(NULL);
	psinfo->SetHWNDInputVolumeSlider(NULL);
	psinfo->SetHWNDOutputVolumeSlider(NULL);

	PropSheet_SetWizButtons(hwndWizard, PSWIZB_FINISH);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteFinishHandler"
BOOL CompleteFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	psinfo->Finish();
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CompleteResetHandler"
BOOL CompleteResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedProc"
INT_PTR CALLBACK MicTestFailedProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LONG lRet;
	BOOL fRet;
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		MicTestFailedInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = MicTestFailedSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZBACK :
			fRet = MicTestFailedBackHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_RESET :
			fRet = MicTestFailedResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZFINISH :
			fRet = MicTestFailedFinishHandler(hDlg, message, wParam, lParam, psinfo);
			break;
			
		default :
			break;
		}
		break;

	default:
		break;
	}

	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedInitDialogHandler"
BOOL MicTestFailedInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfTitle;
	HICON hIcon;
	HRESULT hr = DV_OK;

	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetTitleFont(&hfTitle);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfTitle, (LPARAM)TRUE);

	// load the warning icon
	hIcon = LoadIcon(NULL, IDI_WARNING);
	SendDlgItemMessage(hDlg, IDC_WARNINGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

	DPF_EXIT();
	return FALSE;

// error block
error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedSetActiveHandler"
BOOL MicTestFailedSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard;
	HWND hwndParent = NULL;
	HWND hwndPeak;
	HANDLE hEvent;
	HRESULT hr;

	PlaySound( _T("SystemExclamation"), NULL, SND_ASYNC );			

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		// log it, and return, don't know how to terminate the wizard properly
		// without this handle!
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(NULL);
	psinfo->SetHWNDOutputPeak(NULL);
	psinfo->SetHWNDInputVolumeSlider(NULL);
	psinfo->SetHWNDOutputVolumeSlider(NULL);

	// enable the finish and back buttons
	PropSheet_SetWizButtons(hwndWizard, PSWIZB_BACK|PSWIZB_FINISH);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedRecordStopHandler"
BOOL MicTestFailedRecordStopHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedBackHandler"
BOOL MicTestFailedBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	// go back to the mic test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_MICTEST);

	DPF_EXIT();
	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedResetHandler"
BOOL MicTestFailedResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "MicTestFailedFinishHandler"
BOOL MicTestFailedFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	psinfo->Finish();

	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestProc"
INT_PTR CALLBACK SpeakerTestProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	LONG lRet;
	BOOL fRet;
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		SpeakerTestInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = SpeakerTestSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZNEXT :
			fRet = SpeakerTestNextHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZBACK :
			fRet = SpeakerTestBackHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_RESET :
			fRet = SpeakerTestResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default :
			break;
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDC_RECADVANCED:
			fRet = SpeakerTestRecAdvancedHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case IDC_OUTADVANCED:
			fRet = SpeakerTestOutAdvancedHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default:
			break;
		}
		break;
		
	case WM_VSCROLL:
		fRet = SpeakerTestVScrollHandler(hDlg, message, wParam, lParam, psinfo);
		break;
		
	default:
		break;
	}

	DPF_ENTER();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestInitDialogHandler"
BOOL SpeakerTestInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfBold;
	HWND hwndRecPeak;
	HWND hwndOutPeak;
	HWND hwndRecSlider;
	HWND hwndOutSlider;
	HRESULT hr = DV_OK;
	
	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetBoldFont(&hfBold);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfBold, (LPARAM)TRUE);

	// Init the recording peak meter
	hwndRecPeak = GetDlgItem(hDlg, IDC_RECPEAKMETER);
	if (hwndRecPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndRecPeak, PM_SETMIN, 0, 0);
	SendMessage(hwndRecPeak, PM_SETMAX, 0, 99);
	SendMessage(hwndRecPeak, PM_SETCUR, 0, 0);

	// Init the recording volume slider
	hwndRecSlider = GetDlgItem(hDlg, IDC_RECVOL_SLIDER);
	if (hwndRecSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndRecSlider, TBM_SETRANGEMIN, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndRecSlider, TBM_SETRANGEMAX, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN));
	SendMessage(hwndRecSlider, TBM_SETPOS, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndRecSlider, TBM_SETTICFREQ, 
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/10, 0);
	SendMessage(hwndRecSlider, TBM_SETLINESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/20);
	SendMessage(hwndRecSlider, TBM_SETPAGESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/5);

	// Init the playback peak meter
	hwndOutPeak = GetDlgItem(hDlg, IDC_OUTPEAKMETER);
	if (hwndOutPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndOutPeak, PM_SETMIN, 0, 0);
	SendMessage(hwndOutPeak, PM_SETMAX, 0, 99);
	SendMessage(hwndOutPeak, PM_SETCUR, 0, 0);

	// Init the playback volume slider
	hwndOutSlider = GetDlgItem(hDlg, IDC_OUTVOL_SLIDER);
	if (hwndOutSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndOutSlider, TBM_SETRANGEMIN, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndOutSlider, TBM_SETRANGEMAX, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN));
	SendMessage(hwndOutSlider, TBM_SETPOS, 0, DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MAX));
	SendMessage(hwndOutSlider, TBM_SETTICFREQ, 
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/10, 0);
	SendMessage(hwndOutSlider, TBM_SETLINESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/20);
	SendMessage(hwndOutSlider, TBM_SETPAGESIZE, 0,
		(DBToAmpFactor(DSBVOLUME_MAX) - DBToAmpFactor(DSBVOLUME_MIN))/5);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestSetActiveHandler"
BOOL SpeakerTestSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndRecPeak;
	HWND hwndOutPeak;
	HWND hwndRecSlider;
	HWND hwndOutSlider;
	HANDLE hEvent;
	HRESULT hr = DV_OK;
	DWORD dwVolume;
	HWND hwndRecAdvanced;

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Reset the recording peak meter
	hwndRecPeak = GetDlgItem(hDlg, IDC_RECPEAKMETER);
	if (hwndRecPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndRecPeak, PM_SETCUR, 0, 0);

	// set the recording volume slider to match
	// the recording volume slider from the mic
	// test page.
	hwndRecSlider = GetDlgItem(hDlg, IDC_RECVOL_SLIDER);
	if (hwndRecSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	hwndRecAdvanced = GetDlgItem( hDlg, IDC_RECADVANCED );
	if (hwndRecAdvanced == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = lRet;
		goto error_cleanup;
	}
	
    DWORD dwDeviceFlags;

    psinfo->GetDeviceFlags( &dwDeviceFlags );

    if( dwDeviceFlags & DVSOUNDCONFIG_NORECVOLAVAILABLE )
    {
        EnableWindow( hwndRecSlider, FALSE );
        EnableWindow( hwndRecAdvanced, FALSE );
    }
    
	LONG lPos;
	psinfo->GetInputVolumeSliderPos(&lPos);
	SendMessage(hwndRecSlider, TBM_SETPOS, 1, lPos);

	// Reset the playback peak meter
	hwndOutPeak = GetDlgItem(hDlg, IDC_OUTPEAKMETER);
	if (hwndOutPeak == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	SendMessage(hwndOutPeak, PM_SETCUR, 0, 0);

	// Grey out the playback volume slider - until we come back
	// to fix it
	hwndOutSlider = GetDlgItem(hDlg, IDC_OUTVOL_SLIDER);
	if (hwndOutSlider == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// Get the current waveOut volume and set the slider to that position
	hr = psinfo->GetWaveOutVolume(&dwVolume);
	if (FAILED(hr))
	{
		// couldn't get the volume - set the slider to top
		SendMessage(hwndOutSlider, TBM_SETPOS, 1, SendMessage(hwndOutSlider, TBM_GETRANGEMIN, 0, 0));
		// disable the slider
		EnableWindow(hwndOutSlider, FALSE);
	}
	else
	{
		SendMessage(hwndOutSlider, TBM_SETPOS, 1, SendMessage(hwndOutSlider, TBM_GETRANGEMAX, 0, 0) - dwVolume);
	}

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(hwndRecPeak);
	psinfo->SetHWNDOutputPeak(hwndOutPeak);
	psinfo->SetHWNDInputVolumeSlider(hwndRecSlider);
	psinfo->SetHWNDOutputVolumeSlider(hwndOutSlider);

	// unmute the output
	hr = psinfo->Unmute();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unmute failed, code: %i", hr);
		goto error_cleanup;
	}
	
	// enable the next button
	PropSheet_SetWizButtons(hwndWizard, PSWIZB_BACK|PSWIZB_NEXT);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestNextHandler"
BOOL SpeakerTestNextHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;

	// get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);

	// shutdown the loopback test
	hr = psinfo->ShutdownLoopbackThread();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, code: %i", hr);
		goto error_cleanup;		
	}

	// close any volume controls that are open.
	psinfo->CloseWindowsVolumeControl(TRUE);
	psinfo->CloseWindowsVolumeControl(FALSE);

	// the next page is the completion page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_COMPLETE);

	DPF_EXIT();
	return TRUE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestBackHandler"
BOOL SpeakerTestBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	HRESULT hr = DV_OK;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;

	// get the parent window
	psinfo->GetHWNDWizard(&hwndWizard);

	// shutdown the loopback test, so the mic test
	// page can start fresh.
	hr = psinfo->ShutdownLoopbackThread();
	if (FAILED(hr))
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "ShutdownLoopbackThread failed, hr: %i", hr);
		goto error_cleanup;
	}

	// close the output volume control, if showing
	psinfo->CloseWindowsVolumeControl(FALSE);

	// go back to the mic test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_MICTEST);

	DPF_EXIT();
	return TRUE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestResetHandler"
BOOL SpeakerTestResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestVScrollHandler"
BOOL SpeakerTestVScrollHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	HWND hwndSlider;
	DWORD dwSliderPos;

	psinfo->GetHWNDInputVolumeSlider(&hwndSlider);
	if (hwndSlider == (HWND)lParam)
	{
		// the user is moving the input slider
		dwSliderPos = (DWORD)SendMessage(hwndSlider, TBM_GETPOS, 0, 0);

		// set the input volume to the user's request
		psinfo->SetRecordVolume(AmpFactorToDB(DBToAmpFactor(DSBVOLUME_MAX)-dwSliderPos));			
	}

	psinfo->GetHWNDOutputVolumeSlider(&hwndSlider);
	if (hwndSlider == (HWND)lParam)
	{
		// the user is moving the output slider
		dwSliderPos = (DWORD) SendMessage(hwndSlider, TBM_GETPOS, 0, 0);

		// set the output volume
		psinfo->SetWaveOutVolume( ((DWORD) SendMessage(hwndSlider, TBM_GETRANGEMAX, 0, 0)) - dwSliderPos);			
	}
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestRecAdvancedHandler"
BOOL SpeakerTestRecAdvancedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	HWND hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed");
		DPF_EXIT();
		return FALSE;
	}
	psinfo->LaunchWindowsVolumeControl(hwndWizard, TRUE);

	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "SpeakerTestOutAdvancedHandler"
BOOL SpeakerTestOutAdvancedHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	HWND hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed");
		DPF_EXIT();
		return FALSE;
	}
	psinfo->LaunchWindowsVolumeControl(hwndWizard, FALSE);

	DPF_EXIT();
	return FALSE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexFailedProc"
INT_PTR CALLBACK FullDuplexFailedProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;	
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		fRet = FullDuplexFailedInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = FullDuplexFailedSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZFINISH :
			fRet = FullDuplexFailedFinishHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZBACK :
			fRet = FullDuplexFailedBackHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_RESET :
			fRet = FullDuplexFailedResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default :
			break;
		}
		break;

	default:
		break;
	}

	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexFailedInitDialogHandler"
BOOL FullDuplexFailedInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfTitle;
	HICON hIcon;
	HRESULT hr = DV_OK;

	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetTitleFont(&hfTitle);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfTitle, (LPARAM)TRUE);

	// load the warning icon
	hIcon = LoadIcon(NULL, IDI_WARNING);
	SendDlgItemMessage(hDlg, IDC_WARNINGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexFailedSetActiveHandler"
BOOL FullDuplexFailedSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard;
	HWND hwndParent = NULL;
	HANDLE hEvent;
	HRESULT hr;

	PlaySound( _T("SystemExclamation"), NULL, SND_ASYNC );				

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(NULL);
	psinfo->SetHWNDOutputPeak(NULL);
	psinfo->SetHWNDInputVolumeSlider(NULL);
	psinfo->SetHWNDOutputVolumeSlider(NULL);

	PropSheet_SetWizButtons(hwndWizard, PSWIZB_BACK|PSWIZB_FINISH);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexFailedFinishHandler"
BOOL FullDuplexFailedFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	psinfo->Finish();
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexFailedResetHandler"
BOOL FullDuplexFailedResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FullDuplexFailedBackHandler"
BOOL FullDuplexFailedBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	// go back to the full duplex test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXTEST);
	
	DPF_EXIT();
	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "HalfDuplexFailedProc"
INT_PTR CALLBACK HalfDuplexFailedProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	DPF_ENTER();
	
	BOOL fRet;	
	LPNMHDR lpnm;
	
	CSupervisorInfo* psinfo = (CSupervisorInfo*)GetWindowLongPtr(hDlg, GWLP_USERDATA);

	fRet = FALSE;
	switch (message)
	{
	case WM_INITDIALOG :
		fRet = HalfDuplexFailedInitDialogHandler(hDlg, message, wParam, lParam, psinfo);
		break;

	case WM_NOTIFY :
		lpnm = (LPNMHDR) lParam;

		switch (lpnm->code)
		{
		case PSN_SETACTIVE : 
			fRet = HalfDuplexFailedSetActiveHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZFINISH :
			fRet = HalfDuplexFailedFinishHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		case PSN_WIZBACK :
			fRet = HalfDuplexFailedBackHandler(hDlg, message, wParam, lParam, psinfo);
			break;
			
		case PSN_RESET :
			fRet = HalfDuplexFailedResetHandler(hDlg, message, wParam, lParam, psinfo);
			break;

		default :
			break;
		}
		break;

	default:
		break;
	}

	DPF_EXIT();
	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HalfDuplexFailedInitDialogHandler"
BOOL HalfDuplexFailedInitDialogHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard = NULL;
	HWND hwndParent = NULL;
	HWND hwndControl;
	HFONT hfTitle;
	HICON hIcon;
	HRESULT hr = DV_OK;

	// Get the shared data from PROPSHEETPAGE lParam value
	// and load it into GWLP_USERDATA
	psinfo = (CSupervisorInfo*)((LPPROPSHEETPAGE)lParam)->lParam;
	SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)psinfo);
	
	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	
	hwndControl = GetDlgItem(hDlg, IDC_TITLE);
	if (hwndControl == NULL)
	{
		// error, log it and bail
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetDlgItem failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}
	psinfo->GetTitleFont(&hfTitle);
    (void)::SendMessage(hwndControl, WM_SETFONT, (WPARAM)hfTitle, (LPARAM)TRUE);

	// load the warning icon
	hIcon = LoadIcon(NULL, IDI_WARNING);
	SendDlgItemMessage(hDlg, IDC_WARNINGICON, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HalfDuplexFailedSetActiveHandler"
BOOL HalfDuplexFailedSetActiveHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	LONG lRet;
	HWND hwndWizard;
	HWND hwndParent = NULL;
	HANDLE hEvent;
	HRESULT hr;

	PlaySound( _T("SystemExclamation"), NULL, SND_ASYNC );			

	// Get the parent window
	hwndWizard = GetParent(hDlg);
	if (hwndWizard == NULL)
	{
		lRet = GetLastError();
		Diagnostics_Write(DVF_ERRORLEVEL, "GetParent failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// set the HWNDs
	psinfo->SetHWNDWizard(hwndWizard);
	psinfo->SetHWNDDialog(hDlg);
	psinfo->SetHWNDProgress(NULL);
	psinfo->SetHWNDInputPeak(NULL);
	psinfo->SetHWNDOutputPeak(NULL);
	psinfo->SetHWNDInputVolumeSlider(NULL);
	psinfo->SetHWNDOutputVolumeSlider(NULL);

	PropSheet_SetWizButtons(hwndWizard, PSWIZB_BACK|PSWIZB_FINISH);

	DPF_EXIT();
	return FALSE;

error_cleanup:
	psinfo->GetHWNDParent(&hwndParent);
	DV_DisplayErrorBox(hr, hwndParent);
	psinfo->SetError(hr);
	psinfo->Abort(hDlg, hr);
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HalfDuplexFailedFinishHandler"
BOOL HalfDuplexFailedFinishHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	
	psinfo->Finish();
	
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HalfDuplexFailedResetHandler"
BOOL HalfDuplexFailedResetHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();
	DPF_EXIT();
	return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "HalfDuplexFailedBackHandler"
BOOL HalfDuplexFailedBackHandler(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, CSupervisorInfo* psinfo)
{
	DPF_ENTER();

	// go back to the full duplex test page
	SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_FULLDUPLEXTEST);
	
	DPF_EXIT();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\agcva1.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva1.cpp
 *  Content:	Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	pnewson Created it
 *  01/14/2000	rodtoll	Plugged memory leak
 *  01/21/2000	pnewson	Fixed false detection at start of audio stream
 *  					Raised VA_LOW_ENVELOPE from (2<<8) to (3<<8)
 *  01/24/2000	pnewson	Fixed return code on Deinit
 *  01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 *  02/08/2000	rodtoll	Bug #131496 - Selecting DVSENSITIVITY_DEFAULT results in voice
 *						never being detected 
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/20/2000  rodtoll Bug #32889 - Unable to run on non-admin accounts on Win2k
 *  04/20/2000	pnewson Tune AGC algorithm to make it more agressive at 
 *						raising the recording volume.
 *  04/25/2000  pnewson Fix to improve responsiveness of AGC when volume level too low
 *  12/07/2000	rodtoll	WinBugs #48379: DPVOICE: AGC appears to be functioning incorrectly (restoring to old algorithm(
 *
 ***************************************************************************/

#include "dxvutilspch.h"


/*

How this voice activation code works:

The idea is this. The power of the noise signal is pretty much constant over
time. The power of a voice signal varies considerably over time. The power of
a voice signal is not always high however. Weak frictive noises and such do not
generate much power, but since they are part of a stream of speech, they represent
a dip in the power, not a constant low power like the noise signal. We therefore 
associate changes in power with the presence of a voice signal.

If it works as expected, this will allow us to detect voice activity even
when the input volume, and therefore the total power of the signal, is very
low. This in turn will allow the auto gain control code to be more effective.

To estimate the power of the signal, we run the absolute value of the input signal
through a recursive digital low pass filter. This gives us the "envelope" signal.
[An alternative way to view this is a low frequency envelope signal modulated by a 
higher frequency carrier signal. We're extracting the low frequency envelope signal.]

*/

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// the registry names where the AGC stuff is saved
#define DPVOICE_REGISTRY_SAVEDAGCLEVEL		L"SavedAGCLevel"

// AGC_VOLUME_TICKSIZE
//
// The amount the recording volume should be changed
// when AGC determines it is required. 
#define AGC_VOLUME_TICKSIZE 100

/*
// AGC_VOLUME_UPTICK
//
// The amount the recording volume should be increased
// when the input level has been too low for a while.
#define AGC_VOLUME_UPTICK	125

// AGC_VOLUME_DOWNTICK
//
// The amount the recording volume should be increased
// when the input level has been too high for a while.
#define AGC_VOLUME_DOWNTICK	250
*/

// AGC_VOLUME_INITIAL_UPTICK
//
// When the AGC level is loaded from the registry, this
// amount is added to it as an initial boost, since it
// is much easier and faster to lower the recording level
// via AGC than it is to raise it.
#define AGC_VOLUME_INITIAL_UPTICK 500

// AGC_VOLUME_MINIMUM
//
// The minimum volume setting allowed.
// Make sure it's above 0, this mutes some cards
#define AGC_VOLUME_MINIMUM           (DSBVOLUME_MIN+AGC_VOLUME_TICKSIZE)

// AGC_VOLUME_MAXIMUM
//
// The maximum volume setting allowed.
#define AGC_VOLUME_MAXIMUM           DSBVOLUME_MAX 

// AGC_VOLUME_LEVELS
// 
// How many possible volume levels are there?
#define AGC_VOLUME_LEVELS ((DV_ABS(AGC_VOLUME_MAXIMUM - AGC_VOLUME_MINIMUM) / AGC_VOLUME_TICKSIZE) + 1)

/*
// AGC_REDUCTION_THRESHOLD
//
// The peak level at which the recording volume
// must be reduced
#define AGC_REDUCTION_THRESHOLD      98

// AGC_INCREASE_THRESHOLD
//
// If the user's input remains under this threshold
// for an extended period of time, we will consider
// raising the input level.
#define AGC_INCREASE_THRESHOLD       70

// AGC_INCREASE_THRESHOLD_TIME
//
// How long must the input remain uner the increase
// threshold to trigger in increase? (measured
// in milliseconds
#define AGC_INCREASE_THRESHOLD_TIME 500
*/

// AGC_PEAK_CLIPPING_THRESHOLD
//
// The peak value at or above which we consider the 
// input signal to be clipping.
#define AGC_PEAK_CLIPPING_THRESHOLD 0x7e00

/*
// AGC_ENV_CLIPPING_THRESHOLD
//
// When we detect clipping via the threshold above, 
// the 16 bit normalized envelope signal must be above 
// this threshold for us to lower the input volume. 
// This allows us to ignore intermittent spikes in 
// the input.
#define AGC_ENV_CLIPPING_THRESHOLD 0x2000

// AGC_ENV_CLIPPING_COUNT_THRESHOLD
//
// For how many envelope samples does the envelope
// signal need to stay above the threshold value
// above in order to take the volume down a tick?
#define AGC_ENV_CLIPPING_COUNT_THRESHOLD 10
*/

// AGC_IDEAL_CLIPPING_RATIO
//
// What is the ideal ratio of clipped to total samples?
// E.g. a value of 0.005 says that we would like 5 out of
// every 1000 samples to clip. If we are getting less clipping,
// the volume should be increased. If we are getting more,
// the volume should be reduced.
//
// Note: only samples that are part of a frame detected as
// speech are considered.
#define AGC_IDEAL_CLIPPING_RATIO 0.0005

// AGC_CHANGE_THRESHOLD
//
// How far from the ideal does a volume level have to
// stray before we will consider changing the volume?
//
// E.g. If this value is 1.05, the history for a volume
// level would have to be 5% above or below the ideal
// value in order to have an AGC correction made.
#define AGC_CHANGE_THRESHOLD 1.01

// AGC_CLIPPING_HISTORY
//
// How many milliseconds of history should we keep regarding
// the clipping behavior at a particular volume setting?
// E.g. a value of 10000 means that we remember the last
// 10 seconds of activity at each volume level.
//
// Note: only samples that are part of a frame detected as
// speech are considered.
#define AGC_CLIPPING_HISTORY 1000
//#define AGC_CLIPPING_HISTORY 2000
//#define AGC_CLIPPING_HISTORY 5000
//#define AGC_CLIPPING_HISTORY 10000
//#define AGC_CLIPPING_HISTORY 30000 // it took AGC too long to recover
									 // from low volume leves with this
									 // setting

// AGC_FEEDBACK_ENV_THRESHOLD
//
// To detect a feedback condition, we check to see if the
// envelope signal has a value larger than AGC_FEEDBACK_ENV_THRESHOLD.
// If the envelope signal stays consistently above this level,
// for longer than AGC_FEEDBACK_TIME_THRESHOLD milliseconds, we conclude 
// that feedback is occuring. Voice has a changing envelope, and will 
// dip below the threshold on a regular basis. Feedback will not. 
// This will allow us to automatically reduce the input volume 
// when feedback is detected.
#define AGC_FEEDBACK_ENV_THRESHOLD 2500
#define AGC_FEEDBACK_TIME_THRESHOLD 1000

// AGC_DEADZONE_THRESHOLD
//
// If the input signal never goes above this value
// (16bits, promoted if required) for the deadzone time,
// then we consider the input to be in the dead zone,
// and the volume should be upticked.
// #define AGC_DEADZONE_THRESHOLD 0 // This is too low - it does not reliably detect the deadzone
#define AGC_DEADZONE_THRESHOLD (1 << 8)

// AGC_DEADZONE_TIME
//
// How long we have to be in the deadzone before
// the deadzone increase kicks in - we need this to
// be longer than just one frame, or we get false
// positives.
#define AGC_DEADZONE_TIME 1000

// VA_HIGH_DELTA
//
// If the percent change in the envelope signal is greater 
// than this value, voice is detected. Each point of this
// value is equal to 0.1%. E.g. 4000 == 400% increase.
// An unchanging signal produces a 100% value.
//#define VA_HIGH_DELTA 2000

//#define VA_HIGH_DELTA_FASTSLOW 0x7fffffff // select this to factor out this VA parameter

//#define VA_HIGH_DELTA_FASTSLOW 1400
//#define VA_HIGH_DELTA_FASTSLOW 1375	// current choice
//#define VA_HIGH_DELTA_FASTSLOW 1350
//#define VA_HIGH_DELTA_FASTSLOW 1325
//#define VA_HIGH_DELTA_FASTSLOW 1300
//#define VA_HIGH_DELTA_FASTSLOW 1275
//#define VA_HIGH_DELTA_FASTSLOW 1250
//#define VA_HIGH_DELTA_FASTSLOW 1200
//#define VA_HIGH_DELTA_FASTSLOW 1175 // catches all noise
//#define VA_HIGH_DELTA_FASTSLOW 1150 // catches all noise
//#define VA_HIGH_DELTA_FASTSLOW 1125 // catches all noise
//#define VA_HIGH_DELTA_FASTSLOW 1100 // catches all noise


// VA_LOW_DELTA
//
// If the percent change in the envelope signal is lower 
// than this value, voice is detected. Each point of this
// value is equal to 0.1%. E.g. 250 == 25% increase 
// (i.e a decrease to 1/4 the original signal strength).
// An unchanging signal produces a 100% value.
//#define VA_LOW_DELTA 500
//#define VA_LOW_DELTA_FASTSLOW 0 // select this to factor out this VA parameter
//#define VA_LOW_DELTA_FASTSLOW 925
//#define VA_LOW_DELTA_FASTSLOW 900
//#define VA_LOW_DELTA_FASTSLOW 875
//#define VA_LOW_DELTA_FASTSLOW 850
//#define VA_LOW_DELTA_FASTSLOW 825
//#define VA_LOW_DELTA_FASTSLOW 800
//#define VA_LOW_DELTA_FASTSLOW 775	// current choice
//#define VA_LOW_DELTA_FASTSLOW 750
//#define VA_LOW_DELTA_FASTSLOW 725
//#define VA_LOW_DELTA_FASTSLOW 700
//#define VA_LOW_DELTA_FASTSLOW 675
//#define VA_LOW_DELTA_FASTSLOW 650


// The following VA parameters were optimized for what I believe to be
// the hardest configuration: A cheap open stick mic with external speakers,
// with Echo Suppression turned on. Echo suppression penalizes false positives
// harshly, since the receiver cannot send which receiving the "noise". If 
// the VA parameters work for this case, then they should be fine for the 
// much better signal to noise ratio provided by a headset or collar mic.
// (As long as the user does not breathe directly on the headset mic.)
//
// Two source-to-mic distances were tested during tuning.
//
// 1) Across an enclosed office (approx 8 to 10 feet)
// 2) Seated at the workstation (approx 16 to 20 inches)
//
// At distance 1, the AGC was never invoked, gain was at 100%
// At distance 2, the AGC would take the mic down a few ticks.
//
// The office enviroment had the background noise from 3 computers,
// a ceiling vent, and a surprisingly noisy fan from the ethernet
// hub. There is no background talking, cars, trains, or things of
// that nature.
//
// Each parameter was tuned separately to reject 100% of the 
// background noise for case 1 (gain at 100%).
//
// Then they were tested together to see if they could detect
// across the room speech.
//
// Individually, none of the detection criteria could reliably
// detect all of the across the room speech. Together, they did
// not do much better. They even missed some speech while seated.
// Not very satifactory.
//
// Therefore, I decided to abandon the attempt to detect across
// the room speech. I retuned the parameters to reject noise 
// after speaking while seated (which allowed AGC to reduce
// the volume a couple of ticks, thereby increasing the signal
// to noise ratio) and to reliably detect seated speech.
//
// I also found that the "fast" envelope signal was better at
// detecting speech than the "slow" one in a straight threshold
// comparison, so it is used in the VA tests.
//

// VA_HIGH_PERCENT
//
// If the fast envelope signal is more than this percentage
// higher than the slow envelope signal, speech is detected.
//
#define VA_HIGH_PERCENT 170 // rejects most noise, still catches some.
							// decent voice detection. Catches the beginning
							// of speech a majority of the time, but does miss
							// once in a while. Will often drop out partway 
							// into a phrase when used alone. Must test in 
							// conjunction with VA_LOW_PERCENT.
							//
							// After testing in conjunction with VA_LOW_PERCENT,
							// the performance is reasonable. Low input volume
							// signals are usually detected ok, but dropouts are
							// a bit common. However, noise is sometimes still
							// detected, so making these parameters more sensitive
							// would not be useful.
//#define VA_HIGH_PERCENT 165 // catches occational noise
//#define VA_HIGH_PERCENT 160 // catches too much noise
//#define VA_HIGH_PERCENT 150 // catches most noise
//#define VA_HIGH_PERCENT 140 // catches almost all noise
//#define VA_HIGH_PERCENT 0x00007fff // select this to factor out this VA parameter

// VA_LOW_PERCENT
//
// If the fast envelope signal is more than this percentage
// lower than the slow envelope signal, speech is detected.
//
#define VA_LOW_PERCENT 50 // excellent noise rejection. poor detection of speech.
						  // when used alone, could miss entire phrases. Must evaluate
						  // in conjunction with tuned VA_HIGH_PERCENT
						  //
						  // See note above re: testing in conjunction with VA_HIGH_PERCENT
//#define VA_LOW_PERCENT 55 // still catches too much noise
//#define VA_LOW_PERCENT 60 // catches most noise
//#define VA_LOW_PERCENT 65 // catches most noise
//#define VA_LOW_PERCENT 70 // still catches almost all noise
//#define VA_LOW_PERCENT 75 // catches almost all noise
//#define VA_LOW_PERCENT 80 // catches all noise
//#define VA_LOW_PERCENT 0 // select this to factor out this VA parameter

// VA_HIGH_ENVELOPE
//
// If the 16 bit normalized value of the envelope exceeds
// this number, the signal is considered voice.
//
//#define VA_HIGH_ENVELOPE (15 << 8) // still catches high gain noise, starting to get 
								   // speech dropouts, when "p" sounds lower the gain
#define VA_HIGH_ENVELOPE (14 << 8) // Noise immunity good at "seated" S/N ratio. No speech
								   // dropouts encountered. Still catches noise at full gain.
//#define VA_HIGH_ENVELOPE (13 << 8) // Noise immunity not as good as expected (new day).
//#define VA_HIGH_ENVELOPE (12 << 8) // Good noise immunity. Speech recognition excellent.
								   // Only one dropout occured in the test with a 250ms
								   // hangover. I think the hangover time should be increased
								   // above 250 however, because a comma (properly read) tends 
								   // to cause a dropout. I'm going to tune the hangover time, 
								   // and return to this test.
								   //
								   // Hangover time is now 400ms. No dropouts occur with
								   // "seated" speech.
//#define VA_HIGH_ENVELOPE (11 << 8) // Catches almost no noise at "seated" gain
								   // however, if the gain creeped up a bit, noise would
								   // be detected. I therefore think a slightly higher 
								   // threshold would be a good idea. The speech recognition
								   // based on only this parameter at this level was flawless.
								   // No dropouts at all with a 250 ms hangover time. (commas
								   // excepted).
//#define VA_HIGH_ENVELOPE (10 << 8) // catches some noise at "seated" gain - getting very close
//#define VA_HIGH_ENVELOPE (9 << 8) // catches some noise at "seated" gain - getting close
//#define VA_HIGH_ENVELOPE (8 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (7 << 8) // catches noise at "seated" gain
//#define VA_HIGH_ENVELOPE (0x7fffffff) // select this to factor out this VA parameter

// VA_LOW_ENVELOPE
//
// If the 16 bit normalized value of the envelope is below
// this number, the signal will never be considered voice.
// This reduces some false positives on the delta checks
// at very low signal levels
#define VA_LOW_ENVELOPE (3 << 8)
//#define VA_LOW_ENVELOPE (2 << 8) // causes false VA at low input volumes
//#define VA_LOW_ENVELOPE (1 << 8) // causes false VA at low input volumes

// VA_HANGOVER_TIME
//
// The time, in milliseconds, that voice activation sticks in
// the ON position following a voice detection. E.g. a value of 500
// means that voice will always be transmitted in at least 1/2 second
// bursts.
//
// I am trying to tune this so that a properly read comma will not cause
// a dropout. This will give the user a bit of leeway to pause in the
// speech stream without losing the floor when in Echo Suppression mode.
// It will also prevent dropouts even when not in Echo Suppression mode
#define VA_HANGOVER_TIME 400 // this gives satisfying performance
//#define VA_HANGOVER_TIME 375 // almost there, longest commas still goners
//#define VA_HANGOVER_TIME 350 // still drops long commas
//#define VA_HANGOVER_TIME 325 // does not drop fast commas, drops long ones
//#define VA_HANGOVER_TIME 300 // drops almost no commas, quite good
//#define VA_HANGOVER_TIME 275 // drops about half of the commas
//#define VA_HANGOVER_TIME 250 // commas are always dropped

// macros to avoid clib dependencies
#define DV_ABS(a) ((a) < 0 ? -(a) : (a))
#define DV_MAX(a, b) ((a) > (b) ? (a) : (b))
#define DV_MIN(a, b) ((a) < (b) ? (a) : (b))

// A function to lookup the log of n base 1.354 (sort of)
// where 0 <= n <= 127
//
// Why the heck do we care about log n base 1.354???
//
// What we need is a function that maps 0 to 127 down to 0 to 15
// in a nice, smooth non-linear fashion that has more fidelity at
// the low end than at the high end.
//
// The function is actually floor(log(n, 1.354), 1) to keep things
// in the integer realm.
//
// Why 1.354? Because log(128, 1.354) = 16, so we are using the full
// range from 0 to 15.
// 
// This function also cheats and just defines fn(0) = 0 and fn(1) = 1
// for convenience.
BYTE DV_LOG_1_354_lookup_table[95] = 
{
	 0,  1,  2,  3,  4,  5,  5,  6,	//   0..  7
	 6,  7,  7,  7,  8,  8,  8,  8, //   8.. 15
	 9,  9,  9,  9,  9, 10, 10, 10, //  16.. 23
	10, 10, 10, 10, 10, 11, 11, 11,	//  24.. 31
	11, 11, 11, 11, 11, 11, 12, 12, //  32.. 39
	12, 12, 12, 12, 12, 12, 12, 12, //  40.. 47
	12, 12, 12, 12, 13, 13, 13, 13, //  48.. 55
	13, 13, 13, 13, 13, 13, 13, 13, //  56.. 63
	13, 13, 13, 13, 13, 13, 14, 14, //  64.. 71
	14, 14, 14, 14, 14, 14, 14, 14, //  72.. 79
	14, 14, 14, 14, 14, 14, 14, 14, //  80.. 87
	14, 14, 14, 14, 14, 14, 14		//  88.. 94 - stop table at 94 here, everything above is 15
};

BYTE DV_log_1_354(BYTE n)
{
	if (n > 94) return 15;
	return DV_LOG_1_354_lookup_table[n];
}

// function to lookup the base 2 log of (n) where n is 16 bits unsigned
// except that we cheat and say that log_2 of zero is zero
// and we chop of any decimals.
BYTE DV_log_2(WORD n)
{
	if (n & 0x8000)
	{
		return 0x0f;
	}
	if (n & 0x4000)
	{
		return 0x0e;
	}
	if (n & 0x2000)
	{
		return 0x0d;
	}
	if (n & 0x1000)
	{
		return 0x0c;
	}
	if (n & 0x0800)
	{
		return 0x0b;
	}
	if (n & 0x0400)
	{
		return 0x0a;
	}
	if (n & 0x0200)
	{
		return 0x09;
	}
	if (n & 0x0100)
	{
		return 0x08;
	}
	if (n & 0x0080)
	{
		return 0x07;
	}
	if (n & 0x0040)
	{
		return 0x06;
	}
	if (n & 0x0020)
	{
		return 0x05;
	}
	if (n & 0x0010)
	{
		return 0x04;
	}
	if (n & 0x0008)
	{
		return 0x03;
	}
	if (n & 0x0004)
	{
		return 0x02;
	}
	if (n & 0x0002)
	{
		return 0x01;
	}
	return 0x00;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::Init"
//
// Init - initializes the AGC and VA algorithms, including loading saved
// values from registry.
//
// dwFlags - the dwFlags from the dvClientConfig structure
// guidCaptureDevice - the capture device we're performing AGC for
// plInitVolume - the initial volume level is written here
//
HRESULT CAGCVA1::Init(
	const WCHAR *wszBasePath,
	DWORD dwFlags, 
	GUID guidCaptureDevice,
	int iSampleRate,
	int iBitsPerSample,
	LONG* plInitVolume,
	DWORD dwSensitivity)
{
	// Remember the number of bits per sample, if valid
	if (iBitsPerSample != 8 && iBitsPerSample != 16)
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Unexpected number of bits per sample!");
		return DVERR_INVALIDPARAM;
	}
	m_iBitsPerSample = iBitsPerSample;

	// Remember the flags
	m_dwFlags = dwFlags;

	// Remember the sensitivity
	m_dwSensitivity = dwSensitivity;

	// Figure out the shift constants for this sample rate
	m_iShiftConstantFast = (DV_log_2((iSampleRate * 2) / 1000) + 1);

	// This gives the slow filter a cutoff frequency 1/4 of 
	// the fast filter
	m_iShiftConstantSlow = m_iShiftConstantFast + 2;

	// Figure out how often we should sample the envelope signal
	// to measure its change. This of course depends on the sample
	// rate. The cutoff frequency allowed by the calculation
	// above is between 40 and 80 Hz. Therefore we'll sample the 
	// envelope signal at about 100 Hz.
	m_iEnvelopeSampleRate = iSampleRate / 100;

	// Figure out the number of samples in the configured
	// hangover time.
	m_iHangoverSamples = (VA_HANGOVER_TIME * iSampleRate) / 1000;
	m_iCurHangoverSamples = m_iHangoverSamples+1;

	// Figure out the number of samples in the configured dead zone time
	m_iDeadZoneSampleThreshold = (AGC_DEADZONE_TIME * iSampleRate) / 1000;

	// Figure out the number of samples in the configured
	// feedback threshold time.
	m_iFeedbackSamples = (AGC_FEEDBACK_TIME_THRESHOLD * iSampleRate) / 1000;
	m_iPossibleFeedbackSamples = 0;

	// Start the envelope signal at zero
	m_iCurEnvelopeValueFast = 0;
	m_iCurEnvelopeValueSlow = 0;
	m_iPrevEnvelopeSample = 0;
	m_iCurSampleNum = 0;

	// We're not clipping now
	//m_fClipping = 0;
	//m_iClippingCount = 0;

	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:INIT:%i,%i,%i,%i,%i", 
		iSampleRate,
		m_iShiftConstantFast,
		m_iShiftConstantSlow,
		m_iEnvelopeSampleRate, 
		m_iHangoverSamples);
	
	// Save the guid in our local member...
	m_guidCaptureDevice = guidCaptureDevice;

	wcscpy( m_wszRegPath, wszBasePath );
	wcscat( m_wszRegPath, DPVOICE_REGISTRY_AGC );
	
	// if the AGC reset flag is set, reset the AGC parameters,
	// otherwise grab them from the registry
	if (m_dwFlags & DVCLIENTCONFIG_AUTOVOLUMERESET)
	{
		m_lCurVolume = DSBVOLUME_MAX;
	}
	else
	{
		CRegistry cregBase;
		if( !cregBase.Open( HKEY_CURRENT_USER, m_wszRegPath, FALSE, TRUE ) )
		{
			m_lCurVolume = DSBVOLUME_MAX;
		}
		else
		{
			CRegistry cregCapture;
			if (!cregCapture.Open( cregBase.GetHandle(), &m_guidCaptureDevice ), FALSE, TRUE )
			{
				m_lCurVolume = DSBVOLUME_MAX;
			}
			if (!cregCapture.ReadDWORD( DPVOICE_REGISTRY_SAVEDAGCLEVEL, (DWORD&)m_lCurVolume ))
			{
				m_lCurVolume = DSBVOLUME_MAX;
			}
			else
			{
				// boost the saved volume a bit
				m_lCurVolume += AGC_VOLUME_INITIAL_UPTICK;
				if (m_lCurVolume > DSBVOLUME_MAX)
				{
					m_lCurVolume = DSBVOLUME_MAX;
				}
			}
		}
	}

	/*
	// zero out the historgrams
	memset(m_rgdwPeakHistogram, 0, CAGCVA1_HISTOGRAM_BUCKETS*sizeof(DWORD));
	memset(m_rgdwZeroCrossingsHistogram, 0, CAGCVA1_HISTOGRAM_BUCKETS*sizeof(DWORD));
	*/

	// allocate the memory for the AGC history
	m_rgfAGCHistory = new float[AGC_VOLUME_LEVELS];
	if (m_rgfAGCHistory == NULL)
	{
		return DVERR_OUTOFMEMORY;
	}

	// initialize the history to the ideal value
	for (int iIndex = 0; iIndex < AGC_VOLUME_LEVELS; ++iIndex)
	{
		m_rgfAGCHistory[iIndex] = (float)AGC_IDEAL_CLIPPING_RATIO;
	}

	m_dwHistorySamples = (iSampleRate * AGC_CLIPPING_HISTORY) / 1000;

	m_iPossibleFeedbackSamples = 0;

	// stuff the initial volume into the caller's variable
	*plInitVolume = m_lCurVolume;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::Deinit"
//
// Deinit - saves the current AGC and VA state to the registry for use next session
//
HRESULT CAGCVA1::Deinit()
{
	HRESULT hr = DV_OK;
	CRegistry cregBase;
	if(cregBase.Open( HKEY_CURRENT_USER, m_wszRegPath, FALSE, TRUE ) )
	{
		CRegistry cregDevice;
		if (cregDevice.Open( cregBase.GetHandle(), &m_guidCaptureDevice, FALSE, TRUE))
		{
			if (!cregDevice.WriteDWORD( DPVOICE_REGISTRY_SAVEDAGCLEVEL, (DWORD&)m_lCurVolume ))
			{
				DPFX(DPFPREP,DVF_ERRORLEVEL, "Error writing AGC settings to registry");
				hr = DVERR_WIN32;
			}
		}
		else 
		{
			DPFX(DPFPREP,DVF_ERRORLEVEL, "Error writing AGC settings to registry");
			hr = DVERR_WIN32;
		}
	}
	else
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Error writing AGC settings to registry");
		hr = DVERR_WIN32;
	}

	delete [] m_rgfAGCHistory;
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::SetSensitivity"
HRESULT CAGCVA1::SetSensitivity(DWORD dwFlags, DWORD dwSensitivity)
{
	if (dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED)
	{
		m_dwFlags |= DVCLIENTCONFIG_AUTOVOICEACTIVATED;
	}
	else
	{
		m_dwFlags &= ~DVCLIENTCONFIG_AUTOVOICEACTIVATED;
	}
	m_dwSensitivity = dwSensitivity;
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::GetSensitivity"
HRESULT CAGCVA1::GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity)
{
	if (m_dwFlags & DVCLIENTCONFIG_AUTORECORDVOLUME)
	{
		*pdwFlags |= DVCLIENTCONFIG_AUTORECORDVOLUME;
	}
	else
	{
		*pdwFlags &= ~DVCLIENTCONFIG_AUTORECORDVOLUME;
	}
	*pdwSensitivity = m_dwSensitivity;
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::AnalyzeData"
//
// AnaylzeData - performs the AGC & VA calculations on one frame of audio
//
// pbAudioData - pointer to a buffer containing the audio data
// dwAudioDataSize - size, in bytes, of the audio data
//
HRESULT CAGCVA1::AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize /*, DWORD dwFrameTime*/)
{
	int iMaxValue;
	//int iValue;
	int iValueAbs;
	//int iZeroCrossings;
	int iIndex;
	int iMaxPossiblePeak;
	int iNumberOfSamples;
	//BYTE bPeak255;

	//m_dwFrameTime = dwFrameTime;

	if (dwAudioDataSize < 1)
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Error: Audio Data Size < 1");
		return DVERR_INVALIDPARAM;
	}

	/*
	// zip through the data, find the peak value and zero crossings
	if (m_iBitsPerSample == 8)
	{	
		iPrevValue = 0;
		iZeroCrossings = 0;
		iMaxValue = 0;
		iNumberOfSamples = dwAudioDataSize;
		for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)
		{
			iValue = (int)pbAudioData[iIndex] - 0x7F;
			if (iValue * iPrevValue < 0)
			{
				++iZeroCrossings;
			}
			iPrevValue = iValue;
			
			iMaxValue = DV_MAX(DV_ABS(iValue), iMaxValue);
		}

		iMaxPossiblePeak = 0x7F;
	}
	else if (m_iBitsPerSample == 16)
	{
		// cast the audio data to signed 16 bit integers
		signed short* psiAudioData = (signed short *)pbAudioData;
		// halve the number of samples
		iNumberOfSamples = dwAudioDataSize / 2;

		iPrevValue = 0;
		iZeroCrossings = 0;
		iMaxValue = 0;
		for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)
		{
			iValue = (int)psiAudioData[iIndex];
			if (iValue * iPrevValue < 0)
			{
				++iZeroCrossings;
			}
			iPrevValue = iValue;
			
			iMaxValue = DV_MAX(DV_ABS(iValue), iMaxValue);
		}

		iMaxPossiblePeak = 0x7FFF;
	}
	else
	{
		DPFX(DPFPREP,DVF_ERRORLEVEL, "Unexpected number of bits per sample!");
		iMaxValue = 0;
		iZeroCrossings = 0;
	}
	*/

	/*
	// normalize the peak value to the range DVINPUTLEVEL_MIN to DVINPUTLEVEL_MAX
	m_bPeak = (BYTE)(DVINPUTLEVEL_MIN + ((iMaxValue * (DVINPUTLEVEL_MAX - DVINPUTLEVEL_MIN)) / iMaxPossiblePeak));
	
	// normalize zero crossings and peak to the range 0 to 127 (0x7f)
	m_bZeroCrossings127 = (iZeroCrossings * 0x7f) / iIndex;
	m_bPeak127 = (iMaxValue * 0x7f) / iMaxPossiblePeak;

	// take the log base 1.354 of the peak and zero crossing
	m_bPeakLog = DV_log_1_354(m_bPeak127);
	m_bZeroCrossingsLog = DV_log_1_354(m_bZeroCrossings127);

	// update the histograms
	++m_rgdwPeakHistogram[m_bPeakLog];
	++m_rgdwZeroCrossingsHistogram[m_bZeroCrossingsLog];
	
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:ANA:PZ,%i,%i,%i,%i,%i,%i", 
		m_bPeak,
		m_bPeak127, 
		m_bPeakLog, 
		iZeroCrossings,
		m_bZeroCrossings127, 
		m_bZeroCrossingsLog
		);
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:ANAHP,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i",
		m_rgdwPeakHistogram[0x00],
		m_rgdwPeakHistogram[0x01],
		m_rgdwPeakHistogram[0x02],
		m_rgdwPeakHistogram[0x03],
		m_rgdwPeakHistogram[0x04],
		m_rgdwPeakHistogram[0x05],
		m_rgdwPeakHistogram[0x06],
		m_rgdwPeakHistogram[0x07],
		m_rgdwPeakHistogram[0x08],
		m_rgdwPeakHistogram[0x09],
		m_rgdwPeakHistogram[0x0a],
		m_rgdwPeakHistogram[0x0b],
		m_rgdwPeakHistogram[0x0c],
		m_rgdwPeakHistogram[0x0d],
		m_rgdwPeakHistogram[0x0e],
		m_rgdwPeakHistogram[0x0f]);
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:ANAHZ,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i",
		m_rgdwZeroCrossingsHistogram[0x00],
		m_rgdwZeroCrossingsHistogram[0x01],
		m_rgdwZeroCrossingsHistogram[0x02],
		m_rgdwZeroCrossingsHistogram[0x03],
		m_rgdwZeroCrossingsHistogram[0x04],
		m_rgdwZeroCrossingsHistogram[0x05],
		m_rgdwZeroCrossingsHistogram[0x06],
		m_rgdwZeroCrossingsHistogram[0x07],
		m_rgdwZeroCrossingsHistogram[0x08],
		m_rgdwZeroCrossingsHistogram[0x09],
		m_rgdwZeroCrossingsHistogram[0x0a],
		m_rgdwZeroCrossingsHistogram[0x0b],
		m_rgdwZeroCrossingsHistogram[0x0c],
		m_rgdwZeroCrossingsHistogram[0x0d],
		m_rgdwZeroCrossingsHistogram[0x0e],
		m_rgdwZeroCrossingsHistogram[0x0f]);
	*/


	// new algorithm...

	// cast the audio data to signed 16 bit integers
	signed short* psiAudioData = (signed short *)pbAudioData;

	if (m_iBitsPerSample == 16)
	{
		iNumberOfSamples = dwAudioDataSize / 2;
		iMaxPossiblePeak = 0x7fff;
	}
	else
	{
		iNumberOfSamples = dwAudioDataSize;
		iMaxPossiblePeak = 0x7f00;
	}

	m_fDeadZoneDetected = TRUE;
	m_iClippingSampleCount = 0;
	m_iNonClippingSampleCount = 0;
	m_fVoiceDetectedThisFrame = FALSE;
	iMaxValue = 0;
	for (iIndex = 0; iIndex < (int)iNumberOfSamples; ++iIndex)
	{
		++m_iCurSampleNum;

		// extract a sample
		if (m_iBitsPerSample == 8)
		{
			iValueAbs = DV_ABS((int)pbAudioData[iIndex] - 0x80);
			// promote it to 16 bits
			iValueAbs <<= 8;
		}
		else
		{
			iValueAbs = DV_ABS((int)psiAudioData[iIndex]);
		}

		// see if it is the new peak value
		iMaxValue = DV_MAX(iValueAbs, iMaxValue);

		// do the low pass filtering, but only if we are in autosensitivity mode
		int iNormalizedCurEnvelopeValueFast;
		int iNormalizedCurEnvelopeValueSlow;
		if (m_dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED)
		{
			m_iCurEnvelopeValueFast = 
				iValueAbs + 
				(m_iCurEnvelopeValueFast - (m_iCurEnvelopeValueFast >> m_iShiftConstantFast));
			iNormalizedCurEnvelopeValueFast = m_iCurEnvelopeValueFast >> m_iShiftConstantFast;

			m_iCurEnvelopeValueSlow = 
				iValueAbs + 
				(m_iCurEnvelopeValueSlow - (m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow));
			iNormalizedCurEnvelopeValueSlow = m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow;

			// check to see if we consider this voice
			if (iNormalizedCurEnvelopeValueFast > VA_LOW_ENVELOPE &&
				(iNormalizedCurEnvelopeValueFast > VA_HIGH_ENVELOPE ||
				iNormalizedCurEnvelopeValueFast > (VA_HIGH_PERCENT * iNormalizedCurEnvelopeValueSlow) / 100 || 
				iNormalizedCurEnvelopeValueFast < (VA_LOW_PERCENT * iNormalizedCurEnvelopeValueSlow) / 100 ))
			{
				m_fVoiceDetectedNow = TRUE;
				m_fVoiceDetectedThisFrame = TRUE;
				m_fVoiceHangoverActive = TRUE;
				m_iCurHangoverSamples = 0;
			}
			else
			{
				m_fVoiceDetectedNow = FALSE;
				++m_iCurHangoverSamples;
				if (m_iCurHangoverSamples > m_iHangoverSamples)
				{
					m_fVoiceHangoverActive = FALSE;
				}
				else
				{
					m_fVoiceHangoverActive = TRUE;
					m_fVoiceDetectedThisFrame = TRUE;
				}
			}
		}

		/*
		DPFX(DPFPREP,DVF_WARNINGLEVEL, "AGCVA1:VA,%i,%i,%i,%i,%i,%i", 
			iValueAbs,
			iNormalizedCurEnvelopeValueFast, 
			iNormalizedCurEnvelopeValueSlow,
			m_fVoiceDetectedNow,
			m_fVoiceHangoverActive,
			m_fVoiceDetectedThisFrame);		
		*/

		// check for clipping
		if (iValueAbs > AGC_PEAK_CLIPPING_THRESHOLD)
		{
			++m_iClippingSampleCount;
		}
		else
		{
			++m_iNonClippingSampleCount;
		}

		// check for possible feedback condition
		/*		
		if (m_iCurEnvelopeValueFast >> m_iShiftConstantFast > AGC_FEEDBACK_ENV_THRESHOLD)
		{
			++m_iPossibleFeedbackSamples;
		}
		else
		{
			m_iPossibleFeedbackSamples = 0;
		}
		*/

		/*
		// see if this is a sample point
		if (m_iCurSampleNum % m_iEnvelopeSampleRate == 0)
		{
			// calculate the change since the last sample - normalize to 16 bits
			// int iDelta = DV_ABS(m_iCurEnvelopeValueFast - m_iPrevEnvelopeSample) >> iShiftConstant;
			int iDelta;
			if (m_iPrevEnvelopeSample != 0)
			{
				iDelta = (1000 * m_iCurEnvelopeValueFast) / m_iPrevEnvelopeSample;
			}
			else
			{
				iDelta = 1000;
			}

			DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:ANA:ENV,%i,%i",
				m_iCurEnvelopeValueFast >> m_iShiftConstantFast,
				iDelta);

			// check to see if we consider this voice
			if (m_iCurEnvelopeValueFast >> m_iShiftConstantFast > VA_LOW_ENVELOPE &&
				(iDelta > VA_HIGH_DELTA || 
				iDelta < VA_LOW_DELTA || 
				m_iCurEnvelopeValueFast >> m_iShiftConstantFast > VA_HIGH_ENVELOPE))
			{
				m_fVoiceDetectedNow = TRUE;
				m_fVoiceDetectedThisFrame = TRUE;
				m_fVoiceHangoverActive = TRUE;
				m_iCurHangoverSamples = 0;
			}
			else
			{
				m_fVoiceDetectedNow = FALSE;
				m_iCurHangoverSamples += m_iEnvelopeSampleRate;
				if (m_iCurHangoverSamples > m_iHangoverSamples)
				{
					m_fVoiceHangoverActive = FALSE;
				}
				else
				{
					m_fVoiceHangoverActive = TRUE;
					m_fVoiceDetectedThisFrame = TRUE;
				}
			}

			// check for possible feedback condition
			if (m_iCurEnvelopeValueFast >> m_iShiftConstantFast > AGC_FEEDBACK_ENV_THRESHOLD)
			{
				m_iPossibleFeedbackSamples += m_iEnvelopeSampleRate;
			}
			else
			{
				m_iPossibleFeedbackSamples = 0;
			}
			
			DPFX(DPFPREP,DVF_WARNINGLEVEL, "AGCVA1:VA,%i,%i,%i,%i,%i,%i,%i", 
				m_iCurEnvelopeValueFast >> m_iShiftConstantFast, 
				m_iCurEnvelopeValueSlow >> m_iShiftConstantSlow,
				iDeltaFastSlow,
				iDelta,
				m_fVoiceDetectedNow,
				m_fVoiceHangoverActive,
				m_fVoiceDetectedThisFrame);

			m_iPrevEnvelopeSample = m_iCurEnvelopeValueFast;
		}
		*/
	}

	// Normalize the peak value to the range DVINPUTLEVEL_MIN to DVINPUTLEVEL_MAX
	// This is what is returned for caller's peak meters...
	m_bPeak = (BYTE)(DVINPUTLEVEL_MIN + 
		((iMaxValue * (DVINPUTLEVEL_MAX - DVINPUTLEVEL_MIN)) / iMaxPossiblePeak));

	// if we are in manual VA mode (not autovolume) check the peak against
	// the sensitivity threshold
	if (!(m_dwFlags & DVCLIENTCONFIG_AUTOVOICEACTIVATED))
	{
		if (m_bPeak > m_dwSensitivity)
		{
			m_fVoiceDetectedThisFrame = TRUE;
		}
	}

	// Check if we're in a deadzone
	if (iMaxValue > AGC_DEADZONE_THRESHOLD)
	{
		m_fDeadZoneDetected = FALSE;
	}


	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:ANA,%i,%i,%i,%i,%i,%i,%i", 
		m_bPeak,
		iMaxValue,
		m_fVoiceDetectedThisFrame,
		m_fDeadZoneDetected,
		m_iClippingSampleCount,
		m_iNonClippingSampleCount,
		m_iPossibleFeedbackSamples);
	
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::AGCResults"
//
// AGCResults - returns the AGC results from the previous AnalyzeFrame call
//
// lCurVolume - the current recording volume
// plNewVolume - stuffed with the desired new recording volume
//
HRESULT CAGCVA1::AGCResults(LONG lCurVolume, LONG* plNewVolume, BOOL fTransmitFrame)
{
	// default to keeping the same volume
    *plNewVolume = lCurVolume;

	// Figure out what volume level we're at
	int iVolumeLevel = DV_MIN(DV_ABS(AGC_VOLUME_MAXIMUM - lCurVolume) / AGC_VOLUME_TICKSIZE,
								AGC_VOLUME_LEVELS - 1);

    //DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1:AGC,Cur Volume:%i,%i",lCurVolume, iVolumeLevel);

    // Don't make another adjustment if we have just done one.
    // This ensures that when we start looking at input data
    // again, it will be post-adjustment data.
    if( m_fAGCLastFrameAdjusted )
    {
		//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,Previous frame adjusted, no AGC this frame");
        m_fAGCLastFrameAdjusted = FALSE;
    }
    else
    {
    	// check for a dead zone condition
    	if (m_fDeadZoneDetected /* || m_rgfAGCHistory[iVolumeLevel] == 0.0 */)
    	{
    		// We may be in the dead zone (volume way too low).
    		// Before we take the drastic action of sweepting the volume
    		// up, make sure we've been here long enough to be sure
    		// we're too low.
    		m_iDeadZoneSamples += (m_iClippingSampleCount + m_iNonClippingSampleCount);
    		if (m_iDeadZoneSamples > m_iDeadZoneSampleThreshold)
    		{
				// The input volume has been lowered too far. We're not
				// getting any input at all. To remedy this situation,
				// we'll boost the volume now, but we'll also mark this
				// volume level as off limits by setting its history to 
				// zero. That will prevent the volume from ever being
				// dropped to this level again during this session.
				if (iVolumeLevel != 0)
				{
					// We also reset the history of the volume level we are going to,
					// so we start with a clean slate.
					m_rgfAGCHistory[iVolumeLevel-1] = (const float)AGC_IDEAL_CLIPPING_RATIO;
					*plNewVolume = DV_MIN(lCurVolume + AGC_VOLUME_TICKSIZE, AGC_VOLUME_MAXIMUM);
					m_fAGCLastFrameAdjusted = TRUE;
				}
    		}
    	}
    	else
    	{
    		m_iDeadZoneSamples = 0;
    	}

    	// check for a feedback condition
    	if (m_iPossibleFeedbackSamples > m_iFeedbackSamples)
    	{
			// we have feedback. take the volume down a tick, but only if the
			// next tick down is not off limits due to a dead zone, and we're
			// not already on the lowest tick.
			if (iVolumeLevel < AGC_VOLUME_LEVELS - 1) 
			{
				*plNewVolume = DV_MAX(lCurVolume - AGC_VOLUME_TICKSIZE, AGC_VOLUME_MINIMUM);
				m_fAGCLastFrameAdjusted = TRUE;
				
				// Also adjust this level's history, so it will be hard to 
				// get back up to this bad feedback level. Pretend we just
				// clipped on 100% of the samples in this frame.
				m_rgfAGCHistory[iVolumeLevel] = 
					(m_iClippingSampleCount + m_iNonClippingSampleCount + (m_rgfAGCHistory[iVolumeLevel] * m_dwHistorySamples))
					/ (m_iClippingSampleCount + m_iNonClippingSampleCount + m_dwHistorySamples);
			}
    	}
		else if (fTransmitFrame)
		{
			// Factor this frame's clipping ratio into the appropriate history bucket
			m_rgfAGCHistory[iVolumeLevel] = 
				(m_iClippingSampleCount + (m_rgfAGCHistory[iVolumeLevel] * m_dwHistorySamples))
				/ (m_iClippingSampleCount + m_iNonClippingSampleCount + m_dwHistorySamples);
			
			if (m_rgfAGCHistory[iVolumeLevel] > AGC_IDEAL_CLIPPING_RATIO)
			{
				// Only consider lowering the volume if we clipped on this frame.
				if (m_iClippingSampleCount > 0)
				{
					// we're clipping too much at this level, consider reducing
					// the volume.
					if (iVolumeLevel >= AGC_VOLUME_LEVELS - 1)
					{
						// we're already at the lowest volume level that we have
						// a bucket for. Make sure we're clamped to the minimum
		                if (lCurVolume > AGC_VOLUME_MINIMUM)
		                {
		                	*plNewVolume = AGC_VOLUME_MINIMUM;
		                	m_fAGCLastFrameAdjusted = TRUE;
							//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,too much clipping, clamping volume to min: %i", *plNewVolume);
		                }
					}
					else
					{
						// Choose either this volume level, or the next lower
						// one, depending on which has the history that is 
						// closest to the ideal.
						float fCurDistanceFromIdeal = (float)(m_rgfAGCHistory[iVolumeLevel] / AGC_IDEAL_CLIPPING_RATIO);
						if (fCurDistanceFromIdeal < 1.0)
						{
							fCurDistanceFromIdeal = (float)(1.0 / fCurDistanceFromIdeal);
						}

						float fLowerDistanceFromIdeal = (float)(m_rgfAGCHistory[iVolumeLevel+1] / (float)AGC_IDEAL_CLIPPING_RATIO);
						if (fLowerDistanceFromIdeal < 1.0)
						{
							fLowerDistanceFromIdeal = (float)(1.0 / fLowerDistanceFromIdeal);
						}

						if (fLowerDistanceFromIdeal < fCurDistanceFromIdeal
							&& fCurDistanceFromIdeal > AGC_CHANGE_THRESHOLD)
						{
							// The next lower volume level is closer to the ideal
							// clipping ratio. Take the volume down a tick.
							*plNewVolume = DV_MAX(lCurVolume - AGC_VOLUME_TICKSIZE, AGC_VOLUME_MINIMUM);
							m_fAGCLastFrameAdjusted = TRUE;
							//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,too much clipping, setting volume to: %i", *plNewVolume);
						}
					}
				}
			}
			else
			{
				// we're clipping too little at this level, consider increasing
				// the volume.
				if (iVolumeLevel == 0)
				{
					// We're already at the highest volume level.
					// Make sure we're at the max
					if (lCurVolume != AGC_VOLUME_MAXIMUM)
					{
	                	*plNewVolume = AGC_VOLUME_MAXIMUM;
						m_fAGCLastFrameAdjusted = TRUE;
						//DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,too little clipping, clamping volume to max: %i", *plNewVolume);
					}
				}
				else
				{
					// We always increase the volume in this case, and let it push back down if
					// it clips again. This will continue testing the upper volume limit, and
					// help dig us out of "too low" volume holes.
					*plNewVolume = DV_MIN(lCurVolume + AGC_VOLUME_TICKSIZE, AGC_VOLUME_MAXIMUM);
					m_fAGCLastFrameAdjusted = TRUE;
				}
			}
			
			/*
			// see if we clipped on the last analysis pass
			if (m_fClipping)
			{
	            DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1: Above reduction threshold, reducing volume level\n" );
	            if( lCurVolume > AGC_VOLUME_MINIMUM )
	            {
	                *plNewVolume = lCurVolume - AGC_VOLUME_DOWNTICK;
	                m_fAGCLastFrameAdjusted = TRUE;
	                m_dwAGCBelowThresholdTime = 0;
	            }
	            
	            // check to make sure we didn't just make it too low...
				if( *plNewVolume < AGC_VOLUME_MINIMUM )
	            {
	                DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1: Clamping volume to Min\n" );
	                *plNewVolume = AGC_VOLUME_MINIMUM;
	            }
	        }
	        */

			/*
			// The input level can fall into one of three ranges:
			// Above AGC_REDUCTION_THRESHOLD 
			// 		- this means we're probably clipping
			// Between AGC_REDUCTION_THRESHOLD and AGC_INCREASE_THRESHOLD 
			// 		- this is the happy place
			// Below AGC_INCREASE_THRESHOLD
			//		- the input is pretty quiet, we should *consider* raising the input volume.
			if (m_bPeak > AGC_REDUCTION_THRESHOLD)
			{
				// Too high! Reduce the volume and then reset the AGC state
				// variables.
	            DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1: Above reduction threshold, reducing volume level\n" );
	            if( lCurVolume > AGC_VOLUME_MINIMUM )
	            {
	                *plNewVolume = lCurVolume - AGC_VOLUME_DOWNTICK;
	                //m_fAGCLastFrameAdjusted = TRUE;
	                m_dwAGCBelowThresholdTime = 0;
	            }
	            
	            // check to make sure we didn't just make it too low...
				if( *plNewVolume < AGC_VOLUME_MINIMUM )
	            {
	                DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1: Clamping volume to Min\n" );
	                *plNewVolume = AGC_VOLUME_MINIMUM;
	            }
			}
			else if (m_bPeak < AGC_INCREASE_THRESHOLD)
			{
				// Increase the time that the input has been too quiet
				m_dwAGCBelowThresholdTime += m_dwFrameTime;
				DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1: Now below increase threshold for %i milliseconds", m_dwAGCBelowThresholdTime);

				// If things have been too quiet for too long, raise the
				// volume level a tick, assuming we're not already maxed,
				// then reset the AGC state vars
                if( m_dwAGCBelowThresholdTime >= AGC_INCREASE_THRESHOLD_TIME &&
                	lCurVolume < AGC_VOLUME_MAXIMUM )
                {
                    DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1: Boosting volume level\n" );
                    *plNewVolume = lCurVolume + AGC_VOLUME_UPTICK;
                    //m_fAGCLastFrameAdjusted = TRUE;
                    m_dwAGCBelowThresholdTime = 0;
                    
                    // check to make sure we didn't just make it too high...
					if( *plNewVolume > AGC_VOLUME_MAXIMUM )
	                {
	                    DPFX(DPFPREP, DVF_INFOLEVEL, "AGCVA1: Clamping volume to Max\n" );
	                    *plNewVolume = AGC_VOLUME_MAXIMUM;
	                }
                }
            }
			else
			{
				// We are nicely in the sweet spot. Not too loud, not too soft. Reset
				// the below threshold count.
				m_dwAGCBelowThresholdTime = 0;
				DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1: between thresholds, resetting below threshold time: %i", m_dwAGCBelowThresholdTime);
			}
			*/
		}
	}

	m_lCurVolume = *plNewVolume;
	
	// dump profiling data, in an easily importable format
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1:AGC,%i,%i,%i,%i,%i,%i,%i", 
		m_fVoiceDetectedThisFrame,
		m_fDeadZoneDetected,
		iVolumeLevel,
		(int)(m_rgfAGCHistory[iVolumeLevel]*1000000),
		m_iClippingSampleCount,
		m_iNonClippingSampleCount,
		m_lCurVolume);
    return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::VAResults"
//
// VAResults - returns the VA results from the previous AnalyzeFrame call
//
// pfVoiceDetected - stuffed with TRUE if voice was detected in the data, FALSE otherwise
//
HRESULT CAGCVA1::VAResults(BOOL* pfVoiceDetected)
{
	if (pfVoiceDetected != NULL)
	{
		*pfVoiceDetected = m_fVoiceDetectedThisFrame;
	}
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CAGCVA1::PeakResults"
//
// PeakResults - returns the peak sample value from the previous AnalyzeFrame call,
// 				 normalized to the range 0 to 99
//
// pfPeakValue - pointer to a byte where the peak value is written
//
HRESULT CAGCVA1::PeakResults(BYTE* pbPeakValue)
{
	DPFX(DPFPREP,DVF_INFOLEVEL, "AGCVA1: peak value: %i" , m_bPeak);
	*pbPeakValue = m_bPeak;
	return DV_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\aplayd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aplayd.h
 *  Content:	Definition of the CAudioPlaybackDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects 
 * 12/01/99		rodtoll	Bug #121815 - Recording/Playback may contain static. 
 *						Added abstract call to adjust conversion quality
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy. 
 *
 ***************************************************************************/

#ifndef __AUDIOPLAYBACKDEVICE_H
#define __AUDIOPLAYBACKDEVICE_H

class CAudioPlaybackDevice
{
public:
    CAudioPlaybackDevice( ) {} ;
    virtual ~CAudioPlaybackDevice() {};

public: // Initialization

    virtual HRESULT Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *primaryFormat, BOOL fPriorityMode ) = 0;
    virtual HRESULT CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lpapBuffer ) = 0;  

    virtual BOOL IsEmulated() = 0;
  
    inline WAVEFORMATEX *GetPrimaryFormat() { return m_primaryFormat; };

    virtual LPDIRECTSOUND GetPlaybackDevice() = 0;

    virtual HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality ) = 0;
    virtual HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality ) = 0;

protected:
    WAVEFORMATEX  *m_primaryFormat;			// Format used by the device's mixer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\agcva1.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva1.h
 *  Content:	Concrete class that implements CAutoGainControl
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  12/01/99	pnewson Created it
 *  01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/25/2000  pnewson Fix to improve responsiveness of AGC when volume level too low
 *
 ***************************************************************************/

#ifndef _AGCVA1_H_
#define _AGCVA1_H_

#define CAGCVA1_HISTOGRAM_BUCKETS 0x10

#define CAGCVA1_AGCTICKSIZE		250

class CAGCVA1 : public CAGCVA
{
protected:
	DWORD m_dwFlags;
	DWORD m_dwSensitivity;
    GUID m_guidCaptureDevice;
    LONG m_lCurVolume;
	LONG m_lCurStepSize;
	int m_iSampleRate;
	int m_iBitsPerSample;

	int m_iShiftConstantFast;
	int m_iShiftConstantSlow;
	int m_iEnvelopeSampleRate;
	int m_iCurSampleNum;
	int m_iCurEnvelopeValueFast;
	int m_iCurEnvelopeValueSlow;
	int m_iPrevEnvelopeSample;
	int m_iHangoverSamples;
	int m_iCurHangoverSamples;

	BYTE m_bPeak;
	/*
	BYTE m_bPeak127;
	BYTE m_bPeakLog;
	BYTE m_bZeroCrossings127;
	BYTE m_bZeroCrossingsLog;
	*/

	BOOL m_fVoiceDetectedNow;
	BOOL m_fVoiceHangoverActive;
	BOOL m_fVoiceDetectedThisFrame;

	BOOL m_fDeadZoneDetected;
	int m_iFeedbackSamples;
	int m_iPossibleFeedbackSamples;
	
	/*
	BOOL m_fClipping;
	int m_iClippingCount;
	*/
	int m_iClippingSampleCount;
	int m_iNonClippingSampleCount;

	int m_iDeadZoneSamples;
	int m_iDeadZoneSampleThreshold;

	BOOL m_fAGCLastFrameAdjusted;
	//DWORD m_dwAGCBelowThresholdTime;
	//DWORD m_dwFrameTime;

	float* m_rgfAGCHistory;
	DWORD m_dwHistorySamples;

	WCHAR m_wszRegPath[_MAX_PATH];

	/*
	DWORD m_rgdwPeakHistogram[CAGCVA1_HISTOGRAM_BUCKETS];
	DWORD m_rgdwZeroCrossingsHistogram[CAGCVA1_HISTOGRAM_BUCKETS];
	*/
   
public:
	CAGCVA1()
		: m_guidCaptureDevice(GUID_NULL)
		, m_lCurVolume(0)
		, m_lCurStepSize(0)
		, m_bPeak(0)
		, m_fVoiceDetectedThisFrame(FALSE)
		, m_fVoiceDetectedNow(FALSE)
		//, m_fVoiceDetectedValid(FALSE)
		//, m_fAGCLastFrameAdjusted(FALSE)
		//, m_dwAGCBelowThresholdTime(0)
		//, m_dwFrameTime(0)
		{};

	virtual ~CAGCVA1() {};
	
	virtual HRESULT Init(
		const WCHAR *wszBasePath,
		DWORD dwFlags, 
		GUID guidCaptureDevice, 
		int iSampleRate, 
		int iBitsPerSample,
		LONG* plInitVolume,
		DWORD dwSensitivity);
	virtual HRESULT Deinit();
	virtual HRESULT SetSensitivity(DWORD dwFlags, DWORD dwSensitivity);
	virtual HRESULT GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity);
	virtual HRESULT AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize/*, DWORD dwFrameTime*/);
	virtual HRESULT AGCResults(LONG lCurVolume, LONG* plNewVolume, BOOL fTransmitFrame);
	virtual HRESULT VAResults(BOOL* pfVoiceDetected);
	virtual HRESULT PeakResults(BYTE* pbPeakValue);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\aplayb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		aplayb.h
 *  Content:	Definition of the CAudioPlaybackBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/03/99		rodtoll	Modified to take DirectSound compatible volumes
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1
 *
 ***************************************************************************/

#ifndef __AUDIOPLAYBACKBUFFER_H
#define __AUDIOPLAYBACKBUFFER_H

// Forward definition for the AudioPlaybackDevice include
class CAudioPlaybackBuffer;

// CAudioPlaybackBuffer
//
//
class CAudioPlaybackBuffer
{
public:
    CAudioPlaybackBuffer(  ) {} ;
    virtual ~CAudioPlaybackBuffer() {} ;

public: // Initialization
    virtual HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags ) = 0;
    virtual HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 ) = 0;
    virtual HRESULT SetVolume( LONG lVolume ) = 0;
    virtual HRESULT GetCurrentPosition( LPDWORD lpdwPosition ) = 0;
    virtual HRESULT SetCurrentPosition( DWORD dwPosition ) = 0;
    virtual HRESULT Play( DWORD dwPriority, DWORD dwFlags ) = 0;
    virtual HRESULT Stop() = 0;    
    virtual HRESULT Restore() = 0;

    virtual DWORD GetStartupLatency() = 0;

    virtual HRESULT Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer ) = 0;
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\agcva.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		agcva.h
 *  Content:	Abstract base class for automatic gain control and
 *				voice activation algorithms
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/30/99	pnewson Created it
 *  01/31/2000	pnewson re-add support for absence of DVCLIENTCONFIG_AUTOSENSITIVITY flag
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *  04/25/2000  pnewson Fix to improve responsiveness of AGC when volume level too low
 *
 ***************************************************************************/

#ifndef _AGCVA_H_
#define _AGCVA_H_

// The purpose of this abstract base class is to make it relatively simple to 
// experiment with different AGC (auto gain control) & VA (voice activation) 
// algorithms during development. If used properly, switching algorithms at compile 
// time should be as simple as changing one line of code - the line where the concrete 
// AGC/VA class is created.
//
// Note that this interface is used to perform the AGC and VA calculations, and to save
// and restore algorithm specific settings from the registry. It does not actually 
// adjust the volume on the device. That's the responsibility of the code using
// this class
//
// The AGC and VA algorithms have been bundled into this single interface because
// they often need to perform very similar calculations on the input frame. By combining
// them into one interface, it is possible for them to share the results of frame 
// calculations. 
// 
// Additionally, the AGC algorithm is pretty much "at the mercy" of the VA algorithm, 
// since it presumably will not adjust the volume during periods of silence. 
//
// If you want to experiment with families of AGC and VA algorithms that are meant
// to work together, I suggest creating your own abstract AGC and VA base classes 
// for your family of algoriths, and write a concrete class derived from this one
// that uses your separate abstract AGC and VA algorithms. That way someone won't come
// along and try to plug an AGC or VA algorithm into your framework that does not belong.
//
class CAGCVA
{
public:
	CAGCVA() {};
	virtual ~CAGCVA() {};
	virtual HRESULT Init(
		const WCHAR *wszBasePath,
		DWORD dwFlags, 
		GUID guidCaptureDevice, 
		int iSampleRate, 
		int iBitsPerSample, 
		LONG* plInitVolume,
		DWORD dwSensitivity) = 0;
	virtual HRESULT Deinit() = 0;
	virtual HRESULT SetSensitivity(DWORD dwFlags, DWORD dwSensitivity) = 0;
	virtual HRESULT GetSensitivity(DWORD* pdwFlags, DWORD* pdwSensitivity) = 0;
	virtual HRESULT AnalyzeData(BYTE* pbAudioData, DWORD dwAudioDataSize) = 0;
	virtual HRESULT AGCResults(LONG lCurVolume, LONG* plNewVolume, BOOL fTransmitFrame) = 0;
	virtual HRESULT VAResults(BOOL* pfVoiceDetected) = 0;
	virtual HRESULT PeakResults(BYTE* pbPeakValue) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\astypes.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		astypes.h
 *  Content:	Common data types used by the AudioPlayback and 
 *				AudioRecord systems
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __ASTYPES_H
#define __ASTYPES_H

// ARDeviceInfo
//
// This structure is used to store information about recording and
// playback devices available in the AudioPlayback and AudioRecord
// systems.
//
struct ARDeviceInfo
{
    ARDeviceInfo()
    {
        m_deviceName = _T("");
        m_emulated = false;
    };

    ARDeviceInfo( const ARDeviceInfo &di )
    {
        m_deviceName = di.m_deviceName;
        m_emulated = di.m_emulated;
    };

	BFC_STRING	m_deviceName;
    bool		m_emulated;
};

// ARDID
//
// The AudioPlayback and AudioRecord systems use ARDIDs to provide 
// subsystem independent identification of device selection.  Each
// subsystem (E.g. waveIn or DirectSound) is responsible for mapping
// between ARDID's and subsystem dependent device identifiers.
//
// Software itself works in terms of ARDIDs and stores device selections
// using them.
typedef unsigned char ARDID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\arecb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecb.h
 *  Content:	Definition of the CAudioRecordBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/23/99		rodtoll	Added SelectMicrophone call to the interface
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Added new parameter to SelectMicrophone
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						Added lpfLostFocus param to GetCurrentPosition so upper 
 *						layers can detect lost focus.
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 *
 ***************************************************************************/

#ifndef __AUDIORECORDBUFFER_H
#define __AUDIORECORDBUFFER_H

// CAudioRecordBuffer
//
//
class CAudioRecordBuffer
{
public:
    CAudioRecordBuffer(  ) {} ;
    virtual ~CAudioRecordBuffer() {} ;

public: // Initialization
    virtual HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags ) = 0;
    virtual HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 ) = 0;
    virtual HRESULT GetVolume( LPLONG lplVolume ) = 0;
    virtual HRESULT SetVolume( LONG lVolume ) = 0;
    virtual HRESULT GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus ) = 0;
    virtual HRESULT Record( BOOL fLooping ) = 0;
    virtual HRESULT Stop() = 0;    
    virtual HRESULT SelectMicrophone( BOOL fSelect ) = 0;

	virtual LPWAVEFORMATEX GetRecordFormat() = 0;
    virtual DWORD GetStartupLatency() = 0;

    virtual HRESULT YieldFocus() = 0;
    virtual HRESULT ClaimFocus() = 0;
   
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\arecd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		arecd.h
 *  Content:	Definition of the CAudioRecordDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 11/12/99		rodtoll	Modified abstraction for new waveIN support.
 *						Now abstracted types look almost like dsoundcap objects 
 * 12/01/99		rodtoll	Bug #121815 - Recording/Playback may contain static. 
 *						Added abstract call to adjust conversion quality 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						Added hwndOwner param for capture focus support
 *
 ***************************************************************************/

#ifndef __AUDIORECORDDEVICE_H
#define __AUDIORECORDDEVICE_H

class CAudioRecordDevice;

// CAudioRecordDevice
//
// This class provides an abstract interface for the recording devices in
// the system.  The various subsystems provide implementations of this class
// specific to the subsystem.  Applications use the interface described by this
// class to work with recording devices.
//
// WARNING:
// In many cases you must initialize the playback before you can initialize
// the recording.  Therefore you must create and initialize your 
// CAudioPlaybackDevice BEFORE you create your CAudioRecordDevice object.
// 
class CAudioRecordDevice
{
public:
    CAudioRecordDevice( ) {} ;
    virtual ~CAudioRecordDevice() {} ;

public: // Initialization

    virtual HRESULT Initialize( const GUID &refguidDevice ) = 0;
    virtual HRESULT CreateBuffer( LPDSCBUFFERDESC lpdscBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lpapBuffer ) = 0;    

    virtual LPDIRECTSOUNDCAPTURE GetCaptureDevice() = 0;

    virtual HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality ) = 0;
    virtual HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality ) = 0;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\bfctypes.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		bfctypes.h
 *  Content:	General utility types, particularly strings
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __BFCTYPES_H
#define __BFCTYPES_H

typedef std::basic_string<TCHAR>		BFC_STRING;
#define BFC_STRING_TOLPSTR( x )	x.c_str()
#define BFC_STRING_LENGTH( x ) x.length()
#define BFC_STRING_GETAT( x, y ) x.at( y )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\decibels.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		decibels.h
 *  Content:	Functions to map from dsound volumes to wave volumes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/29/99		rodtoll	Adapted from dsound team's file.
 ***************************************************************************/

#include "dxvutilspch.h"

// ORIGINAL HEADER: 
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

//
// This table covers -96.4 dB to -0.1 dB in 0.1 dB units
//
DWORD tblDBTenthsToAmpFactor[] = {
    0x0000, // (-964/10)dB = 0.000015 * amplitude
    0x0001, // (-963/10)dB = 0.000015 * amplitude
    0x0001, // (-962/10)dB = 0.000015 * amplitude
    0x0001, // (-961/10)dB = 0.000016 * amplitude
    0x0001, // (-960/10)dB = 0.000016 * amplitude
    0x0001, // (-959/10)dB = 0.000016 * amplitude
    0x0001, // (-958/10)dB = 0.000016 * amplitude
    0x0001, // (-957/10)dB = 0.000016 * amplitude
    0x0001, // (-956/10)dB = 0.000017 * amplitude
    0x0001, // (-955/10)dB = 0.000017 * amplitude
    0x0001, // (-954/10)dB = 0.000017 * amplitude
    0x0001, // (-953/10)dB = 0.000017 * amplitude
    0x0001, // (-952/10)dB = 0.000017 * amplitude
    0x0001, // (-951/10)dB = 0.000018 * amplitude
    0x0001, // (-950/10)dB = 0.000018 * amplitude
    0x0001, // (-949/10)dB = 0.000018 * amplitude
    0x0001, // (-948/10)dB = 0.000018 * amplitude
    0x0001, // (-947/10)dB = 0.000018 * amplitude
    0x0001, // (-946/10)dB = 0.000019 * amplitude
    0x0001, // (-945/10)dB = 0.000019 * amplitude
    0x0001, // (-944/10)dB = 0.000019 * amplitude
    0x0001, // (-943/10)dB = 0.000019 * amplitude
    0x0001, // (-942/10)dB = 0.000019 * amplitude
    0x0001, // (-941/10)dB = 0.000020 * amplitude
    0x0001, // (-940/10)dB = 0.000020 * amplitude
    0x0001, // (-939/10)dB = 0.000020 * amplitude
    0x0001, // (-938/10)dB = 0.000020 * amplitude
    0x0001, // (-937/10)dB = 0.000021 * amplitude
    0x0001, // (-936/10)dB = 0.000021 * amplitude
    0x0001, // (-935/10)dB = 0.000021 * amplitude
    0x0001, // (-934/10)dB = 0.000021 * amplitude
    0x0001, // (-933/10)dB = 0.000022 * amplitude
    0x0001, // (-932/10)dB = 0.000022 * amplitude
    0x0001, // (-931/10)dB = 0.000022 * amplitude
    0x0001, // (-930/10)dB = 0.000022 * amplitude
    0x0001, // (-929/10)dB = 0.000023 * amplitude
    0x0001, // (-928/10)dB = 0.000023 * amplitude
    0x0001, // (-927/10)dB = 0.000023 * amplitude
    0x0001, // (-926/10)dB = 0.000023 * amplitude
    0x0001, // (-925/10)dB = 0.000024 * amplitude
    0x0001, // (-924/10)dB = 0.000024 * amplitude
    0x0001, // (-923/10)dB = 0.000024 * amplitude
    0x0001, // (-922/10)dB = 0.000025 * amplitude
    0x0001, // (-921/10)dB = 0.000025 * amplitude
    0x0001, // (-920/10)dB = 0.000025 * amplitude
    0x0001, // (-919/10)dB = 0.000025 * amplitude
    0x0001, // (-918/10)dB = 0.000026 * amplitude
    0x0001, // (-917/10)dB = 0.000026 * amplitude
    0x0001, // (-916/10)dB = 0.000026 * amplitude
    0x0001, // (-915/10)dB = 0.000027 * amplitude
    0x0001, // (-914/10)dB = 0.000027 * amplitude
    0x0001, // (-913/10)dB = 0.000027 * amplitude
    0x0001, // (-912/10)dB = 0.000028 * amplitude
    0x0001, // (-911/10)dB = 0.000028 * amplitude
    0x0001, // (-910/10)dB = 0.000028 * amplitude
    0x0001, // (-909/10)dB = 0.000029 * amplitude
    0x0001, // (-908/10)dB = 0.000029 * amplitude
    0x0001, // (-907/10)dB = 0.000029 * amplitude
    0x0001, // (-906/10)dB = 0.000030 * amplitude
    0x0001, // (-905/10)dB = 0.000030 * amplitude
    0x0001, // (-904/10)dB = 0.000030 * amplitude
    0x0002, // (-903/10)dB = 0.000031 * amplitude
    0x0002, // (-902/10)dB = 0.000031 * amplitude
    0x0002, // (-901/10)dB = 0.000031 * amplitude
    0x0002, // (-900/10)dB = 0.000032 * amplitude
    0x0002, // (-899/10)dB = 0.000032 * amplitude
    0x0002, // (-898/10)dB = 0.000032 * amplitude
    0x0002, // (-897/10)dB = 0.000033 * amplitude
    0x0002, // (-896/10)dB = 0.000033 * amplitude
    0x0002, // (-895/10)dB = 0.000033 * amplitude
    0x0002, // (-894/10)dB = 0.000034 * amplitude
    0x0002, // (-893/10)dB = 0.000034 * amplitude
    0x0002, // (-892/10)dB = 0.000035 * amplitude
    0x0002, // (-891/10)dB = 0.000035 * amplitude
    0x0002, // (-890/10)dB = 0.000035 * amplitude
    0x0002, // (-889/10)dB = 0.000036 * amplitude
    0x0002, // (-888/10)dB = 0.000036 * amplitude
    0x0002, // (-887/10)dB = 0.000037 * amplitude
    0x0002, // (-886/10)dB = 0.000037 * amplitude
    0x0002, // (-885/10)dB = 0.000038 * amplitude
    0x0002, // (-884/10)dB = 0.000038 * amplitude
    0x0002, // (-883/10)dB = 0.000038 * amplitude
    0x0002, // (-882/10)dB = 0.000039 * amplitude
    0x0002, // (-881/10)dB = 0.000039 * amplitude
    0x0002, // (-880/10)dB = 0.000040 * amplitude
    0x0002, // (-879/10)dB = 0.000040 * amplitude
    0x0002, // (-878/10)dB = 0.000041 * amplitude
    0x0002, // (-877/10)dB = 0.000041 * amplitude
    0x0002, // (-876/10)dB = 0.000042 * amplitude
    0x0002, // (-875/10)dB = 0.000042 * amplitude
    0x0002, // (-874/10)dB = 0.000043 * amplitude
    0x0002, // (-873/10)dB = 0.000043 * amplitude
    0x0002, // (-872/10)dB = 0.000044 * amplitude
    0x0002, // (-871/10)dB = 0.000044 * amplitude
    0x0002, // (-870/10)dB = 0.000045 * amplitude
    0x0002, // (-869/10)dB = 0.000045 * amplitude
    0x0002, // (-868/10)dB = 0.000046 * amplitude
    0x0003, // (-867/10)dB = 0.000046 * amplitude
    0x0003, // (-866/10)dB = 0.000047 * amplitude
    0x0003, // (-865/10)dB = 0.000047 * amplitude
    0x0003, // (-864/10)dB = 0.000048 * amplitude
    0x0003, // (-863/10)dB = 0.000048 * amplitude
    0x0003, // (-862/10)dB = 0.000049 * amplitude
    0x0003, // (-861/10)dB = 0.000050 * amplitude
    0x0003, // (-860/10)dB = 0.000050 * amplitude
    0x0003, // (-859/10)dB = 0.000051 * amplitude
    0x0003, // (-858/10)dB = 0.000051 * amplitude
    0x0003, // (-857/10)dB = 0.000052 * amplitude
    0x0003, // (-856/10)dB = 0.000052 * amplitude
    0x0003, // (-855/10)dB = 0.000053 * amplitude
    0x0003, // (-854/10)dB = 0.000054 * amplitude
    0x0003, // (-853/10)dB = 0.000054 * amplitude
    0x0003, // (-852/10)dB = 0.000055 * amplitude
    0x0003, // (-851/10)dB = 0.000056 * amplitude
    0x0003, // (-850/10)dB = 0.000056 * amplitude
    0x0003, // (-849/10)dB = 0.000057 * amplitude
    0x0003, // (-848/10)dB = 0.000058 * amplitude
    0x0003, // (-847/10)dB = 0.000058 * amplitude
    0x0003, // (-846/10)dB = 0.000059 * amplitude
    0x0003, // (-845/10)dB = 0.000060 * amplitude
    0x0003, // (-844/10)dB = 0.000060 * amplitude
    0x0003, // (-843/10)dB = 0.000061 * amplitude
    0x0004, // (-842/10)dB = 0.000062 * amplitude
    0x0004, // (-841/10)dB = 0.000062 * amplitude
    0x0004, // (-840/10)dB = 0.000063 * amplitude
    0x0004, // (-839/10)dB = 0.000064 * amplitude
    0x0004, // (-838/10)dB = 0.000065 * amplitude
    0x0004, // (-837/10)dB = 0.000065 * amplitude
    0x0004, // (-836/10)dB = 0.000066 * amplitude
    0x0004, // (-835/10)dB = 0.000067 * amplitude
    0x0004, // (-834/10)dB = 0.000068 * amplitude
    0x0004, // (-833/10)dB = 0.000068 * amplitude
    0x0004, // (-832/10)dB = 0.000069 * amplitude
    0x0004, // (-831/10)dB = 0.000070 * amplitude
    0x0004, // (-830/10)dB = 0.000071 * amplitude
    0x0004, // (-829/10)dB = 0.000072 * amplitude
    0x0004, // (-828/10)dB = 0.000072 * amplitude
    0x0004, // (-827/10)dB = 0.000073 * amplitude
    0x0004, // (-826/10)dB = 0.000074 * amplitude
    0x0004, // (-825/10)dB = 0.000075 * amplitude
    0x0004, // (-824/10)dB = 0.000076 * amplitude
    0x0005, // (-823/10)dB = 0.000077 * amplitude
    0x0005, // (-822/10)dB = 0.000078 * amplitude
    0x0005, // (-821/10)dB = 0.000079 * amplitude
    0x0005, // (-820/10)dB = 0.000079 * amplitude
    0x0005, // (-819/10)dB = 0.000080 * amplitude
    0x0005, // (-818/10)dB = 0.000081 * amplitude
    0x0005, // (-817/10)dB = 0.000082 * amplitude
    0x0005, // (-816/10)dB = 0.000083 * amplitude
    0x0005, // (-815/10)dB = 0.000084 * amplitude
    0x0005, // (-814/10)dB = 0.000085 * amplitude
    0x0005, // (-813/10)dB = 0.000086 * amplitude
    0x0005, // (-812/10)dB = 0.000087 * amplitude
    0x0005, // (-811/10)dB = 0.000088 * amplitude
    0x0005, // (-810/10)dB = 0.000089 * amplitude
    0x0005, // (-809/10)dB = 0.000090 * amplitude
    0x0005, // (-808/10)dB = 0.000091 * amplitude
    0x0006, // (-807/10)dB = 0.000092 * amplitude
    0x0006, // (-806/10)dB = 0.000093 * amplitude
    0x0006, // (-805/10)dB = 0.000094 * amplitude
    0x0006, // (-804/10)dB = 0.000095 * amplitude
    0x0006, // (-803/10)dB = 0.000097 * amplitude
    0x0006, // (-802/10)dB = 0.000098 * amplitude
    0x0006, // (-801/10)dB = 0.000099 * amplitude
    0x0006, // (-800/10)dB = 0.000100 * amplitude
    0x0006, // (-799/10)dB = 0.000101 * amplitude
    0x0006, // (-798/10)dB = 0.000102 * amplitude
    0x0006, // (-797/10)dB = 0.000104 * amplitude
    0x0006, // (-796/10)dB = 0.000105 * amplitude
    0x0006, // (-795/10)dB = 0.000106 * amplitude
    0x0007, // (-794/10)dB = 0.000107 * amplitude
    0x0007, // (-793/10)dB = 0.000108 * amplitude
    0x0007, // (-792/10)dB = 0.000110 * amplitude
    0x0007, // (-791/10)dB = 0.000111 * amplitude
    0x0007, // (-790/10)dB = 0.000112 * amplitude
    0x0007, // (-789/10)dB = 0.000114 * amplitude
    0x0007, // (-788/10)dB = 0.000115 * amplitude
    0x0007, // (-787/10)dB = 0.000116 * amplitude
    0x0007, // (-786/10)dB = 0.000117 * amplitude
    0x0007, // (-785/10)dB = 0.000119 * amplitude
    0x0007, // (-784/10)dB = 0.000120 * amplitude
    0x0007, // (-783/10)dB = 0.000122 * amplitude
    0x0008, // (-782/10)dB = 0.000123 * amplitude
    0x0008, // (-781/10)dB = 0.000124 * amplitude
    0x0008, // (-780/10)dB = 0.000126 * amplitude
    0x0008, // (-779/10)dB = 0.000127 * amplitude
    0x0008, // (-778/10)dB = 0.000129 * amplitude
    0x0008, // (-777/10)dB = 0.000130 * amplitude
    0x0008, // (-776/10)dB = 0.000132 * amplitude
    0x0008, // (-775/10)dB = 0.000133 * amplitude
    0x0008, // (-774/10)dB = 0.000135 * amplitude
    0x0008, // (-773/10)dB = 0.000136 * amplitude
    0x0009, // (-772/10)dB = 0.000138 * amplitude
    0x0009, // (-771/10)dB = 0.000140 * amplitude
    0x0009, // (-770/10)dB = 0.000141 * amplitude
    0x0009, // (-769/10)dB = 0.000143 * amplitude
    0x0009, // (-768/10)dB = 0.000145 * amplitude
    0x0009, // (-767/10)dB = 0.000146 * amplitude
    0x0009, // (-766/10)dB = 0.000148 * amplitude
    0x0009, // (-765/10)dB = 0.000150 * amplitude
    0x0009, // (-764/10)dB = 0.000151 * amplitude
    0x000A, // (-763/10)dB = 0.000153 * amplitude
    0x000A, // (-762/10)dB = 0.000155 * amplitude
    0x000A, // (-761/10)dB = 0.000157 * amplitude
    0x000A, // (-760/10)dB = 0.000158 * amplitude
    0x000A, // (-759/10)dB = 0.000160 * amplitude
    0x000A, // (-758/10)dB = 0.000162 * amplitude
    0x000A, // (-757/10)dB = 0.000164 * amplitude
    0x000A, // (-756/10)dB = 0.000166 * amplitude
    0x000B, // (-755/10)dB = 0.000168 * amplitude
    0x000B, // (-754/10)dB = 0.000170 * amplitude
    0x000B, // (-753/10)dB = 0.000172 * amplitude
    0x000B, // (-752/10)dB = 0.000174 * amplitude
    0x000B, // (-751/10)dB = 0.000176 * amplitude
    0x000B, // (-750/10)dB = 0.000178 * amplitude
    0x000B, // (-749/10)dB = 0.000180 * amplitude
    0x000B, // (-748/10)dB = 0.000182 * amplitude
    0x000C, // (-747/10)dB = 0.000184 * amplitude
    0x000C, // (-746/10)dB = 0.000186 * amplitude
    0x000C, // (-745/10)dB = 0.000188 * amplitude
    0x000C, // (-744/10)dB = 0.000191 * amplitude
    0x000C, // (-743/10)dB = 0.000193 * amplitude
    0x000C, // (-742/10)dB = 0.000195 * amplitude
    0x000C, // (-741/10)dB = 0.000197 * amplitude
    0x000D, // (-740/10)dB = 0.000200 * amplitude
    0x000D, // (-739/10)dB = 0.000202 * amplitude
    0x000D, // (-738/10)dB = 0.000204 * amplitude
    0x000D, // (-737/10)dB = 0.000207 * amplitude
    0x000D, // (-736/10)dB = 0.000209 * amplitude
    0x000D, // (-735/10)dB = 0.000211 * amplitude
    0x000E, // (-734/10)dB = 0.000214 * amplitude
    0x000E, // (-733/10)dB = 0.000216 * amplitude
    0x000E, // (-732/10)dB = 0.000219 * amplitude
    0x000E, // (-731/10)dB = 0.000221 * amplitude
    0x000E, // (-730/10)dB = 0.000224 * amplitude
    0x000E, // (-729/10)dB = 0.000226 * amplitude
    0x000F, // (-728/10)dB = 0.000229 * amplitude
    0x000F, // (-727/10)dB = 0.000232 * amplitude
    0x000F, // (-726/10)dB = 0.000234 * amplitude
    0x000F, // (-725/10)dB = 0.000237 * amplitude
    0x000F, // (-724/10)dB = 0.000240 * amplitude
    0x000F, // (-723/10)dB = 0.000243 * amplitude
    0x0010, // (-722/10)dB = 0.000245 * amplitude
    0x0010, // (-721/10)dB = 0.000248 * amplitude
    0x0010, // (-720/10)dB = 0.000251 * amplitude
    0x0010, // (-719/10)dB = 0.000254 * amplitude
    0x0010, // (-718/10)dB = 0.000257 * amplitude
    0x0011, // (-717/10)dB = 0.000260 * amplitude
    0x0011, // (-716/10)dB = 0.000263 * amplitude
    0x0011, // (-715/10)dB = 0.000266 * amplitude
    0x0011, // (-714/10)dB = 0.000269 * amplitude
    0x0011, // (-713/10)dB = 0.000272 * amplitude
    0x0012, // (-712/10)dB = 0.000275 * amplitude
    0x0012, // (-711/10)dB = 0.000279 * amplitude
    0x0012, // (-710/10)dB = 0.000282 * amplitude
    0x0012, // (-709/10)dB = 0.000285 * amplitude
    0x0012, // (-708/10)dB = 0.000288 * amplitude
    0x0013, // (-707/10)dB = 0.000292 * amplitude
    0x0013, // (-706/10)dB = 0.000295 * amplitude
    0x0013, // (-705/10)dB = 0.000299 * amplitude
    0x0013, // (-704/10)dB = 0.000302 * amplitude
    0x0014, // (-703/10)dB = 0.000305 * amplitude
    0x0014, // (-702/10)dB = 0.000309 * amplitude
    0x0014, // (-701/10)dB = 0.000313 * amplitude
    0x0014, // (-700/10)dB = 0.000316 * amplitude
    0x0014, // (-699/10)dB = 0.000320 * amplitude
    0x0015, // (-698/10)dB = 0.000324 * amplitude
    0x0015, // (-697/10)dB = 0.000327 * amplitude
    0x0015, // (-696/10)dB = 0.000331 * amplitude
    0x0015, // (-695/10)dB = 0.000335 * amplitude
    0x0016, // (-694/10)dB = 0.000339 * amplitude
    0x0016, // (-693/10)dB = 0.000343 * amplitude
    0x0016, // (-692/10)dB = 0.000347 * amplitude
    0x0016, // (-691/10)dB = 0.000351 * amplitude
    0x0017, // (-690/10)dB = 0.000355 * amplitude
    0x0017, // (-689/10)dB = 0.000359 * amplitude
    0x0017, // (-688/10)dB = 0.000363 * amplitude
    0x0018, // (-687/10)dB = 0.000367 * amplitude
    0x0018, // (-686/10)dB = 0.000372 * amplitude
    0x0018, // (-685/10)dB = 0.000376 * amplitude
    0x0018, // (-684/10)dB = 0.000380 * amplitude
    0x0019, // (-683/10)dB = 0.000385 * amplitude
    0x0019, // (-682/10)dB = 0.000389 * amplitude
    0x0019, // (-681/10)dB = 0.000394 * amplitude
    0x001A, // (-680/10)dB = 0.000398 * amplitude
    0x001A, // (-679/10)dB = 0.000403 * amplitude
    0x001A, // (-678/10)dB = 0.000407 * amplitude
    0x001B, // (-677/10)dB = 0.000412 * amplitude
    0x001B, // (-676/10)dB = 0.000417 * amplitude
    0x001B, // (-675/10)dB = 0.000422 * amplitude
    0x001B, // (-674/10)dB = 0.000427 * amplitude
    0x001C, // (-673/10)dB = 0.000432 * amplitude
    0x001C, // (-672/10)dB = 0.000437 * amplitude
    0x001C, // (-671/10)dB = 0.000442 * amplitude
    0x001D, // (-670/10)dB = 0.000447 * amplitude
    0x001D, // (-669/10)dB = 0.000452 * amplitude
    0x001D, // (-668/10)dB = 0.000457 * amplitude
    0x001E, // (-667/10)dB = 0.000462 * amplitude
    0x001E, // (-666/10)dB = 0.000468 * amplitude
    0x001F, // (-665/10)dB = 0.000473 * amplitude
    0x001F, // (-664/10)dB = 0.000479 * amplitude
    0x001F, // (-663/10)dB = 0.000484 * amplitude
    0x0020, // (-662/10)dB = 0.000490 * amplitude
    0x0020, // (-661/10)dB = 0.000495 * amplitude
    0x0020, // (-660/10)dB = 0.000501 * amplitude
    0x0021, // (-659/10)dB = 0.000507 * amplitude
    0x0021, // (-658/10)dB = 0.000513 * amplitude
    0x0022, // (-657/10)dB = 0.000519 * amplitude
    0x0022, // (-656/10)dB = 0.000525 * amplitude
    0x0022, // (-655/10)dB = 0.000531 * amplitude
    0x0023, // (-654/10)dB = 0.000537 * amplitude
    0x0023, // (-653/10)dB = 0.000543 * amplitude
    0x0024, // (-652/10)dB = 0.000550 * amplitude
    0x0024, // (-651/10)dB = 0.000556 * amplitude
    0x0024, // (-650/10)dB = 0.000562 * amplitude
    0x0025, // (-649/10)dB = 0.000569 * amplitude
    0x0025, // (-648/10)dB = 0.000575 * amplitude
    0x0026, // (-647/10)dB = 0.000582 * amplitude
    0x0026, // (-646/10)dB = 0.000589 * amplitude
    0x0027, // (-645/10)dB = 0.000596 * amplitude
    0x0027, // (-644/10)dB = 0.000603 * amplitude
    0x0027, // (-643/10)dB = 0.000610 * amplitude
    0x0028, // (-642/10)dB = 0.000617 * amplitude
    0x0028, // (-641/10)dB = 0.000624 * amplitude
    0x0029, // (-640/10)dB = 0.000631 * amplitude
    0x0029, // (-639/10)dB = 0.000638 * amplitude
    0x002A, // (-638/10)dB = 0.000646 * amplitude
    0x002A, // (-637/10)dB = 0.000653 * amplitude
    0x002B, // (-636/10)dB = 0.000661 * amplitude
    0x002B, // (-635/10)dB = 0.000668 * amplitude
    0x002C, // (-634/10)dB = 0.000676 * amplitude
    0x002C, // (-633/10)dB = 0.000684 * amplitude
    0x002D, // (-632/10)dB = 0.000692 * amplitude
    0x002D, // (-631/10)dB = 0.000700 * amplitude
    0x002E, // (-630/10)dB = 0.000708 * amplitude
    0x002E, // (-629/10)dB = 0.000716 * amplitude
    0x002F, // (-628/10)dB = 0.000724 * amplitude
    0x0030, // (-627/10)dB = 0.000733 * amplitude
    0x0030, // (-626/10)dB = 0.000741 * amplitude
    0x0031, // (-625/10)dB = 0.000750 * amplitude
    0x0031, // (-624/10)dB = 0.000759 * amplitude
    0x0032, // (-623/10)dB = 0.000767 * amplitude
    0x0032, // (-622/10)dB = 0.000776 * amplitude
    0x0033, // (-621/10)dB = 0.000785 * amplitude
    0x0034, // (-620/10)dB = 0.000794 * amplitude
    0x0034, // (-619/10)dB = 0.000804 * amplitude
    0x0035, // (-618/10)dB = 0.000813 * amplitude
    0x0035, // (-617/10)dB = 0.000822 * amplitude
    0x0036, // (-616/10)dB = 0.000832 * amplitude
    0x0037, // (-615/10)dB = 0.000841 * amplitude
    0x0037, // (-614/10)dB = 0.000851 * amplitude
    0x0038, // (-613/10)dB = 0.000861 * amplitude
    0x0039, // (-612/10)dB = 0.000871 * amplitude
    0x0039, // (-611/10)dB = 0.000881 * amplitude
    0x003A, // (-610/10)dB = 0.000891 * amplitude
    0x003B, // (-609/10)dB = 0.000902 * amplitude
    0x003B, // (-608/10)dB = 0.000912 * amplitude
    0x003C, // (-607/10)dB = 0.000923 * amplitude
    0x003D, // (-606/10)dB = 0.000933 * amplitude
    0x003D, // (-605/10)dB = 0.000944 * amplitude
    0x003E, // (-604/10)dB = 0.000955 * amplitude
    0x003F, // (-603/10)dB = 0.000966 * amplitude
    0x0040, // (-602/10)dB = 0.000977 * amplitude
    0x0040, // (-601/10)dB = 0.000989 * amplitude
    0x0041, // (-600/10)dB = 0.001000 * amplitude
    0x0042, // (-599/10)dB = 0.001012 * amplitude
    0x0043, // (-598/10)dB = 0.001023 * amplitude
    0x0043, // (-597/10)dB = 0.001035 * amplitude
    0x0044, // (-596/10)dB = 0.001047 * amplitude
    0x0045, // (-595/10)dB = 0.001059 * amplitude
    0x0046, // (-594/10)dB = 0.001072 * amplitude
    0x0047, // (-593/10)dB = 0.001084 * amplitude
    0x0047, // (-592/10)dB = 0.001096 * amplitude
    0x0048, // (-591/10)dB = 0.001109 * amplitude
    0x0049, // (-590/10)dB = 0.001122 * amplitude
    0x004A, // (-589/10)dB = 0.001135 * amplitude
    0x004B, // (-588/10)dB = 0.001148 * amplitude
    0x004C, // (-587/10)dB = 0.001161 * amplitude
    0x004C, // (-586/10)dB = 0.001175 * amplitude
    0x004D, // (-585/10)dB = 0.001189 * amplitude
    0x004E, // (-584/10)dB = 0.001202 * amplitude
    0x004F, // (-583/10)dB = 0.001216 * amplitude
    0x0050, // (-582/10)dB = 0.001230 * amplitude
    0x0051, // (-581/10)dB = 0.001245 * amplitude
    0x0052, // (-580/10)dB = 0.001259 * amplitude
    0x0053, // (-579/10)dB = 0.001274 * amplitude
    0x0054, // (-578/10)dB = 0.001288 * amplitude
    0x0055, // (-577/10)dB = 0.001303 * amplitude
    0x0056, // (-576/10)dB = 0.001318 * amplitude
    0x0057, // (-575/10)dB = 0.001334 * amplitude
    0x0058, // (-574/10)dB = 0.001349 * amplitude
    0x0059, // (-573/10)dB = 0.001365 * amplitude
    0x005A, // (-572/10)dB = 0.001380 * amplitude
    0x005B, // (-571/10)dB = 0.001396 * amplitude
    0x005C, // (-570/10)dB = 0.001413 * amplitude
    0x005D, // (-569/10)dB = 0.001429 * amplitude
    0x005E, // (-568/10)dB = 0.001445 * amplitude
    0x005F, // (-567/10)dB = 0.001462 * amplitude
    0x0060, // (-566/10)dB = 0.001479 * amplitude
    0x0062, // (-565/10)dB = 0.001496 * amplitude
    0x0063, // (-564/10)dB = 0.001514 * amplitude
    0x0064, // (-563/10)dB = 0.001531 * amplitude
    0x0065, // (-562/10)dB = 0.001549 * amplitude
    0x0066, // (-561/10)dB = 0.001567 * amplitude
    0x0067, // (-560/10)dB = 0.001585 * amplitude
    0x0069, // (-559/10)dB = 0.001603 * amplitude
    0x006A, // (-558/10)dB = 0.001622 * amplitude
    0x006B, // (-557/10)dB = 0.001641 * amplitude
    0x006C, // (-556/10)dB = 0.001660 * amplitude
    0x006E, // (-555/10)dB = 0.001679 * amplitude
    0x006F, // (-554/10)dB = 0.001698 * amplitude
    0x0070, // (-553/10)dB = 0.001718 * amplitude
    0x0071, // (-552/10)dB = 0.001738 * amplitude
    0x0073, // (-551/10)dB = 0.001758 * amplitude
    0x0074, // (-550/10)dB = 0.001778 * amplitude
    0x0075, // (-549/10)dB = 0.001799 * amplitude
    0x0077, // (-548/10)dB = 0.001820 * amplitude
    0x0078, // (-547/10)dB = 0.001841 * amplitude
    0x007A, // (-546/10)dB = 0.001862 * amplitude
    0x007B, // (-545/10)dB = 0.001884 * amplitude
    0x007C, // (-544/10)dB = 0.001905 * amplitude
    0x007E, // (-543/10)dB = 0.001928 * amplitude
    0x007F, // (-542/10)dB = 0.001950 * amplitude
    0x0081, // (-541/10)dB = 0.001972 * amplitude
    0x0082, // (-540/10)dB = 0.001995 * amplitude
    0x0084, // (-539/10)dB = 0.002018 * amplitude
    0x0085, // (-538/10)dB = 0.002042 * amplitude
    0x0087, // (-537/10)dB = 0.002065 * amplitude
    0x0088, // (-536/10)dB = 0.002089 * amplitude
    0x008A, // (-535/10)dB = 0.002113 * amplitude
    0x008C, // (-534/10)dB = 0.002138 * amplitude
    0x008D, // (-533/10)dB = 0.002163 * amplitude
    0x008F, // (-532/10)dB = 0.002188 * amplitude
    0x0091, // (-531/10)dB = 0.002213 * amplitude
    0x0092, // (-530/10)dB = 0.002239 * amplitude
    0x0094, // (-529/10)dB = 0.002265 * amplitude
    0x0096, // (-528/10)dB = 0.002291 * amplitude
    0x0097, // (-527/10)dB = 0.002317 * amplitude
    0x0099, // (-526/10)dB = 0.002344 * amplitude
    0x009B, // (-525/10)dB = 0.002371 * amplitude
    0x009D, // (-524/10)dB = 0.002399 * amplitude
    0x009F, // (-523/10)dB = 0.002427 * amplitude
    0x00A0, // (-522/10)dB = 0.002455 * amplitude
    0x00A2, // (-521/10)dB = 0.002483 * amplitude
    0x00A4, // (-520/10)dB = 0.002512 * amplitude
    0x00A6, // (-519/10)dB = 0.002541 * amplitude
    0x00A8, // (-518/10)dB = 0.002570 * amplitude
    0x00AA, // (-517/10)dB = 0.002600 * amplitude
    0x00AC, // (-516/10)dB = 0.002630 * amplitude
    0x00AE, // (-515/10)dB = 0.002661 * amplitude
    0x00B0, // (-514/10)dB = 0.002692 * amplitude
    0x00B2, // (-513/10)dB = 0.002723 * amplitude
    0x00B4, // (-512/10)dB = 0.002754 * amplitude
    0x00B6, // (-511/10)dB = 0.002786 * amplitude
    0x00B8, // (-510/10)dB = 0.002818 * amplitude
    0x00BA, // (-509/10)dB = 0.002851 * amplitude
    0x00BD, // (-508/10)dB = 0.002884 * amplitude
    0x00BF, // (-507/10)dB = 0.002917 * amplitude
    0x00C1, // (-506/10)dB = 0.002951 * amplitude
    0x00C3, // (-505/10)dB = 0.002985 * amplitude
    0x00C5, // (-504/10)dB = 0.003020 * amplitude
    0x00C8, // (-503/10)dB = 0.003055 * amplitude
    0x00CA, // (-502/10)dB = 0.003090 * amplitude
    0x00CC, // (-501/10)dB = 0.003126 * amplitude
    0x00CF, // (-500/10)dB = 0.003162 * amplitude
    0x00D1, // (-499/10)dB = 0.003199 * amplitude
    0x00D4, // (-498/10)dB = 0.003236 * amplitude
    0x00D6, // (-497/10)dB = 0.003273 * amplitude
    0x00D9, // (-496/10)dB = 0.003311 * amplitude
    0x00DB, // (-495/10)dB = 0.003350 * amplitude
    0x00DE, // (-494/10)dB = 0.003388 * amplitude
    0x00E0, // (-493/10)dB = 0.003428 * amplitude
    0x00E3, // (-492/10)dB = 0.003467 * amplitude
    0x00E5, // (-491/10)dB = 0.003508 * amplitude
    0x00E8, // (-490/10)dB = 0.003548 * amplitude
    0x00EB, // (-489/10)dB = 0.003589 * amplitude
    0x00ED, // (-488/10)dB = 0.003631 * amplitude
    0x00F0, // (-487/10)dB = 0.003673 * amplitude
    0x00F3, // (-486/10)dB = 0.003715 * amplitude
    0x00F6, // (-485/10)dB = 0.003758 * amplitude
    0x00F9, // (-484/10)dB = 0.003802 * amplitude
    0x00FC, // (-483/10)dB = 0.003846 * amplitude
    0x00FE, // (-482/10)dB = 0.003890 * amplitude
    0x0101, // (-481/10)dB = 0.003936 * amplitude
    0x0104, // (-480/10)dB = 0.003981 * amplitude
    0x0107, // (-479/10)dB = 0.004027 * amplitude
    0x010A, // (-478/10)dB = 0.004074 * amplitude
    0x010E, // (-477/10)dB = 0.004121 * amplitude
    0x0111, // (-476/10)dB = 0.004169 * amplitude
    0x0114, // (-475/10)dB = 0.004217 * amplitude
    0x0117, // (-474/10)dB = 0.004266 * amplitude
    0x011A, // (-473/10)dB = 0.004315 * amplitude
    0x011E, // (-472/10)dB = 0.004365 * amplitude
    0x0121, // (-471/10)dB = 0.004416 * amplitude
    0x0124, // (-470/10)dB = 0.004467 * amplitude
    0x0128, // (-469/10)dB = 0.004519 * amplitude
    0x012B, // (-468/10)dB = 0.004571 * amplitude
    0x012F, // (-467/10)dB = 0.004624 * amplitude
    0x0132, // (-466/10)dB = 0.004677 * amplitude
    0x0136, // (-465/10)dB = 0.004732 * amplitude
    0x0139, // (-464/10)dB = 0.004786 * amplitude
    0x013D, // (-463/10)dB = 0.004842 * amplitude
    0x0140, // (-462/10)dB = 0.004898 * amplitude
    0x0144, // (-461/10)dB = 0.004955 * amplitude
    0x0148, // (-460/10)dB = 0.005012 * amplitude
    0x014C, // (-459/10)dB = 0.005070 * amplitude
    0x0150, // (-458/10)dB = 0.005129 * amplitude
    0x0154, // (-457/10)dB = 0.005188 * amplitude
    0x0157, // (-456/10)dB = 0.005248 * amplitude
    0x015B, // (-455/10)dB = 0.005309 * amplitude
    0x015F, // (-454/10)dB = 0.005370 * amplitude
    0x0164, // (-453/10)dB = 0.005433 * amplitude
    0x0168, // (-452/10)dB = 0.005495 * amplitude
    0x016C, // (-451/10)dB = 0.005559 * amplitude
    0x0170, // (-450/10)dB = 0.005623 * amplitude
    0x0174, // (-449/10)dB = 0.005689 * amplitude
    0x0179, // (-448/10)dB = 0.005754 * amplitude
    0x017D, // (-447/10)dB = 0.005821 * amplitude
    0x0181, // (-446/10)dB = 0.005888 * amplitude
    0x0186, // (-445/10)dB = 0.005957 * amplitude
    0x018A, // (-444/10)dB = 0.006026 * amplitude
    0x018F, // (-443/10)dB = 0.006095 * amplitude
    0x0194, // (-442/10)dB = 0.006166 * amplitude
    0x0198, // (-441/10)dB = 0.006237 * amplitude
    0x019D, // (-440/10)dB = 0.006310 * amplitude
    0x01A2, // (-439/10)dB = 0.006383 * amplitude
    0x01A7, // (-438/10)dB = 0.006457 * amplitude
    0x01AC, // (-437/10)dB = 0.006531 * amplitude
    0x01B0, // (-436/10)dB = 0.006607 * amplitude
    0x01B6, // (-435/10)dB = 0.006683 * amplitude
    0x01BB, // (-434/10)dB = 0.006761 * amplitude
    0x01C0, // (-433/10)dB = 0.006839 * amplitude
    0x01C5, // (-432/10)dB = 0.006918 * amplitude
    0x01CA, // (-431/10)dB = 0.006998 * amplitude
    0x01CF, // (-430/10)dB = 0.007079 * amplitude
    0x01D5, // (-429/10)dB = 0.007161 * amplitude
    0x01DA, // (-428/10)dB = 0.007244 * amplitude
    0x01E0, // (-427/10)dB = 0.007328 * amplitude
    0x01E5, // (-426/10)dB = 0.007413 * amplitude
    0x01EB, // (-425/10)dB = 0.007499 * amplitude
    0x01F1, // (-424/10)dB = 0.007586 * amplitude
    0x01F6, // (-423/10)dB = 0.007674 * amplitude
    0x01FC, // (-422/10)dB = 0.007762 * amplitude
    0x0202, // (-421/10)dB = 0.007852 * amplitude
    0x0208, // (-420/10)dB = 0.007943 * amplitude
    0x020E, // (-419/10)dB = 0.008035 * amplitude
    0x0214, // (-418/10)dB = 0.008128 * amplitude
    0x021A, // (-417/10)dB = 0.008222 * amplitude
    0x0221, // (-416/10)dB = 0.008318 * amplitude
    0x0227, // (-415/10)dB = 0.008414 * amplitude
    0x022D, // (-414/10)dB = 0.008511 * amplitude
    0x0234, // (-413/10)dB = 0.008610 * amplitude
    0x023A, // (-412/10)dB = 0.008710 * amplitude
    0x0241, // (-411/10)dB = 0.008810 * amplitude
    0x0248, // (-410/10)dB = 0.008913 * amplitude
    0x024E, // (-409/10)dB = 0.009016 * amplitude
    0x0255, // (-408/10)dB = 0.009120 * amplitude
    0x025C, // (-407/10)dB = 0.009226 * amplitude
    0x0263, // (-406/10)dB = 0.009333 * amplitude
    0x026A, // (-405/10)dB = 0.009441 * amplitude
    0x0271, // (-404/10)dB = 0.009550 * amplitude
    0x0279, // (-403/10)dB = 0.009661 * amplitude
    0x0280, // (-402/10)dB = 0.009772 * amplitude
    0x0287, // (-401/10)dB = 0.009886 * amplitude
    0x028F, // (-400/10)dB = 0.010000 * amplitude
    0x0296, // (-399/10)dB = 0.010116 * amplitude
    0x029E, // (-398/10)dB = 0.010233 * amplitude
    0x02A6, // (-397/10)dB = 0.010351 * amplitude
    0x02AE, // (-396/10)dB = 0.010471 * amplitude
    0x02B6, // (-395/10)dB = 0.010593 * amplitude
    0x02BE, // (-394/10)dB = 0.010715 * amplitude
    0x02C6, // (-393/10)dB = 0.010839 * amplitude
    0x02CE, // (-392/10)dB = 0.010965 * amplitude
    0x02D6, // (-391/10)dB = 0.011092 * amplitude
    0x02DF, // (-390/10)dB = 0.011220 * amplitude
    0x02E7, // (-389/10)dB = 0.011350 * amplitude
    0x02F0, // (-388/10)dB = 0.011482 * amplitude
    0x02F9, // (-387/10)dB = 0.011614 * amplitude
    0x0301, // (-386/10)dB = 0.011749 * amplitude
    0x030A, // (-385/10)dB = 0.011885 * amplitude
    0x0313, // (-384/10)dB = 0.012023 * amplitude
    0x031D, // (-383/10)dB = 0.012162 * amplitude
    0x0326, // (-382/10)dB = 0.012303 * amplitude
    0x032F, // (-381/10)dB = 0.012445 * amplitude
    0x0339, // (-380/10)dB = 0.012589 * amplitude
    0x0342, // (-379/10)dB = 0.012735 * amplitude
    0x034C, // (-378/10)dB = 0.012882 * amplitude
    0x0356, // (-377/10)dB = 0.013032 * amplitude
    0x035F, // (-376/10)dB = 0.013183 * amplitude
    0x0369, // (-375/10)dB = 0.013335 * amplitude
    0x0374, // (-374/10)dB = 0.013490 * amplitude
    0x037E, // (-373/10)dB = 0.013646 * amplitude
    0x0388, // (-372/10)dB = 0.013804 * amplitude
    0x0393, // (-371/10)dB = 0.013964 * amplitude
    0x039D, // (-370/10)dB = 0.014125 * amplitude
    0x03A8, // (-369/10)dB = 0.014289 * amplitude
    0x03B3, // (-368/10)dB = 0.014454 * amplitude
    0x03BE, // (-367/10)dB = 0.014622 * amplitude
    0x03C9, // (-366/10)dB = 0.014791 * amplitude
    0x03D4, // (-365/10)dB = 0.014962 * amplitude
    0x03DF, // (-364/10)dB = 0.015136 * amplitude
    0x03EB, // (-363/10)dB = 0.015311 * amplitude
    0x03F7, // (-362/10)dB = 0.015488 * amplitude
    0x0402, // (-361/10)dB = 0.015668 * amplitude
    0x040E, // (-360/10)dB = 0.015849 * amplitude
    0x041A, // (-359/10)dB = 0.016032 * amplitude
    0x0426, // (-358/10)dB = 0.016218 * amplitude
    0x0433, // (-357/10)dB = 0.016406 * amplitude
    0x043F, // (-356/10)dB = 0.016596 * amplitude
    0x044C, // (-355/10)dB = 0.016788 * amplitude
    0x0458, // (-354/10)dB = 0.016982 * amplitude
    0x0465, // (-353/10)dB = 0.017179 * amplitude
    0x0472, // (-352/10)dB = 0.017378 * amplitude
    0x0480, // (-351/10)dB = 0.017579 * amplitude
    0x048D, // (-350/10)dB = 0.017783 * amplitude
    0x049A, // (-349/10)dB = 0.017989 * amplitude
    0x04A8, // (-348/10)dB = 0.018197 * amplitude
    0x04B6, // (-347/10)dB = 0.018408 * amplitude
    0x04C4, // (-346/10)dB = 0.018621 * amplitude
    0x04D2, // (-345/10)dB = 0.018836 * amplitude
    0x04E0, // (-344/10)dB = 0.019055 * amplitude
    0x04EF, // (-343/10)dB = 0.019275 * amplitude
    0x04FD, // (-342/10)dB = 0.019498 * amplitude
    0x050C, // (-341/10)dB = 0.019724 * amplitude
    0x051B, // (-340/10)dB = 0.019953 * amplitude
    0x052A, // (-339/10)dB = 0.020184 * amplitude
    0x053A, // (-338/10)dB = 0.020417 * amplitude
    0x0549, // (-337/10)dB = 0.020654 * amplitude
    0x0559, // (-336/10)dB = 0.020893 * amplitude
    0x0569, // (-335/10)dB = 0.021135 * amplitude
    0x0579, // (-334/10)dB = 0.021380 * amplitude
    0x0589, // (-333/10)dB = 0.021627 * amplitude
    0x0599, // (-332/10)dB = 0.021878 * amplitude
    0x05AA, // (-331/10)dB = 0.022131 * amplitude
    0x05BB, // (-330/10)dB = 0.022387 * amplitude
    0x05CC, // (-329/10)dB = 0.022646 * amplitude
    0x05DD, // (-328/10)dB = 0.022909 * amplitude
    0x05EE, // (-327/10)dB = 0.023174 * amplitude
    0x0600, // (-326/10)dB = 0.023442 * amplitude
    0x0612, // (-325/10)dB = 0.023714 * amplitude
    0x0624, // (-324/10)dB = 0.023988 * amplitude
    0x0636, // (-323/10)dB = 0.024266 * amplitude
    0x0648, // (-322/10)dB = 0.024547 * amplitude
    0x065B, // (-321/10)dB = 0.024831 * amplitude
    0x066E, // (-320/10)dB = 0.025119 * amplitude
    0x0681, // (-319/10)dB = 0.025410 * amplitude
    0x0694, // (-318/10)dB = 0.025704 * amplitude
    0x06A8, // (-317/10)dB = 0.026002 * amplitude
    0x06BB, // (-316/10)dB = 0.026303 * amplitude
    0x06CF, // (-315/10)dB = 0.026607 * amplitude
    0x06E3, // (-314/10)dB = 0.026915 * amplitude
    0x06F8, // (-313/10)dB = 0.027227 * amplitude
    0x070D, // (-312/10)dB = 0.027542 * amplitude
    0x0721, // (-311/10)dB = 0.027861 * amplitude
    0x0737, // (-310/10)dB = 0.028184 * amplitude
    0x074C, // (-309/10)dB = 0.028510 * amplitude
    0x0762, // (-308/10)dB = 0.028840 * amplitude
    0x0777, // (-307/10)dB = 0.029174 * amplitude
    0x078E, // (-306/10)dB = 0.029512 * amplitude
    0x07A4, // (-305/10)dB = 0.029854 * amplitude
    0x07BB, // (-304/10)dB = 0.030200 * amplitude
    0x07D2, // (-303/10)dB = 0.030549 * amplitude
    0x07E9, // (-302/10)dB = 0.030903 * amplitude
    0x0800, // (-301/10)dB = 0.031261 * amplitude
    0x0818, // (-300/10)dB = 0.031623 * amplitude
    0x0830, // (-299/10)dB = 0.031989 * amplitude
    0x0848, // (-298/10)dB = 0.032359 * amplitude
    0x0861, // (-297/10)dB = 0.032734 * amplitude
    0x087A, // (-296/10)dB = 0.033113 * amplitude
    0x0893, // (-295/10)dB = 0.033497 * amplitude
    0x08AC, // (-294/10)dB = 0.033884 * amplitude
    0x08C6, // (-293/10)dB = 0.034277 * amplitude
    0x08E0, // (-292/10)dB = 0.034674 * amplitude
    0x08FA, // (-291/10)dB = 0.035075 * amplitude
    0x0915, // (-290/10)dB = 0.035481 * amplitude
    0x0930, // (-289/10)dB = 0.035892 * amplitude
    0x094B, // (-288/10)dB = 0.036308 * amplitude
    0x0967, // (-287/10)dB = 0.036728 * amplitude
    0x0982, // (-286/10)dB = 0.037154 * amplitude
    0x099F, // (-285/10)dB = 0.037584 * amplitude
    0x09BB, // (-284/10)dB = 0.038019 * amplitude
    0x09D8, // (-283/10)dB = 0.038459 * amplitude
    0x09F5, // (-282/10)dB = 0.038905 * amplitude
    0x0A13, // (-281/10)dB = 0.039355 * amplitude
    0x0A31, // (-280/10)dB = 0.039811 * amplitude
    0x0A4F, // (-279/10)dB = 0.040272 * amplitude
    0x0A6D, // (-278/10)dB = 0.040738 * amplitude
    0x0A8C, // (-277/10)dB = 0.041210 * amplitude
    0x0AAB, // (-276/10)dB = 0.041687 * amplitude
    0x0ACB, // (-275/10)dB = 0.042170 * amplitude
    0x0AEB, // (-274/10)dB = 0.042658 * amplitude
    0x0B0C, // (-273/10)dB = 0.043152 * amplitude
    0x0B2C, // (-272/10)dB = 0.043652 * amplitude
    0x0B4D, // (-271/10)dB = 0.044157 * amplitude
    0x0B6F, // (-270/10)dB = 0.044668 * amplitude
    0x0B91, // (-269/10)dB = 0.045186 * amplitude
    0x0BB3, // (-268/10)dB = 0.045709 * amplitude
    0x0BD6, // (-267/10)dB = 0.046238 * amplitude
    0x0BF9, // (-266/10)dB = 0.046774 * amplitude
    0x0C1C, // (-265/10)dB = 0.047315 * amplitude
    0x0C40, // (-264/10)dB = 0.047863 * amplitude
    0x0C65, // (-263/10)dB = 0.048417 * amplitude
    0x0C89, // (-262/10)dB = 0.048978 * amplitude
    0x0CAE, // (-261/10)dB = 0.049545 * amplitude
    0x0CD4, // (-260/10)dB = 0.050119 * amplitude
    0x0CFA, // (-259/10)dB = 0.050699 * amplitude
    0x0D21, // (-258/10)dB = 0.051286 * amplitude
    0x0D48, // (-257/10)dB = 0.051880 * amplitude
    0x0D6F, // (-256/10)dB = 0.052481 * amplitude
    0x0D97, // (-255/10)dB = 0.053088 * amplitude
    0x0DBF, // (-254/10)dB = 0.053703 * amplitude
    0x0DE8, // (-253/10)dB = 0.054325 * amplitude
    0x0E11, // (-252/10)dB = 0.054954 * amplitude
    0x0E3B, // (-251/10)dB = 0.055590 * amplitude
    0x0E65, // (-250/10)dB = 0.056234 * amplitude
    0x0E90, // (-249/10)dB = 0.056885 * amplitude
    0x0EBB, // (-248/10)dB = 0.057544 * amplitude
    0x0EE6, // (-247/10)dB = 0.058210 * amplitude
    0x0F13, // (-246/10)dB = 0.058884 * amplitude
    0x0F3F, // (-245/10)dB = 0.059566 * amplitude
    0x0F6C, // (-244/10)dB = 0.060256 * amplitude
    0x0F9A, // (-243/10)dB = 0.060954 * amplitude
    0x0FC8, // (-242/10)dB = 0.061660 * amplitude
    0x0FF7, // (-241/10)dB = 0.062373 * amplitude
    0x1027, // (-240/10)dB = 0.063096 * amplitude
    0x1056, // (-239/10)dB = 0.063826 * amplitude
    0x1087, // (-238/10)dB = 0.064565 * amplitude
    0x10B8, // (-237/10)dB = 0.065313 * amplitude
    0x10E9, // (-236/10)dB = 0.066069 * amplitude
    0x111C, // (-235/10)dB = 0.066834 * amplitude
    0x114E, // (-234/10)dB = 0.067608 * amplitude
    0x1182, // (-233/10)dB = 0.068391 * amplitude
    0x11B5, // (-232/10)dB = 0.069183 * amplitude
    0x11EA, // (-231/10)dB = 0.069984 * amplitude
    0x121F, // (-230/10)dB = 0.070795 * amplitude
    0x1255, // (-229/10)dB = 0.071614 * amplitude
    0x128B, // (-228/10)dB = 0.072444 * amplitude
    0x12C2, // (-227/10)dB = 0.073282 * amplitude
    0x12FA, // (-226/10)dB = 0.074131 * amplitude
    0x1332, // (-225/10)dB = 0.074989 * amplitude
    0x136B, // (-224/10)dB = 0.075858 * amplitude
    0x13A4, // (-223/10)dB = 0.076736 * amplitude
    0x13DF, // (-222/10)dB = 0.077625 * amplitude
    0x141A, // (-221/10)dB = 0.078524 * amplitude
    0x1455, // (-220/10)dB = 0.079433 * amplitude
    0x1491, // (-219/10)dB = 0.080353 * amplitude
    0x14CE, // (-218/10)dB = 0.081283 * amplitude
    0x150C, // (-217/10)dB = 0.082224 * amplitude
    0x154B, // (-216/10)dB = 0.083176 * amplitude
    0x158A, // (-215/10)dB = 0.084140 * amplitude
    0x15CA, // (-214/10)dB = 0.085114 * amplitude
    0x160A, // (-213/10)dB = 0.086099 * amplitude
    0x164B, // (-212/10)dB = 0.087096 * amplitude
    0x168E, // (-211/10)dB = 0.088105 * amplitude
    0x16D0, // (-210/10)dB = 0.089125 * amplitude
    0x1714, // (-209/10)dB = 0.090157 * amplitude
    0x1758, // (-208/10)dB = 0.091201 * amplitude
    0x179E, // (-207/10)dB = 0.092257 * amplitude
    0x17E4, // (-206/10)dB = 0.093325 * amplitude
    0x182A, // (-205/10)dB = 0.094406 * amplitude
    0x1872, // (-204/10)dB = 0.095499 * amplitude
    0x18BB, // (-203/10)dB = 0.096605 * amplitude
    0x1904, // (-202/10)dB = 0.097724 * amplitude
    0x194E, // (-201/10)dB = 0.098855 * amplitude
    0x1999, // (-200/10)dB = 0.100000 * amplitude
    0x19E5, // (-199/10)dB = 0.101158 * amplitude
    0x1A32, // (-198/10)dB = 0.102329 * amplitude
    0x1A7F, // (-197/10)dB = 0.103514 * amplitude
    0x1ACE, // (-196/10)dB = 0.104713 * amplitude
    0x1B1D, // (-195/10)dB = 0.105925 * amplitude
    0x1B6E, // (-194/10)dB = 0.107152 * amplitude
    0x1BBF, // (-193/10)dB = 0.108393 * amplitude
    0x1C11, // (-192/10)dB = 0.109648 * amplitude
    0x1C65, // (-191/10)dB = 0.110917 * amplitude
    0x1CB9, // (-190/10)dB = 0.112202 * amplitude
    0x1D0E, // (-189/10)dB = 0.113501 * amplitude
    0x1D64, // (-188/10)dB = 0.114815 * amplitude
    0x1DBB, // (-187/10)dB = 0.116145 * amplitude
    0x1E13, // (-186/10)dB = 0.117490 * amplitude
    0x1E6C, // (-185/10)dB = 0.118850 * amplitude
    0x1EC7, // (-184/10)dB = 0.120226 * amplitude
    0x1F22, // (-183/10)dB = 0.121619 * amplitude
    0x1F7E, // (-182/10)dB = 0.123027 * amplitude
    0x1FDC, // (-181/10)dB = 0.124451 * amplitude
    0x203A, // (-180/10)dB = 0.125893 * amplitude
    0x209A, // (-179/10)dB = 0.127350 * amplitude
    0x20FA, // (-178/10)dB = 0.128825 * amplitude
    0x215C, // (-177/10)dB = 0.130317 * amplitude
    0x21BF, // (-176/10)dB = 0.131826 * amplitude
    0x2223, // (-175/10)dB = 0.133352 * amplitude
    0x2288, // (-174/10)dB = 0.134896 * amplitude
    0x22EE, // (-173/10)dB = 0.136458 * amplitude
    0x2356, // (-172/10)dB = 0.138038 * amplitude
    0x23BF, // (-171/10)dB = 0.139637 * amplitude
    0x2429, // (-170/10)dB = 0.141254 * amplitude
    0x2494, // (-169/10)dB = 0.142889 * amplitude
    0x2500, // (-168/10)dB = 0.144544 * amplitude
    0x256E, // (-167/10)dB = 0.146218 * amplitude
    0x25DD, // (-166/10)dB = 0.147911 * amplitude
    0x264D, // (-165/10)dB = 0.149624 * amplitude
    0x26BF, // (-164/10)dB = 0.151356 * amplitude
    0x2732, // (-163/10)dB = 0.153109 * amplitude
    0x27A6, // (-162/10)dB = 0.154882 * amplitude
    0x281B, // (-161/10)dB = 0.156675 * amplitude
    0x2892, // (-160/10)dB = 0.158489 * amplitude
    0x290B, // (-159/10)dB = 0.160325 * amplitude
    0x2984, // (-158/10)dB = 0.162181 * amplitude
    0x29FF, // (-157/10)dB = 0.164059 * amplitude
    0x2A7C, // (-156/10)dB = 0.165959 * amplitude
    0x2AFA, // (-155/10)dB = 0.167880 * amplitude
    0x2B79, // (-154/10)dB = 0.169824 * amplitude
    0x2BFA, // (-153/10)dB = 0.171791 * amplitude
    0x2C7C, // (-152/10)dB = 0.173780 * amplitude
    0x2D00, // (-151/10)dB = 0.175792 * amplitude
    0x2D86, // (-150/10)dB = 0.177828 * amplitude
    0x2E0D, // (-149/10)dB = 0.179887 * amplitude
    0x2E95, // (-148/10)dB = 0.181970 * amplitude
    0x2F1F, // (-147/10)dB = 0.184077 * amplitude
    0x2FAB, // (-146/10)dB = 0.186209 * amplitude
    0x3038, // (-145/10)dB = 0.188365 * amplitude
    0x30C7, // (-144/10)dB = 0.190546 * amplitude
    0x3158, // (-143/10)dB = 0.192752 * amplitude
    0x31EA, // (-142/10)dB = 0.194984 * amplitude
    0x327E, // (-141/10)dB = 0.197242 * amplitude
    0x3314, // (-140/10)dB = 0.199526 * amplitude
    0x33AB, // (-139/10)dB = 0.201837 * amplitude
    0x3444, // (-138/10)dB = 0.204174 * amplitude
    0x34DF, // (-137/10)dB = 0.206538 * amplitude
    0x357C, // (-136/10)dB = 0.208930 * amplitude
    0x361A, // (-135/10)dB = 0.211349 * amplitude
    0x36BB, // (-134/10)dB = 0.213796 * amplitude
    0x375D, // (-133/10)dB = 0.216272 * amplitude
    0x3801, // (-132/10)dB = 0.218776 * amplitude
    0x38A7, // (-131/10)dB = 0.221309 * amplitude
    0x394F, // (-130/10)dB = 0.223872 * amplitude
    0x39F9, // (-129/10)dB = 0.226464 * amplitude
    0x3AA5, // (-128/10)dB = 0.229087 * amplitude
    0x3B53, // (-127/10)dB = 0.231739 * amplitude
    0x3C03, // (-126/10)dB = 0.234423 * amplitude
    0x3CB5, // (-125/10)dB = 0.237137 * amplitude
    0x3D68, // (-124/10)dB = 0.239883 * amplitude
    0x3E1F, // (-123/10)dB = 0.242661 * amplitude
    0x3ED7, // (-122/10)dB = 0.245471 * amplitude
    0x3F91, // (-121/10)dB = 0.248313 * amplitude
    0x404D, // (-120/10)dB = 0.251189 * amplitude
    0x410C, // (-119/10)dB = 0.254097 * amplitude
    0x41CD, // (-118/10)dB = 0.257040 * amplitude
    0x4290, // (-117/10)dB = 0.260016 * amplitude
    0x4355, // (-116/10)dB = 0.263027 * amplitude
    0x441D, // (-115/10)dB = 0.266073 * amplitude
    0x44E7, // (-114/10)dB = 0.269153 * amplitude
    0x45B3, // (-113/10)dB = 0.272270 * amplitude
    0x4682, // (-112/10)dB = 0.275423 * amplitude
    0x4753, // (-111/10)dB = 0.278612 * amplitude
    0x4826, // (-110/10)dB = 0.281838 * amplitude
    0x48FC, // (-109/10)dB = 0.285102 * amplitude
    0x49D4, // (-108/10)dB = 0.288403 * amplitude
    0x4AAF, // (-107/10)dB = 0.291743 * amplitude
    0x4B8D, // (-106/10)dB = 0.295121 * amplitude
    0x4C6D, // (-105/10)dB = 0.298538 * amplitude
    0x4D4F, // (-104/10)dB = 0.301995 * amplitude
    0x4E34, // (-103/10)dB = 0.305492 * amplitude
    0x4F1C, // (-102/10)dB = 0.309030 * amplitude
    0x5007, // (-101/10)dB = 0.312608 * amplitude
    0x50F4, // (-100/10)dB = 0.316228 * amplitude
    0x51E4, // (-99/10)dB = 0.319890 * amplitude
    0x52D7, // (-98/10)dB = 0.323594 * amplitude
    0x53CC, // (-97/10)dB = 0.327341 * amplitude
    0x54C5, // (-96/10)dB = 0.331131 * amplitude
    0x55C0, // (-95/10)dB = 0.334965 * amplitude
    0x56BE, // (-94/10)dB = 0.338844 * amplitude
    0x57BF, // (-93/10)dB = 0.342768 * amplitude
    0x58C3, // (-92/10)dB = 0.346737 * amplitude
    0x59CA, // (-91/10)dB = 0.350752 * amplitude
    0x5AD5, // (-90/10)dB = 0.354813 * amplitude
    0x5BE2, // (-89/10)dB = 0.358922 * amplitude
    0x5CF2, // (-88/10)dB = 0.363078 * amplitude
    0x5E06, // (-87/10)dB = 0.367282 * amplitude
    0x5F1C, // (-86/10)dB = 0.371535 * amplitude
    0x6036, // (-85/10)dB = 0.375837 * amplitude
    0x6154, // (-84/10)dB = 0.380189 * amplitude
    0x6274, // (-83/10)dB = 0.384592 * amplitude
    0x6398, // (-82/10)dB = 0.389045 * amplitude
    0x64BF, // (-81/10)dB = 0.393550 * amplitude
    0x65EA, // (-80/10)dB = 0.398107 * amplitude
    0x6718, // (-79/10)dB = 0.402717 * amplitude
    0x684A, // (-78/10)dB = 0.407380 * amplitude
    0x697F, // (-77/10)dB = 0.412098 * amplitude
    0x6AB7, // (-76/10)dB = 0.416869 * amplitude
    0x6BF4, // (-75/10)dB = 0.421697 * amplitude
    0x6D34, // (-74/10)dB = 0.426580 * amplitude
    0x6E78, // (-73/10)dB = 0.431519 * amplitude
    0x6FBF, // (-72/10)dB = 0.436516 * amplitude
    0x710A, // (-71/10)dB = 0.441570 * amplitude
    0x7259, // (-70/10)dB = 0.446684 * amplitude
    0x73AC, // (-69/10)dB = 0.451856 * amplitude
    0x7503, // (-68/10)dB = 0.457088 * amplitude
    0x765E, // (-67/10)dB = 0.462381 * amplitude
    0x77BD, // (-66/10)dB = 0.467735 * amplitude
    0x7920, // (-65/10)dB = 0.473151 * amplitude
    0x7A87, // (-64/10)dB = 0.478630 * amplitude
    0x7BF2, // (-63/10)dB = 0.484172 * amplitude
    0x7D62, // (-62/10)dB = 0.489779 * amplitude
    0x7ED5, // (-61/10)dB = 0.495450 * amplitude
    0x804D, // (-60/10)dB = 0.501187 * amplitude
    0x81CA, // (-59/10)dB = 0.506991 * amplitude
    0x834A, // (-58/10)dB = 0.512861 * amplitude
    0x84D0, // (-57/10)dB = 0.518800 * amplitude
    0x8659, // (-56/10)dB = 0.524807 * amplitude
    0x87E8, // (-55/10)dB = 0.530884 * amplitude
    0x897A, // (-54/10)dB = 0.537032 * amplitude
    0x8B12, // (-53/10)dB = 0.543250 * amplitude
    0x8CAE, // (-52/10)dB = 0.549541 * amplitude
    0x8E4F, // (-51/10)dB = 0.555904 * amplitude
    0x8FF5, // (-50/10)dB = 0.562341 * amplitude
    0x91A0, // (-49/10)dB = 0.568853 * amplitude
    0x9350, // (-48/10)dB = 0.575440 * amplitude
    0x9504, // (-47/10)dB = 0.582103 * amplitude
    0x96BE, // (-46/10)dB = 0.588844 * amplitude
    0x987D, // (-45/10)dB = 0.595662 * amplitude
    0x9A41, // (-44/10)dB = 0.602560 * amplitude
    0x9C0A, // (-43/10)dB = 0.609537 * amplitude
    0x9DD9, // (-42/10)dB = 0.616595 * amplitude
    0x9FAD, // (-41/10)dB = 0.623735 * amplitude
    0xA186, // (-40/10)dB = 0.630957 * amplitude
    0xA365, // (-39/10)dB = 0.638263 * amplitude
    0xA549, // (-38/10)dB = 0.645654 * amplitude
    0xA733, // (-37/10)dB = 0.653131 * amplitude
    0xA923, // (-36/10)dB = 0.660693 * amplitude
    0xAB18, // (-35/10)dB = 0.668344 * amplitude
    0xAD13, // (-34/10)dB = 0.676083 * amplitude
    0xAF14, // (-33/10)dB = 0.683912 * amplitude
    0xB11B, // (-32/10)dB = 0.691831 * amplitude
    0xB328, // (-31/10)dB = 0.699842 * amplitude
    0xB53B, // (-30/10)dB = 0.707946 * amplitude
    0xB755, // (-29/10)dB = 0.716143 * amplitude
    0xB974, // (-28/10)dB = 0.724436 * amplitude
    0xBB9A, // (-27/10)dB = 0.732825 * amplitude
    0xBDC6, // (-26/10)dB = 0.741310 * amplitude
    0xBFF9, // (-25/10)dB = 0.749894 * amplitude
    0xC232, // (-24/10)dB = 0.758578 * amplitude
    0xC471, // (-23/10)dB = 0.767361 * amplitude
    0xC6B8, // (-22/10)dB = 0.776247 * amplitude
    0xC905, // (-21/10)dB = 0.785236 * amplitude
    0xCB59, // (-20/10)dB = 0.794328 * amplitude
    0xCDB3, // (-19/10)dB = 0.803526 * amplitude
    0xD015, // (-18/10)dB = 0.812831 * amplitude
    0xD27E, // (-17/10)dB = 0.822243 * amplitude
    0xD4EE, // (-16/10)dB = 0.831764 * amplitude
    0xD765, // (-15/10)dB = 0.841395 * amplitude
    0xD9E4, // (-14/10)dB = 0.851138 * amplitude
    0xDC6A, // (-13/10)dB = 0.860994 * amplitude
    0xDEF7, // (-12/10)dB = 0.870964 * amplitude
    0xE18C, // (-11/10)dB = 0.881049 * amplitude
    0xE429, // (-10/10)dB = 0.891251 * amplitude
    0xE6CD, // (-9/10)dB = 0.901571 * amplitude
    0xE979, // (-8/10)dB = 0.912011 * amplitude
    0xEC2D, // (-7/10)dB = 0.922571 * amplitude
    0xEEE9, // (-6/10)dB = 0.933254 * amplitude
    0xF1AD, // (-5/10)dB = 0.944061 * amplitude
    0xF47A, // (-4/10)dB = 0.954993 * amplitude
    0xF74F, // (-3/10)dB = 0.966051 * amplitude
    0xFA2C, // (-2/10)dB = 0.977237 * amplitude
    0xFD11, // (-1/10)dB = 0.988553 * amplitude
    };

;

//
//  DBToAmpFactor
//
//  Converts lDB, specified in 100ths decibels, into a
//  linear amplification factor.  For all lDB >= 0 this
//  function returns 0xffff.  This is because our current
//  implementation of DirectSound doesn't allow amplification,
//  and users of this function often require 16-bit results
//
#undef DPF_MODNAME
#define DPF_MODNAME "DBToAmpFactor"

DWORD DBToAmpFactor( LONG lDB )
{
    DWORD dwFactor;

    // input lDB is 100ths of decibels

    // REMIND hack to make mixer code work- it only handles 16-bit factors and
    //  cannot amplify
    if (0 <= lDB) return 0x0000FFFF;
    
    //
    // bias and scale the input and check boundaries for indexing into table
    //
    lDB = (lDB+5)/10;		    // scaled to 1/10th dB units
    
    if (lDB > -1)   lDB = -1;	    // upper boundary
    if (lDB < -964) lDB = -964;	    // lower boundary

    lDB = (lDB + 964);		    // bias

    // lDB better be a good index.
    DNASSERT(lDB >= 0);
    DNASSERT(lDB <= sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]));
    
    dwFactor = tblDBTenthsToAmpFactor[lDB];

    return dwFactor;
}

// Note, could use DirectSound3D's fyl2x function instead of searching 
// through the table.
#undef DPF_MODNAME
#define DPF_MODNAME "AmpFactorToDB"

LONG AmpFactorToDB( DWORD dwFactor )
{
    LONG    lDB;
    int	    i;
    int	    iMax;

    iMax = sizeof(tblDBTenthsToAmpFactor) / sizeof(tblDBTenthsToAmpFactor[0]) - 1;
    
    if (dwFactor < 0x0000FFFF) 
    {
        for (i = 0; i <= iMax - 1; i++) {
	         if (dwFactor <= tblDBTenthsToAmpFactor[i]) break;
        }
        lDB = (i - 964) * 10;
    }
    else
    {
        lDB = 0; 
    }


    return lDB;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\bfcsynch.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		bfcsynch.h
 *  Content:	Declaration of synchronization classes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __BFCSYNCH_H
#define __BFCSYNCH_H

class BFCSingleLock
{
public:
	BFCSingleLock( DNCRITICAL_SECTION *cs ) 
		{ m_cs = cs; DNEnterCriticalSection( m_cs );  };
	~BFCSingleLock() { DNLeaveCriticalSection( m_cs ); };

	void Lock() { };
protected:
	DNCRITICAL_SECTION	*m_cs;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\devmap.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devmap.h
 *  Content:	Maps various default devices GUIDs to real guids. 
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11-24-99  pnewson   Created
 *  12-02-99  rodtoll	Added new functions for mapping device IDs and finding default
 *                      devices.
 *  01/25/2000 pnewson  Added DV_MapWaveIDToGUID
 *
 ***************************************************************************/

#ifndef _DEVMAP_H_
#define _DEVMAP_H_

extern HRESULT DV_MapCaptureDevice(const GUID* lpguidCaptureDeviceIn, GUID* lpguidCaptureDeviceOut);
extern HRESULT DV_MapPlaybackDevice(const GUID* lpguidPlaybackDeviceIn, GUID* lpguidPlaybackDeviceOut);
extern HRESULT DV_LegacyGetDefaultDeviceID( BOOL fCapture, DWORD *pdwDeviceID );
extern HRESULT DV_CheckDeviceGUID( BOOL fCapture, const GUID &guidDevice );
extern HRESULT DV_MapGUIDToWaveID( BOOL fCapture, const GUID &guidDevice, DWORD *pdwDevice );
extern HRESULT DV_MapWaveIDToGUID( BOOL fCapture, DWORD dwDevice, GUID& guidDevice );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\decibels.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		decibels.h
 *  Content:	Functions to map from dsound volumes to wave volumes
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/29/99		rodtoll	Adapted from dsound team's file.
 ***************************************************************************/

// ORIGINAL HEADER: 
//
//--------------------------------------------------------------------------;
//
//  File: decibels.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/15/95	FrankYe
//
//--------------------------------------------------------------------------;

DWORD DBToAmpFactor( LONG lDB );
LONG AmpFactorToDB( DWORD dwFactor );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\devmap.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devmap.cpp
 *  Content:	Maps various default devices GUIDs to real guids. 
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11-24-99  pnewson   Created
 *  12-02-99  rodtoll	Added new functions for mapping device IDs and finding default
 *                      devices. 
 *            rodtoll	Updated mapping function to map default devices to real GUIDs
 *						for non-DX7.1 platforms. 
 *  01/25/2000 pnewson  Added DV_MapWaveIDToGUID
 *  04/14/2000 rodtoll  Bug #32341 GUID_NULL and NULL map to different devices
 *                      Updated so both map to default voice device
 *  04/19/2000	pnewson	    Error handling cleanup  
 *  04/20/2000  rodtoll Bug #32889 - Unable to run on non-admin accounts on Win2k
 *  06/28/2000	rodtoll	Prefix Bug #38022
 *				rodtoll Whistler Bug #128427 - Unable to run voice wizard from multimedia control panel
 *  08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h, added STR_* and strutils.h
 *  01/08/2001	rodtoll WINBUG #256541	Pseudo: Loss of functionality: Voice Wizrd can't be launched. 
 *  04/02/2001	simonpow	Fixes for PREfast bugs #354859
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define REGSTR_WAVEMAPPER               L"Software\\Microsoft\\Multimedia\\Sound Mapper"
#define REGSTR_PLAYBACK                 L"Playback"
#define REGSTR_RECORD                   L"Record"

// function pointer typedefs
typedef HRESULT (* PFGETDEVICEID)(LPCGUID, LPGUID);

typedef HRESULT (WINAPI *DSENUM)( LPDSENUMCALLBACK lpDSEnumCallback,LPVOID lpContext );

struct DSWaveDeviceFind_Param
{
	GUID guidDevice;
	UINT uiDevice;
	UINT uiCounter;
	BOOL fCapture;
};

// DSWaveDeviceFind
//
// This callback function is used to try and match the GUID of the device to a 
// wave ID#.  Once it finds the entry that matches the device GUID it determines
// the waveIN ID by one of two methods:
// 
// 1. Looks at the driver name, and looks for WaveIN X and uses X as the device ID.
//    (Only works on english versions).  (WaveIN only)
// 2. Fuzzy Matching - Order in enumeration determines device ID.  The first device
//    which is not the default is device 0, second is device 1, etc.. etc...
//  
#undef DPF_MODNAME
#define DPF_MODNAME "DSWaveDeviceFind"

BOOL CALLBACK DSWaveDeviceFind(
    LPGUID lpGUID, 
    LPCTSTR lpszDesc,
    LPCTSTR lpszDrvName, 
    LPVOID lpContext 
) {

	DSWaveDeviceFind_Param *pParam = (DSWaveDeviceFind_Param *) lpContext;

	if( lpGUID == NULL )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Ignoring default" );
		return TRUE;
	}

	if( *lpGUID == pParam->guidDevice )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Device found id=%x", pParam->uiCounter );

		if( pParam->fCapture && sscanf( lpszDrvName, "WaveIn %u", &pParam->uiDevice ) == 1 )
		{
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Emulated Driver, Positive match found id=%d", pParam->uiDevice );
		}
		else
		{
			pParam->uiDevice = pParam->uiCounter;
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Fuzzy match found id=%d", pParam->uiDevice );		
		}
		return TRUE;
	}

	pParam->uiCounter++;
	
    return TRUE;
}

// This function uses DSWaveDeviceFind to do a fuzzy map from GUID --> device ID on
// old operating systems.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_LegacyFuzzyGUIDMap"
HRESULT DV_LegacyFuzzyGUIDMap( BOOL fCapture, const GUID &guidDevice, DWORD *pdwDeviceID )
{
    DSENUM enumFunc;
    HINSTANCE hinstds;
    DSWaveDeviceFind_Param findParam;
    HRESULT hr;

	hinstds = NULL;

	// Attempt to load the directsound DLL
    hinstds = LoadLibraryA( "DSOUND.DLL" );

	// If it couldn't be loaded, this sub system is not supported
	// on this system.
    if( hinstds == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "Unable to load dsound.dll to enum devices" );
		return DVERR_GENERIC;
    }

	// Attempt to get the DirectSoundCaptureEnumerateA function from the
	// DSOUND.DLL.  If it's not available then this class assumes it's
	// not supported on this system.

	if( fCapture )
	{
#ifdef UNICODE
	    enumFunc = (DSENUM) GetProcAddress( hinstds, "DirectSoundCaptureEnumerateW" );
#else
	    enumFunc = (DSENUM) GetProcAddress( hinstds, "DirectSoundCaptureEnumerateA" );
#endif
	}
	else
	{
#ifdef UNICODE
	    enumFunc = (DSENUM) GetProcAddress( hinstds, "DirectSoundEnumerateW" );	
#else
	    enumFunc = (DSENUM) GetProcAddress( hinstds, "DirectSoundEnumerateA" );	
#endif
	}

    if( enumFunc == NULL )
    {
        DPFX(DPFPREP,  DVF_INFOLEVEL, "Unable to find enum func for enumerate" );
        FreeLibrary( hinstds );
        return DVERR_NOTSUPPORTED;
    }

    findParam.guidDevice = guidDevice;
    findParam.uiDevice = 0xFFFFFFFF;
    findParam.uiCounter = 0;
    findParam.fCapture = fCapture;

    hr = (*enumFunc)( DSWaveDeviceFind, &findParam );

    if( FAILED( hr ) )
    {
    	DPFX(DPFPREP,  DVF_INFOLEVEL, "Error enumerating capture devices hr = 0x%x", hr );
    }

    if( findParam.uiDevice == 0xFFFFFFFF )
    {
    	DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map the capture device. Defaulting to 0" );

    	*pdwDeviceID = 0;
		hr = DVERR_INVALIDDEVICE;
    }
    else
    {
    	*pdwDeviceID = findParam.uiDevice;    
    	DPFX(DPFPREP,  DVF_INFOLEVEL, "Found the device during enum, id=%d", findParam.uiDevice );	    	
    }

    FreeLibrary( hinstds );

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_CheckDeviceGUID"
HRESULT DV_CheckDeviceGUID( BOOL fCapture, const GUID &guidDevice )
{
    DWORD dwDeviceID;

	return DV_MapGUIDToWaveID( fCapture, guidDevice, &dwDeviceID );
}

// DV_MapGUIDToWaveID
//
// This function maps the specified GUID to the corresponding waveIN/waveOut device
// ID.  For default devices it looks up the system's default device, for other devices
// it uses the private interface.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapGUIDToWaveID"
HRESULT DV_MapGUIDToWaveID( BOOL fCapture, const GUID &guidDevice, DWORD *pdwDevice )
{
	LPKSPROPERTYSET pPropertySet;
	PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pData;
	GUID tmpGUID;
	HRESULT hr;

	// We're running on pre-private interface, no way to map default 
	// device.
	if( guidDevice == GUID_NULL )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Mapping GUID to WaveID.  Mapping GUID_NULL" );
		
		hr = DV_LegacyGetDefaultDeviceID( fCapture, pdwDevice );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to determine default system waveIN ID hr = 0x%x", hr );
		}

		return hr;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "Mapping non GUID_NULL to Wave ID" );

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to map GUID, attempting fuzzy map" );
		
		hr = DV_LegacyFuzzyGUIDMap( fCapture, guidDevice, pdwDevice );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map GUID to wave.  Defaulting to ID 0 hr=0x%x", hr );
			*pdwDevice = 0;
		}
	}
	else
	{
		tmpGUID = guidDevice;

		hr = PrvGetDeviceDescription( pPropertySet, tmpGUID, &pData );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find GUID.  Defaulting to ID 0 hr=0x%x", hr );
		}
		else
		{
			*pdwDevice = pData->WaveDeviceId;
			DPFX(DPFPREP,  DVF_INFOLEVEL, "Mapped GUID to Wave ID %d", *pdwDevice );
			delete pData;
		}

		pPropertySet->Release();
	}

	return hr;
}

// DV_MapWaveIDToGUID
//
// This function maps the specified waveIN/waveOut device ID to the corresponding DirectSound
// GUID. 
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapWaveIDToGUID"
HRESULT DV_MapWaveIDToGUID( BOOL fCapture, DWORD dwDevice, GUID &guidDevice )
{
	HRESULT hr;

	LPKSPROPERTYSET ppKsPropertySet;
	HMODULE hModule;

	hModule = LoadLibraryA( "dsound.dll " );

	if( hModule == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Could not load dsound.dll" );
		return DVERR_GENERIC;
	}

	hr = DirectSoundPrivateCreate( &ppKsPropertySet );

	if( FAILED( hr ) )
	{
		FreeLibrary( hModule );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get interface for ID<-->GUID Map hr=0x%x", hr );
		return hr;
	}	

	if( DNGetOSType() == VER_PLATFORM_WIN32_NT )
	{
		WAVEINCAPSW wiCapsW;
		WAVEOUTCAPSW woCapsW;		
		MMRESULT mmr;
		
		if( fCapture )
		{
			mmr = waveInGetDevCapsW( dwDevice, &wiCapsW, sizeof( WAVEINCAPSW ) );
		}
		else
		{
			mmr = waveOutGetDevCapsW( dwDevice, &woCapsW, sizeof( WAVEOUTCAPSW ) );
		}

		if( mmr != MMSYSERR_NOERROR )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified device is invalid hr=0x%x", mmr );
			ppKsPropertySet->Release();
			FreeLibrary( hModule );
			return DVERR_INVALIDPARAM;
		}

		hr = PrvGetWaveDeviceMappingW( ppKsPropertySet, (fCapture) ? wiCapsW.szPname : woCapsW.szPname , fCapture, &guidDevice );
	}
	else
	{
		WAVEINCAPSA wiCapsA;
		WAVEOUTCAPSA woCapsA;		
		MMRESULT mmr;

		if( fCapture )
		{
			mmr = waveInGetDevCapsA( dwDevice, &wiCapsA, sizeof( WAVEINCAPSA ) );
		}
		else
		{
			mmr = waveOutGetDevCapsA( dwDevice, &woCapsA, sizeof( WAVEOUTCAPSA ) );
		}

		if( mmr != MMSYSERR_NOERROR )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Specified device is invalid hr=0x%x", mmr );
			ppKsPropertySet->Release();
			FreeLibrary( hModule );
			return DVERR_INVALIDPARAM;
		}

		hr = PrvGetWaveDeviceMapping( ppKsPropertySet, (fCapture) ? wiCapsA.szPname : woCapsA.szPname , fCapture, &guidDevice );
	}

	ppKsPropertySet->Release();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to map ID-->GUID hr=0x%x", hr );
	}

	FreeLibrary( hModule );
	
	return hr;
}


// DV_GetDefaultDeviceID_Win2000
//
// Looks up the default waveIN or waveOut device ID for the system under
// Windows 2000.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_GetDefaultDeviceID_Win2000"
HRESULT DV_GetDefaultDeviceID_Win2000( BOOL fCapture, DWORD *pdwDeviceID )
{
    MMRESULT        mmr;
    DWORD           dwFlags = 0;

    if( fCapture )
    {
        mmr = waveInMessage((HWAVEIN) ((UINT_PTR) WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) pdwDeviceID, (DWORD_PTR) &dwFlags);
    }
    else
    {
        mmr = waveOutMessage((HWAVEOUT) ((UINT_PTR) WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) pdwDeviceID, (DWORD_PTR) &dwFlags);    
    }

    if( mmr != 0 )
    {
    	DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve default device (Method A)" );
    }

	return CMixerLine::MMRESULTtoHRESULT(mmr);
}

// DV_GetDefaultWaveInID_Win2k
//
// Looks up the default waveIN or waveOut device ID for Win9x/Millenium
// systems.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_GetDefaultWaveInID_Win2k"
HRESULT DV_GetDefaultDeviceID_Win9X( BOOL fCapture, DWORD *pdwDeviceID )
{
	CRegistry reg;
	wchar_t lpwszDeviceName[MAX_REGISTRY_STRING_SIZE+1];
	char lpszDeviceName[MAX_REGISTRY_STRING_SIZE+1];
	DWORD dwSize;
	DWORD dwIndex;
	UINT uiNumDevices;
	WAVEINCAPS wiCaps;
	WAVEOUTCAPS woCaps;
	MMRESULT mmr;
	HRESULT hr;

	if( !reg.Open( HKEY_CURRENT_USER, REGSTR_WAVEMAPPER, TRUE, FALSE ) )
	{
    	DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve default device, cannot open (Method B)" );
		return DVERR_GENERIC;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE+1;

	if( !reg.ReadString( fCapture ? REGSTR_RECORD : REGSTR_PLAYBACK, lpwszDeviceName, &dwSize ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve default device, cannot find (Method B)" );
		return DVERR_GENERIC;
	}

	if( fCapture )
	{
		uiNumDevices = waveInGetNumDevs();
	}
	else
	{	
		uiNumDevices = waveOutGetNumDevs();
	}

#if !defined(_UNICODE) && !defined(UNICODE)
	hr = STR_jkWideToAnsi( lpszDeviceName, lpwszDeviceName, MAX_REGISTRY_STRING_SIZE );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to convert device name ansi", lpszDeviceName );
		return hr;
	}
#endif	

	for( dwIndex = 0; dwIndex < uiNumDevices; dwIndex++ )
	{
		if( fCapture )
		{
			mmr = waveInGetDevCaps( dwIndex, &wiCaps, sizeof( WAVEINCAPS ) );
		}
		else
		{
			mmr = waveOutGetDevCaps( dwIndex, &woCaps, sizeof( WAVEOUTCAPS ) );		
		}
		
		if( FAILED( mmr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Error querying device mmr=0x%x", mmr );		
		}
		else 
		{
			if( _tcscmp( (fCapture) ? wiCaps.szPname : woCaps.szPname, lpszDeviceName ) == 0 )
			{
				DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Found default device, id=%d", dwIndex );
				*pdwDeviceID = dwIndex;
				return DV_OK;
			}
		}
	}

	DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve default device, could not match default device.  (Method B)" );

	return DVERR_GENERIC;
}

// DV_LegacyGetDefaultDeviceID
//
// This function finds the default playback or capture device in the
// system.  (It's waveIN/waveOut device ID).
//
// This function will work on all Win9X platforms, Windows 2000.
//
// Not tested on Windows NT 4.0.
//
HRESULT DV_LegacyGetDefaultDeviceID( BOOL fCapture, DWORD *pdwDeviceID )
{
	DNASSERT( pdwDeviceID != NULL );
	
	HRESULT hr;
	
	hr = DV_GetDefaultDeviceID_Win2000( fCapture, pdwDeviceID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Failed method A hr = 0x%x", hr );

		hr = DV_GetDefaultDeviceID_Win9X( fCapture, pdwDeviceID );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Failed method B hr = 0x%x" , hr );
			return hr;
		}
	}

	return DV_OK;
}

// DV_LegacyMapDefaultGUID
//
// For systems that don't have DX7.1, determines the GUID for the default
// playback or record devices.  It does this by:
//
// 1. Looking up the system's default waveIn/waveOut ID
// 2. Looking up the device's name
// 3. Uses the private interface to map to a GUID
//
// This function will not work for systems without the private interface.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DV_LegacyMapDefaultGUID"
HRESULT DV_LegacyMapDefaultGUID( BOOL fCapture, GUID* lpguidDevice)
{
	DWORD dwDeviceID = 0;
	HRESULT hr = DV_OK;
	LPKSPROPERTYSET pPropertySet = NULL;
	WAVEINCAPS wiCaps;
	WAVEOUTCAPS woCaps;
	MMRESULT mmr = 0;
	
	hr = DV_LegacyGetDefaultDeviceID( fCapture,  &dwDeviceID );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Could not determine default device ID hr=0x%x", hr );	
		*lpguidDevice = GUID_NULL;
		return hr;
	}

	DPFX(DPFPREP,  DVF_INFOLEVEL, "MapDefCapDev: Default device is device ID#%d", dwDeviceID );
	DPFX(DPFPREP,  DVF_INFOLEVEL, "MapDefCapDev: Searching for matching GUID" );

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "MapDefCapDev: Unable to access search. (Defaulting to GUID_NULL) hr=0x%x", hr );
		*lpguidDevice = GUID_NULL;
		return hr;
	}

	if( fCapture )
	{
		mmr = waveInGetDevCaps( dwDeviceID, &wiCaps, sizeof( WAVEINCAPS ) );	
	}
	else
	{
		mmr = waveOutGetDevCaps( dwDeviceID, &woCaps, sizeof( WAVEOUTCAPS ) );	
	}

	if( FAILED( hr ) )
	{
		DNASSERT( FALSE );
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "MapDefCapDev: Retrieving device info failed default to GUID_NULL mmr=0x%x", mmr );
		pPropertySet->Release();
		*lpguidDevice = GUID_NULL;		
		return CMixerLine::MMRESULTtoHRESULT( mmr );
	}

	hr = PrvGetWaveDeviceMapping( pPropertySet, (fCapture) ? wiCaps.szPname : woCaps.szPname, fCapture, lpguidDevice );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "MapDefCapDev: Unable to map from ID to GUID, defaulting to GUID_NULL  hr=0x%x" , hr );
		*lpguidDevice = GUID_NULL;				
	}

	pPropertySet->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapCaptureDevice"
HRESULT DV_MapCaptureDevice(const GUID* lpguidCaptureDeviceIn, GUID* lpguidCaptureDeviceOut)
{
	LONG lRet;
	HRESULT hr;
	PFGETDEVICEID pfGetDeviceID;
	
	// attempt to map any default guids to real guids...
	HINSTANCE hDSound = LoadLibraryA("dsound.dll");
	if (hDSound == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to get instance handle to DirectSound dll: %s", "dsound.dll");
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadLibrary error code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// attempt to get a pointer to the GetDeviceId function
	pfGetDeviceID = (PFGETDEVICEID)GetProcAddress(hDSound, "GetDeviceID");
	if (pfGetDeviceID == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Unable to get a pointer to GetDeviceID function: %s", "GetDeviceID" );
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "GetProcAddress error code: %i", lRet);
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Assuming that we are running on a Pre-DX7.1 DirectSound", lRet);

		// On a pre-DX 7.1 system, we map NULL to GUID_NULL, and that's all, since
		// the other "default" guids don't really exist on this system (i.e. if I were
		// to pass them to DirectSound, it wouldn't understand.).
		if (lpguidCaptureDeviceIn == NULL || 
		    *lpguidCaptureDeviceIn == DSDEVID_DefaultCapture ||
		    *lpguidCaptureDeviceIn == DSDEVID_DefaultVoiceCapture ||
			*lpguidCaptureDeviceIn == GUID_NULL )
		{
			hr = DV_LegacyMapDefaultGUID( TRUE, lpguidCaptureDeviceOut );

			if( FAILED( hr ) )
			{
				DNASSERT( FALSE );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to perform old mapping.  Assuming GUID_NULL" );
				*lpguidCaptureDeviceOut = GUID_NULL;
			}
		}
		else
		{
			*lpguidCaptureDeviceOut = *lpguidCaptureDeviceIn;
		}
	}
	else
	{
		// Use the GetDeviceID function to map the devices.
		if (lpguidCaptureDeviceIn == NULL)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping null device pointer to DSDEVID_DefaultCapture");
			lpguidCaptureDeviceIn = &DSDEVID_DefaultCapture;
		}
		else if (*lpguidCaptureDeviceIn == GUID_NULL)
		{
			// GetDeviceID does not accept GUID_NULL, since it does not know
			// if we are asking for a capture or playback device. So we map
			// GUID_NULL to the system default capture device here. Then 
			// GetDeviceID can map it to the real device.
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping GUID_NULL to DSDEVID_DefaultCapture");
			lpguidCaptureDeviceIn = &DSDEVID_DefaultCapture;
		}

		GUID guidTemp;
		hr = pfGetDeviceID(lpguidCaptureDeviceIn, &guidTemp);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "GetDeviceID failed: %i", hr);
			if (hr == DSERR_NODRIVER)
			{
				hr = DVERR_INVALIDDEVICE;
			}
			else
			{
				hr = DVERR_GENERIC;
			}
			goto error_cleanup;
		}
		if (*lpguidCaptureDeviceIn != guidTemp)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: GetDeviceID mapped device GUID");
			*lpguidCaptureDeviceOut = guidTemp;
		}
		else
		{
			*lpguidCaptureDeviceOut = *lpguidCaptureDeviceIn;
		}
	}
	
	if (!FreeLibrary(hDSound))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "FreeLibrary failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	return DV_OK;

error_cleanup:
	if (hDSound != NULL)
	{
		FreeLibrary(hDSound);
	}
	DPF_EXIT();
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DV_MapPlaybackDevice"
HRESULT DV_MapPlaybackDevice(const GUID* lpguidPlaybackDeviceIn, GUID* lpguidPlaybackDeviceOut)
{
	LONG lRet;
	HRESULT hr;
	PFGETDEVICEID pfGetDeviceID;
	
	// attempt to map any default guids to real guids...
	HINSTANCE hDSound = LoadLibraryA("dsound.dll");
	if (hDSound == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "Unable to get instance handle to DirectSound dll: %s", "dsound.dll");
		DPFX(DPFPREP, DVF_ERRORLEVEL, "LoadLibrary error code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	// attempt to get a pointer to the GetDeviceId function
	pfGetDeviceID = (PFGETDEVICEID)GetProcAddress(hDSound, "GetDeviceID");
	if (pfGetDeviceID == NULL)
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Unable to get a pointer to GetDeviceID function: %s", "GetDeviceID");
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "GetProcAddress error code: %i", lRet);
		DPFX(DPFPREP, DVF_WARNINGLEVEL, "Assuming that we are running on a Pre-DX7.1 DirectSound", lRet);

		// On a pre-DX 7.1 system, we map NULL to GUID_NULL, and that's all, since
		// the other "default" guids don't really exist on this system (i.e. if I were
		// to pass them to DirectSound, it wouldn't understand.).

		if (lpguidPlaybackDeviceIn == NULL || 
		    *lpguidPlaybackDeviceIn == DSDEVID_DefaultPlayback ||
		    *lpguidPlaybackDeviceIn == DSDEVID_DefaultVoicePlayback ||
			*lpguidPlaybackDeviceIn == GUID_NULL )
		{
			hr = DV_LegacyMapDefaultGUID( FALSE, lpguidPlaybackDeviceOut );

			if( FAILED( hr ) )
			{
				DNASSERT( FALSE );
				DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to perform old mapping.  Assuming GUID_NULL" );
				*lpguidPlaybackDeviceOut = GUID_NULL;
			}
		}
		else
		{
			*lpguidPlaybackDeviceOut = *lpguidPlaybackDeviceIn;
		}
	}
	else
	{
		// Use the GetDeviceID function to map the devices.
		if (lpguidPlaybackDeviceIn == NULL)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping null device pointer to DSDEVID_DefaultPlayback");
			lpguidPlaybackDeviceIn = &DSDEVID_DefaultPlayback;
		} 
		else if (*lpguidPlaybackDeviceIn == GUID_NULL)
		{
			// GetDeviceID does not accept GUID_NULL, since it does not know
			// if we are asking for a capture or playback device. So we map
			// GUID_NULL to the system default playback device here. Then 
			// GetDeviceID can map it to the real device.
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: Mapping GUID_NULL to DSDEVID_DefaultPlayback");
			lpguidPlaybackDeviceIn = &DSDEVID_DefaultPlayback;
		}

		GUID guidTemp;
		hr = pfGetDeviceID(lpguidPlaybackDeviceIn, &guidTemp);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, DVF_ERRORLEVEL, "GetDeviceID failed: %i", hr);
			if (hr == DSERR_NODRIVER)
			{
				hr = DVERR_INVALIDDEVICE;
			}
			else
			{
				hr = DVERR_GENERIC;
			}
			goto error_cleanup;
		}
		if (*lpguidPlaybackDeviceIn != guidTemp)
		{
			DPFX(DPFPREP, DVF_WARNINGLEVEL, "Warning: GetDeviceID mapped device GUID");
			*lpguidPlaybackDeviceOut = guidTemp;
		}
		else
		{
			*lpguidPlaybackDeviceOut = *lpguidPlaybackDeviceIn;
		}
	}
	
	if (!FreeLibrary(hDSound))
	{
		lRet = GetLastError();
		DPFX(DPFPREP, DVF_ERRORLEVEL, "FreeLibrary failed, code: %i", lRet);
		hr = DVERR_GENERIC;
		goto error_cleanup;
	}

	return DV_OK;

error_cleanup:
	if (hDSound != NULL)
	{
		FreeLibrary(hDSound);
	}
	DPF_EXIT();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\diagnos.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		diagnos.h
 *  Content:	Utility functions to write out diagnostic files when registry key is set.  
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/13/00	rodtoll	Created (Bug #31468 - Add diagnostic spew to logfile to show what is failing
 *
 ***************************************************************************/
#ifndef __DIAGNOS_H
#define __DIAGNOS_H

void Diagnostics_WriteDeviceInfo( DWORD dwLevel, const char *szDeviceName, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pData );
HRESULT Diagnostics_DeviceInfo( GUID *pguidPlayback, GUID *pguidCapture );
HRESULT Diagnostics_Begin( BOOL fEnabled, const char *szFileName );
void Diagnostics_End();
void Diagnostics_Write( DWORD dwLevel, const char *szFormat, ... );
void Diagnostics_WriteGUID( DWORD dwLevel, GUID &guid );
void Diagnositcs_WriteWAVEFORMATEX( DWORD dwLevel, PWAVEFORMATEX lpwfxFormat );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\diagnos.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		diagnos.cpp
 *  Content:	Utility functions to write out diagnostic files when registry key is set.  
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/13/00	rodtoll	Created (Bug #31468 - Add diagnostic spew to logfile to show what is failing
 *  08/22/2000	rodtoll	Bug #43060 - DPVOICE: Diagnostics data which is dumped to memory / debugger contains garbage
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DPLOG_MAX_STRING 256

FILE *g_hOutputFile = NULL;
BOOL g_fDiagnosisEnabled = FALSE;

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_WriteDeviceInfo"
void Diagnostics_WriteDeviceInfo( DWORD dwLevel, const char *szDeviceName, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA pData )
{
	Diagnostics_Write(  dwLevel, "%s Device Information:", szDeviceName );
	Diagnostics_Write(  dwLevel, "Device Name:\n%s", pData->Description ? pData->Description : "<NULL>");
	Diagnostics_Write(  dwLevel, "Device ID:" );
	Diagnostics_WriteGUID(dwLevel,  pData->DeviceId );

	switch( pData->Type )
	{
	case DIRECTSOUNDDEVICE_TYPE_EMULATED:	Diagnostics_Write(  dwLevel, "Device Type:\nEmulated" );	break;
	case DIRECTSOUNDDEVICE_TYPE_VXD:		Diagnostics_Write(  dwLevel, "Device Type:\nVXD" );		break;
	case DIRECTSOUNDDEVICE_TYPE_WDM:		Diagnostics_Write(  dwLevel, "Device Type:\nWDM" );		break;
	default:								Diagnostics_Write(  dwLevel, "Device Type:\n<UNKNOWN>" );	break;
	}

	Diagnostics_Write(  dwLevel, "Description:\n%s", pData->Description ? pData->Description : "<NULL>" );
	Diagnostics_Write(  dwLevel, "Module:\n%s", pData->Module ? pData->Module : "<NULL>" );
	Diagnostics_Write(  dwLevel, "WaveID:\n%d", pData->WaveDeviceId );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_DeviceInfo"
HRESULT Diagnostics_DeviceInfo( GUID *pguidPlayback, GUID *pguidCapture )
{
	if( !g_fDiagnosisEnabled )
		return DV_OK;

	LPKSPROPERTYSET lpksProperty = NULL;
	HRESULT hr = DV_OK;
	GUID guidTruePlayback;
	GUID guidTrueCapture;
	PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pPlaybackDesc = NULL;
	PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA pCaptureDesc = NULL;

	hr = DV_MapCaptureDevice( pguidPlayback, &guidTruePlayback );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting true playback device hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	hr = DV_MapPlaybackDevice( pguidCapture, &guidTrueCapture );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting true capture device hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	hr = DirectSoundPrivateCreate( &lpksProperty );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting interface to get device name hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	hr = PrvGetDeviceDescription( lpksProperty, guidTruePlayback, &pPlaybackDesc );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting device description hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	Diagnostics_WriteDeviceInfo( DVF_INFOLEVEL, "Playback", pPlaybackDesc );

	hr = PrvGetDeviceDescription( lpksProperty, guidTrueCapture, &pCaptureDesc );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  0, "Error getting device description hr=0x%x", hr );
		goto DEVICEINFO_EXIT;
	}

	Diagnostics_WriteDeviceInfo( DVF_INFOLEVEL, "Capture", pPlaybackDesc );

DEVICEINFO_EXIT:

	if( pPlaybackDesc )
		delete pPlaybackDesc;

	if( pCaptureDesc )
		delete pCaptureDesc;
		
	if( lpksProperty )
	{
		lpksProperty->Release();
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_Begin"
HRESULT Diagnostics_Begin( BOOL fEnabled, const char *szFileName )
{
	// Prevent double-open
	if( g_fDiagnosisEnabled )
		return DV_OK;

	HRESULT hr = DV_OK;

	g_fDiagnosisEnabled = fEnabled;

	if( !fEnabled )
		return DV_OK;

	g_hOutputFile = fopen( szFileName, "w" );

	if( !g_hOutputFile )
	{
		hr = DVERR_GENERIC;
		DPFX(DPFPREP,  0, "Error opening diagnostics file" );
		goto BEGIN_ERROR;
	}

	return DV_OK;

BEGIN_ERROR:

	Diagnostics_End();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_End"
void Diagnostics_End()
{
	if( g_fDiagnosisEnabled )
	{
		if( g_hOutputFile )
		{
			fclose( g_hOutputFile );
			g_hOutputFile = NULL;
		}
		g_fDiagnosisEnabled = FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnostics_Write"
void Diagnostics_Write( DWORD dwLevel, const char *szFormat, ... )
{
	char szBuffer[DPLOG_MAX_STRING];
	va_list argptr;
	va_start(argptr, szFormat);

	if( g_fDiagnosisEnabled )
	{
		vfprintf( g_hOutputFile, szFormat, argptr );
		fputs( "\n", g_hOutputFile );
	}

	_vsnprintf( szBuffer, DPLOG_MAX_STRING, szFormat, argptr );

	DPFX(DPFPREP,  dwLevel, szBuffer );

	va_end(argptr);

	fflush( g_hOutputFile );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnositcs_WriteWAVEFORMATEX"
void Diagnostics_WriteGUID( DWORD dwLevel, GUID &guid )
{
	Diagnostics_Write( dwLevel, "{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", guid.Data1, guid.Data2, guid.Data3, 
               guid.Data4[0], guid.Data4[1], guid.Data4[2], guid.Data4[3],
               guid.Data4[4], guid.Data4[5], guid.Data4[6], guid.Data4[7] );
}

#undef DPF_MODNAME
#define DPF_MODNAME "Diagnositcs_WriteWAVEFORMATEX"
void Diagnositcs_WriteWAVEFORMATEX( DWORD dwLevel, PWAVEFORMATEX lpwfxFormat )
{
	Diagnostics_Write( dwLevel, "wFormatTag = %d", lpwfxFormat->wFormatTag );
	Diagnostics_Write( dwLevel, "nSamplesPerSec = %d", lpwfxFormat->nSamplesPerSec );
	Diagnostics_Write( dwLevel, "nChannels = %d", lpwfxFormat->nChannels );
	Diagnostics_Write( dwLevel, "wBitsPerSample = %d", lpwfxFormat->wBitsPerSample );
	Diagnostics_Write( dwLevel, "nAvgBytesPerSec = %d", lpwfxFormat->nAvgBytesPerSec );
	Diagnostics_Write( dwLevel, "nBlockAlign = %d", lpwfxFormat->nBlockAlign );
	Diagnostics_Write( dwLevel, "cbSize = %d", lpwfxFormat->cbSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecb.h
 *  Content:	Definition of the CDirectSoundCaptureRecordBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/22/99		rodtoll	Added code to allow specification of wave device ID
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail
 * 		        rodtoll	Added SelectMicrophone call to the interface 
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDCAPTURERECORDBUFFER_H
#define __DIRECTSOUNDCAPTURERECORDBUFFER_H

// Uncomment out to get a lockup of the recording position after LOCKUP_NUM_FRAMES_BEFORE_LOCKUP frames
//#define LOCKUP_SIMULATION						1
#define LOCKUP_NUM_CALLS_BEFORE_LOCKUP			60

// Uncomment to have Stop fail on a reset
//#define LOCKUP_STOPFAIL			

// Uncomment to have Start fail on a reset
//#define LOCKUP_STARTFAIL

// CDirectSoundCaptureRecordBuffer
//
// This class provides an implementation of the CAudioRecordBuffer class
// for directsound.  In the abstract sense, it represents a buffer of audio
// which can be played to the sound hardware which consists of multiple,
// equal length subbuffers.  
//
class CDirectSoundCaptureRecordBuffer: public CAudioRecordBuffer
{
public:
    CDirectSoundCaptureRecordBuffer( LPDIRECTSOUNDCAPTUREBUFFER lpdsBuffer, HWND hwndOwner, const GUID &guidDevice, UINT uiWaveDeviceID, LPDSCBUFFERDESC lpdsBufferDesc );
    virtual ~CDirectSoundCaptureRecordBuffer();

public: 

    HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags );
    HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 );
    HRESULT GetVolume( LPLONG lplVolume );
    HRESULT SetVolume( LONG lVolume );
    HRESULT GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus );
    HRESULT Record( BOOL fLooping );
    HRESULT Stop();  
    HRESULT SelectMicrophone( BOOL fSelect );

    HRESULT YieldFocus();
    HRESULT ClaimFocus();    

	LPWAVEFORMATEX GetRecordFormat();
    DWORD GetStartupLatency();

protected: 

    BOOL                            m_fUseCaptureFocus;
	HWND							m_hwndOwner;
	LPDIRECTSOUNDCAPTUREBUFFER		m_lpdscBuffer;
	LPDIRECTSOUNDCAPTUREBUFFER7_1	m_lpdscBuffer7;
	UINT							m_uiWaveDeviceID;
	LPWAVEFORMATEX					m_lpwfxRecordFormat;
	GUID							m_guidDevice;
	CMixerLine						m_mixerLine;
#ifdef LOCKUP_SIMULATION	
	DWORD							m_dwNumSinceLastLockup;
	DWORD							m_dwLastPosition;
#endif 	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecd.h
 *  Content:	Definition of the CDirectSoundCaptureRecordDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation of object using a pre-created
 *						DirectSoundCapture Object.
 * 08/04/99		rodtoll	Added member to retrieve DSC object
 * 11/12/99		rodtoll	Modified abstraction for new waveIN support.
 *						Now abstracted types look almost like dsoundcap objects  
 * 11/22/99		rodtoll	Added code to map from GUID to waveIN device
 *						ID for non-millenium systems.
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail 
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 *				rodtoll	New algorithm to map from GUIDs to device IDs if DSound 7.1 is not
 *						available.  Will map device correctly on DX7, will guess for other
 *						DX versions < 7.  However, default device is assumed to be waveIN ID #0.
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *
 ***************************************************************************/

// DirectSoundCaptureRecordDevice.cpp
//
// This module contains the declaration of the DirectSoundCaptureRecordDevice
// class.  See the class definition below for a description
//
// Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
#ifndef __DIRECTSOUNDCAPTURERECORDDEVICE_H
#define __DIRECTSOUNDCAPTURERECORDDEVICE_H

// CDirectSoundCaptureRecordDevice
//
// This class provides an implementation of the CAudioRecordDevice class which
// uses the DirectSoundCapture API to talk to the recording hardware.  
//
class CDirectSoundCaptureRecordDevice: public CAudioRecordDevice
{
public:
	CDirectSoundCaptureRecordDevice();
	
    virtual ~CDirectSoundCaptureRecordDevice();

public: // Initialization

    HRESULT Initialize( const GUID &refguidDevice );
    HRESULT Initialize( LPDIRECTSOUNDCAPTURE lpdsc, const GUID &guidDevice );
    
    HRESULT CreateBuffer( LPDSCBUFFERDESC lpdscBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lpapBuffer ); 

    LPDIRECTSOUNDCAPTURE GetCaptureDevice();

    HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality );
    HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality );    

protected:

	HRESULT	FindDeviceID();

    LPDIRECTSOUNDCAPTURE		m_lpdscDirectSound;		// DirectSoundCapture interface
    GUID						m_guidDevice;
    UINT						m_uiWaveDeviceID;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecb.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundCaptureRecordBuffer.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/22/99		rodtoll	Added code to allow specification of wave device ID
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail 
 *				rodtoll	Updated with new Microphone select member
 * 12/08/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support
 *						- Added lpfLostFocus param to GetCurrentPosition so upper 
 *						  layers can detect lost focus.
 * 01/28/2000	rodtoll	Bug #130465: Record Mute/Unmute must call YieldFocus() / ClaimFocus() 
 * 02/10/2000	rodtoll	Removed more capture focus code
 * 04/19/2000   rodtoll Re-enabled capture focus behaviour 
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 04/22/2001	rodtoll	Fixed bug in lockup simulation code (TESTING PURPOSES ONLY)
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

#define DSC_STARTUP_LATENCY 1

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::CDirectSoundCaptureRecordBuffer"
CDirectSoundCaptureRecordBuffer::CDirectSoundCaptureRecordBuffer(
	LPDIRECTSOUNDCAPTUREBUFFER lpdscBuffer, HWND hwndOwner, const GUID &guidDevice, UINT uiWaveDeviceID, LPDSCBUFFERDESC lpdsBufferDesc
): CAudioRecordBuffer(), m_lpwfxRecordFormat(NULL), m_lpdscBuffer7(NULL), 
   m_guidDevice(guidDevice), m_uiWaveDeviceID(uiWaveDeviceID), 
#ifdef LOCKUP_SIMULATION   
	m_dwNumSinceLastLockup(0), m_dwLastPosition(0),
#endif
	m_hwndOwner(hwndOwner), m_fUseCaptureFocus( FALSE )
{
	HRESULT hr;
	DWORD dwSize;

	if( lpdsBufferDesc->dwFlags & DSCBCAPS_FOCUSAWARE )
	{
	    DPFX(DPFPREP,  1, "Enabling focus" );
	    m_fUseCaptureFocus = TRUE;
	}
	else
	{
	    DPFX(DPFPREP,  1, "Disabling focus" );
        m_fUseCaptureFocus = FALSE;
	}
	
	hr = lpdscBuffer->QueryInterface( IID_IDirectSoundCaptureBuffer, (void **) &m_lpdscBuffer );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get dsound buffer interface" );
		m_lpdscBuffer = NULL;
	}

	hr = lpdscBuffer->QueryInterface( IID_IDirectSoundCaptureBuffer7_1, (void **) &m_lpdscBuffer7 );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not retrieve new interface hr=0x%x.", hr );

		hr = m_mixerLine.Initialize( m_uiWaveDeviceID );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to acquire volume controls hr=0x%x", hr );
			DNASSERT( FALSE );
		}		
	}  
	else 
	{
	    if( m_fUseCaptureFocus )
	    {
    		hr = m_lpdscBuffer7->SetFocusHWND( hwndOwner );

    		if( FAILED( hr ) )
    		{
    			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to set the focus window hr = 0x%x", hr );
    			DNASSERT( FALSE );
    		}
	    }
	}

	hr = lpdscBuffer->GetFormat( NULL, 0, &dwSize );

	m_lpwfxRecordFormat = (LPWAVEFORMATEX) new BYTE[dwSize];

	if( m_lpwfxRecordFormat == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to allocate space for record format" );
		DNASSERT( FALSE );
	}

	hr = lpdscBuffer->GetFormat( m_lpwfxRecordFormat, dwSize, NULL );

	if( FAILED( hr ) )
	{
		delete [] ((LPBYTE) m_lpwfxRecordFormat);
		m_lpwfxRecordFormat = NULL;
	}

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::CDirectSoundCaptureRecordBuffer"
CDirectSoundCaptureRecordBuffer::~CDirectSoundCaptureRecordBuffer()
{
	if( m_lpdscBuffer7 != NULL )
	{
		m_lpdscBuffer7->Release();
	}
	
	if( m_lpdscBuffer != NULL )
	{
		m_lpdscBuffer->Release();
	}

	if( m_lpwfxRecordFormat != NULL )
	{
		delete [] ((LPBYTE) m_lpwfxRecordFormat);
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::Lock"
HRESULT CDirectSoundCaptureRecordBuffer::Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags )
{
	HRESULT hr;
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	hr = m_lpdscBuffer->Lock( dwWriteCursor, dwWriteBytes, lplpvBuffer1, lpdwSize1, lplpvBuffer2, lpdwSize2, dwFlags );

	DSERTRACK_Update( "DSCB::Lock()", hr );

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::UnLock"
HRESULT CDirectSoundCaptureRecordBuffer::UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 )
{
	HRESULT hr;
	
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	hr = m_lpdscBuffer->Unlock( lpvBuffer1, dwSize1, lpvBuffer2, dwSize2 );	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::SetVolume"
HRESULT CDirectSoundCaptureRecordBuffer::SetVolume( LONG lVolume )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	if( m_lpdscBuffer7 != NULL )
	{
		hr = m_lpdscBuffer7->SetVolume( lVolume );
	}
	else
	{
		hr = m_mixerLine.SetMasterRecordVolume( lVolume );
	}

	// This is only a warning condition
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Could not set master volume hr=0x%x", hr );
	}

	
	if( m_lpdscBuffer7 != NULL )
	{
		hr = m_lpdscBuffer7->SetMicVolume( lVolume );
	}
	else
	{
		hr = m_mixerLine.SetMicrophoneVolume( lVolume );
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_INFOLEVEL, "Unable to set Microphone volume hr=0x%x", hr );
		return hr;
	}
		
	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetVolume"
HRESULT CDirectSoundCaptureRecordBuffer::GetVolume( LPLONG lplVolume )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;
	
	if( m_lpdscBuffer7 != NULL )
	{
		hr = m_lpdscBuffer7->GetMicVolume( lplVolume );
	}
	else
	{
		hr = m_mixerLine.GetMicrophoneVolume( lplVolume );
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get Microphone volume hr=0x%x", hr );

		if( m_lpdscBuffer7 != NULL )
		{
			hr = m_lpdscBuffer7->GetVolume( lplVolume );
		}
		else
		{
			hr = m_mixerLine.GetMasterRecordVolume( lplVolume );
		}

		// This is only a warning condition
		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Could not get master record volume hr=0x%x", hr );
			return hr;
		}		

		return hr;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetCurrentPosition"
HRESULT CDirectSoundCaptureRecordBuffer::GetCurrentPosition( LPDWORD lpdwPosition, LPBOOL lpfLostFocus )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSoundCapture Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

#ifdef LOCKUP_SIMULATION	
	m_dwNumSinceLastLockup++;

	if( m_dwNumSinceLastLockup > LOCKUP_NUM_CALLS_BEFORE_LOCKUP )
	{
		*lpdwPosition = m_dwLastPosition;
		*lpfLostFocus = FALSE;
		return DV_OK;
	}
#endif

	HRESULT hr;

	if( m_lpdscBuffer7 != NULL && m_fUseCaptureFocus )
	{
		DWORD dwStatus;
		hr = m_lpdscBuffer7->GetStatus( &dwStatus );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error getting status hr=0x%x", hr );
			*lpfLostFocus = FALSE;
		}
		else
		{
			*lpfLostFocus = (dwStatus & DSCBSTATUS_LOSTFOCUS) ? TRUE : FALSE;
		}
	}
	else
	{
		*lpfLostFocus = FALSE;
	}

	hr = m_lpdscBuffer->GetCurrentPosition( NULL, lpdwPosition );

#ifdef LOCKUP_SIMULATION	
	m_dwLastPosition = *lpdwPosition;
#endif

	DSERTRACK_Update( "DSCB::GetCurrentPosition()", hr );		

	return hr;

}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::Play"
HRESULT CDirectSoundCaptureRecordBuffer::Record( BOOL fLooping )
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	hr = m_lpdscBuffer->Start( (fLooping) ? DSCBSTART_LOOPING : 0 );	

#ifdef LOCKUP_SIMULATION	

#ifdef LOCKUP_STOPFAIL		
	if( m_dwNumSinceLastLockup > LOCKUP_NUM_CALLS_BEFORE_LOCKUP )
	{
		hr = DSERR_GENERIC;
	}
#else
	m_dwNumSinceLastLockup = 0;
#endif

#endif

	DSERTRACK_Update( "DSCB::Start()", hr );		

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::Stop"
HRESULT CDirectSoundCaptureRecordBuffer::Stop()
{
	if( m_lpdscBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	hr = m_lpdscBuffer->Stop(  );	

#ifdef LOCKUP_SIMULATION	

#ifdef LOCKUP_STOPFAIL		
	if( m_dwNumSinceLastLockup > LOCKUP_NUM_CALLS_BEFORE_LOCKUP )
	{
		
		hr = DSERR_GENERIC;
	}
#endif 
	
#endif

	DSERTRACK_Update( "DSCB::Stop()", hr );		

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetStartupLatency"
DWORD CDirectSoundCaptureRecordBuffer::GetStartupLatency()
{
	return DSC_STARTUP_LATENCY;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::GetRecordFormat"
LPWAVEFORMATEX CDirectSoundCaptureRecordBuffer::GetRecordFormat()
{
	return m_lpwfxRecordFormat;	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::SelectMicrophone"
HRESULT CDirectSoundCaptureRecordBuffer::SelectMicrophone( BOOL fSelect )
{
	if( m_lpdscBuffer7 != NULL )
	{
		return m_lpdscBuffer7->EnableMic( fSelect );
	}
	else
	{
		return m_mixerLine.EnableMicrophone( fSelect );
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::ClaimFocus"
HRESULT CDirectSoundCaptureRecordBuffer::ClaimFocus(  )
{
	if( m_lpdscBuffer7 != NULL && m_fUseCaptureFocus)
	{
		return m_lpdscBuffer7->ClaimFocus();
	}
	else
	{
		return DVERR_NOTSUPPORTED;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordBuffer::YieldFocus"
HRESULT CDirectSoundCaptureRecordBuffer::YieldFocus(  )
{
	if( m_lpdscBuffer7 != NULL && m_fUseCaptureFocus )
	{
		return m_lpdscBuffer7->YieldFocus();
	}
	else
	{
		return DVERR_NOTSUPPORTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dscrecd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecd.cpp
 *  Content:
 *		This file contains the DirectSoundCapture implementation of the 
 *		CAudioRecordDevice abstraction.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 11/04/99		rodtoll	Created
 * 11/12/99		rodtoll	Modified abstraction for new waveIN support.
 *						Now abstracted types look almost like dsoundcap objects  
 * 11/22/99		rodtoll	Added code to map from GUID to waveIN device
 *						ID for non-millenium systems.
 * 11/23/99		rodtoll Updated to use waveIn device ID or DSound 7.1 when they are avail 
 * 12/01/99		rodtoll	Bug #115783 - Will always adjust volume of default device
 *						Now uses new CMixerLine class for adjusting volumes/selecting mic 
 *				rodtoll	New algorithm to map from GUIDs to device IDs if DSound 7.1 is not
 *						available.  Will map device correctly on DX7, will guess for other
 *						DX versions < 7.  However, default device is assumed to be waveIN ID #0. 
 * 12/08/99		rodtoll Bug #121054 - DirectX 7.1 support.  
 *						- Added hwndOwner param for capture focus support 
 * 04/21/2000   rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                      to allow reads of REG_BINARY when expecting REG_DWORD 
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 * 06/28/2000	rodtoll	Prefix Bug #38022
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 08/28/2000	masonb  Voice Merge: Changed ccomutil.h to comutil.h
 * 09/13/2000	rodtoll	Bug #44806 - When volume control not avail, dropping to DX7 levels instead of disabling volume control 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


// This function is responsible for mapping from the Device's GUID to the
// waveIN ID.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::FindDeviceID"
HRESULT CDirectSoundCaptureRecordDevice::FindDeviceID()
{
	HRESULT hr;

	DWORD dwDeviceID = 0;
	
	hr = DV_MapGUIDToWaveID( TRUE, m_guidDevice, &dwDeviceID );

	// If we were going to use the hack for enum of devices
	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find waveIN ID, mapping to ID 0 hr=0x%x", hr );
		m_uiWaveDeviceID = 0;
	}	
	else
	{
		m_uiWaveDeviceID = dwDeviceID;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::CDirectSoundCaptureRecordDevice"
CDirectSoundCaptureRecordDevice::CDirectSoundCaptureRecordDevice(
): CAudioRecordDevice(), m_lpdscDirectSound(NULL), m_uiWaveDeviceID(0), m_guidDevice(GUID_NULL)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::CDirectSoundCaptureRecordDevice"
CDirectSoundCaptureRecordDevice::~CDirectSoundCaptureRecordDevice()
{
	if( m_lpdscDirectSound != NULL )
	{
		m_lpdscDirectSound->Release();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::Initialize"
HRESULT CDirectSoundCaptureRecordDevice::Initialize( LPDIRECTSOUNDCAPTURE lpdscDirectSound, const GUID &guidDevice  )
{
	HRESULT hr;

	if( m_lpdscDirectSound != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already initialized" );
		return DVERR_INITIALIZED;
	}

	hr = lpdscDirectSound->QueryInterface( IID_IDirectSoundCapture, (void **) &m_lpdscDirectSound );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "DirectSoundCapture Object passed failed. 0x%x Creating internal", hr );
		m_lpdscDirectSound = NULL;
		return hr;
	}

	m_guidDevice = guidDevice;

	hr = FindDeviceID();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find waveIn ID for device hr=0x%x", hr );
		m_lpdscDirectSound->Release();
		return hr;
	}	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::Initialize"
HRESULT CDirectSoundCaptureRecordDevice::Initialize( const GUID &guidDevice  )
{
	HRESULT hr;
		
	if( m_lpdscDirectSound != NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Already initialized" );
		return DVERR_INITIALIZED;
	}

	hr = COM_CoCreateInstance( CLSID_DirectSoundCapture, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectSoundCapture, (void **) &m_lpdscDirectSound );

	DSERTRACK_Update( "DSCD:CoCreateInstance()", hr );		

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to load directsoundcapture hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	hr = m_lpdscDirectSound->Initialize( &guidDevice );

	DSERTRACK_Update( "DSCD:Initialize()", hr );			

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to initialize directsoundcapture hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	m_guidDevice = guidDevice;

	hr = FindDeviceID();

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to find waveIn ID for device hr=0x%x", hr );
		return hr;
	}

	return DV_OK;

INITIALIZE_ERROR:

	if( m_lpdscDirectSound != NULL )
	{
		m_lpdscDirectSound->Release();
		m_lpdscDirectSound = NULL;
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::CreateBuffer"
HRESULT CDirectSoundCaptureRecordDevice::CreateBuffer( LPDSCBUFFERDESC lpdsBufferDesc, HWND hwndOwner, DWORD dwFrameSize, CAudioRecordBuffer **lplpacBuffer )
{
	HRESULT hr;

	LPDIRECTSOUNDCAPTUREBUFFER lpdscBuffer;

	lpdsBufferDesc->dwFlags |= DSCBCAPS_CTRLVOLUME;

	hr = m_lpdscDirectSound->CreateCaptureBuffer( lpdsBufferDesc, &lpdscBuffer, NULL );

	DSERTRACK_Update( "DSCD::CreateCaptureBuffer()", hr );	

	// Ask for volume control, if we can't get it, do the old create
	if( hr == DSERR_INVALIDPARAM || hr == DSERR_CONTROLUNAVAIL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "New caps are not available, attempting old create hr=0x%x", hr );

		// Turn off the new caps -- (for non-Millenium systems).
		lpdsBufferDesc->dwFlags &= ~(DSCBCAPS_CTRLVOLUME);

		hr = m_lpdscDirectSound->CreateCaptureBuffer( lpdsBufferDesc, &lpdscBuffer, NULL );		
				
	}

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Failed to create the capture buffer hr=0x%x", hr );
		return hr;
	}

	*lplpacBuffer = new CDirectSoundCaptureRecordBuffer( lpdscBuffer, hwndOwner, m_guidDevice, m_uiWaveDeviceID, lpdsBufferDesc );

	lpdscBuffer->Release();

	if( *lplpacBuffer == NULL )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
		return DVERR_OUTOFMEMORY;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::GetCaptureDevice"
LPDIRECTSOUNDCAPTURE CDirectSoundCaptureRecordDevice::GetCaptureDevice()
{
	return m_lpdscDirectSound;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::GetMixerQuality"
HRESULT CDirectSoundCaptureRecordDevice::GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to get mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvGetMixerSrcQuality( pPropertySet, m_guidDevice, psrcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundCaptureRecordDevice::SetMixerQuality"
HRESULT CDirectSoundCaptureRecordDevice::SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to set mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvSetMixerSrcQuality( pPropertySet, m_guidDevice, srcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayb.h
 *  Content:	Definition of the CDirectSoundPlaybackBuffer class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume 
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects   
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 04/17/2000   rodtoll Fix: Bug #32215 - Session Lost after resuming from hibernation 
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDPLAYBACKBUFFER_H
#define __DIRECTSOUNDPLAYBACKBUFFER_H

// CDirectSoundPlaybackBuffer
//
// This class provides an implementation of the CAudioPlaybackBuffer class
// for directsound.  In the abstract sense, it represents a buffer of audio
// which can be played to the sound hardware which consists of multiple,
// equal length subbuffers.  
//
class CDirectSoundPlaybackBuffer: public CAudioPlaybackBuffer
{
public:
    CDirectSoundPlaybackBuffer( LPDIRECTSOUNDBUFFER lpdsBuffer );
    virtual ~CDirectSoundPlaybackBuffer();

public: 

    HRESULT Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags );
    HRESULT UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 );
    HRESULT SetVolume( LONG lVolume );
    HRESULT GetCurrentPosition( LPDWORD lpdwPosition );
    HRESULT SetCurrentPosition( DWORD dwPosition );
    HRESULT Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer );    
    HRESULT Play( DWORD dwPriority, DWORD dwFlags );
    HRESULT Stop();    
    HRESULT Restore();

    DWORD GetStartupLatency();    

protected: 

	LPDIRECTSOUNDBUFFER	m_lpdsBuffer;
	DWORD m_dwLastPosition;
	DWORD m_dwPriority;
	DWORD m_dwFlags;
	BOOL  m_fPlaying;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dscrecb.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundPlaybackBuffer.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 08/04/99		rodtoll	Updated to take dsound ranges for volume
 * 08/27/99		rodtoll	Updated CreateBuffer call to remove DX7 dependencies.
 * 09/07/99		rodtoll	Added 3d caps to buffer
 * 09/20/99		rodtoll	Added memory allocation failure checks 
 * 10/05/99		rodtoll	Added DPF_MODNAMEs        
 * 11/02/99		pnewson Fix: Bug #116365 - using wrong DSBUFFERDESC
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects    
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 04/17/2000   rodtoll Fix: Bug #32215 - Session Lost after resuming from hibernation 
 * 07/12/2000	rodtoll	Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 * 10/04/2000	rodtoll	Bug #43510 - DPVOICE: Apps receive a DVMSGID_SESSIONLOST w/DVERR_LOCKEDBUFFER
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#define DSOUND_STARTUPLATENCY 1 

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::CDirectSoundPlaybackBuffer"
CDirectSoundPlaybackBuffer::CDirectSoundPlaybackBuffer(
	LPDIRECTSOUNDBUFFER lpdsBuffer 
): CAudioPlaybackBuffer(), m_dwLastPosition(0), m_dwPriority(0),m_dwFlags(0),m_fPlaying(FALSE)
{
	HRESULT hr;
	
	hr = lpdsBuffer->QueryInterface( IID_IDirectSoundBuffer, (void **) &m_lpdsBuffer );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to get dsound buffer interface" );
		m_lpdsBuffer = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::CDirectSoundPlaybackBuffer"
CDirectSoundPlaybackBuffer::~CDirectSoundPlaybackBuffer()
{
	if( m_lpdsBuffer != NULL )
	{
		m_lpdsBuffer->Release();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Lock"
HRESULT CDirectSoundPlaybackBuffer::Lock( DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *lplpvBuffer1, LPDWORD lpdwSize1, LPVOID *lplpvBuffer2, LPDWORD lpdwSize2, DWORD dwFlags )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	while( 1 )
	{
        hr = m_lpdsBuffer->Lock( dwWriteCursor, dwWriteBytes, lplpvBuffer1, lpdwSize1, lplpvBuffer2, lpdwSize2, dwFlags );

        if( hr == DSERR_BUFFERLOST ) 
        {
            DPFX(DPFPREP, 0, "Buffer lost while locking buffer" );
            hr = Restore();
        }
        else
        {
			DSERTRACK_Update( "DSB::Lock()", hr );	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
        
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::UnLock"
HRESULT CDirectSoundPlaybackBuffer::UnLock( LPVOID lpvBuffer1, DWORD dwSize1, LPVOID lpvBuffer2, DWORD dwSize2 )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

    hr = m_lpdsBuffer->Unlock( lpvBuffer1, dwSize1, lpvBuffer2, dwSize2 );	

    if( hr == DSERR_BUFFERLOST )
    {
        hr = DS_OK;
    }
    
	DSERTRACK_Update( "DSB::UnLock()", hr );	        		    	

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::SetVolume"
HRESULT CDirectSoundPlaybackBuffer::SetVolume( LONG lVolume )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	while( 1 ) 
	{
        hr = m_lpdsBuffer->SetVolume( lVolume );	

        if( hr == DSERR_BUFFERLOST )
        {
            DPFX(DPFPREP, 0, "Buffer lost while setting volume" );
            hr = Restore();
        }
        else
        {
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
        
	}

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::GetCurrentPosition"
HRESULT CDirectSoundPlaybackBuffer::GetCurrentPosition( LPDWORD lpdwPosition )
{
    HRESULT hr;
    
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	while( 1 )
	{
        hr = m_lpdsBuffer->GetCurrentPosition( NULL, lpdwPosition );	

        if( SUCCEEDED( hr ) )
        {
			DSERTRACK_Update( "DSB::GetCurrentPosition()", hr );	        		    	        	
            m_dwLastPosition = *lpdwPosition;
			break;
        }
        else if( hr == DSERR_BUFFERLOST )
        {
            DPFX(DPFPREP, 0, "Buffer lost while getting current position" );
            hr = Restore();
            DPFX(DPFPREP, 0, "Restore --> 0x%x", hr );
        }
        else
        {
			DSERTRACK_Update( "DSB::GetCurrentPosition()", hr );	        		    	        	        		    	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );


        
	}

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::SetCurrentPosition"
HRESULT CDirectSoundPlaybackBuffer::SetCurrentPosition( DWORD dwPosition )
{
    HRESULT hr;
    
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	while( 1 ) 
	{
    	hr = m_lpdsBuffer->SetCurrentPosition( dwPosition );	

        if( SUCCEEDED( hr ) )
        {
			DSERTRACK_Update( "DSB::SetCurrentPosition()", hr );	        		    	        	        	
            m_dwLastPosition = dwPosition;
			break;
        }
        else if( hr == DSERR_BUFFERLOST ) 
        {
            DPFX(DPFPREP, 0, "Buffer lost while setting position" );
            hr = Restore();
        }
        else
        {
			DSERTRACK_Update( "DSB::SetCurrentPosition()", hr );	        		    	        	        	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
        
	}

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Get3DBuffer"
HRESULT CDirectSoundPlaybackBuffer::Get3DBuffer( LPDIRECTSOUND3DBUFFER *lplpds3dBuffer )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	return m_lpdsBuffer->QueryInterface( IID_IDirectSound3DBuffer, (void **) lplpds3dBuffer );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Play"
HRESULT CDirectSoundPlaybackBuffer::Play( DWORD dwPriority, DWORD dwFlags )
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

    m_dwPriority = dwPriority ;
    m_dwFlags = dwFlags;

	while( 1 )
	{
        hr = m_lpdsBuffer->Play( 0, dwPriority, dwFlags );	

        if( hr == DSERR_BUFFERLOST ) 
        {
            DPFX(DPFPREP, 0, "Error playing buffer" );
            hr = Restore();
        }
        else
        {
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
	}

	m_fPlaying = TRUE;

	return hr;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Stop"
HRESULT CDirectSoundPlaybackBuffer::Stop()
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

	HRESULT hr;

	while( 1 )
	{
        hr = m_lpdsBuffer->Stop(  );		    

        m_fPlaying = FALSE;

        if( hr == DSERR_BUFFERLOST )
        {
            DPFX(DPFPREP, 0, "Error stopping buffer" );
            hr = Restore();
            // If buffer is lost during restore, no need to stop
            break;
        }
        else
        {
			DSERTRACK_Update( "DSB::Stop()", hr );	        		    	        	        	        	
            break;
        }

        if( hr == DSERR_BUFFERLOST )
            Sleep( 50 );
	}

	return hr;

}


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::Restore"
HRESULT CDirectSoundPlaybackBuffer::Restore()
{
	if( m_lpdsBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "No DirectSound Buffer Available" );
		return DVERR_NOTINITIALIZED;
	}

    HRESULT hr = m_lpdsBuffer->Restore(  );	

    DPFX(DPFPREP, 0, "Restore result --> 0x%x", hr );

    if( SUCCEEDED( hr ) )
    {
        if( m_fPlaying )
        {
            // Attempt to restore current position as well
            hr = m_lpdsBuffer->SetCurrentPosition( m_dwLastPosition );

            if( FAILED( hr ) )
            {
                DPFX(DPFPREP, 0, "Error setting position after restore hr=0x%x", hr );
                return hr;
            }

            hr = Play(m_dwPriority, m_dwFlags);
        }
    }

    return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackBuffer::GetStartupLatency"
DWORD CDirectSoundPlaybackBuffer::GetStartupLatency()
{
	return DSOUND_STARTUPLATENCY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayd.h
 *  Content:	Definition of the CDirectSoundPlaybackDevice class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation of object using a pre-created
 *						DirectSound Object.
 * 08/04/99		rodtoll	Added member to retrieve DirectSound object
 * 11/01/99		rodtoll	Updated to conform to new interface
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects    
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(For Win2k/Millenium/Systems w/DX7)
 *				rodtoll	Cleanup of class
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 02/17/2000	rodtoll	Updated so primary buffer is held instead of released immediately
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy. 
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDPLAYBACKDEVICE_H
#define __DIRECTSOUNDPLAYBACKDEVICE_H

class CDirectSoundPlaybackDevice;

// CDirectSoundPlaybackDevice
//
// This class is responsible for providing an implementation of the 
// CAudioPLaybackDevice class for DirectSound.  A single instance
// of this class represents a DirectSound playback device and
// is used to initialize the sound device and act as a class
// factory for CAudioPlaybackBuffers for the DirectSound
// sub-system.
//
class CDirectSoundPlaybackDevice: public CAudioPlaybackDevice
{
public:
    CDirectSoundPlaybackDevice( );

    virtual ~CDirectSoundPlaybackDevice();

public: // Initialization

    HRESULT Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *primaryFormat, BOOL fPriorityMode );
    HRESULT Initialize( LPDIRECTSOUND lpDirectSound, const GUID &guidDevice );

    BOOL IsEmulated() { return m_fEmulated; };
    
    HRESULT CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lpapBuffer );
    LPDIRECTSOUND GetPlaybackDevice();    

    HRESULT GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality );
    HRESULT SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality );
    
protected:

	HRESULT CheckAndSetEmulated( );
	
    LPDIRECTSOUND       m_lpdsDirectSound;			// DirectSound object associated w/this object
    LPDIRECTSOUNDBUFFER m_lpdsPrimaryBuffer;
    HWND				m_hwndOwner;
    GUID				m_guidDevice;
    BOOL				m_fEmulated;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsplayd.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsplayd.cpp
 *  Content:
 *		This module contains the implementation of the 
 *		CDirectSoundPlaybackDevice.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 07/30/99		rodtoll	Updated to allow creation of object using a pre-created
 *						DirectSound Object.
 * 10/05/99		rodtoll	Added DPF_MODNAMEs         
 * 10/14/99		rodtoll	Added 3d caps to primary buffer created
 * 10/27/99		rodtoll	Bug #115431: Must release primary buffer
 * 11/12/99		rodtoll	Modified abstraction for new waveOut support.
 *						Now abstracted types look almost like dsound objects   
 * 12/01/99		rodtoll Bug #121815 - Static in playback/record
 *						Added implementations of Set/GetMixerQuality
 *						(For Win2k/Millenium/Systems w/DX7) 
 * 01/27/2000	rodtoll	Updated sound classes to accept playback flags, 
 *						buffer structures and DSBUFFERDESC instead of DSBUFFERDESC1 
 * 02/16/2000	rodtoll	Fixed so primary buffer is not released
 * 02/17/2000	rodtoll	Updated so primary buffer is held instead of released immediately 
 * 04/21/2000   rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                      to allow reads of REG_BINARY when expecting REG_DWORD 
 * 04/24/2000   rodtoll Bug #33203 - Removed workaround for aureal vortex 1 problem -- had 
 *                      problems on Vortex 2.  
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 * 07/12/2000	rodtoll	Bug #31468 - Add diagnostic spew to logfile to show what is failing the HW Wizard
 * 08/03/2000	rodtoll	Bug #41457 - DPVOICE: need way to discover which specific dsound call failed when returning DVERR_SOUNDINITFAILURE 
 *  08/28/2000	masonb  Voice Merge: Changed ccomutil.h to comutil.h
 * 04/04/2001	rodtoll	WINBUG #343428 - DPVOICE:  Voice wizard's playback is very choppy. 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::CDirectSoundPlaybackDevice"
CDirectSoundPlaybackDevice::CDirectSoundPlaybackDevice(
): CAudioPlaybackDevice(), m_hwndOwner(NULL), m_lpdsDirectSound(NULL), m_guidDevice(GUID_NULL), m_lpdsPrimaryBuffer(NULL), m_fEmulated(FALSE)
{
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::~CDirectSoundPlaybackDevice"
CDirectSoundPlaybackDevice::~CDirectSoundPlaybackDevice()
{
	if( m_lpdsPrimaryBuffer != NULL )
	{
		m_lpdsPrimaryBuffer->Release();
		m_lpdsPrimaryBuffer = NULL;
	}
	
	if( m_lpdsDirectSound != NULL )	
	{	
		m_lpdsDirectSound->Release();
		m_lpdsDirectSound = NULL;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::CheckAndSetEmulated"
HRESULT CDirectSoundPlaybackDevice::CheckAndSetEmulated( )
{
	HRESULT hr;
	DSCAPS dsCaps;

	ZeroMemory( &dsCaps, sizeof( DSCAPS ) );
	dsCaps.dwSize = sizeof( DSCAPS );

	hr = m_lpdsDirectSound->GetCaps( &dsCaps );

	if( FAILED( hr ) )
	{
		m_fEmulated = FALSE;
		Diagnostics_Write(DVF_ERRORLEVEL, "Querying for playback caps failed hr=0x%x", hr );		
		return hr;
	}
	
	m_fEmulated = (dsCaps.dwFlags & DSCAPS_EMULDRIVER);

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::Initialize"
HRESULT CDirectSoundPlaybackDevice::Initialize( LPDIRECTSOUND lpdsDirectSound, const GUID &guidDevice )
{
	HRESULT hr;

	m_guidDevice = guidDevice;

	hr = lpdsDirectSound->QueryInterface( IID_IDirectSound, (void **) &m_lpdsDirectSound );

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "DirectSound Object passed failed. 0x%x Creating internal", hr );
		m_lpdsDirectSound = NULL;
		return hr;
	}

	hr = CheckAndSetEmulated();

	if( FAILED( hr ) )
	{
		m_lpdsDirectSound->Release();
		m_lpdsDirectSound = NULL;
		return hr;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::Initialize"
HRESULT CDirectSoundPlaybackDevice::Initialize( const GUID &guidDevice, HWND hwndOwner, WAVEFORMATEX *lpwfxFormat, BOOL fPriorityMode )
{
	HRESULT hr;
    DSBUFFERDESC dsbdesc;
    DWORD dwPriority;

    m_guidDevice = guidDevice;
		
	if( m_lpdsDirectSound != NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Already initialized" );
		return DVERR_INITIALIZED;
	}

	hr = COM_CoCreateInstance( CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER  , IID_IDirectSound, (void **) &m_lpdsDirectSound );

	DSERTRACK_Update( "DSD::CoCreateInstance()", hr );	        		    	        	        	        		

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to load directsound hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	hr = m_lpdsDirectSound->Initialize( &guidDevice );

	DSERTRACK_Update( "DSD::Initialize()", hr );	        		    	        	        	        			

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to initialize directsound hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	if( fPriorityMode )
	{
		dwPriority = DSSCL_PRIORITY;
	}
	else
	{
		dwPriority = DSSCL_NORMAL;
	}

	hr = m_lpdsDirectSound->SetCooperativeLevel( hwndOwner, dwPriority );

	DSERTRACK_Update( "DSD::SetCooperativeLevel()", hr );	

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to set cooperative level hr=0x%x", hr );
		goto INITIALIZE_ERROR;
	}

	if( fPriorityMode && lpwfxFormat != NULL )
	{
        memset(&dsbdesc, 0, sizeof(DSBUFFERDESC)); 
        dsbdesc.dwSize = sizeof(DSBUFFERDESC); 
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;
        dsbdesc.dwBufferBytes = 0; 
        dsbdesc.lpwfxFormat = NULL; 

        hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) &dsbdesc, &m_lpdsPrimaryBuffer, NULL );

		DSERTRACK_Update( "DSD::CreateSoundBuffer() (Primary)", hr );	        

        if( FAILED( hr ) )
        {
        	Diagnostics_Write(DVF_ERRORLEVEL, "Create of primary buffer failed.  Trying DX5 dsound hr=0x%x", hr );
        	dsbdesc.dwSize = sizeof( DSBUFFERDESC1 );

	        hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) &dsbdesc, &m_lpdsPrimaryBuffer, NULL );        	
        }

        if( FAILED( hr ) )
        {
        	Diagnostics_Write(DVF_ERRORLEVEL, "Could not create primary sound buffer" );
        	goto INITIALIZE_ERROR;
        }

        hr = m_lpdsPrimaryBuffer->SetFormat( lpwfxFormat );

		DSERTRACK_Update( "DSD::SetFormat() (Primary)", hr );	        
        
        if( FAILED( hr ) )
        {
        	Diagnostics_Write(DVF_ERRORLEVEL, "Could not set the format" );
        	goto INITIALIZE_ERROR;
        }
	}
	
	m_hwndOwner = hwndOwner;

	hr = CheckAndSetEmulated();

    if( FAILED( hr ) )
    {
    	Diagnostics_Write(DVF_ERRORLEVEL, "Could not get emulated state hr=0x%x", hr );
    	goto INITIALIZE_ERROR;
    }	

	return DV_OK;

INITIALIZE_ERROR:

	if( m_lpdsPrimaryBuffer )
	{
		m_lpdsPrimaryBuffer->Release();
		m_lpdsPrimaryBuffer = NULL;
	}

	if( m_lpdsDirectSound != NULL )
	{
		m_lpdsDirectSound->Release();
		m_lpdsDirectSound = NULL;
	}
	
	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::CreateBuffer"
HRESULT CDirectSoundPlaybackDevice::CreateBuffer( LPDSBUFFERDESC lpdsBufferDesc, DWORD dwFrameSize, CAudioPlaybackBuffer **lplpapBuffer )
{
	HRESULT hr;

	LPDIRECTSOUNDBUFFER lpdsBuffer;

	hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) lpdsBufferDesc, &lpdsBuffer, NULL );

	DSERTRACK_Update( "DSD::CreateSoundBuffer() ", hr );	        	

	if( FAILED( hr ) )
	{
		lpdsBufferDesc->dwSize = sizeof( DSBUFFERDESC1 );
		
		Diagnostics_Write(DVF_ERRORLEVEL, "Unable to create sound buffer under DX7.  Attempting DX5 create hr=0x%x", hr );

		hr = m_lpdsDirectSound->CreateSoundBuffer( (DSBUFFERDESC *) lpdsBufferDesc, &lpdsBuffer, NULL );
	}

	if( FAILED( hr ) )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Failed to create the sound buffer hr=0x%x", hr );
		return hr;
	}
/*
    // Freee wave format
	delete dsBufferDesc.lpwfxFormat;

	hr = lpdsBuffer->SetFrequency( 8000 );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  0, "Could not set frequency hr=0x%x", hr );
	    return hr;
	}*/

	*lplpapBuffer = new CDirectSoundPlaybackBuffer( lpdsBuffer );

	lpdsBuffer->Release();

	if( *lplpapBuffer == NULL )
	{
		Diagnostics_Write(DVF_ERRORLEVEL, "Out of memory" );
		return DVERR_OUTOFMEMORY;
	}

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::GetPlaybackDevice"
LPDIRECTSOUND CDirectSoundPlaybackDevice::GetPlaybackDevice( )
{
	return m_lpdsDirectSound;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::GetMixerQuality"
HRESULT CDirectSoundPlaybackDevice::GetMixerQuality( DIRECTSOUNDMIXER_SRCQUALITY *psrcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to get mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvGetMixerSrcQuality( pPropertySet, m_guidDevice, psrcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to retrieve mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirectSoundPlaybackDevice::SetMixerQuality"
HRESULT CDirectSoundPlaybackDevice::SetMixerQuality( const DIRECTSOUNDMIXER_SRCQUALITY srcQuality )
{
	HRESULT hr;
	LPKSPROPERTYSET	pPropertySet = NULL;

	hr = DirectSoundPrivateCreate( &pPropertySet );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to get int to set mixer quality hr=0x%x", hr );
		return hr;
	}

	hr = PrvSetMixerSrcQuality( pPropertySet, m_guidDevice, srcQuality );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_WARNINGLEVEL, "Unable to set mixer quality hr=0x%x", hr );
	}

	pPropertySet->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsutils.cpp
 *  Content:
 *		This module contains the implementation of the DirectSoundException class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 * 09/21/99		rodtoll	Updated to remove string translation in release build
 * 10/05/99		rodtoll	Added DPF_MODNAMEs         
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_MODNAME
#define DPF_MODNAME "DirectSoundException::MapResultToString"

// MapResultToString
//
// This function is used by the DirectSoundException class to map from
// HRESULT's returned from DirectSound to the string equivalent which
// is placed into the m_szErrorString member variable.  To retrieve
// this string, call DirectSoundException::what().
//
// Parameters:
// N/A
//
// Returns: 
// N/A
//
void DirectSoundException::MapResultToString()
{
#ifdef _DEBUG
    switch( m_result )
    {
    case DS_OK:
        _tcscpy( m_szErrorString, _T( "The request completed successfully." ) );
        break;
    case DSERR_ALLOCATED:
        _tcscpy( m_szErrorString, _T( "The request failed because resources, are already in use. " ) );
        break;
    case DSERR_ALREADYINITIALIZED:
        _tcscpy( m_szErrorString, _T( "The object is already initialized." ) );
        break;
    case DSERR_BADFORMAT:
        _tcscpy( m_szErrorString, _T( "The specified wave format is not supported." ) );
        break;
    case DSERR_BUFFERLOST:
        _tcscpy( m_szErrorString, _T( "The buffer memory has been lost and must be restored." ) );
        break;
    case DSERR_CONTROLUNAVAIL:
        _tcscpy( m_szErrorString, _T( "The control (volume, pan, and so forth) reqested not available" ) );
        break;
    case DSERR_GENERIC:
        _tcscpy( m_szErrorString, _T( "An undetermined error occurred inside the DirectSound subsystem." ) );
        break;
    case DSERR_INVALIDCALL:
        _tcscpy( m_szErrorString, _T( "This function is not valid for the current state of this object." ) );
        break;
    case DSERR_INVALIDPARAM:
        _tcscpy( m_szErrorString, _T( "An invalid parameter was passed to the returning function." ) );
        break;
    case DSERR_NOAGGREGATION:
        _tcscpy( m_szErrorString, _T( "The object does not support aggregation." ) );
        break;
    case DSERR_NODRIVER:
        _tcscpy( m_szErrorString, _T( "No sound driver is available for use." ) );
        break;
    case DSERR_NOINTERFACE:
        _tcscpy( m_szErrorString, _T( "The requested COM interface is not available." ) );
        break;
    case DSERR_OTHERAPPHASPRIO:
        _tcscpy( m_szErrorString, _T( "Another application has a higher priority level, preventing this call from succeeding" ) );
        break;
    case DSERR_OUTOFMEMORY:
        _tcscpy( m_szErrorString, _T( "The DirectSound subsystem could not allocate sufficient memory to complete the caller's request." ) );
        break;
    case DSERR_PRIOLEVELNEEDED:
        _tcscpy( m_szErrorString, _T( "The caller does not have the priority level required for the function to succeed." ) );
        break;
    case DSERR_UNINITIALIZED:
        _tcscpy( m_szErrorString, _T( "The IDirectSound::Initialize method has not been called or has not been called successfully before other methods were called." ) );
        break;
    case DSERR_UNSUPPORTED:
        _tcscpy( m_szErrorString, _T( "The function called is not supported at this time." ) );
        break;
    default:
        _tcscpy( m_szErrorString, _T( "Unknown error" ) );
        break;
    }
#else
	_tcscpy( m_szErrorString, _T("") );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsprvobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.c
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *  12/16/99	rodtoll	Added support for new funcs from dsound team on private
 *						interface for getting process dsound object list 
 *  01/08/2001	rodtoll WINBUG #256541	Pseudo: Loss of functionality: Voice Wizrd can't be launched. 
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#define MAX_OBJECTS		20


/***************************************************************************
 *
 *  DirectSoundPrivateCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundPrivate object.
 *
 *  Arguments:
 *      LPKSPROPERTYSET * [out]: receives IKsPropertySet interface to the
 *                               object.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *       ppKsPropertySet
)
{
    typedef HRESULT (STDAPICALLTYPE *LPFNDLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);

    HINSTANCE               hLibDsound              = NULL;
    LPFNGETCLASSOBJECT      pfnDllGetClassObject    = NULL;
    LPCLASSFACTORY          pClassFactory           = NULL;
    LPKSPROPERTYSET         pKsPropertySet          = NULL;
    HRESULT                 hr                      = DS_OK;

    // Get dsound.dll's instance handle.  The dll must already be loaded at this
    // point.
    hLibDsound = 
        GetModuleHandle
        (
            TEXT("dsound.dll")
        );

    if(!hLibDsound)
    {
        hr = DSERR_GENERIC;
    }

    // Find DllGetClassObject
    if(SUCCEEDED(hr))
    {
        pfnDllGetClassObject = (LPFNDLLGETCLASSOBJECT)
            GetProcAddress
            (
                hLibDsound, 
                "DllGetClassObject"
            );

        if(!pfnDllGetClassObject)
        {
            hr = DSERR_GENERIC;
        }
    }

    // Create a class factory object    
    if(SUCCEEDED(hr))
    {
        hr = 
            pfnDllGetClassObject
            (
                CLSID_DirectSoundPrivate, 
                IID_IClassFactory, 
                (LPVOID *)&pClassFactory
            );
    }

    // Create the DirectSoundPrivate object and query for an IKsPropertySet
    // interface
    if(SUCCEEDED(hr))
    {
        hr = 
            pClassFactory->CreateInstance
            (
                NULL, 
                IID_IKsPropertySet, 
                (LPVOID *)&pKsPropertySet
            );
    }

    // Release the class factory
    if(pClassFactory)
    {
        pClassFactory->Release();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppKsPropertySet = pKsPropertySet;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerSrcQuality
 *
 *  Description:
 *      Gets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY * [out]: receives mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *               pSrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pSrcQuality = Data.Quality;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerSrcQuality
 *
 *  Description:
 *      Sets the mixer SRC quality for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: mixer SRC quality.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY                 SrcQuality
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Quality = SrcQuality;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetMixerAcceleration
 *
 *  Description:
 *      Gets the mixer acceleration flags for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      LPDWORD [out]: receives acceleration flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetMixerAcceleration
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    LPDWORD                                         pdwAcceleration
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA   Data;
    HRESULT                                         hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pdwAcceleration = Data.Flags;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetMixerAcceleration
 *
 *  Description:
 *      Sets the mixer acceleration flags for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DWORD [in]: acceleration flags.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetMixerAcceleration
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    DWORD                                           dwAcceleration
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA   Data;
    HRESULT                                         hr;

    Data.DeviceId = guidDeviceId;
    Data.Flags = dwAcceleration;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundMixer,
            DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDevicePresence
 *
 *  Description:
 *      Determines whether a device is enabled.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      LPBOOL [out]: receives TRUE if the device is enabled.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDevicePresence
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    LPBOOL                                      pfEnabled
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pfEnabled = Data.Present;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetDevicePresence
 *
 *  Description:
 *      Sets whether a device is enabled.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      BOOL [in]: TRUE if the device is enabled.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetDevicePresence
(
    LPKSPROPERTYSET                             pKsPropertySet,
    REFGUID                                     guidDeviceId,
    BOOL                                        fEnabled
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Data;
    HRESULT                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Present = fEnabled;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}

/***************************************************************************
 *
 *  PrvGetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPCSTR [in]: wave device description.
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET                                     pKsPropertySet,
    LPCTSTR                                             pszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA Data;
    HRESULT                                             hr;

    Data.DeviceName = (LPTSTR)pszWaveDevice;
    Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pguidDeviceId = Data.DeviceId;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetWaveDeviceMappingW (Unicode)
 *
 *  Description:
 *      Gets the DirectSound device id (if any) for a given waveIn or
 *      waveOut device description.  This is the description given by
 *      waveIn/OutGetDevCaps (szPname).
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPWCSTR [in]: wave device description.
 *      BOOL [in]: TRUE if the device description refers to a waveIn device.
 *      LPGUID [out]: receives DirectSound device GUID.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetWaveDeviceMappingW
(
    LPKSPROPERTYSET                                     pKsPropertySet,
    LPWSTR                                              pwszWaveDevice,
    BOOL                                                fCapture,
    LPGUID                                              pguidDeviceId
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA Data;
    HRESULT                                               hr;

    Data.DeviceName = (LPWSTR)pwszWaveDevice;
    Data.DataFlow = fCapture ? DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE : DIRECTSOUNDDEVICE_DATAFLOW_RENDER;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pguidDeviceId = Data.DeviceId;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDeviceDescription
 *
 *  Description:
 *      Gets the extended description for a given DirectSound device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: receives
 *                                                            description.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA  pData   = NULL;
    ULONG                                           cbData;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA   Basic;
    HRESULT                                         hr;

    Basic.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA)new BYTE [cbData];

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = guidDeviceId;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDevice,
                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        delete[] pData;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvEnumerateDevices
 *
 *  Description:
 *      Enumerates all DirectSound devices.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK [in]: pointer to the callback
 *                                                   function.
 *      LPVOID [in]: context argument to pass to the callback function.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvEnumerateDevices
(
    LPKSPROPERTYSET                             pKsPropertySet,
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK      pfnCallback,
    LPVOID                                      pvContext
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_DATA Data;
    HRESULT                                     hr;

    Data.Callback = pfnCallback;
    Data.Context = pvContext;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDevice,
            DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetBasicAcceleration
 *
 *  Description:
 *      Gets basic acceleration flags for a given DirectSound device.  This
 *      is the accleration level that the multimedia control panel uses.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDBASICACCELERATION_LEVEL * [out]: receives basic 
 *                                                  acceleration level.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetBasicAcceleration
(
    LPKSPROPERTYSET                                             pKsPropertySet,
    REFGUID                                                     guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL *                        pLevel
)
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   Data;
    HRESULT                                                     hr;

    Data.DeviceId = guidDeviceId;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr))
    {
        *pLevel = Data.Level;
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetBasicAcceleration
 *
 *  Description:
 *      Sets basic acceleration flags for a given DirectSound device.  This
 *      is the accleration level that the multimedia control panel uses.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device GUID.
 *      DIRECTSOUNDBASICACCELERATION_LEVEL [in]: basic acceleration level.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetBasicAcceleration
(
    LPKSPROPERTYSET                                             pKsPropertySet,
    REFGUID                                                     guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL                          Level
)
{
    DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA   Data;
    HRESULT                                                     hr;

    Data.DeviceId = guidDeviceId;
    Data.Level = Level;

    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundBasicAcceleration,
            DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDebugInformation
 *
 *  Description:
 *      Gets the current DirectSound debug settings.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      LPDWORD [in]: receives DPF flags.
 *      PULONG [out]: receives DPF level.
 *      PULONG [out]: receives break level.
 *      LPSTR [out]: receives log file name.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDebugInformation
(
    LPKSPROPERTYSET                             pKsPropertySet,
    LPDWORD                                     pdwFlags,
    PULONG                                      pulDpfLevel,
    PULONG                                      pulBreakLevel,
    LPTSTR                                      pszLogFile
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    Data;
    HRESULT                                     hr;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO,
            NULL,
            0,
            &Data,
            sizeof(Data),
            NULL
        );

    if(SUCCEEDED(hr) && pdwFlags)
    {
        *pdwFlags = Data.Flags;
    }

    if(SUCCEEDED(hr) && pulDpfLevel)
    {
        *pulDpfLevel = Data.DpfLevel;
    }

    if(SUCCEEDED(hr) && pulBreakLevel)
    {
        *pulBreakLevel = Data.BreakLevel;
    }

    if(SUCCEEDED(hr) && pszLogFile)
    {
        lstrcpy
        (
            pszLogFile,
            Data.LogFile
        );
    }
    
    return hr;
}


/***************************************************************************
 *
 *  PrvSetDebugInformation
 *
 *  Description:
 *      Sets the current DirectSound debug settings.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      DWORD [in]: DPF flags.
 *      ULONG [in]: DPF level.
 *      ULONG [in]: break level.
 *      LPCSTR [in]: log file name.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetDebugInformation
(
    LPKSPROPERTYSET                             pKsPropertySet,
    DWORD                                       dwFlags,
    ULONG                                       ulDpfLevel,
    ULONG                                       ulBreakLevel,
    LPCTSTR                                     pszLogFile
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    Data;
    HRESULT                                     hr;

    Data.Flags = dwFlags;
    Data.DpfLevel = ulDpfLevel;
    Data.BreakLevel = ulBreakLevel;

    lstrcpy
    (
        Data.LogFile,
        pszLogFile
    );
    
    hr =
        pKsPropertySet->Set
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO,
            NULL,
            0,
            &Data,
            sizeof(Data)
        );

    return hr;
}


/***************************************************************************
 *
 *  PrvGetPersistentData
 *
 *  Description:
 *      Gets a registry value stored under the DirectSound subkey of a 
 *      specific hardware device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      LPCSTR [in]: subkey path.
 *      LPCSTR [in]: value name.
 *      LPDWORD [in/out]: receives registry data type.
 *      LPVOID [out]: data buffer.
 *      LPDWORD [in/out]: size of above buffer.  On entry, this argument is
 *                        filled with the maximum size of the data buffer.
 *                        On exit, this argument is filled with the required
 *                        size.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetPersistentData
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    REFGUID                                                 guidDeviceId,
    LPCTSTR                                                 pszSubkey,
    LPCTSTR                                                 pszValue,
    LPDWORD                                                 pdwRegType,
    LPVOID                                                  pvData,
    LPDWORD                                                 pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA  pPersist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    cbPersist = sizeof(*pPersist) + *pcbData;
    
    pPersist = (PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA)
        LocalAlloc
        (
            LPTR,
            cbPersist
        );

    if(pPersist)
    {
        pPersist->DeviceId = guidDeviceId;
        pPersist->SubKeyName = (LPTSTR)pszSubkey;
        pPersist->ValueName = (LPTSTR)pszValue;

        if(pdwRegType)
        {
            pPersist->RegistryDataType = *pdwRegType;
        }

        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                pPersist,
                cbPersist,
                &cbPersist
            );
    }
    else
    {
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr))
    {
        CopyMemory
        (
            pvData,
            pPersist + 1,
            *pcbData
        );
    }
    
    *pcbData = cbPersist - sizeof(*pPersist);

    if(pPersist && pdwRegType)
    {
        *pdwRegType = pPersist->RegistryDataType;
    }

    if(pPersist)
    {
        LocalFree(pPersist);
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvSetPersistentData
 *
 *  Description:
 *      Sets a registry value stored under the DirectSound subkey of a 
 *      specific hardware device.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      REFGUID [in]: DirectSound device id.
 *      LPCSTR [in]: subkey path.
 *      LPCSTR [in]: value name.
 *      DWORD [in]: registry data type.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvSetPersistentData
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    REFGUID                                                 guidDeviceId,
    LPCTSTR                                                 pszSubkey,
    LPCTSTR                                                 pszValue,
    DWORD                                                   dwRegType,
    LPVOID                                                  pvData,
    DWORD                                                   cbData
)
{
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA  pPersist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    cbPersist = sizeof(*pPersist) + cbData;
    
    pPersist = (PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA)
        LocalAlloc
        (
            LPTR,
            cbPersist
        );

    if(pPersist)
    {
        pPersist->DeviceId = guidDeviceId;
        pPersist->SubKeyName = (LPTSTR)pszSubkey;
        pPersist->ValueName = (LPTSTR)pszValue;
        pPersist->RegistryDataType = dwRegType;

        CopyMemory
        (
            pPersist + 1,
            pvData,
            cbData
        );

        hr =
            pKsPropertySet->Set
            (
                DSPROPSETID_DirectSoundPersistentData,
                DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA,
                NULL,
                0,
                pPersist,
                cbPersist
            );
    }
    else
    {
        hr = DSERR_OUTOFMEMORY;
    }

    if(pPersist)
    {
        LocalFree(pPersist);
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvTranslateErrorCode
 *
 *  Description:
 *      Translates an error code to a string representation.
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *      HRESULT [in]: result code.
 *      PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATEERRORCODE_DATA * [out]:
 *          receives error code data.  The caller is responsible for freeing
 *          this buffer.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvTranslateResultCode
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    HRESULT                                                 hrResult,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA * ppData
)
{
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA   pData   = NULL;
    DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA    Basic;
    ULONG                                                   cbData;
    HRESULT                                                 hr;

    Basic.ResultCode = hrResult;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSoundDebug,
            DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE,
            NULL,
            0,
            &Basic,
            sizeof(Basic),
            &cbData
        );

    if(SUCCEEDED(hr))
    {
        pData = (PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA)
            LocalAlloc
            (
                LPTR,
                cbData
            );

        if(!pData)
        {
            hr = DSERR_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        pData->ResultCode = hrResult;
        
        hr =
            pKsPropertySet->Get
            (
                DSPROPSETID_DirectSoundDebug,
                DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE,
                NULL,
                0,
                pData,
                cbData,
                NULL
            );
    }

    if(SUCCEEDED(hr))
    {
        *ppData = pData;
    }
    else if(pData)
    {
        LocalFree
        (
            pData
        );
    }

    return hr;
}


/***************************************************************************
 *
 *  PrvGetDirectSoundObjects
 *
 *  Description:
 *      Gets the list of DirectSound objects in the current process
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *		GUID guiDevice [in]: Device to get list for, or GUID_NULL for all.
 *      DSPROPERTY_DIRECTSOUND_OBJECTS_DATA [in/out]: Pointer to place
 *							  newly allocated memory containing list.
 *							  Free the memory with a delete [] 
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDirectSoundObjects
(
	LPKSPROPERTYSET						pKsPropertySet,
	GUID								guidDevice,
	DSPROPERTY_DIRECTSOUND_OBJECTS_DATA **pDSObjects
)
{
    HRESULT hr;
    ULONG ulSize;
    DSPROPERTY_DIRECTSOUND_OBJECTS_DATA* pDsObjList;
    DWORD dwNumObjects;

  	*pDSObjects = NULL;    

    pDsObjList = (DSPROPERTY_DIRECTSOUND_OBJECTS_DATA *) new DSPROPERTY_DIRECTSOUND_OBJECTS_DATA;

    if( pDsObjList == NULL )
    {
    	return E_OUTOFMEMORY;
    }

    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUND_OBJECTS_DATA ) );
    pDsObjList->DeviceId = guidDevice;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSound,
            DSPROPERTY_DIRECTSOUND_OBJECTS,
            NULL,
            0,
            pDsObjList,
            sizeof( DSPROPERTY_DIRECTSOUND_OBJECTS_DATA ),
            NULL
        );

	dwNumObjects = pDsObjList->Count;



    if(SUCCEEDED(hr))
    {
    	if( dwNumObjects > 0 )
    	{	
    		delete pDsObjList;
			pDsObjList = NULL;
			
		    ulSize = sizeof(DSPROPERTY_DIRECTSOUND_OBJECTS_DATA) + (dwNumObjects * sizeof(DIRECTSOUND_INFO));

		    pDsObjList = (DSPROPERTY_DIRECTSOUND_OBJECTS_DATA *) new BYTE[ulSize];

		    if( pDsObjList == NULL )
		    {
		    	return E_OUTOFMEMORY;
		    }

		    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUND_OBJECTS_DATA ) );
		    pDsObjList->DeviceId = guidDevice;	    

	    	hr =
		        pKsPropertySet->Get
		        (
		            DSPROPSETID_DirectSound,
		            DSPROPERTY_DIRECTSOUND_OBJECTS,
		            NULL,
		            0,
		            pDsObjList,
		            ulSize,
		            NULL
		        );

		    if( FAILED( hr ) )
		    {
		    	delete [] pDsObjList;
		    	return hr;
		    }
		}

		*pDSObjects = pDsObjList;	    
    }
    else
    {
		delete pDsObjList;
		pDsObjList = NULL;    
    	*pDSObjects = NULL;
    }

    return hr;
}

/***************************************************************************
 *
 *  PrvGetDirectSoundCaptureObjects
 *
 *  Description:
 *      Gets the list of DirectSoundCapture objects in the current process
 *
 *  Arguments:
 *      LPKSPROPERTYSET [in]: IKsPropertySet interface to the
 *                            DirectSoundPrivate object.
 *		GUID guiDevice [in]: Device to get list for, or GUID_NULL for all.
 *      DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA [in/out]: Pointer to place
 *							  newly allocated memory containing list.
 *							  Free the memory with a delete [] 
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT PrvGetDirectSoundCaptureObjects
(
	LPKSPROPERTYSET						pKsPropertySet,
	GUID								guidDevice,
	DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA **pDSObjects
)
{
    HRESULT hr;
    ULONG ulSize;
    DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA* pDsObjList;
    DWORD dwNumObjects;

  	*pDSObjects = NULL;    

    pDsObjList = (DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA *) new DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA;

    if( pDsObjList == NULL )
    {
    	return E_OUTOFMEMORY;
    }

    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA ) );
    pDsObjList->DeviceId = guidDevice;

    hr =
        pKsPropertySet->Get
        (
            DSPROPSETID_DirectSound,
            DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS,
            NULL,
            0,
            pDsObjList,
            sizeof( DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA ),
            NULL
        );

	dwNumObjects = pDsObjList->Count;

    if(SUCCEEDED(hr))
    {
    	if( dwNumObjects > 0 )
    	{

			delete [] pDsObjList;
			pDsObjList = NULL;
    	
		    ulSize = sizeof(DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA) + (dwNumObjects * sizeof(DIRECTSOUNDCAPTURE_INFO));

		    pDsObjList = (DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA *) new BYTE[ulSize];

		    if( pDsObjList == NULL )
		    {
		    	return E_OUTOFMEMORY;
		    }

		    memset( pDsObjList, 0x00, sizeof( DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA ) );
		    pDsObjList->DeviceId = guidDevice;	    

	    	hr =
		        pKsPropertySet->Get
		        (
		            DSPROPSETID_DirectSound,
		            DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS,
		            NULL,
		            0,
		            pDsObjList,
		            ulSize,
		            NULL
		        );

		    if( FAILED( hr ) )
		    {
		    	delete [] pDsObjList;
		    	return hr;
		    }
		}

		*pDSObjects = pDsObjList;	    
    }
    else
    {
		delete pDsObjList;
    	*pDSObjects = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsprvobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.h
 *  Content:    DirectSound Private Object wrapper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/12/98    dereks  Created.
 *  12/16/99	rodtoll	Added support for new funcs from dsound team on private
 *						interface for getting process dsound object list
 *  01/08/2001	rodtoll WINBUG #256541	Pseudo: Loss of functionality: Voice Wizrd can't be launched.
 * 
 *
 ***************************************************************************/

#ifndef __DSPRVOBJ_H__
#define __DSPRVOBJ_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

HRESULT DirectSoundPrivateCreate
(
    LPKSPROPERTYSET *   ppKsPropertySet
);

HRESULT PrvGetMixerSrcQuality
(
    LPKSPROPERTYSET                 pKsPropertySet,
    REFGUID                         guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY *   pSrcQuality
);

HRESULT PrvSetMixerSrcQuality
(
    LPKSPROPERTYSET             pKsPropertySet,
    REFGUID                     guidDeviceId,
    DIRECTSOUNDMIXER_SRCQUALITY SrcQuality
);

HRESULT PrvGetMixerAcceleration
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPDWORD         pdwAcceleration
);

HRESULT PrvSetMixerAcceleration
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    DWORD           dwAcceleration
);

HRESULT PrvGetDevicePresence
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPBOOL          pfEnabled
);

HRESULT PrvSetDevicePresence
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    BOOL            fEnabled
);

HRESULT PrvGetWaveDeviceMapping
(
    LPKSPROPERTYSET pKsPropertySet,
    LPCTSTR         pszWaveDevice,
    BOOL            fCapture,
    LPGUID          pguidDeviceId
);

HRESULT PrvGetWaveDeviceMappingW
(
    LPKSPROPERTYSET pKsPropertySet,
    LPWSTR          pwszWaveDevice,
    BOOL            fCapture,
    LPGUID          pguidDeviceId
);

HRESULT PrvGetDeviceDescription
(
    LPKSPROPERTYSET                                 pKsPropertySet,
    REFGUID                                         guidDeviceId,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA *ppData
);

HRESULT PrvEnumerateDevices
(
    LPKSPROPERTYSET                         pKsPropertySet,
    LPFNDIRECTSOUNDDEVICEENUMERATECALLBACK  pfnCallback,
    LPVOID                                  pvContext
);

HRESULT PrvGetBasicAcceleration
(
    LPKSPROPERTYSET                         pKsPropertySet,
    REFGUID                                 guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL *    pLevel
);

HRESULT PrvSetBasicAcceleration
(
    LPKSPROPERTYSET                     pKsPropertySet,
    REFGUID                             guidDeviceId,
    DIRECTSOUNDBASICACCELERATION_LEVEL  Level
);

HRESULT PrvGetDebugInformation
(
    LPKSPROPERTYSET pKsPropertySet,
    LPDWORD         pdwFlags,
    PULONG          pulDpfLevel,
    PULONG          pulBreakLevel,
    LPTSTR          pszLogFile
);

HRESULT PrvSetDebugInformation
(
    LPKSPROPERTYSET pKsPropertySet,
    DWORD           dwFlags,
    ULONG           ulDpfLevel,
    ULONG           ulBreakLevel,
    LPCTSTR         pszLogFile
);

HRESULT PrvGetPersistentData
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPCTSTR         pszSubkey,
    LPCTSTR         pszValue,
    LPDWORD         pdwRegType,
    LPVOID          pvData,
    LPDWORD         pcbData
);

HRESULT PrvSetPersistentData
(
    LPKSPROPERTYSET pKsPropertySet,
    REFGUID         guidDeviceId,
    LPCTSTR         pszSubkey,
    LPCTSTR         pszValue,
    DWORD           dwRegType,
    LPVOID          pvData,
    DWORD           cbData
);

HRESULT PrvTranslateResultCode
(
    LPKSPROPERTYSET                                         pKsPropertySet,
    HRESULT                                                 hrResult,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_DATA * ppData
);

HRESULT PrvGetDirectSoundObjects
(
	LPKSPROPERTYSET						pKsPropertySet,
	GUID								guidDevice,
	DSPROPERTY_DIRECTSOUND_OBJECTS_DATA **ppDSObjects
);

HRESULT PrvGetDirectSoundCaptureObjects
(
	LPKSPROPERTYSET								pKsPropertySet,
	GUID										guidDevice,	
	DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA 	**ppDSCObjects
);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSPRVOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dsutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dsutils.h
 *  Content:	declares general DirectSound utils, particularly error stuff
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 07/16/99		rodtoll	Created
 *
 ***************************************************************************/

#ifndef __DIRECTSOUNDUTILS_H
#define __DIRECTSOUNDUTILS_H


// DirectXException
//
// This class is the exception class for handling exceptions from
// errors from DirectSound.  It is used by the DSCHECK macro to
// check return codes from DirectSound calls.
//
// It provides an implementation of the DirectXException and
// provides mapping from HRESULTs to string descriptions of
// directsound errors.
//
class DirectSoundException: public DirectXException
{
public:
    DirectSoundException( 
        const TCHAR *funcName, HRESULT result, 
        const unsigned int moduleID = 0, unsigned int lineNumber = 0 
    ): DirectXException( funcName, result, moduleID, lineNumber ) 
    {
        MapResultToString();
    };
protected:
    void MapResultToString();
};

// DSCHECK MACRO
//
// This macro is used to check the return codes from DirectSound calls.  If 
// the directsound call does not return a DS_OK, a DirectSoundException exception
// is created and thrown.
//
#define DSCHECK(x) if( x != DS_OK ) { throw DirectSoundException( "", x, 0, __LINE__ ); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dvcdb.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvcdb.h
 *  Content:	structures, data types and functions for the
 *				compression subsystem
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 08/23/99		rodtoll	Created
 * 09/08/99		rodtoll	Moved the dwMaxBitsPerSecond field to the DVCOMPRESSIONINFO struct
 * 10/07/99		rodtoll	Updated to work in Unicode 
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 *
 ***************************************************************************/

#ifndef __DVCDB_H
#define __DVCDB_H

HRESULT DVCDB_LoadCompressionInfo(const WCHAR *swzBaseRegistryPath );
HRESULT DVCDB_FreeCompressionInfo();

HRESULT CREG_ReadAndAllocWaveFormatEx( HKEY hkeyReg, const LPWSTR path, LPWAVEFORMATEX *lpwfxFormat );
HRESULT DVCDB_GetCompressionInfo( GUID guidType, PDVFULLCOMPRESSIONINFO *lpdvfCompressionInfo );
HRESULT DVCDB_IsValidCompressionType( GUID guidType );

HRESULT DVCDB_CreateConverter( GUID guidSrc, WAVEFORMATEX *pwfxTarget, PDPVCOMPRESSOR *pConverter );
HRESULT DVCDB_CreateConverter( WAVEFORMATEX *pwfxSrcFormat, GUID guidTarget, PDPVCOMPRESSOR *pConverter );
DWORD DVCDB_CalcUnCompressedFrameSize( LPDVFULLCOMPRESSIONINFO lpdvInfo, LPWAVEFORMATEX lpwfxFormat );

HRESULT DVCDB_CopyCompressionArrayToBuffer( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags );
DWORD DVCDB_GetCompressionInfoSize( LPDVCOMPRESSIONINFO lpdvCompressionInfo );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dverror.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dverror.h
 *  Content:	Error string handling
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 01/21/2000	pnewson Created
 *
 ***************************************************************************/

#ifndef _DVERROR_H
#define _DVERROR_H

void DV_DisplayErrorBox(HRESULT hr, HWND hwndParent, UINT idsErrorMessage = 0);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dvoice\dxvutils\dvcdb.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dvcdb.cpp
 *  Content:	
 *			This module contains the implementation of the compression
 *			subsystem and the associated utility functions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 08/29/99		rodtoll	Created
 * 09/01/99		rodtoll	Updated to add checks for valid read/write pointers
 * 09/07/99		rodtoll	Removed bad assert and added dpf_modnames
 *					    Removed Create flag on registry opens
 * 09/10/99		rodtoll	dwFlags check on call to DVCDB_CopyCompress...
 * 09/14/99		rodtoll	Minor bugfix in compression info copy
 * 09/21/99		rodtoll	Added OSInd and fixed memory leak 
 * 10/07/99		rodtoll	Added stubs for supporting new codecs 
 *				rodtoll	Updated to use Unicode
 * 10/15/99		rodtoll	Plugged some memory leaks 
 * 10/28/99		rodtoll	Updated to use new compression providers
 * 10/29/99		rodtoll	Bug #113726 - Integrate Voxware Codecs, updating to use new
 *						pluggable codec architecture.     
 * 11/22/99		rodtoll	Removed false error message when loading compression types
 * 12/16/99		rodtoll	Removed asserts (which were not needed) exposed by compression
 *						provider changes.
 * 02/10/2000	rodtoll	Fixed crash if invalid registry entries are present.
 *  03/03/2000	rodtoll	Updated to handle alternative gamevoice build.   
 * 03/16/2000   rodtoll   Updated converter create to check and return error code
 * 04/21/2000   rodtoll Bug #32889 - Does not run on Win2k w/o Admin 
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *  06/28/2000	rodtoll	Prefix Bug #38022
 *  08/28/2000	masonb  Voice Merge: Removed OSAL_* and dvosal.h, added STR_* and strutils.h
 *  08/31/2000	rodtoll	Prefix Bug #171840
 * 10/05/2000	rodtoll	Bug #46541 - DPVOICE: A/V linking to dpvoice.lib could cause application to fail init and crash
 *
 ***************************************************************************/

#include "dxvutilspch.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE


struct DVCDBProvider
{
	GUID					guidClassID;
	PDVFULLCOMPRESSIONINFO	pInfo;
	DWORD					dwNumElements;
	DVCDBProvider			*pNext;
};

DVCDBProvider *g_dvcdbProviderList = NULL;

#define REGISTRY_CDB_FORMAT					L"Format"
#define REGISTRY_WAVEFORMAT_RATE			L"Rate"
#define REGISTRY_WAVEFORMAT_BITS			L"Bits"
#define REGISTRY_WAVEFORMAT_CHANNELS		L"Channels"
#define REGISTRY_WAVEFORMAT_TAG				L"Tag"
#define REGISTRY_WAVEFORMAT_AVGPERSEC		L"AvgPerSec"
#define REGISTRY_WAVEFORMAT_BLOCKALIGN		L"BlockAlign"
#define REGISTRY_WAVEFORMAT_CBSIZE			L"cbsize"
#define REGISTRY_WAVEFORMAT_CBDATA			L"cbdata"

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CalcUnCompressedFrameSize"
DWORD DVCDB_CalcUnCompressedFrameSize( LPDVFULLCOMPRESSIONINFO lpdvInfo, LPWAVEFORMATEX lpwfxFormat )
{
	DWORD frameSize;

    switch( lpwfxFormat->nSamplesPerSec )
    {
    case 8000:      frameSize = lpdvInfo->dwFrame8Khz;      break;
    case 11025:     frameSize = lpdvInfo->dwFrame11Khz;     break;
    case 22050:     frameSize = lpdvInfo->dwFrame22Khz;     break;
    case 44100:     frameSize = lpdvInfo->dwFrame44Khz;     break;
    default:        return 0;
    }

	if( lpwfxFormat->wBitsPerSample == 16 )
		frameSize *= 2;

	frameSize *= lpwfxFormat->nChannels;

	return frameSize;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CREG_ReadAndAllocWaveFormatEx"
HRESULT CREG_ReadAndAllocWaveFormatEx( HKEY hkeyReg, const LPWSTR path, LPWAVEFORMATEX *lpwfxFormat )
{
	CRegistry waveKey;

	if( !waveKey.Open( hkeyReg, path, TRUE, FALSE ) )
	{
		return E_FAIL; 
	}

	DWORD dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CBSIZE, dwTmp ) )
	{
		return E_FAIL;
	}

	*lpwfxFormat = (LPWAVEFORMATEX) new BYTE[dwTmp+sizeof(WAVEFORMATEX)];

	LPWAVEFORMATEX tmpFormat = *lpwfxFormat;

	if( tmpFormat == NULL )
	{
		return E_OUTOFMEMORY;
	}

	tmpFormat->cbSize = (BYTE) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_RATE, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->nSamplesPerSec = dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BITS, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->wBitsPerSample = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_CHANNELS, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->nChannels = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_TAG, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->wFormatTag = (WORD) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_AVGPERSEC, dwTmp ) )
	{
		goto READ_FAILURE;
	}

	tmpFormat->nAvgBytesPerSec = (INT) dwTmp;

	if( !waveKey.ReadDWORD( REGISTRY_WAVEFORMAT_BLOCKALIGN, dwTmp ) ) 
	{
		goto READ_FAILURE;
	}

	tmpFormat->nBlockAlign = (INT) dwTmp;

	dwTmp = tmpFormat->cbSize;

	if( !waveKey.ReadBlob( REGISTRY_WAVEFORMAT_CBDATA, (LPBYTE) &tmpFormat[1], &dwTmp ) )
	{
		DPFX(DPFPREP,  0, "Error reading waveformat blob" );
		goto READ_FAILURE;
	}

	return S_OK;

READ_FAILURE:

	delete [] *lpwfxFormat;
	*lpwfxFormat = NULL;

	return E_FAIL;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_LoadCompressionInfo"
HRESULT DVCDB_LoadCompressionInfo( const WCHAR *swzBaseRegistryPath )
{
	CRegistry mainKey, subKey;
	LPWSTR keyName = NULL;
	DWORD dwIndex = 0;
	DWORD dwSize = 0;
	HRESULT hr;
	PDPVCOMPRESSIONPROVIDER pCompressionProvider = NULL;	
	DVCDBProvider *pNewProvider = NULL;
	WCHAR wszPath[_MAX_PATH];

	if( swzBaseRegistryPath == NULL )
	{
		DPFX(DPFPREP,  0, "INTERNAL ERROR!" );
		return E_FAIL;
	}

	wcscpy( wszPath, swzBaseRegistryPath );
    wcscat( wszPath, DPVOICE_REGISTRY_CP );
	
	if( !mainKey.Open( HKEY_LOCAL_MACHINE, wszPath, TRUE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Error reading compression providers from the registry.  Path doesn't exist" );
		return E_FAIL;
	}

	dwIndex = 0;
	keyName = NULL;
	dwSize = 0;
	LPSTR lpstrKeyName = NULL;
	GUID guidCP;

	// Enumerate the subkeys at this point in the tree
	while( 1 )
	{
		dwSize = 0;

		if( !mainKey.EnumKeys( keyName, &dwSize, dwIndex ) )
		{
			if( dwSize == 0 )
			{
				DPFX(DPFPREP,  DVF_INFOLEVEL, "End of provider list" );
				break;
			}

			if( keyName != NULL )
			{
				delete [] keyName;
			}

			keyName = new wchar_t[dwSize];
		}

		if( !mainKey.EnumKeys( keyName, &dwSize, dwIndex ) )
		{
			delete [] keyName;
			break;
		}

		if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error allocating memory" );
			break;
		}

		DPFX(DPFPREP,  DVF_INFOLEVEL, "Reading provider: %s", lpstrKeyName );

		if( !subKey.Open( mainKey, keyName, TRUE, FALSE ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error reading provider: %s", lpstrKeyName );
			goto SKIP_TO_NEXT;
		}

		delete [] keyName;
		keyName = NULL;
		dwSize = 0;

		// Read the GUID from the default key
		if( !subKey.ReadGUID( L"", guidCP ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to read the provider's GUID" );
			goto SKIP_TO_NEXT;
		}

		// Attempt to create the provider
		hr = COM_CoCreateInstance( guidCP , NULL, CLSCTX_INPROC_SERVER, IID_IDPVCompressionProvider, (void **) &pCompressionProvider );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "FAILED to create 0x%x\n", hr );	
			goto SKIP_TO_NEXT;
		} 

		// Build a record for the provider
		pNewProvider = new DVCDBProvider;

		if( pNewProvider == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
			goto SKIP_TO_NEXT;
		}
		
		pNewProvider->guidClassID = guidCP;
		pNewProvider->pInfo = NULL;
		pNewProvider->dwNumElements = 0;
		dwSize = 0;

		// GetCompression Info for the provider
		hr = pCompressionProvider->EnumCompressionTypes( pNewProvider->pInfo, &dwSize, &pNewProvider->dwNumElements, 0 );

		if( hr != DVERR_BUFFERTOOSMALL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get compression info for provider: %s", lpstrKeyName );
			goto SKIP_TO_NEXT;
		}

		pNewProvider->pInfo = (DVFULLCOMPRESSIONINFO *) new BYTE[dwSize];

		if( pNewProvider->pInfo == NULL )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Out of memory" );
			goto SKIP_TO_NEXT;
		}

		hr = pCompressionProvider->EnumCompressionTypes( pNewProvider->pInfo, &dwSize, &pNewProvider->dwNumElements, 0 );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP,  DVF_ERRORLEVEL, "Unable to get compression info for %s hr=0x%x", lpstrKeyName, hr );
			goto SKIP_TO_NEXT;
		}

		// Add it to the list
		pNewProvider->pNext = g_dvcdbProviderList;
		g_dvcdbProviderList = pNewProvider;

		pNewProvider = NULL;
		

	SKIP_TO_NEXT:

		if( pCompressionProvider != NULL )
		{
			pCompressionProvider->Release();
			pCompressionProvider = NULL;
		}

		if( pNewProvider != NULL )
		{
			delete pNewProvider;
			pNewProvider = NULL;
		}

		if( lpstrKeyName != NULL )
			delete [] lpstrKeyName;

		if( keyName != NULL )
			delete [] keyName;	
		lpstrKeyName = NULL;
		keyName = NULL;
		dwSize = 0;

		dwIndex++;

		continue;
	}

	if( lpstrKeyName != NULL )
		delete [] lpstrKeyName;

	if( keyName != NULL )
		delete [] keyName;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_FreeCompressionInfo"
HRESULT DVCDB_FreeCompressionInfo()
{
	DVCDBProvider *pTmpProvider, *pTmpNext;

	if( g_dvcdbProviderList == NULL )
		return DV_OK;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		pTmpNext = pTmpProvider->pNext;

		delete [] pTmpProvider->pInfo;
		delete pTmpProvider;
	
		pTmpProvider = pTmpNext;
	}

	g_dvcdbProviderList = NULL;

	return DV_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_GetCompressionClassID"
HRESULT DVCDB_GetCompressionClassID( GUID guidCT, GUID &guidClass )
{
	DVCDBProvider *pTmpProvider;
	DWORD dwIndex;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		for( dwIndex = 0; dwIndex < pTmpProvider->dwNumElements; dwIndex++ )
		{
			if( pTmpProvider->pInfo[dwIndex].guidType == guidCT )
			{
				guidClass = pTmpProvider->guidClassID;
				return DV_OK;
			}
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}

	return DVERR_COMPRESSIONNOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_GetCompressionInfo"
HRESULT DVCDB_GetCompressionInfo( GUID guidType, PDVFULLCOMPRESSIONINFO *lpdvfCompressionInfo )
{
	DVCDBProvider *pTmpProvider;
	DWORD dwIndex;

	pTmpProvider = g_dvcdbProviderList;

	while( pTmpProvider != NULL )
	{
		for( dwIndex = 0; dwIndex < pTmpProvider->dwNumElements; dwIndex++ )
		{
			if( pTmpProvider->pInfo[dwIndex].guidType == guidType )
			{
				*lpdvfCompressionInfo = &pTmpProvider->pInfo[dwIndex];
				return DV_OK;
			}
		}
		
		pTmpProvider = pTmpProvider->pNext;
	}

	return DVERR_COMPRESSIONNOTSUPPORTED;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_IsValidCompressionType"
HRESULT DVCDB_IsValidCompressionType( GUID guidCT )
{
	GUID guidDummy;
	
	return DVCDB_GetCompressionClassID( guidCT, guidDummy );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CreateConverter"
HRESULT DVCDB_CreateConverter( WAVEFORMATEX *pwfxSrcFormat, GUID guidTarget, PDPVCOMPRESSOR *pConverter )
{
	HRESULT hr;
	GUID guidProvider;
	PDPVCOMPRESSIONPROVIDER pCompressionProvider = NULL;	

	hr = DVCDB_GetCompressionClassID( guidTarget, guidProvider );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Requested compression type is not supported, hr=0x%x", hr );
		return hr;
	}
	
	hr = COM_CoCreateInstance( guidProvider , NULL, CLSCTX_INPROC_SERVER, IID_IDPVCompressionProvider, (void **) &pCompressionProvider );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "FAILED to create 0x%x\n", hr );	
		return DVERR_COMPRESSIONNOTSUPPORTED;
	} 

	hr = pCompressionProvider->CreateCompressor( pwfxSrcFormat, guidTarget, pConverter, 0 );

	if( FAILED( hr ) )
	{
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating compressor hr=0x%x", hr );
	    return hr;
	}

	pCompressionProvider->Release();

	return hr;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CreateConverter"
HRESULT DVCDB_CreateConverter( GUID guidSrc, WAVEFORMATEX *pwfxTarget, PDPVCOMPRESSOR *pConverter )
{
	HRESULT hr;
	GUID guidProvider;
	PDPVCOMPRESSIONPROVIDER pCompressionProvider = NULL;	

	hr = DVCDB_GetCompressionClassID( guidSrc, guidProvider );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "Requested compression type is not supported, hr=0x%x", hr );
		return hr;
	}
	
	hr = COM_CoCreateInstance( guidProvider , NULL, CLSCTX_INPROC_SERVER, IID_IDPVCompressionProvider, (void **) &pCompressionProvider );

	if( FAILED( hr ) )
	{
		DPFX(DPFPREP,  DVF_ERRORLEVEL, "FAILED to create 0x%x\n", hr );	
		return DVERR_COMPRESSIONNOTSUPPORTED;
	} 

	hr = pCompressionProvider->CreateDeCompressor( guidSrc, pwfxTarget, pConverter, 0 );

    if( FAILED( hr ) )
    {
	    DPFX(DPFPREP,  DVF_ERRORLEVEL, "Error creating compressor hr=0x%x", hr );
	    return hr;
    }
    
	pCompressionProvider->Release();

	return DV_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DVCDB_CopyCompressionArrayToBuffer"
HRESULT DVCDB_CopyCompressionArrayToBuffer( LPVOID lpBuffer, LPDWORD lpdwSize, LPDWORD lpdwNumElements, DWORD dwFlags )
{
	if( lpdwNumElements == NULL || lpdwSize == NULL ||
	    !DNVALID_READPTR(lpdwNumElements,sizeof(DWORD)) ||
	    !DNVALID_RE